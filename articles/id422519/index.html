<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘“ ğŸ•˜ ğŸ‘©ğŸ¿â€ğŸ’» Distribusi Freebie: Thread Non-Pengereman di Jawa. Proyek tenun ğŸ§  ğŸ® ğŸ‘¨ğŸ¾â€ğŸ­</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apakah Anda ingin di utas java yang tidak memakan memori seolah-olah mereka tidak sendiri dan tidak memperlambat? Penghargaan bagus, dan masalah ini m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Distribusi Freebie: Thread Non-Pengereman di Jawa. Proyek tenun</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422519/"><p>  Apakah Anda ingin di utas java yang tidak memakan memori seolah-olah mereka tidak sendiri dan tidak memperlambat?  Penghargaan bagus, dan masalah ini menjawab pertanyaan ini. </p><br><p>  Kami menjelaskan pekerjaan Project Loom pada kotak pizza!  Ayo! </p><br><p>  Semua ini dihapus dan ditulis <b>khusus untuk Habr</b> . </p><br><br><p><br clear="all"></p><a name="habracut"></a><br><h1 id="pozyvnye">  Tanda panggilan </h1><br><p>  Seberapa sering Anda melihat gambar ini di layanan web Anda: pada awalnya semuanya baik-baik saja, lalu satu juta orang Cina mendatangi Anda, layanan membuat sejuta benang dan tenggelam di neraka? </p><br><p><img src="https://habrastorage.org/webt/ym/_-/3r/ym_-3rq8a8g56hsmrvjhprnih8y.png"><br><br></p><br><p>  Apakah Anda ingin gambar yang bagus? </p><br><p><img src="https://habrastorage.org/webt/38/s-/04/38s-04z5nak6trs_p2lei9chjku.png"><br><br></p><br><p>  Dengan kata lain, apakah Anda ingin di utas java yang tidak memakan memori tetapi tidak dalam diri mereka sendiri dan tidak memperlambat?  Penghargaan bagus, dan masalah ini menjawab pertanyaan ini. </p><br><p>  Kami akan terlibat, pada kenyataannya, <em>membongkar kerangka baru</em> .  Ingat bagaimana Wylsacom membongkar iPhone?  Beberapa sudah tidak ingat pengulas lama, tetapi mengapa?  Karena Habr adalah benteng utama, dan video berbayar, maaf, adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sinar diare</a> .  Dalam posting ini kita akan membahas secara eksklusif dengan teknis hardcore. </p><br><p>  Pertama, dua menit ke bola mata, penafian dan sampah lainnya, yang harus dikatakan.  Anda dapat melewatkannya jika Anda terlalu malas. </p><br><p>  Pertama-tama, semua yang dikatakan dalam video adalah pikiran pribadi saya, dan itu tidak ada hubungannya dengan majikan atau perusahaan Oracle yang mulia, pemerintah dunia kadal dan hal-hal terkutuk dalam mortir.  Saya bahkan menulis ini pada jam tiga pagi sehingga jelas bahwa ini adalah inisiatif pribadi saya, sampah pribadi saya.  <em>Semua pertandingan murni acak.</em> </p><br><p>  Tetapi ada tujuan bonus lain.  Kami terus-menerus berbicara tentang coroutine di Kotlin.  Baru-baru ini ada wawancara dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Roma Elizarov</a> , dewa Corutin, dan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pasha Finkelstein</a> , yang akan menulis backend pada mereka.  Segera akan ada wawancara dengan Andrei Breslav - yang merupakan ayah dari Kotlin.  Dan di mana-mana proyek Loom disebutkan satu atau lain cara, karena itu adalah analog dari coroutine.  Dan jika Anda tidak tahu apa itu Loom, Anda mungkin menjadi bodoh ketika membaca wawancara ini.  Ada beberapa cowok keren, mereka membahas hal keren.  Dan di sanalah Anda, dan Anda tidak bersama mereka, Anda bodoh.  Ini sangat bodoh. </p><br><p>  Jangan lakukan ini, baca apa yang ada dalam artikel ini, atau tonton video ini lebih lanjut, saya akan menjelaskan semuanya. </p><br><p>  Jadi, apa komplikasinya.  Ada pria seperti itu, Ron Presler. </p><br><br><p><img src="https://habrastorage.org/webt/w-/tq/ut/w-tqutfyx33olnhdavtq_asdv9u.png"><br><br></p><br><p>  Tahun lalu, ia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pergi ke mailing list</a> , mengatakan bahwa utas di Jawa payah, dan menyarankan agar ia menjalankan runtime dan memperbaikinya.  Dan semua orang akan menertawakannya dan melempar batu, sial, kalau bukan karena fakta bahwa dia menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quasar</a> sebelumnya, dan ini sebenarnya sangat keren.  Anda bisa bersumpah di Quasar untuk waktu yang lama, tetapi tampaknya ada di sana dan itu bekerja, dan dalam gambaran besar dari semua ini lebih mungkin sebuah pencapaian. </p><br><p>  Ada banyak pemerintahan yang tidak melakukan apa-apa, katakan saja.  Baiklah, lakukan dengan benar, saya sama.  Atau ada orang yang tampaknya insinyur keren, tetapi secara umum di alam bawah sadar, mereka mengatakan ini: "Di Jawa, Anda perlu meningkatkan utas."  Apa yang harus ditingkatkan?  Apa itu utas? </p><br><p>  Orang pada umumnya terlalu malas untuk berpikir. </p><br><p>  Seperti dalam lelucon: <br>  Petka dan Vasily Ivanovich terbang di pesawat. <br>  Dengan mudah Ivanovich bertanya: - Petka, perangkat? <br>  Balasan Petka: - 200! <br>  Vasily Ivanovich: - Dan bagaimana dengan 200? <br>  Petka: - Bagaimana dengan peralatan? </p><br><p>  Saya akan menceritakan sebuah kisah.  Saya berada di Ukraina musim semi ini, kami terbang dari Belarus (Anda mengerti mengapa itu tidak mungkin langsung dari St. Petersburg).  Dan di bea cukai kami duduk selama sekitar dua jam, tidak kurang.  Petugas bea cukai sangat baik, dalam semua keseriusannya bertanya apakah Jawa adalah teknologi yang usang.  Orang-orang yang duduk di dekatnya yang terbang ke konf yang sama.  Dan saya adalah tipe pembicara, saya harus menyodok, berdiri dan, seperti yang diharapkan, tanpa malu-malu berbicara tentang hal-hal yang tidak saya gunakan sama sekali.  Dan sepanjang jalan dia berbicara tentang distribusi JDK yang disebut Liberica, ini adalah JDK untuk Raspberry Pi. </p><br><p>  Dan bagaimana menurutmu.  Bahkan enam bulan berlalu sebelum orang-orang mengetuk gerobak saya dan mengatakan bahwa, lihat, kami telah meletakkan solusi di Liber pada prod, dan saya sudah memiliki laporan tentang ini di jfuture.by konf Belarusia.  Inilah pendekatannya.  Ini bukan penginjil yang buruk, tetapi seorang pria, seorang insinyur normal. </p><br><blockquote>  Ngomong-ngomong, kita akan segera mengadakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konferensi Joker 2018</a> , yang akan mencakup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Andrei Breslav</a> (jelas-jelas mengobrak-abrik coroutine), dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pasha Finkelstein</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Josh Long</a> dapat ditanya tentang dukungan Spring's Loom.  Nah, dan sekelompok ahli terkemuka yang keren, ayolah! </blockquote><p>  Dan sekarang, kembali ke utas.  Orang-orang mencoba menggambar pikiran melalui dua neuron mereka yang telah terdegradasi, mereka mengendus-endus dengan kepalan tangan mereka, dan bergumam: "Thread tidak begitu di Jawa, thread tidak begitu di Jawa."  Perangkat!  Peralatan apa?  Ini umumnya neraka. </p><br><p>  Dan inilah Presler, seorang lelaki yang normal, tidak terdegradasi, dan pada awalnya ia membuat deskripsi yang waras.  Setahun kemudian, menggergaji demo yang berfungsi.  Saya mengatakan semua ini sehingga Anda mengerti bahwa deskripsi masalah yang normal, dokumentasi normal adalah kepahlawanan dari jenis khusus.  Dan demo umumnya ruang.  Ini adalah orang pertama yang benar-benar melakukan sesuatu ke arah ini.  Dia sangat membutuhkan. </p><br><p>  Bersama dengan demo, Presler berbicara di konferensi dan merilis video ini: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/J31o0ZMQEnI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Bahkan, seluruh artikel ini adalah ulasan tentang apa yang dikatakan di sana.  Saya tidak berpura-pura sama sekali atas keunikan materi ini, semua yang ada di artikel ini ditemukan oleh Ron. </p><br><p>  Diskusi ini tentang tiga topik yang menyakitkan: </p><br><ul><li>  Kontinasi </li><li>  Serat </li><li>  Buntut panggilan </li></ul><br><p>  Mungkin, dia sangat muak dengan melihat Quasar dan bertarung dengan gangguannya sehingga tidak ada kekuatan - kamu harus mendorongnya menjadi runtime. </p><br><p>  Itu setahun yang lalu, dan sejak itu mereka menggergaji sebuah prototipe.  Beberapa sudah kehilangan harapan bahwa suatu hari nanti kita akan melihat demo, tetapi sebulan yang lalu mereka melahirkannya dan menunjukkan apa yang terlihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di tweet ini</a> . </p><br><br><p><img src="https://habrastorage.org/webt/ck/hp/mc/ckhpmcchdv2k6_4vfbw733evg6c.png"><br><br></p><br><p>  Ketiga topik yang menyakitkan dalam demo ini baik secara langsung dalam kode, atau setidaknya secara moral hadir.  Ya, mereka belum menguasai panggilan ekor, tapi mereka mau. </p><br><h1 id="problematika">  Masalah </h1><br><p>  Pengguna yang tidak bahagia, pengembang aplikasi, ketika mereka membuat API, dipaksa untuk memilih di antara dua kursi.  Puncak dibangun di atas satu kursi, bunga tumbuh di kursi lainnya.  Dan tidak ada yang cocok dengan kita. </p><br><br><p><img src="https://habrastorage.org/webt/tn/nx/k-/tnnxk-iwzuj7sybfwllour9qozq.png"><br><br></p><br><p>  Misalnya, jika Anda menulis layanan yang bekerja secara serempak, itu berfungsi dengan baik dengan kode lawas, mudah untuk debug dan memantau kinerja.  Masalah akan muncul dengan bandwidth dan skalabilitas.  Hanya karena jumlah utas yang sekarang dapat Anda jalankan di perangkat sederhana, pada perangkat keras komoditas - yah, katakanlah, dua ribu.  Ini jauh lebih sedikit daripada jumlah koneksi yang bisa dibuka ke server ini.  Yang dari sudut pandang netcode bisa hampir tak ada habisnya. </p><br><p>  (Ya, ya, ini ada hubungannya dengan fakta bahwa soket di Jawa diatur secara moral, tetapi ini adalah topik untuk percakapan lain) </p><br><p>  Bayangkan Anda sedang menulis semacam MMO. </p><br><br><p><img src="https://habrastorage.org/webt/ye/mg/pm/yemgpm6on0pidozkhmco3epwapa.png"><br><br></p><br><p>  Sebagai contoh, selama Perang Utara di EVE Online, dua ribu empat ratus pilot berkumpul pada satu titik di angkasa, masing-masing - secara kondisional, apakah itu ditulis di Jawa - bukan hanya satu utas, tetapi beberapa.  Dan pilot, tentu saja, adalah logika bisnis yang kompleks, dan bukan penerbitan HTML apa pun yang dapat dikesampingkan dengan tangan di kaca pembesar. </p><br><p>  Waktu respons dalam pertempuran itu begitu lama sehingga pemain harus menunggu beberapa menit untuk menunggu tembakan.  Sejauh yang saya tahu, PKC khusus untuk pertempuran itu melemparkan sumber daya perangkat keras yang sangat besar dari klusternya. </p><br><p>  Meskipun, saya mungkin mengutip EVE sebagai contoh dengan sia-sia, karena, sejauh yang saya mengerti, semuanya ditulis dalam Python, dan dalam Python dengan multithreading masih lebih buruk daripada kita - dan kita dapat mempertimbangkan persaingan fitur fitur bahasa yang buruk.  Tapi kemudian contohnya jelas dan dengan gambar. </p><br><p>  Jika Anda tertarik pada subjek IMO secara umum dan sejarah "Perang Utara" khususnya, baru-baru ini sebuah video yang sangat bagus tentang topik ini telah muncul di saluran Bulzhat (apa pun nama itu berarti), tonton dari stempel waktu saya. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AkAtiTNvjz8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Kami kembali ke topik. </p><br><p>  Di sisi lain, Anda dapat menggunakan semacam kerangka asinkron.  Itu scalable.  Tetapi kami akan segera jatuh ke dalam debugging yang sangat sulit, profiling kinerja yang rumit, kami tidak akan dapat mengintegrasikannya secara mulus dengan warisan, Anda harus menulis ulang banyak hal, membungkusnya dengan pembungkus yang buruk, dan umumnya merasa seperti kami baru saja diperkosa.  Beberapa kali berturut-turut.  Selama berhari-hari, pada kenyataannya, sepanjang waktu kami menulis ini, Anda harus merasa seperti itu. </p><br><p>  Saya bertanya kepada pakar, akademisi terkenal Escobar, apa pendapatnya tentang ini: </p><br><br><p><img width="300" src="https://habrastorage.org/webt/7g/hf/mg/7ghfmg3x8aqhdl0jcyrbpairqsc.png"><br><br></p><br><p>  Apa yang harus dilakukan  Yang disebut faybers bergegas untuk menyelamatkan. </p><br><p>  Dalam kasus umum, serat adalah benang yang sangat ringan yang juga menggeledah ruang alamat (karena keajaiban tidak terjadi, Anda mengerti).  Tetapi tidak seperti utas biasa, mereka tidak menggunakan multitasking preemptive, tetapi multitasking kooperatif.  Baca lebih lanjut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Wikipedia</a> . </p><br><p>  Fiber dapat mewujudkan keunggulan pemrograman sinkron dan asinkron.  Akibatnya, pemanfaatan besi meningkat, dan kami menggunakan lebih sedikit server di gugus untuk tugas yang sama.  Nah, di saku kita untuk ini kita mendapatkan lavender.  Babos  Lave.  Uang  Nah, Anda mengerti intinya.  Untuk server yang disimpan. </p><br><h1 id="na-raspute">  Di persimpangan jalan </h1><br><p>  Hal pertama yang ingin saya diskusikan.  Orang tidak mengerti perbedaan antara kelanjutan dan serat. <br>  Sekarang akan ada pencerahan Kultus! </p><br><p>  Kami akan mengumumkan fakta: Kelanjutan dan Serat adalah dua hal yang berbeda. </p><br><h1 id="continuations">  Lanjutan </h1><br><p>  Serat dibangun di atas mekanik yang disebut Lanjutan. </p><br><p>  Lanjutan (lebih tepatnya, lanjutan terbatas) adalah semacam perhitungan, eksekusi, bagian dari program yang dapat tertidur, lalu bangun dan melanjutkan eksekusi dari tempat ia tertidur.  Kadang-kadang bahkan bisa dikloning atau serial, bahkan ketika dia sedang tidur. </p><br><p>  Saya akan menggunakan kata "kelanjutan", dan bukan "kelanjutan" (seperti yang tertulis di Wikipedia), karena kita semua berkomunikasi dalam <em>bahasa Inggris</em> .  Dengan menggunakan terminologi Rusia yang normal, seseorang dapat dengan mudah sampai pada situasi di mana perbedaan antara istilah Rusia dan Inggris menjadi terlalu besar dan tidak ada orang lain yang mengerti arti dari apa yang dikatakan. </p><br><p>  Kadang-kadang saya juga akan menggunakan kata "crowding out" alih-alih versi bahasa Inggris "yield".  Hanya kata "hasil" - ini semacam benar-benar jahat.  Karena itu akan ada â€œcrowding outâ€. </p><br><p>  Jadi disini.  Sangat penting bahwa tidak boleh ada persaingan dalam kontinum.  Itu sendiri adalah primitif minimal dari proses ini. </p><br><p> Anda dapat menganggap kelanjutan sebagai <code>Runnable</code> , di dalamnya Anda dapat memanggil metode <code>pause()</code> .  Itu ada di dalam dan langsung, karena multitasking kami kooperatif.  Dan kemudian Anda dapat menjalankannya lagi, dan alih-alih menghitung ulang semuanya, ia akan melanjutkan dari tempat ia tinggalkan.  Sihir semacam itu.  Kami akan kembali ke sihir. </p><br><p>  Di mana mendapatkan demo dengan kelanjutan kerja - kita akan membahas di bagian paling akhir.  Sekarang mari kita bicara tentang apa yang ada di sana. </p><br><p>  Kelas kelanjutan itu sendiri terletak di java.base, semua tautan akan ada dalam deskripsi.  ( <code>src/java.base/share/classes/java/lang/Continuation.java</code> ).  Tetapi kelas ini sangat besar, banyak, sehingga masuk akal untuk melihat hanya semacam tekanan dari itu. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Continuation</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Continuation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContinuationScope scope, Runnable body)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yield</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ContinuationScope scope)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isDone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPinned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Reason reason)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"Pinned: "</span></span> + reason); } }</code> </pre> <br><p>  Perhatikan bahwa sebenarnya file ini terus berubah.  Misalnya, pada hari sebelumnya, kelanjutan tidak mengimplementasikan antarmuka <code>Runnable</code> .  Perlakukan ini sebagai semacam sketsa. </p><br><p>  Lihatlah konstruktornya.  <code>body</code> - ini adalah kode yang Anda coba jalankan, dan <code>scope</code> - adalah semacam lompatan yang memungkinkan Anda untuk membuat sarang dalam kelanjutan. </p><br><p>  Karenanya, Anda dapat menjadwalkan kode ini hingga akhir dengan <code>run</code> metode, atau menggantikannya dengan beberapa larik tertentu menggunakan metode <code>yield</code> (larik diperlukan di sini untuk sesuatu seperti meneruskan tindakan ke penangan yang bersarang, tetapi kami tidak peduli sebagai pengguna).  Anda dapat bertanya menggunakan metode <code>isDone</code> jika semuanya selesai sampai akhir. </p><br><p>  Dan untuk alasan yang ditentukan semata-mata oleh kebutuhan implementasi saat ini (tetapi kemungkinan besar, itu juga akan dimasukkan dalam rilis), tidak selalu memungkinkan untuk <code>yield</code> .  Misalnya, jika di dalam kelanjutan kami memiliki transisi ke kode asli dan bingkai asli muncul di tumpukan, maka tidak mungkin terjebak.  Ini juga akan terjadi jika Anda mencoba untuk diperas sementara monitor asli, seperti metode yang disinkronkan, diambil di dalam tubuh kontinum.  Secara default, ketika Anda mencoba memalsukan ini, pengecualian dilemparkan ... tetapi serat yang dibangun di atas kelanjutan membebani metode ini dan melakukan sesuatu yang lain.  Ini akan sedikit nanti. </p><br><p>  Anda dapat menggunakan ini kira-kira dengan cara berikut: </p><br><pre> <code class="java hljs">Continuation cont = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Continuation(SCOPE, () -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { System.out.println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>); Continuation.yield(SCOPE); System.out.println(<span class="hljs-string"><span class="hljs-string">"after"</span></span>); } }); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!cont.isDone()) { cont.run(); }</code> </pre> <br><p>  Ini adalah contoh dari presentasi Presler.  Sekali lagi, ini bukan kode "sepele", ini semacam sketsa. </p><br><p>  Ini adalah sketsa dari apa yang kita lakukan kelanjutan, di tengah kelanjutan ini kita ramai keluar dan kemudian dalam siklus tanpa akhir kita bertanya apakah kelanjutan bekerja sampai akhir dan apakah itu harus dilanjutkan. </p><br><p>  Tetapi secara umum, itu tidak dimaksudkan bahwa pemrogram aplikasi biasa akan berhubungan dengan API ini.  Ini dimaksudkan untuk pencipta kerangka kerja sistem.  Kerangka kerja pembentuk sistem seperti Spring Framework akan segera mengadopsi fitur ini segera setelah keluar.  Kamu akan lihat.  Anggap ini prediksi.  Prediksi yang ringan, karena semuanya cukup jelas di sini.  Semua data untuk prediksi adalah.  Fitur ini terlalu penting untuk tidak diadaptasi.  Karena itu, tidak perlu khawatir sebelumnya bahwa seseorang akan menyiksa Anda dengan penyandian dalam formulir ini.  Nah, jika Anda adalah pengembang Spring, maka Anda tahu apa yang Anda lakukan. </p><br><p>  Dan sekarang, di atas kelanjutan, serat dibangun. </p><br><h1 id="fibers">  Serat </h1><br><p>  Jadi, apa yang ada dalam kasus kami artinya serat. <br><br>  Ini adalah semacam abstraksi, yaitu: </p><br><ul><li>  Thread ringan diproses dalam JVM itu sendiri, dan bukan di sistem operasi; </li><li>  Dengan biaya overhead yang sangat rendah untuk membuat, mempertahankan hidup, berpindah tugas; </li><li>  Yang bisa dijalankan jutaan kali. </li></ul><br><p>  Banyak teknologi mencoba membuat serat dengan satu atau lain cara.  Sebagai contoh, di Kotlin ada coroutine yang diimplementasikan pada generasi bytecode yang sangat cerdas.  <em>SANGAT CERDAS</em> .  Tetapi runtime adalah tempat yang lebih baik untuk mengimplementasikan hal-hal seperti itu. </p><br><p>  Minimal, JVM sudah tahu cara menangani utas dengan baik, dan yang perlu kita lakukan adalah merampingkan proses pengkodean untuk multithreading.  Anda dapat menggunakan API asinkron, tetapi ini hampir tidak bisa disebut "penyederhanaan": bahkan menggunakan hal-hal seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Reaktor</a> , Reaktor Proyek Musim Semi, yang memungkinkan penulisan kode yang tampaknya linier, tidak akan banyak membantu jika Anda perlu men-debug masalah yang rumit. </p><br><p>  Jadi Fiber. </p><br><p>  Serat terdiri dari dua komponen.  Ini adalah: </p><br><ul><li>  Lanjutan </li><li>  Penjadwal </li></ul><br><p>  Itu adalah: </p><br><ul><li>  Lanjutan </li><li>  Perencana </li></ul><br><br><p><img src="https://habrastorage.org/webt/ga/wc/yk/gawcykupqgqwqjwfxcpccyltenu.jpeg"><br><br></p><br><p>  Anda dapat memutuskan siapa perencana di sini.  Saya pikir perencana di sini adalah Jay. </p><br><ul><li>  Fibre membungkus kode yang ingin Anda jalankan dalam kelanjutan </li><li>  Penjadwal meluncurkannya di kumpulan utas operator </li></ul><br><p>  <em>Saya akan memanggil mereka utas pembawa.</em> </p><br><br><br><p><img src="https://habrastorage.org/webt/j4/hc/gw/j4hcgwglzzsi6qe-cxczwcewohy.jpeg"><br><br></p><br><p>  Prototipe saat ini menggunakan <code>java.util.concurrent.Executor</code> , dan penjadwal <code>ForkJoinPool</code> .  Kami memiliki segalanya.  Di masa depan, sesuatu yang lebih pintar mungkin muncul di sana, tetapi untuk saat ini, seperti ini. </p><br><p>  Bagaimana kelanjutannya: </p><br><ul><li>  Itu ramai keluar (menghasilkan) ketika kunci terjadi (misalnya, pada IO); </li><li>  Berlanjut saat siap untuk melanjutkan (misalnya, operasi IO telah selesai dan Anda dapat melanjutkan). </li></ul><br><p>  Status pekerjaan saat ini: </p><br><ul><li>  Fokus utama pada filosofi, konsep; </li><li>  API tidak diperbaiki, itu "untuk pertunjukan".  Ini adalah prototipe penelitian; </li><li>  Ada prototipe kerja enkode yang sudah jadi dari kelas <code>java.lang.Fiber</code> . </li></ul><br><p>  Itu akan dibahas. </p><br><p>  Apa yang sudah digergaji menjadi serat: </p><br><ul><li>  Ini menjalankan peluncuran tugas; </li><li>  Parkir mobil tidak diparkir di atas kapal induk; </li><li>  Menunggu selesainya serat. </li></ul><br><h1 id="principialnaya-shema">  Diagram sirkuit </h1><br><pre> <code class="java hljs">mount(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { cont.run(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> () { unmount(); }</code> </pre> <br><ul><li>  Kita bisa memasang serat pada pembawa benang; </li><li>  Kemudian jalankan kelanjutannya; </li><li>  Dan tunggu sampai dia penuh sesak atau dengan jujur â€‹â€‹berhenti; </li><li>  Pada akhirnya, kami selalu meninggalkan utas. </li></ul><br><p>  Pseudo-code ini akan dieksekusi pada <code>ForkJoinPool</code> atau yang lainnya (yang nantinya akan menjadi versi final). </p><br><h1 id="ispolzovanie-v-realnosti">  Gunakan dalam kenyataan </h1><br><pre> <code class="java hljs">Fiber f = Fiber.execute( () -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Good Morning!"</span></span>); readLock.lock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { System.out.println(<span class="hljs-string"><span class="hljs-string">"Good Afternoon"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { readLock.unlock(); } System.out.println(<span class="hljs-string"><span class="hljs-string">"Good Night"</span></span>); });</code> </pre> <br><p>  Lihat, kami membuat serat di mana: </p><br><ul><li>  selamat datang semuanya; </li><li>  kami memblokir di reentrant loke; </li><li>  sekembalinya, selamat atas makan siang Anda; </li><li>  akhirnya lepaskan kuncinya; </li><li>  dan ucapkan selamat tinggal. </li></ul><br><p>  Semuanya sangat sederhana. </p><br><p>  Kami tidak menyebabkan crowding secara langsung.  Project Loom sendiri tahu bahwa ketika <code>readLock.lock();</code> dipicu <code>readLock.lock();</code>  dia harus turun tangan dan secara implisit melakukan represi.  Pengguna tidak melihat ini, tetapi itu terjadi di sana. </p><br><h1 id="steki-povsyudu-steki">  Tumpukan, tumpukan di mana-mana! </h1><br><p>  Mari kita tunjukkan apa yang terjadi menggunakan tumpukan pizza sebagai contoh. </p><br><p>  Pada awalnya, utas pembawa dalam keadaan menunggu, dan tidak ada yang terjadi. </p><br><p><img src="https://habrastorage.org/webt/8y/gw/mr/8ygwmr7dc_owazfdj-wa4trrs4g.png"><br><br></p><br><p>  Atas tumpukan di atas, ingat. </p><br><p>  Kemudian serat dijadwalkan untuk dieksekusi, dan tugas serat mulai berjalan. </p><br><p><img src="https://habrastorage.org/webt/pd/ya/mn/pdyamn0chhcnelgtphtxeg6eniq.png"><br><br></p><br><p>  Di dalam dirinya, ia jelas meluncurkan kelanjutan, di mana kode sebenarnya sudah ada. </p><br><p><img src="https://habrastorage.org/webt/33/nw/fb/33nwfb3dz0klj1oiog21iegsbuy.png"><br><br></p><br><p>  Dari sudut pandang pengguna, kami belum meluncurkan apa pun di sini. </p><br><p>  Itu hanya bingkai pertama dari kode pengguna muncul di tumpukan, dan itu ditandai dengan warna ungu. </p><br><p>  Selanjutnya, kode dieksekusi, dieksekusi, di beberapa titik tugas mencoba menangkap kunci dan memblokirnya, yang mengarah ke crowding out otomatis. </p><br><p><img src="https://habrastorage.org/webt/vv/lk/ah/vvlkahftvyuefpupb4fyidb5gdq.png"><br><br></p><br><p>  Segala sesuatu yang ada di tumpukan kelanjutan disimpan di tempat magis tertentu.  Dan menghilang. </p><br><p><img src="https://habrastorage.org/webt/hz/oq/6n/hzoq6nmzmezadhp8-ntn6_qerxk.png"><br><br></p><br><p>  Seperti yang Anda lihat, aliran kembali ke serat, ke instruksi yang mengikuti <code>Continuation.run</code> .  Dan ini adalah akhir dari kode serat. </p><br><p>  Tugas serat berakhir, pembawa media sedang menunggu pekerjaan baru. </p><br><p><img src="https://habrastorage.org/webt/l4/nt/k9/l4ntk9qfl8dpcamol4ufahy8sa0.png"><br><br></p><br><p>  Serat diparkir, di suatu tempat terletak, kontinum benar-benar ramai. </p><br><p>  Cepat atau lambat, saatnya tiba ketika orang yang memiliki kunci melepaskannya. <br>  Ini mengarah pada fakta bahwa serat, yang sedang menunggu pelepasan kunci, dibongkar.  Tugas serat ini dimulai lagi. </p><br><ul><li>  Reentrantlock.unlock </li><li>  Locksupport.unpark </li><li>  Fiber.unpark </li><li>  ForkJoinPool.execute </li></ul><br><p>  Dan kami dengan cepat kembali ke tumpukan, yang baru-baru ini. </p><br><p><img src="https://habrastorage.org/webt/hz/oq/6n/hzoq6nmzmezadhp8-ntn6_qerxk.png"><br><br></p><br><p>  Selain itu, utas pengangkut mungkin sangat berbeda.  Dan itu masuk akal! </p><br><p>  Jalankan kelanjutan lagi. </p><br><p><img src="https://habrastorage.org/webt/ll/c-/mx/llc-mxgfttlpleiqtprwm6igcju.png"><br><br></p><br><p>  Dan inilah MAGIC !!!  Stack dikembalikan, dan eksekusi berlanjut dengan instruksi setelah <code>Continuation.yield</code> . </p><br><p><img src="https://habrastorage.org/webt/la/4t/pp/la4tppjy2spiy4_auvwdikgm8nu.png"><br><br></p><br><p>  Kami merangkak keluar dari kunci yang baru saja diparkir dan mulai mengeksekusi semua kode yang tersisa dalam kelanjutan: </p><br><p><img src="https://habrastorage.org/webt/yt/ce/ht/ytcehtff1fomwn5cehnzkegzpts.png"><br><br></p><br><p>  Tugas pengguna berakhir, dan kontrol kembali ke tugas serat segera setelah instruksi continue.run </p><br><p><img src="https://habrastorage.org/webt/sz/m8/cc/szm8ccxgwntcgjzwqcl_gcernqg.png"><br><br></p><br><p>  Pada saat yang sama, eksekusi serat berakhir, dan kami kembali menemukan diri kami dalam mode siaga. </p><br><p><img src="https://habrastorage.org/webt/l4/nt/k9/l4ntk9qfl8dpcamol4ufahy8sa0.png"><br><br></p><br><p>  Peluncuran serat berikutnya lagi memulai seluruh siklus kelahiran kembali yang dijelaskan di atas. </p><br><p><img src="https://habrastorage.org/webt/c7/z9/wm/c7z9wmktfbsithnlvyuea4mtqki.jpeg"><br><br></p><br><h1 id="zhivye-primery">  Contoh langsung </h1><br><p>  Dan siapa yang pernah mengatakan bahwa semua ini berhasil?  Apakah ini tentang sepasang microbenchmark yang ditulis pada malam hari? </p><br><p>  Sebagai contoh operasi petasan, Oraklovites menulis server web kecil dan memberi makan dengan permintaan sehingga tersedak.  Kemudian mereka dipindahkan ke serat.  Server berhenti tersedak, dan dari sini kami menyimpulkan bahwa serat bekerja. </p><br><p>  Saya tidak memiliki kode persis untuk server ini, tetapi jika posting ini mendapat cukup suka dan komentar, saya akan mencoba menulis contoh sendiri dan membuat grafik nyata. </p><br><h1 id="problemy">  Masalahnya </h1><br><p>  Apakah ada masalah di sini?  Ya tentu saja!  Seluruh cerita dengan para penipu adalah kisah tentang masalah dan pengorbanan yang berkelanjutan. </p><br><h2 id="filosofskie-problemy">  Masalah filosofis </h2><br><ul><li>  Apakah kita perlu menemukan kembali utas? </li><li>  Haruskah <em>semua</em> kode yang ada berfungsi dengan baik di dalam fiber? </li></ul><br><p>  Prototipe saat ini berjalan dengan keterbatasan.  Yang mungkin masuk ke rilis, meskipun saya tidak mau.  Namun, OpenJDK adalah hal yang menghargai kompatibilitas tanpa akhir. </p><br><p>  Apa batasan teknisnya?  Batasan yang paling jelas adalah 2 buah. </p><br><h2 id="problema-raz--nelzya-vytesnit-nativnye-freymy">  Masalahnya sekali - Anda tidak dapat mengganti bingkai asli </h2><br><pre> <code class="java hljs">PrivilegedAction&lt;Void&gt; pa = () -&gt; { readLock.lock(); <span class="hljs-comment"><span class="hljs-comment">// may park/yield try { // } finally { readLock.unlock(); } return null; } AccessController.doPrivileged(pa); //native method</span></span></code> </pre> <br><p>  Di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">doPrivileged</a> memanggil metode asli. </p><br><p>  Anda memanggil <code>doPrivileged</code> , melompat keluar dari VM, bingkai asli muncul di tumpukan Anda, setelah itu Anda mencoba memarkir di baris <code>readLock.lock()</code> .  Dan pada saat itu, utas pembawa akan ternoda sampai tidak dijiplak.  Artinya, utasnya hilang.  Dalam hal ini, benang pembawa dapat berakhir, dan secara umum, ini mematahkan seluruh ide serat. </p><br><p>  Cara untuk menyelesaikan ini sudah diketahui, dan diskusi sedang berlangsung tentang hal ini. </p><br><h2 id="problema-dva---synchronized-bloki">  Masalah dua - blok disinkronkan </h2><br><p>  Ini adalah sampah yang jauh lebih serius </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (object) { <span class="hljs-comment"><span class="hljs-comment">//may park object.wait(); //may park }</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (object) { <span class="hljs-comment"><span class="hljs-comment">//may park socket.getInputStream().read(); //may park }</span></span></code> </pre> <br><p>  Dalam hal monitor menangkap serat, benang pembawa juga menendang. </p><br><p>  Jelas bahwa dalam kode yang sama sekali baru Anda dapat mengubah monitor menjadi kunci langsung, alih-alih menunggu + memberi tahu Anda dapat menggunakan objek kondisi, tetapi apa yang harus dilakukan dengan warisan?  Ini masalah. </p><br><h1 id="thread-api-threadcurrentthread-thread-locals">  API utas?  Thread.currentThread ()?  Penduduk setempat? </h1><br><p>  Dalam prototipe saat ini, <code>Thread</code> and <code>Fiber</code> telah membuat satu superclass umum yang disebut <code>Strand</code> . </p><br><p>  Ini memungkinkan Anda untuk mentransfer API dengan cara yang paling minimal. <br>  Apa yang harus dilakukan selanjutnya - seperti biasa dalam proyek ini, adalah sebuah pertanyaan. </p><br><p>  Apa yang terjadi dengan Thread API sekarang? </p><br><ul><li>  Penggunaan pertama <code>Thread.currentThread()</code> dalam sebuah serat menciptakan semacam bayangan benang, Bayangan Thread; </li><li>  dari sudut pandang sistem, ini adalah utas yang "belum dirilis", dan tidak ada informasi meta VM di dalamnya; </li><li>  ST mencoba untuk meniru semua yang ia bisa; </li><li>  tetapi Anda harus memahami bahwa API lama memiliki banyak sampah; </li><li>  lebih khusus, Shadow Thread mengimplementasikan Thread Thread untuk semua hal kecuali <code>stop</code> , <code>suspend</code> , <code>resume</code> dan menangani pengecualian yang tidak tertangkap. </li></ul><br><p>  Apa yang harus dilakukan dengan utas lokal? </p><br><ul><li>  sekarang utas penduduk setempat berubah menjadi serat lokal; </li><li>  ada banyak masalah dengan ini, semua ini sedang dibahas; </li><li>  seperangkat kegunaan terutama dibahas; </li><li>  Utas secara historis menggunakan keduanya dengan benar dan salah (mereka yang menggunakan salah masih berharap untuk sesuatu, dan Anda tidak dapat sepenuhnya mengecewakan mereka); </li><li>  secara umum, ini menciptakan berbagai macam aplikasi: <br><ul><li>  Tingkat tinggi: cache koneksi atau kata sandi dalam wadah; </li><li>  Tingkat rendah: prosesor di perpustakaan sistem. </li></ul></li></ul><br><h1 id="skolko-vse-eto-zhret">  Berapa makan semuanya </h1><br><p><img src="https://habrastorage.org/webt/pl/7-/pi/pl7-pidz-d2o3l98qx2srbmezxi.png"><br><br></p><br><p>  Utas: </p><br><ul><li>  Stack: 1MB dan 16KB pada struktur data kernel; </li><li>  Contoh per utas: 2300 byte, termasuk informasi meta VM. </li></ul><br><p>  Serat: </p><br><ul><li>  Tumpukan lanjutan: dari ratusan byte ke kilobyte; </li><li>  Per fiber misalnya: 200-240 byte. </li></ul><br><p>  Perbedaannya sangat besar! <br>  Dan itulah yang membuat jutaan orang bersemangat. </p><br><h1 id="chto-mozhet-parkovatsya">  Apa yang bisa parkir </h1><br><p>  Jelas bahwa hal yang paling ajaib adalah parkir otomatis ketika beberapa peristiwa terjadi.  Apa yang saat ini didukung? </p><br><ul><li>  Thread.sleep, gabung; </li><li>  java.util.concurrent dan LockSupport.lock; </li><li>  IO: jaringan pada soket (soket baca, tulis, sambungkan, terima), file, pipa; </li><li>  Semua ini belum selesai, tetapi cahaya di terowongan terlihat. </li></ul><br><h1 id="kommunikaciya-mezhdu-fayberami">  Komunikasi antar Fiber </h1><br><p>  Pertanyaan lain yang diajukan semua orang adalah: bagaimana cara bertukar informasi di antara serat secara kompetitif. </p><br><ul><li>  Prototipe saat ini meluncurkan tugas di <code>Runnable</code> , dapat dikonversi ke <code>CompletableFuture</code> , jika karena alasan tertentu Anda perlu; </li><li>  java.util.concurrent "just works."  Anda dapat meraba-raba segala sesuatu dengan cara standar; </li><li>  mungkin ada API baru untuk multithreading, tetapi ini tidak akurat; </li><li>  banyak pertanyaan kecil seperti "haruskah serat mengembalikan nilai?";  semuanya dibahas, mereka tidak ada dalam prototipe. </li></ul><br><h1 id="kak-realizovany-kontinuacii-v-prototipe">  Bagaimana kelanjutan diimplementasikan dalam prototipe? </h1><br><p>  Persyaratan yang jelas dibebankan pada kelanjutan: Anda perlu menggunakan RAM sesedikit mungkin, dan Anda harus beralih di antara mereka secepat mungkin.  Kalau tidak, itu tidak akan berhasil untuk menjaga mereka dalam jutaan.  Tugas utama di sini adalah entah bagaimana tidak melakukan salinan penuh tumpukan untuk setiap parkir-uppark.  Dan ada skema seperti itu!  Mari kita coba jelaskan ini di gambar. </p><br><p>  Cara paling keren tentu saja dengan meletakkan semua tumpukan di pinggul java dan menggunakannya secara langsung.  Tetapi tidak jelas bagaimana cara membuat kode sekarang, jadi prototipe menggunakan penyalinan.  Tetapi menyalin dengan hack kecil tapi penting. </p><br><p>  Kami punya dua kursi ... Maksudku, dua tumpukan.  Dua array java di pinggul.  Salah satunya adalah array objek, di mana kita akan menyimpan referensi ke objek.  Yang kedua adalah primitif (misalnya, intim), yang akan menangani segalanya. </p><br><p><img src="https://habrastorage.org/webt/33/tf/cj/33tfcj897awloqfisxfwwl-4ypy.png"><br><br></p><br><p>  Sekarang kita berada dalam keadaan di mana kelanjutan akan dilakukan untuk pertama kalinya. </p><br><p>  <code>run</code> panggilan metode internal yang disebut <code>enter</code> : </p><br><p><img src="https://habrastorage.org/webt/j6/d5/ki/j6d5kioz8ygupanxditl3iaslbi.png"><br><br></p><br><p>  Dan kemudian kode pengguna dieksekusi, sampai crowding out pertama. </p><br><p><img src="https://habrastorage.org/webt/ab/on/6c/abon6cdsoepe-ts69pkmm9sk35i.png"><br><br></p><br><p>  Pada titik ini, panggilan VM dibuat, yang panggilannya <code>freeze</code> .  Dalam prototipe ini, ini dilakukan secara fisik - menggunakan salinan. </p><br><p><img src="https://habrastorage.org/webt/iu/or/jv/iuorjvmb6xrjnycvx3nxbdcqxxc.png"><br><br></p><br><p>  Kami memulai proses menyalin frame secara berurutan dari tumpukan asli ke java hip. </p><br><p><img src="https://habrastorage.org/webt/ln/nu/sm/lnnusmrix2hsqpwxmzkeemd_or0.png"><br><br></p><br><p>  Penting untuk memeriksa apakah monitor dipegang di sana atau kode asli digunakan, atau sesuatu yang benar-benar tidak memungkinkan kita untuk terus bekerja. </p><br><p><img src="https://habrastorage.org/webt/vl/5c/k0/vl5ck0i3jtouapded9snnl9brvy.png"><br><br></p><br><p>  Dan jika semuanya baik-baik saja, kita salin dulu ke array primitif: </p><br><p><img src="https://habrastorage.org/webt/ka/z_/gl/kaz_glkmthfyd1x8rzdprn3v8ym.png"><br><br></p><br><p>  Kemudian kita mengisolasi referensi ke objek dan menyimpannya di array objek: </p><br><p><img src="https://habrastorage.org/webt/xc/2q/nb/xc2qnbafy_2eybwzif-3s3vmaym.png"><br><br></p><br><p>  Sebenarnya, dua teh untuk semua orang yang membaca ke tempat ini! </p><br><p>  Selanjutnya kami melanjutkan prosedur ini untuk semua elemen lain dari tumpukan asli. </p><br><p><img src="https://habrastorage.org/webt/6e/sp/-0/6esp-07i4dyasxj5esb9qu6fh5i.png"><br><br></p><br><p>  Hore!  Kami menyalin semuanya ke sarang di pinggul.  Anda dapat dengan aman melompat ke tempat panggilan tanpa takut bahwa kami telah kehilangan sesuatu.  Semuanya keren. </p><br><p><img src="https://habrastorage.org/webt/bq/sz/ju/bqszjuffw-s4f14audafvzbmqzc.png"><br><br></p><br><p>  Sekarang, cepat atau lambat, kode panggilan akan memanggil kelanjutan kami lagi.  Dan dia harus melanjutkan dari tempat di mana dia ditinggalkan terakhir kali.  Ini tugas kita. </p><br><p><img src="https://habrastorage.org/webt/8i/bg/x9/8ibgx9r_26wedxrahar1vfqdifi.png"><br><br></p><br><p>  Memeriksa apakah kelanjutan berjalan, mengatakan ya, itu berjalan.  Jadi, Anda perlu memanggil VM, membersihkan beberapa ruang di tumpukan dan memanggil fungsi VM internal.  "Thaw" diterjemahkan ke dalam bahasa Rusia sebagai "thaw", "unfreeze", yang terdengar cukup logis.  Kita perlu mencairkan frame dari tumpukan lanjutan ke tumpukan asli utama kita. </p><br><p>  Saya tidak yakin teh yang mencairkan cukup jelas.  Abstraksi yang buruk seperti anak kucing dengan pintu.  Tetapi ini akan bermanfaat bagi kita. </p><br><p><img src="https://habrastorage.org/webt/ra/sv/5v/rasv5v_5w8_dpegomn_omgtdiza.png"><br><br></p><br><p>  Kami membuat salinan yang cukup jelas. </p><br><p>  Pertama dengan array primitif: </p><br><p><img src="https://habrastorage.org/webt/wc/he/vg/wchevg-fsflrnicy0itprkp0q2e.png"><br><br></p><br><p>  Kemudian dari tautan: </p><br><p><img src="https://habrastorage.org/webt/o_/o2/6s/o_o26sakm0n5hyq9wisbo7vouge.png"><br><br></p><br><p>  Anda perlu menambal bit yang disalin untuk mendapatkan tumpukan yang benar: </p><br><p><img src="https://habrastorage.org/webt/sm/h7/0n/smh70naepp3kshxaa78zxv1g2du.png"><br><br></p><br><p>  Ulangi kecabulan untuk semua bingkai: </p><br><p><img src="https://habrastorage.org/webt/cg/dv/61/cgdv617uqeriqmuqcyc2jkjpnbe.png"><br><br></p><br><p>  Sekarang Anda dapat kembali untuk <code>yield</code> dan melanjutkan seolah-olah tidak ada yang terjadi. </p><br><p><img src="https://habrastorage.org/webt/gn/dd/xw/gnddxwqqsrwuidc9ev2nxwmiwqc.png"><br><br></p><br><p>  Masalahnya adalah bahwa salinan penuh tumpukan itu sama sekali tidak seperti yang ingin kita miliki.  Ini sangat menghambat.  Semua ini adalah isolasi tautan, periksa pinning, tidak cepat.  Dan yang paling penting - semua ini secara linear tergantung pada ukuran tumpukan!  Singkatnya, neraka.  Tidak perlu melakukan ini. </p><br><p>  Sebaliknya, kami punya ide lain - menyalin malas. </p><br><p>  Mari kita kembali ke tempat di mana kita sudah memiliki kelanjutan beku. </p><br><p><img src="https://habrastorage.org/webt/5b/hw/tg/5bhwtgg8cfg-agcwu_kdtrqlify.png"><br><br></p><br><p>  Kami melanjutkan proses seperti sebelumnya: </p><br><p><img src="https://habrastorage.org/webt/rj/ac/f9/rjacf9tmfekskko8jwojuocxixm.png"><br><br></p><br><p>  Dengan cara yang sama seperti sebelumnya, kami membersihkan tempat di tumpukan asli: </p><br><p><img src="https://habrastorage.org/webt/nm/ol/ow/nmolowac-dkmdefuobd-kaijyeq.png"><br><br></p><br><p>  Tapi kami tidak menyalin semuanya dalam satu baris, tetapi hanya satu atau beberapa bingkai: </p><br><p><img src="https://habrastorage.org/webt/3a/ca/1x/3aca1xglgfbq8yzwxkjypelxpqy.png"><br><br></p><br><p>  Sekarang retas.  Anda perlu menambal alamat pengirim metode <code>C</code> sehingga menunjuk ke penghalang pengembalian tertentu: </p><br><p><img src="https://habrastorage.org/webt/zs/si/3z/zssi3zgaadvvsrg883agxsmq3pc.png"><br><br></p><br><p>  Sekarang Anda dapat dengan aman kembali ke <code>yield</code> : </p><br><p><img src="https://habrastorage.org/webt/e1/f_/2s/e1f_2snf4bh-ggjcv5lrgabqkwk.png"><br><br></p><br><p>  Yang pada gilirannya akan mengarah pada panggilan ke kode pengguna dalam metode <code>C</code> : </p><br><p><img src="https://habrastorage.org/webt/y2/nl/rm/y2nlrmn9lczwhcaa3f41ii69nq0.png"><br><br></p><br><p>  Sekarang bayangkan <code>C</code> ingin kembali ke kode yang memanggilnya.  Tapi pemanggilnya adalah <code>B</code> , dan dia tidak ada di tumpukan!  Karena itu, ketika dia mencoba untuk kembali, dia akan pergi ke alamat pengirim, dan alamat ini sekarang menjadi penghalang kembali.  Dan, Anda tahu, ini sekali lagi akan menarik panggilan <code>thaw</code> : </p><br><p><img src="https://habrastorage.org/webt/hb/6g/8d/hb6g8dfw35ujqntvi-y7lzyskis.png"><br><br></p><br><p>  Dan <code>thaw</code> akan mencairkan frame berikutnya pada tumpukan kelanjutan, dan ini adalah <code>B</code> : </p><br><p><img src="https://habrastorage.org/webt/cp/mp/ao/cpmpao3_arvnvgykenc9r4fgwsk.png"><br><br></p><br><p>  Bahkan, kami menyalinnya dengan malas, berdasarkan permintaan. </p><br><p>  Selanjutnya, kita menjatuhkan <code>B</code> dari tumpukan kelanjutan dan mengatur penghalang lagi (penghalang perlu diatur karena ada sesuatu yang tersisa pada tumpukan kelanjutan).  Dan seterusnya. </p><br><p><img src="https://habrastorage.org/webt/gv/yo/0u/gvyo0u4iwzunuqovy1yv_-jbutq.png"><br><br></p><br><p>  Tetapi anggaplah <code>B</code> tidak akan kembali ke kode panggilan, tetapi pertama-tama memanggil beberapa metode lain <code>D</code>  Dan metode baru ini juga ingin dihalangi. </p><br><p><img src="https://habrastorage.org/webt/f9/1i/t9/f91it9xn705zsxuzvvbqh5gdoqi.png"><br><br></p><br><p>  Dalam hal ini, ketika tiba saatnya untuk melakukan <code>freeze</code> , kita hanya perlu menyalin bagian atas tumpukan asli ke tumpukan lanjutan: </p><br><p><img src="https://habrastorage.org/webt/pt/8b/ul/pt8buljt77lsp-wj-rswobc4v_y.png"><br><br></p><br><p>  Dengan demikian, jumlah pekerjaan yang dilakukan tidak tergantung secara linear pada ukuran tumpukan.  Secara linear hanya tergantung pada jumlah frame yang sebenarnya kita gunakan dalam pekerjaan. </p><br><h1 id="chto-ostalos">  Apa yang tersisa </h1><br><p>  Pengembang mengingat beberapa fitur, tetapi mereka tidak masuk ke prototipe. </p><br><ul><li>  Serialisasi dan kloning.  Kemampuan untuk melanjutkan di komputer lain, di waktu lain, dll. </li><li>  JVM TI dan debugging, seolah-olah itu adalah utas biasa.  Jika Anda diblokir saat membaca soket, maka Anda tidak akan melihat lompatan indah dari hasil, dalam prototipe utas hanya akan diblokir, seperti utas biasa lainnya. </li><li>  Rekursi ekor bahkan tidak tersentuh. </li></ul><br><p>  Langkah selanjutnya: </p><br><ul><li>  Buat API manusia; </li><li>  Tambahkan semua fitur yang hilang; </li><li>  Tingkatkan kinerja. </li></ul><br><h1 id="gde-vzyat">  Dari mana mendapatkan </h1><br><p>  Prototipe dibuat sebagai brunch di repositori OpenJDK.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda dapat mengunduh prototipe di sini</a> dengan beralih ke <code>fibers</code> brunch. </p><br><p>  Ini dilakukan seperti ini: </p><br><pre> <code class="bash hljs">$ hg <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> http://hg.openjdk.java.net/loom/loom $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> loom $ hg update -r fibers $ sh configure $ make images</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda tahu, semua ini akan memulai perakitan OpenJDK sialan seluruh. </font><font style="vertical-align: inherit;">Karena itu, pertama, setengah jam berikutnya hidup Anda harus melakukan sesuatu yang lain, sementara semua ini akan terjadi.</font></font></p><br><p><img src="https://habrastorage.org/webt/gk/qz/3-/gkqz3-f8gmkcwkynnnrp4opp1rg.png"><br><br></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, Anda harus memiliki komputer yang dikonfigurasi dengan benar dengan C ++ toolchain dan libs GNU. </font><font style="vertical-align: inherit;">Saya mengisyaratkan bahwa Anda tidak disarankan melakukan ini di Windows. </font><font style="vertical-align: inherit;">Serius, bahkan dengan mengunduh VirtualBox dan menginstal Ubuntu baru di sana, Anda akan menghabiskan pesanan dengan jumlah yang lebih sedikit daripada mencoba untuk menyadari kesalahan tidak manusiawi lainnya ketika membangun dari Cygwin atau msys64. </font><font style="vertical-align: inherit;">Di sinilah msys datang bahkan lebih buruk daripada Cygwin.</font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun ini, tentu saja, semua bohong, saya hanya bosan menulis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruksi perakitan kepada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda </font><font style="vertical-align: inherit;">.</font></font></p><br><p>   -   ,   mercurial extension   fsmonitor. ,   ,   <code>hg help -e fsmonitor</code> . <br>      ~/.hgrc  : </p><br><pre> <code class="plaintext hljs">[fsmonitor] mode = on</code> </pre> <br><p>  -           .             -, <code>cp -R ./loom ./loom-backup</code> . </p><br><p>  ,          . ,   Java-    ,       . </p><br><p> <code>sh configure</code>    - . ,     Ubuntu,     Autoconf ( <code>sudo apt-get install autoconf</code> ).  â€”     OpenJDK   Ubuntu,     ,  .  Windows      ,   . </p><br><p> ,     ,   <code>hg diff --stat -r default:fibers</code> . </p><br><p>  ,          ,   ,     . </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p>      Â«, Â».   Â«Â», . Â«LoomÂ» â€”  Â« Â».  Project Loom         . </p><br><p>          ,        . ,      Â«Â»  ,  ,      â€”  , ,  , â€”  . </p><br><p> ,   ,          XIX    ,        . </p><br><br><img src="https://habrastorage.org/getpro/habr/post_images/305/64e/143/30564e14316852dd18d4235b3850e134.jpg"><br><p>      . -,  . </p><br><p> ,                 .        IDE   . </p><br><p>          ,       ,   ,    Â« Â», Â«Â», Â« Â»   . </p><br><p>       ?   .   . </p><br><p>  Terima kasih </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422519/">https://habr.com/ru/post/id422519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422509/index.html">Ringkasan buku "Never Eat Alone"</a></li>
<li><a href="../id422511/index.html">Memuat data ke dalam Splunk: Universal Forwarder vs Heavy Forwarder. Apa bedanya?</a></li>
<li><a href="../id422513/index.html">7 tips tentang cara tidak membuat marah kolega penguji di liburannya</a></li>
<li><a href="../id422515/index.html">Dua Apache Ignite mitaps dan In-Memory Computing webinar pada bulan September</a></li>
<li><a href="../id422517/index.html">TelegramBot di Cloud Wolfram</a></li>
<li><a href="../id422521/index.html">Firasat akan hal yang tak terhindarkan</a></li>
<li><a href="../id422525/index.html">"Matriks persahabatan." Grafik sosial tertua untuk yang terkecil</a></li>
<li><a href="../id422527/index.html">Intisari berita PostgreSQL. Edisi 10</a></li>
<li><a href="../id422529/index.html">Kursus Spesial Group-IB: "Keamanan Aplikasi Seluler"</a></li>
<li><a href="../id422531/index.html">Optimalisasi Web: Yang Paling Penting</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>