<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚅 🙍🏼 🖼️ 资源控制。 自定义SwiftGen 🎹 👎 🤵🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大概，在每个大型的iOS项目中，这个寿命长的项目可能会偶然发现没有在任何地方使用过的图标，或者访问很长时间不存在的本地化密钥。 大多数情况下，这种情况是由注意力不集中引起的，自动化是解决注意力不集中的最佳方法。 


 在HeadHunter的iOS团队中，我们非常重视自动化开发人员可能遇到的例行任...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>资源控制。 自定义SwiftGen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/423381/"><p> 大概，在每个大型的iOS项目中，这个寿命长的项目可能会偶然发现没有在任何地方使用过的图标，或者访问很长时间不存在的本地化密钥。 大多数情况下，这种情况是由注意力不集中引起的，自动化是解决注意力不集中的最佳方法。 </p><br><p> 在HeadHunter的iOS团队中，我们非常重视自动化开发人员可能遇到的例行任务。 在这篇文章中，我们希望开始一系列有关简化我们的日常工作的工具和方法的故事。 </p><br><p> 不久前，我们设法使用SwiftGen实用程序来控制应用程序资源。 关于如何配置它，如何使用它以及该实用程序如何帮助将对资源相关性的检查转移到编译器，我们将讨论cat。 </p><br><p><img src="https://habrastorage.org/webt/dl/sy/-c/dlsy-cocqhwmu02tsyr4aoukf-y.jpeg"></p><a name="habracut"></a><br><p>  SwiftGen是一个实用程序，可让您生成Swift代码以访问Xcode项目的各种资源，其中包括： </p><br><ul><li> 字型 </li><li> 颜色 </li><li> 故事板； </li><li> 本地化字符串； </li><li> 资产。 </li></ul><br><p> 每个人都可以编写类似的代码来初始化图像或本地化字符串： </p><br><pre><code class="swift hljs">logoImageView.image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(named: <span class="hljs-string"><span class="hljs-string">"Swift"</span></span>) nameLabel.text = <span class="hljs-type"><span class="hljs-type">String</span></span>( format: <span class="hljs-type"><span class="hljs-type">NSLocalizedString</span></span>(<span class="hljs-string"><span class="hljs-string">"languages.swift.name"</span></span>, comment: <span class="hljs-string"><span class="hljs-string">""</span></span>), locale: <span class="hljs-type"><span class="hljs-type">Locale</span></span>.current )</code> </pre> <br><p> 为了表示图像或本地化键的名称，我们使用字符串文字。 双引号之间写的内容未经编译器或开发环境（Xcode）验证。 其中存在以下问题集： </p><br><ul><li> 您可以打错字； </li><li> 您可能会在编辑或删除密钥/图像后忘记更新代码中的用法。 </li></ul><br><p> 让我们看看如何使用SwiftGen改进此代码。 </p><br><p> 对于我们的团队而言，生成只与字符串和资产相关，它们将在本文中进行讨论。 其他类型资源的生成类似，并且，如果需要，可以轻松地独立掌握。 </p><br><h2 id="vnedrenie-v-proekt"> 项目实施 </h2><br><p> 首先，您需要安装SwiftGen。 我们选择通过CocoaPods安装它，以方便在所有团队成员之间分发实用程序。 但这可以通过其他方式完成， <a href="">文档中</a>对此进行了详细介绍。 在我们的例子中，所有要做的就是将<code>pod 'SwiftGen'</code>添加<code>pod 'SwiftGen'</code> ，然后添加一个新的构建阶段（ <code>Build Phase</code> ），该<code>Build Phase</code>将在构建项目之前启动SwiftGen。 </p><br><pre> <code class="plaintext hljs">"$PODS_ROOT"/SwiftGen/bin/swiftgen</code> </pre> <br><p> 在开始“ <code>Compile Sources</code>阶段之前运行SwiftGen很重要，以避免在编译项目时出错。 </p><br><p><img src="https://habrastorage.org/webt/gx/1t/xw/gx1txw1lfcxmghilpakndv_wnck.png"></p><br><p> 现在我们准备将SwiftGen适应我们的项目。 </p><br><h2 id="nastroyka-swiftgen"> 配置SwiftGen </h2><br><p> 首先，您需要配置模板，通过这些模板将生成用于访问资源的代码。 该实用程序已经包含了一组用于生成代码的模板，它们都可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>上查看，并且原则上可以使用。 模板是以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Stencil</a>语言编写的，如果您使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sourcery</a>或与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kitura</a>一起<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">玩</a> ，您可能会熟悉它。 如果需要，每个模板都可以适应其自己的指南。 <br> 例如，采用<code>enum</code>生成的模板来访问本地化字符串。 在我们看来，标准中有太多多余的东西，可以简化。 扰流板下面是一个带有解释性注释的简化示例。 </p><br><div class="spoiler">  <b class="spoiler_title">范本范例</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">{#      #} {% set accessModifier %}{% if param.publicAccess %}public{% else %}internal{% endif %}{% endset %} {#    #} {% macro parametersBlock types %}{% filter removeNewlines:"leading" %} {% for type in types %} _ p{{forloop.counter}}: {{type}}{% if not forloop.last %}, {% endif %} {% endfor %} {% endfilter %}{% endmacro %} {% macro argumentsBlock types %}{% filter removeNewlines:"leading" %} {% for type in types %} p{{forloop.counter}}{% if not forloop.last %}, {% endif %} {% endfor %} {% endfilter %}{% endmacro %} {#       enum        #} {% macro recursiveBlock table item sp %} {{sp}}{% for string in item.strings %} {{sp}}{% if not param.noComments %} {{sp}}/// {{string.translation}} {{sp}}{% endif %} {{sp}}{% if string.types %} {{sp}}{{accessModifier}} static func {{string.name|swiftIdentifier:"pretty"|lowerFirstWord|escapeReservedKeywords}}({% call parametersBlock string.types %}) -&gt; String { {{sp}} return localize("{{string.key}}", {% call argumentsBlock string.types %}) {{sp}}} {{sp}}{% else %} {{sp}}{{accessModifier}} static let {{string.name|swiftIdentifier:"pretty"|lowerFirstWord|escapeReservedKeywords}} = localize("{{string.key}}") {{sp}}{% endif %} {{sp}}{% endfor %} {{sp}}{% for child in item.children %} {{sp}}{{accessModifier}} enum {{child.name|swiftIdentifier:"pretty"|escapeReservedKeywords}} { {{sp}}{% set sp2 %}{{sp}} {% endset %} {{sp}}{% call recursiveBlock table child sp2 %} {{sp}}} {{sp}}{% endfor %} {% endmacro %} import Foundation {#   enum #} {% set enumName %}{{param.enumName|default:"L10n"}}{% endset %} {{accessModifier}} enum {{enumName}} { {% if tables.count &gt; 1 %} {% for table in tables %} {{accessModifier}} enum {{table.name|swiftIdentifier:"pretty"|escapeReservedKeywords}} { {% call recursiveBlock table.name table.levels " " %} } {% endfor %} {% else %} {% call recursiveBlock tables.first.name tables.first.levels " " %} {% endif %} } {#  enum Localization         #} extension Localization { fileprivate static func localize(_ key: String, _ args: CVarArg...) -&gt; String { return String( format: NSLocalizedString(key, comment: ""), locale: Locale.current, arguments: args ) } }</code> </pre> </div></div><br><p> 将模板文件本身保存在项目的根目录中非常方便，例如，保存在<code>SwiftGen/Templates</code>文件夹中，以便该模板可供项目中的每个人使用。 <br> 该实用程序通过YAML文件<code>swiftgen.yml</code>支持配置，您可以在其中指定源文件，模板和其他参数的路径。 在<code>Swiftgen</code>文件夹的项目根目录中创建它，然后将与脚本相关的其他文件分组到同一文件夹中。 <br> 对于我们的项目，此文件可能如下所示： </p><br><pre> <code class="plaintext hljs">xcassets: - paths: ../SwiftGenExample/Assets.xcassets templatePath: Templates/ImageAssets.stencil output: ../SwiftGenExample/Image.swift params: enumName: Image publicAccess: 1 noAllValues: 1 strings: - paths: ../SwiftGenExample/en.lproj/Localizable.strings templatePath: Templates/LocalizableStrings.stencil output: ../SwiftGenExample/Localization.swift params: enumName: Localization publicAccess: 1 noComments: 0</code> </pre> <br><p> 实际上，文件和模板的路径以及在其中传递到模板上下文的其他参数都在此处指示。 <br> 由于该文件不是项目的根目录，因此在启动Swiftgen时我们需要指定其路径。 更改我们的启动脚本： </p><br><pre> <code class="plaintext hljs">"$PODS_ROOT"/SwiftGen/bin/swiftgen config run --config SwiftGen/swiftgen.yml</code> </pre> <br><p> 现在我们的项目可以组装了。 组装后，两个文件<code>Localization.swift</code>和<code>Image.swift</code>应该沿着<code>Image.swift</code>指定的路径出现在项目文件夹中。 它们需要添加到Xcode项目中。 在我们的情况下，生成的文件包含以下内容： </p><br><div class="spoiler">  <b class="spoiler_title">对于字符串：</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Localization</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Languages</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectiveC</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/// General-purpose, object-oriented programming language that adds Smalltalk-style messaging to the C programming language public static let description = localize("languages.objective-c.description") /// https://en.wikipedia.org/wiki/Objective-C public static let link = localize("languages.objective-c.link") /// Objective-C public static let name = localize("languages.objective-c.name") } public enum Swift { /// General-purpose, multi-paradigm, compiled programming language developed by Apple Inc. for iOS, macOS, watchOS, tvOS, and Linux public static let description = localize("languages.swift.description") /// https://en.wikipedia.org/wiki/Swift_(programming_language) public static let link = localize("languages.swift.link") /// Swift public static let name = localize("languages.swift.name") } } public enum MainScreen { /// Language public static let title = localize("main-screen.title") public enum Button { /// View in Wikipedia public static let title = localize("main-screen.button.title") } } } extension Localization { fileprivate static func localize(_ key: String, _ args: CVarArg...) -&gt; String { return String( format: NSLocalizedString(key, comment: ""), locale: Locale.current, arguments: args ) } }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">对于图像：</b> <div class="spoiler_text"><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Image</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logos</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> objectiveC: <span class="hljs-type"><span class="hljs-type">UIImage</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image(named: <span class="hljs-string"><span class="hljs-string">"ObjectiveC"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> swift: <span class="hljs-type"><span class="hljs-type">UIImage</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image(named: <span class="hljs-string"><span class="hljs-string">"Swift"</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(named name: String)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIImage</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bundle = <span class="hljs-type"><span class="hljs-type">Bundle</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">BundleToken</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = <span class="hljs-type"><span class="hljs-type">UIImage</span></span>(named: name, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: bundle, compatibleWith: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Unable to load image named \(name)."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BundleToken</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> </div></div><br><p> 现在，您可以将生成的图像替换为<code>UIImage(named: "")</code>形式的图像的本地化和初始化字符串<code>UIImage(named: "")</code>所有用法。 这将使我们更容易跟踪对更改或删除本地化字符串键的更改。 在上述任何一种情况下，只有在修复了与更改相关的所有错误之后，项目才可以组装。 <br> 更改之后，我们的代码如下所示： </p><br><pre> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logos = <span class="hljs-type"><span class="hljs-type">Image</span></span>.<span class="hljs-type"><span class="hljs-type">Logos</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> localization = <span class="hljs-type"><span class="hljs-type">Localization</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupWithLanguage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> language: ProgrammingLanguage)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> language { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">Swift</span></span>: logoImageView.image = logos.swift nameLabel.text = localization.<span class="hljs-type"><span class="hljs-type">Languages</span></span>.<span class="hljs-type"><span class="hljs-type">Swift</span></span>.name descriptionLabel.text = localization.<span class="hljs-type"><span class="hljs-type">Languages</span></span>.<span class="hljs-type"><span class="hljs-type">Swift</span></span>.description wikiUrl = localization.<span class="hljs-type"><span class="hljs-type">Languages</span></span>.<span class="hljs-type"><span class="hljs-type">Swift</span></span>.link.toURL() <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .<span class="hljs-type"><span class="hljs-type">ObjectiveC</span></span>: logoImageView.image = logos.objectiveC nameLabel.text = localization.<span class="hljs-type"><span class="hljs-type">Languages</span></span>.<span class="hljs-type"><span class="hljs-type">ObjectiveC</span></span>.name descriptionLabel.text = localization.<span class="hljs-type"><span class="hljs-type">Languages</span></span>.<span class="hljs-type"><span class="hljs-type">ObjectiveC</span></span>.description wikiUrl = localization.<span class="hljs-type"><span class="hljs-type">Languages</span></span>.<span class="hljs-type"><span class="hljs-type">ObjectiveC</span></span>.link.toURL() } }</code> </pre> <br><h2 id="nastroyka-proekta-v-xcode"> 在Xcode中设置项目 </h2><br><p> 生成的文件存在一个问题：它们可能会被错误地手动更改，并且由于每次编译都会从头开始覆盖它们，所以这些更改可能会丢失。 为避免这种情况，您可以在<code>SwiftGen</code>脚本后锁定文件以进行写入。 <br> 这可以使用<code>chmod</code>来实现。 我们通过启动SwiftGen重写了<code>Build Phase</code> ，如下所示： </p><br><pre> <code class="plaintext hljs">PODSROOT="$1" OUTPUT_FILES=() COUNTER=0 while [ $COUNTER -lt ${SCRIPT_OUTPUT_FILE_COUNT} ]; do tmp="SCRIPT_OUTPUT_FILE_$COUNTER" OUTPUT_FILES+=(${!tmp}) COUNTER=$[$COUNTER+1] done for file in "${OUTPUT_FILES[@]}" do if [ -f $file ] then chmod a=rw "$file" fi done $PODSROOT/SwiftGen/bin/swiftgen config run --config SwiftGen/swiftgen.yml for file in "${OUTPUT_FILES[@]}" do chmod a=r "$file" done</code> </pre> <br><p> 该脚本非常简单。 在开始生成之前，如果文件存在，我们将授予它们写入权限。 运行脚本后，我们阻止了修改文件的功能。 <br> 为了便于编辑和检查脚本以进行检查，将其放置在单独的<code>runswiftgen.sh</code>文件中非常方便。 可以在<a href="">此处</a>找到经过少量修改的脚本的最终版本。 现在，我们的<code>Build Phase</code>将如下所示：我们将Pods文件夹的路径传递到脚本输入： </p><br><pre> <code class="plaintext hljs">"$SRCROOT"/SwiftGen/runswiftgen.sh "$PODS_ROOT"</code> </pre> <br><p> 我们重建项目，现在当您尝试手动修改生成的文件时，将出现警告： </p><br><p><img src="https://habrastorage.org/webt/-n/ly/km/-nlykmdjarer-97mhderydx5psq.png"></p><br><p> 因此，带有Swiftgen的文件夹现在包含一个配置文件，一个用于锁定文件并启动<code>Swiftgen</code>的脚本以及一个带有自定义模板的文件夹。 如有必要，可以方便地将其添加到项目中以进行进一步编辑。 </p><br><p><img src="https://habrastorage.org/webt/yw/dk/kq/ywdkkqfdjws_a32syu94hscr4cm.png"></p><br><p> 而且由于<code>Localization.swift</code>和<code>Image.swift</code>自动生成的，因此您可以将它们添加到.gitignore，这样您就不必在<code>git merge</code>再次<code>git merge</code>后解决冲突。 </p><br><p> 如果您的项目使用Xcode New Build System（它是Xcode 10的默认构建系统），我还要提请注意需要为SwiftGen阶段构建指定输入/输出文件。 在“输入文件”列表中，必须指定生成代码所依据的所有文件。 在我们的例子中，这是脚本本身，配置，模板，.strings和.xcassets文件： </p><br><pre> <code class="plaintext hljs">$(SRCROOT)/SwiftGen/runswiftgen.sh $(SRCROOT)/SwiftGen/swiftgen.yml $(SRCROOT)/SwiftGen/Templates/ImageAssets.stencil $(SRCROOT)/SwiftGen/Templates/LocalizableStrings.stencil $(SRCROOT)/SwiftGenExample/en.lproj/Localizable.strings $(SRCROOT)/SwiftGenExample/Assets.xcassets</code> </pre> <br><p> 在输出文件中，我们放置SwiftGen生成代码的文件： </p><br><pre> <code class="plaintext hljs">$(SRCROOT)/SwiftGenExample/Image.swift $(SRCROOT)/SwiftGenExample/Localization.swift</code> </pre> <br><p> 这些文件的指示是必需的，以便构建系统可以根据文件中是否存在更改以及在程序集的什么时候应执行此脚本来决定是否运行脚本。 </p><br><h2 id="itogi"> 总结 </h2><br><p> 在处理项目资源时，SwiftGen是防止我们粗心大意的好工具。 有了它，我们能够自动生成代码以访问应用程序资源，并把检查资源与编译器的相关性的部分工作转移到编译器上，这意味着可以简化我们的工作。 另外，我们设置了Xcode项目，以便进一步方便使用该工具。 </p><br><p>  <strong>优点：</strong> </p><br><ol><li> 更容易控制项目资源。 </li><li> 减少错字错误，可以使用自动替换。 </li><li> 在编译阶段检查错误。 </li></ol><br><p>  <strong>缺点：</strong> </p><br><ol><li> 不支持Localizable.stringsdict。 </li><li> 不考虑未使用的资源。 </li></ol><br><p> 完整的例子可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>上看到 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN423381/">https://habr.com/ru/post/zh-CN423381/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN423371/index.html">沃尔沃推出无驾驶室自动驾驶电动卡车</a></li>
<li><a href="../zh-CN423373/index.html">没有神经网络就没有致命缺陷的人工推理</a></li>
<li><a href="../zh-CN423375/index.html">韩国科学家找到了一种避免因等离子体不稳定而损坏托卡马克壁的方法</a></li>
<li><a href="../zh-CN423377/index.html">PgModeler程序集</a></li>
<li><a href="../zh-CN423379/index.html">为什么完全放弃现金对于发展中国家来说可能过于昂贵</a></li>
<li><a href="../zh-CN423383/index.html">Ajax Asp .net MVC的Ajax js修改</a></li>
<li><a href="../zh-CN423385/index.html">课程“编程基础”</a></li>
<li><a href="../zh-CN423391/index.html">CLRium＃4：.Net社区会议</a></li>
<li><a href="../zh-CN423393/index.html">基于规则的神经网络</a></li>
<li><a href="../zh-CN423395/index.html">特斯拉创电动车季度产量纪录</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>