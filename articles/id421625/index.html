<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧤 😠 🈹 Asynchronous Python: berbagai bentuk kompetisi 🍁 🎹 🗂️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dengan munculnya Python 3, ada sedikit desas-desus tentang "asinkronisme" dan "konkurensi", kita dapat mengasumsikan bahwa Python baru-baru ini memper...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Asynchronous Python: berbagai bentuk kompetisi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421625/">  Dengan munculnya Python 3, ada sedikit desas-desus tentang "asinkronisme" dan "konkurensi", kita dapat mengasumsikan bahwa Python baru-baru ini memperkenalkan fitur / konsep ini.  Tapi ini tidak benar.  Kami telah menggunakan operasi ini berkali-kali.  Selain itu, pemula mungkin berpikir bahwa asyncio adalah satu-satunya atau cara terbaik untuk membuat ulang dan menggunakan operasi asinkron / paralel.  Dalam artikel ini, kita akan melihat berbagai cara untuk mencapai paralelisme, kelebihan dan kekurangannya. <br><a name="habracut"></a><br><h4>  Definisi istilah: </h4><br>  Sebelum kita mempelajari aspek teknis, penting untuk memiliki pemahaman dasar tentang istilah yang sering digunakan dalam konteks ini. <br><br>  <b>Sinkron dan asinkron:</b> <br><br>  Dalam operasi <b>sinkron</b> , tugas dilakukan satu demi satu.  Dalam tugas-tugas tidak <b>sinkron</b> dapat dimulai dan diselesaikan secara independen satu sama lain.  Satu tugas tidak sinkron dapat mulai dan terus berjalan sementara eksekusi berpindah ke tugas baru.  Tugas asinkron <b>tidak</b> menghalangi (jangan memaksa untuk menunggu tugas selesai) operasi dan biasanya dilakukan di latar belakang. <br><br>  Misalnya, Anda harus menghubungi agen perjalanan untuk merencanakan liburan Anda berikutnya.  Anda perlu mengirim surat kepada penyelia Anda sebelum terbang.  Dalam mode sinkron, Anda pertama kali memanggil agen perjalanan, dan jika Anda diminta untuk menunggu, Anda akan menunggu sampai mereka menjawab Anda.  Kemudian Anda akan mulai menulis surat kepada pemimpin.  Dengan demikian, Anda menyelesaikan tugas satu demi satu.  <i>[eksekusi sinkron, kira-kira.</i>  <i>penerjemah]</i> Tetapi, jika Anda cerdas, mereka telah meminta Anda untuk menunggu <i>[tunggu telepon, kira-kira.</i>  <i>penerjemah]</i> Anda akan mulai menulis email dan ketika Anda berbicara lagi Anda akan berhenti menulis, berbicara, dan kemudian menambahkan surat itu.  Anda juga dapat meminta teman untuk menghubungi agensi dan menulis sendiri surat.  Ini asinkron, tugas tidak saling menghalangi. <br><br>  <b>Daya saing dan konkurensi:</b> <br><br>  Daya saing menyiratkan bahwa dua tugas dilakukan <u>bersama</u> .  Dalam contoh kami sebelumnya, ketika kami mempertimbangkan contoh asinkron, kami secara bertahap berkembang dalam menulis surat, kemudian dalam percakapan dengan tur.  agensi.  Ini adalah <b>daya saing</b> . <br><br>  Ketika kami meminta untuk menelepon seorang teman, dan menulis surat sendiri, tugas dilakukan <b>secara paralel</b> . <br><br>  Concurrency pada dasarnya adalah bentuk kompetisi.  Tetapi konkurensi bergantung pada perangkat keras.  Misalnya, jika CPU hanya memiliki satu inti, maka dua tugas tidak dapat dijalankan secara paralel.  Mereka hanya berbagi waktu prosesor di antara mereka sendiri.  Maka ini adalah kompetisi, tetapi tidak konkurensi.  Tetapi ketika kita memiliki beberapa inti <i>[sebagai teman dalam contoh sebelumnya, yang merupakan inti kedua, kira-kira.</i>  <i>translator]</i> kita dapat melakukan beberapa operasi (tergantung pada jumlah core) secara bersamaan. <br><br>  Untuk meringkas: <br><br><ul><li>  Sinkronisasi: memblokir operasi (pemblokiran) </li><li>  Asynchrony: tidak memblokir operasi (non-blocking) </li><li>  Daya saing: kemajuan bersama (joint) </li><li>  Konkurensi: kemajuan paralel (paralel) </li></ul><br>  Concurrency menyiratkan persaingan.  Tetapi persaingan tidak selalu menyiratkan konkurensi. <br><br><h4>  Thread dan proses </h4><br>  Python telah mendukung utas untuk waktu yang sangat lama.  Utas memungkinkan Anda untuk melakukan operasi secara kompetitif.  Tetapi ada masalah dengan <b>Global Interpreter Lock (GIL)</b> karena utas yang tidak dapat memberikan konkurensi sejati.  Namun, dengan munculnya <b>multiprocessing,</b> Anda dapat menggunakan beberapa core menggunakan Python. <br><br>  <b>Utas</b> <br><br>  Pertimbangkan sebuah contoh kecil.  Dalam kode berikut, fungsi <i>pekerja</i> akan dijalankan pada banyak utas secara serempak dan serempak. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> sleep = random.randrange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) time.sleep(sleep) print(<span class="hljs-string"><span class="hljs-string">"I am Worker {}, I slept for {} seconds"</span></span>.format(number, sleep)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): t = threading.Thread(target=worker, args=(i,)) t.start() print(<span class="hljs-string"><span class="hljs-string">"All Threads are queued, let's see when they finish!"</span></span>)</code> </pre> <br>  Dan berikut adalah contoh output: <br><br><pre> <code class="python hljs">$ python thread_test.py All Threads are queued, let<span class="hljs-string"><span class="hljs-string">'s see when they finish! I am Worker 1, I slept for 1 seconds I am Worker 3, I slept for 4 seconds I am Worker 4, I slept for 5 seconds I am Worker 2, I slept for 7 seconds I am Worker 0, I slept for 9 seconds</span></span></code> </pre><br>  Jadi, kami mulai 5 utas untuk kolaborasi dan setelah mulai (yaitu, setelah fungsi pekerja diluncurkan), operasi <b>tidak menunggu</b> utas selesai sebelum beralih ke pernyataan cetak berikutnya.  Ini adalah operasi yang tidak sinkron. <br><br>  Dalam contoh kami, kami meneruskan fungsi ke konstruktor Thread.  Jika kita mau, kita bisa mengimplementasikan subkelas dengan metode (gaya OOP). <br><br>  <u>Bacaan lebih lanjut:</u> <br><br>  Untuk mempelajari lebih lanjut tentang stream, gunakan tautan di bawah ini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pymotw.com/3/threading/index.html</a> </li></ul><br>  <b>Global Interpreter Lock (GIL)</b> <br><br>  GIL diperkenalkan untuk mempermudah penanganan memori CPython dan memberikan integrasi terbaik dengan C (mis. Dengan ekstensi).  GIL adalah mekanisme penguncian ketika interpreter Python hanya menjalankan satu utas pada satu waktu.  Yaitu  hanya satu utas yang dapat dieksekusi dalam bytecode Python sekaligus.  GIL memastikan bahwa banyak utas tidak dijalankan <b>secara paralel</b> . <br><br>  Rincian Cepat GIL: <br><br><ul><li>  Satu utas dapat berjalan sekaligus. </li><li>  Interpreter Python beralih di antara utas untuk mencapai daya saing. </li><li>  GIL berlaku untuk CPython (implementasi standar).  Tetapi seperti, misalnya, Jython dan IronPython tidak memiliki GIL. </li><li>  GIL membuat program single-threaded cepat. </li><li>  GIL biasanya tidak mengganggu I / O. </li><li>  GIL memudahkan untuk mengintegrasikan pustaka thread-safe ke dalam C, berkat GIL kami memiliki banyak ekstensi / modul berkinerja tinggi yang ditulis dalam C. </li><li>  Untuk tugas-tugas yang bergantung pada CPU, juru bahasa memeriksa setiap kutu N dan mengganti untaian.  Karenanya, satu utas tidak menghalangi yang lainnya. </li></ul><br>  Banyak yang melihat GIL sebagai kelemahan.  Saya menganggap ini sebagai berkah, karena perpustakaan seperti NumPy, SciPy diciptakan, yang menempati posisi khusus dan unik dalam komunitas ilmiah. <br><br>  <u>Bacaan lebih lanjut:</u> <br><br>  Sumber daya ini akan memungkinkan Anda mempelajari GIL: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.dabeaz.com/python/UnderstandingGIL.pdf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel ini dalam bahasa Rusia.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>[sekitar</i></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>penerjemah]</i></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sedikit lagi tentang GIL.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>[sekitar</i></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>penerjemah]</i></a> </li></ul><br>  <b>Proses</b> <br><br>  Untuk mencapai konkurensi dalam Python, modul <b>multiprocessing</b> telah ditambahkan yang menyediakan API dan terlihat sangat mirip jika Anda menggunakan <b>threading</b> sebelumnya. <br><br>  Mari kita pergi dan mengubah contoh sebelumnya.  Sekarang versi yang dimodifikasi menggunakan <b>Proses</b> alih-alih <b>Stream</b> . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> multiprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> sleep = random.randrange(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) time.sleep(sleep) print(<span class="hljs-string"><span class="hljs-string">"I am Worker {}, I slept for {} seconds"</span></span>.format(number, sleep)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): t = multiprocessing.Process(target=worker, args=(i,)) t.start() print(<span class="hljs-string"><span class="hljs-string">"All Processes are queued, let's see when they finish!"</span></span>)</code> </pre><br>  Apa yang berubah?  Saya baru saja mengimpor modul <b>multiprosesing</b> alih-alih <b>threading</b> .  Dan kemudian, alih-alih utas, saya menggunakan proses.  Itu saja!  Sekarang, alih-alih banyak utas, kami menggunakan proses yang berjalan pada core CPU yang berbeda (kecuali, tentu saja, prosesor Anda memiliki beberapa core). <br><br>  Menggunakan kelas Pool, kita juga dapat mendistribusikan eksekusi satu fungsi antara beberapa proses untuk nilai input yang berbeda.  Contoh dari dokumen resmi: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> multiprocessing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pool <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x*x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: p = Pool(<span class="hljs-number"><span class="hljs-number">5</span></span>) print(p.map(f, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]))</code> </pre><br>  Di sini, alih-alih mengulangi daftar nilai dan memanggil fungsi satu per satu, kita sebenarnya menjalankan fungsi dalam proses yang berbeda.  Satu proses tidak f (1), yang lain f (2), dan yang lain f (3).  Akhirnya, hasilnya digabungkan lagi menjadi daftar.  Ini memungkinkan kami untuk memecah perhitungan berat menjadi bagian-bagian yang lebih kecil dan menjalankannya secara paralel untuk perhitungan yang lebih cepat. <br><br>  <u>Bacaan lebih lanjut:</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pymotw.com/3/multiprocessing/index.html</a> </li></ul><br>  <b>Modul Concurrent.futures</b> <br><br>  Modul concurrent.futures berukuran besar dan membuat penulisan kode asinkron sangat mudah.  Favorit saya adalah <b>ThreadPoolExecutor</b> dan <b>ProcessPoolExecutor</b> .  Seniman-seniman ini mendukung kumpulan benang atau proses.  Kami mengirim tugas kami ke kumpulan, dan menjalankan tugas dalam utas / proses yang dapat diakses.  Objek <b>Masa Depan</b> dikembalikan, yang dapat digunakan untuk kueri dan mendapatkan hasil saat tugas selesai. <br><br>  Dan berikut ini adalah contoh ThreadPoolExecutor: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> concurrent.futures <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ThreadPoolExecutor <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sleep <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_after_5_secs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message)</span></span></span><span class="hljs-function">:</span></span> sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message pool = ThreadPoolExecutor(<span class="hljs-number"><span class="hljs-number">3</span></span>) future = pool.submit(return_after_5_secs, (<span class="hljs-string"><span class="hljs-string">"hello"</span></span>)) print(future.done()) sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>) print(future.done()) print(future.result())</code> </pre><br>  Saya punya artikel tentang concurrent.futures <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html</a> .  Ini dapat bermanfaat untuk mempelajari modul ini lebih dalam. <br><br>  <u>Bacaan lebih lanjut:</u> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pymotw.com/3/concurrent.futures</a> </li></ul><br><h4>  Asyncio - apa, bagaimana dan mengapa? </h4><br>  Anda mungkin memiliki pertanyaan yang dimiliki banyak orang di komunitas Python - apa yang dibawa asyncio baru?  Mengapa ada cara lain untuk menggunakan I / O asinkron?  Bukankah kita sudah memiliki utas dan proses?  Ayo lihat! <br><br>  <b>Mengapa kita perlu asyncio?</b> <br><br>  Prosesnya sangat mahal <i>[dalam hal konsumsi sumber daya, kira-kira.</i>  <i>penerjemah]</i> untuk membuat.  Oleh karena itu, untuk operasi I / O, utas terutama dipilih.  Kita tahu bahwa I / O tergantung pada hal-hal eksternal - drive lambat atau kelambatan jaringan yang tidak menyenangkan membuat I / O sering tidak dapat diprediksi.  Sekarang anggaplah kita menggunakan utas untuk I / O.  3 utas melakukan berbagai tugas I / O.  Penerjemah harus beralih di antara arus kompetitif dan memberi mereka masing-masing waktu.  Sebut arus T1, T2, dan T3.  Tiga utas memulai operasi I / O mereka.  T3 menyelesaikannya terlebih dahulu.  T2 dan T1 masih menunggu I / O.  Penerjemah Python beralih ke T1, tetapi masih menunggu.  Nah, penerjemah pindah ke T2, dan penerjemah masih menunggu, dan kemudian pindah ke T3, yang siap dan menjalankan kode.  Apakah Anda melihat ini sebagai masalah? <br><br>  T3 sudah siap, tetapi penerjemah pertama kali beralih antara T2 dan T1 - ini biaya pengalihan, yang bisa kita hindari jika penerjemah pertama kali beralih ke T3, kan? <br><br>  <b>Apa itu asynio?</b> <br><br>  Asyncio menyediakan bagi kita loop acara bersama dengan hal-hal keren lainnya.  Event loop memonitor I / O events dan mengganti tugas yang siap dan menunggu operasi I / O <i>[loop event adalah sebuah konstruksi perangkat lunak yang menunggu kedatangan dan mengirimkan acara atau pesan dalam program, kira-kira.</i>  <i>penerjemah]</i> . <br><br>  Idenya sangat sederhana.  Ada loop acara.  Dan kami memiliki fungsi yang melakukan asynchronous I / O.  Kami mentransfer fungsi kami ke loop acara dan memintanya untuk menjalankannya untuk kami.  Loop acara mengembalikan kita objek Masa Depan, seperti janji bahwa di masa depan kita akan mendapatkan sesuatu.  Kami berpegang pada janji, memeriksa dari waktu ke waktu apakah itu penting (kami benar-benar tidak bisa menunggu), dan akhirnya, ketika nilainya diterima, kami menggunakannya dalam beberapa operasi lain <i>[mis.</i>  <i>kami mengirim permintaan, kami segera diberi tiket dan disuruh menunggu sampai hasilnya datang.</i>  <i>Kami memeriksa hasilnya secara berkala dan begitu diterima, kami menerima tiket dan mendapatkan nilai, kira-kira.</i>  <i>penerjemah]</i> . <br><br>  Asyncio menggunakan generator dan coroutine untuk berhenti dan melanjutkan tugas.  Anda dapat membaca detailnya di sini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masnun.com/2015/11/20/python-asyncio-future-task-and-the-event-loop.html</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masnun.com/2015/11/13/python-generators-coroutines-native-coroutines-and-async-await.html</a> </li></ul><br>  <b>Bagaimana cara menggunakan asyncio?</b> <br><br>  Sebelum kita mulai, mari kita lihat sebuah contoh: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> datetime <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_sleep_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display_date</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num, loop)</span></span></span><span class="hljs-function">:</span></span> end_time = loop.time() + <span class="hljs-number"><span class="hljs-number">50.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Loop: {} Time: {}"</span></span>.format(num, datetime.datetime.now())) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loop.time() + <span class="hljs-number"><span class="hljs-number">1.0</span></span>) &gt;= end_time: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> my_sleep_func() loop = asyncio.get_event_loop() asyncio.ensure_future(display_date(<span class="hljs-number"><span class="hljs-number">1</span></span>, loop)) asyncio.ensure_future(display_date(<span class="hljs-number"><span class="hljs-number">2</span></span>, loop)) loop.run_forever()</code> </pre><br>  Perhatikan bahwa sintaks async / await hanya untuk Python 3.5 dan yang lebih baru.  Mari kita lihat kodenya: <br><br><ul><li>  Kami memiliki fungsi display_date asynchronous yang mengambil angka (sebagai pengidentifikasi) dan loop acara sebagai parameter. </li><li>  Fungsi ini memiliki loop tak terbatas, yang terputus setelah 50 detik.  Tetapi selama periode ini, dia berulang kali mencetak waktu dan berhenti.  Fungsi menunggu dapat menunggu untuk menyelesaikan fungsi asinkron lainnya (coroutine). </li><li>  Kami meneruskan fungsi ke loop acara (menggunakan metode sure_future). </li><li>  Kami memulai siklus acara. </li></ul><br>  Setiap kali menunggu dipanggil, asyncio menyadari bahwa fungsi tersebut mungkin akan memakan waktu.  Dengan demikian, itu menjeda eksekusi, mulai memonitor semua peristiwa I / O yang terkait dengannya, dan memungkinkan Anda untuk menjalankan tugas.  Ketika asyncio memperhatikan bahwa fungsi I / O yang dijeda sudah siap, ia melanjutkan fungsinya. <br><br><h4>  Membuat pilihan yang tepat. </h4><br>  Kami baru saja melalui bentuk daya saing yang paling populer.  Tetapi pertanyaannya tetap - apa yang harus dipilih?  Itu tergantung pada kasus penggunaan.  Dari pengalaman saya, saya cenderung mengikuti pseudo-code ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> io_bound: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> io_very_slow: print(<span class="hljs-string"><span class="hljs-string">"Use Asyncio"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Use Threads"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Multi Processing"</span></span>)</code> </pre><br><ul><li>  CPU Bound =&gt; Pemrosesan Multi </li><li>  I / O Bound, I / O Cepat, Jumlah Koneksi Terbatas =&gt; Multi Threading </li><li>  I / O Bound, I / O Lambat, Banyak koneksi =&gt; Asyncio </li></ul><br>  <i>[Catatan</i>  <i>penerjemah]</i> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kuliah (presentasi) dalam bahasa Rusia tentang multithreading dan GIL.</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421625/">https://habr.com/ru/post/id421625/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421607/index.html">“Kami bahkan tidak mencoba menjalankan kode lama, kami pada prinsipnya tidak memiliki tugas seperti itu” - Roman Elizarov tentang pengembangan Kotlin</a></li>
<li><a href="../id421611/index.html">Bagaimana World of Warcraft diciptakan: pandangan ke dalam pada 20 tahun pembangunan</a></li>
<li><a href="../id421613/index.html">Bagaimana kami menulis artikel tentang Habr: pengalaman pengembang EastBanc Technologies</a></li>
<li><a href="../id421615/index.html">Solusi untuk kurangnya prevProps di getDerivedStateFromProps</a></li>
<li><a href="../id421619/index.html">Sistem otonom masa depan. Klasifikasi, fitur dan persyaratan</a></li>
<li><a href="../id421629/index.html">Apakah robot akan mengambil pekerjaan saya? (Dan jika saya seorang humanis?)</a></li>
<li><a href="../id421631/index.html">Tinjau Notebook Lenovo ThinkPad X1 Carbon (2018): ringan, nyaman, kuat</a></li>
<li><a href="../id421633/index.html">Cara membuat standar dalam 10 hari</a></li>
<li><a href="../id421637/index.html">Arloji anak-anak dengan GPS pada 1 September: apa yang dapat Anda perhatikan</a></li>
<li><a href="../id421639/index.html">Laptop Cina Jumper EZBook X4 - keyboard backlit dan platform Danau Gemini yang baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>