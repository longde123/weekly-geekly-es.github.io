<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕔 ⬛️ 🙉 Write Telegram Client - Einfach 👨🏿‍🤝‍👨🏽 🧜🏻 🎺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was ist der Unterschied zwischen Telegramm und anderen beliebten Boten? Er ist offen! 
 Andere Messenger haben ebenfalls eine API, aber ist das Telegr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Write Telegram Client - Einfach</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424245/"><p><img src="https://habrastorage.org/webt/74/05/en/7405endgngr3x59c7slog56gha0.png"></p><br><p>  Was ist der Unterschied zwischen Telegramm und anderen beliebten Boten?  Er ist offen! <br>  Andere Messenger haben ebenfalls eine API, aber ist das Telegramm aus irgendeinem Grund als das offenste der beliebtesten bekannt? </p><br><p>  Zunächst hat Telegram einen wirklich vollständig offenen Client <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> .  Leider sehen wir nicht jeden Tag Commits direkt auf GitHub, aber wir haben einen Code unter einer offenen Lizenz.  Die Telegrammarchitektur impliziert, dass sowohl Bot als auch API fast dieselben Methoden haben - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://core.telegram.org/methods</a> . </p><br><p>  Tatsächlich ist Telegram nicht nur ein Chat-Messenger, sondern eine soziale Plattform, auf die für verschiedene Arten von Anwendungen zugegriffen werden kann.  Sie können Benutzern zusätzliche Chips bereitstellen, anstatt ein vorgefertigtes Netzwerk von Benutzern und Servern für die Nachrichtenübermittlung zu verwenden.  Es klingt so attraktiv, dass wir versuchen wollten, unseren „Client“ für Telegramme zu schreiben. </p><a name="habracut"></a><br><h3 id="sut-prilozheniya">  Das Wesentliche der Anwendung </h3><br><p>  Wir beschäftigen uns hauptsächlich mit Karten und Navigation, daher haben wir uns sofort mit Geolokalisierung befasst.  Es hat mir sehr gut gefallen, dass es in Telegram vor allen anderen Anwendungen eine bequeme Möglichkeit gab, Ihren Standort in Echtzeit zu teilen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://telegram.org/blog/live-locations</a> ), und ich verwende ihn häufig: Helfen Sie mir, mich zu orientieren, zeigen Sie meinen Weg und Das Wichtigste ist, die Hauptfrage "Wann wirst du sein?" zu beantworten.  Im Prinzip reicht dies für die meisten Menschen aus, aber wie immer gibt es Szenarien, in denen einfache Möglichkeiten nicht ausreichen.  Beispielsweise kann es sich um eine Gruppe von mehr als 10 Personen mit unterschiedlichen Geräten (einige Geräte sind möglicherweise keine Telefone) und unterschiedlichen Personen handeln.  Für diese Personen wäre es praktisch, Nachrichten in einer Gruppe auszutauschen und sich gegenseitig auf einer Karte zu sehen. </p><br><p>  Wir haben uns auf die Aufgabe konzentriert, zusätzlichen Wert für Telegramm zu schaffen und nicht zu versuchen, ihn für andere Zwecke zu verwenden.  Wir wollten nicht, dass Leute, die keinen speziellen Telegramm-Client hatten, im Chat ein Durcheinander von Nachrichten oder etwas Unverständliches sehen.  Menschen mit einem "verbesserten" Kunden haben zusätzliche Möglichkeiten, zum Beispiel: </p><br><ol><li>  Feinere Zeitverwaltung beim Senden von Standorten in Echtzeit zum Chatten. </li><li>  Zeigen Sie den Standort der Kontakte auf der Karte an. </li><li>  Herstellen einer Verbindung zum Chat von Beacon-Geräten über eine externe API (Bot). </li></ol><br><h3 id="kak-my-eto-delali">  Wie haben wir das gemacht? </h3><br><p>  Glücklicherweise ist der gesamte Code, den wir schreiben, Open Source, sodass ich sofort einen Link zu seiner Implementierung geben kann - <a href="">Bot-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegramm-Client-Implementierung auf Kotlin</a> . </p><br><h5 id="bot---osnovy">  Bot - die Grundlagen </h5><br><p>  Es gibt viele Dokumentationen und Beispiele zur Implementierung von Bot, aber ich möchte trotzdem noch einmal auf einige der Fallstricke eingehen.  Zunächst haben wir die Serverseite geschrieben <br>  in Java und wählte die org.telegram Bibliothek: telegrambots.  Da es sich bei unserem Server um einen regulären SpringBoot handelt, ist die Initialisierung äußerst einfach: </p><br><pre><code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Gradle implementation <span class="hljs-string"><span class="hljs-string">"org.telegram:telegrambots:3.6"</span></span> TelegramBotsApi telegramBotsApi = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TelegramBotsApi(); telegramBotsApi.registerBot(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TelegramLongPollingBot() {...});</code> </pre> <br><p>  Das Hauptmerkmal der Standortübertragung ist, dass sie regelmäßig aktualisiert werden muss und der Bot bereits gesendete Nachrichten bearbeiten muss.  Wenn es keine solche Gelegenheit gäbe, würde Bot den Chat nur als Spam versenden und natürlich wäre es Epic Fail.  Gott sei Dank Telegramm gibt dem Bot das Recht, Nachrichten für 24 Stunden zu bearbeiten (Minimum, möglicherweise länger). </p><br><p>  Es gibt viele Möglichkeiten, eine Nachricht zu senden.  Es gibt den Typ Nur Text, Veranstaltungsort, Ort, Spiel, Kontakt, Rechnung usw.  Es schien, dass die Lage perfekt für unsere Aufgabe war, aber ein unangenehmes Merkmal wurde aufgedeckt.  Der Standort kann jeweils nur von einem Gerät auf ein Konto oder einen Bot übertragen werden!  Stellen Sie sich vor, Sie haben zwei Telefone und von zwei Telefonen aus haben Sie Ihren Standort in einem Chat gesendet.  Auf dem Server tritt also ein Fehler auf und die erste Standortfreigabe wird einfach gestoppt.  Es scheint, dass dies eindeutig ein neuronaler Fall ist, aber stellen Sie sich vor, Sie haben viele chinesische Beacons, die Location an eine bestimmte URL senden können, aber nicht direkt an Telegram.  Sie schreiben Bot, der vom Server abholt und Telegramme sendet.  Hier stellt sich heraus, dass Bot nicht mehr als eine Beacon-Nachricht mit dem Standorttyp senden kann.  Es stellt sich heraus, dass dies ideal für das einmalige Senden ist, aber nicht für den Live-Standort geeignet. </p><br><p>  Die Lösung ist einfach: Senden Sie Textnachrichten, und der Client analysiert den Text und zeigt die Positionen auf der Karte an.  Leider werden im Standard-Telegramm-Client nur Textnachrichten angezeigt, aber Sie können dort einen Link einfügen, um die Karte zu öffnen. </p><br><h5 id="bot---podvodnye-kamni">  Bot - Fallstricke </h5><br><p>  Leider musste Bot bis zu 2,5 Mal umschreiben.  Das Hauptproblem ist das falsche Design der Kommunikation. </p><br><ol><li>  Aus irgendeinem Grund schien es zunächst eine gute Idee zu sein, ob der Bot ein vollwertiger Teilnehmer am Chat sein und Nachrichten senden würde.  Dies ist jedoch sowohl in Bezug auf die Privatsphäre der Korrespondenz als auch in Bezug auf die Interaktion mit dem Bot schlecht.  Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inline-Bots</a> , um die richtige Entscheidung zu treffen.  Somit ist garantiert, dass der Bot nichts anderes als seinen Standort sieht und in jedem Chat verwendet werden kann.  Menschlich gesehen ist es unkulturell, Ihren Bot in eine Art allgemeinen Chat zu ziehen, aber Sie müssen eins zu eins mit dem Bot sprechen und ihn konfigurieren, damit er die erforderlichen Nachrichten an jeden ausgewählten Chat senden kann. </li><li>  In der Telegrammnachrichten-API gibt es in der Vergangenheit zwei Arten von Interaktionen: Schaltflächen unter dem Text ((Inline-Schaltflächen) [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://core.telegram.org/bots/2-0-intro#switch-to-inline-buttons</a> ]) und direkte Antworten auf den Bot Text.  Im Allgemeinen sind die Antworten mit dem Bot hoffnungslos veraltet.  Schaltflächen sind aus Sicht der Implementierung etwas komplizierter, dies wird jedoch durch die Benutzerfreundlichkeit vollständig bezahlt und sollten für alle Nicht-Texteingaben verwendet werden. </li><li>  Als Beispiel für einen Bot sehen Sie den beliebten @vote_bot oder unseren @osmand_bot. </li></ol><br><h5 id="telegram-client">  Telegramm-Client </h5><br><p>  Wir konnten keine Beispiele für einen vorgefertigten Telegramm-Client finden, außer für den Haupt-Client, aber die recht einfache tdlib-Struktur half uns, den Basis-Client in nur wenigen Tagen zu erstellen. </p><br><div class="spoiler">  <b class="spoiler_title">Gradle-Setup:</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">task downloadTdLibzip { doLast { ant.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(src: <span class="hljs-string"><span class="hljs-string">'https://core.telegram.org/tdlib/tdlib.zip'</span></span>, dest: <span class="hljs-string"><span class="hljs-string">'tdlib.zip'</span></span>, skipexisting: <span class="hljs-string"><span class="hljs-string">'true'</span></span>) ant.unzip(src: <span class="hljs-string"><span class="hljs-string">'tdlib.zip'</span></span>, dest: <span class="hljs-string"><span class="hljs-string">'tdlib/'</span></span>) } } task copyNativeLibs(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Copy</span></span>) { dependsOn downloadTdLibzip <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "tdlib/libtd/src/main/libs" <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> "libs" } task copyJavaSources(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">Copy</span></span>) { dependsOn downloadTdLibzip <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "tdlib/libtd/src/main/java/org/drinkless/td" <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> "src/org/drinkless/td" } dependencies { implementation fileTree(dir: <span class="hljs-string"><span class="hljs-string">'libs'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>: [<span class="hljs-string"><span class="hljs-string">'*.jar'</span></span>]) }</code> </pre> </div></div><br><p>  Fast alle Interna des Telegramms sind in C ++ geschrieben und aus Sicht von Android ist auf den 1,5-MB-Proxy-Methoden <a href="">TdApi.java</a> nur die API-Klasse sichtbar.  Durch Vergleichen der Dokumentation der Bots und des Namens der Methoden können Sie einfach herausfinden, wohin Sie sich bewegen müssen. </p><br><div class="spoiler">  <b class="spoiler_title">Kundeninitialisierung mit globalem Handler:</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (libraryLoaded) { <span class="hljs-comment"><span class="hljs-comment">// create client client = Client.create(UpdatesHandler(), null, null) true } else { false } }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Benutzerfotoanfrage:</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestUserPhoto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">TdApi</span></span></span></span><span class="hljs-function"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">User</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> remotePhoto = user.profilePhoto?.small?.remote <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remotePhoto != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; remotePhoto.id.isNotEmpty()) { downloadUserFilesMap[remotePhoto.id] = user client!!.send(TdApi.GetRemoteFile(remotePhoto.id, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) { obj -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (obj.<span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>) { TdApi.Error.CONSTRUCTOR -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> error = obj <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TdApi.Error <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> code = error.code <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (code != IGNORED_ERROR_CODE) { listener?.onTelegramError(code, error.message) } } TdApi.File.CONSTRUCTOR -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> file = obj <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TdApi.File client!!.send(TdApi.DownloadFile(file.id, <span class="hljs-number"><span class="hljs-number">10</span></span>), defaultHandler) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; listener?.onTelegramError(-<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"Receive wrong response from TDLib: </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$obj</span></span></span><span class="hljs-string">"</span></span>) } } } }</code> </pre> </div></div><br><h5 id="telegram-client---podvodnye-kamni">  Telegramm-Client - Fallstricke </h5><br><ol><li>  Registrierung / Login und Logout.  Bei der Registrierung müssen verschiedene Szenarien berücksichtigt werden: Wenn der Zugangscode per SMS oder an einen anderen Telegramm-Client gesendet wird, Zwei-Faktor-Autorisierung usw.  Die größte Herausforderung ist das Testen.  Jede Autorisierung, die mehr als dreimal durchgeführt wurde, führte zu einer Sperrung des Kontos für 24 Stunden. Daher hat das Testen der Abmeldung besonders viel Spaß gemacht.  Trotz der Tatsache, dass eine Registrierung nur einmal erforderlich ist, ist dies wahrscheinlich der schwierigste Teil der Integration. </li><li>  Bestimmen Sie, wie und in welcher Reihenfolge Nachrichten gelesen werden sollen.  Jeder Client hat Zugriff auf alle Nachrichten in allen Chats, diese müssen jedoch nacheinander ausgelesen werden.  In unserem Fall müssen 99% der Nachrichten verworfen werden.  Zuerst haben wir aus irgendeinem Grund alle Nachrichten der letzten 3 Tage mit einem Login gelesen, aber später verursachte dies nur Probleme und beim Neustart verschwanden die Nachrichten.  Daher lesen wir jetzt nur neue Nachrichten und speichern für die Nachrichten, die wir benötigen, die ID in der internen Datenbank. </li></ol><br><h3 id="chto-poluchilos">  Was ist passiert? </h3><br><p>  Wenn man alle Fallstricke kennt, kann man wahrscheinlich alles um ein Vielfaches schneller machen, aber für drei Personen stellte sich heraus, dass es ungefähr 1-2 Monate waren.  Die endgültige App finden Sie bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Play</a> . </p><br><p><img src="https://habrastorage.org/webt/gf/o0/zs/gfo0zsgavbn09pkswyzurjoibik.png"></p><br><p>  Die Hauptfrage in dieser Geschichte ist, wie korrekt diese Interaktion aus Sicht des Telegramms ist und ob Benutzer diese Art der Integration mögen.  In jedem Fall ist die Idee selbst eine Nische und hat bereits einzelne Kunden gefunden. </p><br><p>  Gerne beantworte ich Ihre Fragen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424245/">https://habr.com/ru/post/de424245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424235/index.html">Verwendung von STATSPACK anstelle von AWR in Oracle Standard Edition</a></li>
<li><a href="../de424237/index.html">Laden Sie Ihr Gehirn direkt auf! Laufzeit, Compiler und Performance bei Joker 2018</a></li>
<li><a href="../de424239/index.html">IBM Herbstseminare - Container, Computer Vision, Digitale Transformation</a></li>
<li><a href="../de424241/index.html">Drucken Sie Ihre Welt</a></li>
<li><a href="../de424243/index.html">5 einfache Möglichkeiten zur Verbesserung der Kommunikation mit Kunden</a></li>
<li><a href="../de424247/index.html">KotlinConf 2018 Live - Sehen Sie sich die Sendung vom 4. bis 5. Oktober an</a></li>
<li><a href="../de424249/index.html">Materialien vom Treffen #RuPostgres - Videos, Präsentationen, Analyse des Quiz und Fotobericht</a></li>
<li><a href="../de424251/index.html">Wir betrachten Statistiken über Experimente auf hh.ru.</a></li>
<li><a href="../de424255/index.html">So verwenden Sie die statische Analyse richtig</a></li>
<li><a href="../de424257/index.html">Sechseckkarten in Einheit: Teile 1-3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>