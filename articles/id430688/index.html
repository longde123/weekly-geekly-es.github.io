<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ•ºğŸ¾ ğŸŒ¸ Transfer data melalui animasi QR ke Gomobile dan GopherJS ğŸ‘¨ğŸ¼â€ğŸ¤ ğŸ¦‰ â—</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini saya ingin berbicara tentang proyek akhir pekan yang kecil dan lucu untuk mentransfer file melalui kode QR animasi. Proyek ini dituli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transfer data melalui animasi QR ke Gomobile dan GopherJS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430688/"><p> Pada artikel ini saya ingin berbicara tentang proyek akhir pekan yang kecil dan lucu untuk mentransfer file melalui kode QR animasi.  Proyek ini ditulis dalam Go, menggunakan Gomobile dan Gopherjs - yang terbaru untuk aplikasi web untuk secara otomatis mengukur kecepatan transfer data.  Jika Anda tertarik dengan gagasan mentransmisikan data melalui kode visual, kembangkan aplikasi web bukan pada JS atau lintas platform nyata Go - to Wellcome to Cat. </p><br><p><img src="https://habrastorage.org/webt/2p/zg/t_/2pzgt_2anc92t0udxgl3cnt3xy0.gif" alt="demo txqr"></p><a name="habracut"></a><br><p>  Gagasan proyek ini lahir dari tugas khusus untuk aplikasi seluler - cara mentransfer sebagian kecil data (~ 15KB) ke perangkat lain yang paling sederhana dan cepat, dalam kondisi pemblokiran jaringan.  Pikiran pertama adalah menggunakan Bluetooth, tetapi tampaknya tidak senyaman - proses yang relatif lama dan tidak selalu berfungsi untuk mendeteksi dan memasangkan perangkat terlalu sulit untuk tugas tersebut.  Ide yang bagus adalah menggunakan NFC (Near Field Communication), tetapi masih terlalu banyak perangkat yang dukungan NFCnya terbatas atau tidak ada sama sekali.  Kami membutuhkan sesuatu yang lebih sederhana dan lebih terjangkau. </p><br><p>  Bagaimana dengan kode QR? </p><br><h1 id="qr-kody">  Kode QR </h1><br><p>  Kode QR (Respon Cepat) adalah jenis kode visual paling populer di dunia.  Ini memungkinkan Anda untuk menyandikan hingga 3KB data sewenang-wenang dan memiliki berbagai tingkat koreksi kesalahan, memungkinkan Anda untuk percaya diri membaca bahkan sepertiga dari kode yang tertutup atau kotor. </p><br><p>  Tetapi dengan kode QR ada dua masalah: </p><br><ul><li>  3KB tidak cukup </li><li>  semakin banyak data yang disandikan, semakin tinggi persyaratan kualitas gambar yang akan dipindai </li></ul><br><p>  Berikut adalah kode QR dari versi ke-40 (kepadatan perekaman tertinggi) dengan 1.276 byte: </p><br><p><img src="https://habrastorage.org/webt/wp/r1/mp/wpr1mp7p-uz4vzzssaai5zp8v44.gif" alt="qrv40"></p><br><p>  Untuk tugas saya, saya perlu belajar cara mentransfer ~ 15KB data pada perangkat standar (smartphone / tablet), jadi pertanyaannya muncul dengan sendirinya - mengapa tidak menganimasikan urutan kode QR dan mentransfer data dalam beberapa bagian? </p><br><p>  Pencarian cepat dari implementasi yang sudah jadi mengarah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seperti itu</a> - terutama proyek hackathon (walaupun ada juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tesis</a> ) - tetapi semuanya ditulis dalam Java, Python atau JavaScript, yang, sayangnya, membuat kode praktis tidak dapat diakses dan tidak digunakan.  Tetapi mengingat popularitas besar kode QR dan kompleksitas teknis yang rendah dari ide tersebut, diputuskan untuk menulis dari awal di Go - sebuah lintas-platform, bahasa yang mudah dibaca dan cepat.  Biasanya, cross-platform menyiratkan kemampuan untuk membangun kode biner untuk Windows, Mac dan Linux, tetapi dalam kasus saya itu juga penting untuk membangunnya untuk web (gopherjs) dan untuk sistem seluler (iOS / Android).  Go memberikan semuanya di luar kotak dengan biaya minimal. </p><br><p>  Saya juga mempertimbangkan opsi alternatif untuk kode visual - seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HCCB</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JAB Code</a> , tetapi bagi mereka saya harus menulis pemindai OpenCV, mengimplementasikan encoder / decoder dari awal dan ini terlalu banyak untuk proyek selama satu minggu.  Kode QR <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bulat</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shotcodes</a> ), dan rekan-rekan mereka yang digunakan di Facebook, Kik dan Snapchat, memungkinkan Anda untuk menyandikan informasi yang jauh lebih sedikit, dan pendekatan paten Apple yang sangat keren untuk memasangkan Apple Watch dan iPhone - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">awan animasi partikel warna-warni</a> - juga dioptimalkan untuk efek wow, dan tidak di bawah bandwidth maksimum.  Kode QR diintegrasikan ke dalam kamera SDK asli OS mobile, yang sangat memudahkan pekerjaan dengan mereka. </p><br><h1 id="txqr">  TXQR </h1><br><p>  Jadi proyek <em>txqr</em> lahir (dari Tx - transmission, dan QR), yang mengimplementasikan perpustakaan untuk encoding / decoding QR pada Go murni dan protokol untuk mentransmisikan data. </p><br><p>  Gagasan utamanya adalah sebagai berikut: satu klien memilih file atau data yang akan dikirim, program pada perangkat memecah file menjadi potongan-potongan, mengkodekan masing-masing ke dalam frame QR dan menunjukkan mereka dalam loop tanpa akhir dengan frame rate yang diberikan sampai penerima menerima semua data.  Protokol dibuat sedemikian rupa sehingga penerima dapat mulai dari bingkai apa pun, menerima bingkai QR dalam urutan apa pun - ini menghilangkan kebutuhan untuk menyinkronkan frekuensi animasi dan frekuensi pemindaian.  Penerima dapat berupa perangkat lama, yang kekuatannya memungkinkan Anda untuk memecahkan kode 2 frame per detik, dan pengirim dengan smartphone baru yang menghasilkan animasi 120Hz, atau sebaliknya, dan ini tidak akan menjadi masalah mendasar untuk protokol. </p><br><p> Ini dicapai sebagai berikut - ketika file dibagi menjadi beberapa bagian ( <em>frame</em> lebih lanjut), awalan dengan informasi tentang offset relatif terhadap semua data dan total panjang - <code>OFFSET/TOTAL|</code>  (di mana OFFSET dan TOTAL masing-masing adalah nilai integer offset dan panjang).  Data biner masih dikodekan dalam Base64, tetapi ini tidak benar-benar diperlukan - spesifikasi QR memungkinkan tidak hanya untuk menyandikan data sebagai biner, tetapi juga untuk mengoptimalkan berbagai bagian data untuk pengkodean yang berbeda (misalnya, awalan dengan perubahan kecil dapat dikodekan sebagai <em>alfanumerik</em> , dan seluruh konten - seperti <em>biner</em> ), tetapi untuk kesederhanaan, Base64 menjalankan fungsinya dengan sempurna. </p><br><p>  Selain itu, ukuran dan frekuensi bingkai bahkan dapat diubah secara dinamis, beradaptasi dengan kemampuan penerima. </p><br><p><img src="https://habrastorage.org/webt/qm/7g/dg/qm7gdgycvmlhgjflhc_xudrfeu8.png" alt="protokol"></p><br><p>  Protokol itu sendiri sangat sederhana, dan minus utamanya adalah untuk file-file besar (walaupun ini di luar lingkup tugas, tetapi masih), satu frame yang dilewati selama pemindaian akan menggandakan waktu pemindaian - penerima harus menunggu siklus penuh lagi.  Dalam teori pengkodean ada solusi untuk kasus-kasus seperti - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode air mancur</a> , tapi saya akan meninggalkan ini untuk beberapa hari libur berikut. </p><br><p>  Poin paling menarik adalah menulis aplikasi seluler yang bisa menggunakan protokol ini. </p><br><h2 id="gomobile">  Gomobile </h2><br><p>  Jika Anda belum pernah mendengar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gomobile</a> , maka ini adalah proyek yang memungkinkan Anda untuk menggunakan Go libraries di proyek iOS dan Android dan menjadikannya prosedur sederhana yang cabul. </p><br><p>  Proses standar adalah sebagai berikut: </p><br><ul><li>  Anda menulis kode Go biasa </li><li>  jalankan <code>gomobile bind ...</code> </li><li>  salin artefak (s) yang <code>yourpackage.framework.</code> ( <code>yourpackage.framework.</code> atau <code>yourpackage.aar</code> ) ke proyek seluler Anda </li><li>  impor <code>yourpackage</code> dan bekerja dengannya seperti dengan perpustakaan biasa </li></ul><br><p>  Anda dapat mencoba betapa mudahnya itu. </p><br><p>  Oleh karena itu, saya segera menulis aplikasi pada Swift yang memindai kode QR (terima kasih untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang luar biasa ini</a> ) dan menerjemahkannya, menempelkannya bersama-sama, dan ketika seluruh file diterima, menunjukkannya di jendela pratinjau. </p><br><p>  Sebagai pemula untuk Swift (meskipun saya membaca buku Swift 4), ada beberapa saat ketika saya terjebak pada sesuatu yang sederhana, mencoba mencari cara untuk melakukannya dengan benar dan, pada akhirnya, solusi terbaik adalah untuk mengimplementasikan fungsi ini di Go dan gunakan via gomobile.  Jangan salah paham, Swift dalam banyak hal merupakan bahasa yang luar biasa, tetapi, seperti kebanyakan bahasa pemrograman lainnya, Swift menyediakan terlalu banyak cara untuk melakukan hal yang sama, dan sudah memiliki riwayat perubahan yang tidak kompatibel yang terbelakang.  Sebagai contoh, saya perlu melakukan hal sederhana - untuk mengukur durasi acara dengan akurasi milidetik.  Pencarian di Google dan StackOverflow mengarah ke sejumlah solusi yang berbeda, saling bertentangan, dan sering usang, tidak ada yang, pada akhirnya, tampak indah untuk saya atau tepat untuk kompiler.  Setelah menghabiskan waktu 40 menit, saya hanya membuat metode lain dalam paket Go yang disebut waktu. <code>time.Since(start) / time.Millisecond</code> dan menggunakan hasilnya dari Swift secara langsung. </p><br><p>  Saya juga menulis utilitas konsol <code>txqr-ascii</code> untuk pengujian aplikasi cepat.  Ini mengkodekan file dan menjiwai kode QR di terminal.  Semuanya bekerja dengan sangat baik - saya dapat mengirim gambar kecil dalam beberapa detik, tetapi segera setelah saya mulai menguji nilai frame rate yang berbeda, jumlah byte di setiap frame QR dan tingkat koreksi kesalahan pada encoder QR, menjadi jelas bahwa solusi terminal tidak berupaya dengan frekuensi tinggi (lebih dari 10) dari animasi, dan bahwa menguji dan mengukur hasilnya secara manual adalah hal yang berbahaya. </p><br><h1 id="txqr-tester">  Penguji TXQR </h1><br><p><img src="https://habrastorage.org/webt/bc/tp/a6/bctpa6fnru8q-kxbezmo27dcc1w.jpeg"></p><br><p>  Untuk menemukan kombinasi optimal frame rate, ukuran data dalam bingkai QR dan tingkat koreksi kesalahan di antara batas-batas yang wajar dari nilai-nilai ini, saya harus menjalankan lebih dari 1000 tes, secara manual mengubah parameter, menunggu siklus lengkap dengan telepon di tangan saya dan menulis hasilnya ke piring.  Tentu saja, ini harus otomatis! </p><br><p>  Di sini muncul ide aplikasi berikutnya - <code>txqr-tester</code> .  Awalnya, saya berencana untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">x / exp / shiny</a> - kerangka UI eksperimental untuk aplikasi desktop asli di Go, tetapi tampaknya ditinggalkan.  Sekitar setahun yang lalu saya mencobanya, dan kesan itu tidak buruk - sangat cocok untuk hal-hal tingkat rendah.  Tetapi hari ini, cabang utama bahkan belum dikompilasi.  Tampaknya tidak ada lagi insentif untuk berinvestasi dalam pengembangan kerangka kerja desktop - tugas yang rumit dan rumit, dengan hampir nol permintaan saat ini, semua solusi UI telah pindah ke web sejak lama. </p><br><p>  Dalam pemrograman web, seperti yang Anda ketahui, bahasa pemrograman baru saja mulai masuk, berkat WebAssembly, tetapi ini masih merupakan langkah pertama bagi anak-anak.  Tentu saja, ada juga JavaScript dan add-on, tetapi teman tidak mengizinkan teman untuk menulis aplikasi dalam JavaScript, jadi saya memutuskan untuk menggunakan penemuan saya baru-baru ini - kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vecty</a> , yang memungkinkan Anda untuk menulis frontends di Go murni, yang secara otomatis dikonversi ke JavaScript menggunakan JavaScript yang sangat dewasa dan secara mengejutkan berfungsi dengan baik Proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GopherJS</a> . </p><br><h1 id="vecty-i-gopherjs">  Vecty dan GopherJS </h1><br><p><img src="https://habrastorage.org/webt/rf/xc/zz/rfxczzfu4b5efmhjtu_lmf7ema4.png" alt="Vecty"></p><br><p>  Dalam hidup saya, saya belum menerima kesenangan seperti itu dari pengembangan antarmuka front-end. </p><br><p>  Beberapa saat kemudian saya berencana untuk menulis beberapa artikel lagi tentang pengalaman saya dalam mengembangkan tampilan depan pada Vecty, termasuk aplikasi WebGL, tetapi intinya adalah bahwa setelah beberapa proyek tentang React, Angulars dan Ember, menulis sebuah frontend dalam bahasa pemrograman yang bijaksana dan sederhana adalah sebuah napas segar udara!  Saya dapat menulis frontend yang cukup bagus dalam waktu singkat tanpa menulis satu baris pun dalam JavaScript! </p><br><p>  Sebagai permulaan, ini adalah bagaimana Anda memulai proyek baru di Vecty (tidak ada generator kode "proyek awal" yang menciptakan banyak file dan folder) - hanya main.go: </p><br><pre> <code class="go hljs">ackage main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/gopherjs/vecty"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { app := NewApp() vecty.SetTitle(<span class="hljs-string"><span class="hljs-string">"My App"</span></span>) vecty.AddStylesheet(<span class="hljs-comment"><span class="hljs-comment">/* ... add your css... */</span></span>) vecty.RenderBody(app) }</code> </pre> <br><p>  Aplikasi, seperti komponen UI lainnya, hanyalah tipe: struktur yang menyertakan tipe <code>vecty.Core</code> dan harus mengimplementasikan antarmuka <code>vecty.Component</code> (terdiri dari satu metode <code>Render()</code> ).  Dan itu saja!  Kemudian Anda bekerja dengan tipe, metode, fungsi, perpustakaan untuk bekerja dengan DOM, dan sebagainya - tanpa sihir tersembunyi dan istilah dan konsep baru.  Berikut adalah kode sederhana untuk halaman utama: </p><br><pre> <code class="go hljs">/ App is a top-level app component. <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { vecty.Core session *Session settings *Settings <span class="hljs-comment"><span class="hljs-comment">// any other stuff you need, // it's just a struct } // Render implements the vecty.Component interface. func (a *App) Render() vecty.ComponentOrHTML { return elem.Body( a.header(), elem.Div( vecty.Markup( vecty.Class("columns"), ), // Left half elem.Div( vecty.Markup( vecty.Class("column", "is-half"), ), elem.Div(a.QR()), // QR display zone ), // Right half elem.Div( vecty.Markup( vecty.Class("column", "is-half"), ), vecty.If(!a.session.Started(), elem.Div( a.settings, )), vecty.If(a.session.Started(), elem.Div( a.resultsTable, )), ), ), vecty.Markup( event.KeyDown(a.KeyListener), ), ) }</span></span></code> </pre> <br><p>  Anda mungkin melihat kode sekarang dan berpikir - berapa banyak pekerjaan yang tidak berdasar dengan DOM!  Saya juga berpikir begitu pada awalnya, tetapi begitu saya mulai bekerja, saya menyadari betapa nyamannya itu: </p><br><ol><li>  Tidak ada keajaiban - setiap blok (Markup atau HTML) hanyalah variabel dari jenis yang diinginkan, dengan batas yang jelas di mana Anda dapat meletakkan sesuatu, berkat pengetikan statis. </li><li>  Tidak ada tag pembuka / penutup yang harus Anda ingat untuk berubah saat refactoring, atau gunakan IDE yang melakukan ini untuk Anda. </li><li>  Struktur tiba-tiba menjadi jelas - misalnya, saya tidak pernah mengerti mengapa dalam Bereaksi sampai versi ke-16 tidak mungkin untuk mengembalikan beberapa tag dari suatu komponen - ini adalah "hanya sebuah string".  Melihat bagaimana hal ini dilakukan di Vecty, tiba-tiba menjadi jelas di mana akar kendala itu tumbuh di Bereaksi.  Meski begitu, tidak jelas, mengapa, setelah Bereaksi 16 itu menjadi mungkin, tetapi tidak perlu. </li></ol><br><p>  Secara umum, segera setelah Anda mencoba pendekatan ini untuk bekerja dengan DOM, keuntungannya akan menjadi sangat jelas.  Tentu saja ada juga kerugiannya, tetapi setelah kerugian dari metode yang biasa, mereka tidak terlihat. </p><br><p>  Vecty disebut kerangka kerja React-like, tetapi ini tidak sepenuhnya benar.  Ada pustaka GopherJS asli untuk React - <a href="">myitcv.io/react</a> , tapi saya rasa itu bukan ide yang baik untuk mengulangi solusi arsitektur React untuk Go.  Ketika Anda menulis sebuah frontend di Vecty, tiba-tiba menjadi jelas betapa lebih mudahnya sebenarnya.  Tiba-tiba, semua sihir tersembunyi ini serta istilah dan konsep baru yang diciptakan oleh setiap kerangka kerja JavaScript menjadi tidak berguna - semuanya hanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menambah kompleksitas</a> , tidak lebih.  Semua yang diperlukan adalah untuk dengan jelas dan jelas menggambarkan komponen, perilaku mereka, dan menghubungkan mereka bersama - jenis, metode dan fungsi, dan itu saja. </p><br><p>  Untuk CSS, saya menggunakan kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bulma yang</a> sangat baik - ia memiliki penamaan kelas yang sangat jelas dan struktur yang baik, dan kode UI deklaratif dengannya sangat mudah dibaca. </p><br><p>  Namun, keajaiban yang sebenarnya dimulai ketika Anda mengkompilasi kode Go dalam JavaScript.  Kedengarannya sangat menakutkan, tetapi, pada kenyataannya, Anda hanya memanggil <code>gopherjs build</code> dan dalam waktu kurang dari satu detik, Anda memiliki file JavaScript yang dibuat secara otomatis yang siap dimasukkan dalam halaman HTML dasar Anda (aplikasi reguler hanya terdiri dari tag tubuh kosong dan penyertaan ini Skrip JS).  Ketika saya pertama kali menjalankan perintah ini, saya berharap untuk melihat banyak pesan, peringatan dan kesalahan, tetapi tidak - itu bekerja dengan sangat cepat dan diam-diam, itu hanya mencetak file satu-baris dalam kasus kesalahan kompilasi yang dihasilkan oleh kompiler Go, sehingga mereka sangat jelas.  Tapi itu bahkan lebih keren untuk melihat kesalahan di konsol browser, dengan jejak tumpukan menunjuk ke file .go dan baris yang benar!  Ini sangat keren. </p><br><h2 id="testirovanie-parametrov-qr-animacii">  Menguji parameter animasi QR </h2><br><p>  Selama beberapa jam saya memiliki aplikasi web siap yang memungkinkan saya untuk dengan cepat mengubah parameter untuk pengujian: </p><br><ul><li>  FPS - frame rate </li><li>  Ukuran Bingkai QR - berapa byte yang harus ada di setiap frame </li><li>  QR Recovery Level - Level koreksi kesalahan QR </li></ul><br><p>  dan jalankan tes secara otomatis. </p><br><p><img src="https://habrastorage.org/webt/dl/51/my/dl51myjlg-kfbii5wxjx3ggu9tm.png" alt="aplikasi"></p><br><p>  Aplikasi seluler, tentu saja, juga harus otomatis - harus memahami kapan putaran berikutnya dimulai dengan parameter baru, memahami kapan penerimaan terlalu banyak waktu dan memutus putaran, mengirim hasilnya ke aplikasi, dan seterusnya. </p><br><p>  Masalahnya adalah bahwa aplikasi web, saat berjalan di kotak pasir browser, tidak dapat membuat koneksi baru, dan jika saya tidak salah, satu-satunya kemungkinan koneksi peer-to-peer nyata ke browser hanya melalui WebRTC (saya tidak perlu membobol NAT ), tapi itu terlalu rumit.  Aplikasi web hanya bisa menjadi klien. </p><br><p>  Solusinya sederhana - layanan web Go yang mengirimkan aplikasi web (dan meluncurkan browser ke URL yang diinginkan) juga meluncurkan proxy WebSocket untuk dua klien.  Segera setelah dua klien bergabung, secara transparan mengirim pesan dari satu koneksi ke yang lain, memungkinkan klien (aplikasi web dan klien seluler) untuk berkomunikasi secara langsung.  Mereka harus melakukannya, dalam satu jaringan WIFI, tentu saja. </p><br><p>  Ada masalah tentang cara memberi tahu perangkat seluler di mana, pada kenyataannya, untuk terhubung, dan dipecahkan menggunakan ... QR code! </p><br><p>  Proses pengujian terlihat seperti ini: </p><br><ul><li>  aplikasi seluler mencari kode QR dengan penanda awal dan tautan ke proksi WebSocket </li><li>  segera setelah token dibaca, aplikasi terhubung ke proxy WebSocket ini </li><li>  aplikasi web (sudah terhubung ke proksi) memahami bahwa aplikasi seluler siap dan menampilkan kode QR dengan penanda "siap untuk putaran selanjutnya?" </li><li>  aplikasi seluler mengenali sinyal, mengatur ulang dekoder, dan mengirim pesan "ya" melalui WebSocket. </li><li>  aplikasi web, setelah menerima konfirmasi, menghasilkan animasi QR baru dan memelintirnya hingga menerima hasil atau batas waktu. </li><li>  hasilnya ditambahkan ke piring di sebelah mana Anda dapat langsung mengunduh sebagai CSV </li></ul><br><p><img src="https://habrastorage.org/webt/u_/gm/jx/u_gmjxdtzg16tus3pboxicibyuk.png" alt="desain"></p><br><p>  Akibatnya, yang tersisa bagi saya hanyalah meletakkan telepon di atas tripod, meluncurkan aplikasi, dan kemudian kedua program itu sendiri melakukan semua pekerjaan kotor, berkomunikasi dengan sopan melalui kode QR dan WebSocket :) </p><br><p><img src="https://habrastorage.org/webt/b-/no/wn/b-nownnc3g_qjijctnqqwpjppri.gif" alt="demo penguji"></p><br><p>  Pada akhirnya, saya mengunduh file CSV dengan hasilnya, membawanya ke RStudio dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Plotly Online Chart Maker</a> dan menganalisis hasilnya. </p><br><h1 id="rezultaty">  Hasil </h1><br><p>  Siklus pengujian penuh membutuhkan waktu sekitar 4 jam (sayangnya, bagian tersulit dari proses - menghasilkan gambar GIF animasi dengan bingkai QR, harus dijalankan di browser, dan karena kode yang dihasilkan masih dalam JS, hanya satu prosesor yang digunakan), selama yang mana, Anda harus menonton agar layar tidak tiba-tiba menjadi kosong atau beberapa aplikasi tidak menutup jendela dengan aplikasi web.  Parameter berikut diuji: </p><br><ul><li>  FPS - 3 hingga 12 </li><li>  Ukuran bingkai QR adalah dari 100 hingga 1000 byte (dengan penambahan 50) </li><li>  Semua 4 level koreksi kesalahan QR (Rendah, Sedang, Tinggi, Tertinggi) </li><li>  Ukuran file yang ditransfer - 13KB byte yang dihasilkan secara acak </li></ul><br><p>  Beberapa jam kemudian saya mengunduh CSV dan mulai menganalisis hasilnya. </p><br><p>  Gambar lebih penting daripada seribu kata, tetapi visualisasi 3D interaktif lebih penting daripada seribu gambar.  Berikut adalah visualisasi hasil (dapat diklik): </p><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" title="qr_scan_result"><img src="https://habrastorage.org/getpro/habr/post_images/ba3/833/7f1/ba38337f18e68ef62245173481e497f7.png" alt="qr_scan_result" width="600"></a> <br><br><br><p>  Hasil terbaik adalah 1,4 detik, yaitu sekitar 9KB / dtk!  Hasil ini direkam pada frekuensi 11 frame per detik, ukuran frame 850 byte, dan tingkat koreksi kesalahan rata-rata.  Dalam kebanyakan kasus, bagaimanapun, pada kecepatan ini, decoder kamera melewatkan beberapa frame, dan harus menunggu pengulangan berikutnya dari frame yang terlewat, yang memiliki efek yang sangat negatif pada hasilnya - alih-alih dua detik dapat dengan mudah berubah menjadi 15, atau timeout yang diatur ke 30 detik. </p><br><p>  Berikut adalah grafik ketergantungan hasil pada variabel variabel: </p><br><h3 id="vremya--razmer-freyma">  Waktu Bingkai / Ukuran </h3><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/pd/9c/rp/pd9crp3igj0djkv3uftlpxcgb2y.png" alt="Waktu vs Ukuran"></a> </p><br><p>  Seperti yang Anda lihat, pada nilai rendah dari jumlah byte di setiap frame, kelebihan encoding terlalu besar dan total waktu baca, masing-masing juga.  Ada beberapa minimum lokal 500-600 byte per frame, tetapi nilai di sebelahnya masih mengarah ke frame yang hilang.  Hasil terbaik diamati pada 900 byte, tetapi 1000 ke atas hampir dijamin kehilangan bingkai. </p><br><h3 id="vremya--fps">  Waktu / FPS </h3><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/-g/al/up/-galupwvvmk5k78p2bqgmsg1zme.png" alt="Waktu vs FPS"></a> </p><br><p>  Nilai jumlah frame per detik, yang mengejutkan saya, tidak memiliki efek yang sangat besar - nilai-nilai kecil meningkatkan waktu transmisi keseluruhan terlalu banyak, dan yang besar meningkatkan kemungkinan frame terjawab.  Nilai optimal, dilihat dari tes ini, berada di wilayah 6-7 frame per detik untuk perangkat yang saya uji. </p><br><h3 id="vremya--uroven-korrekcii-oshibok">  Level Koreksi Waktu / Kesalahan </h3><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/c4/2g/di/c42gdiq0sqjxynepawom9j6bpi4.png" alt="Waktu vs Lvl"></a> </p><br><p>  Level koreksi kesalahan menunjukkan hubungan yang jelas antara waktu transfer file dan level redundansi, yang tidak mengejutkan.  Pemenang yang jelas di sini adalah tingkat koreksi rendah (L) - semakin sedikit data yang berlebihan, semakin mudah dibaca kode QR untuk pemindai dengan ukuran data yang sama.  Sebenarnya, redundansi tidak diperlukan sama sekali untuk percobaan ini, tetapi standar tidak menawarkan opsi seperti itu. </p><br><p>  Tentu saja, untuk data yang lebih objektif, tes ini harus dijalankan ratusan dan ribuan kali, pada perangkat yang berbeda dan layar yang berbeda, tetapi untuk eksperimen akhir pekan saya, hasilnya lebih dari cukup. </p><br><h1 id="vyvody">  Kesimpulan </h1><br><p>  Proyek lucu ini membuktikan bahwa transfer data satu arah melalui kode animasi tentu dimungkinkan, dan untuk situasi di mana Anda perlu mentransfer sejumlah kecil tanpa adanya jaringan apa pun, itu sangat cocok.  Meskipun hasil maksimum saya sekitar 9KB / s, dalam kebanyakan kasus kecepatan sebenarnya adalah 1-2KB / s. </p><br><p>  Saya juga sangat menikmati menggunakan Gomobile dan GopherJS dengan Vecty sebagai alat pemecahan masalah rutin.  Ini adalah proyek yang sangat matang, dengan kecepatan kerja yang sangat baik, dan, dalam banyak kasus, memberikan pengalaman "itu hanya bekerja." </p><br><p>  Pada akhirnya, saya masih mengagumi betapa produktifnya Anda dengan Go ketika Anda jelas tahu apa yang ingin Anda terapkan - siklus "perubahan" yang sangat singkat - "berkumpul" - "centang" memungkinkan Anda untuk banyak bereksperimen dan sering kali, kode sederhana dan tidak adanya hierarki kelas dalam struktur program memungkinkan untuk dengan mudah dan tanpa rasa sakit refactor mereka saat bepergian, dan cross-platform fantastis yang tertanam dalam bahasa sejak awal memungkinkan Anda untuk menulis kode sekali dan menggunakannya di server, di klien web dan di aplikasi mobile asli.  Pada saat yang sama, meskipun kinerja lebih dari cukup, masih ada banyak ruang untuk optimasi dan akselerasi. </p><br><p>  Jadi, jika Anda belum pernah mencoba Gomobile atau GopherJS - Saya sarankan Anda mencoba pada kesempatan berikutnya.  Ini akan memakan waktu satu jam dari waktu Anda, tetapi mungkin membuka seluruh lapisan peluang baru dalam pengembangan web atau seluler.  Jangan ragu untuk mencoba! </p><br><h1 id="ssylki">  Referensi </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/divan/txqr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/divan/txqr/tree/master/cmd/txqr-tester</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/divan/txqr-tester-ios</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/divan/txqr-reader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/gopherjs/vecty</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/golang/mobile</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430688/">https://habr.com/ru/post/id430688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430678/index.html">Uji sepuluh dimmer dengan lampu LED</a></li>
<li><a href="../id430680/index.html">Menulis prosesor dan lingkungan yang sederhana untuknya</a></li>
<li><a href="../id430682/index.html">Tiga tahun proyek mikrosatelit bulan: tahap-tahap pertumbuhan</a></li>
<li><a href="../id430684/index.html">Memindai Kontrak Ethereum Langsung untuk Kesalahan Tidak Terkirim-Kirim. Bagian 2</a></li>
<li><a href="../id430686/index.html">Tinjauan: Mesin pemotong waterjet pertama WAZER</a></li>
<li><a href="../id430690/index.html">Pengecualian deterministik dan penanganan kesalahan dalam â€œC ++ of the futureâ€</a></li>
<li><a href="../id430692/index.html">Rekayasa Sosial dengan Perangkat Lunak Universal Windows Platform (APPX)</a></li>
<li><a href="../id430694/index.html">Panduan singkat untuk mempelajari C ++: apa, kapan dan apa yang harus dibuat</a></li>
<li><a href="../id430700/index.html">Sistem terpadu untuk merekam tayangan film online akan mulai berfungsi di Rusia</a></li>
<li><a href="../id430704/index.html">Bagaimana Teknologi Kecerdasan Buatan Membantu Aviasales Tumbuh: Tujuh Contoh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>