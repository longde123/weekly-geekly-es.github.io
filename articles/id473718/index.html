<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤š ğŸš¢ ğŸ“Ÿ Cara menambahkan cek ke NoVerify tanpa menulis satu baris kode Go ğŸŒš â™’ï¸ ğŸ¥œ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fitur pembunuh telah muncul di penganalisa statis NoVerify : cara deklaratif untuk menggambarkan inspeksi yang tidak memerlukan pemrograman Go dan kom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menambahkan cek ke NoVerify tanpa menulis satu baris kode Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/473718/"><p>  Fitur pembunuh telah muncul di penganalisa statis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NoVerify</a> : cara deklaratif untuk menggambarkan inspeksi yang tidak memerlukan pemrograman Go dan kompilasi kode. </p><br><p>  Untuk membuat Anda penasaran, saya akan menunjukkan kepada Anda deskripsi inspeksi yang sederhana namun bermanfaat: </p><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> duplicated sub-expressions inside boolean expression */</span></span> $x &amp;&amp; $x;</code> </pre> <br><p>  Pemeriksaan ini menemukan semua ekspresi logis <code>&amp;&amp;</code> mana operan kiri dan kanan identik. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NoVerify</a> adalah penganalisa statis untuk PHP yang ditulis dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Go</a> .  Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membacanya</a> di artikel â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NoVerify: Linter for PHP dari Tim VKontakte</a> â€.  Dan dalam ulasan ini saya akan berbicara tentang fungsionalitas baru dan bagaimana kami melakukannya. </p><br><p><img src="https://habrastorage.org/webt/gv/ru/74/gvru74yeqcbjdphiuwj4tieehoq.png"></p><a name="habracut"></a><br><h1 id="predposylki">  Latar belakang </h1><br><p>  Ketika bahkan untuk pemeriksaan baru yang sederhana, Anda perlu menulis beberapa lusin baris kode di Go, Anda mulai bertanya-tanya: apakah mungkin sebaliknya? </p><br><p>  On Go, kami telah menulis inferensi tipe, seluruh jalur pipa linter, cache metadata, dan banyak elemen penting lainnya yang tanpanya NoVerify tidak mungkin.  Komponen-komponen ini unik, tetapi tugas-tugas seperti "melarang memanggil fungsi X dengan seperangkat argumen Y" tidak.  Hanya untuk tugas-tugas sederhana seperti itu mekanisme aturan dinamis telah ditambahkan. </p><br><p>  Aturan dinamis memungkinkan Anda untuk memisahkan internal yang kompleks dari penyelesaian masalah yang khas.  File definisi dapat disimpan dan diversi secara terpisah - itu dapat diedit oleh orang-orang yang tidak terkait dengan pengembangan NoVerify itu sendiri.  Setiap aturan menerapkan inspeksi kode (yang terkadang kami sebut verifikasi). </p><br><p>  Ya, jika kami memiliki bahasa untuk menjelaskan aturan ini, Anda selalu dapat menulis templat yang semantik salah atau mengabaikan beberapa batasan jenis - dan ini mengarah pada false positive.  Namun demikian, perlombaan data atau dereferencing <code>nil</code> pointer melalui bahasa aturan tidak dimasukkan. </p><br><h1 id="yazyk-opisaniya-shablonov">  Deskripsi Template Bahasa </h1><br><p>  Bahasa deskripsi secara sintaksis kompatibel dengan PHP.  Ini menyederhanakan studinya, dan juga memungkinkan untuk mengedit file aturan menggunakan PhpStorm yang sama. </p><br><p>  Di awal file aturan, disarankan untuk memasukkan arahan yang menenangkan IDE favorit Anda: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** *      , *        PHP-. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@noinspection</span></span></span><span class="hljs-comment"> ALL */</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...  â€”   .</span></span></code> </pre> <br><p>  Eksperimen pertama saya dengan sintaks dan kemungkinan filter untuk templat adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">phpgrep</a> .  Ini mungkin berguna sendiri, tetapi di dalam NoVerify telah menjadi lebih menarik, karena sekarang ia memiliki akses untuk mengetik informasi. </p><br><p>  Beberapa kolega saya sudah mencoba phpgrep dalam pekerjaan mereka, dan ini adalah argumen lain yang mendukung pemilihan <a href="">sintaksis</a> seperti itu. </p><br><p>  Phpgrep sendiri merupakan adaptasi gogrep untuk PHP (Anda mungkin juga tertarik dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cgrep</a> ).  Dengan menggunakan program ini, Anda dapat mencari kode melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">templat sintaks</a> . </p><br><p>  Alternatif adalah sintaks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian struktural dan penggantian</a> (SSR) dari PhpStorm.  Keuntungannya jelas - ini adalah format yang ada, tetapi saya mengetahui tentang fitur ini setelah saya mengimplementasikan phpgrep.  Anda dapat, tentu saja, memberikan penjelasan teknis: ada sintaks yang tidak sesuai dengan PHP dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parser kami</a> tidak akan menguasainya, tetapi alasan "nyata" yang meyakinkan ini ditemukan setelah menulis sepeda. </p><br><div class="spoiler">  <b class="spoiler_title">Bahkan, ada opsi lain</b> <div class="spoiler_text"><hr><br><p>  Mungkin diperlukan untuk menampilkan templat dengan kode-PHP hampir satu-ke-satu - atau pergi dengan cara lain: menciptakan bahasa baru, misalnya dengan sintaks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekspresi S.</a> </p><br><pre> <code class="plaintext hljs">PHP-like Lisp-like ----------------------------- $x = $y | (expr = $x $y) fn($x, 1) | (expr call fn $x 1)          : (or (expr == (type string (expr)) (expr)) (expr == (expr) (type string (expr))))</code> </pre> <br><p>  Pada akhirnya, saya berpikir bahwa keterbacaan template masih penting, dan kita dapat menambahkan filter melalui atribut phpdoc. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dentang-permintaan</a> adalah contoh dari ide yang sama, tetapi menggunakan sintaksis yang lebih tradisional. </p><br><hr></div></div><br><h1 id="sozdayom-i-zapuskaem-svoyu-diagnostiku">  Kami membuat dan menjalankan diagnostik kami sendiri! </h1><br><p>  Mari kita coba menerapkan diagnostik baru kami untuk penganalisa. </p><br><p>  Untuk melakukan ini, Anda perlu menginstal NoVerify.  Ambil <a href="">rilis biner</a> jika Anda tidak memiliki Go-toolchain di sistem (jika Anda memilikinya, Anda dapat mengkompilasi semuanya dari sumbernya). </p><br><div class="scrollable-table"><table><tbody><tr><td>  Jika Anda tidak menginstal NoVerify, Anda dapat terus membaca lebih lanjut, tetapi berpura-pura mereproduksi langkah-langkah yang tercantum dan mengagumi hasilnya! <br></td></tr></tbody></table></div><br><h2 id="postanovka-zadachi">  Pernyataan masalah </h2><br><p>  PHP memiliki banyak fungsi menarik, salah satunya adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">parse_str</a> .  Tanda tangannya: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   encoded_string,     //   URL,      //   (  ,    result). parse_str ( string $encoded_string [, array &amp;$result ] ) : void</span></span></code> </pre> <br><p>  Anda akan mengerti apa yang salah di sini jika Anda melihat contoh ini dari dokumentasi: </p><br><pre> <code class="php hljs">$str = <span class="hljs-string"><span class="hljs-string">"first=value&amp;arr[]=foo+bar&amp;arr[]=baz"</span></span>; parse_str($str); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $first; <span class="hljs-comment"><span class="hljs-comment">// value echo $arr[0]; // foo bar echo $arr[1]; // baz</span></span></code> </pre> <br><p>  Mmm, parameter dari string berada dalam ruang lingkup saat ini.  Untuk menghindari ini, kami akan meminta dalam pengujian baru kami untuk menggunakan parameter fungsi kedua, <code>$result</code> , sehingga hasilnya ditulis ke array ini. </p><br><h2 id="sozdanie-svoey-diagnostiki">  Buat diagnostik Anda sendiri </h2><br><p>  Buat file <code>myrules.php</code> : </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> parse_str without second argument */</span></span> parse_str($_);</code> </pre> <br><p>  File aturan secara umum adalah daftar ekspresi di tingkat atas, yang masing-masing ditafsirkan sebagai templat phpgrep.  Komentar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">phpdoc</a> khusus diharapkan untuk setiap templat tersebut.  Hanya satu atribut yang diperlukan - kategori kesalahan dengan teks peringatan. </p><br><p>  Sekarang ada empat level total: <code>error</code> , <code>warning</code> , <code>info</code> , dan <code>maybe</code> .  Dua yang pertama sangat penting: linter akan mengembalikan kode non-nol setelah eksekusi jika setidaknya salah satu aturan penting berfungsi.  Setelah atribut itu sendiri ada teks peringatan yang akan dikeluarkan oleh linter jika template dipicu. </p><br><p>  Template yang kami tulis menggunakan <code>$_</code> - ini adalah variabel template yang tidak disebutkan namanya.  Kita bisa menyebutnya, misalnya, <code>$x</code> , tetapi karena kita tidak melakukan apa-apa dengan variabel ini, kita dapat memberinya nama "kosong".  Perbedaan antara variabel template dan variabel PHP adalah bahwa yang pertama bertepatan dengan ekspresi apa pun, dan tidak hanya dengan variabel "literal".  Ini nyaman: kita sering perlu mencari ekspresi yang tidak diketahui, daripada variabel tertentu. </p><br><h2 id="zapusk-novoy-diagnostiki">  Memulai diagnostik baru </h2><br><p>  Buat file uji kecil untuk debugging, <code>test.php</code> : </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ parse_str($x); <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p>  Selanjutnya, jalankan NoVerify dengan aturan kami pada file ini: </p><br><pre> <code class="bash hljs">$ noverify -rules myrules.php test.php</code> </pre> <br><p>  Peringatan kami akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">WARNING myrules.php:4: parse_str without second argument at test.php:4 parse_str($x); ^^^^^^^^^^^^^</code> </pre> <br><p>  Nama pemeriksaan default adalah nama file aturan dan baris yang menentukan pemeriksaan ini.  Dalam kasus kami, ini adalah <code>myrules.php:4</code> . </p><br><p>  Anda dapat mengatur nama Anda menggunakan <code>@name &lt;name&gt;</code> . </p><br><div class="spoiler">  <b class="spoiler_title">@Nama contoh</b> <div class="spoiler_text"><hr><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@name</span></span></span><span class="hljs-comment"> parseStrResult * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> parse_str without second argument */</span></span> parse_str($_);</code> </pre> <br><pre> <code class="plaintext hljs">WARNING parseStrResult: parse_str without second argument at test.php:4 parse_str($x); ^^^^^^^^^^^^^</code> </pre> <br><p>  Aturan yang dinamai menyerah pada hukum diagnostik lain: </p><br><ul><li>  Dapat dinonaktifkan melalui <code>-exclude-checks</code> </li><li>  Tingkat <code>-critical</code> dapat didefinisikan ulang melalui <code>-critical</code> </li></ul><br><hr></div></div><br><h1 id="rabota-s-tipami">  Bekerja dengan tipe </h1><br><p>  Contoh sebelumnya bagus untuk hello world - tetapi seringkali kita perlu mengetahui jenis ekspresi untuk mengurangi jumlah operasi diagnostik </p><br><p>  Sebagai contoh, untuk fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">in_array,</a> kami meminta argumen <code>$strict=true</code> ketika argumen pertama ( <code>$needle</code> ) adalah tipe string. </p><br><p>  Untuk ini kami memiliki filter hasil. </p><br><p>  Salah satu filter tersebut adalah <code>@type &lt;type&gt; &lt;var&gt;</code> .  Ini memungkinkan Anda untuk membuang segala sesuatu yang tidak sesuai dengan tipe yang disebutkan. </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> 3rd arg of in_array must be true when comparing strings * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> string $needle */</span></span> in_array($needle, $_);</code> </pre> <br><p>  Di sini kami memberikan nama argumen pertama ke panggilan <code>in_array</code> untuk mengikat filter tipe ke sana.  Peringatan akan dikeluarkan hanya ketika tipe <code>$needle</code> adalah <code>string</code> . </p><br><p>  Set filter dapat dikombinasikan dengan operator <code>@or</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** *     -. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> strings must be compared using '===' operator * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> string $x * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@or</span></span></span><span class="hljs-comment"> * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> string $y */</span></span> $x == $y;</code> </pre> <br><p>  Pada contoh di atas, polanya hanya akan cocok dengan ekspresi <code>==</code> , di mana salah satu operan bertipe <code>string</code> .  Dapat diasumsikan bahwa tanpa <code>@or</code> semua filter digabungkan melalui <code>@and</code> , tetapi ini tidak perlu diindikasikan secara eksplisit. </p><br><h1 id="ogranichivaem-oblast-deystviya-diagnostiki">  Batasi ruang lingkup diagnosis </h1><br><p>  Untuk setiap pengujian, Anda dapat menentukan <code>@scope &lt;name&gt;</code> : </p><br><ul><li>  <code>@scope all</code> - nilai default, validasi berfungsi di mana saja; </li><li>  <code>@scope root</code> - luncurkan hanya di tingkat atas; </li><li>  <code>@scope local</code> - jalankan hanya di dalam fungsi dan metode. </li></ul><br><p>  Misalkan kita ingin melaporkan <code>return</code> luar fungsi tubuh.  Dalam PHP, ini kadang masuk akal - misalnya, ketika file terhubung dari suatu fungsi ... Tapi dalam artikel ini kami mengutuk ini. </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> don't use return outside of functions * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@scope</span></span></span><span class="hljs-comment"> root */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $_;</code> </pre> <br><p>  Mari kita lihat bagaimana aturan ini akan berlaku: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"OK"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"NOT OK"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Gives a warning class C { public function m() { return "ALSO OK"; } }</span></span></code> </pre> <br><p>  Demikian pula, Anda dapat membuat permintaan untuk menggunakan <code>*_once</code> alih-alih <code>require</code> dan <code>include</code> : </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@maybe</span></span></span><span class="hljs-comment"> prefer require_once over require * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@scope</span></span></span><span class="hljs-comment"> root */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> $_; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@maybe</span></span></span><span class="hljs-comment"> prefer include_once over include * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@scope</span></span></span><span class="hljs-comment"> root */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> $_;</code> </pre> <br><blockquote>  Sekarang ketika mencocokkan pola, tanda kurung tidak diperhitungkan dengan cukup konsisten.  Pola <code>(($x))</code> tidak akan menemukan "semua ekspresi dalam tanda kurung ganda", tetapi hanya sembarang ekspresi, mengabaikan tanda kurung.  Namun, <code>$x+$y*$z</code> dan <code>($x+$y)*$z</code> berlaku sebagaimana mestinya.  Fitur ini berasal dari kesulitan bekerja dengan token <code>(</code> dan <code>)</code> , tetapi ada kemungkinan bahwa pesanan akan dikembalikan dalam salah satu rilis berikutnya. </blockquote><br><h1 id="gruppirovanie-shablonov">  Template Pengelompokan </h1><br><p>  Ketika duplikasi komentar phpdoc muncul di templat, kemampuan untuk menggabungkan templat datang ke penyelamatan. </p><br><p>  Contoh sederhana untuk menunjukkan: </p><br><div class="scrollable-table"><table><tbody><tr><th>  Apakah </th><th>  Itu menjadi (dengan pengelompokan) </th></tr><tr><td><pre> / ** @mungkin tidak menggunakan jalan keluar atau mati * /
 die ($ _);<font></font>
<font></font>
 / ** @mungkin tidak menggunakan jalan keluar atau mati * /
 keluar ($ _);
</pre></td><td><pre> / ** @mungkin tidak menggunakan jalan keluar atau mati * /
 {
   die ($ _);
   keluar ($ _);
 }
</pre></td></tr></tbody></table></div><br><p>  Sekarang bayangkan betapa tidak menyenangkannya menggambarkan sebuah aturan dalam contoh berikut tanpa fitur ini! </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> don't compare arrays with numeric types * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> array $x * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> int|float $y * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@or</span></span></span><span class="hljs-comment"> * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> int|float $x * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@type</span></span></span><span class="hljs-comment"> array $y */</span></span> { $x &gt; $y; $x &lt; $y; $x &gt;= $y; $x &lt;= $y; $x == $y; }</code> </pre> <br><p>  Format rekaman yang ditentukan dalam artikel hanyalah salah satu opsi yang diusulkan.  Jika Anda ingin berpartisipasi dalam pilihan, maka Anda memiliki kesempatan seperti itu: Anda harus memberi +1 pada tawaran yang lebih Anda sukai daripada yang lain.  Untuk lebih jelasnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klik di sini</a> . </p><br><h1 id="kak-integrirovany-dinamicheskie-pravila">  Bagaimana aturan dinamis diintegrasikan </h1><br><p><img src="https://habrastorage.org/webt/1l/hl/x4/1lhlx4vcasmxii4zhwf6fmzlgn8.jpeg"></p><br><p>  Pada saat peluncuran, NoVerify mencoba menemukan file aturan yang ditentukan dalam argumen <code>rules</code> . </p><br><p>  Selanjutnya, file ini diuraikan sebagai skrip PHP biasa, dan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AST yang</a> dihasilkan, seperangkat objek aturan dengan templat phpgrep yang terikat dengannya dikumpulkan. </p><br><p>  Kemudian penganalisa memulai pekerjaan sesuai dengan skema yang biasa - satu-satunya perbedaan adalah bahwa untuk beberapa bagian kode yang diperiksa, ia memulai seperangkat aturan yang terikat.  Jika aturan dipicu, peringatan ditampilkan. </p><br><p>  Sukses dianggap sebagai pencocokan template phpgrep dan bagian dari setidaknya satu set filter (mereka dipisahkan oleh <code>@or</code> ). </p><br><p>  Pada tahap ini, mekanisme aturan tidak secara signifikan memperlambat pengoperasian linter, bahkan jika ada banyak aturan dinamis. </p><br><h2 id="algoritm-matchinga">  Algoritma Pencocokan </h2><br><p>  Dengan pendekatan naif, untuk setiap simpul AST, kita perlu menerapkan semua aturan dinamis.  Ini adalah implementasi yang sangat tidak efisien, karena sebagian besar pekerjaan akan dilakukan dengan sia-sia: banyak template memiliki awalan spesifik yang dengannya kita dapat mengelompokkan aturan. </p><br><p>  Ini mirip dengan gagasan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencocokan paralel</a> , tetapi alih-alih dengan jujur â€‹â€‹membangun NFA, kami hanya "memparalelkan" langkah pertama perhitungan. </p><br><p>  Pertimbangkan ini dengan contoh dengan tiga aturan: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> duplicated then/else parts of ternary */</span></span> $_ ? $x : $x; <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> don't call explode with delim="" */</span></span> explode(<span class="hljs-string"><span class="hljs-string">""</span></span>, ${<span class="hljs-string"><span class="hljs-string">"*"</span></span>}); <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@maybe</span></span></span><span class="hljs-comment"> suspicious empty body of the if statement */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($_);</code> </pre> <br><p>  Jika kita memiliki elemen N dan aturan M, dengan pendekatan naif kita memiliki operasi N * M untuk dilakukan.  Secara teori, kompleksitas ini dapat dikurangi menjadi linier dan mendapatkan <code>O(N)</code> - jika Anda menggabungkan semua pola menjadi satu dan melakukan kecocokan seperti halnya, misalnya, paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">regexp</a> dari Go. </p><br><p>  Namun, dalam praktiknya, saya sejauh ini fokus pada implementasi parsial dari pendekatan ini.  Ini akan memungkinkan aturan dari file di atas untuk dibagi menjadi tiga kategori, dan untuk elemen AST yang tidak ada aturan yang sesuai, untuk menetapkan kategori kosong keempat.  Karena itu, tidak lebih dari satu aturan yang dijalankan untuk setiap elemen. </p><br><p>  Jika kita memiliki ribuan aturan dan kita akan merasakan pelambatan yang signifikan, algoritme akan diselesaikan.  Sementara itu, kesederhanaan solusi dan akselerasi yang dihasilkan cocok untuk saya. </p><br><h2 id="muki-vybora-ili-nemnogo-o-forme-zapisi-type">  Siksaan pilihan, atau Sedikit tentang formulir <code>@type</code> </h2><br><div class="scrollable-table"><table><tbody><tr><td>  Tugas: untuk memilih sintaks yang baik untuk filter dalam anotasi phpdoc. <br></td></tr></tbody></table></div><br><p>  Sintaksis saat ini menduplikasi <code>@var</code> dan <code>@var</code> , tetapi kita mungkin memerlukan operator baru, misalnya, "tipe tidak sama."  Bayangkan bagaimana tampilannya. </p><br><p>  Kami memiliki setidaknya dua prioritas penting: </p><br><ol><li>  Sintaksis penjelasan yang dapat dibaca dan ringkas. </li><li>  Dukungan setinggi mungkin dari IDE tanpa usaha ekstra. </li></ol><br><p>  Untuk PhpStorm ada plugin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">anotasi php</a> yang menambahkan penyelesaian otomatis, transisi ke kelas anotasi dan kegunaan lain untuk bekerja dengan komentar phpdoc. </p><br><p>  Prioritas (2) dalam praktik berarti Anda membuat keputusan yang tidak bertentangan dengan harapan IDE dan plugin.  Misalnya, Anda dapat membuat anotasi dalam format yang dapat dikenali oleh plugin anotasi php: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Type is a filter that checks that $value * satisfies the given type constraints. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@Annotation</span></span></span><span class="hljs-comment"> */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** Variable name that is being filtered */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $value; <span class="hljs-comment"><span class="hljs-comment">/** Check that value type is equal to $type */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $type; <span class="hljs-comment"><span class="hljs-comment">/** Check that value text is equal to $text */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $text; }</code> </pre> <br><p>  Kemudian menerapkan filter ke tipe akan terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">@Type($needle, eq=string) @Type($x, not_eq=Foo)</code> </pre> <br><p>  Pengguna dapat pergi ke definisi <code>Filter</code> , mereka akan diminta dengan daftar parameter yang mungkin (tipe / teks / dll). </p><br><p>  Metode perekaman alternatif, beberapa di antaranya disarankan oleh rekan: </p><br><pre> <code class="plaintext hljs">@type string $needle @type !Foo $x @type $needle == string @type $x != Foo @type(==) string $needle @type(!=) Foo $x @type($needle) == string @type($x) != Foo @filter type($needle) == string @filter type($x) != Foo</code> </pre> <br><p>  Kemudian kami sedikit terganggu dan lupa bahwa semuanya ada di dalam phpdoc, dan ini muncul: </p><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">eq</span></span> string (<span class="hljs-name"><span class="hljs-name">typeof</span></span> $needle)) (<span class="hljs-name"><span class="hljs-name">neq</span></span> Foo (<span class="hljs-name"><span class="hljs-name">typeof</span></span> $x))</code> </pre> <br><p>  Meskipun opsi dengan perekaman postfix untuk bersenang-senang juga terdengar.  Bahasa untuk menggambarkan batasan tipe dan nilai bisa disebut keenam: </p><br><pre> <code class="plaintext hljs">@eval string $needle typeof = @eval Foo $x typeof &lt;&gt;</code> </pre> <br><p>  Pencarian untuk opsi terbaik masih belum selesai ... </p><br><h1 id="sravnenie-rasshiryaemosti-s-phan">  Perbandingan Extensibility dengan Phan </h1><br><p>  Sebagai salah satu kelebihan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Phan</a> , artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Analisis statis kode PHP menggunakan contoh PHPStan, Phan dan Mazmur</a> " menunjukkan ekstensibilitas. </p><br><p>  Inilah yang diimplementasikan dalam plugin sampel: </p><br><blockquote>  Kami ingin mengevaluasi seberapa siap kode kami untuk PHP 7.3 (khususnya, untuk mengetahui apakah ia memiliki konstanta case-insensitive).  Kami hampir yakin bahwa tidak ada konstanta seperti itu, tetapi apa pun bisa terjadi dalam 12 tahun - itu harus diperiksa.  Dan kami menulis sebuah plugin untuk Phan yang akan bersumpah jika parameter ketiga digunakan dalam define (). </blockquote><p>  Beginilah tampilan kode plugin (pemformatan dioptimalkan untuk lebar): </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">AST</span></span>\<span class="hljs-title"><span class="hljs-title">ContextNode</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">CodeBase</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Context</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">Language</span></span>\<span class="hljs-title"><span class="hljs-title">Element</span></span>\<span class="hljs-title"><span class="hljs-title">Func</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Phan</span></span>\<span class="hljs-title"><span class="hljs-title">PluginV2</span></span>\<span class="hljs-title"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">ast</span></span>\<span class="hljs-title"><span class="hljs-title">Node</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefineThirdParamTrue</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PluginV2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyzeFunctionCallCapability</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAnalyzeFunctionCallClosures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeBase $code_base)</span></span></span><span class="hljs-function"> </span></span>{ $def = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CodeBase $cb, Context $ctx, Func $fn, $args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count($args) &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emitIssue( $cb, $ctx, <span class="hljs-string"><span class="hljs-string">'PhanDefineCaseInsensitiv'</span></span>, <span class="hljs-string"><span class="hljs-string">'define with 3 arguments'</span></span>, [] ); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'define'</span></span> =&gt; $def]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefineThirdParamTrue();</code> </pre> <br><p>  Dan inilah cara ini dapat dilakukan di NoVerify: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@warning</span></span></span><span class="hljs-comment"> define with 3 arguments */</span></span> define($_, $_, $_);</code> </pre> <br><p>  Kami ingin mencapai hasil yang kira-kira sama - sehingga hal-hal sepele dapat dilakukan sesederhana mungkin. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><ul><li>  Coba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NoVerify</a> di proyek Anda. </li><li>  Jika Anda memiliki ide untuk perbaikan atau laporan bug, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beri tahu kami</a> . </li><li>  Jika Anda ingin berpartisipasi dalam pengembangan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">selamat datang</a> ! </li></ul><br><h1 id="ssylki-poleznye-materialy">  Tautan, materi yang bermanfaat </h1><br><p>  Tautan penting dikumpulkan di sini, beberapa di antaranya mungkin sudah disebutkan dalam artikel, tetapi untuk kejelasan dan kenyamanan, saya mengumpulkannya di satu tempat. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel tentang NoVerify di HabrÃ©</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel tentang phpgrep di HabrÃ©</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Video pembicaraan Phpgrep dengan IT Nights</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gogrep</a> - Cari kode pencarian berdasarkan pola sintaksis </li><li>  Konsep <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyeleksi</a> ASL ESLint mirip dengan templat sintaks </li></ul><br><p>  Jika Anda membutuhkan lebih banyak contoh aturan yang dapat diterapkan, Anda dapat mengintip <a href="">tes NoVerify</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473718/">https://habr.com/ru/post/id473718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473706/index.html">Zoia: CMS reaktif ringan untuk pengembangan situs web yang cepat</a></li>
<li><a href="../id473708/index.html">Mobil listrik buatan rumah - semuanya tidak seperti yang Anda pikirkan</a></li>
<li><a href="../id473710/index.html">Prinsip-prinsip dokumentasi dan lokalisasi, atau cara mendapatkan lokalisasi yang baik dengan biaya minimal</a></li>
<li><a href="../id473714/index.html">Bagaimana saya sampai pada spesifikasi formal prosesor RISC-V di F #</a></li>
<li><a href="../id473716/index.html">Widget yang digerakkan mouse. Seret dan letakkan di dalam jendela</a></li>
<li><a href="../id473720/index.html">Dua cara untuk membuat unit test yang andal</a></li>
<li><a href="../id473722/index.html">Isolasi jarak jauh, kecemasan dan depresi</a></li>
<li><a href="../id473726/index.html">Tidak cukup hanya tahu apa itu Mutex, Semaphore, dan async / tunggu. Anda perlu tahu segalanya dari kuanta</a></li>
<li><a href="../id473728/index.html">Implementasi pemantauan yang khas. Nikolay Sivko</a></li>
<li><a href="../id473732/index.html">Sejarah penipuan dalam pembangunan jaringan kabel di bawah Kutub Utara sebesar $ 1 miliar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>