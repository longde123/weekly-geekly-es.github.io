<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏫ 🤙🏼 🖤 Qt: menggambar berdasarkan grafik vektor 🏚️ 🚪 🕘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt menyediakan programmer dengan fitur yang sangat kaya, tetapi rangkaian widget terbatas. Jika tidak ada yang cocok, Anda harus menggambar sesuatu se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt: menggambar berdasarkan grafik vektor</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425547/"><p><img src="https://habrastorage.org/webt/kp/7v/oi/kp7voi6ve63y4yxzdtthd-dxs80.png" align="right">  Qt menyediakan programmer dengan fitur yang sangat kaya, tetapi rangkaian widget terbatas.  Jika tidak ada yang cocok, Anda harus menggambar sesuatu sendiri.  Cara paling sederhana - untuk menggunakan gambar yang sudah jadi - memiliki kelemahan serius: kebutuhan untuk menyimpan gambar dalam file atau sumber daya, masalah dengan skalabilitas, dan portabilitas format gambar.  Berikut ini menjelaskan penggunaan prinsip-prinsip grafik vektor tanpa menggunakan gambar vektor yang sebenarnya. </p><a name="habracut"></a><br><h2 id="preambula">  Pembukaan </h2><br><p>  Semuanya dimulai dengan fakta bahwa sekali indikasi tanda-tanda satu-bit diperlukan.  Beberapa aplikasi menerima beberapa data pada beberapa port, paket harus dibongkar dan ditampilkan di layar.  Akan menyenangkan pada saat yang sama untuk meniru dashboard yang sudah dikenalinya.  Untuk menampilkan data digital, Qt menawarkan "out of the box" kelas QLCDN, mirip dengan indikator tujuh segmen yang sudah dikenal, tetapi ada sesuatu yang tidak terlihat dalam lampu tunggal. </p><br><p>  Menggunakan bendera (itu kotak centang) dan sakelar (itu adalah tombol radio) untuk keperluan ini buruk, dan berikut adalah daftar alasannya: </p><br><ul><li>  Ini salah secara semantik.  Tombol - itu adalah tombol, dan dimaksudkan untuk input pengguna, dan bukan untuk menunjukkan apa pun padanya. </li><li>  Ini menyiratkan yang kedua: pengguna berusaha menyodok tombol-tombol tersebut.  Jika pada saat yang sama memperbarui informasi tidak terlalu cepat, indikasinya akan berbohong, dan pengguna akan melaporkan kegagalan program, cekikikan dengan kejam. </li><li>  Jika Anda mengunci tombol untuk menekan (setEnabled (false)), maka itu menjadi abu-abu jelek.  Saya ingat bahwa di Delphi, di wilayah versi 6, ada tipuan dengan telinga: Anda bisa meletakkan bendera di panel dan menonaktifkan ketersediaan panel, bukan bendera, maka bendera tidak abu-abu atau aktif.  Trik ini tidak berfungsi di sini. </li><li>  Tombol-tombol memiliki fokus input.  Dengan demikian, jika ada elemen input di jendela, dan pengguna berjalan di sepanjang mereka menggunakan tombol Tab, ia harus berjalan di sepanjang elemen output, yang tidak nyaman dan jelek. </li><li>  Pada akhirnya, tombol-tombol ini hanya terlihat tidak estetis, terutama di sebelah tujuh segmen. </li></ul><br><p>  Kesimpulan: Anda perlu menggambar bola lampu sendiri. </p><br><h2 id="muki-vybora">  Pilihan tepung </h2><br><p>  Pertama saya mencari solusi yang sudah jadi.  Dalam waktu sejauh itu, ketika saya menggunakan Delphi, Anda dapat menemukan hanya sejumlah besar komponen jadi, baik dari perusahaan yang serius dan produsen amatir.  Qt memiliki banyak masalah dengan ini.  QWT memiliki beberapa elemen, tetapi bukan itu.  Saya tidak melihat amatirisme sama sekali.  Mungkin, jika Anda menggali dengan benar di Github, Anda dapat menemukan sesuatu, tetapi saya sendiri mungkin akan melakukannya lebih cepat. </p><br><p>  Hal pertama yang disarankan sendiri dari buatan sendiri adalah menggunakan dua file gambar dengan gambar lampu menyala dan mati.  Buruk: </p><br><ul><li>  Penting untuk menemukan gambar yang bagus (atau menggambar, tetapi saya bukan seorang seniman); </li><li>  Pertanyaan prinsipnya adalah: mengikat itu tidak baik, bahkan gambar, bahkan berbaring di bawah kaki Anda; </li><li>  Mereka harus disimpan di suatu tempat.  File-file ini sangat buruk: tidak sengaja terhapus - dan tidak ada tombol.  Sumber dayanya lebih baik, tetapi saya juga tidak merasa jika saya bisa bertahan; </li><li>  Tidak ada skalabilitas; </li><li>  Kemampuan penyesuaian (warna, misalnya) dicapai hanya dengan menambahkan file.  Yaitu, sumber daya intensif dan tidak fleksibel. </li></ul><br><p>  Hal kedua yang mengikuti dari yang pertama adalah menggunakan gambar vektor, bukan gambar.  Selain itu, Qt dapat membuat SVG.  Di sini sudah sedikit lebih mudah dengan pencarian gambar itu sendiri: ada banyak pelajaran tentang grafik vektor dalam jaringan, Anda dapat menemukan sesuatu yang lebih atau kurang cocok dan menyesuaikannya dengan kebutuhan Anda.  Tetapi pertanyaannya tetap penyimpanan dan kustomisasi, dan rendering tidak gratis untuk sumber daya.  Uang, tentu saja, tetapi masih ... </p><br><p>  Dan yang ketiga mengikuti dari yang kedua: Anda dapat menggunakan prinsip-prinsip grafik vektor untuk gambar gambar sendiri!  File gambar vektor dalam bentuk teks menunjukkan apa dan bagaimana cara menggambar.  Saya dapat menentukan kode yang sama menggunakan tutorial vektor.  Untungnya, objek QPainter memiliki alat yang diperlukan: pena, kuas, gradien dan gambar primitif, bahkan isian tekstur.  Ya, alat-alatnya jauh dari semua: tidak ada topeng, mode campuran, tapi sama sekali tidak diperlukan fotorealisme. </p><br><p>  Saya mencari beberapa contoh di internet.  Dia mengambil pelajaran pertama yang muncul: "Kami menggambar tombol di editor grafis Inkscape" dari situs "Sangat mudah untuk menggambar."  Tombol dari pelajaran ini jauh lebih seperti bola lampu daripada tombol, yang sangat cocok untukku.  Saya membuat konsep: alih-alih Inkscape, proyek di Qt. </p><br><h2 id="proba-pera">  Tes bulu </h2><br><p>  Saya membuat proyek baru.  Saya memilih nama proyek rgbled (karena saya ingin melakukan sesuatu seperti LED RGB) dan jalur untuk itu.  Saya memilih kelas dasar QWidget dan nama RgbLed, saya menolak untuk membuat file formulir.  Proyek secara default setelah peluncuran membuat jendela kosong, itu masih tidak menarik. </p><br><h3 id="podgotovka-k-risovaniyu">  Persiapan untuk menggambar </h3><br><p>  Ada yang kosong.  Sekarang Anda perlu mendapatkan anggota pribadi dari kelas, yang akan menentukan geometri gambar.  Keuntungan penting dari grafik vektor adalah skalabilitasnya, sehingga harus ada jumlah minimum yang konstan, dan mereka hanya mengatur proporsi.  Dimensi akan dihitung ulang dalam acara resizeEvent (), yang perlu didefinisikan ulang. </p><br><p>  Dalam tutorial menggambar yang digunakan, dimensi ditentukan dalam piksel saat Anda melanjutkan.  Saya harus menentukan terlebih dahulu apa yang akan saya gunakan dan bagaimana cara menghitung ulang. </p><br><p>  Gambar yang diambil terdiri dari elemen-elemen berikut: </p><br><ul><li>  cincin luar (condong ke luar, bagian tepi cembung) </li><li>  cincin bagian dalam (miring ke dalam) </li><li>  Rumah lampu LED, "kaca" </li><li>  bayangan di tepi kaca </li><li>  sorotan teratas </li><li>  suar bawah </li></ul><br><p>  Lingkaran konsentris, yaitu segala sesuatu kecuali silau, ditentukan oleh posisi pusat dan jari-jari.  Silau ditentukan oleh pusat, lebar dan tinggi, dan posisi pusat-pusat silau X bertepatan dengan posisi pusat X dari keseluruhan gambar. </p><br><p>  Untuk menghitung elemen geometri, Anda perlu menentukan mana yang lebih besar - lebar atau tinggi, karena bohlam bulat dan harus masuk ke dalam persegi dengan sisi sama dengan yang lebih kecil dari dua dimensi.  Jadi, saya menambahkan anggota pribadi yang sesuai ke file header. </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minDim; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> half; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerY; QRect drawingRect; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> outerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> innerBorderRadius; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> topReflexHeight; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexWidth; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bottomReflexHeight;</code> </pre> </div></div><br><p>  Lalu saya mendefinisikan kembali fungsi yang dilindungi yang disebut ketika widget diubah ukurannya. </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: void resizeEvent(QResizeEvent *event); void RgbLed::resizeEvent(QResizeEvent *event) { QWidget::resizeEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;height = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().height(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size().width(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;minDim = (height &gt; width) ? width : height; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;half = minDim / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerX = width / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;centerY = height / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderWidth = minDim / <span class="hljs-number"><span class="hljs-number">14</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;outerBorderRadius = half - outerBorderWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;innerBorderRadius = half - (outerBorderWidth + innerBorderWidth); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexY = centerY - (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexY = centerY + (half - outerBorderWidth - innerBorderWidth) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;topReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexHeight = half / <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;bottomReflexWidth = half / <span class="hljs-number"><span class="hljs-number">3</span></span>; drawingRect.setTop((height - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setLeft((width - minDim) / <span class="hljs-number"><span class="hljs-number">2</span></span>); drawingRect.setHeight(minDim); drawingRect.setWidth(minDim); }</code> </pre> </div></div><br><p>  Di sini, sisi bujur sangkar yang menjadi tempat bohlam bertulis dihitung, bagian tengah bujur sangkar, jari-jari pelek yang menempati area semaksimal mungkin, lebar pelek, bagian luarnya harus 1/10 dari diameter, dan bagian dalam 1/14.  Kemudian posisi silau, yang terletak di tengah jari-jari atas dan bawah, dihitung, lebar dan tinggi dipilih oleh mata. </p><br><p>  Selain itu, di bidang yang dilindungi saya akan segera menambahkan satu set warna untuk digunakan. </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ledColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> lightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> shadowColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowDarkColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowMedColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> ringShadowLightColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexUpColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> topReflexDownColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexCenterColor; <span class="hljs-attribute"><span class="hljs-attribute">QColor</span></span> bottomReflexSideColor;</code> </pre> </div></div><br><p>  Dengan namanya, kira-kira jelas bahwa ini adalah warna bola lampu, bagian terang bayangan, bagian gelap bayangan, tiga warna bayangan berbentuk lingkaran di sekitar bola lampu dan warna gradien silau. </p><br><p>  Warna harus diinisialisasi, jadi saya akan melengkapi benda kerja desainer. </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre> <code class="hljs php">RgbLed::RgbLed(QWidget *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) : QWidget(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>), ledColor(Qt::green), lightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>, <span class="hljs-number"><span class="hljs-number">0xE0</span></span>)), shadowColor(QColor(<span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)), ringShadowDarkColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>)), ringShadowMedColor(QColor(<span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x50</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>)), ringShadowLightColor(QColor(<span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), topReflexUpColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xA0</span></span>)), topReflexDownColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexCenterColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>)), bottomReflexSideColor(QColor(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x70</span></span>)) { }</code> </pre> </div></div><br><p>  Juga, jangan lupa untuk memasukkan dalam file header inklusi kelas yang akan dibutuhkan saat menggambar. </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPainter&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QPen&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QBrush&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QColor&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QGradient&gt;</span></span></span></span></code> </pre> </div></div><br><p>  Kode ini berhasil dikompilasi, tetapi tidak ada yang berubah di jendela widget.  Sudah waktunya untuk mulai menggambar. </p><br><h3 id="risovanie">  Menggambar </h3><br><p>  Saya memasukkan fungsi tertutup </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawLed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QColor &amp;color</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  dan mendefinisikan kembali fungsi yang dilindungi </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">paintEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QPaintEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  Peristiwa menggambar kembali akan menyebabkan gambar yang sebenarnya, yang warna "kaca" dilewatkan sebagai parameter. </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::paintEvent(QPaintEvent *event) { QWidget::paintEvent(event); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;drawLed(ledColor); }</code> </pre> </div></div><br><p>  Sejauh ini.  Dan kita mulai secara bertahap mengisi fungsi menggambar. </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::drawLed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QColor &amp;color) { <span class="hljs-function"><span class="hljs-function">QPainter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; QPen pen; pen.setStyle(Qt::NoPen); p.setPen(pen); }</code> </pre> </div></div><br><p>  Pertama, objek artis dibuat, yang akan digunakan dalam menggambar.  Kemudian pensil dibuat yang diperlukan sehingga tidak ada pensil: dalam gambar ini, garis besar stroke tidak hanya tidak diperlukan, tetapi tidak diperlukan sama sekali. </p><br><p>  Kemudian lingkaran pertama digambar sesuai dengan pelajaran tentang grafik vektor: lingkaran besar, diisi dengan gradien radial.  Gradien memiliki titik jangkar cahaya di bagian atas, tetapi tidak di bagian paling ujung, dan yang gelap di bagian bawah, tetapi juga tidak di bagian paling ujung.  Kuas dibuat berdasarkan gradien, dengan pelukis kuas ini melukis lingkaran (yaitu, elips yang tertulis dalam kotak).  Ternyata kode seperti itu </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient outerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY - outerBorderRadius - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">outerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; outerRingGradient.setColorAt(0, lightColor); outerRingGradient.setColorAt(1, shadowColor); QBrush outerRingBrush(outerRingGradient); p.setBrush(outerRingBrush); p.drawEllipse(this-&gt;drawingRect); qDebug() &lt;&lt; "draw";</span></span></code> </pre> </div></div><br><p>  Lingkungan menekankan parameter warna dari fungsi drawLed karena tidak digunakan.  Biarkan dia bertoleransi, dia belum dibutuhkan, tetapi dia akan segera membutuhkannya.  Proyek yang diluncurkan menghasilkan hasil sebagai berikut: </p><br><div class="spoiler">  <b class="spoiler_title">menggambar</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tr/d5/w4/trd5w4j8fbipcfgzjzhgydbxln8.png"></p></div></div><br><p>  Tambahkan kumpulan kode lain. </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QRadialGradient innerRingGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY + innerBorderRadius + (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>)), minDim - (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>))<span class="hljs-comment"><span class="hljs-comment">; innerRingGradient.setColorAt(0, lightColor); innerRingGradient.setColorAt(1, shadowColor); QBrush innerRingBrush(innerRingGradient); p.setBrush(innerRingBrush); p.drawEllipse(QPoint(centerX, centerY), outerBorderRadius, outerBorderRadius);</span></span></code> </pre> </div></div><br><p>  Lingkarannya hampir sama, hanya berukuran lebih kecil dan terbalik.  Kami mendapatkan gambar berikut: </p><br><div class="spoiler">  <b class="spoiler_title">menggambar</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sl/qa/-p/slqa-p1yxoytsvbaw86hsqniexw.png"></p></div></div><br><p>  Maka akhirnya Anda membutuhkan warna kaca: </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QColor</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.darker</span></span>(120)); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dark</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">glassBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Di sini, menggunakan fungsi yang lebih gelap dari warna yang ditransmisikan, warna yang sama diperoleh, tetapi lebih gelap, untuk mengatur gradien.  Koefisien 120 dipilih oleh mata.  Inilah hasilnya: </p><br><div class="spoiler">  <b class="spoiler_title">menggambar</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/hs/wq/dl/hswqdl5hkf_fxabxawraf8alsgq.png"></p></div></div><br><p>  Tambahkan bayangan annular di sekitar kaca.  Ini dilakukan dalam pelajaran tentang grafik vektor, dan ini harus menambah volume dan realisme: </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">QRadialGradient</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowLightColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(0<span class="hljs-selector-class"><span class="hljs-selector-class">.85</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowMedColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setColorAt</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">ringShadowDarkColor</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">QBrush</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowGradient</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setBrush</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shadowBrush</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">p</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.drawEllipse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">QPoint</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">centerX</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">centerY</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">innerBorderRadius</span></span>);</code> </pre> </div></div><br><p>  Ada gradien tiga langkah, sehingga bayangan lebih tebal ke tepi dan berubah pucat menuju pusat.  Ternyata seperti ini: </p><br><div class="spoiler">  <b class="spoiler_title">menggambar</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ga/0n/wj/ga0nwjnp8vjh6yupym3d_yyo5lc.png"></p></div></div><br><p>  Tambahkan highlight, keduanya sekaligus.  Sorotan atas, tidak seperti yang lebih rendah (dan semua elemen lainnya), dibuat gradien linier.  Artis saya begitu-begitu, saya mengambil kata saya untuk penulis pelajaran.  Mungkin ada kebenarannya, saya tidak akan bereksperimen dengan berbagai jenis gradien. </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre> <code class="hljs lisp"> QLinearGradient topTeflexGradient(<span class="hljs-name"><span class="hljs-name">QPoint</span></span>(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, (<span class="hljs-name"><span class="hljs-name">innerBorderWidth</span></span> + outerBorderWidth)), QPoint(<span class="hljs-name"><span class="hljs-name">centerX</span></span>, centerY))<span class="hljs-comment"><span class="hljs-comment">; topTeflexGradient.setColorAt(0, topReflexUpColor); topTeflexGradient.setColorAt(1, topReflexDownColor); QBrush topReflexbrush(topTeflexGradient); p.setBrush(topReflexbrush); p.drawEllipse(QPoint(centerX, topReflexY), topReflexWidth, topReflexHeight); QRadialGradient bottomReflexGradient(QPoint(centerX, bottomReflexY + (bottomReflexHeight / 2)), bottomReflexWidth); bottomReflexGradient.setColorAt(0, bottomReflexSideColor); bottomReflexGradient.setColorAt(1, bottomReflexCenterColor); QBrush bottomReflexBrush(bottomReflexGradient); p.setBrush(bottomReflexBrush); p.drawEllipse(QPoint(centerX, bottomReflexY), bottomReflexWidth, bottomReflexHeight);</span></span></code> </pre> </div></div><br><p>  Faktanya, itu semua, bola lampu yang sudah jadi, seperti pada KDPV. </p><br><div class="spoiler">  <b class="spoiler_title">menggambar</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/99/xx/bm/99xxbmwsmy1r6fo-dht2pif7wdg.png"></p></div></div><br><p>  Visibilitas silau dan tonjolan kaca dipengaruhi oleh warna, atau lebih tepatnya, seberapa gelap itu.  Mungkin masuk akal untuk menambahkan penyesuaian untuk kecerahan silau dan koefisien peredupan dalam fungsi yang lebih gelap tergantung pada kegelapan, tapi ini perfeksionisme, saya pikir. </p><br><p>  Di bawah ini adalah contoh penggunaan di jendela program. </p><br><div class="spoiler">  <b class="spoiler_title">menggambar</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xy/tt/ix/xyttix1vqiabybl7-no-9d2dgk8.png"></p></div></div><br><h3 id="balovstvo">  Memanjakan </h3><br><p>  Untuk bersenang-senang, Anda bisa bermain-main dengan bunga.  Misalnya, mengganti acara klik mouse yang dilindungi </p><br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mousePressEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">QMouseEvent *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">event</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><p>  dengan cara ini: </p><br><div class="spoiler">  <b class="spoiler_title">kode</b> <div class="spoiler_text"><pre> <code class="hljs axapta"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RgbLed::mousePressEvent(QMouseEvent *event) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event-&gt;button() == Qt::LeftButton) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">count</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: ledColor = Qt::red; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: ledColor = Qt::green; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: ledColor = Qt::blue; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: ledColor = Qt::gray; <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ledColor = QColor(<span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">count</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;repaint(); } QWidget::mousePressEvent(event); }</code> </pre> </div></div><br><p>  tidak lupa menambahkan acara mouse ke header: </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QMouseEvent&gt;</span></span></span></span></code> </pre> <br><p>  Sekarang klik mouse pada komponen akan mengubah warna bola lampu: merah, hijau, biru, abu-abu dan beberapa cahaya acak dari lampu. </p><br><h2 id="epilog">  Epilog </h2><br><p>  Sedangkan untuk menggambar, itu saja.  Dan widget harus menambahkan fungsionalitas.  Dalam kasus saya, bidang Boolean "status penggunaan" ditambahkan, bidang Boolean lain yang mendefinisikan status "Aktif" atau "Tidak Aktif" dan warna default untuk status ini, serta getter terbuka dan setter untuk semua ini. Kolom ini digunakan dalam fungsi paintEvent () untuk memilih warna yang diteruskan ke drawLed () sebagai parameter. Sebagai akibatnya, Anda dapat mematikan penggunaan status dan mengatur bohlam ke warna apa pun, atau menghidupkan status dan menghidupkan atau mematikan bohlam berdasarkan peristiwa. Terutama nyaman untuk membuat setter keadaan terbuka dan slot siam  baik itu dengan sinyal yang harus dipantau. </p><br><p>  Menggunakan mousePressEvent menunjukkan bahwa widget dapat dibuat tidak hanya sebagai indikator, tetapi juga sebuah tombol, yang membuatnya ditekan, dilepaskan, dibengkokkan, dipelintir, diwarnai dan apa pun yang Anda inginkan untuk acara menunjuk, mengklik, dan melepaskan. </p><br><p>  Tetapi ini tidak lagi mendasar.  Tujuannya adalah untuk menunjukkan di mana Anda dapat mengambil model peran ketika menggambar widget Anda sendiri dan bagaimana rendering ini mudah diterapkan tanpa menggunakan gambar raster atau vektor, dalam sumber daya atau file. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425547/">https://habr.com/ru/post/id425547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425531/index.html">Pendinginan rem cair. Opsi Pengembangan Sistem</a></li>
<li><a href="../id425533/index.html">Cara bekerja di cloud: dari memeriksa keandalan pusat data hingga mengelola infrastruktur virtual</a></li>
<li><a href="../id425537/index.html">Bagaimana menggabungkan Java, Js dan grafik dengan seni, atau kisah tentang bagaimana teater interaktif dibuat</a></li>
<li><a href="../id425541/index.html">Cara cepat dan tanpa chip yang tidak perlu menghindari kekekalan alamat HTU21</a></li>
<li><a href="../id425545/index.html">Anda harus memikirkan jam latihan.</a></li>
<li><a href="../id425549/index.html">Saham Supermicro jatuh di tengah penyelidikan penyebaran chip mata-mata Cina</a></li>
<li><a href="../id425551/index.html">Siapa yang harus menerima uang dari penjualan karya seni yang dibuat oleh AI?</a></li>
<li><a href="../id425553/index.html">Apa yang Dapat Diceritakan oleh Pangeran Monte Cristo Tentang Keamanan Siber</a></li>
<li><a href="../id425555/index.html">Charles Nutter pada bahasa dinamis di JVM di jug.msk.ru</a></li>
<li><a href="../id425557/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 10: Eksekusi Simbolik, Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>