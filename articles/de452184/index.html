<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏿 🔠 💉 Über Anonymität in kontobasierten Blockchains 👨‍👨‍👦‍👦 🍾 🤛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir haben uns seit langem für das Thema Anonymität in Kryptowährungen interessiert und versuchen, die Entwicklung von Technologien in diesem Bereich z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Über Anonymität in kontobasierten Blockchains</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/exante/blog/452184/">  Wir haben uns seit langem für das Thema Anonymität in Kryptowährungen interessiert und versuchen, die Entwicklung von Technologien in diesem Bereich zu verfolgen.  In unseren Artikeln haben wir bereits die Grundsätze für den Betrieb <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vertraulicher Transaktionen</a> in Monero eingehend untersucht und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vergleichende Überprüfung der</a> in diesem Bereich vorhandenen Technologien durchgeführt.  Alle anonymen Kryptowährungen basieren heute jedoch auf dem von Bitcoin - Unspent Transaction Output (im Folgenden: UTXO) vorgeschlagenen Datenmodell.  Bei kontobasierten Blockchains wie Ethereum haben vorhandene Lösungen für die Implementierung von Anonymität und Datenschutz (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mobius</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aztec</a> ) versucht, das UTXO-Modell in intelligenten Verträgen zu wiederholen. <br><br>  Im Februar 2019 eine Gruppe von Forschern der Stanford University und Visa Research <a name="habracut"></a>  veröffentlichte den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Preprint</a> "Zether: Auf dem Weg zum Datenschutz in der Welt der intelligenten Verträge".  Die Autoren schlugen zunächst einen Ansatz zur Gewährleistung der Anonymität in kontobasierten Blockchains vor und stellten zwei Optionen für einen intelligenten Vertrag vor: für vertrauliche (Ausblenden von Guthaben und Überweisungsbeträgen) und anonyme (Ausblenden von Empfänger und Absender) Transaktionen.  Wir finden die vorgeschlagene Technologie interessant und möchten ihr Gerät teilen und darüber sprechen, warum das Anonymitätsproblem in kontobasierten Blockchains als sehr komplex angesehen wird und ob es den Autoren gelungen ist, es vollständig zu lösen. <br><br><cut></cut><br><br><h3>  Über das Gerät dieser Datenmodelle </h3><br>  Im UTXO-Modell besteht eine Transaktion aus „Eingaben“ und „Ausgaben“.  Ein direktes Analogon zu den „Ausgängen“ ist die Banknote in Ihrer Brieftasche: Jeder „Ausgang“ hat eine bestimmte Stückelung.  Wenn Sie mit jemandem bezahlen (eine Transaktion bilden), geben Sie eine oder mehrere "Ausgaben" aus, während diese zu "Eingaben" der Transaktion werden, und die Blockchain markiert sie als ausgegeben.  Gleichzeitig erhält der Empfänger Ihrer Zahlung (oder Sie selbst, wenn Sie eine Änderung benötigen) die neu generierten „Ausgaben“.  Schematisch kann dies wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/webt/tj/ed/8o/tjed8olalcrirbjpupoms6bwejo.png" alt="Bild"><br><br>  Kontobasierte Blockchains sind wie Ihr Bankkonto aufgebaut.  Sie arbeiten nur mit dem Betrag auf Ihrem Konto und dem Überweisungsbetrag.  Wenn Sie einen bestimmten Betrag von Ihrem Konto überweisen, verbrennen Sie keine "Ausgänge". Das Netzwerk muss sich nicht merken, welche Münzen ausgegeben werden und welche nicht.  Im einfachsten Fall reduziert sich die Überprüfung einer Transaktion auf die Überprüfung der Unterschrift des Absenders und des Betrags in seiner Bilanz: <br><br><img src="https://habrastorage.org/webt/kw/pg/zn/kwpgzn1wg1mmztznetqntcdfbca.png" alt="Bild"><br><br><h3>  Technologie-Analyse </h3><br>  Als nächstes werden wir darüber sprechen, wie Zether die Anzahl der Transaktionen, den Empfänger und den Absender verbirgt.  Im Verlauf der Beschreibung der Prinzipien seiner Arbeit werden wir die Unterschiede in der vertraulichen und anonymen Version feststellen.  Da die Gewährleistung des Datenschutzes in kontobasierten Blockchains viel einfacher ist, sind einige der durch die Anonymisierung auferlegten Einschränkungen für eine vertrauliche Version der Technologie nicht relevant. <br><br><h4>  Verschleierung von Guthaben und Überweisungsbeträgen </h4><br>  Zether verwendet das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">El Gamal-</a> Verschlüsselungsschema, um Guthaben zu verschlüsseln und Beträge zu übertragen.  Es funktioniert wie folgt.  Wenn Alice Bob <i><b>b</b></i> Münzen an die Adresse (seinen öffentlichen Schlüssel) <i><b>Y</b></i> senden möchte, wählt sie eine Zufallszahl <i><b>r</b></i> und verschlüsselt den Betrag: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ky/t6/3x/kyt63xxqcoleppvesgfpoubyj8y.png" alt="Bild"></div><br>  wobei <i><b>C</b></i> die verschlüsselte Summe ist, <i><b>D</b></i> der Hilfswert ist, der zum Entschlüsseln dieser Summe benötigt wird, <i><b>G</b></i> der feste Punkt auf der elliptischen Kurve ist, wenn der geheime Schlüssel multipliziert wird, mit dem der öffentliche Schlüssel erhalten wird. <br><br>  Wenn Bob diese Werte erhält, fügt er sie einfach zu seinem Guthaben hinzu, das auf die gleiche Weise verschlüsselt ist, was für dieses Schema praktisch ist. <br><br>  In ähnlicher Weise subtrahiert Alice dieselben Werte von ihrer Bilanz und verwendet nur <i><b>Y</b></i> als ihren öffentlichen Schlüssel. <br><br><h4>  Verschleierung des Adressaten und des Absenders </h4><br>  Das Mischen von „Exits“ in UTXO trat zu Beginn der Kryptowährungen auf und hilft, den Absender zu verbergen.  Zu diesem Zweck sammelt der Absender bei einer Überweisung zufällige „Ausgänge“ in der Blockchain und knetet sie mit seinen eigenen.  Dann signiert er die „Ausgänge“ mit einer Ringsignatur - ein kryptografischer Mechanismus, mit dem er den Prüfer davon überzeugen kann, dass sich unter den beteiligten „Ausgängen“ Absender-Münzen befinden.  Die betroffenen Münzen selbst werden natürlich nicht verschwendet. <br><br>  Um den Empfänger zu verbergen, können wir jedoch keine gefälschten „Ausgaben“ generieren.  Daher hat in UTXO jeder „Ausgang“ seine eigene eindeutige Adresse und ist kryptografisch mit der Adresse des Empfängers dieser Münzen verknüpft.  Im Moment gibt es keine Möglichkeit, die Beziehung zwischen der eindeutigen "Exit" -Adresse und der Adresse des Empfängers zu identifizieren, ohne seine geheimen Schlüssel zu kennen. <br><br>  In einem kontobasierten Modell können wir keine einmaligen Adressen verwenden (andernfalls handelt es sich bereits um ein Modell für "Exits").  Daher müssen Empfänger und Absender unter anderen Konten in der Blockchain geknetet werden.  Gleichzeitig werden verschlüsselte 0-Münzen von den gekneteten Konten abgebucht (oder 0 wird hinzugefügt - im Falle eines Knetens des Empfängers), ohne dass sich der tatsächliche Kontostand ändert. <br><br>  Da sowohl der Absender als auch der Empfänger immer eine permanente Adresse haben, müssen hier dieselben Gruppen zum Mischen mit denselben Adressen verwendet werden.  Es ist einfacher, dies anhand eines Beispiels zu betrachten. <br><br>  Angenommen, Alice hat beschlossen, zu Bobs Wohltätigkeit beizutragen, zieht es jedoch vor, dass die Übertragung für einen externen Beobachter anonym bleibt.  Um sich im Feld des Absenders zu verkleiden, gibt sie dann auch die Konten von Adam und Adele ein.  Und um Bob zu verstecken - im Empfängerfeld zusätzlich Ben- und Bill-Konten.  Alice machte die nächste Rate und beschloss, Alex und Amanda neben sich und Bruce und Bengen neben Bob zu betreten.  In diesem Fall gibt es bei der Analyse der Blockchain in diesen beiden Transaktionen nur ein sich überschneidendes Teilnehmerpaar - Alice und Bob, die diese Transaktionen dekanonymisieren. <br><br><img src="https://habrastorage.org/webt/dj/o6/x0/djo6x0r31q3_bzpa78t0cklzt_i.png" alt="Bild"><br><br><h4>  Transaktionsrennen </h4><br>  Wie bereits erwähnt, verschlüsselt der Benutzer sein Guthaben und den Überweisungsbetrag, um sein Guthaben in kontobasierten Systemen zu verbergen.  Darüber hinaus muss er nachweisen, dass der Saldo auf seinem Konto nicht negativ bleibt.  Das Problem ist, dass der Benutzer beim Erstellen einer Transaktion Beweise für seinen aktuellen Status des Kontos erstellt.  Und was passiert, wenn Bob eine Transaktion an Alice sendet und diese früher akzeptiert wird als von Alice gesendet?  Dann wird Alices Transaktion als ungültig angesehen, da der Nachweis des Gleichgewichts vor der Annahme der Transaktion Bob erstellt wurde. <br><br><img src="https://habrastorage.org/webt/bn/d0/7z/bnd07z43bu5m76fbbvjlvda7ek0.png" alt="Bild"><br><br>  Die erste Lösung in einer solchen Situation besteht darin, Ihr Konto vor der Transaktion einzufrieren.  Dieser Ansatz ist jedoch nicht geeignet, da neben der Komplexität der Lösung eines solchen Problems in einem verteilten System in einem anonymen Schema nicht klar ist, wessen Konto gesperrt werden soll. <br><br>  Um dieses Problem zu lösen, trennt die Technologie eingehende und ausgehende Transaktionen: Geldausgaben wirken sich unmittelbar auf die Bilanz aus und Einnahmen werden abgegrenzt.  Dazu wird das Konzept der „Ära“ eingeführt - eine Gruppe von Blöcken fester Größe.  Die aktuelle „Ära“ wird bestimmt, indem die Blockhöhe durch die Größe der Gruppe geteilt wird.  Bei der Verarbeitung der Transaktion aktualisiert das Netzwerk sofort den Kontostand des Absenders und fügt das Guthaben des Empfängers dem Laufwerk hinzu.  Die angesammelten Mittel stehen dem Zahlungsempfänger nur dann zur Verfügung, wenn eine neue „Ära“ beginnt. <br><br>  Infolgedessen kann der Benutzer Transaktionen senden, unabhängig davon, wie oft er Geld erhält (sofern sein Kontostand dies zulässt).  Die Größe einer Epoche hängt davon ab, wie schnell sich die Blöcke im Netzwerk ausbreiten und wie schnell die Transaktion in den Block fällt. <br><br>  Diese Lösung funktioniert gut bei vertraulichen Überweisungen, aber bei anonymen Transaktionen treten, wie wir später sehen werden, ernsthafte Probleme auf. <br><br><h4>  Angriffsschutz wiederholen </h4><br>  In kontobasierten Blockchains wird jede Transaktion mit dem privaten Schlüssel des Absenders signiert, wodurch der Prüfer davon überzeugt wird, dass die Transaktion nicht geändert wurde und vom Eigentümer dieses Schlüssels erstellt wurde.  Was aber, wenn der Angreifer, der den Übertragungskanal abgehört hat, diese Nachricht abfängt und genau dieselbe Sekunde sendet?  Der Prüfer überprüft die Unterschrift der Transaktion und ist von ihrer Urheberschaft überzeugt, und das Netzwerk belastet den Saldo des Absenders erneut mit dem gleichen Betrag. <br><br>  Dieser Angriff wird als Wiederholungsangriff bezeichnet.  Im UTXO-Modell sind solche Angriffe nicht relevant, da der Angreifer versucht, die verbrauchten Ausgaben zu verwenden, die an sich nicht gültig sind und vom Netzwerk zurückgewiesen werden. <br><br>  Um dies zu verhindern, wird ein zufälliges Datenfeld in die Transaktion eingefügt, das als Nonce oder einfach als "Salt" bezeichnet wird.  Wenn Sie eine Transaktion mit einem Salt erneut senden, prüft der Prüfer, ob diese Nonce bereits verwendet wurde, und betrachtet diese Transaktion, falls nicht, als gültig.  Um nicht den gesamten Verlauf von Nonce-Benutzern in der Blockchain zu speichern, wird dieser normalerweise bei der ersten Transaktion als Null angenommen und dann um Eins erhöht.  Das Netzwerk kann nur überprüfen, ob sich die Nonce der neuen Transaktion von der Vergangenheit um eins unterscheidet. <br><br>  In einem anonymen Übersetzungsschema tritt das Problem der Validierung von Nonce-Transaktionen auf.  Wir können nonce nicht explizit an die Absenderadresse binden, da dies offensichtlich die Übersetzung deanonymisiert.  Wir können auch keine Einheit zum Nonce aller teilnehmenden Konten hinzufügen, da dies zu Konflikten mit anderen Übersetzungen führen kann, die verarbeitet werden. <br><br>  Die Autoren von Zether schlagen vor, Nonce kryptografisch zu generieren - abhängig von der "Ära".  Zum Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5q/ku/zu/5qkuzus5hr-5168x4ieihiwtbjw.png" alt="Bild"></div><br>  Hier ist <b><i>x</i></b> der geheime Schlüssel des Absenders, und die <b><i>G- <sub>Epoche</sub></i></b> ist ein zusätzlicher Generator für die Ära, der durch Hashing einer Zeichenfolge der Form 'Zether +' erhalten wird.  Nun scheint das Problem gelöst zu sein - wir legen das Nonce des Absenders nicht offen und stören das Nonce der unbeteiligten Teilnehmer nicht.  Dieser Ansatz stellt jedoch eine ernsthafte Einschränkung dar: Ein Konto kann in der „Ära“ nicht mehr als eine Transaktion senden.  Dieses Problem bleibt leider ungelöst und macht derzeit eine anonyme Version von Zether unserer Meinung nach kaum zur Verwendung geeignet. <br><br><h4>  Zero-Confidence-Beweise </h4><br>  Bei UTXO muss der Absender dem Netzwerk nachweisen, dass er keinen negativen Betrag ausgibt, da es sonst möglich wird, neue Münzen aus der Luft zu generieren (warum dies möglich war, haben wir in einem der vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel geschrieben</a> ).  Und unterschreiben Sie auch die „Eingaben“ mit einer Ringsignatur, um zu beweisen, dass sich unter den Knetmünzen Gelder befinden, die ihm gehören. <br><br>  In der anonymen Version der kontobasierten Blockchain sind Beweisausdrücke viel komplizierter.  Der Absender beweist, dass: <br><br><ol><li>  Der gesendete Betrag ist positiv; </li><li>  Der Saldo bleibt nicht negativ; </li><li>  Der Absender hat die Anzahl der Überweisungen (einschließlich Null) korrekt verschlüsselt. </li><li>  Der Kontostand wird nur vom Absender und vom Empfänger geändert. </li><li>  Der Absender besitzt den geheimen Schlüssel von seinem Konto und steht wirklich auf der Liste der Absender (unter den Beteiligten). </li><li>  Die in der Transaktion verwendete Nonce ist korrekt zusammengesetzt. </li></ol><br>  Für solch komplexe Beweise verwenden die Autoren eine Mischung aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bulletproof</a> (einer der Autoren war übrigens an seiner Erstellung beteiligt) und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sigma-Protokoll</a> , das Sigma-Bullets genannt wird.  Der formale Nachweis einer solchen Aussage ist eine ziemlich schwierige Aufgabe und schränkt die Anzahl der Personen, die mit der Implementierung der Technologie beginnen möchten, erheblich ein. <br><br><h4>  Was ist das Ergebnis? </h4><br>  Unserer Meinung nach kann der Teil von Zether, der kontobasierten Blockchains Datenschutz verleiht, jetzt durchaus verwendet werden.  Gegenwärtig unterliegt eine anonyme Version der Technologie ernsthaften Einschränkungen bei ihrer Verwendung und ihrer Komplexität bei der Implementierung.  Vergessen Sie jedoch nicht, dass die Autoren es erst vor wenigen Monaten veröffentlicht haben und vielleicht jemand anderes heute eine Lösung für die Probleme finden wird.  In der Tat wird Wissenschaft auf diese Weise betrieben. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452184/">https://habr.com/ru/post/de452184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452172/index.html">Komplexe Systeme. Erreichen eines kritischen Niveaus</a></li>
<li><a href="../de452174/index.html">Er braucht dich nicht</a></li>
<li><a href="../de452178/index.html">Analyse: 23 beliebte Fehler in geschriebenem Englisch und wie man sie vermeidet</a></li>
<li><a href="../de452180/index.html">Wir steigern die Leistung von SSD von den Knien aus, wo und warum zu klicken ist</a></li>
<li><a href="../de452182/index.html">Befragung von Mitarbeitern. Der Hauptfehler</a></li>
<li><a href="../de452186/index.html">Die seltensten und teuersten Programmiersprachen</a></li>
<li><a href="../de452188/index.html">Testen der Json-Serialisierungseinheit in Spring Boot</a></li>
<li><a href="../de452190/index.html">Verwenden von WebAssembly 20x Web Application Accelerated</a></li>
<li><a href="../de452192/index.html">Was ist das hier? Innere Operation von JavaScript-Objekten</a></li>
<li><a href="../de452198/index.html">Was sollte jeder QS-Ingenieur über Selen 4 wissen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>