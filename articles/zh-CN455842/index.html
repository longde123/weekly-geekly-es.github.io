<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏻 🕒 ✒️ 传播一个单链表。 迅捷版 👨‍👦‍👦 👨🏻‍✈️ 🧑🏿‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="众所周知，软件开发人员最喜欢的消遣方式之一就是面试雇主。 我们都是出于完全不同的原因，不时这样做。 我认为，其中最明显的是求职并不是最常见的。 参加面试是保持健康，重复被遗忘的基础知识和学习新知识的好方法。 而且，如果成功的话，还可以增强自信心。 我们感到无聊，我们在诸如“ LinkedIn”之类的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>传播一个单链表。 迅捷版</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455842/">众所周知，软件开发人员最喜欢的消遣方式之一就是面试雇主。 我们都是出于完全不同的原因，不时这样做。 我认为，其中最明显的是求职并不是最常见的。 参加面试是保持健康，重复被遗忘的基础知识和学习新知识的好方法。 而且，如果成功的话，还可以增强自信心。 我们感到无聊，我们在诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ LinkedIn”之</a>类的“商业”社交网络中将自己设置为“开放报价”的状态-人力资源经理大军已经在攻击我们收件箱中的传入消息。 <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/bw/9r/mc/bw9rmcigk0k9beg-50tdq74sadw.jpeg" alt="图片"><br><br> 在此过程中，尽管发生了所有麻烦，但我们面临着许多问题，正如他们在隐性折叠的窗帘的另一侧所说的那样，它们正在“摇铃”，其细节隐藏在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">战争迷雾的</a>背后。 通常只会在通过算法和数据结构进行的测试（个人而言，我根本没有此类数据）以及实际采访中才回忆起它们。 <br><br> 清单是任何专业程序员采访中最常见的问题之一。 例如，单链列表。 以及相关的基本算法。 例如，掉头。 通常，这种情况是这样发生的：“很好，但是您将如何扩展单链表？” 最主要的是让这个问题让申请人感到惊讶。 <br><br> 实际上，所有这些使我写了这篇简短的评论，以不断提醒和启发。 所以，开个玩笑，瞧！ <br><br><h2> 单链表 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链表</a>是基本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据结构之一</a> 。 实际上，它的每个元素（或节点）都由存储的数据和到相邻元素的链接组成。 单链接列表仅存储指向结构中下一个元素的链接，而<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">双链接</a>列表则保存下一个和上一个元素。 这样的数据组织允许它们位于任何存储区域中（例如，与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数组不同</a> ，所有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数组</a>的元素都应该一个接一个地位于内存中）。 <br><br> 当然，关于列表还有很多要说的：它们可以是循环的（即最后一个元素存储到第一个元素的链接），也可以不是（即没有到最后一个元素的链接）。 可以输入列表，即 是否包含相同类型的数据。 依此类推。 <br><br> 最好尝试编写一些代码。 例如，以某种方式可以想象一个列表节点： <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payload: <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(payload: <span class="hljs-type"><span class="hljs-type">T</span></span>, nextNode: <span class="hljs-type"><span class="hljs-type">Node?</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.payload = payload <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.nextNode = nextNode } }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“通用”是</a>在<code>payload</code>字段中能够存储任何类型的有效负载的类型。 <br><br> 该列表本身由其第一个节点详尽地标识： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(firstNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.firstNode = firstNode } }</code> </pre><br> 第一个节点被声明为可选节点，因为列表很可能为空。 <br><br>  <i>从理论上讲，当然，在该类中，您需要实现所有必需的方法-插入，删除，访问节点等，但是我们将在其他时间实现。</i>  <i>同时，我们将检查使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>struct</code></a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apple</a>积极鼓励我们使用的示例）是否是更好的选择，也许还记得<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“写时复制”</a>方法。</i> <br><br><h2> 单链列表传播 </h2><br><h3> 第一种方式。 循环次数 </h3><br> 现在是时候开始做我们今天要从事的事情了！ 处理它的最有效方法是两种方法。 第一个是一个简单的循环，从第一个节点到最后一个节点。 <br><br> 该循环使用三个变量，这些变量在开始之前被分配了上一个，当前和下一个节点的值。  （此时，前一个节点的值自然为空。）该循环从检查下一个节点不为空开始，如果是，则执行循环的主体。 循环中没有任何魔术发生：在当前节点上，指向下一个元素的字段被分配一个指向前一个元素的链接（在第一次迭代时，分别重置了链接的值，这对应于最后一个节点的事务状态）。 进一步，对应于上一个，当前和下一个节点的变量将被分配新值。 退出循环后，当前节点（即通常最后一个可迭代的节点）被分配一个新的链接值到下一个节点，因为 当列表中的最后一个节点成为当前节点时，就会退出循环。 <br><br> 换句话说，这听起来似乎很奇怪而且难以理解，所以最好看一下代码： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> previousNode: <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentNode = firstNode <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nextNode = firstNode?.nextNode <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> nextNode != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { currentNode?.nextNode = previousNode previousNode = currentNode currentNode = nextNode nextNode = currentNode?.nextNode } currentNode?.nextNode = previousNode firstNode = currentNode } }</code> </pre><br> 为了进行验证，我们使用有效载荷为简单<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">整数</a>标识符的节点列表。 创建十个元素的列表： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> node = <span class="hljs-type"><span class="hljs-type">Node</span></span>(payload: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// T == Int let list = SinglyLinkedList(firstNode: node) var currentNode = node var nextNode: Node&lt;Int&gt; for id in 1..&lt;10 { nextNode = Node(payload: id) currentNode.nextNode = nextNode currentNode = nextNode }</span></span></code> </pre><br> 一切似乎都很好，但是我们是人，而不是计算机，这对我们很容易获得所创建列表和上述算法的正确性的直观证明。 也许简单的打印就足够了。 为了使输出可读，将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>CustomStringConvertible</code></a>协议的实现添加<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>CustomStringConvertible</code></a>具有整数标识符<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>CustomStringConvertible</code></a>节点： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomStringConvertible</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstPart = <span class="hljs-string"><span class="hljs-string">""" Node \(Unmanaged.passUnretained(self).toOpaque()) has id \(payload) and """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nextNode = nextNode { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstPart + <span class="hljs-string"><span class="hljs-string">" next node \(nextNode.payload)."</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstPart + <span class="hljs-string"><span class="hljs-string">" no next node."</span></span> } } }</code> </pre><br>  ...并以相应的列表顺序显示所有节点： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomStringConvertible</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description = <span class="hljs-string"><span class="hljs-string">""" List \(Unmanaged.passUnretained(self).toOpaque()) """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> firstNode != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { description += <span class="hljs-string"><span class="hljs-string">" has nodes:\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = firstNode <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { description += (node!.description + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) node = node!.nextNode } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> description } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> description + <span class="hljs-string"><span class="hljs-string">" has no nodes."</span></span> } } }</code> </pre><br> 我们类型的字符串表示形式将包含一个内存地址和一个整数标识符。 使用它们，我们组织了十个节点的生成列表的打印： <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e2380 has id 0 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 6. Node 0x00006000012e8900 has id 6 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 9. Node 0x00006000012e8820 has id 9 and no next node. */</span></span></code> </pre><br> 展开此列表并再次打印： <br><br><pre> <code class="swift hljs">list.<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e8820 has id 9 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 6. Node 0x00006000012e8900 has id 6 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 0. Node 0x00006000012e2380 has id 0 and no next node. */</span></span></code> </pre><br> 您可能会注意到列表和节点的内存中的地址未更改，并且列表的节点以相反的顺序打印。 现在，对节点的下一个元素的引用指向前一个元素（即，例如，节点“ 5”的下一个元素现在不是“ 6”，而是“ 4”）。 这意味着我们做到了！ <br><br><h3> 第二种方式。 递归 </h3><br> 进行相同掉头的第二种已知方法是基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">递归</a> 。 为了实现它，我们将声明一个函数，该函数采用列表的第一个节点，并返回“新”的第一个节点（之前的最后一个节点）。 <br><br> 参数和返回值是可选的，因为在此函数内部，将在每个后续节点上一次又一次地调用它，直到它为空（即直到列表末尾）。 因此，在函数主体中，有必要检查在其上调用该函数的节点是否为空，以及该节点是否具有以下内容。 如果不是，则该函数返回传递给参数的内容。 <br><br> 实际上，我确实尝试用语言描述了完整的算法，但是最后我几乎擦除了所有内容，因为结果难以理解。 绘制流程图并正式描述算法的步骤-同样，在这种情况下，我认为这没有任何意义，因为这对您我来说都更方便阅读和尝试理解<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Swift</a>代码： <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SinglyLinkedList</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverseRecursively</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> node: Node&lt;T&gt;?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Node</span></span>&lt;<span class="hljs-type"><span class="hljs-type">T</span></span>&gt;? { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> head = node <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> head.nextNode == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> head } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> reversedHead = <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(head.nextNode) head.nextNode?.nextNode = head head.nextNode = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reversedHead } firstNode = <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(firstNode) } }</code> </pre><br> 为了调用方便，算法本身由实际列表类型的方法“包装”。 <br><br> 它看起来更短，但我认为更难理解。 <br><br> 我们对之前的价差结果调用此方法，并打印新的结果： <br><br><pre> <code class="swift hljs">list.reverseRecursively() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>(describing: list)) <span class="hljs-comment"><span class="hljs-comment">/* List 0x00006000012e1a60 has nodes: Node 0x00006000012e2380 has id 0 and next node 1. Node 0x00006000012e8d40 has id 1 and next node 2. Node 0x00006000012e8d20 has id 2 and next node 3. Node 0x00006000012e8ce0 has id 3 and next node 4. Node 0x00006000012e8ae0 has id 4 and next node 5. Node 0x00006000012e89a0 has id 5 and next node 6. Node 0x00006000012e8900 has id 6 and next node 7. Node 0x00006000012e8a40 has id 7 and next node 8. Node 0x00006000012e8a60 has id 8 and next node 9. Node 0x00006000012e8820 has id 9 and no next node. */</span></span></code> </pre><br> 从输出中可以看到，存储器中的所有地址都没有再次更改，并且节点现在按照原始顺序进行了跟随（也就是说，它们又被“部署”了）。 这意味着我们再次正确！ <br><br><h3> 结论 </h3><br> 如果仔细研究逆向方法（或进行调用计数实验），您会注意到第一种情况下的循环和第二种情况下的内部（递归）方法调用的次数比列表中节点数少一倍（在本例中为九个）次）。 您还可以注意在第一种情况下循环发生的事情-分配顺序相同-在第二种情况下注意第一个非递归方法调用。 事实证明，在两种情况下，对于十个节点的列表，“圆”都重复了十次。 因此，我们对两种算法都具有线性<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">复杂度</a> <i>-O（n）</i> 。 <br><br> 一般而言，描述的两种算法被认为是解决此问题最有效的方法。 至于计算复杂度，不可能提出一种值较低的算法：一种或另一种方式，您需要“访问”每个节点，以便为存储在链接中的一个节点分配一个新值。 <br><br> 另一个值得一提的功能是“分配的内存复杂性”。 两种提出的算法都会创建固定数量的新变量（第一种情况为三个，第二种情况为一个）。 这意味着分配的内存量不取决于输入数据的定量特性，而是由常数函数O（1）来描述。 <br><br> 但是，实际上，在第二种情况下并非如此。 递归的危险是为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">堆栈</a>上的每个递归调用分配了额外的内存。 在我们的情况下，递归深度对应于输入数据量。 <br><br> 最后，我决定做更多的实验：以一种简单的原始方式，针对不同数量的输入数据，测量了两种方法的绝对执行时间。 像这样： <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> startDate = <span class="hljs-type"><span class="hljs-type">Date</span></span>().timeIntervalSince1970 <span class="hljs-comment"><span class="hljs-comment">// list.reverse() / list.reverseRecursively() let finishDate = Date().timeIntervalSince1970 let runningTime = finishDate – startDate // Seconds</span></span></code> </pre><br> 这就是我得到的（这是来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Playground</a>的原始数据）： <br><br><img src="https://habrastorage.org/webt/kf/at/bf/kfatbfsxar9clyyokzu6beu3ios.png" alt="图片"><br><br>  （不幸的是，我的计算机尚未掌握较大的值。） <br><br> 从表中可以看到什么？ 没什么特别的。 尽管已经注意到递归方法在节点数量相对较少的情况下表现较差，但在100到1000之间的某个地方，它开始表现出更好的效果。 <br><br> 我还在成熟的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Xcode”</a>项目中尝试了相同的简单测试。 结果如下： <br><br><img src="https://habrastorage.org/webt/sr/vj/0d/srvj0dqmtgtse2wfuqq6llutte4.png" alt="图片"><br><br> 首先，值得一提的是，结果是在激活针对执行速度（ <code>-Ofast</code> ）的“积极”优化模式之后获得的，这部分是数量如此之少的原因。 有趣的是，在这种情况下，递归方法表现出更好的效果，相反，仅在非常小的输入数据上并且已经在100个节点的列表上，该方法失败了。 在100,000个中，他使程序异常终止。 <br><br><h2> 结论 </h2><br> 从目前我最喜欢的编程语言的角度来看，我试图涵盖一个相当经典的话题，希望您以及我自己都对进步感到好奇。 如果您也能学到新的东西，我也感到非常高兴-然后，我肯定在本文上浪费了我的时间（而不是坐在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">电视上</a> ）。 <br><br>  <i>如果有人希望跟踪我的社交活动，请访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我的“ Twitter”</a>链接，其中首先有指向我的新帖子的链接，还有更多链接。</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455842/">https://habr.com/ru/post/zh-CN455842/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455828/index.html">科学家发现了新的异国同步形式</a></li>
<li><a href="../zh-CN455830/index.html">看一下.NET开发人员的眼光。 第一周</a></li>
<li><a href="../zh-CN455832/index.html">一次SQL调查的历史记录</a></li>
<li><a href="../zh-CN455834/index.html">Linux服务器基准测试：5个开放工具</a></li>
<li><a href="../zh-CN455840/index.html">如何处理多个查询。 组成，还原剂，FP</a></li>
<li><a href="../zh-CN455846/index.html">Julia中的分布式计算</a></li>
<li><a href="../zh-CN455848/index.html">访问单例时避免未定义行为的技术</a></li>
<li><a href="../zh-CN455852/index.html">窦提升和同时植入</a></li>
<li><a href="../zh-CN455854/index.html">如何在iOS 13中实现上下文菜单</a></li>
<li><a href="../zh-CN455856/index.html">nRF52832上的无线温度，湿度和大气压传感器</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>