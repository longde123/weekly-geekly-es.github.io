<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔪 🛒 🤸🏼 我们在LabVIEW中编写FPGA加载器。 第二部分 👩🏻‍🤝‍👨🏾 🌭 ♌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="通过USB将配置下载到FPGA或拆卸FTDI MPSSE 
 我们在LabVIEW中编写FPGA加载器。 第一部分 


 在第一篇文章中，我们测试了旧版本C上的加载算法，在第二篇文章中，我们了解了如何在LabVIEW中组织程序并实现简单的用户界面。 这次，我们将熟悉LabVIEW中的新工作方法，分...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们在LabVIEW中编写FPGA加载器。 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429448/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过USB将配置下载到FPGA或拆卸FTDI MPSSE</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我们在LabVIEW中编写FPGA加载器。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a> </p><br><img src="https://habrastorage.org/webt/2m/nu/6l/2mnu6ljkhtj-pydr_chsebgpp_i.jpeg"><br><br> 在第一篇文章中，我们测试了旧版本C上的加载算法，在第二篇文章中，我们了解了如何在LabVIEW中组织程序并实现简单的用户界面。 这次，我们将熟悉LabVIEW中的新工作方法，分析错误处理的功能并完成项目：我们实现了将配置文件加载到FPGA中的协议。 <a name="habracut"></a><br><br><h2 id="obrabotka-oshibok"> 错误处理 </h2><br><p>打开源代码，分析函数MPSSE_open。 尽管算法简单（函数被称为另一个函数），但仍需要导入许多D2XX API元素： <code>FT_OpenEx</code> ， <code>FT_ResetDevice</code> ， <code>FT_Purge</code> ， <code>FT_SetUSBParameters</code> ， <code>FT_SetChars</code> ， <code>FT_SetTimeouts</code> ， <code>FT_SetLatencyTimer</code> ， <code>FT_SetFlowControl</code> ， <code>FT_SetBitMode</code> 如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前一篇文章</a>所示，使用“ <code>Call library Function</code>节点执行函数的导入。 该节点具有用于错误控制的专用端子。  LabVIEW有一个简单的规则：所有<abbr title="虚拟设备">VI</abbr>必须跟踪错误并报告错误终端返回的错误。 大多数内置VI都严格遵循它。 我希望每个人都知道控制和处理错误的重要性，尤其是在调试阶段，但这是另一个重要原因，为什么它对“经典”程序员不那么重要。  LabVIEW在程序框图中没有严格的设备顺序：当输入中的数据准备就绪时，将执行设备。 如果将一个VI的输出中的数据传输到另一个VI的输入中，则很显然第一个VI会在开始时起作用，而第二个VI才起作用。 但是，如果不进行数据传输，并且VI执行独立的操作，该怎么办？ 当然，您可以使用繁琐的“平面序列结构”，但是通过一系列错误将设备彼此连接起来会更加方便。 </p><br><p> 导入D2XX函数时，我们会遇到两种类型的错误。 第一个-这是直接导入错误-返回<code>Call library Function</code>块本身。 第二个错误是库本身的错误；几乎每个函数都通过<code>FT_STATUS</code>返回该错误。 头文件ftd2xx.h中将所有可能的值都描述为枚举。 尽管足以知道<code>FT_OK</code>值是没有错误，而所有其他值都是错误代码，但我不仅要跟踪错误本身的事实，而且还要跟踪发生了什么错误以及确切的位置。 </p><br><p> 在LabVIEW中，错误数据通过<code>error</code>簇传播。 这是一种特殊的专用数据类型； LabVIEW具有许多VI和用于处理它的函数。 错误群集由三个元素组成：逻辑变量-显示状态，带符号的整数-错误代码，字符串-错误源。 该状态指示是否发生了错误，错误代码确定了错误的类型，并由特殊VI用来生成报告。 该行给出了错误发生的确切位置的更详细的想法。  LabVIEW接受到，如果状态为<code>TRUE</code> ，则为错误;如果状态为<code>FALSE</code> ，但代码不为零，并且描述行不为空，则为<em>警告</em> ;如果状态为<code>FALSE</code> ，则代码为零，且行为空-无错误。 </p><br><img src="https://habrastorage.org/webt/pm/ku/gv/pmkugvhr1yzt6uarss9lfnmthuc.png"><br><br><p>  LabVIEW包含一个内部数据库，每个错误代码均与其说明相关联。 对于每种类型的错误，都会分配特殊范围的代码值。 例如，对于与网络运行相关的错误，分配了几个范围：–2147467263至–1967390460、61至65、116至118和122、1101、1114、1115、1132至1134、1139至1143和1178至1185为用户定义的错误保留了两个范围，分别是–8999至–8000和5000至9999。从这些范围中，我们可以为D2XX库的错误代码选择值。 </p><br><p> 我们创建一个VI，该VI接收D2XX函数的状态作为输入，并将该状态转换为LabVIEW错误簇。  LabVIEW中的大多数函数和VI在“ <code>Error In</code>输入”输入中处于“ <code>TRUE</code>状态，不执行其代码，而是将错误信息传输至“ <code>Error Out</code>终端。 这使您可以通过整个链有效地将有关源的信息传输到错误处理程序，从而避免了在紧急模式下执行代码。 希望我们的VI具有相似的行为。 </p><br><p> 让我们以<code>enum</code>的形式排列D2XX状态列表，并将其放在单独的类型中（在上一篇文章中，我们使用FTDI类型进行了此操作）。 </p><br><div class="spoiler">  <b class="spoiler_title">枚举FT_Status</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/mb/bp/kp/mbbpkpzguefjrdg2p4l2n7-rpg0.png"></div></div><br><p> 我们将新VI保存为FT_error.vi。 我们将两个群集“ <code>Error In</code>和“ <code>Error Out</code>前面板，您可以在“数组，矩阵和群集”面板中找到它们。 如上一篇文章所述，我们将它们分别连接到左下角和右下角的连接面板上的端子，这是LabVIEW采用的错误流端子的位置。 我们将<code>Case</code>结构添加到框图，将<code>Error In</code>群集提交到<code>Case selector</code>输入，之后<code>Case</code>结构更改颜色并划分两个子图：“无错误”-绿色和“错误”-红色。 在“错误”情况下，我们将错误簇从选择器终端直接传输到右边界的输出隧道。 在绿色案例中，我们根据状态添加另一个<code>Case</code> ，它将确定是创建错误（状态不等于FT_OK）还是保持原样：跳过输入错误集群以退出而不更改。 </p><br><p> 为了将错误代码从技术上转换为群集，可以使用VI <code>Error Cluster From Error Code VI</code> 。 该子<abbr title="子虚拟仪器。他是郊区居民">VI</abbr>在错误描述中添加了一个调用链，因此我们不仅可以确定发生了<strong>什么</strong> ，还可以确定发生<strong>在哪里</strong> 。 </p><br><p> 要选择与输入状态（FT_Status）相对应的文本，请使用属性块：选择“ RingText.Text”。 错误文本<code>Error Cluster From Error Code VI</code>发送到<code>Error Cluster From Error Code VI</code>的<code>error message</code>输入。 <br> 不要忘了画一个“会说话的”图标。 </p><br><div class="spoiler">  <b class="spoiler_title">FT_error.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xx/xw/ub/xxxwubdzodjs1jfaywcbjamsrtg.png"><br>  <em>前（前）子仪器面板</em> </p><br><p><img src="https://habrastorage.org/webt/ja/wu/te/jawuteahiriyixrjpcgbm91esjo.png"><br>  <em>方框图。</em>  <em>输入错误</em> </p><br><p><img src="https://habrastorage.org/webt/yd/qf/lp/ydqflp1m-zexy_zvvdx8drixu9e.png"><br>  <em>方框图。</em>  <em>输入没有错误，状态为FT_OK</em> </p><br><p><img src="https://habrastorage.org/webt/1h/wp/7m/1hwp7mcprzgv3mf9oz3jenbco4q.png"><br>  <em>方框图。</em>  <em>输入没有错误，但状态与FT_OK不同</em> </p><br></div></div><br><p> 要测试FT_error，可以创建一个空的VI，在其中添加创建的VI，并查看在应用各种状态时启动时值将如何变化。 </p><br><div class="spoiler">  <b class="spoiler_title">FT_error.vi测试</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rn/_r/be/rn_rbewvlb--au_hi3nosghkjmk.png"><br>  <em>设备的前（前）面板</em> </p><br><p><img src="https://habrastorage.org/webt/ju/44/fz/ju44fzmyx2aly2-fraydjrkyffg.png"><br>  <em>方块图</em> </p></div></div><br><p> 现在，在从D2XX API调用任何函数之后，我们将使用SubVI FT_error.vi。 在整个调用层次结构中，所有VI都会传递错误簇。 </p><br><p> 在顶级VI中，我们必须决定如何处理检测到的错误：您可以在对话框中显示消息，将其写入报告文件，忽略它，或者简单地“安静地”结束应用程序。 对话框是报告错误的最简单，最流行的方法。 对于新手程序员而言，这也很方便，因为它无关紧要。 在每个VI中，默认情况下均启用了<strong>自动错误处理</strong>模式（位于VI Properties菜单的Execution类别中的<strong>Enable auto error processing</strong> ）。 它的工作原理是：如果某个节点的<code>Error Out</code>输出端子未连接到任何地方，并且此节点发生错误，则LabVIEW将暂停应用程序并显示一个对话框。 如果连接了节点的“ <code>Error Out</code>终端，则错误流将按编程方式传播，并且不会发生其他操作。 但是，可以通过编程方式调用消息窗口，为此，您需要使用<code>General Error Handler</code> <code>Simple Error Handler</code>程序VI和<code>Simple Error Handler</code>程序VI（位于“对话框和用户界面”面板中）。 在这种情况下，我们可以使用错误信息来完成程序。 在框图中，它看起来像这样： </p><br><p> <a href=""><img src="https://habrastorage.org/webt/u9/8y/_p/u98y_paluq1jtgm2gylcaceydgs.png"></a> <br>  <em>可点击的图片</em> </p><br><p> 发生错误时，程序将被挂起，将显示一个报告窗口，关闭该窗口后，程序将正确退出。 </p><br><div class="spoiler">  <b class="spoiler_title">报告窗口</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><h2 id="otkryt-i-zakryt-ftdi"> 打开和关闭FTDI </h2><br><p> 因此，回到<code>MPSSE_open</code>函数。 创建一个新的<abbr title="虚拟仪器">VI</abbr> 。 首先，添加错误流的端子。 添加选择结构，然后<code>Error In</code>选择器上选择“ <code>Error In</code>输入”输入。 在绿色情况下，我们按照Sishny原型中的顺序和参数导入函数。  <code>Call Library Function Node</code>所有节点通过错误流成链状连接。 在通过隧道的红色情况下，我们将<code>Error In</code>与<code>Error In</code>的输出端子连接。 </p><br><p> <a href=""><img src="https://habrastorage.org/webt/4p/qq/zx/4pqqzxgwcgsbb-jcvepvyaj6jam.png"></a> <br>  <em>可点击的图片</em> </p><br><p><img src="https://habrastorage.org/webt/5z/uq/k6/5zuqk6hmya20zgu9ddnciwgj5a0.png"><br>  <em>VI MPSSE_open.vi</em> </p><br><p> 带有FTDI描述的行（ <code>Description</code> ）被发送到SubVI的输入，在输出处<code>Handle</code>和处于MPSSE模式的已初始化FTDI芯片。 </p><br><p> 让我们创建一个完成FTDI工作的VP，您已经可以检查硬件的性能了。 </p><br><div class="spoiler">  <b class="spoiler_title">FT_Close.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/1e/te/g3/1eteg3uh0t2t16y9yho_kxjbufe.png"><br>  <em>方块图</em> </p><br><p><img src="https://habrastorage.org/webt/ki/ez/tt/kiezttogb-2n4zl1qe893hfc55w.png"><br>  <em>前面板</em> </p></div></div><br><p> 在上一篇文章中，为了调试接口，我们制作了VI存根SP_FT_MPSSE_FPGA.vi，现在该填充它了。 将MPSSE_open.vi和FT_Close.vi添加到其框图。 在此阶段，很难评估初始化是否正确，但是，MPSSE_open.vi输出上的<code>Handle</code>的非零值以及没有错误将告诉我们很多。 </p><br><p><img src="https://habrastorage.org/webt/ci/rn/q5/cirnq5ik2_g5p-wbz3cmfcxzquo.png"><br>  <em>流程图SP_FT_MPSSE_FPGA.vi</em> </p><br><p> 为了查看<code>Handle</code>的值<code>Handle</code>可以使用“ Probe Watch Window”。 这是一种方便的调试工具，可让您在设备执行期间在任何（几乎所有）线路上显示数据值。 为了在该行上设置样本，您需要在该行的上下文菜单中选择“探针”。  “ Probe Watch Window”窗口将打开，并且带有样品编号的数字将显示在该行上。 在上图中，它是“ 3”。 </p><br><div class="spoiler">  <b class="spoiler_title">探针观察窗</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/yq/qv/u_/yqqvu_pkihohde2in-uy7sttt-i.png"><br>  <em>在“句柄”行上，值698389336</em> </p></div></div><br><p> 太好了！ 我们启动顶层VI，将调试板连接到计算机。 所连接的FTDI芯片的描述出现在“选择设备”列表中，单击“程序”按钮，然后...什么都没有发生。 仅在“ Probe Watch”窗口中，“ <code>Handle</code> ”值出现。 那很好。 </p><br><p> 我们关闭电路板，清除设备列表。 点击“程序”。 这是错误报告窗口弹出的地方。 </p><br><div class="spoiler">  <b class="spoiler_title">报告窗口</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><p> 单击“继续”按钮后，VI将完成其工作。 </p><br><p> 如果找不到任何设备，则禁止按下按钮。 我们修改案例“超时”事件处理程序。 让我提醒您，连接到PC的FTDI芯片每秒扫描两次，如果它们被检测到并可用于对FPGA进行编程，则它们的描述符通过<code>Strings[]</code>属性添加到<code>Devices list</code> 。 我们为“编程”创建<code>Disabled</code>属性，如果找不到合适的设备，请关闭按钮并使其变暗。 </p><br><div class="spoiler">  <b class="spoiler_title">案例超时</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wx/nf/5n/wxnf5n-ttwqqrsmbtydmttzcghw.png"></a> <br>  <em>可点击的图片</em> </p></div></div><br><h2 id="osvaivaem-gpio"> 掌握GPIO </h2><br><p> 激活MPSSE后，将通过所谓的“操作码”进行操作，并且<code>FT_Write</code> API函数仅使用<code>FT_Write</code> ， <code>FT_Read</code>和<code>FT_Queue</code> （以查找接收器缓冲区的状态）。 我们沿着创建的轨迹创建相应的VI：FT_Write.vi，FT_Read.vi，FT_Queue.vi。 </p><br><div class="spoiler">  <b class="spoiler_title">有点常规</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tw/or/ku/tworkua4o2qj3bntqoer1jb4o0u.png"><br>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/8k/pm/4s/8kpm4sdeaqgzlsctp-106wvtdz0.png"><br>  <em>方框图。</em>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/i0/px/18/i0px189plvqpokb3sijjuxtxbei.png"><br>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ku/hm/xw/kuhmxw1j66symp05f0ergjkriag.png"><br>  <em>方框图。</em>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/bf/2s/q_/bf2sq_t4uinirm94vmh-ugkzqzy.png"><br>  <em>FT_Queue.vi</em> </p><br><p><img src="https://habrastorage.org/webt/5p/zm/dv/5pzmdvtnhtdq0ivxzfs0t32nfjk.png"><br>  <em>方框图。</em>  <em>FT_Queue.vi</em> </p></div></div><br><p> 现在，从这三个积木中，我们布置VI来读取并写入并行端口。 该值方便地表示为布尔变量数组。 </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Set_LByte.vi和MPSSE_Get_LByte.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/oy/uh/8l/oyuh8lrdyniwp6ub2pvgwrxtlvw.png"><br>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/g4/ab/u-/g4abu-lurodnce0udnamj1ftsjm.png"><br>  <em>方框图。</em>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/7g/s9/5d/7gs95ddkb8pg9fjzt-s0vflzes4.png"><br>  <em>MPSSE_Get_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ki/dm/n_/kidmn_ewfihbrokreabs90538p0.png"><br>  <em>方框图。</em>  <em>MPSSE_Get_LByte.vi</em> </p><br><p> 我承认我很懒惰为所有操作码创建一个命名列表，所以我以魔术数字的形式将它们保留了下来。 </p></div></div><br><p> 如第一<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">篇文章</a>所述，无源串行FPGA启动协议仅是带有附加标志操作的SPI。 总共使用了五个<em>分支</em> ：必须将<em>DCLK</em> ， <em>DATA [0]</em> ， <em>nCONFIG行</em>配置为输出，将<em>nSTATUS</em> ， <em>CONF_DONE行配置</em>为输入。 </p><br><div class="spoiler">  <b class="spoiler_title">表格布局引脚</b> <div class="spoiler_text"><table><thead><tr><th>  FPGA引脚 </th><th> 引脚名称 </th><th> 销钉 </th><th>  MPSSE </th><th> 方向 </th><th> 默认值 </th></tr></thead><tbody><tr><td> 时钟 </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td> 出 </td><td>  0 </td></tr><tr><td> 数据[0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI /溶解氧 </td><td> 出 </td><td>  1个 </td></tr><tr><td> 配置文件 </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td> 出 </td><td>  1个 </td></tr><tr><td> 状态 </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td> 在 </td><td>  1个 </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td> 在 </td><td>  1个 </td></tr></tbody></table></div></div><br><p> 我们需要一个VP，它可以在不影响所有其他支路的情况下更改所选支路的值。 首先，使用端口中分支的序列号创建<code>Enum</code> ，将其另存为“ Strict Type Def”到文件SP_LBYTE_BITS.ctl。 我们创建一个新的VI，添加熟悉的错误流程终端。 我们使用MPSSE_Get_LByte.vi读取并行端口的当前值，使用“ <code>Replace Array Subset</code>功能修改所需的位并将该值写回到端口（MPSSE_Set_LByte.vi）。 </p><br><div class="spoiler">  <b class="spoiler_title">SP_Set_Flag.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/y7/d3/ap/y7d3aps-9ima93quyatag0ggkui.png"><br>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/jn/ae/h4/jnaeh4ewehebgcba9fstkxnxa4o.png"><br>  <em>方框图。</em>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ud/mt/jx/udmtjxpekkcskrmisie8t2h4hfw.png"><br>  <em>枚举SP_LBYTE_BITS.ctl</em> </p></div></div><br><p> 要开始配置，MPSSE必须在<em>nCONFIG</em>线上产生从低到高的<em>跳</em>变。 一旦FPGA准备好接收数据，它将在<em>nSTATUS</em>线上形成高电平。 在这个阶段，一切准备就绪，可以用铁进行实验了。 在框图SP_FT_MPSSE_FPGA.v上，我们添加了控制线nCONFIG-在MPSSE初始化之后，我们给出了一个低电平，然后为高电平。 每次操作（用于调试）后，我们都会读取端口支脚的状态。 </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5q/8g/u1/5q8gu1k9oezxomhdblxqyjbxxas.png"><br>  <em>启动期间</em> </p><br><p><img src="https://habrastorage.org/webt/nj/qv/bv/njqvbvi3dibaezauuqh4t2thdo8.png"><br>  <em>方块图</em> </p></div></div><br><p> 通常，在启动VI时，很明显FPGA响应<em>nCONFIG</em>线上的转换-在<em>nSTATUS</em>引脚上设置为0，然后再设置为1。 但是用示波器来监视它并不是多余的。 几乎任何带有触发触发（待机）的两通道示波器都适用。 我将通道<strong>A</strong> （蓝色轨道）放入电路<em>nCONFIG</em>的控制点中，通道<strong>B</strong> （红色轨道）-链<em>nSTATUS</em> 。 触发器设置为通道<strong>A</strong>的下降沿<strong>。</strong> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ca/b9/ti/cab9tizq5kpbnbguzew2avmi_je.png"></a> <br>  <em>图片是可单击的。</em>  <em>随着细节！</em> </p><br><h2 id="rabota-s-faylom"> 处理文件 </h2><br><p>  FPGA准备接受配置文件。 我们准备好将文件传输到FPGA了吗？ </p><br><p>  LabVIEW包含大量用于处理文件的工具。 我不能说该功能足以满足所有任务，但是，诸如<em>读取</em>和<em>写入之</em>类的基本操作可以轻松愉快地执行。 可在“文件I / O”面板中找到用于处理文件的基本VI集。 为了解决该问题，您需要打开配置文件，评估其大小（我们需要知道发送FPGA的字节数），然后读取并关闭它。 一切都很简单，一个接一个。 我们使用<code>Open/Create/Replace File</code> ， <code>Get File Size</code> ， <code>Read from Binary File</code> ， <code>Close File</code> <code>refnum</code> ，将它们与错误流链和<code>refnum</code>结合使用-打开文件时会创建一个数字，例如文件描述符，应将其传送至其他可处理VI的输入该文件。 </p><br><p> 到目前为止，我们没有地方可以处理读取的数据，但是，如果您确实要检查链的可操作性，则可以创建<code>String</code>类型的指示器并进行一些设置。 在上下文菜单中，激活“十六进制显示”选项，打开垂直滚动条（“可见项-&gt;垂直滚动条”），启动后，我们观察二进制配置文件的内容。 </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/7w/r8/dy/7wr8dyzaxomkxwmqioien0rn2om.png"><br>  <em>前面板</em>  <em>我们看一下文件的内容</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/qf/8l/vv/qf8lvvjj6xtwo_be0aiu-3aa2co.png"></a> <br>  <em>方框图。</em>  <em>Karinka可点击</em> </p></div></div><br><p> 在VI的框图上形成的两条独立的并行代码行，因此使用了独立的错误链。 为了减少流入一个<code>Error Out</code>终端的并行流，使用了“ <code>Merge Errors</code>功能。 此函数从上到下查找输入错误（是的，可以有两个以上的输入端子，用鼠标拉伸），然后返回找到的第一个错误。 如果没有错误，它将返回第一条警告消息。 如果没有警告，则输出无错误。 重要的是要注意，“ <code>Merge Errors</code>输入的连接顺序确定了<code>Merge Errors</code>的优先级，如果在两个链中立即发生错误，则较低的错误将被忽略。 这应该小心对待。 </p><br><p> 如果我们尝试在不选择文件的情况下在顶级VI中按下“程序”按钮，则输入SP_FT_MPSSE_FPGA.vi将收到一个空路径，这将导致错误“错误1430。LabVIEW：（Hex 0x596）路径为空或相对。您必须使用绝对路径。” 就像我儿时的朋友说的那样：“步枪，这是世间万物！” 这个错误根本不是错误，而是用户的疏忽。 我们不会停止该程序并使用带有红叉的窗口发誓，我们只是从流中删除此代码的错误，并在对话框中建议用户决定该文件。 要过滤错误，请使用“对话框和用户界面”选板中的“清除错误” VI。 要显示消息-“一个按钮对话框”。 </p><br><p><img src="https://habrastorage.org/webt/o2/nf/bm/o2nfbmdreh3hdppvxsabj7hsgt4.png"></p><br><div class="spoiler">  <b class="spoiler_title">方块图</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/-6/ik/cp/-6ikcptiqxx7uloza1v2g5y6wdo.png"></a> <br>  <em>可点击的图片</em> </p></div></div><br><h2 id="zagruzka-konfiguracii"> 下载配置 </h2><br><p> 对于串行数据传输，MPSSE处理器需要发送操作码0x18，命令参数将是传输序列的长度（两个字节，从最低的字节开始），以及数据序列本身。 长度编码为负一。 让我们以VI MPSSE_send的形式发送数据块。 </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Send.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/my/du/hi/myduhilu9cbsm8f3j_ceduagppq.png"><br>  <em>MPSSE_Send.vi</em> </p><br><p><img src="https://habrastorage.org/webt/fv/13/9m/fv139mrjy-t8l8cz-u82btswts8.png"><br>  <em>方块图</em> </p></div></div><br><p> 输入缓冲区的大小（ <code>Array Size</code> ）转换为双字节类型<code>U16</code> ，我们减去一个，交换低字节和高字节（ <code>Swap Bytes</code> ）-您需要从最低字节开始发送长度，并将双字节数字转换为单字节数组（ <code>Type Cast</code> ）。 </p><br><p>  <code>Type Cast</code>功能值得特别注意。 这是一种通用类型的转换器，其独创性有时非常令人惊讶。 简而言之，则： </p><br><p><img src="https://habrastorage.org/webt/k9/qp/0t/k9qp0tiyjs2ajjgisnhbfuaonpe.png"><br>  <em>直观地为程序员</em> </p><br><p> 但是，这不仅是将数据转换为其他类型，还是一种启发式的解释。 该功能使您可以在不兼容的数据类型之间执行转换，而该功能则毫不犹豫地对齐输入数据，甚至删除了“多余的”部分。 如果请求的数据类型比输入数据需要更多的内存，则该函数将分配丢失的数量。 对于新手开发人员来说，LabVIEW <code>Type Cast</code>可以成为救生员，但是随着年龄的增长，最好不要使用这样的转换器-它非常隐蔽，可能会导致意外错误。 最好使用更明确的转换方法，例如<code>Coerce To Type</code> 。 </p><br><p> 初始化MPSSE处理器时，我们将用于数据传输的缓冲区的最大允许大小设置为65536字节，因此我们必须将配置文件划分为大小不超过指定大小的片段。 我们将使用<code>Array Subset</code>函数，该函数从数组中选择一个以<code>index</code>元素和long <code>length</code>开头的子数组。 我们将在<code>While</code>循环中将其断开，将索引的每次迭代增加65536，在迭代之间，我们将值传递给移位寄存器。 一旦无法从主阵列中捏入65536个字节，我们将处理剩下的所有内容，将其发送并停止循环。 </p><br><p> 根据下载协议，在传输完所有数据之后，必须再施加两个时钟脉冲以启动FPGA初始化。 为此，在循环之后，我们发送另一个“空”字节。 </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vp/y4/wr/vpy4wrsts1szqayvnquvjtb2nzw.png"></a> <br>  <em>可点击的图片</em> </p></div></div><br><p> 为了理解固件的成功，我们考虑了这些标志，如果将<em>CONF_DONE</em>设置为1，则<em>报告</em>顶层VI一切正常。 </p><br><p> 程序完成。 仍然需要确保FPGA成功闪烁，并且板上的LED会愉快地闪烁。 </p><br><h2 id="pro-imenovanie-vp"> 关于VP命名 </h2><br><p>     ,             ,       LabVIEW, ,      SubVI.              .        : </p><br><ul><li>    —  ,     FTDI,           API D2XX.            "FT",  FT_Close.vi  FT_Read.vi. </li><li>   —     MPSSE.        "MPSSE". : MPSSE_open.vi, MPSSE_Set_LByte.vi, MPSSE_Get_LByte.vi. </li><li>   —    "Passive Serial"  MPSSE.     "S". , SP_FT_MPSSE_FPGA.vi ( ,   )  SP_LBYTE_BITS.ctl. </li><li>  .   .    , . </li></ul><br><p>     ( ),             .          <em>subVI</em> . </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p>  ,     ,           . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ff/i0/fq/ffi0fqqs7gbi3aczbucvusrw2qi.jpeg"></p></div></div><br><p>         ,        LabVIEW,        .    ,     ,        ,         (    ).         . </p><br><h2 id="materialy-po-teme">    </h2><br><ol><li>  . LabVIEW:  . .  .  .  .– .: <br>  , 2008 – 400 .: . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">labview_mpsse</a> .   . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   </a> .    </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Software Application Development D2XX Programmer's Guide</a> .   API D2XX. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN429448/">https://habr.com/ru/post/zh-CN429448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt486174/index.html">Tenho rotatividade zero</a></li>
<li><a href="../zh-CN429420/index.html">PlayStation Classic使用PCSX ReARMed仿真器进行操作，无专有解决方案</a></li>
<li><a href="../zh-CN429422/index.html">UHCI或第一个USB</a></li>
<li><a href="../zh-CN429424/index.html">戴姆勒和博世的Robotaxi将亮相加利福尼亚</a></li>
<li><a href="../zh-CN429426/index.html">QGIS和瓷砖出口</a></li>
<li><a href="../zh-CN429450/index.html">Rust中的通用编程技术：我们如何将Exonum从Iron转换为actix-web</a></li>
<li><a href="../zh-CN429452/index.html">五角大楼开始解密其他人的恶意软件</a></li>
<li><a href="../zh-CN429456/index.html">已经有故事了：创业文化在1930年代从哪里开始</a></li>
<li><a href="../zh-CN429458/index.html">我如何为二年级儿子制作太阳系动画</a></li>
<li><a href="../zh-CN429460/index.html">“我们对微服务有什么了解”报告摘要（HL2018，Avito，Vadim Madison）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>