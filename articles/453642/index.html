<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚ÄçüöÄ üìπ üò§ Analizador inteligente para un n√∫mero escrito en palabras ‚è™ üëçüèæ üëäüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologo 


 Buenas tardes, queridos lectores. En este art√≠culo hablar√© sobre c√≥mo analizar un n√∫mero escrito en palabras en ruso. 


 Este analizador ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analizador inteligente para un n√∫mero escrito en palabras</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453642/"><img src="https://habrastorage.org/webt/x_/al/d2/x_ald2dbs-mrb8gyk1v9z7fzk9w.png"><br><br><h1>  Prologo </h1><br><p>  Buenas tardes, queridos lectores.  En este art√≠culo hablar√© sobre c√≥mo analizar un n√∫mero escrito en palabras en ruso. </p><br><p>  Este analizador hace que sea inteligente extraer n√∫meros del texto con errores cometidos como resultado de una entrada incorrecta o como resultado del reconocimiento √≥ptico de texto de una imagen (OCR). </p><br><p>  Para los perezosos: <br>  Enlace al proyecto github: <a href="">enlace</a> . </p><br><a name="habracut"></a><br><h1>  Del algoritmo al resultado </h1><br><p>  Esta secci√≥n describir√° los algoritmos utilizados.  ¬°Atenci√≥n, muchas cartas! </p><br><h2>  Declaraci√≥n del problema. </h2><br><p> En el trabajo, necesito reconocer el texto de un documento impreso fotografiado con una c√°mara de tel√©fono inteligente / tableta.  Debido al acuerdo de no divulgaci√≥n, no puedo dar un ejemplo de una fotograf√≠a, pero el punto es que el documento tiene una tabla en la que ciertos indicadores est√°n escritos en n√∫meros y en palabras, y estos datos deben leerse.  Es necesario analizar el texto en palabras como una herramienta de validaci√≥n adicional para garantizar que el n√∫mero se reconozca correctamente.  Pero, como sabe, OCR no garantiza el reconocimiento preciso de texto.  Por ejemplo, el n√∫mero veinte, escrito en palabras, puede reconocerse como "dvupat" o incluso como "dvupat".  Es necesario tener esto en cuenta y extraer la cantidad m√°xima de informaci√≥n, evaluando la magnitud del posible error. </p><br><p>  <b>Nota</b>  Para el reconocimiento de texto, uso tesseract 4. Para .NET, no hay un paquete NuGet listo para usar de la cuarta versi√≥n, as√≠ que cre√© uno de la rama principal del proyecto, que puede ser √∫til: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Genesis.Tesseract4</a> . </p><br><br><h2>  Algoritmo de an√°lisis num√©rico b√°sico </h2><br><p>  Comencemos con uno simple, es decir, con un algoritmo de reconocimiento de texto escrito en palabras, hasta ahora sin errores.  Si est√° interesado en el an√°lisis inteligente, omita esta secci√≥n. </p><br><p>  No soy particularmente bueno para buscar en Google, por lo que no encontr√© de inmediato un algoritmo listo para resolver este problema.  Sin embargo, esto es incluso para mejor, porque  Un algoritmo inventado por nosotros mismos da m√°s espacio para la codificaci√≥n.  Y la tarea en s√≠ result√≥ ser interesante. </p><br><p>  Entonces, tomemos un peque√±o n√∫mero, por ejemplo, "ciento veintitr√©s".  Se compone de tres palabras ( <i>tokens</i> ), cada una de las cuales corresponde a un n√∫mero, todos estos n√∫meros se resumen: </p><br> <code>"  " =  +  +  = 100 + 20 + 3 = 123</code> <br> <br><p>  Hasta ahora, todo es simple, pero profundizamos, por ejemplo, consideremos el n√∫mero "doscientos doce mil ciento cinco". </p><br> <code>"    " = ( + ) √ó  + ( + ) = 212 * 1.000 + 105 = 212.105.</code> <br> <br><p>  Como puede ver, cuando hay miles en el n√∫mero (as√≠ como millones y otros grados de mil), el n√∫mero se divide en partes que consisten en un n√∫mero peque√±o local, en el ejemplo anterior, 212, y un factor (1000).  Puede haber varios fragmentos de este tipo, pero todos van en orden descendente del multiplicador, por ejemplo, mil o mil no pueden seguir a mil.  Esto tambi√©n es cierto para partes de un n√∫mero peque√±o, ya que cientos no pueden seguir a cientos y decenas de decenas, por lo que la entrada "ciento quinientos" es incorrecta.  Llamaremos a una caracter√≠stica que relaciona dos tokens del mismo tipo con un <i>nivel</i> , por ejemplo, los tokens "cien" y "trescientos" tienen un nivel, y es mayor que el token "cincuenta". </p><br><p>  De estas consideraciones, nace la idea de un algoritmo.  Escribamos todos los tokens ( <i>muestras</i> ) posibles, a cada uno de los cuales asignaremos un n√∫mero, as√≠ como dos par√°metros: el nivel y el signo del multiplicador. </p><br><div class="scrollable-table"><table><tbody><tr><th>  Token </th><th>  Numero </th><th>  Nivel </th><th>  Multiplicador? </th></tr><tr><td>  cero <br></td><td>  0 0 <br></td><td>  1 <br></td><td>  no <br></td></tr><tr><td>  soltero / soltero <br></td><td>  1 <br></td><td>  1 <br></td><td>  no <br></td></tr><tr><td>  dos / dos <br></td><td>  2 <br></td><td>  1 <br></td><td>  no <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  1 <br></td><td>  no <br></td></tr><tr><td>  diecinueve <br></td><td>  19 <br></td><td>  1 <br></td><td>  no <br></td></tr><tr><td>  veinte <br></td><td>  20 <br></td><td>  2 <br></td><td>  no <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  2 <br></td><td>  no <br></td></tr><tr><td>  noventa <br></td><td>  90 <br></td><td>  2 <br></td><td>  no <br></td></tr><tr><td>  cien <br></td><td>  100 <br></td><td>  3 <br></td><td>  no <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  3 <br></td><td>  no <br></td></tr><tr><td>  novecientos <br></td><td>  900 <br></td><td>  3 <br></td><td>  no <br></td></tr><tr><td>  mil / mil / mil <br></td><td>  1,000 <br></td><td>  4 4 <br></td><td>  si <br></td></tr><tr><td>  millones / millones / millones <br></td><td>  1,000,000 <br></td><td>  5 5 <br></td><td>  si <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td><td>  si <br></td></tr><tr><td>  cuatrillones / cuatrillones / cuatrillones <br></td><td>  1,000,000,000,000,000 <br></td><td>  8 <br></td><td>  si <br></td></tr></tbody></table></div><br><p>  De hecho, puede agregar cualquier otro token a esta tabla, incluso para idiomas extranjeros, solo no olvide que en algunos pa√≠ses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se usa un sistema de nombres</a> largo, en lugar de uno corto. </p><br><p>  Ahora pasemos al an√°lisis.  Obtendremos cuatro cantidades: </p><br><ol><li>  <i>Nivel global</i> (globalLevel).  Indica el nivel del √∫ltimo multiplicador.  Inicialmente indefinido y necesario para el control.  Si nos encontramos con un token multiplicador cuyo nivel es mayor o igual que el global, entonces este es un error. </li><li>  <i>Valor global</i> (globalValue).  El sumador total, donde el resultado es el resultado de multiplicar el n√∫mero local y el factor. </li><li>  <i>Nivel local</i> (localLevel).  Indica qu√© nivel ten√≠a el √∫ltimo token.  Inicialmente indefinido, funciona de manera similar al nivel global, pero se restablece despu√©s del descubrimiento del multiplicador. </li><li>  <i>Valor local</i> ( <i>valor local</i> )  Un sumador de tokens no multiplicador, es decir  n√∫meros hasta 999. </li></ol><br><p>  El algoritmo es el siguiente: </p><br><ol><li>  Divide la cadena en tokens usando el "\ s +" regular. </li><li>  Tomamos el siguiente token, obtenemos informaci√≥n al respecto de la muestra. </li><li>  Si es un multiplicador: <br><ul><li>  Si se establece el nivel global, nos aseguramos de que sea mayor o igual que el nivel del token.  Si no, esto es un error; el n√∫mero es incorrecto. </li><li>  Establece el nivel global al nivel del token actual. </li><li>  Multiplique el valor del token por el valor local y agregue el resultado al valor global. </li><li>  Limpiamos el valor local y el nivel. </li></ul></li><li>  Si esto no es un multiplicador: <br><ul><li>  Si se establece el nivel local, nos aseguramos de que sea mayor o igual que el nivel del token.  Si no, esto es un error; el n√∫mero es incorrecto. </li><li>  Establece el nivel local al nivel del token actual. </li><li>  Agregue el valor del token al valor local. </li></ul></li><li>  Devolvemos el resultado como la suma de valores globales y locales. </li></ol><br><p>  Un ejemplo de trabajo para el n√∫mero "dos millones doscientos doce mil ciento ochenta y cinco". </p><br><div class="scrollable-table"><table><tbody><tr><th>  Token <br></th><th>  globalLevel <br></th><th>  globalValue <br></th><th>  nivel local <br></th><th>  valor local <br></th></tr><tr><td></td><td>  - <br></td><td>  - <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  dos <br></td><td>  - <br></td><td>  - <br></td><td>  1 <br></td><td>  2 <br></td></tr><tr><td>  millones <br></td><td>  5 5 <br></td><td>  2,000,000 <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  doscientos <br></td><td>  5 5 <br></td><td>  2,000,000 <br></td><td>  3 <br></td><td>  200 <br></td></tr><tr><td>  doce <br></td><td>  5 5 <br></td><td>  2,000,000 <br></td><td>  1 <br></td><td>  212 <br></td></tr><tr><td>  mil <br></td><td>  4 4 <br></td><td>  2.212.000 <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  cien <br></td><td>  4 4 <br></td><td>  2.212.000 <br></td><td>  3 <br></td><td>  100 <br></td></tr><tr><td>  ochenta <br></td><td>  4 4 <br></td><td>  2.212.000 <br></td><td>  2 <br></td><td>  180 <br></td></tr><tr><td>  cinco <br></td><td>  4 4 <br></td><td>  2.212.000 <br></td><td>  1 <br></td><td>  185 <br></td></tr></tbody></table></div><p>  El resultado ser√° 2.212.185. </p><br><h2>  An√°lisis inteligente </h2><br><p>  Este algoritmo se puede usar para implementar otras comparaciones, y no solo para analizar n√∫meros, por esta raz√≥n tratar√© de describirlo con m√°s detalle. </p><br><p>  Con el an√°lisis del n√∫mero escrito correctamente resuelto.  Ahora pensemos qu√© errores pueden ocurrir si el n√∫mero obtenido como resultado de OCR se escribe incorrectamente.  No considero otras opciones, pero puede modificar el algoritmo para una tarea espec√≠fica. </p><br><p>  He identificado tres tipos de errores que encontr√© en el proceso de trabajo: </p><br><ol><li>  Reemplazar personajes con otros con un estilo similar.  Por ejemplo, la letra "c" se reemplaza por alguna raz√≥n por "p" y "n" por "y" y viceversa.  Cuando se utiliza la tercera versi√≥n de tesseract, es posible reemplazar la letra "o" con cero.  Estos errores, por s√≠ solos, son los m√°s comunes y requieren ajuste para una biblioteca de reconocimiento espec√≠fica.  Entonces, los principios de funcionamiento de las versiones 3 y 4 de tesseract tienen diferencias cardinales, por lo tanto, los errores all√≠ ser√°n diferentes. <br></li><li>  Token merge.  Las palabras pueden fusionarse (a√∫n no han encontrado lo contrario).  En combinaci√≥n con el primer error, genera frases demon√≠acas como "doble uno".  Tratemos de demonizar a esos monstruos tambi√©n. <br></li><li>  Ruido: dej√≥ caracteres y frases en el texto.  Desafortunadamente, hay poco que se pueda hacer en este momento, pero hay una posibilidad cuando se recopilan estad√≠sticas suficientemente significativas. <br></li></ol><br><p>  Al mismo tiempo, el algoritmo de an√°lisis descrito anteriormente casi no cambia, la principal diferencia est√° en dividir la cadena en tokens. </p><br><p>  Pero comencemos recopilando algunas estad√≠sticas sobre el uso de letras en tokens.  De las 33 letras del idioma ruso, solo 20 se usan al escribir enteros no negativos, llam√©moslas <i>buenas letras</i> : </p><br> <code></code> <br> <br><p>  Los 13 restantes, respectivamente, se <i>llamar√°n letras malas</i> .  El tama√±o m√°ximo de la ficha es de 12 caracteres (13 cuando se cuenta hasta cuatro mil millones).  Las subcadenas m√°s largas que este valor deben dividirse. </p><br><p>  Para comparar cadenas y tokens, decid√≠ usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el algoritmo Wagner-Fisher</a> , aunque lo llam√© el nombre de Levenshtein en el c√≥digo.  No necesito una instrucci√≥n editorial, as√≠ que implement√© una versi√≥n del algoritmo compatible con la memoria.  Debo admitir que la implementaci√≥n de este algoritmo result√≥ ser una tarea m√°s dif√≠cil que el analizador en s√≠. </p><br><p>  Un peque√±o programa educativo: la distancia de Levenshtein es un caso especial del algoritmo Wagner-Fisher, cuando el costo de insertar, eliminar y reemplazar caracteres es est√°tico.  Esto no es as√≠ en nuestra tarea.  Obviamente, si encontramos una letra mala en una subcadena, entonces debe ser reemplazada por una buena letra, pero reemplazar una buena por una mala es extremadamente indeseable.  En t√©rminos generales, es imposible, pero la situaci√≥n depende de la tarea espec√≠fica. </p><br><p>  Para describir el costo de insertar, eliminar y reemplazar caracteres, cre√© una tabla como esta: un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace a una tabla con pesos</a> .  Si bien se llena con el m√©todo de tres P (g√©nero, dedo, techo), pero si lo llena con datos basados ‚Äã‚Äãen estad√≠sticas OCR, puede mejorar significativamente la calidad del reconocimiento de n√∫meros.  El c√≥digo de la biblioteca contiene el archivo de recursos NumeralLevenshteinData.txt, en el que puede insertar datos de una tabla similar usando Ctrl + A, Ctrl + C y Ctrl + V. </p><br><p>  Si se encuentra un car√°cter que no es de tabla en el texto, por ejemplo, cero, entonces el costo de insertarlo es igual al valor m√°ximo de la tabla, y el costo de eliminar y reemplazar es igual al m√≠nimo, por lo que es m√°s probable que el algoritmo reemplace cero con la letra "o", y si usa la tercera versi√≥n de tesseract , entonces tiene sentido agregar cero a la tabla y escribir el precio m√≠nimo para reemplazarlo con la letra "o". </p><br><p>  Entonces, preparamos los datos para el algoritmo Wagner-Fisher, hagamos cambios en el algoritmo para dividir la cadena en tokens.  Para hacer esto, realizaremos un an√°lisis adicional de cada token, pero antes de eso ampliaremos la informaci√≥n sobre el token con las siguientes caracter√≠sticas: </p><br><ul><li>  <i>Nivel de error</i>  Un n√∫mero real de 0 (sin error) a 1 (el token es incorrecto), lo que significa qu√© tan bien se compar√≥ el token con la muestra. <br></li><li>  <i>Una se√±al de uso de un token</i> .  Al analizar una cadena con desechos intercalados, parte de los tokens se descartar√°n, ya que este atributo no se establecer√°.  En este caso, el valor de error total se considerar√° como el promedio aritm√©tico de los errores de los tokens utilizados. <br></li></ul><br><p>  Algoritmo de an√°lisis de tokens: </p><br><ol><li>  Estamos tratando de encontrar el token en la tabla tal como est√°.  Si encontramos que todo est√° bien, devu√©lvelo. </li><li>  Si no, haga una lista de posibles opciones: </li><li><p>  Estamos tratando de hacer coincidir el token con la muestra utilizando el algoritmo Wagner-Fisher.  Esta opci√≥n consta de un token (muestra mapeada) y su error es igual a la mejor distancia dividida por la longitud de la muestra. </p><br>  <b>Ejemplo: el</b> token "cero" se compara con la muestra "cero", mientras que la distancia es 0.5, porque  el costo de reemplazar la letra incorrecta "y" con una buena "o" es 0.5.  El error total para este token ser√° 0.5 / 4 = 0.125. <br></li><li><p>  Si la subcadena es lo suficientemente grande (tengo 6 caracteres), intentamos dividirla en dos partes de al menos 3 caracteres en cada una.  Para una cadena de 6 caracteres habr√° una sola divisi√≥n: 3 + 3 caracteres.  Para una cadena de 7 caracteres, ya hay dos opciones, 3 + 4 y 4 + 3, etc.  Para cada una de las opciones, llamamos a la misma funci√≥n de an√°lisis de tokens de forma recursiva, ingresamos las opciones recibidas en la lista. </p><br><p>  Para no morir en la recursi√≥n, determinamos el nivel m√°ximo de falla.  Adem√°s, las opciones obtenidas como resultado de la divisi√≥n se degradan artificialmente en una cierta cantidad (opci√≥n, por defecto 0.1), de modo que la opci√≥n de comparaci√≥n directa es m√°s valiosa.  Tuve que agregar esta operaci√≥n, porque  Los pasos del tipo "doble" se dividieron con √©xito en tokens "dos" y "cinco", y no se redujeron a "veinte".  Por desgracia, estas son las caracter√≠sticas del idioma ruso. </p><br><p>  <b>Ejemplo: el</b> token "doble" tiene una comparaci√≥n directa con la muestra "veinte", error 0.25.  Adem√°s, la mejor opci√≥n para dividir es "dos" + "cinco" con un costo de 0.25 (reemplazando "a" con "i"), empeorado artificialmente a 0.35, por lo que se prefiere la ficha "veinte". </p><br></li><li>  Despu√©s de compilar todas las opciones, seleccionamos la mejor por la cantidad m√≠nima de errores de los tokens que participan en ella.  El resultado es devuelto. </li></ol><br><p>  Adem√°s, la verificaci√≥n del token se introduce en el algoritmo principal de generaci√≥n de n√∫meros para que su error no exceda un cierto valor (opci√≥n, por defecto 0,67).  Con esto, eliminamos la basura potencial, aunque no con mucho √©xito. </p><br><h2>  El algoritmo en pocas palabras para aquellos que eran demasiado vagos para leer el texto de arriba </h2><br><p>  Dividimos la cadena de entrada, que es el n√∫mero en palabras, en subcadenas usando la regularidad \ s +, luego intentamos hacer coincidir cada subcadena con tokens de muestra o dividirla en subcadenas m√°s peque√±as, eligiendo los mejores resultados.  Como resultado, obtenemos un conjunto de tokens mediante los cuales generamos un n√∫mero, y el valor del error se toma como la media aritm√©tica de los errores entre los tokens utilizados en la generaci√≥n. </p><br><h2>  Afilar un algoritmo para una tarea espec√≠fica </h2><br><p>  En mi tarea, los n√∫meros no son negativos y son relativamente peque√±os, por lo que excluir√© tokens innecesarios del "mill√≥n" o m√°s.  Para la prueba, queridos lectores, por el contrario, agregu√© tokens de jerga adicionales, lo que permiti√≥ analizar cadenas como "cinco piezas", "cortar doscientos" e incluso "tres stolniks y dos piezas de oro".  Es divertido, pero ni siquiera requiri√≥ cambios en el algoritmo. </p><br><h2>  Mejora adicional </h2><br><p>  El algoritmo existente tiene fallas: </p><br><ol><li>  <b>Control de casos.</b>  Las cadenas "dos mil" y "dos mil" se reconocer√°n con un error cero como 2000. En mi tarea, el control de casos no es necesario, incluso es da√±ino, pero si necesita dicha funci√≥n, esto se resuelve mediante la introducci√≥n de una bandera adicional en el token que es responsable del caso del pr√≥ximo token . <br></li><li>  <b>N√∫meros negativos</b>  Se introduce un token negativo adicional con un procesamiento especial.  Nada complicado, pero no olvide que la letra "y" es mala y no aparece en los n√∫meros, deber√° cambiar sus caracter√≠sticas de peso o esperar que no cambie durante el proceso de OCR. <br></li><li>  <b>N√∫meros fraccionarios</b>  Se resuelve reemplazando el tipo largo con un doble e introduciendo tokens de "d√©cimos", "cent√©simos", etc. ... No olvides revisar las escalas de letras. <br></li><li>  <b>Reconocimiento de n√∫meros ingresados ‚Äã‚Äãpor los usuarios.</b>  Porque  al ingresar texto manualmente, con frecuencia cometemos errores relacionados con la reedici√≥n de siVMolov, debe agregar esta operaci√≥n al algoritmo Wagner-Fisher. <br></li><li>  <b>Soporte para otros idiomas.</b>  Introducimos nuevos tokens, ampliamos la tabla de pesos. <br></li><li>  <b>Manejo de basura.</b>  En algunos documentos, se imprimen datos, la calidad de la imagen puede ser deficiente, la celda puede estar curiosamente vac√≠a.  En este caso, la basura que debe limpiarse de alguna manera entra en la l√≠nea.  Lo mejor que puedo ofrecer en este momento es preprocesar el documento antes de OCR.  Quitar las l√≠neas de la tabla y llenarlas con un color cercano al color del espacio libre de la celda me ayud√≥ mucho.  Esto no resolvi√≥ todos los problemas, pero mejor√≥ la calidad del reconocimiento de texto de documentos donde la tabla ten√≠a curvaturas debido a los hematomas del documento o un fot√≥grafo torcido.  Idealmente, debe rotar la celda y reconocerla por separado, si, por supuesto, tiene una tabla. <br></li></ol><br><h1>  Entonces, ¬øcu√°l es el resultado final? </h1><br><p>  El proyecto tiene un ejemplo de una aplicaci√≥n de consola que se ejecuta a trav√©s del archivo samples.txt con ejemplos para el analizador.  Aqu√≠ hay una captura de pantalla de los resultados: </p><br><img src="https://habrastorage.org/webt/fq/ed/ac/fqedacgduf7tewa8tvg-tn6zv3s.png"><br><br><p>  Le cobro que eval√∫e el resultado, pero en cuanto a m√≠, no est√° mal.  El error para los ejemplos de reconocimiento real no supera 0.25, aunque todav√≠a no he ejecutado todo el conjunto de documentos disponibles, probablemente no todo ser√° tan f√°cil all√≠. </p><br><p>  En cuanto a la √∫ltima secci√≥n, siempre me preguntaba cu√°nto es "dofiga".  Adem√°s, el programa se dio una respuesta adecuada a cu√°nto se tarda en tomar (no lo uso, pero a√∫n as√≠) e incluso determin√≥ con precisi√≥n el significado de la antigua palabra rusa "oscuridad".  Y s√≠, la conclusi√≥n no incluy√≥ otra medida que la educaci√≥n no permiti√≥ agregar, pero el programa cree que es igual a mil =) </p><br><h1>  Algunas palabras sobre la biblioteca. </h1><br><p>  Inicialmente, mis planes no inclu√≠an la creaci√≥n de una biblioteca, decid√≠ dise√±arla exclusivamente para un Habr.  Trat√© de ordenar el c√≥digo, pero si lo usa, haga un tenedor o una copia, como  lo m√°s probable es que no necesite jerga y otros tokens incluidos en los ejemplos. </p><br><p>  La biblioteca en s√≠ est√° escrita bajo .NET Standart 2.0 y C # 7.x, y los algoritmos se traducen f√°cilmente a otros idiomas. </p><br><p>  En caso de una posible expansi√≥n de la biblioteca, agregar√© la composici√≥n de los componentes importantes del analizador num√©rico en palabras (espacio de nombres Genesis.CV.NumberUtils): </p><br><ul><li>  RussianNumber.cs: analizador directo </li><li>  RussianNumber.Data.cs - archivo con descripci√≥n de tokens </li><li>  RussianNumber.ToString.cs - convertidor de n√∫mero a texto en palabras </li><li>  RussianNumberParserOptions.cs - opciones de analizador </li><li>  NumeralLevenshtein.cs: implementaci√≥n del algoritmo Wagner-Fisher </li><li>  NumeralLevenshteinData.txt - recurso, datos de ponderaciones de letras </li></ul><br><p>  Uso: </p><br><ul><li>  RussianNumber.ToString (valor): convierte un n√∫mero en texto </li><li>  RussianNumber.Parse (valor, [opciones]) - convierte texto a n√∫mero </li></ul><br><h1>  Conclusi√≥n </h1><br><p>  Realmente espero que el art√≠culo no te haya parecido aburrido a pesar de la abundancia de texto.  Recientemente, se me ocurrieron muchos temas relacionados con la visi√≥n por computadora, sobre los cuales hay algo que contar, por lo que me gustar√≠a saber una opini√≥n sobre este formato de art√≠culos.  ¬øQu√© vale la pena agregar o, por el contrario, eliminar?  ¬øQu√© es m√°s interesante para ustedes, lectores, los algoritmos mismos o los fragmentos de c√≥digo? </p><br><p>  ¬øTe gusta el art√≠culo?  Mira los otros: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Soporte de serializaci√≥n JavaScript JavaScript de clase</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Relleno de plantillas de texto con datos basados ‚Äã‚Äãen modelos.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n de .NET usando funciones de bytecode din√°mico (IL)</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453642/">https://habr.com/ru/post/453642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453618/index.html">C√≥mo trabajamos con ideas y c√≥mo naci√≥ LANBIX</a></li>
<li><a href="../453622/index.html">Programador de chips G-Shield: escritura de certificados digitales en chips en la etapa de producci√≥n</a></li>
<li><a href="../453626/index.html">Aventuras en una corriente separada. Informe Yandex</a></li>
<li><a href="../453628/index.html">¬øQu√© pagar√° en 20 a√±os?</a></li>
<li><a href="../453634/index.html">Alfa Bank School of System Analysis</a></li>
<li><a href="../453644/index.html">Entrevista: 10 preguntas sobre Swift. Parte 3</a></li>
<li><a href="../453646/index.html">Normalizaci√≥n de datos en una base de datos distribuida, microservicios y ERP</a></li>
<li><a href="../453650/index.html">N√∫cleo de software de la infraestructura cibern√©tica a bordo del caza de combate unificado F-35</a></li>
<li><a href="../453652/index.html">LogRock: Prueba a trav√©s del registro</a></li>
<li><a href="../453656/index.html">Web est√°tica: ¬øvolver a lo b√°sico?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>