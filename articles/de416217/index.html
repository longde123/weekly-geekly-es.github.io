<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥ üî™ üë©üèæ‚Äç‚öïÔ∏è Wie ich Computer und Benutzer mit Netzwerkger√§teports im Netzwerk-MACMonitor-√úberwachungsprogramm verbunden habe üéπ ‚ûñ üèí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich bin Entwickler der Netzwerk√ºberwachungssoftware Network MACMonitor . 


 Bei der Programmentwicklung stellte sich die Aufgabe, festzustellen, welc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie ich Computer und Benutzer mit Netzwerkger√§teports im Netzwerk-MACMonitor-√úberwachungsprogramm verbunden habe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/macmonitor/blog/416217/"><p>  Ich bin Entwickler der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Netzwerk√ºberwachungssoftware Network MACMonitor</a> . </p><br><p>  Bei der Programmentwicklung stellte sich die Aufgabe, festzustellen, welche Computer Benutzer verwenden, und diese Informationen den Ports von Netzwerkger√§ten zuzuordnen.  In diesem Artikel m√∂chte ich schreiben, wie ich das geschafft habe. </p><br><p><img src="https://habrastorage.org/webt/ab/uf/qc/abufqc8euaofveu4dqt-htkaqrm.png" alt="Bild"></p><a name="habracut"></a><br><p>  Ich begann mit einfachen √úberlegungen: Um einen Benutzer einem Port auf einem Netzwerkger√§t zuzuordnen, m√ºssen Sie zuerst den Computer, mit dem der Benutzer arbeitet, an diesen Port anschlie√üen.  Da Sie mit dem Programm Network MACMonitor Mac-Adressen an den Ports von Netzwerkger√§ten finden k√∂nnen, wurde beschlossen, Computer √ºber Mac-Adressen mit Ports zu verbinden.  Als N√§chstes m√ºssen Sie Benutzer mit Computern verbinden.  Diese Informationen k√∂nnen durch Abfragen von Computern auf irgendeine Weise erhalten werden. </p><br><p>  Ich habe zwei M√∂glichkeiten gesehen, um dieses Problem zu l√∂sen: </p><br><ol><li>  Schreiben Sie einen Windows-Agenten und fragen Sie ihn mit Network MACMonitor ab. </li><li>  Verwenden Sie Windows Management Instrumentation (WMI). </li></ol><br><p>  Die Version mit dem Windows-Agenten weist eine Reihe von Nachteilen auf, die f√ºr mich von Bedeutung waren: </p><br><ul><li>  Entwicklung eines sicheren Protokolls f√ºr die Netzwerkinteraktion eines Windows-Agenten mit Network MACMonitor; </li><li>  die Notwendigkeit, den Agenten auf Computern vorinstallieren; </li><li>  Verwenden einer anderen Programmiersprache (ich schreibe in Java), da Java meines Erachtens nicht zum Schreiben eines Agenten geeignet ist: aufgrund des relativ hohen Verbrauchs an virtuellem Speicher und der Notwendigkeit, JRE auf allen Computern zu installieren. </li></ul><br><p>  Aufgrund all der oben genannten Nachteile habe ich mich entschlossen, √ºber die Option mit WMI nachzudenken. </p><br><h3>  WMI-Client-Entwicklung </h3><br><p>  Da Network MACMonitor in Java geschrieben ist, habe ich versucht, eine vorgefertigte plattform√ºbergreifende Java-Bibliothek zu finden, die die Funktionalit√§t des WMI-Clients implementiert.  Und dann war ich entt√§uscht - es gibt keine solche Bibliothek.  Alle vorhandenen Bibliotheken sind entweder Wrapper √ºber Windows-Dienstprogramme oder (j-Interop-Bibliothek) erfordern zus√§tzliche Registrierungsmanipulationen (Eigent√ºmerwechsel und Berechtigungen f√ºr Registrierungszweige), um WMI √ºber eine Remote-Registrierung zu aktivieren.  Da es f√ºr Java keine voll funktionsf√§hige Bibliothek gab, entschied ich mich, eine Bibliothek oder einen WMI-Client zu finden, der in einer anderen Programmiersprache geschrieben ist.  Und fand einen WMI-Client f√ºr Linux.  Nachdem ich die Arbeit heruntergeladen und √ºberpr√ºft hatte, stellte ich fest, dass das Abrufen von Windows-Computern unter Linux m√∂glich ist. </p><br><p>  Wenn dies m√∂glich ist, habe ich beschlossen, meine Bibliothek in reinem Java zu schreiben, damit ich den Computer mit WMI abfragen kann. </p><br><p>  Zum Schreiben der Bibliothek war eine klare Dokumentation zum Betrieb des WMI-Protokolls erforderlich.  Es stellte sich heraus, dass es eine solche Dokumentation gibt und diese gemeinfrei ist. </p><br><p>  Ich begann mich auf das Schreiben der Bibliothek vorzubereiten, indem ich mir den Netzwerkstapel des WMI-Protokolls ansah. </p><br><table><tbody><tr><th>  Protokoll </th><th>  Technische Daten </th></tr><tr><td>  Windows Management Instrumentation (WMI) </td><td>  MS-WMI, MS-WMIO </td></tr><tr><td>  Distributed Component Object Model (DCOM) </td><td>  MS-DCOM </td></tr><tr><td>  Remote Procedure Call (RPC) </td><td>  MS-RPCE </td></tr><tr><td>  Transmission Control Protocol (TCP) </td><td>  - - </td></tr><tr><td>  Internet Protocol (IP) </td><td>  - - </td></tr></tbody></table><br><p>  Damit WMI ordnungsgem√§√ü funktioniert, m√ºssen alle Stapelebenen implementiert sein. </p><br><p>  Da WMI nicht in Java implementiert ist, bin ich zum n√§chsten Protokoll im Stack √ºbergegangen - DCOM.  Und hier hatte ich Gl√ºck.  Obwohl die oben erw√§hnte j-Interop-Bibliothek keine WMI-Funktionalit√§t implementiert, ist die DCOM-Funktionalit√§t darin implementiert.  Es bleibt also eine Implementierung des WMI-Protokolls zu schreiben, dh eine Implementierung der MS-WMI- und MS-WMIO-Spezifikationen zu schreiben. </p><br><p>  Ich begann mit der Implementierung der MS-WMIO-Spezifikation, die f√ºr das Codierungsformat von Daten in Netzwerkpaketen des WMI-Protokolls verantwortlich ist.  Aus der Spezifikation habe ich gelernt, dass beim Codieren von Daten die erweiterte Backus-Naur-Syntaxspezifikation (ABNF, RFC 5234) verwendet wird.  Die MS-WMIO-Spezifikation beschreibt das Codierungsformat mit ABNF vollst√§ndig.  Es ist bekannt, dass bei einer in ABNF beschriebenen Grammatik ein Parser f√ºr diese Grammatik erstellt werden kann.  Im Internet habe ich einen ABNF-Parser-Generator f√ºr Java gefunden und ihn mit einer Grammatik aus der Spezifikation eingegeben.  Da der generierte Parser mit Zeichenfolgen arbeitete und MS-WMIO ein bin√§res Codierungsformat beschreibt, bestand die Idee darin, den generierten Parser einfach durch Zeichenfolgen durch Arrays und Zeichen durch Bytes zu ersetzen.  Nachdem ich mir jedoch die Anzahl der Dateien angesehen hatte, bei denen ein Austausch erforderlich war, und aus der MS-WMIO-Spezifikation gelernt hatte, dass manchmal mit Bits gearbeitet werden muss, wurde mir klar, dass es sehr schwierig sein w√ºrde, den generierten Parser zu reparieren, und ich entschied mich, diese Idee aufzugeben.  Ich dachte, dass das Schreiben eines Parsers von Grund auf schneller sein w√ºrde.  Und jetzt war der Parser fertig. </p><br><p>  Aber wie kann √ºberpr√ºft werden, ob der Parser korrekt geschrieben ist, wenn die MS-WMI-Spezifikation, die f√ºr den Betrieb des WMI-Protokolls verantwortlich ist, noch nicht implementiert ist?  Dann half mir Wireshark, ein Netzwerk-Verkehrsanalysator.  Nachdem ich WMI-Anfragen mit Standard-Windows-Tools (wbemtest) gestellt und zuvor die Verschl√ºsselung deaktiviert hatte, erhielt ich Netzwerkpakete und speicherte sie in Bin√§rdateien.  Diese Dateien konnten bereits als Testdaten f√ºr den Parser verwendet werden. </p><br><p>  Als der Parser getestet und die gefundenen Fehler behoben wurden, implementierte ich die MS-WMI-Spezifikation, die die Funktionsweise des WMI-Protokolls beschreibt. </p><br><p>  Die MS-WMI-Spezifikation ist in Server und Client unterteilt.  Ich habe den Client-Teil teilweise implementiert, soweit dies f√ºr die Abfrage eines Computers √ºber WMI erforderlich ist.  In diesem Teil brauchte ich auch Wireshark, aber bereits, um die Reihenfolge der Netzwerkpakete w√§hrend der WMI-Abfrage zu analysieren. </p><br><h3 id="popytka-polucheniya-neobhodimyh-dannyh-s-pomoschyu-wmi">  Der Versuch, die erforderlichen Daten mit WMI abzurufen </h3><br><p>  Nach dem Schreiben der WMI-Bibliothek wurde die Aufgabe, sie im Programm Network MACMonitor zu verwenden.  Es stellte sich die Frage: Welche Daten sollten von Computern bezogen werden?  Ich dachte, ich m√ºsste den Computernamen, die Dom√§ne, das Betriebssystem, die Einschaltzeit, die Mac-Adressen, die IP-Adressen und die aktiven Benutzer abrufen, die am Computer arbeiten. </p><br><p>  Es trat jedoch ein sehr wichtiges Problem auf: Wie kann ein Computer w√§hrend der WMI-Abfrage eindeutig identifiziert werden?  Ich habe folgende Optionen in Betracht gezogen: </p><br><ul><li>  Mac-Adresse, m√∂gliche √Ñnderung, m√∂glicherweise nicht eindeutig; </li><li>  Computername und Dom√§ne (Arbeitsgruppe), m√∂gliche √Ñnderung, nicht eindeutig (f√ºr Arbeitsgruppe); </li><li>  Die Seriennummer der Festplatte, auf der das Betriebssystem installiert ist, Administratorrechte sind w√§hrend der WMI-Abfrage erforderlich. Ich habe nicht auf Eindeutigkeit √ºberpr√ºft, aber ich vermute, dass eine Eindeutigkeit m√∂glich ist. </li><li>  Die Seriennummer des Motherboards, nicht eindeutig, ist m√∂glich und ziemlich oft. </li><li>  die Kennung des Computersystems ( <em>UUID</em> WMI-Eigenschaft der <em>Win32_ComputerSystemProduct-</em> Klasse), Nicht-Eindeutigkeit ist m√∂glich und ziemlich h√§ufig; </li><li>  Die Installationszeit des Betriebssystems ist die beste aller Optionen. Beim Klonen des Systems oder bei der Bereitstellung von einem Image ist jedoch eine Eindeutigkeit m√∂glich. </li></ul><br><p>  Da Sie mit keiner Option den Computer eindeutig identifizieren k√∂nnen, habe ich mich entschlossen, den Computer auf drei Arten zu identifizieren: </p><br><ul><li>  Seriennummer des Motherboards, </li><li>  Computersystem-ID </li><li>  Installationszeit des Betriebssystems. </li></ul><br><p>  Nat√ºrlich k√∂nnen diese drei Parameter auf verschiedenen Computern zusammenfallen, aber weniger h√§ufig als einer von ihnen. </p><br><p>  Es wurde auch versucht, aktive Benutzer mithilfe der Standard-WMI-Klasse <em>Win32_LogonSession zu gewinnen</em> .  Dann trat das erste Problem auf: Es stellte sich heraus, dass <em>Win32_LogonSession</em> alle Benutzersitzungen <em>anzeigt</em> , auch diejenigen, die bereits abgeschlossen wurden.  Ich begann zu √ºberlegen, wie ich aktive Sitzungen aus denen herausfiltern sollte, die endeten.  Es wurde festgestellt, dass dies mit der <em>Win32_SessionProcess-</em> Klasse durchgef√ºhrt werden kann, die Instanzen der <em>Win32_LogonSession-</em> Klassen mit <em>Win32_Process verkn√ºpft</em> .  Wenn der Link zur Sitzung in der Liste der Instanzen der <em>Win32_SessionProcess-</em> Klasse vorhanden ist (es gibt mindestens einen Prozess mit der Kennung dieser Sitzung), ist er aktiv.  Als n√§chstes stellte sich die Frage, wie eine Sitzung einem Benutzer zugeordnet werden kann.  Dies kann mit der <em>Win32_LoggedOnUser-</em> Klasse erfolgen, die Instanzen der <em>Klassen</em> <em>Win32_LogonSession</em> und <em>Win32_UserAccount</em> bindet.  Es m√ºssen nur noch Instanzen der <em>Win32_UserAccount-</em> Klasse <em>abgerufen werden</em> , die detaillierte Informationen zum Benutzer bereitstellen. </p><br><p><img src="https://habrastorage.org/webt/gq/0x/vg/gq0xvgaauo2dtpkmzajpife-x5g.png" alt="Bild"></p><br><p>  Aber hier war ich entt√§uscht.  Bei der Remote-Verwendung von WMI stellte sich heraus, dass beim Versuch, Instanzen der <em>Win32_UserAccount-</em> Klasse <em>abzurufen</em> , nur lokale Computerbenutzer <em>abgerufen werden</em> k√∂nnen.  Das hei√üt, es stellte sich heraus, dass mit Standard-WMI-Tools nicht herausgefunden werden kann, welche Benutzer auf dem Computer aktiv sind. </p><br><h3 id="razrabotka-wmi-provaydera">  Entwicklung eines WMI-Anbieters. </h3><br><p>  Aufgrund der Unm√∂glichkeit einer eindeutigen Identifizierung von Computern und der Unm√∂glichkeit, Informationen √ºber aktive Benutzer mithilfe von Standard-WMI-Klassen zu erhalten, wurde beschlossen, die Funktionalit√§t von WMI zu erweitern.  Sie k√∂nnen dies tun, indem Sie Ihre WMI-Klassen in einer MOF-Datei beschreiben und einen WMI-Anbieter schreiben, um Instanzen dieser Klassen abzurufen. </p><br><p>  Es wurden zwei neue WMI-Klassen beschrieben: <em>NMBY_InstallInfo</em> - zur Identifizierung eines Computers und <em>NMBY_LogonSession</em> - zur Identifizierung aktiver Benutzer eines Computers. </p><br><p><img src="https://habrastorage.org/webt/5b/op/gi/5bopgiwlndpdgqpb7h2zdhqbyxg.png" alt="Bild"></p><br><p>  Dann wurde ein WMI-Anbieter geschrieben, mit dem Sie Instanzen dieser Klassen erhalten k√∂nnen. </p><br><p>  F√ºr den Anbieter wurden zus√§tzliche Anforderungen festgelegt: </p><br><ul><li>  auf einem System ohne .NET arbeiten; </li><li>  Arbeit unter dem Betriebssystem Windows XP und h√∂her; </li><li>  die F√§higkeit, Informationen √ºber ein nicht administratives Konto zu erhalten. </li></ul><br><p>  Daher wurde der Anbieter mit WinApi in C ++ geschrieben. </p><br><p>  Beim Schreiben des Anbieters traten aufgrund der geringen Menge und Qualit√§t der Dokumentation zu diesem Thema Schwierigkeiten auf, der Anbieter wurde jedoch trotzdem erfolgreich geschrieben. </p><br><p>  Ein schriftlicher Anbieter ist auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Downloadseite</a> verf√ºgbar.  Es kann kostenlos installiert und verwendet werden. </p><br><h3 id="itog">  Zusammenfassung </h3><br><p>  Infolgedessen wurde mit dem Programm Network MACMonitor Folgendes m√∂glich: </p><br><ul><li>  Benutzer mit Computern verkn√ºpfen </li></ul><br><p><img src="https://habrastorage.org/webt/u7/zn/op/u7znop78jhskuqgge9w7axw1i5g.png" alt="Bild"></p><br><ul><li>  Verkn√ºpfen Sie Computer mit Ports auf Netzwerkger√§ten </li></ul><br><p><img src="https://habrastorage.org/webt/ri/53/zq/ri53zqdcphgvs9q5xnyqtc2wdjs.png" alt="Bild"></p><br><ul><li>  Verkn√ºpfen Sie Netzwerkger√§teports mit Computern und Benutzern </li></ul><br><p><img src="https://habrastorage.org/webt/_0/t-/ks/_0t-kseg8qqmzmxobo4z138hb54.png" alt="Bild"></p><br><ul><li>  Anzeigen des Benutzerregistrierungsverlaufs auf Computern. </li></ul><br><p><img src="https://habrastorage.org/webt/wp/u0/aa/wpu0aat6iwqqappksaq_vem9-yw.png" alt="Bild"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programmwebsite</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416217/">https://habr.com/ru/post/de416217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416207/index.html">"Nicht schlimmer als in Hogwarts" - zuk√ºnftige Studenten sprechen √ºber IT</a></li>
<li><a href="../de416209/index.html">DeepMind kann nicht aufh√∂ren: AI kann jetzt Quake III Arena spielen</a></li>
<li><a href="../de416211/index.html">Neuronen in 5 Minuten</a></li>
<li><a href="../de416213/index.html">Offenes Webinar "Abh√§ngigkeitsinjektion im Winkel"</a></li>
<li><a href="../de416215/index.html">Food Design Digest Juni 2018</a></li>
<li><a href="../de416219/index.html">Yandex begann, Google Text & Tabellen mit Passw√∂rtern zu indizieren</a></li>
<li><a href="../de416229/index.html">10 B√ºcher √ºber Marketing und verwandte Themen, die ein Designer lesen sollte</a></li>
<li><a href="../de416231/index.html">√úberwachung der Zadarma Zabbix-R√§ume</a></li>
<li><a href="../de416235/index.html">Erstellen benutzerdefinierter Komponenten f√ºr Bootstrap 4</a></li>
<li><a href="../de416237/index.html">Designer werden: von freiberuflich in einem Hostel √ºber die Zusammenarbeit mit Top-Unternehmen bis hin zur Einf√ºhrung Ihres Produkts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>