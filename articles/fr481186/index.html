<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏻 👼🏼 ↪️ Top 10 des bugs dans les projets Java pour 2019 🧑🏽‍🤝‍🧑🏻 ☝🏾 🍾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="2019 touche à sa fin et l'équipe PVS-Studio résume les résultats de l'année sortante. Début 2019, nous avons étendu les capacités de l'analyseur en pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 10 des bugs dans les projets Java pour 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/481186/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/uy/oe/n2uyoeo7ko6owq_omdtzx419gty.png"></div><br>  2019 touche à sa fin et l'équipe PVS-Studio résume les résultats de l'année sortante.  Début 2019, nous avons étendu les capacités de l'analyseur en prenant en charge le langage Java.  Par conséquent, la liste de nos publications sur la vérification des projets ouverts a été remplie avec des revues de projets Java.  De nombreuses erreurs ont été constatées au cours de l'année, et nous avons décidé de préparer le Top 10 des plus intéressants d'entre eux. <br><a name="habracut"></a><br><br><h2>  Dixième place: octet iconique </h2><br>  Source: <a href="https://www.viva64.com/ru/b/0663/">Analyse du code source du framework RPC Apache Dubbo par l'analyseur statique PVS-Studio</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007 L'</a> expression 'endKey [i] &lt;0xff' est toujours vraie.  OptionUtil.java (32) <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> ByteSequence </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prefixEndOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteSequence prefix)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] endKey = prefix.getBytes().clone(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = endKey.length - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endKey[i] &lt; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= endKey[i] = (byte) (endKey[i] + 1); return ByteSequence.from(Arrays.copyOf(endKey, i + 1)); } } return ByteSequence.from(NO_PREFIX_END); }</span></span></code> </pre> <br>  De nombreux programmeurs pensent qu'un type nommé <i>octet</i> ne sera pas signé.  Et en effet, souvent dans différentes langues, c'est exactement le cas.  Par exemple, en C #, le type d' <i>octet</i> n'est pas signé.  En Java, ce n'est pas le cas. <br><br>  Dans la condition <i>endKey [i] &lt;0xff, l'</i> auteur de la méthode compare une variable de type <i>octet</i> avec le nombre 255 (0xff), représenté dans la représentation hexadécimale.  Apparemment, lors de l'écriture de la méthode, le développeur a oublié que la plage de valeurs de type <i>octet</i> en Java est [-128, 127].  Cette condition est toujours vraie, donc la boucle <i>for</i> ne traitera toujours que le dernier élément du tableau <i>endKey</i> . <br><br><h2>  Neuvième place: deux en un </h2><br>  Source: <a href="https://www.viva64.com/ru/b/0621/">PVS-Studio pour Java est envoyé vers le chemin.</a>  <a href="https://www.viva64.com/ru/b/0621/">Le prochain arrêt est Elasticsearch</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007 L'</a> expression '(int) x &lt;0' est toujours fausse.  BCrypt.java (429) <br><br>  <a href="https://www.viva64.com/ru/w/v6025/">V6025 L'</a> index '(int) x' est peut-être hors limites.  BCrypt.java (431) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">char64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x &gt; index_64.length) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index_64[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x]; }</code> </pre> <br>  Aujourd'hui, nous avons une offre spéciale!  Deux erreurs dans une méthode à la fois.  La cause de la première erreur est le type <i>char</i> , qui n'est pas signé en Java, c'est pourquoi la condition <i>(int) x &lt;0 est</i> toujours fausse.  La deuxième erreur est le banal sortant des <i>limites du</i> tableau <i>index_64</i> lorsque <i>(int) x == index_64.length</i> .  Cette situation est possible en raison de la condition <i>(int) x&gt; index_64.length</i> .  Pour se débarrasser de sortir des limites du tableau, il est nécessaire de remplacer la condition '&gt;' par '&gt; ='.  La condition correcte serait: <i>(int) x&gt; = index_64.length</i> . <br><br><h2>  Huitième place: décision et ses conséquences </h2><br>  Source: <a href="https://www.viva64.com/ru/b/0626/">CUBA Platform Code Analysis avec PVS-Studio</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007 L'</a> expression 'previousMenuItemFlatIndex&gt; = 0' est toujours vraie.  CubaSideMenuWidget.java (328) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> MenuItemWidget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findNextMenuItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MenuItemWidget currentItem)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;MenuTreeNode&gt; menuTree = buildVisibleTree(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); List&lt;MenuItemWidget&gt; menuItemWidgets = menuTreeToList(menuTree); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> menuItemFlatIndex = menuItemWidgets.indexOf(currentItem); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> previousMenuItemFlatIndex = menuItemFlatIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousMenuItemFlatIndex &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= return menuItemWidgets.get(previousMenuItemFlatIndex); } return null; }</span></span></code> </pre> <br>  L'auteur de la méthode <i>findNextMenuItem</i> souhaite se débarrasser du -1 renvoyé par la méthode <i>indexOf</i> si la liste <i>menuItemWidgets ne</i> contient pas <i>currentItem</i> .  Pour ce faire, il en ajoute un au résultat <i>indexOf</i> (variable <i>menuItemFlatIndex</i> ) et stocke la valeur résultante dans la variable <i>précédenteMenuItemFlatIndex</i> , qui est ensuite utilisée dans la méthode.  Cette solution au problème -1 échoue car elle conduit à plusieurs erreurs à la fois: <br><br><ul><li>  <i>return null</i> code ne sera jamais exécuté, car l'expression <i>previousMenuItemFlatIndex&gt; = 0 est</i> toujours vraie, ce qui signifie que le retour de la méthode <i>findNextMenuItem se</i> produira toujours à l'intérieur du <i>if</i> ; </li><li>  une <i>IndexOutOfBoundsException</i> sera levée lorsque la liste <i>menuItemWidgets</i> est vide, car le premier élément de la liste vide sera accessible; </li><li>  une exception <i>IndexOutOfBoundsException</i> se produit lorsque l'argument <i>currentItem</i> est le dernier de la liste <i>menuItemWidget</i> . </li></ul><br><h2>  Septième place: créer un fichier à partir de rien </h2><br>  Source: <a href="https://www.viva64.com/ru/b/0688/">Huawei Cloud: il est nuageux dans PVS-Studio aujourd'hui</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6008/">V6008 Déréférence</a> nulle potentielle de 'dataTmpFile'.  CacheManager.java (91) <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putToCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PutRecordsRequest putRecordsRequest)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists()) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dataTmpFile.createNewFile(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } catch (IOException e) { LOGGER.error("Failed to create cache tmp file, return.", e); return; } } .... }</span></span></code> </pre> <br>  Lors de l'écriture de la méthode <i>putToCache, le</i> programmeur a fait une faute de frappe dans la condition <i>dataTmpFile == null ||</i>  <i>! dataTmpFile.exists ()</i> avant de créer un nouveau fichier <i>dataTmpFile.createNewFile ().</i>  Une faute de frappe est l'utilisation de l'opérateur '==' au lieu de '! ='.  Cette faute de frappe <i>lèvera une exception</i> <i>NullPointerException</i> lors de l'appel de la méthode <i>createNewFile</i> .  La condition après avoir corrigé une faute de frappe ressemble à ceci: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !dataTmpFile.exists())</code> </pre> <br>  «L'erreur a été trouvée, corrigée.  Vous pouvez vous détendre », penserez-vous.  Mais peu importe comment! <br><br>  Après avoir corrigé une erreur, nous en avons trouvé une autre.  Maintenant, une <i>exception NullPointerException</i> peut se produire lors de l'appel de <i>dataTmpFile.exists ()</i> .  Maintenant, pour se débarrasser de l'exception, il est nécessaire de remplacer l'opérateur '||' dans la condition  sur '&amp;&amp;'.  La condition dans laquelle toutes les erreurs disparaissent sera la suivante: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dataTmpFile != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !dataTmpFile.exists())</code> </pre> <br><h2>  Sixième place: une erreur logique très étrange </h2><br>  Source: <a href="https://www.viva64.com/ru/b/0603/">PVS-Studio pour Java</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6007/">V6007</a> [CWE-570] L'expression "" 0 ".equals (texte)" est toujours fausse.  ConvertIntegerToDecimalPredicate.java 46 <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">@NonNls</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) {<span class="hljs-comment"><span class="hljs-comment">// &lt;= return false; } return text.charAt(0) == '0'; }</span></span></code> </pre> <br>  Cette méthode est intéressante en ce qu'elle contient une erreur logique évidente.  Si la méthode <i>satisfaitBy ne</i> renvoie pas de valeur après le premier <i>if</i> , il devient connu que la chaîne de <i>texte se</i> compose d'au moins deux caractères.  Pour cette raison, la première coche <i>«0» .equals (texte)</i> dans la suivante <i>si</i> n'a pas de sens.  Ce que le développeur voulait vraiment dire reste un mystère. <br><br><h2>  Cinquième place: c'est un tour! </h2><br>  Source: <a href="https://www.viva64.com/ru/b/0657/">PVS-Studio visite Apache Hive</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6034/">V6034 Le</a> décalage de la valeur de 'bitShiftsInWord - 1' peut ne pas correspondre à la taille du type: 'bitShiftsInWord - 1' = [-1 ... 30].  UnsignedInt128.java (1791) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shiftRightDestructive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wordShifts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bitShiftsInWord, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> roundUp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; bitShiftsInWord == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (bitShiftsInWord &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> (bitShiftsInWord &lt; <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wordShifts &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { zeroClear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shiftRestore = <span class="hljs-number"><span class="hljs-number">32</span></span> - bitShiftsInWord; <span class="hljs-comment"><span class="hljs-comment">// check this because "123 &lt;&lt; 32" will be 123. final boolean noRestore = bitShiftsInWord == 0; final int roundCarryNoRestoreMask = 1 &lt;&lt; 31; final int roundCarryMask = (1 &lt;&lt; (bitShiftsInWord - 1)); // &lt;= .... }</span></span></code> </pre> <br>  Avec les arguments d'entrée <i>wordShifts = 3</i> et <i>bitShiftsInWord = 0</i> , la variable <i>roundCarryMask</i> , qui stocke le résultat du décalage de bit <i>(1 &lt;&lt; (bitShiftsInWord - 1))</i> , se révélera être un nombre négatif.  Peut-être que le développeur ne s'attendait pas à ce comportement. <br><br><h2>  Quatrième place: les exceptions sortiront-elles pour une promenade? </h2><br>  Source: <a href="https://www.viva64.com/ru/b/0657/">PVS-Studio visite Apache Hive</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6051/">V6051</a> L'utilisation de l'instruction 'return' dans le bloc 'finalement' peut entraîner la perte d'exceptions non gérées.  ObjectStore.java (9080) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> List&lt;MPartitionColumnStatistics&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMPartitionColumnStatistics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> NoSuchObjectException, MetaException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> committed = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... <span class="hljs-comment"><span class="hljs-comment">/*some actions*/</span></span> committed = commitTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception ex) { LOG.error(<span class="hljs-string"><span class="hljs-string">"Error retrieving statistics via jdo"</span></span>, ex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> MetaException) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> (MetaException) ex; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MetaException(ex.getMessage()); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!committed) { rollbackTransaction(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lists.newArrayList(); } } }</code> </pre> <br>  La déclaration de la méthode <i>getMPartitionColumnStatistics</i> nous ment, disant qu'elle peut lever une exception.  Lorsqu'une exception se produit dans <i>try</i> , la variable validée reste <i>fausse</i> , par conséquent, dans le bloc <i>finally</i> , l' <i>instruction return</i> renvoie la valeur de la méthode et toutes les exceptions levées sont perdues et ne peuvent pas être traitées en dehors de la méthode.  Ainsi, aucune exception levée dans cette méthode ne pourra jamais en sortir. <br><br><h2>  Troisième place: je tourne, je tourne, je veux obtenir un nouveau masque </h2><br>  Source: <a href="https://www.viva64.com/ru/b/0657/">PVS-Studio visite Apache Hive</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6034/">V6034 Le</a> décalage de la valeur de 'j' peut être incompatible avec la taille du type: 'j' = [0 ... 63].  IoTrace.java (272) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logSargResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> stripeIx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] rgsToRead)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, valOffset = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elements; ++i, valOffset += <span class="hljs-number"><span class="hljs-number">64</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">64</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix = valOffset + j; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rgsToRead.length == ix) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rgsToRead[ix]) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; val = val | (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; j); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } .... } .... }</span></span></code> </pre> <br>  Une autre erreur liée au décalage au niveau du bit, mais cette fois non seulement il a été impliqué dans l'affaire.  Dans la boucle <i>for</i> interne, la variable <i>j</i> [0 ... 63] est utilisée comme compteur de boucle.  Ce compteur est impliqué dans un décalage binaire de <i>1 &lt;&lt; j</i> .  Rien ne présage de problème, cependant, le littéral entier '1' de type <i>int</i> (valeur 32 bits) entre en jeu ici.  Il s'ensuit que les résultats du décalage binaire commenceront à se répéter après que <i>j</i> soit supérieur à 31. Si le comportement décrit n'est pas souhaitable, alors l'unité doit être représentée aussi <i>longtemps</i> , par exemple, <i>1L &lt;&lt; j</i> ou <i>(long) 1 &lt;&lt; j</i> . <br><br><h2>  Deuxième place: ordre d'initialisation </h2><br>  Source: <a href="https://www.viva64.com/ru/b/0688/">Huawei Cloud: il est nuageux dans PVS-Studio aujourd'hui</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6050/">Le</a> cycle d'initialisation de la classe <a href="https://www.viva64.com/ru/w/v6050/">V6050</a> est présent.  L'initialisation de 'INSTANCE' apparaît avant l'initialisation de 'LOG'.  UntrustedSSL.java (32), UntrustedSSL.java (59), UntrustedSSL.java (33) <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UntrustedSSL INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UntrustedSSL(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger LOG = LoggerFactory.getLogger(UntrustedSSL.class); .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UntrustedSSL</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { LOG.error(t.getMessage(), t); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } } }</span></span></code> </pre> <br>  L'ordre dans lequel les champs sont déclarés dans une classe est important car les champs sont initialisés dans l'ordre dans lequel ils sont déclarés.  Cependant, quand ils l'oublient, des erreurs subtiles se produisent, comme celle-ci. <br><br>  L'analyseur a indiqué que le champ <i>LOG</i> statique est déréférencé dans le constructeur lorsqu'il est initialisé à <i>null</i> , ce qui conduit à la chaîne d'exceptions <i>NullPointerException</i> -&gt; <i>ExceptionInInitializerError</i> . <br><br>  «Pourquoi, au moment de l'appel du constructeur, le champ <i>LOG</i> statique est-il <i>nul</i> ?», Vous demandez-vous. <br><br>  L'exception <i>ExceptionInInitializerError</i> est un indice.  Le fait est que ce constructeur est utilisé pour initialiser le champ statique <i>INSTANCE</i> déclaré dans la classe plus tôt que le champ <i>LOG</i> .  Par conséquent, au moment de l'appel du constructeur, le champ <i>LOG</i> n'est toujours pas initialisé.  Pour que le code fonctionne correctement, vous devez initialiser le champ <i>LOG</i> avant d'appeler le constructeur. <br><br><h2>  Première place: programmation orientée copier-coller </h2><br>  Source: <a href="https://www.viva64.com/ru/b/0697/">Apache Hadoop Code Qualité: production VS test</a> <br><br>  <a href="https://www.viva64.com/ru/w/v6072/">V6072</a> Deux fragments de code similaires ont été trouvés.  Il s'agit peut-être d'une faute de frappe et la variable «localFiles» devrait être utilisée à la place de «localArchives».  LocalDistributedCacheManager.java (183), LocalDistributedCacheManager.java (178), LocalDistributedCacheManager.java (176), LocalDistributedCacheManager.java (181) <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JobConf conf, JobID jobId)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">// Update the configuration object with localized data. if (!localArchives.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALARCHIVES, StringUtils .arrayToString(localArchives.toArray(new String[localArchives // &lt;= .size()]))); } if (!localFiles.isEmpty()) { conf.set(MRJobConfig.CACHE_LOCALFILES, StringUtils .arrayToString(localFiles.toArray(new String[localArchives // &lt;= .size()]))); } .... }</span></span></code> </pre> <br>  Et la première place est prise par copier-coller, ou plutôt, une erreur qui est survenue en raison de la négligence de celui qui a commis cette chose pécheresse.  Il est fort probable que le second <i>if ait</i> été créé par copier-coller du premier avec le remplacement des variables: <br><br><ul><li>  <i>localArchives</i> sur <i>localFiles</i> ; </li><li>  <i>MRJobConfig.CACHE_LOCALARCHIVES</i> à <i>MRJobConfig.CACHE_LOCALFILES</i> . </li></ul><br>  Cependant, même avec une opération aussi simple, une erreur a été commise, car la variable <i>localArchives</i> était toujours utilisée dans la deuxième ligne <i>if</i> dans le deuxième <i>analyseur</i> , bien que l'utilisation de <i>localFiles soit</i> très probablement implicite. <br><br><h2>  Conclusion </h2><br>  La correction des erreurs détectées dans les derniers stades de développement ou après la publication d'un projet nécessite des ressources importantes.  L'analyseur statique PVS-Studio simplifie la détection des erreurs lors de l'écriture de code, ce qui réduit considérablement la quantité de ressources dépensées pour les corriger.  L'utilisation constante de l'analyseur a déjà simplifié la vie des développeurs de nombreuses <a href="https://www.viva64.com/ru/customers/">entreprises</a> .  Si vous souhaitez programmer avec grand plaisir, essayez notre <a href="https://www.viva64.com/ru/pvs-studio-download/">analyseur</a> . <br><br>  Notre équipe ne s'arrêtera pas là et continuera d'améliorer et d'améliorer l'analyseur.  Attendez-vous à de nouveaux diagnostics et articles avec des bogues encore plus intéressants l'année prochaine. <br><br>  Je te regarde aimer l'aventure!  Tout d'abord, le <a href="https://habr.com/ru/company/pvs-studio/blog/481178/">top 10 des erreurs dans les projets C # pour 2019 a</a> gagné, et maintenant Java a pu surmonter!  Bienvenue au niveau suivant dans l'article sur les <a href="https://habr.com/ru/company/pvs-studio/blog/481190/">meilleures erreurs de 2019 dans les projets C ++</a> . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/24/2j/ex/242jexzqwnmth1lyfcrr8icxmms.png"></div><br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/481184/"><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br>  Si vous souhaitez partager cet article avec un public anglophone, veuillez utiliser le lien vers la traduction: Valery Komarov.  <a href="https://habr.com/en/company/pvs-studio/blog/481184/">Top 10 des bugs trouvés dans les projets Java en 2019</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481186/">https://habr.com/ru/post/fr481186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481176/index.html">Couriers Yandex.Le Food and Delivery Club a besoin d'un syndicat</a></li>
<li><a href="../fr481178/index.html">Top 10 des bugs dans les projets C # pour 2019</a></li>
<li><a href="../fr481180/index.html">Les développeurs doivent-ils recevoir des suggestions des utilisateurs?</a></li>
<li><a href="../fr481182/index.html">Istio Service Mesh Posts Series</a></li>
<li><a href="../fr481184/index.html">Top 10 des bugs trouvés dans les projets Java en 2019</a></li>
<li><a href="../fr481188/index.html">Top 10 des bugs trouvés dans les projets C ++ en 2019</a></li>
<li><a href="../fr481190/index.html">Top 10 des bugs dans les projets C ++ pour 2019</a></li>
<li><a href="../fr481200/index.html">Voice Control et VoiceOver: comment adapter l'application pour les aveugles ou encore</a></li>
<li><a href="../fr481202/index.html">Antiquités: le principe de la collecte des ordures et les résultats de 2019</a></li>
<li><a href="../fr481204/index.html">Tech release Mail.ru Group, hiver 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>