<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöì üí™üèª üç• Nouvelle tentative de requ√™tes HTTP ayant √©chou√© dans Angular üïì üë©üèª‚Äçü§ù‚Äçüë®üèæ üë©‚Äçüë©‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'organisation de l'acc√®s aux donn√©es du serveur est √† la base de presque toutes les applications d'une page. Tout le contenu dynamique de ces applica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nouvelle tentative de requ√™tes HTTP ayant √©chou√© dans Angular</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459302/">  L'organisation de l'acc√®s aux donn√©es du serveur est √† la base de presque toutes les applications d'une page.  Tout le contenu dynamique de ces applications est t√©l√©charg√© depuis le backend. <br><br>  Dans la plupart des cas, les requ√™tes HTTP au serveur fonctionnent de mani√®re fiable et renvoient le r√©sultat souhait√©.  Cependant, dans certaines situations, les demandes peuvent √©chouer. <br><br>  Imaginez comment quelqu'un travaille avec votre site Web via un point d'acc√®s dans un train qui parcourt le pays √† une vitesse de 200 kilom√®tres par heure.  La connexion r√©seau dans ce sc√©nario peut √™tre lente, mais les demandes du serveur, malgr√© cela, font leur travail. <br><br>  Mais que faire si le train entre dans le tunnel?  Il existe une forte probabilit√© que la connexion √† Internet soit interrompue et que l'application Web ne puisse pas "atteindre" le serveur.  Dans ce cas, l'utilisateur devra recharger la page d'application une fois le train sorti du tunnel et la connexion Internet r√©tablie. <br><br>  Recharger la page peut affecter l'√©tat actuel de l'application.  Cela signifie que l'utilisateur peut, par exemple, perdre les donn√©es qu'il a entr√©es dans le formulaire. <br><br>  Au lieu de simplement se r√©concilier avec le fait qu'une certaine demande n'a pas abouti, il vaudrait mieux la r√©p√©ter plusieurs fois et montrer √† l'utilisateur une notification correspondante.  Avec cette approche, lorsque l'utilisateur se rend compte que l'application essaie de faire face au probl√®me, il ne rechargera probablement pas la page. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/tq/jn/st/tqjnsttqoifuf4p9-rnt_g1dfwg.jpeg"></a> <br><br>  Le mat√©riel, dont nous publions la traduction aujourd'hui, est consacr√© √† l'analyse de plusieurs fa√ßons de r√©p√©ter les demandes infructueuses dans les applications angulaires. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">R√©p√©ter les demandes ayant √©chou√©</font> </h2><br>  Reproduisons une situation qu'un utilisateur travaillant sur Internet √† partir d'un train peut rencontrer.  Nous allons cr√©er un backend qui traite la demande de mani√®re incorrecte lors des trois premi√®res tentatives pour y acc√©der, renvoyant uniquement les donn√©es de la quatri√®me tentative. <br>  Habituellement, en utilisant Angular, nous cr√©ons un service, connectons le <code>HttpClient</code> et l'utilisons pour obtenir des donn√©es du backend. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      catchError((</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      })    );  } }</span></span></code> </pre> <br>  Il n'y a rien de sp√©cial ici.  Nous <code>HttpClient</code> module Angular <code>HttpClient</code> et <code>HttpClient</code> une simple requ√™te GET.  Si la requ√™te retourne une erreur, nous ex√©cutons du code pour la traiter et renvoyons un <code>Observable</code> vide (objet observable) afin d'informer de ce qui a initi√© la requ√™te.  Ce code, pour ainsi dire, dit: "Il y avait une erreur, mais tout est en ordre, je peux le g√©rer." <br><br>  La plupart des applications effectuent les requ√™tes HTTP de cette fa√ßon.  Dans le code ci-dessus, la demande n'est ex√©cut√©e qu'une seule fois.  Apr√®s cela, il retourne les donn√©es re√ßues du serveur ou √©choue. <br><br>  Comment r√©p√©ter la demande si le noeud final <code>/greet</code> pas disponible ou renvoie une erreur?  Peut-√™tre existe-t-il une instruction RxJS appropri√©e?  Bien s√ªr que √ßa existe.  RxJS a des op√©rateurs pour tout. <br><br>  La premi√®re chose qui peut vous venir √† l'esprit dans cette situation est l' <code>retry</code> .  Regardons sa d√©finition: ¬´Renvoie un Observable qui joue l'Observable original sauf <code>error</code> .  Si l'observable d'origine appelle l' <code>error</code> , cette m√©thode, au lieu de propager l'erreur, se r√©abonnera √† l'observable d'origine. <br><br>  Le nombre maximal de r√©abonnements est limit√© au <code>count</code> (il s'agit du param√®tre num√©rique transmis √† la m√©thode). " <br><br>  La <code>retry</code> tr√®s similaire √† ce dont nous avons besoin.  Alors, int√©grons-le dans notre cha√Æne. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError, retry, shareReplay} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      retry(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">),      </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">catchError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      }),      shareReplay()    );  } }</span></span></code> </pre> <br>  Nous avons utilis√© avec succ√®s l'op√©rateur de nouvelle <code>retry</code> .  Voyons comment cela a affect√© le comportement de la requ√™te HTTP qui est ex√©cut√©e dans l'application exp√©rimentale.  <a href="">Voici</a> un grand fichier GIF qui montre l'√©cran de cette application et l'onglet R√©seau des outils de d√©veloppement du navigateur.  Vous trouverez plusieurs autres d√©monstrations de ce type ici. <br><br>  Notre application est extr√™mement simple.  Il fait simplement une requ√™te HTTP lorsque le bouton <code>PING THE SERVER</code> est cliqu√©. <br><br>  Comme d√©j√† mentionn√©, le backend renvoie une erreur lors de l'ex√©cution des trois premi√®res tentatives pour lui ex√©cuter une requ√™te, et lorsqu'une quatri√®me requ√™te lui parvient, il renvoie une r√©ponse normale. <br><br>  Dans l'onglet Outil du d√©veloppeur r√©seau, vous pouvez voir que l' <code>retry</code> r√©sout la t√¢che qui lui est affect√©e et r√©p√®te l'ex√©cution de la demande ayant √©chou√© trois fois.  La derni√®re tentative a r√©ussi, l'application re√ßoit une r√©ponse, un message correspondant appara√Æt sur la page. <br><br>  Tout cela est tr√®s bien.  Maintenant, l'application peut r√©p√©ter les demandes ayant √©chou√©. <br><br>  Cependant, cet exemple peut encore √™tre am√©lior√©.  Veuillez noter que les requ√™tes d√©sormais r√©p√©t√©es sont ex√©cut√©es imm√©diatement apr√®s l'ex√©cution des requ√™tes infructueuses.  Ce comportement du syst√®me n'apportera pas beaucoup d'avantages dans notre situation - lorsque le train p√©n√®tre dans le tunnel et que la connexion Internet est perdue pendant un certain temps. <br><br><h2>  <font color="#3AC1EF">Nouvelle tentative retard√©e des demandes ayant √©chou√©</font> </h2><br>  Le train qui est entr√© dans le tunnel ne le quitte pas instantan√©ment.  Il y passe du temps.  Par cons√©quent, nous devons ¬´√©tirer¬ª la p√©riode pendant laquelle nous effectuons des requ√™tes r√©p√©t√©es au serveur.  Vous pouvez le faire en diff√©rant les tentatives. <br><br>  Pour ce faire, nous devons mieux contr√¥ler le processus d'ex√©cution des demandes r√©p√©t√©es.  Nous devons √™tre en mesure de prendre des d√©cisions sur le moment exact de r√©p√©ter les demandes.  Cela signifie que les capacit√©s de l'op√©rateur de nouvelle <code>retry</code> ne nous suffisent plus.  Par cons√©quent, nous nous tournons √† nouveau vers la documentation sur RxJS. <br><br>  La documentation contient une description de l' <code>retryWhen</code> , qui semble nous convenir.  Dans la documentation, il est d√©crit comme suit: ¬´Renvoie un observable qui lit l'observable d'origine √† l'exception de l' <code>error</code> .  Si l' <code>error</code> Observable d'origine appelle, alors cette m√©thode lancera Throwable, qui a provoqu√© l'erreur, l'Observable retourn√© par <code>notifier</code> .  Si cet Observable appelle <code>complete</code> ou <code>error</code> , cette m√©thode appellera <code>complete</code> ou <code>error</code> sur l'abonnement enfant.  Sinon, cette m√©thode se r√©abonnera √† l'Observable d'origine. " <br><br>  Oui, la d√©finition n'est pas simple.  D√©crivons la m√™me chose dans un langage plus accessible. <br><br>  L' <code>retryWhen</code> accepte un rappel qui renvoie un Observable.  L'observable renvoy√© d√©cide du <code>retryWhen</code> op√©rateur <code>retryWhen</code> fonction de certaines r√®gles.  √Ä savoir, <code>retryWhen</code> comment <code>retryWhen</code> op√©rateur <code>retryWhen</code> : <br><br><ul><li>  Il cesse de fonctionner et g√©n√®re une erreur si l'Observable renvoy√© renvoie une erreur. </li><li>  Il se ferme si l'observable retourn√© signale l'ach√®vement. </li><li>  Dans d'autres cas, lorsque l'observable revient avec succ√®s, il r√©p√®te l'ex√©cution de l'observable d'origine </li></ul><br>  Un rappel n'est appel√© que lorsque l'Observable d'origine renvoie une erreur pour la premi√®re fois. <br><br>  Nous pouvons maintenant utiliser ces connaissances pour cr√©er un m√©canisme de nouvelle tentative diff√©r√©e pour une demande ayant √©chou√© √† l'aide de l'instruction <code>retryWhen</code> . <br><br><pre> <code class="plaintext hljs">retryWhen((errors: Observable&lt;any&gt;) =&gt; errors.pipe(    delay(delayMs),    mergeMap(error =&gt; retries-- &gt; 0 ? of(error) : throwError(getErrorMessage(maxEntry))    )) )</code> </pre> <br>  Si l'Observable d'origine, qui est notre requ√™te HTTP, renvoie une erreur, alors l'instruction <code>retryWhen</code> est <code>retryWhen</code> .  Dans le rappel, nous avons acc√®s √† l'erreur qui a provoqu√© l'√©chec.  Nous reportons les <code>errors</code> , r√©duisons le nombre de nouvelles tentatives et renvoyons un nouvel observable qui g√©n√®re une erreur. <br><br>  En fonction des r√®gles de l' <code>retryWhen</code> , cet observable, car il <code>retryWhen</code> , <code>retryWhen</code> demande.  Si la r√©p√©tition √©choue plusieurs fois et que la valeur de la variable <code>retries</code> diminue √† 0, nous terminons la t√¢che avec une erreur qui s'est produite lors de l'ex√©cution de la demande. <br><br>  Super!  Apparemment, nous pouvons prendre le code ci-dessus et remplacer l'op√©rateur de nouvelle <code>retry</code> dans notre cha√Æne par lui.  Mais ici, nous ralentissons un peu. <br><br>  Comment <code>retries</code> les <code>retries</code> variables?  Cette variable contient l'√©tat actuel du syst√®me de nouvelle tentative de demande ayant √©chou√©.  O√π est-elle annonc√©e?  Quand la condition est-elle r√©initialis√©e?  L'√âtat doit √™tre g√©r√© √† l'int√©rieur du flux, pas √† l'ext√©rieur. <br><br><h3>  <font color="#3AC1EF">‚ñçCr√©ez votre propre instruction delayRetry</font> </h3><br>  Nous pouvons r√©soudre le probl√®me de la gestion des √©tats et am√©liorer la lisibilit√© du code en √©crivant le code ci-dessus en tant qu'op√©rateur RxJS distinct. <br><br>  Il existe diff√©rentes fa√ßons de cr√©er vos propres op√©rateurs RxJS.  La m√©thode √† utiliser d√©pend de la structure de l'op√©rateur concern√©. <br><br>  Notre op√©rateur est bas√© sur les op√©rateurs RxJS existants.  En cons√©quence, nous pouvons utiliser le moyen le plus simple pour cr√©er nos propres op√©rateurs.  Dans notre cas, l'op√©rateur RxJs est juste une fonction avec la signature suivante: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt;</code> </pre> <br>  Cette d√©claration prend l'Observable d'origine et renvoie un autre Observable. <br><br>  √âtant donn√© que notre op√©rateur permet √† l'utilisateur de sp√©cifier la fr√©quence √† laquelle les demandes r√©p√©t√©es doivent √™tre ex√©cut√©es et le nombre de fois o√π elles doivent √™tre ex√©cut√©es, nous devons encapsuler la d√©claration de fonction ci-dessus dans une fonction d'usine, qui prend <code>delayMs</code> (d√©lai entre les <code>maxRetry</code> ) et <code>maxRetry</code> ( nombre maximum de r√©p√©titions). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt; }</code> </pre> <br>  Si vous souhaitez cr√©er un op√©rateur qui n'est pas bas√© sur des op√©rateurs existants, vous devez faire attention √† la gestion des erreurs et des abonnements.  De plus, vous devrez √©tendre la classe <code>Observable</code> et impl√©menter la fonction <code>lift</code> . <br><br>  Si vous √™tes int√©ress√©, jetez un ≈ìil <a href="">ici</a> . <br><br>  Donc, sur la base des extraits de code ci-dessus, √©crivons notre propre op√©rateur RxJs. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delayedRetry</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        delay(delayMs),        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error) : throwError(getErrorMessage(maxRetry))        ))      )    ); }</code> </pre> <br>  Super.  Nous pouvons maintenant importer cet op√©rateur dans le code client.  Nous l'utiliserons lors de l'ex√©cution d'une requ√™te HTTP. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span><span class="hljs-string">/greet`</span></span>).pipe(        delayedRetry(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>),        catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error);            <span class="hljs-comment"><span class="hljs-comment">//               return EMPTY;        }),        shareReplay()    );</span></span></code> </pre> <br>  Nous avons plac√© l'op√©rateur <code>delayedRetry</code> dans la cha√Æne et pass√© les param√®tres 1000 et 3. Le premier param√®tre d√©finit le d√©lai en millisecondes entre les tentatives de demandes r√©p√©t√©es.  Le deuxi√®me param√®tre d√©termine le nombre maximal de demandes r√©p√©t√©es. <br><br>  Red√©marrez l'application et <a href="">regardez</a> comment fonctionne le nouvel op√©rateur. <br><br>  Apr√®s avoir analys√© le comportement du programme √† l'aide des outils du d√©veloppeur de navigateur, nous pouvons voir que l'ex√©cution de tentatives r√©p√©t√©es pour ex√©cuter la demande est retard√©e d'une seconde.  Apr√®s avoir re√ßu la bonne r√©ponse √† la demande, un message correspondant appara√Ætra dans la fen√™tre de l'application. <br><br><h2>  <font color="#3AC1EF">R√©p√©tition de demande exponentielle</font> </h2><br>  D√©veloppons l'id√©e d'une nouvelle tentative diff√©r√©e des demandes ayant √©chou√©.  Auparavant, nous retardions toujours l'ex√©cution de chacune des demandes r√©p√©t√©es en m√™me temps. <br><br>  Ici, nous parlons de la fa√ßon d'augmenter le d√©lai apr√®s chaque tentative.  La premi√®re tentative de nouvelle tentative est effectu√©e apr√®s une seconde, la deuxi√®me apr√®s deux secondes, la troisi√®me apr√®s trois. <br><br>  Cr√©ez une nouvelle instruction, <code>retryWithBackoff</code> , qui impl√©mente ce comportement. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up.`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_BACKOFF = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retryWithBackoff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES, backoffMs = DEFAULT_BACKOFF</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {              <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backoffTime = delayMs + (maxRetry - retries) * backoffMs;              <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error).pipe(delay(backoffTime));            }            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> throwError(getErrorMessage(maxRetry));          }        )))); }</code> </pre> <br>  Si vous utilisez cet op√©rateur dans l'application et le testez, vous pouvez <a href="">voir</a> comment le d√©lai d'ex√©cution de la demande r√©p√©t√©e augmente apr√®s chaque nouvelle tentative. <br><br>  Apr√®s chaque tentative, nous attendons un certain temps, r√©p√©tons la demande et augmentons le temps d'attente.  Ici, comme d'habitude, une fois que le serveur a renvoy√© la bonne r√©ponse √† la demande, nous affichons un message dans la fen√™tre de l'application. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  La r√©p√©tition des requ√™tes HTTP ayant √©chou√© rend les applications plus stables.  Ceci est particuli√®rement important lors de l'ex√©cution de requ√™tes tr√®s importantes, sans les donn√©es obtenues gr√¢ce auxquelles l'application ne peut pas fonctionner normalement.  Par exemple, il peut s'agir de donn√©es de configuration contenant les adresses des serveurs avec lesquels l'application doit interagir. <br><br>  Dans la plupart des sc√©narios, l'instruction de nouvelle tentative RxJs <code>retry</code> pas suffisante pour fournir un syst√®me de nouvelle tentative fiable pour les demandes ayant √©chou√©.  L' <code>retryWhen</code> donne au d√©veloppeur un niveau de contr√¥le plus √©lev√© sur les demandes r√©p√©t√©es.  Il vous permet de configurer l'intervalle des demandes r√©p√©t√©es.  En raison des capacit√©s de cet op√©rateur, il est possible de mettre en ≈ìuvre un sch√©ma de r√©p√©tition retard√©e ou des r√©p√©titions retard√©es exponentiellement. <br><br>  Lors de l'impl√©mentation de mod√®les de comportement pouvant √™tre r√©utilis√©s dans les cha√Ænes RxJS, il est recommand√© de les formater en tant que nouveaux op√©rateurs.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/kreuzerk/">Voici le</a> r√©f√©rentiel √† partir duquel le code a √©t√© utilis√© dans cet article. <br><br>  <b>Chers lecteurs!</b>  Comment r√©solvez-vous le probl√®me de la nouvelle tentative de requ√™tes HTTP ayant √©chou√©? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459302/">https://habr.com/ru/post/fr459302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459292/index.html">Automatisation des tests d'applications mobiles: comparaison d'outils</a></li>
<li><a href="../fr459294/index.html">Quoi de plus important: conna√Ætre un langage de programmation ou √™tre capable de r√©soudre un probl√®me m√©tier?</a></li>
<li><a href="../fr459296/index.html">Prix ‚Äã‚ÄãJavaScript 2019</a></li>
<li><a href="../fr459298/index.html">Angulaire: statut en 2019</a></li>
<li><a href="../fr459300/index.html">Quasar 1.0: un nouvel outil utile pour les d√©veloppeurs de Vue et pas seulement pour eux</a></li>
<li><a href="../fr459304/index.html">Contournement angulaire de l'√©cueil et gain de temps</a></li>
<li><a href="../fr459306/index.html">Rendu de serveur dans un environnement sans serveur</a></li>
<li><a href="../fr459308/index.html">Le r√©f√©rencement ne fonctionne pas en 2019?</a></li>
<li><a href="../fr459310/index.html">Outils d'automatisation de test ou testeur de st√©ro√Ødes mobile</a></li>
<li><a href="../fr459312/index.html">Cher Agile, j'en ai marre de faire semblant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>