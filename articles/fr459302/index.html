<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚓 💪🏻 🍥 Nouvelle tentative de requêtes HTTP ayant échoué dans Angular 🕓 👩🏻‍🤝‍👨🏾 👩‍👩‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'organisation de l'accès aux données du serveur est à la base de presque toutes les applications d'une page. Tout le contenu dynamique de ces applica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nouvelle tentative de requêtes HTTP ayant échoué dans Angular</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459302/">  L'organisation de l'accès aux données du serveur est à la base de presque toutes les applications d'une page.  Tout le contenu dynamique de ces applications est téléchargé depuis le backend. <br><br>  Dans la plupart des cas, les requêtes HTTP au serveur fonctionnent de manière fiable et renvoient le résultat souhaité.  Cependant, dans certaines situations, les demandes peuvent échouer. <br><br>  Imaginez comment quelqu'un travaille avec votre site Web via un point d'accès dans un train qui parcourt le pays à une vitesse de 200 kilomètres par heure.  La connexion réseau dans ce scénario peut être lente, mais les demandes du serveur, malgré cela, font leur travail. <br><br>  Mais que faire si le train entre dans le tunnel?  Il existe une forte probabilité que la connexion à Internet soit interrompue et que l'application Web ne puisse pas "atteindre" le serveur.  Dans ce cas, l'utilisateur devra recharger la page d'application une fois le train sorti du tunnel et la connexion Internet rétablie. <br><br>  Recharger la page peut affecter l'état actuel de l'application.  Cela signifie que l'utilisateur peut, par exemple, perdre les données qu'il a entrées dans le formulaire. <br><br>  Au lieu de simplement se réconcilier avec le fait qu'une certaine demande n'a pas abouti, il vaudrait mieux la répéter plusieurs fois et montrer à l'utilisateur une notification correspondante.  Avec cette approche, lorsque l'utilisateur se rend compte que l'application essaie de faire face au problème, il ne rechargera probablement pas la page. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/tq/jn/st/tqjnsttqoifuf4p9-rnt_g1dfwg.jpeg"></a> <br><br>  Le matériel, dont nous publions la traduction aujourd'hui, est consacré à l'analyse de plusieurs façons de répéter les demandes infructueuses dans les applications angulaires. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Répéter les demandes ayant échoué</font> </h2><br>  Reproduisons une situation qu'un utilisateur travaillant sur Internet à partir d'un train peut rencontrer.  Nous allons créer un backend qui traite la demande de manière incorrecte lors des trois premières tentatives pour y accéder, renvoyant uniquement les données de la quatrième tentative. <br>  Habituellement, en utilisant Angular, nous créons un service, connectons le <code>HttpClient</code> et l'utilisons pour obtenir des données du backend. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      catchError((</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      })    );  } }</span></span></code> </pre> <br>  Il n'y a rien de spécial ici.  Nous <code>HttpClient</code> module Angular <code>HttpClient</code> et <code>HttpClient</code> une simple requête GET.  Si la requête retourne une erreur, nous exécutons du code pour la traiter et renvoyons un <code>Observable</code> vide (objet observable) afin d'informer de ce qui a initié la requête.  Ce code, pour ainsi dire, dit: "Il y avait une erreur, mais tout est en ordre, je peux le gérer." <br><br>  La plupart des applications effectuent les requêtes HTTP de cette façon.  Dans le code ci-dessus, la demande n'est exécutée qu'une seule fois.  Après cela, il retourne les données reçues du serveur ou échoue. <br><br>  Comment répéter la demande si le noeud final <code>/greet</code> pas disponible ou renvoie une erreur?  Peut-être existe-t-il une instruction RxJS appropriée?  Bien sûr que ça existe.  RxJS a des opérateurs pour tout. <br><br>  La première chose qui peut vous venir à l'esprit dans cette situation est l' <code>retry</code> .  Regardons sa définition: «Renvoie un Observable qui joue l'Observable original sauf <code>error</code> .  Si l'observable d'origine appelle l' <code>error</code> , cette méthode, au lieu de propager l'erreur, se réabonnera à l'observable d'origine. <br><br>  Le nombre maximal de réabonnements est limité au <code>count</code> (il s'agit du paramètre numérique transmis à la méthode). " <br><br>  La <code>retry</code> très similaire à ce dont nous avons besoin.  Alors, intégrons-le dans notre chaîne. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Injectable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {HttpClient} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/common/http'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {EMPTY, Observable} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {catchError, retry, shareReplay} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; @Injectable() <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GreetingService</span></span></span><span class="hljs-class"> </span></span>{  private GREET_ENDPOINT = <span class="hljs-string"><span class="hljs-string">'http://localhost:3000'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private httpClient: HttpClient) {  }  greet(): Observable&lt;string&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">`</span></span></span><span class="hljs-subst"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">${</span></span></span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">/greet`</span></span></span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pipe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">      retry(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span></span><span class="hljs-function">),      </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">catchError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> {        <span class="hljs-comment"><span class="hljs-comment">//           return EMPTY;      }),      shareReplay()    );  } }</span></span></code> </pre> <br>  Nous avons utilisé avec succès l'opérateur de nouvelle <code>retry</code> .  Voyons comment cela a affecté le comportement de la requête HTTP qui est exécutée dans l'application expérimentale.  <a href="">Voici</a> un grand fichier GIF qui montre l'écran de cette application et l'onglet Réseau des outils de développement du navigateur.  Vous trouverez plusieurs autres démonstrations de ce type ici. <br><br>  Notre application est extrêmement simple.  Il fait simplement une requête HTTP lorsque le bouton <code>PING THE SERVER</code> est cliqué. <br><br>  Comme déjà mentionné, le backend renvoie une erreur lors de l'exécution des trois premières tentatives pour lui exécuter une requête, et lorsqu'une quatrième requête lui parvient, il renvoie une réponse normale. <br><br>  Dans l'onglet Outil du développeur réseau, vous pouvez voir que l' <code>retry</code> résout la tâche qui lui est affectée et répète l'exécution de la demande ayant échoué trois fois.  La dernière tentative a réussi, l'application reçoit une réponse, un message correspondant apparaît sur la page. <br><br>  Tout cela est très bien.  Maintenant, l'application peut répéter les demandes ayant échoué. <br><br>  Cependant, cet exemple peut encore être amélioré.  Veuillez noter que les requêtes désormais répétées sont exécutées immédiatement après l'exécution des requêtes infructueuses.  Ce comportement du système n'apportera pas beaucoup d'avantages dans notre situation - lorsque le train pénètre dans le tunnel et que la connexion Internet est perdue pendant un certain temps. <br><br><h2>  <font color="#3AC1EF">Nouvelle tentative retardée des demandes ayant échoué</font> </h2><br>  Le train qui est entré dans le tunnel ne le quitte pas instantanément.  Il y passe du temps.  Par conséquent, nous devons «étirer» la période pendant laquelle nous effectuons des requêtes répétées au serveur.  Vous pouvez le faire en différant les tentatives. <br><br>  Pour ce faire, nous devons mieux contrôler le processus d'exécution des demandes répétées.  Nous devons être en mesure de prendre des décisions sur le moment exact de répéter les demandes.  Cela signifie que les capacités de l'opérateur de nouvelle <code>retry</code> ne nous suffisent plus.  Par conséquent, nous nous tournons à nouveau vers la documentation sur RxJS. <br><br>  La documentation contient une description de l' <code>retryWhen</code> , qui semble nous convenir.  Dans la documentation, il est décrit comme suit: «Renvoie un observable qui lit l'observable d'origine à l'exception de l' <code>error</code> .  Si l' <code>error</code> Observable d'origine appelle, alors cette méthode lancera Throwable, qui a provoqué l'erreur, l'Observable retourné par <code>notifier</code> .  Si cet Observable appelle <code>complete</code> ou <code>error</code> , cette méthode appellera <code>complete</code> ou <code>error</code> sur l'abonnement enfant.  Sinon, cette méthode se réabonnera à l'Observable d'origine. " <br><br>  Oui, la définition n'est pas simple.  Décrivons la même chose dans un langage plus accessible. <br><br>  L' <code>retryWhen</code> accepte un rappel qui renvoie un Observable.  L'observable renvoyé décide du <code>retryWhen</code> opérateur <code>retryWhen</code> fonction de certaines règles.  À savoir, <code>retryWhen</code> comment <code>retryWhen</code> opérateur <code>retryWhen</code> : <br><br><ul><li>  Il cesse de fonctionner et génère une erreur si l'Observable renvoyé renvoie une erreur. </li><li>  Il se ferme si l'observable retourné signale l'achèvement. </li><li>  Dans d'autres cas, lorsque l'observable revient avec succès, il répète l'exécution de l'observable d'origine </li></ul><br>  Un rappel n'est appelé que lorsque l'Observable d'origine renvoie une erreur pour la première fois. <br><br>  Nous pouvons maintenant utiliser ces connaissances pour créer un mécanisme de nouvelle tentative différée pour une demande ayant échoué à l'aide de l'instruction <code>retryWhen</code> . <br><br><pre> <code class="plaintext hljs">retryWhen((errors: Observable&lt;any&gt;) =&gt; errors.pipe(    delay(delayMs),    mergeMap(error =&gt; retries-- &gt; 0 ? of(error) : throwError(getErrorMessage(maxEntry))    )) )</code> </pre> <br>  Si l'Observable d'origine, qui est notre requête HTTP, renvoie une erreur, alors l'instruction <code>retryWhen</code> est <code>retryWhen</code> .  Dans le rappel, nous avons accès à l'erreur qui a provoqué l'échec.  Nous reportons les <code>errors</code> , réduisons le nombre de nouvelles tentatives et renvoyons un nouvel observable qui génère une erreur. <br><br>  En fonction des règles de l' <code>retryWhen</code> , cet observable, car il <code>retryWhen</code> , <code>retryWhen</code> demande.  Si la répétition échoue plusieurs fois et que la valeur de la variable <code>retries</code> diminue à 0, nous terminons la tâche avec une erreur qui s'est produite lors de l'exécution de la demande. <br><br>  Super!  Apparemment, nous pouvons prendre le code ci-dessus et remplacer l'opérateur de nouvelle <code>retry</code> dans notre chaîne par lui.  Mais ici, nous ralentissons un peu. <br><br>  Comment <code>retries</code> les <code>retries</code> variables?  Cette variable contient l'état actuel du système de nouvelle tentative de demande ayant échoué.  Où est-elle annoncée?  Quand la condition est-elle réinitialisée?  L'État doit être géré à l'intérieur du flux, pas à l'extérieur. <br><br><h3>  <font color="#3AC1EF">▍Créez votre propre instruction delayRetry</font> </h3><br>  Nous pouvons résoudre le problème de la gestion des états et améliorer la lisibilité du code en écrivant le code ci-dessus en tant qu'opérateur RxJS distinct. <br><br>  Il existe différentes façons de créer vos propres opérateurs RxJS.  La méthode à utiliser dépend de la structure de l'opérateur concerné. <br><br>  Notre opérateur est basé sur les opérateurs RxJS existants.  En conséquence, nous pouvons utiliser le moyen le plus simple pour créer nos propres opérateurs.  Dans notre cas, l'opérateur RxJs est juste une fonction avec la signature suivante: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt;</code> </pre> <br>  Cette déclaration prend l'Observable d'origine et renvoie un autre Observable. <br><br>  Étant donné que notre opérateur permet à l'utilisateur de spécifier la fréquence à laquelle les demandes répétées doivent être exécutées et le nombre de fois où elles doivent être exécutées, nous devons encapsuler la déclaration de fonction ci-dessus dans une fonction d'usine, qui prend <code>delayMs</code> (délai entre les <code>maxRetry</code> ) et <code>maxRetry</code> ( nombre maximum de répétitions). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> customOperator = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;A&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> Observable&lt;B&gt; }</code> </pre> <br>  Si vous souhaitez créer un opérateur qui n'est pas basé sur des opérateurs existants, vous devez faire attention à la gestion des erreurs et des abonnements.  De plus, vous devrez étendre la classe <code>Observable</code> et implémenter la fonction <code>lift</code> . <br><br>  Si vous êtes intéressé, jetez un œil <a href="">ici</a> . <br><br>  Donc, sur la base des extraits de code ci-dessus, écrivons notre propre opérateur RxJs. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delayedRetry</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        delay(delayMs),        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error) : throwError(getErrorMessage(maxRetry))        ))      )    ); }</code> </pre> <br>  Super.  Nous pouvons maintenant importer cet opérateur dans le code client.  Nous l'utiliserons lors de l'exécution d'une requête HTTP. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient.get&lt;string&gt;(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.GREET_ENDPOINT}</span></span></span><span class="hljs-string">/greet`</span></span>).pipe(        delayedRetry(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>),        catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error);            <span class="hljs-comment"><span class="hljs-comment">//               return EMPTY;        }),        shareReplay()    );</span></span></code> </pre> <br>  Nous avons placé l'opérateur <code>delayedRetry</code> dans la chaîne et passé les paramètres 1000 et 3. Le premier paramètre définit le délai en millisecondes entre les tentatives de demandes répétées.  Le deuxième paramètre détermine le nombre maximal de demandes répétées. <br><br>  Redémarrez l'application et <a href="">regardez</a> comment fonctionne le nouvel opérateur. <br><br>  Après avoir analysé le comportement du programme à l'aide des outils du développeur de navigateur, nous pouvons voir que l'exécution de tentatives répétées pour exécuter la demande est retardée d'une seconde.  Après avoir reçu la bonne réponse à la demande, un message correspondant apparaîtra dans la fenêtre de l'application. <br><br><h2>  <font color="#3AC1EF">Répétition de demande exponentielle</font> </h2><br>  Développons l'idée d'une nouvelle tentative différée des demandes ayant échoué.  Auparavant, nous retardions toujours l'exécution de chacune des demandes répétées en même temps. <br><br>  Ici, nous parlons de la façon d'augmenter le délai après chaque tentative.  La première tentative de nouvelle tentative est effectuée après une seconde, la deuxième après deux secondes, la troisième après trois. <br><br>  Créez une nouvelle instruction, <code>retryWithBackoff</code> , qui implémente ce comportement. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Observable, <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>, throwError} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {delay, mergeMap, retryWhen} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'rxjs/operators'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getErrorMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">maxRetry: number</span></span></span><span class="hljs-function">) =&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">`Tried to load Resource over XHR for </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${maxRetry}</span></span></span><span class="hljs-string"> times without success. Giving up.`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_MAX_RETRIES = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> DEFAULT_BACKOFF = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">retryWithBackoff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">delayMs: number, maxRetry = DEFAULT_MAX_RETRIES, backoffMs = DEFAULT_BACKOFF</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> retries = maxRetry;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span>    src.pipe(      retryWhen(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors: Observable&lt;any&gt;</span></span></span><span class="hljs-function">) =&gt;</span></span> errors.pipe(        mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retries-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {              <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> backoffTime = delayMs + (maxRetry - retries) * backoffMs;              <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>(error).pipe(delay(backoffTime));            }            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> throwError(getErrorMessage(maxRetry));          }        )))); }</code> </pre> <br>  Si vous utilisez cet opérateur dans l'application et le testez, vous pouvez <a href="">voir</a> comment le délai d'exécution de la demande répétée augmente après chaque nouvelle tentative. <br><br>  Après chaque tentative, nous attendons un certain temps, répétons la demande et augmentons le temps d'attente.  Ici, comme d'habitude, une fois que le serveur a renvoyé la bonne réponse à la demande, nous affichons un message dans la fenêtre de l'application. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  La répétition des requêtes HTTP ayant échoué rend les applications plus stables.  Ceci est particulièrement important lors de l'exécution de requêtes très importantes, sans les données obtenues grâce auxquelles l'application ne peut pas fonctionner normalement.  Par exemple, il peut s'agir de données de configuration contenant les adresses des serveurs avec lesquels l'application doit interagir. <br><br>  Dans la plupart des scénarios, l'instruction de nouvelle tentative RxJs <code>retry</code> pas suffisante pour fournir un système de nouvelle tentative fiable pour les demandes ayant échoué.  L' <code>retryWhen</code> donne au développeur un niveau de contrôle plus élevé sur les demandes répétées.  Il vous permet de configurer l'intervalle des demandes répétées.  En raison des capacités de cet opérateur, il est possible de mettre en œuvre un schéma de répétition retardée ou des répétitions retardées exponentiellement. <br><br>  Lors de l'implémentation de modèles de comportement pouvant être réutilisés dans les chaînes RxJS, il est recommandé de les formater en tant que nouveaux opérateurs.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://github.com/kreuzerk/">Voici le</a> référentiel à partir duquel le code a été utilisé dans cet article. <br><br>  <b>Chers lecteurs!</b>  Comment résolvez-vous le problème de la nouvelle tentative de requêtes HTTP ayant échoué? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459302/">https://habr.com/ru/post/fr459302/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459292/index.html">Automatisation des tests d'applications mobiles: comparaison d'outils</a></li>
<li><a href="../fr459294/index.html">Quoi de plus important: connaître un langage de programmation ou être capable de résoudre un problème métier?</a></li>
<li><a href="../fr459296/index.html">Prix ​​JavaScript 2019</a></li>
<li><a href="../fr459298/index.html">Angulaire: statut en 2019</a></li>
<li><a href="../fr459300/index.html">Quasar 1.0: un nouvel outil utile pour les développeurs de Vue et pas seulement pour eux</a></li>
<li><a href="../fr459304/index.html">Contournement angulaire de l'écueil et gain de temps</a></li>
<li><a href="../fr459306/index.html">Rendu de serveur dans un environnement sans serveur</a></li>
<li><a href="../fr459308/index.html">Le référencement ne fonctionne pas en 2019?</a></li>
<li><a href="../fr459310/index.html">Outils d'automatisation de test ou testeur de stéroïdes mobile</a></li>
<li><a href="../fr459312/index.html">Cher Agile, j'en ai marre de faire semblant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>