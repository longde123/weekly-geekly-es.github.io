<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçª üê≥ üßìüèø Ein bisschen √ºber lexikalische Analyse ü§¨ üìö ü§∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es war einmal, als der Himmel blau war, das Gras gr√ºner und Dinosaurier durchstreiften die Erde ... Nein, vergessen Sie Dinosaurier. Nun, im Allgemein...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein bisschen √ºber lexikalische Analyse</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435102/"><img src="https://habrastorage.org/webt/93/ob/36/93ob36rkepacsoqhbmlu4bj3g0q.png"><br><br>  Es war einmal, als der Himmel blau war, das Gras gr√ºner und Dinosaurier durchstreiften die Erde ... Nein, vergessen Sie Dinosaurier.  Nun, im Allgemeinen kam mir einmal die Idee, von der Standard-Webprogrammierung abzulenken und etwas Verr√ºckteres zu tun.  K√∂nnte nat√ºrlich alles sein, aber die Wahl fiel darauf, einen eigenen Dolmetscher zu schreiben.  Was soll ich sagen ... <i>Schreiben Sie niemals Ihre eigenen Programmiersprachen</i> .  Aber ich habe einige Erfahrungen daraus gemacht und beschlossen, sie zu teilen.  Beginnen wir mit dem Fundament - dem Lexer. <br><a name="habracut"></a><br><h2>  Vorwort </h2><br>  Bevor Sie verstehen, was f√ºr ein Tier "Lexer" ist, sollten Sie herausfinden, woraus YaPs bestehen. <br><br>  In der modernen Welt ist jeder Compiler / Interpreter / Transpiler / etwas anderes (ich nenne es einfach weiter "Compiler", ohne Unterscheidung zwischen Typen) in zwei Teile unterteilt.  In der Terminologie der intelligenten Onkel werden solche Teile als "Frontend" und "Backend" bezeichnet.  Nein, das ist √ºberhaupt nicht das, was wir bei der Arbeit mit dem Web genannt haben, und die Vorderseite ist nicht in JS mit HTML geschrieben.  Obwohl ... Okay. <br><br>  Die erste Aufgabe des Frontends besteht darin, den <b>Text</b> in einen <b>AST</b> (abstrakten Syntaxbaum) umzuwandeln und dabei die Syntax (und manchmal auch die Semantik) zu √ºberpr√ºfen.  Die Aufgabe des zweiten Backends ist es, alles zum Laufen zu bringen.  Wenn der Code im Interpreter zusammengestellt ist, erstellt der AST einen Befehlssatz f√ºr den virtuellen Prozessor (virtuelle Maschine), wenn der Compiler, dann den Befehlssatz f√ºr den realen Prozessor.  Im Leben ist alles ziemlich komplizierter und kann m√∂glicherweise nicht so implementiert werden.  Zum Beispiel ist im Fall des GCC-Compilers alles durcheinander, aber Clang ist bereits kanonischer, LLVM ist ein typischer Vertreter des ‚ÄûBackends‚Äú f√ºr Compiler. <br><br><img src="https://habrastorage.org/webt/un/ai/wa/unaiwa1kmx5jci6uxnhngor5ozs.png"><br><br>  Jetzt lernen wir ein St√ºck namens Frontend kennen. <br><br><h2>  Lexikalische Analyse </h2><br>  Die Aufgabe des Lexers und die Phase der lexikalischen Analyse besteht darin, viele, viele Buchstaben am Eingang zu erhalten und sie in einige Kategorien zu gruppieren - ‚ÄûToken‚Äú.  Daher wird die lexikalische Analyse auch als "Tokenisierung" bezeichnet.  Dies ist die allererste Stufe der Textverarbeitung, die jeder vorhandene Compiler erstellt. <br><br>  So etwas wie das: <br><br><pre><code class="php hljs">$tokens = [<span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>]; var_dump(lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>, $tokens)); <span class="hljs-comment"><span class="hljs-comment">// array(4) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(1) "}" // }</span></span></code> </pre> <br>  √úbrigens haben wir hier bereits eine Reihe von Werkzeugen geschrieben, um das Leben leichter zu machen.  Die gleichen <i>Preg-</i> Funktionen, die wir zum Parsen von Text verwendet haben, sind <i>f√ºr</i> diese Aufgabe durchaus <i>geeignet</i> .  Es gibt jedoch bequemere Werkzeuge f√ºr diese Angelegenheit: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phlexy</a> , geschrieben von Nikita Popov. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hoa</a> ist ein Toolkit bestehend aus Lexer + Parser + Grammatik. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Port Yacc</a> , geschrieben von Anthony Ferrara, das ebenfalls ein umfassendes Toolkit ist und auf dem der bekannte Popov- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PHP-Parser</a> geschrieben ist, ist in Tools anwendbar, die Code-Analyse verwenden. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Railt Lexer</a> meine Implementierung f√ºr PHP 7.1+ </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parle</a> ist eine Erweiterung f√ºr PHP, die eine begrenzte Anzahl von PCRE-Ausdr√ºcken zul√§sst (kein Lookahead und einige andere Syntaxkonstrukte). </li><li>  Und schlie√ülich die Standard-PHP-Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">token_get_all</a> , die direkt f√ºr die lexikalische Analyse von PHP vorgesehen ist. </li></ul><br>  Nun, es ist klar, dass es viele Dinge gibt, die Text durch Token teilen k√∂nnen. Vielleicht habe ich sogar etwas vergessen, wie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Doctrine</a> Lexer.  Aber wie geht es weiter? <br><br><h2>  Arten von Lexern </h2><br>  Und wie immer ist nicht alles so einfach, wie es schien.  Es gibt mindestens zwei verschiedene Kategorien von Lexern.  Es gibt die √ºbliche, ziemlich triviale Option, nach der Sie die Regeln verschieben, und die bereits alles in Token unterteilt.  Die Konfiguration unterscheidet sich nicht wesentlich von dem oben gezeigten Beispiel.  Es gibt jedoch eine andere Option namens <b>Multistate</b> .  Solche Lexer sind etwas schwieriger zu verstehen, deshalb m√∂chte ich etwas mehr √ºber sie sprechen. <br><br>  Die Aufgabe eines Multistate-Lexers besteht darin, je nach vorherigem Status verschiedene Token anzuzeigen.  Nun, zum Beispiel werden in PHP solche "√úbergangszust√§nde" unter Verwendung der &lt;? Php +?&gt; -Tags, innerhalb von Zeilen, Kommentaren und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HEREDOC</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NOWDOC-</a> Konstrukten gebildet. <br><br>  Erinnern Sie sich an das vorherige Beispiel mit 4 Token oben?  Lassen Sie es uns ein wenig modifizieren, um zu verstehen, was diese Zust√§nde sind: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// class Example {} }</span></span></code> </pre><br>  In diesem Fall erhalten wir den folgenden Satz von Token, wenn wir den einfachsten Lexer ohne die umfassenden Funktionen von PCRE haben: <br><br><pre> <code class="php hljs">var_dump(lex(...)); <span class="hljs-comment"><span class="hljs-comment">// array(9) { // [0] =&gt; string(5) "class" // [1] =&gt; string(7) "Example" // [2] =&gt; string(1) "{" // [3] =&gt; string(2) "//" // [4] =&gt; string(5) "class" // [5] =&gt; string(7) "Example" // [6] =&gt; string(1) "{" // [7] =&gt; string(1) "}" // [8] =&gt; string(1) "}" //}</span></span></code> </pre><br>  Wie Sie sehen k√∂nnen, haben wir einen v√∂llig banalen Pfosten zu den Elementen 3-5 erhalten: Der Kommentar wurde ziemlich unerwartet empfangen und in Token unterteilt, obwohl er als ganzes St√ºck h√§tte betrachtet werden sollen. <br><br>  Nat√ºrlich k√∂nnte mit der PCRE-Funktion ein solches Token mit Hilfe einer einfachen Regelm√§√üigkeit " <i>// [^ \ n] * \ n</i> " herausgerissen werden, aber wenn nicht?  Oder wollen wir es mit unseren H√§nden zertr√ºmmern?  Kurz gesagt, im Fall des mehrstufigen Lexers k√∂nnen wir sagen, dass sich alle Token in Gruppe <b>Nr. 1 befinden sollten</b> , sobald das Token " <i>//</i> " gefunden wird, sollte ein √úbergang zu Gruppe <b>Nr</b> . <b>2</b> erfolgen.  Und innerhalb der zweiten Gruppe der umgekehrte √úbergang, wenn das Token " <i>\ n</i> " gefunden wird - der √úbergang zur√ºck zur ersten Gruppe. <br><br>  So etwas wie das: <br><br><pre> <code class="php hljs">$tokens = [ <span class="hljs-string"><span class="hljs-string">'group-1'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'//'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'group-2'</span></span> <span class="hljs-comment"><span class="hljs-comment">//      2 ], 'group-2' =&gt; [ "\n" =&gt; 'group-1', //    1    '.*' ] ];</span></span></code> </pre><br>  Ich denke, jetzt wird klarer, wie HEREDOC analysiert wird, denn trotz aller M√∂glichkeiten von PCRE ist das Schreiben eines Regulars f√ºr diesen Fall √§u√üerst problematisch, da diese HEREDOC-Syntax die variable Interpolation unterst√ºtzt.  Versuchen Sie einfach, so etwas mit der <i>integrierten</i> Funktion <i>token_get_all</i> zu analysieren (Hinweis&gt; 12 Token): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $example = <span class="hljs-number"><span class="hljs-number">42</span></span>; $a = &lt;&lt;&lt;EOL Your answer is $example !!! EOL; var_dump(token_get_all(file_get_contents(<span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>)));</code> </pre><br>  Nun, es scheint, wir sind bereit zu √ºben. <br><br><h2>  √úbe </h2><br>  Erinnern wir uns, was wir in PHP f√ºr solche Dinge haben?  Na klar, preg_match!  Okay, komm runter.  Der preg_match-basierte Algorithmus ist in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hoa</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in dieser Implementierung von Phelxy implementiert</a> .  Ihre Aufgabe ist ganz einfach: <br><br><ol><li>  Wir haben den Quelltext und eine Reihe von Stammg√§sten zur Hand. </li><li>  Wir passen zusammen, bis etwas Passendes gefunden ist. </li><li>  Sobald Sie ein St√ºck gefunden haben, schneiden Sie es aus dem Text aus und passen Sie es weiter an. </li></ol><br>  In Codeform sieht es ungef√§hr so ‚Äã‚Äãaus: <br><br><div class="spoiler">  <b class="spoiler_title">Codeblatt</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[$name] = \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G%s/isSum'</span></span>, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ [$offset, $length] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, \strlen($sources)]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($offset &lt; $length) { [$name, $token] = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;next($sources, $offset); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $token; $offset += \strlen($token); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> int $offset * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string,string&gt; * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> RuntimeException */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources, int $offset)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $pcre) { \preg_match($pcre, $sources, $matches, <span class="hljs-number"><span class="hljs-number">0</span></span>, $offset); $token = \reset($matches); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\count($matches) &amp;&amp; \strpos($sources, $token, $offset) === $offset) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [$name, $token]; } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \RuntimeException(<span class="hljs-string"><span class="hljs-string">'Unrecognized token at offset '</span></span> . $offset); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Verwenden eines Codeblatts</b> <div class="spoiler_text"><pre> <code class="php hljs">$lexer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleLexer([ <span class="hljs-string"><span class="hljs-string">'T_CLASS'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'class'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_CONST'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\w+'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_OPEN'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'{'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_BRACE_CLOSE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'}'</span></span>, <span class="hljs-string"><span class="hljs-string">'T_WHITESPACE'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\s+'</span></span>, ]); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'VALUE'</span></span>, <span class="hljs-string"><span class="hljs-string">'NAME'</span></span>) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($lexer-&gt;lex(<span class="hljs-string"><span class="hljs-string">'class Example {}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $token) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'| %-10s | %-20s |'</span></span>, <span class="hljs-string"><span class="hljs-string">'"'</span></span> . \trim($token, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) . <span class="hljs-string"><span class="hljs-string">'"'</span></span>, $name) . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; }</code> </pre><br></div></div><br>  Dieser Ansatz ist ziemlich trivial und erm√∂glicht ein paar Tastendr√ºcke, um den Lexer im Bereich der next () -Methode zu modifizieren, einen √úbergang zwischen Zust√§nden hinzuzuf√ºgen und dieses St√ºck Masturbation in einen primitiven mehrstufigen Lexer zu verwandeln.  <i>F√ºgen Sie im Bereich $ this-&gt; tokens</i> einfach so etwas wie <i>$ this-&gt; tokens [$ this-&gt; state] hinzu</i> . <br><br>  Zus√§tzlich zum Primitivismus selbst gibt es jedoch einen weiteren Nachteil, der nicht fatal ist, wie sich herausstellen k√∂nnte, aber dennoch ... Eine solche Implementierung ist unglaublich langsam.  Auf i7 7600k, dessen Besitzer ich zuf√§llig war - ein √§hnlicher Algorithmus verarbeitet ungef√§hr 400 Token pro Sekunde und mit einer Zunahme ihrer Variationen (dh der Definitionen, die wir an den Konstruktor weitergegeben haben) - kann er sich auf die Geschwindigkeit des Pr√§sidentenwechsels in Russland verlangsamen ... √§hm Entschuldigung.  Ich wollte nat√ºrlich sagen, dass es <b>sehr langsam</b> funktionieren <b>wird</b> . <br><br>  Okay, was k√∂nnen wir tun?  F√ºr den Anfang k√∂nnen Sie verstehen, was falsch l√§uft.  Tatsache ist, dass jedes Mal, wenn wir <b>preg_match</b> in der Wildnis der Sprache aufrufen, ein Compiler mit seiner JIT namens PCRE aufsteigt (und mit PHP 7.3 ist PCRE2 bereits vorhanden).  Jedes Mal analysiert er die Stammg√§ste selbst und sammelt einen Parser f√ºr sie, mit dem wir den Text analysieren, um Token zu erstellen.  Es klingt etwas seltsam und tautologisch.  Kurz gesagt, jedes Token erfordert eine Kompilierung von 1 bis N Stammg√§sten, wobei N die Anzahl der Definitionen dieser Token ist.  Gleichzeitig ist anzumerken, dass selbst das angewendete " <i>S</i> " -Flag und die Optimierung mit " <i>\ G</i> " im Konstruktor, in dem regul√§re Ausdr√ºcke f√ºr Token generiert werden, nicht helfen. <br><br>  Es gibt nur einen Ausweg aus dieser Situation - Sie m√ºssen den gesamten Text in einem Durchgang analysieren, d. H.  durch Ausf√ºhren nur einer <b>preg_match-</b> Funktion.  Es bleiben zwei Probleme zu l√∂sen: <br><br><ol><li>  Wie kann angezeigt werden, dass das Ergebnis des regul√§ren Ausdrucks N1 dem Token N2 entspricht?  Das hei√üt,  wie man angibt, dass " <i>\ w +</i> " zum Beispiel <i>T_CONST ist</i> . </li><li>  So bestimmen Sie die Reihenfolge der Token als Ergebnis.  Wie Sie wissen, enth√§lt das Ergebnis von <b>preg_match</b> oder <b>preg_match_all</b> alles durcheinander.  Und selbst mit Hilfe von Flaggen, die als viertes Argument √ºbergeben wurden, wird sich die Situation nicht √§ndern. </li></ol><br>  Hier k√∂nnen Sie innehalten und ein wenig nachdenken.  Gut oder nicht. <br><br>  Die L√∂sung f√ºr das erste Problem hei√üt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PCRE-Gruppen</a> , die auch als "Submasken" bezeichnet werden.  Mit den Regeln: " <i>(? &lt;T_WHITESPACE&gt; \ s + | &lt;T_WORD&gt; \ w + | ...)</i> " k√∂nnen Sie alle Token in einem Durchgang erhalten, indem Sie sie mit ihren Namen vergleichen.  Als Ergebnis der √úbereinstimmung wird ein assoziatives Array gebildet, das aus den Paaren " <i>[TOKEN_NAME =&gt; TOKEN_VALUE]</i> " besteht. <br><br>  Der zweite ist etwas komplizierter.  Hier k√∂nnen Sie jedoch einen taktischen Trick anwenden und die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">preg_replace_callback</a> verwenden.  Seine Besonderheit ist, dass die als zweites Argument √ºbergebene Anonymit√§t f√ºr jedes Token vom ersten bis zum letzten streng nacheinander aufgerufen wird. <br><br>  Um nicht zu schmachten - die Implementierung ist wie folgt: <br><br><div class="spoiler">  <b class="spoiler_title">Noch eine Codeklappe</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PregReplaceLexer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array&lt;string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $tokens = []; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array&lt;string&gt; $tokens */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $tokens)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($tokens <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $definition) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens[] = \sprintf(<span class="hljs-string"><span class="hljs-string">'(?&lt;%s&gt;%s)'</span></span>, $name, $definition); } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string $sources * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> iterable&amp;\Traversable&lt;string,string&gt; */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $sources)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterable</span></span></span><span class="hljs-function"> </span></span>{ $result = []; \preg_replace_callback(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;compilePcre(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $matches)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (\array_reverse($matches) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (\is_string($name) &amp;&amp; $value !== <span class="hljs-string"><span class="hljs-string">''</span></span>) { $result[] = [$name, $value]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }, $sources); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [$name, $value]) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $name =&gt; $value; } } <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compilePcre</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \sprintf(<span class="hljs-string"><span class="hljs-string">'/\G(?:%s)/isSum'</span></span>, \implode(<span class="hljs-string"><span class="hljs-string">'|'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;tokens)); } }</code> </pre><br></div></div><br>  Und seine Verwendung unterscheidet sich nicht von der vorherigen Version.  Gleichzeitig erh√∂ht sich die Arbeitsgeschwindigkeit von <b>400</b> auf <b>57.000</b> Token pro Sekunde.  Diesen Algorithmus habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in meiner Implementierung</a> angewendet und das Umschreiben des Hoa-Quellcodes √ºbernommen.  Wenn Sie Parle verwenden, k√∂nnen Sie √ºbrigens bis zu <b>600.000</b> Token pro Sekunde dr√ºcken.  Und das Gesamtbild sieht ungef√§hr so ‚Äã‚Äãaus (wenn XDebug in PHP 7.1 aktiviert ist, sind die Zahlen niedriger, aber das Verh√§ltnis kann grob dargestellt werden). <br><br> <a href=""><img src="https://habrastorage.org/webt/rr/yw/qr/rrywqr04hb7lt5zdhdpmu8ppdc8.png"></a> <br><br><ul><li>  Gelb ist die native Erweiterung von Parle. </li><li>  Blau - Implementierung durch <i>preg_replace_callback</i> mit vormontiertem Regular. </li><li>  Rot - <i>egal</i> , aber mit der generierten <i>Regelm√§√üigkeit</i> w√§hrend des Aufrufs von <i>preg_replace_callback</i> . </li><li>  Gr√ºn - Implementierung durch <i>preg_match</i> . </li></ul><br><h2>  Warum? </h2><br>  Nun, das alles ist nat√ºrlich wunderbar, aber die Ungeduldigen wollen unbedingt die Frage stellen: "Wer braucht das √ºberhaupt?"  In der abstrakten Welt von PHP, in der das Prinzip "fig-fig-and-site-ready" dominiert - solche Bibliotheken werden nicht ben√∂tigt, werden wir ehrlich sein.  Wenn wir jedoch √ºber das √ñkosystem als Ganzes sprechen, k√∂nnen wir uns an die ber√ºchtigten Bibliotheken wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Symfony / Yaml</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Doctrine</a> erinnern.  Anmerkungen in Symfony sind dieselbe Untersprache in PHP und erfordern eine separate lexikalische und syntaktische Analyse.  Dar√ºber hinaus gibt es in PHP noch etwas weniger bekannte CoffeeScript-, Less- und Scss / Sass-Transpiler.  Nun, oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yay</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorverarbeitung</a> basierend darauf.  Ich werde nicht einmal Code-Analyse-Tools wie phpmd oder phpcs erw√§hnen.  Und Dokumentationsgeneratoren wie phpDocumentnor oder Sami sind ziemlich trivial.  Jedes dieser Projekte verwendet bis zu dem einen oder anderen Grad eine lexikalische Analyse in der ersten Phase des Parsens von Text / Code. <br><br>  Dies ist keine vollst√§ndige Liste der Projekte, und vielleicht hoffe ich, dass meine Geschichte Ihnen hilft, etwas Neues zu entdecken und es wieder aufzuf√ºllen. <br><br><h2>  Nachwort </h2><br>  Wenn sich jemand f√ºr das Thema Parser und Compiler interessiert, gibt es in der Zukunft einige interessante Berichte zu diesem Thema, insbesondere von den Jungs von JetBrains: <br><br><div class="spoiler">  <b class="spoiler_title">Video</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/zI1QmnRRBMA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  Trotzdem nat√ºrlich die meisten Auff√ºhrungen von Andrei Breslav ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">abreslav</a> ), die auf der Weite von YouTube zu finden sind - ich rate Ihnen, sie anzuschauen. <br><br>  Nun, f√ºr Fans von Belletristik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt es eine solche Ressource</a> , die f√ºr mich pers√∂nlich √§u√üerst n√ºtzlich war. <br><br>  Post post scriptum.  Wenn Sie irgendwo in der Weite dieses Epos versiegelt sind, k√∂nnen Sie den Autor sicher in jeder f√ºr Sie geeigneten Form informieren. <br><br>  Als Bonus m√∂chte ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Beispiel f√ºr einen einfachen PHP-Lexer geben</a> . Es scheint, dass es jetzt nicht so be√§ngstigend ist und jetzt sogar klar ist, was es tut, oder?  Obwohl wen ich t√§usche, bluten die Augen von den Stammg√§sten.  =) <br><br>  Vielen Dank! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435102/">https://habr.com/ru/post/de435102/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435088/index.html">Der chinesische Streaming-Riese Tencent Music geht an die B√∂rse - was bedeutet das und was sollten die Wettbewerber erwarten?</a></li>
<li><a href="../de435090/index.html">Die Hyundai Motor Group f√ºhrte das Konzept des drahtlosen Ladens und des autonomen Parkens ein</a></li>
<li><a href="../de435094/index.html">Gamepad von Sega Mega Drive und Raspberry Pi Part 2 (letzte Sechs-Tasten)</a></li>
<li><a href="../de435096/index.html">Die Wirkung von warmem R√∂hrenradio</a></li>
<li><a href="../de435098/index.html">ADB gegen Spy Cam & Mic</a></li>
<li><a href="../de435106/index.html">Noch einmal √ºber passport.js</a></li>
<li><a href="../de435108/index.html">Mit Prolog</a></li>
<li><a href="../de435112/index.html">Unternehmensinterview</a></li>
<li><a href="../de435114/index.html">Federdaten jpa</a></li>
<li><a href="../de435118/index.html">Save File Me - ein kostenloser Sicherungsdienst mit clientseitiger Verschl√ºsselung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>