<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎧 😈 🍆 19 ide untuk pengembang Node.js yang ingin tumbuh di atas diri mereka sendiri pada tahun 2019 🎨 🤐 👨‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penulis materi, terjemahan yang kami terbitkan, mengumpulkan 19 ide yang mungkin berguna bagi para pengembang Node.js yang ingin meningkatkan level pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>19 ide untuk pengembang Node.js yang ingin tumbuh di atas diri mereka sendiri pada tahun 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/434114/">  Penulis materi, terjemahan yang kami terbitkan, mengumpulkan 19 ide yang mungkin berguna bagi para pengembang Node.js yang ingin meningkatkan level profesional mereka pada tahun 2019.  Dunia JavaScript sangat besar, sehingga menguasai segala sesuatu yang akan dibahas di sini tidak realistis.  Tidak mungkin ada seseorang yang memiliki semua ini dengan sempurna.  Namun, sesuatu dalam ulasan ini mungkin berguna bagi Anda. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/3d/lf/aq/3dlfaqcq1uy5fvbz6mskzawwmf8.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">1. Pikirkan tentang mengetik.</font>  <font color="#3AC1EF">Perhatikan TypeScript</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terbukti</a> bahwa pemrograman dalam JavaScript, menggunakan pendekatan pengetikan yang digunakan di dalamnya, mengarah pada penurunan produktivitas tenaga kerja dan munculnya kesalahan.  Ini tidak berarti bahwa Anda harus berusaha untuk memastikan bahwa semua kode diketik dengan kuat.  Sebaliknya, kita berbicara tentang fakta bahwa akan lebih baik, ketika mengembangkan JavaScript, untuk memilih pendekatan tertentu untuk bekerja dengan tipe dan tetap menggunakannya.  Pendekatan semacam itu berbeda, antara lain, dengan tingkat pembatasan yang terkait dengan jenis data yang dikenakan pada kode.  Sebagai contoh, ini bisa menjadi sesuatu yang sangat sederhana, seperti mengatur cek menggunakan paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jsonschema</a> (atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">joi</a> ).  Jika Anda merasa bahwa Anda memerlukan kontrol tipe yang lebih ketat, Anda dapat mempertimbangkan menggunakan anotasi jenis dalam kode JS biasa (di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aliran</a> dari Facebook akan membantu Anda).  Dan jika Anda siap untuk menulis kode yang hampir seluruhnya diketik - perhatikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TypeScript</a> . <br><br>  Perlu dicatat bahwa pada tahun 2018 TypeScript mendapatkan popularitas yang serius, di samping itu, ada perasaan bahwa ada semua prasyarat untuk itu untuk memantapkan dirinya dengan kuat di Node.js.  Jika Anda serius melihat TypeScript, Anda harus bertanya pada diri sendiri apakah Anda hanya berpikir tentang mengetik, atau tentang fitur lain dari bahasa tersebut.  Intinya di sini adalah bahwa bekerja dengan sesuatu seperti antarmuka dan kelas abstrak akan berarti bahwa Anda akan menemukan diri Anda dalam lingkungan di mana, terutama berpikir tentang mengetik, Anda hampir tidak akan masuk ke dalamnya. <br><br><h2>  <font color="#3AC1EF">2. Perhatikan kemampuan linter</font> </h2><br>  Linter hari ini diterima begitu saja.  Setelah pengaturan sederhana, Anda memiliki alat yang siap membantu Anda menemukan kesalahan dalam kode.  Lewat sudah hari-hari ketika kode linting terutama berarti mengendalikan desainnya (sesuatu seperti ada atau tidak adanya titik koma).  Sekarang linter dapat mengidentifikasi masalah serius - seperti kesalahan yang tidak ditangani dengan benar, janji-janji yang tidak pernah diselesaikan, dan masalah serupa lainnya yang secara sadar tidak akan dimasukkan ke dalam kode mereka.  Karena itu, jika Anda belum menggunakan linter, sekaranglah saatnya untuk melakukannya, tanpa melupakan konfigurasi yang bijak.  Di sini, misalnya, adalah plugin untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ESLint</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eslint-plugin-chai-expect</a> , yang dapat mendeteksi tes yang dikomposisikan secara keliru.  Berikut ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin eslint-plugin-janji</a> yang mendeteksi janji yang tidak terselesaikan (kode dengan janji seperti itu, tanpa alasan yang jelas, berhenti).  Menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin eslint-plugin-security,</a> dimungkinkan untuk menemukan ekspresi reguler yang tidak aman dalam kode yang dapat digunakan oleh penyerang untuk melakukan serangan DOS. <br><br><h2>  <font color="#3AC1EF">3. Memperdalam pengetahuan Anda tentang arsitektur proyek perangkat lunak dengan mengadopsi sesuatu dari dunia Java dan melupakan banyak hal dari dunia Ruby</font> </h2><br>  Ekosistem Node.js jarang mengangkat topik arsitektur dan desain sistem informasi.  Jadi, semua orang berbicara tentang layanan mikro, tetapi hanya sedikit yang berbicara tentang struktur internal mereka.  Akibatnya, sebagian besar aplikasi Node.js adalah contoh penerapan konsep MVC dan pola meragukan lainnya dari dunia Ruby.  Apa yang buruk tentang itu?  Template MVC, misalnya, dibuat untuk merampingkan pekerjaan dengan data, tetapi template ini tidak cocok untuk merancang bagian server aplikasi yang andal.  Bob Martin, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengatakan</a> bahwa MVC adalah mekanisme untuk mengirimkan data kepada pengguna, bukan arsitektur aplikasi.  Apakah mungkin untuk menggambarkan logika bisnis aplikasi layanan mikro, aturan operasinya, fitur akses data, interaksi dengan layanan microser lainnya hanya dengan menggunakan dua kelas - <code>Controller</code> dan <code>Model</code> ? <br>  Perlu dicatat bahwa saya benar-benar tidak ingin merekomendasikan penggunaan template Java / Spring di Node.js di sini (setelah semua, bukan kebetulan bahwa kami beralih ke Node.js untuk mengembangkan program server?).  Saya akan menyarankan Anda untuk meminjam hanya beberapa ide yang, di satu sisi, dapat memiliki efek menguntungkan pada arsitektur aplikasi, dan di sisi lain, tidak akan menyebabkan kompleksitas yang berlebihan. <br><br>  Berikut adalah beberapa pedoman bagi mereka yang peduli tentang arsitektur proyek Node.js: <br><br><ul><li>  Baca bagian pertama artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> di arsitektur aplikasi Node.js. </li><li>  Cobalah untuk tidak mencampur logika bisnis aplikasi dengan objek Express, baca tentang prinsip-prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Desain Berbasis Domain</a> (DDD) dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">arsitektur heksagonal</a> . </li><li>  Penggunaan pola Rekaman Aktif, yang sangat populer di kalangan pengembang yang menggunakan Mongoose dan Sequelize, dengan mudah mengarah pada tampilan objek yang kelebihan beban yang sulit untuk diuji.  Pertimbangkan untuk menggunakan pola <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Data Mapper</a> alih-alih pola Rekaman Aktif. </li><li>  Lihatlah kode untuk proyek template Node.js yang dibuat dengan baik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> , menampilkan arsitektur berkualitas yang mengimplementasikan prinsip-prinsip DDD. </li></ul><br><h2>  <font color="#3AC1EF">4. Pikirkan tentang bagaimana menggunakan async_hooks Node.js-API baru saat bekerja dengan kode asinkron</font> </h2><br>  Model eksekusi kode berulir tunggal yang digunakan dalam JavaScript memiliki satu kelemahan serius - operasi asinkron, misalnya, permintaan, kehilangan konteks.  Itu tidak disimpan selama siklus hidup permintaan, karena operasi asinkron terlibat dalam pelaksanaannya.  Kenapa ini buruk?  Misalnya, pengembang sering berusaha untuk memasukkan pengidentifikasi kueri unik dalam entri jurnal, yang, ketika menganalisis catatan tersebut, memungkinkan seseorang untuk mengidentifikasi orang-orang yang berhubungan dengan permintaan yang sama.  Hari ini, pada tahun 2018, ini tidak mudah.  Tahun depan, sesuatu yang baru menunggu kita, yaitu, kita berbicara tentang kait asinkron, API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">async_hooks</a> .  Ini bukan untuk mengatakan bahwa ini adalah kesempatan yang sama sekali baru, intinya adalah bahwa ia harus segera meninggalkan rezim eksperimental.  Sederhananya, kait asinkron memungkinkan pengembang untuk mengeksekusi kode asli pada titik-titik tertentu dalam siklus hidup operasi asinkron.  Dengan mengingat hal ini, Anda dapat mengoordinasikan tindakan yang dilakukan oleh kode asinkron dan mempertahankan konteks.  Fitur ini meletakkan dasar untuk mengembangkan paket yang akan membawa Node.js ke tingkat baru dalam melacak operasi asinkron dan bekerja dengan konteks. <br><br>  Sebagai contoh, paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cls-hooked</a> memungkinkan Anda untuk mengatur penggunaan variabel dan konteks sepanjang siklus hidup operasi asinkron.  Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jaeger-client</a> memungkinkan Anda untuk memvisualisasikan proses melewati permintaan melalui sistem, bahkan melalui microservices dan server (standar Javascript OpenTracing API 1.0 diterapkan di sini). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut adalah</a> bahan untuk mengetahui lebih lanjut tentang penggunaan async_hooks API. <br><br><h2>  <font color="#3AC1EF">5. Memahami teknologi "tanpa server" terbaru yang sudah cukup siap untuk proyek-proyek serius dan mampu membunuh Kubernetes</font> </h2><br>  Di sini kita menggunakan konsep FaaS (Function as a Service, function as a service) dan "serverless technologies" sebagai sinonim, meskipun tidak berarti hal yang sama.  Secara khusus, di bawah ini kita akan berbicara tentang layanan FaaS cloud. <br><br>  Awalnya, teknologi FaaS dimaksudkan untuk mengembangkan tugas-tugas mikro, dan bukan untuk membuat aplikasi "layanan mikro" penuh.  Semakin populernya platform FaaS telah menyebabkan peningkatan minat penyedia layanan cloud, platform FaaS telah mendapatkan fitur baru.  Akibatnya, meskipun ini tidak terduga, ada perasaan bahwa pada 2019 platform FaaS dapat menjadi dasar untuk proyek-proyek serius.  Bisakah platform ini bersaing dengan Kubernetes dan digunakan untuk meng-host aplikasi besar?  Beberapa melihat dalam komputasi tanpa server dan teknologi FaaS yang merupakan sesuatu yang sama sekali baru, tetapi dalam praktiknya, setiap pencipta aplikasi cloud harus membuat pilihan antara ketiga teknologi pada 2019.  Pilihan ini, secara harfiah, disajikan di situs web penyedia layanan cloud.  Yaitu, kita berbicara tentang memilih satu dari tiga opsi: <br><br><ol><li>  Server cloud normal (mis. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VDS</a> dari RUVDS) </li><li>  Kubernetes </li><li>  FaaS </li></ol><br>  Akibatnya, di zaman kita, sangat penting untuk dapat membandingkan kemampuan Kubernet dengan FaaS dan mengantisipasi konsekuensi dari memilih teknologi tertentu. <br><br><h2>  <font color="#3AC1EF">6. Periksa inovasi JavaScript yang akan segera standar.</font> </h2><br>  Saya tidak bisa menyebut diri saya pendukung pencarian dan penggunaan fitur bahasa terbaru, karena kadang-kadang penggunaannya merusak kesederhanaan dan kelengkapan kode.  Tetapi dari waktu ke waktu, fitur-fitur JavaScript yang sangat berharga muncul (seperti async / tunggu konstruksi dua tahun lalu), jadi sangat berguna untuk melihat daftar penawaran dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">node.gc.</a> Sumber daya yang ramah untuk mengetahui terlebih dahulu tentang fitur-fitur baru yang mungkin cocok untuk Anda.  Inilah yang menarik yang saya temukan di sana: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bidang kelas</a> sekarang pada 3 (terakhir) tahap persetujuan, mereka dapat memasukkan standar pada 2019. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tipe</a> data <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BigInt</a> juga melewati tahap akhir dari rekonsiliasi.  Penggunaan angka-angka jenis ini dapat membantu dalam mengatur interaksi dengan layanan-layanan mikro atau sistem apa pun, di mana angka-angka besar digunakan. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Iterator asinkron</a> dan metode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akhirnya ()</a> telah diterima.  Jika Anda belum memperhatikannya - bacalah. </li></ul><br><h2>  <font color="#3AC1EF">7. Kuasai setidaknya satu teknologi untuk membuat API.</font>  <font color="#3AC1EF">Perhatikan GraphQL</font> </h2><br>  REST-API adalah alat yang hebat untuk menyelesaikan kelas tugas tertentu.  Yaitu, kita berbicara tentang mengelola kueri dan memodifikasi catatan dalam basis data.  Apakah sistem Anda fokus untuk bekerja dengan data keuangan?  Mungkin, untuk memastikan operasinya, perlu untuk mematuhi pembatasan ketat dan menggunakan model data yang dikembangkan dengan hati-hati yang tidak memungkinkan ambiguitas.  Teknologi REST cocok untuk Anda dalam hal ini, tetapi tidak menunjukkan dirinya dengan sangat baik dalam situasi yang sangat umum lainnya, misalnya, ketika eksekusi permintaan yang sama dapat menyebabkan diterimanya set data yang berbeda.  Hal yang sama berlaku untuk bekerja dalam kondisi kecepatan koneksi rendah, ketika data sesedikit mungkin ditransmisikan saat bekerja dengan API tertentu.  Situasi seperti itu termasuk koneksi antar komputer, di mana komunikasi berkecepatan tinggi muncul.  Apakah layak dalam kasus seperti itu untuk beralih ke sesuatu yang baru?  Tidak, tidak sepadan.  Yang terbaik adalah menambahkan sesuatu yang baru ke apa yang sudah digunakan.  API bukan arsitektur aplikasi.  Ini hanyalah titik akses ke aplikasi, yang berarti bahwa API yang dibuat menggunakan alat yang berbeda dapat hidup berdampingan.  Bahkan jika mereka semua dibangun di atas kerangka web tunggal seperti Express. <br><br>  Teknologi apa yang harus dipelajari?  Mungkin, dalam kondisi saat ini layak bertaruh pada teknologi GraphQL, yang menjadi semakin populer.  Ekosistem teknologi ini telah matang secara signifikan, melayani beberapa skenario data yang sangat populer - seperti pencarian dinamis dan interaksi dengan sumber data hierarkis.  Di sisi lain, teknologi gRPC masih merupakan solusi yang sangat khusus yang sangat cocok untuk komunikasi antara server dalam situasi ketika selama pertukaran data, diharapkan untuk mentransfer informasi layanan sesedikit mungkin (misalnya, kita berbicara tentang sistem pertukaran data berdasarkan pada " publisher-subscriber ”, atau tentang mereka yang menggunakan antrian pesan dan pesan).  Berikut adalah beberapa tulisan bermanfaat tentang hal ini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perbandingan</a> REST, GraphQL dan gRPC </li><li>  Pengembangan server GraphQL berdasarkan Node.js dan Express </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Video</a> YouTube <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">11 menit</a> menjelaskan dasar-dasar GraphQL </li></ul><br><h2>  <font color="#3AC1EF">8. Menggunakan tes unit dan integrasi?</font>  <font color="#3AC1EF">Lihatlah teknik pengujian baru.</font> </h2><br>  Apakah Anda sudah terbiasa dengan piramida tes, dengan unit, integrasi, dan tes end-to-end?  Jika begitu - hebat.  Semua ini mendasari strategi pengujian yang sukses.  Namun, perlu dicatat bahwa selama 10 tahun terakhir, dunia pengembangan perangkat lunak telah berubah dengan sangat serius, dan model pengujiannya tetap sama, yang menimbulkan pertanyaan kepada kami tentang cara menguji layanan mikro, aplikasi Internet yang kaya, sistem tanpa server.  Beberapa pendekatan modern untuk pengujian melengkapi serangkaian teknologi tradisional, dan beberapa bahkan mungkin menggantinya, sehingga meningkatkan strategi dan hasil pengujian.  Inilah yang dapat Anda baca dan lihat: <br><br><ul><li>  Sistem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengujian</a> yang dibangun pada pola Consumer-Driven Contracts membantu mencegah API server yang digunakan oleh layanan mikro atau klien gagal. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengujian menggunakan snapshot</a> dapat digunakan tidak hanya di frontend, tetapi juga di proyek server. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengujian komponen</a> adalah pendekatan yang seimbang untuk menguji layanan mikro. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut ini adalah</a> video tentang pendekatan modern untuk menguji proyek Node.js. </li></ul><br><h2>  <font color="#3AC1EF">9. Bawa sistem pemantauan aplikasi Anda sejalan dengan praktik terbaik SRE / DevOps</font> </h2><br>  Pada 2019, bahkan aplikasi berukuran sedang dapat terdiri dari puluhan komponen.  Untuk memastikan kelancaran operasi infrastruktur seperti itu, harus dipantau dengan cermat.  Meskipun jelas di atas, sebagian besar pengembang masih tidak menganggap penting untuk mempelajari dan menggunakan rekomendasi tersebut untuk memantau aplikasi dan membuat sistem peringatan tentang masalah yang dapat diberikan kepada mereka oleh spesialis yang bertanggung jawab atas keandalan proyek web.  Misalnya, pengembang sering fokus pada indikator internal kinerja sistem, seperti kecepatan prosesor atau RAM, daripada mengkhawatirkan metrik yang secara langsung mempengaruhi pengguna akhir.  Secara khusus, kita berbicara tentang frekuensi kesalahan dan penundaan.  Ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disebut</a> "pemantauan berbasis gejala."  Indikator berorientasi pengguna seperti itu kadang-kadang disebut "sinyal emas", dan Anda, mungkin memperkenalkan sistem pemantauan, memutuskan untuk memulai dengan pengenalan metrik tersebut.  Berikut adalah bahan terkait: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4 "sinyal emas" pemantauan</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab</a> pemantauan sistem terdistribusi dari Teknik Keandalan Situs Google. </li><li>  Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">statistik permintaan</a> dapat berguna dalam mengumpulkan metrik yang sesuai, yang kemudian dapat ditransfer ke sistem pemantauan. </li></ul><br><h2>  <font color="#3AC1EF">10. Tingkatkan keamanan proyek dengan melihatnya dari sudut pandang penyerang, serta mempelajari cara melakukan serangan dan alat peretas</font> </h2><br>  Jika Anda tidak dapat berpikir seperti seseorang yang ingin menyerang sistem Anda, itu berarti Anda tidak dapat berpikir seperti yang akan dipikirkan oleh pembela sistem ini.  Pada 2019, Anda tidak boleh mentransfer tugas untuk melindungi proyek ke pihak ketiga, atau hanya mengandalkan penganalisa keamanan statis.  Saat ini ada sejumlah besar jenis serangan (tren terbaru di daerah ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangan</a> terhadap infrastruktur pembangunan dan pada npm).  Pada saat yang sama, aplikasi berubah sangat, sangat cepat - kemarin proyek itu diakui sebagai terlindungi dengan baik, dan besok mereka dapat menambahkan beberapa layanan AWS baru, beberapa jenis database baru dan peran IAM baru.  Pada saat yang sama, tidak akan segera menganalisis keamanan proyek.  Hasilnya adalah bahwa pengembang menimbulkan risiko keamanan terbesar pada proyek mereka sendiri.  Solusi untuk masalah ini adalah pelatihan mereka.  Ini berarti bahwa setiap pengembang proyek web perlu membawa implementasi aturan keamanan hampir ke otomatisme, dan apa pun yang dilakukannya, selalu ingat keselamatan. <br><br>  Setelah Anda memutuskan untuk bergerak ke arah ini, ternyata memperhitungkan keamanan saat melakukan pekerjaan apa pun tidak begitu menakutkan.  Katakanlah, setelah membiasakan diri dengan metode dan alat umum untuk menyerang, buatlah diagram arsitektur aplikasi Anda dan pikirkan bagaimana Anda akan menyerangnya.  Seiring waktu, bahkan tanpa memberi diri Anda laporan dalam hal ini, Anda akan mulai mempertimbangkan masalah keamanan akun, membuat setiap keputusan arsitektur dan memasukkan setiap baris kode baru di editor.  Berikut adalah beberapa ide untuk mengelola masalah keamanan: <br><br><ul><li>  Coba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OWASP ZAP</a> - alat multi-fungsional untuk meneliti sistem dan peretasan, yang memungkinkan bahkan pemula untuk mempelajari tingkat keamanan aplikasi. </li><li>  Lihatlah daftar rekomendasi keamanan Node.js ini untuk lebih dari dua lusin ide serangan dan contoh kode JavaScript. </li><li>  Jadwalkan pertemuan analisis ancaman bulanan di mana tim proyek akan mempelajari arsitekturnya dan menawarkan serangan terhadapnya.  Jika ide seperti itu terasa membosankan bagi Anda - Anda dapat melakukan gamifikasi rapat semacam itu.  Katakanlah, mereka yang menemukan kerentanan dapat diberi imbalan entah bagaimana.  Anda juga dapat, misalnya, membagi peserta dari pertemuan semacam itu menjadi dua tim dan mengatur kompetisi di antara mereka untuk menemukan kerentanan. </li></ul><br><h2>  <font color="#3AC1EF">11. Merancang dan mengimplementasikan strategi pembaruan paket npm.</font>  <font color="#3AC1EF">2018 menunjukkan bahwa tergesa-gesa saat memperbarui mereka berbahaya</font> </h2><br>  Biasanya, tim pengembangan mematuhi satu dari dua "strategi" untuk memperbarui paket npm.  Mereka memperbarui mereka secepat mungkin setelah rilis versi baru mereka, kadang-kadang bahkan mengotomatiskan proses ini, atau tidak memiliki strategi pembaruan paket sama sekali.  Dengan pendekatan ini, paket diperbarui secara tidak teratur, dan, memulai proses ini, mereka dipandu oleh sesuatu seperti pemikiran tiba-tiba: "Haruskah kita diperbarui hari ini?"  Meskipun yang pertama dari pendekatan ini terlihat lebih baik dari yang kedua, ternyata secara tak terduga dikaitkan dengan risiko yang lebih tinggi pada tahun 2018 daripada yang kedua.  Masalah, seperti yang terjadi pada paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">flat-stream</a> , ditemukan oleh komunitas dalam beberapa lusin hari, dan mereka yang tidak tergesa-gesa untuk memperbarui aman. <br><br>  Pertimbangkan memformalkan strategi untuk memperbarui paket yang tergantung pada proyek Anda, pertimbangkan untuk menggunakan alat otomatisasi untuk proses ini.  Temukan jalan tengah antara menolak pembaruan dan memperbarui paket terlalu sering.  Di sini program <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">npq</a> dapat membantu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda</a> , yang memeriksa paket selama instalasi dan memberikan rekomendasi.  Anda dapat melihat proyek komersial seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penjaga hijau</a> .  Kerugian dari solusi tersebut adalah bahwa mereka tidak dapat menunda instalasi sampai saat ketika akan sangat jelas bahwa paket tertentu aman. <br><br><h2>  <font color="#3AC1EF">12. Lihatlah lebih dekat pada penyebaran proyek secara bertahap</font> </h2><br>  Mungkin pada tahun 2019 Anda akan menganggap pantas untuk menyebarkan proyek dalam produksi menggunakan skema bertahap, dan tidak dengan langsung mengirim segala sesuatu yang sebelumnya dalam proses pengembangan ke server tempur.  Proses ini disebut "penyebaran kenari", ini memberikan tingkat perlindungan proyek yang lebih tinggi daripada penyebaran kode baru secara simultan.  Biasanya membedakan tiga tahap berikut: <br><br><ol><li>  Penempatan  Kode baru ini digunakan dalam lingkungan produksi baru yang terisolasi (pada layanan Kubernet baru, pada server virtual baru).  Pada tahap ini, kode belum melayani siapa pun, oleh karena itu, kegagalan di dalamnya tidak dapat menyebabkan kerusakan. </li><li>  Pengujian.  Sekarang, beberapa spesialis dapat bekerja dengan kode baru dalam kondisi sedekat mungkin dengan yang asli, karena kode tersebut digunakan dalam produksi. </li><li>  Lepaskan  Setelah pengujian menunjukkan operabilitas kode baru, secara bertahap diberikan akses ke semakin banyak pengguna, dan setelah ternyata itu bekerja cukup andal, versi yang lama secara bertahap dikeluarkan dari penggunaan. </li></ol><br>  Salah satu poin penting untuk dibuat di sini adalah bahwa melakukan penyebaran kenari skala penuh pada tahun 2019 masih akan menjadi kesenangan yang sangat mahal.  Faktanya adalah ini membutuhkan koordinasi pekerjaan elemen infrastruktur proyek - seperti perutean dan pemantauan.  Jadi, jika Anda ingin menerapkan teknik yang sama, Anda harus mulai dengan penyebaran kenari yang sederhana, sebagian manual.  Secara khusus, ini terdiri dari kenyataan bahwa setelah berhasil menyelesaikan tes pertama, dengan mempertimbangkan indikator pemantauan, penambahan manual server dengan versi baru dari perangkat lunak ke sistem dilakukan.  Baca lebih lanjut tentang rilis kenari di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Jika Anda ingin mengotomatiskan proses melakukan rilis seperti itu, perhatikan platform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spinnaker</a> . <br><br><h2>  <font color="#3AC1EF">13. Lihatlah teknologi Kubernetes yang telah menaklukkan dunia.</font> </h2><br>  Kubernetes (K8S)      ,            .    -    .    .  Kubernetes     ,     , 54%        K8S-.         — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>      .         K8S —   ,     : <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Istio</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">K-Native</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> Kubernetes</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  Kubernetes</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  Kubernetes</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helm</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Scaffold</a> </li></ul><br>  ,   ,     Kubernetes,  . <br><br><h2> <font color="#3AC1EF">14.  -,       </font> </h2><br> - —    .        ,   . <br><br><h2> <font color="#3AC1EF">15.    , ,   ,    </font> </h2><br> ,   —      .  ,        .        .  ,                   (,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tensorflow.js</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">brain.js</a> ,     ,    ). <br><br><h2> <font color="#3AC1EF">16.     </font> </h2><br>   ,                  .    ,  ,        .      ,   —   . <br><br><h2> <font color="#3AC1EF">17.      Linux,   —   </font> </h2><br>   Linux-    ,        ,   .   — ,     ( —  ),   Docker,       .       ,  ,   ,   ,  ,    . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  ,      Linux. <br><br><h2> <font color="#3AC1EF">18.   ,     Node.js</font> </h2><br>      ( Node.js): «     .      ,   ».            ,   ,         (     ). ,       Node.js, ,   V8   libuv.   ,  2019  —     ,       Node.js,  , ,       libuv. , ,   ,  Node.js    -  ,     . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   ,     . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,   npm-  C/C++. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>      Node.js. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>     Node.js   RUVDS. <br><br><h2> <font color="#3AC1EF">19.  ,   </font> </h2><br>      ,     ,  .   ,  ,   , ,   ,      . ,  ,       ,      ,   .         JavaScript-,    .    ,      JavaScript,       .    , ,  TypeScript   .      flow  ,     ,   .   ,  -   flow,      , ,  , «   ,    ».   ? ,      ,   « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ».   ,    - . ,           ,     ,   — .          .  ,        -           ,       ,    ,  .     ,            .   ,     2019   ,    —    . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>    . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>   ,       .       —    ,     ,     ,     ,   ,   ,      .       ,   ,     ,  ,     ,    . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>   19 ,   Node.js-,    -   ,    2019 . ,    - ,   . <br><br>  <b>Pembaca yang budiman!</b>      Node.js-  2019 ? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/n0/ry/op/n0ryop7wfykgkeicz3mtuwghrcu.jpeg"></a> </div><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434114/">https://habr.com/ru/post/id434114/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434102/index.html">Animasi yang indah dan informatif: kasus gerakan melingkar dan getaran</a></li>
<li><a href="../id434104/index.html">Ground VHF atau demistifikasi antena kotak ganda / tiga</a></li>
<li><a href="../id434106/index.html">Percaya pada SDK Seluler</a></li>
<li><a href="../id434110/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 344 (17-23 Desember 2018)</a></li>
<li><a href="../id434112/index.html">Prinsip pemrograman fungsional dalam JavaScript</a></li>
<li><a href="../id434116/index.html">Kisah tentang mudahnya peretasan infrastruktur pengembangan perangkat lunak modern</a></li>
<li><a href="../id434118/index.html">React Tutorial Bagian 4: Komponen Induk dan Anak</a></li>
<li><a href="../id434120/index.html">React Tutorial, Bagian 5: Memulai dengan Aplikasi TODO, Styling Dasar</a></li>
<li><a href="../id434122/index.html">Skenario - Bukan Objek Halaman</a></li>
<li><a href="../id434124/index.html">Aktifkan akselerasi GPU di Photoshop di bawah Wine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>