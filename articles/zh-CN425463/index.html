<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😞 🍰 😑 Unity六边形地图：水，地标和堡垒墙 🚃 💦 🧙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第1-3部分：网格，颜色和像元高度 

 第4-7部分：颠簸，河流和道路 

 第8-11部分：水，地貌和城墙 

 第12-15部分：保存和加载，纹理，距离 

 第16-19部分：找到道路，队员，动画 

 第20-23部分：战争迷雾，地图研究，程序生成 

 第24-27部分：水循环，侵蚀，生...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity六边形地图：水，地标和堡垒墙</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425463/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1-3部分：网格，颜色和像元高度</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4-7部分：颠簸，河流和道路</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8-11部分：水，地貌和城墙</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第12-15部分：保存和加载，纹理，距离</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第16-19部分：找到道路，队员，动画</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第20-23部分：战争迷雾，地图研究，程序生成</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第24-27部分：水循环，侵蚀，生物群落，圆柱图</a> <br><br><h1> 第8部分：水 </h1><br><ul><li> 加水到细胞。 </li><li> 对水表面进行三角剖分。 </li><li> 用泡沫制作冲浪。 </li><li> 结合水和河流。 </li></ul><br> 我们已经增加了河流支持，在这一部分中，我们将把细胞完全浸入水中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a9/73c/b6e/2a973cb6eb97eba7d04a325f3ac89a3e.jpg"></div><br>  <i>水来了。</i> <br><a name="habracut"></a><br><h2> 水位 </h2><br> 最简单的方法是通过将其设置在同一级别来实现水支持。 所有高度低于此水平的电池都将浸入水中。 但是，更灵活的方法是将水保持在不同的高度，因此让我们更改水位。 为此， <code>HexCell</code>需要监控其水位。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> WaterLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (waterLevel == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } waterLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> waterLevel;</code> </pre> <br> 如果需要，您可以确保浮雕的某些功能在水下不存在。 但是现在我不会这样做。 诸如水下道路之类的东西适合我。 它们可以被认为是最近被洪水淹没的地区。 <br><br><h3> 淹没细胞 </h3><br> 现在我们有了水位，最重要的问题是细胞是否在水下。 如果单元格的水位高于其高度，则该单元格在水下。 为了获得此信息，我们将添加一个属性。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsUnderwater { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> waterLevel &gt; elevation; } }</code> </pre> <br> 这意味着当水位和高度相等时，单元会上升到水面之上。 即，水的真实表面低于该高度。 与河流表面一样，让我们​​添加相同的偏移量<code>HexMetrics.riverSurfaceElevationOffset</code> 。 将其名称更改为更通用的名称。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public const float riverSurfaceElevationOffset = -0.5f; public const float waterElevationOffset = -0.5f;</span></span></code> </pre> <br> 更改<code>HexCell.RiverSurfaceY</code> ，使其使用新名称。 然后，我们向淹没单元的水面添加类似的属性。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RiverSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.waterElevationOffset) * HexMetrics.elevationStep; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WaterSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (waterLevel + HexMetrics.waterElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><h3> 水编辑 </h3><br> 编辑水位类似于更改高度。 因此， <code>HexMapEditor</code>必须监视活动水位以及是否应将其应用于单元格。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeElevation; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeWaterLevel; … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyElevation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyWaterLevel = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br> 添加将这些参数与UI连接的方法。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyWaterLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyWaterLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWaterLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeWaterLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; }</code> </pre> <br> 并将水位添加到<code>EditCell</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } … } }</code> </pre> <br> 要将水位添加到UI，请复制标签和高度滑块，然后进行更改。 请记住将其事件附加到适当的方法。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42b/a13/de4/42ba13de4120b43e460628021c77d99f.png"></div><br>  <i>水位滑块。</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">统一包装</a> <br><br><h2> 水三角剖分 </h2><br> 要对水进行三角剖分，我们需要使用新材质的新网格。 首先，创建一个<em>Water</em>着色器，复制<em>River</em>着色器。 对其进行更改，以使其使用color属性。 <br><br><pre> <code class="hljs pgsql">Shader "Custom/Water" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Transparent" "Queue"="Transparent" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard alpha #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br> 通过复制“ <em>水”</em>材质并将其替换为着色器，使用此着色器创建新材质。 保留噪波纹理，因为稍后将使用它。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd9/238/283/fd9238283d92bacd26a3ff5dce73b17b.png"></div><br>  <i>水材料。</i> <br><br> 通过复制<em>Rivers</em>子代将新子代添加到预制中。 他不需要UV坐标，并且必须使用<em>Water</em> 。 与往常一样，我们将通过创建预制实例，对其进行更改，然后将所做的更改应用于预制来实现。 在那之后，摆脱实例。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ec/6e6/82f/6ec6e682f16c604d75c0e5b835d5b03e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/3f3/eeb/7c53f3eeb282e533f9f0b8a20e813091.png"></div><br>  <i>儿童对象水。</i> <br><br> 接下来，向<code>HexGridChunk</code>添加水网格支持。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); }</code> </pre> <br> 并将其连接到预制子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/19a/76a/b4d19a76a745d550314b277fd2c0e13c.png"></div><br>  <i>水对象已连接。</i> <br><br><h3> 水六边形 </h3><br> 由于水形成第二层，因此让我们针对每个方向使用自己的三角剖分方法。 我们仅在将电池浸入水中时才需要调用它。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsUnderwater) { TriangulateWater(direction, cell, center); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br> 与河流一样，在水位相同的情况下，水面的高度变化也不大。 因此，我们似乎不需要复杂的肋骨。 一个简单的三角形就足够了。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { center.y = cell.WaterSurfaceY; Vector3 c1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondSolidCorner(direction); water.AddTriangle(center, c1, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a51/72b/99b/a5172b99ba382c6e79abff653e4b7fb2.png"></div><br>  <i>水的六边形。</i> <br><br><h3> 水化合物 </h3><br> 我们可以将相邻的单元格与一个四边形的水相连。 <br><br><pre> <code class="cs hljs"> water.AddTriangle(center, c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !neighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 e1 = c1 + bridge; Vector3 e2 = c2 + bridge; water.AddQuad(c1, c2, e1, e2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a6/3af/949/0a63af9496da925e966b008f41f808a8.png"></div><br>  <i>水的边缘的连接。</i> <br><br> 并用一个三角形填充角。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { … water.AddQuad(c1, c2, e1, e2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || !nextNeighbor.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } water.AddTriangle( c2, e2, c2 + HexMetrics.GetBridge(direction.Next()) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c32/37e/5b4/c3237e5b4e492f9a1c334f90aaa88ee4.png"></div><br>  <i>水角的关节。</i> <br><br> 现在，当水细胞在附近时，我们将它们连接起来。 它们与较高高度的干细胞之间留有间隙，但我们将留给以后使用。 <br><br><h3> 协调水位 </h3><br> 我们假设相邻的水下细胞具有相同的水位。 如果是这样，那么一切看起来都很好，但是如果违反了此假设，则会发生错误。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fcf/a8b/b4f/fcfa8bb4fb960ddc788d358e60f9023f.png"></div><br>  <i>水位不一致。</i> <br><br> 我们可以使水保持在同一水平上。 例如，当淹没单元的水位发生变化时，我们可以将更改传播到相邻单元，以保持水位同步。 但是，此过程应继续进行，直到遇到未浸入水中的细胞为止。 这些单元定义了水团的边界。 <br><br> 这种方法的危险在于它可能很快失控。 如果编辑不成功，则水可能会覆盖整个地图。 然后，所有片段都必须同时进行三角剖分，这将导致延迟的巨大跳跃。 <br><br> 因此，让我们暂时不做。 可以在更复杂的编辑器中添加此功能。 虽然水位的一致性，我们离开了用户的良心。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">统一包装</a> <br><br><h2> 水动画 </h2><br> 我们将创建类似于波浪的颜色，而不是均匀的颜色。 与其他着色器一样，现在我们将不再努力争取精美的图形，只需要指定波浪即可。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca1/a2f/1f9/ca1a2f1f978cd2f2993a96b44440227b.png"></div><br>  <i>完全平坦的水。</i> <br><br> 让我们做些与河流有关的事情。 我们根据世界的位置对噪声进行采样，并将其添加到统一的颜色中。 要设置曲面动画，请在V坐标上添加时间。 <br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise.z; fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>滚动水，时间×10。</i> <br><br><h3> 两个方向 </h3><br> 到目前为止，这根本不像波浪。 让我们通过添加第二个噪声样本来使图片复杂化 <br> 然后添加U坐标我们使用了一个不同的噪声通道来得到两个不同的模式 完成的波将这两个样本堆叠在一起。 <br><br><pre> <code class="hljs pgsql"> float2 uv1 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv1.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise1 = tex2D(_MainTex, uv1 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); float2 uv2 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; uv2.x += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(_MainTex, uv2 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise1.z + noise2.x;</code> </pre> <br> 当对两个样本求和时，我们得到的结果范围为0–2，因此我们需要将其缩放回0–1。 代替简单地将波分成两半，我们可以使用<code>smoothstep</code>函数创建更有趣的结果。 我们将¾– 2放在0–1上，以使水面没有可见波。 <br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waves = noise1.z + noise2.x; waves = <span class="hljs-keyword"><span class="hljs-keyword">smoothstep</span></span>(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>两个方向，时间×10。</i> <br><br><h3> 混合浪潮 </h3><br> 仍然值得注意的是，我们有两个实际上没有变化的运动噪声模式。 如果模式发生变化，那将更加合理。 我们可以通过在噪声样本的不同通道之间进行插值来实现这一点。 但这不能以相同的方式进行，否则水的整个表面将同时变化，这是非常明显的。 相反，我们将造成一波混乱。 <br><br> 我们将在正弦波的帮助下创建一个混合波，该混合波将沿水表面对角线移动。 为此，我们将世界坐标X和Z相加，并将总和用作<code>sin</code>函数的输入。 缩小以获取足够大的波段。 当然，让我们添加相同的值来制作动画。 <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin((<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + _Time.y);</code> </pre> <br> 正弦波的范围是-1和1，我们需要一个0–1的间隔。 您可以通过平方波来获得它。 要查看隔离的结果，请使用它代替更改的颜色作为输出值。 <br><br><pre> <code class="hljs pgsql"> sin((<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + _Time.y); blendWave *= blendWave; <span class="hljs-type"><span class="hljs-type">float</span></span> waves = noise1.z + noise2.x; waves = smoothstep(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves); fixed4 c = blendWave; //saturate(_Color + waves);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa3/3d9/d70/aa33d9d70a022df57a0348423181b258.png"></div><br>  <i>混合浪潮。</i> <br><br> 为了使混合波不那么引人注目，请从两个样本中添加一些噪声。 <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin( (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.x + <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.z) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (noise1.y + noise2.z) + _Time.y ); blendWave *= blendWave;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/c8f/697/618c8f697cd2e463d7349030277d1a82.png"></div><br>  <i>扭曲的混合波。</i> <br><br> 最后，我们使用混合波在两个噪声样本的两个通道之间进行内插。 为了获得最大的变化，采用四个不同的通道。 <br><br><pre> <code class="hljs lisp"> float waves = lerp(<span class="hljs-name"><span class="hljs-name">noise1</span></span>.z, noise1.w, blendWave) + lerp(<span class="hljs-name"><span class="hljs-name">noise2</span></span>.x, noise2.y, blendWave)<span class="hljs-comment"><span class="hljs-comment">; waves = smoothstep(0.75, 2, waves); fixed4 c = saturate(_Color + waves);</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>混波，时间×2。</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">统一包装</a> <br><br><h2> 海岸 </h2><br> 我们已经完成了开放水域，但现在我们需要填补沿海水域的空白。 由于我们必须符合土地的轮廓，因此沿海水需要采取不同的方法。 让我们将<code>TriangulateWater</code>分为两种方法-一种用于开放水域，另一种用于海岸水域。 要了解何时与海岸合作，我们需要查看邻近的单元。 也就是说，在<code>TriangulateWater</code>我们将得到一个邻居。 如果有邻居并且他不在水下，那么我们正在与海岸打交道。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { center.y = cell.WaterSurfaceY; HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; !neighbor.IsUnderwater) { TriangulateWaterShore(direction, cell, neighbor, center); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateOpenWater(direction, cell, neighbor, center); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { Vector3 c1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondSolidCorner(direction); water.AddTriangle(center, c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// HexCell neighbor = cell.GetNeighbor(direction); // if (neighbor == null || !neighbor.IsUnderwater) { // return; // } Vector3 bridge = HexMetrics.GetBridge(direction); … } } void TriangulateWaterShore ( HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center ) { }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f04/799/441/f0479944178dcb5646bbf935700a798e.png"></div><br>  <i>沿海没有三角剖分。</i> <br><br> 由于海岸变形，我们必须使海岸的水三角形变形。 因此，我们需要边缘的顶部和三角形的扇形。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); water.AddTriangle(center, e1.v1, e1.v2); water.AddTriangle(center, e1.v2, e1.v3); water.AddTriangle(center, e1.v3, e1.v4); water.AddTriangle(center, e1.v4, e1.v5); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/761/283/bbd76128386859bb388e6e2d3f105ff0.png"></div><br>  <i>沿海岸的三角形风扇。</i> <br><br> 接下来是一条肋骨，就像通常的浮雕一样。 但是，我们没有义务将自己仅限于某些区域，因为我们在遇到海岸时只呼叫<code>TriangulateWaterShore</code> ，而对于该海岸而言，则始终需要该区域。 <br><br><pre> <code class="cs hljs"> water.AddTriangle(center, e1.v4, e1.v5); Vector3 bridge = HexMetrics.GetBridge(direction); EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v5 + bridge ); water.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); water.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); water.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); water.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7da/fbc/aa9/7dafbcaa95a4b48509ab68fbf111c703.png"></div><br>  <i>肋骨条纹沿海。</i> <br><br> 同样，我们每次也必须添加一个三角形的三角形。 <br><br><pre> <code class="cs hljs"> water.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { water.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/18f/8b1/06418f8b10cc0fc0a4e2276b86375385.png"></div><br>  <i>沿海的肋骨的角落。</i> <br><br> 现在我们已经为海岸准备了水。 它的一部分始终在浮雕网格下方，因此没有孔。 <br><br><h3> 紫外线海岸 </h3><br> 我们可以保留一切，但如果沿海水有自己的时间表，那将很有趣。 例如，泡沫的影响，在靠近海岸时会变得更大。 要实现它，着色器必须知道片段离海岸有多近。 我们可以通过UV坐标传输此信息。 <br><br> 开放水没有紫外线坐标，也不需要泡沫。 仅海岸附近的水才需要。 因此，对两种水的要求都大不相同。 为每种类型创建自己的网格是合乎逻辑的。 因此，我们向HexGridChunk添加了对另一个网格对象的支持。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water, waterShore; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); }</code> </pre> <br> 这个新的网格将使用<code>TriangulateWaterShore</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); } }</code> </pre> <br> 复制水对象，将其连接到预制件并进行设置，以使其使用UV坐标。 我们还为沿海水创建了一个着色器和材质，复制了现有的着色器和水材质。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/561/77e/e73/56177ee7331ce092a859a058645f0364.png"></div><br>  <i>水岸设施和紫外线材料。</i> <br><br> 更改“ <em>水岸”</em>着色器，以使其显示UV坐标而不是水。 <br><br><pre> <code class="hljs lisp"> fixed4 c = fixed4(<span class="hljs-name"><span class="hljs-name">IN</span></span>.uv_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br> 由于尚未设置坐标，它将显示纯色。 因此，很容易看到海岸实际上使用了带有材料的单独网格。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/630/45c/ec0/63045cec0f1f367bfee191f69cfa11ad.png"></div><br>  <i>用于海岸的单独网格。</i> <br><br> 让我们将海岸信息放置在坐标V中。在水侧，将其分配为0，在陆地侧将其分配为-值1。由于我们无需传输其他任何内容，因此所有U坐标都将简单地为0。 <br><br><pre> <code class="cs hljs"> waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetBridge(direction.Next()) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f4/3fa/f86/8f43faf864c259e21c2ce731d08f43f6.png"></div><br>  <i>向海岸过渡是错误的。</i> <br><br> 上面的代码适用于边缘，但是在某些角度上是错误的。 如果下一个邻居在水下，则此方法将是正确的。 但是，当下一个邻居不在水下时，三角形的第三个峰将在陆地下。 <br><br><pre> <code class="cs hljs"> waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, nextNeighbor.IsUnderwater ? <span class="hljs-number"><span class="hljs-number">0f</span></span> : <span class="hljs-number"><span class="hljs-number">1f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/9e9/6e6/c2e9e96e63c161d0f71f81e31742af89.png"></div><br>  <i>过渡到海岸是正确的。</i> <br><br><h3> 海岸上的泡沫 </h3><br> 现在已经正确实现了向海岸的过渡，您可以使用它们创建泡沫效果。 最简单的方法是将惯性运动的值添加到统一的颜色。 <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = shore; fixed4 c = saturate(_Color + foam); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/502/a56/ef5502a56ab665732312be25a6961817.png"></div><br>  <i>线性泡沫。</i> <br><br> 为了使泡沫更有趣，请将其乘以正弦曲线的平方。 <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin(shore * <span class="hljs-number"><span class="hljs-number">10</span></span>); foam *= foam * shore;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/acf/6d8/c2eacf6d83e9f7c1298cdd7a05e551d0.png"></div><br>  <i>褪色正弦方形泡沫。</i> <br><br> 靠近岸边时，让泡沫前端变大。 这可以通过在使用Coast值之前取其平方根来完成。 <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; shore = sqrt(shore);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/762/675/e98/762675e987d119034cd5b643c86ca672.png"></div><br>  <i>靠近岸边的泡沫变稠。</i> <br><br> 添加变形以使其看起来更自然。 让我们在接近海岸时使变形减弱。 因此，最好沿着海岸走。 <br><br><pre> <code class="hljs pgsql"> float2 noiseUV = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin((shore + distortion) * <span class="hljs-number"><span class="hljs-number">10</span></span>); foam *= foam * shore;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31a/7fd/59a/31a7fd59ad215b200571133543f1406b.png"></div><br>  <i>泡沫变形。</i> <br><br> 而且，当然，我们正在为所有这些动画：正弦曲线和扭曲。 <br><br><pre> <code class="hljs pgsql"> float2 noiseUV = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam = sin((shore + distortion) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam *= foam * shore;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>动画泡沫。</i> <br><br> 除了传入的泡沫外，还有一种后退泡沫。 让我们添加第二个正弦曲线来模拟它，它以相反的方向移动。 使其变弱并添加时移。 成品泡沫将是这两个正弦波的最大值。 <br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distortion1 = <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam1 = <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>((shore + distortion1) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam1 *= foam1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distortion2 = <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.y * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam2 = <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>((shore + distortion2) * <span class="hljs-number"><span class="hljs-number">10</span></span> + _Time.y + <span class="hljs-number"><span class="hljs-number">2</span></span>); foam2 *= foam2 * <span class="hljs-number"><span class="hljs-number">0.7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> foam = <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(foam1, foam2) * shore;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>进出泡沫。</i> <br><br><h3> 波浪和泡沫的混合 </h3><br> 在开放水域和沿海水域之间有一个急剧的过渡，因为开放水波不包括在沿海水域中。 要解决此问题，我们需要在<em>Water Shore</em>着色器中包括这些波浪。 <br><br> 让我们将其粘贴到<em>Water.cginc</em>包含文件中，而不是复制波形代码。 实际上，我们在其中插入了用于泡沫和波浪的代码，每个都是独立的功能。 <br><br><div class="spoiler">  <b class="spoiler_title">着色器包含文件如何工作？</b> <div class="spoiler_text"> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rendering 5</a>教程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ Multiple Lights”中</a>介绍了如何创建自己的包含着色器文件。 </div></div><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> Foam (<span class="hljs-type"><span class="hljs-type">float</span></span> shore, float2 worldXZ, sampler2D noiseTex) { // <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; shore = sqrt(shore); float2 noiseUV = worldXZ + _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(noiseTex, noiseUV * <span class="hljs-number"><span class="hljs-number">0.015</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> distortion1 = noise.x * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam1 = sin((shore + distortion1) * <span class="hljs-number"><span class="hljs-number">10</span></span> - _Time.y); foam1 *= foam1; <span class="hljs-type"><span class="hljs-type">float</span></span> distortion2 = noise.y * (<span class="hljs-number"><span class="hljs-number">1</span></span> - shore); <span class="hljs-type"><span class="hljs-type">float</span></span> foam2 = sin((shore + distortion2) * <span class="hljs-number"><span class="hljs-number">10</span></span> + _Time.y + <span class="hljs-number"><span class="hljs-number">2</span></span>); foam2 *= foam2 * <span class="hljs-number"><span class="hljs-number">0.7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> max(foam1, foam2) * shore; } <span class="hljs-type"><span class="hljs-type">float</span></span> Waves (float2 worldXZ, sampler2D noiseTex) { float2 uv1 = worldXZ; uv1.y += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise1 = tex2D(noiseTex, uv1 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); float2 uv2 = worldXZ; uv2.x += _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(noiseTex, uv2 * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> blendWave = sin( (worldXZ.x + worldXZ.y) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (noise1.y + noise2.z) + _Time.y ); blendWave *= blendWave; <span class="hljs-type"><span class="hljs-type">float</span></span> waves = lerp(noise1.z, noise1.w, blendWave) + lerp(noise2.x, noise2.y, blendWave); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> smoothstep(<span class="hljs-number"><span class="hljs-number">0.75</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, waves); }</code> </pre> <br> 更改<em>水</em>着色器，使其使用新的包含文件。 <br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); fixed4 c = saturate(_Color + waves); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br> 在“ <em>水岸”</em>着色器中，将同时计算泡沫和波浪的值。 然后，当我们接近海岸时，我们将海浪消声。 最终结果将是泡沫和波浪的最大化。 <br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = Foam(shore, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); waves *= <span class="hljs-number"><span class="hljs-number">1</span></span> - shore; fixed4 c = saturate(_Color + max(foam, waves)); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>泡沫和波浪的混合物。</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">统一包装</a> <br><br><h2> 再谈沿海水 </h2><br> 海岸网格的一部分隐藏在浮雕网格下方。 这是正常现象，但是只有一小部分被隐藏。 不幸的是，陡峭的悬崖掩盖了大部分沿海水域，因此也起泡沫。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dea/adf/7e3/deaadf7e3290f93b28ed6177c713bbaa.png"></div><br>  <i>几乎隐藏的沿海水域。</i> <br><br> 我们可以通过增加海岸带的大小来解决这个问题。 这可以通过减小水的六边形的半径来完成。 为此，除了完整性系数外，我们还需要<code>HexMetrics</code>水系数以及获取水角的方法。 <br><br> 完整性系数为0.8。 要使水化合物的大小增加一倍，我们需要将水系数设置为0.6。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waterFactor = <span class="hljs-number"><span class="hljs-number">0.6f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstWaterCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] * waterFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondWaterCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] * waterFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将使用这些新方法</font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来查找水的角度。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { Vector3 c1 = center + HexMetrics.GetFirstWaterCorner(direction); Vector3 c2 = center + HexMetrics.GetSecondWaterCorner(direction); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstWaterCorner(direction), center + HexMetrics.GetSecondWaterCorner(direction) ); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/123/b85/fcf/123b85fcffde7ae313f177f76f882ef5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用水角。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，水的六边形之间的距离增加了一倍。</font><font style="vertical-align: inherit;">现在</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它也应该有一种在水中建立桥梁的方法。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> waterBlendFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> - waterFactor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWaterBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * waterBlendFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行更改，</font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便他使用新方法。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateOpenWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE &amp;&amp; neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 bridge = HexMetrics.GetWaterBridge(direction); … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E) { … water.AddTriangle( c2, e2, c2 + HexMetrics.GetWaterBridge(direction.Next()) ); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … Vector3 bridge = HexMetrics.GetWaterBridge(direction); … HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { waterShore.AddTriangle( e1.v5, e2.v5, e1.v5 + HexMetrics.GetWaterBridge(direction.Next()) ); … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99b/756/1fa/99b7561fad8556733ea1f10b2dcdd233.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在水中的长桥。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在水陆之间 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管这为我们提供了更多的泡沫空间，但在浮雕下隐藏了更多的空间。</font><font style="vertical-align: inherit;">理想情况下，我们将能够在水侧使用水肋，在陆侧使用肋水肋。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们从水的角落开始，我们将无法使用简单的桥梁来找到土地的相对边缘。</font><font style="vertical-align: inherit;">相反，我们可以从邻居的中心向相反的方向前进。</font><font style="vertical-align: inherit;">更改</font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为使用此新方法。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Vector3 bridge = HexMetrics.GetWaterBridge(direction); Vector3 center2 = neighbor.Position; center2.y = center.y; EdgeVertices e2 = new EdgeVertices( center2 + HexMetrics.GetSecondSolidCorner(direction.Opposite()), center2 + HexMetrics.GetFirstSolidCorner(direction.Opposite()) ); … HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); if (nextNeighbor != null) { Vector3 center3 = nextNeighbor.Position; center3.y = center.y; waterShore.AddTriangle( e1.v5, e2.v5, center3 + HexMetrics.GetFirstSolidCorner(direction.Previous()) ); … }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b29/3f2/01f/b293f201f065b7921f1098484e3b725d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">边角错误。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这行之有效，只是现在我们再次需要考虑角度三角形的两种情况。</font></font><br><br><pre> <code class="cs hljs"> HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Vector3 center3 = nextNeighbor.Position; // center3.y = center.y; Vector3 v3 = nextNeighbor.Position + (nextNeighbor.IsUnderwater ? HexMetrics.GetFirstWaterCorner(direction.Previous()) : HexMetrics.GetFirstSolidCorner(direction.Previous())); v3.y = center.y; waterShore.AddTriangle(e1.v5, e2.v5, v3); waterShore.AddTriangleUV( new Vector2(0f, 0f), new Vector2(0f, 1f), new Vector2(0f, nextNeighbor.IsUnderwater ? 0f : 1f) ); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e1/f64/db1/4e1f64db1a34a8e6cff0f402f5fc6bd8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">边缘的正确角。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种方法效果很好，但是现在大多数泡沫可见，因此变得非常明显。</font><font style="vertical-align: inherit;">为了弥补这一点，我们将通过减少着色器中的惯性运动值的比例来使效果变弱。</font></font><br><br><pre> <code class="hljs lisp"> shore = sqrt(<span class="hljs-name"><span class="hljs-name">shore</span></span>) * <span class="hljs-number"><span class="hljs-number">0.9</span></span><span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准备好的泡沫。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 海底河流 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最终，我们至少在没有河流流入的地方喝了水。</font><font style="vertical-align: inherit;">由于水和河流尚未相互注意到，因此河流将在水中流动。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/1ee/bc5/0511eebc5420c9203475b65ce5c478b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">河流在水中流动。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染半透明对象的顺序取决于它们与相机的距离。</font><font style="vertical-align: inherit;">最近的对象最后渲染，因此它们在顶部。</font><font style="vertical-align: inherit;">移动相机时，这意味着有时河流和水有时会彼此叠置。</font><font style="vertical-align: inherit;">首先，使渲染顺序恒定。</font><font style="vertical-align: inherit;">必须在水面上绘制河流，以便正确显示瀑布。</font><font style="vertical-align: inherit;">我们可以通过更改</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器的队列来实现</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs objectivec"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent+1"</span></span> }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4bc/74e/d91/4bc74ed9179598f5b9e82c3ff0cde851.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们最后画了河。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 隐藏水下河 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管河床很可能在水下，并且水实际上可以流过河水，但我们不应看到这种水。</font><font style="vertical-align: inherit;">更重要的是，不应将其渲染在真实的水面之上。</font><font style="vertical-align: inherit;">仅当当前单元格不在水下时，才可以通过添加河段来摆脱海底河流的水。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; … } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要</font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始，将增加河流的部分，当没有电流，没有相邻小区不是在水中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/899/0c7/cf6/8990c7cf6af7bf25596b4ffc05204817.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有更多的水下河流。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 瀑布 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不再有水下河，但是现在我们在河与水面相遇的那些地方开了孔。与水位相同的河流会形成小洞或覆盖层。但是最引人注目的是从更高的高度流出的河流缺少的瀑布。让我们先照顾他们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一条带有瀑布的河段，用于穿过水面。结果，他发现自己部分在水上，部分在水下。我们需要保持一部分高于水位，丢弃其他所有东西。您将为此而努力，因此请创建一个单独的方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新方法需要四个峰值，两个河流水位和一个水位。我们将对其进行设置，以使我们朝着瀑布下方的水流方向看。因此，前两个峰和左侧和右侧将在顶部，而较低的峰将跟随。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterfallInWater</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waterY </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = y1; v3.y = v4.y = y2; rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当邻居在水下并创建瀑布时，</font><font style="vertical-align: inherit;">我们将调用此方法</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor.IsUnderwater) { TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &gt; neighbor.WaterLevel) { TriangulateWaterfallInWater( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, neighbor.WaterSurfaceY ); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当当前单元格在水下，而下一个不在时，我们还需要以相反的方向处理瀑布。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !neighbor.IsUnderwater &amp;&amp; neighbor.Elevation &gt; cell.WaterLevel ) { TriangulateWaterfallInWater( e2.v4, e2.v2, e1.v4, e1.v2, neighbor.RiverSurfaceY, cell.RiverSurfaceY, cell.WaterSurfaceY ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们再次得到了原始河的四边形。</font><font style="vertical-align: inherit;">接下来，我们需要进行更改，</font></font><code>TriangulateWaterfallInWater</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便将较低的峰升高到水位。</font><font style="vertical-align: inherit;">不幸的是，仅更改Y坐标是不够的。</font><font style="vertical-align: inherit;">这可以将瀑布从悬崖上推开，可能形成洞。</font><font style="vertical-align: inherit;">相反，您必须使用插值将较低的顶点移动到较高的顶点。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/942/11b/250/94211b250d95b614a5d6be6ff52c9e9e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插值。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要向上移动较低的峰，请将其在水面以下的距离除以瀑布的高度。</font><font style="vertical-align: inherit;">这将为我们提供内插器值。</font></font><br><br><pre> <code class="cs hljs"> v1.y = v2.y = y1; v3.y = v4.y = y2; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = (waterY - y2) / (y1 - y2); v3 = Vector3.Lerp(v3, v1, t); v4 = Vector3.Lerp(v4, v2, t); rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，我们得到了具有相同方向的缩短的瀑布。</font><font style="vertical-align: inherit;">但是，由于下顶点的位置已更改，因此它们不会像原始顶点一样变形。</font><font style="vertical-align: inherit;">这意味着最终结果仍将与原始瀑布不一致。</font><font style="vertical-align: inherit;">为了解决这个问题，我们需要在插值之前手动扭曲顶点，然后添加未扭曲的四边形。</font></font><br><br><pre> <code class="cs hljs"> v1.y = v2.y = y1; v3.y = v4.y = y2; v1 = HexMetrics.Perturb(v1); v2 = HexMetrics.Perturb(v2); v3 = HexMetrics.Perturb(v3); v4 = HexMetrics.Perturb(v4); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = (waterY - y2) / (y1 - y2); v3 = Vector3.Lerp(v3, v1, t); v4 = Vector3.Lerp(v4, v2, t); rivers.AddQuadUnperturbed(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们已经有了添加不变形三角形的方法，因此我们实际上不需要为四边形创建一个。</font><font style="vertical-align: inherit;">因此，我们添加了必要的方法</font></font><code>HexMesh.AddQuadUnperturbed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUnperturbed</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4 </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); vertices.Add(v4); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">3</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc4/605/bdd/dc4605bdd24ed9460b0ca3a310a11fb5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">瀑布终止于水面。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 河口 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当河流以与水面相同的高度流动时，河流网会触及沿海网。如果它是一条流入大海或海洋的河流，那条河将与海浪相遇。因此，我们称此类区域为河口。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddd/27b/efa/ddd27befa12ec543e2969505365b0d91.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这条河与海岸交汇而不会扭曲山峰。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们的嘴巴有两个问题。首先，四角河连接了排骨的第二和第四顶部，跳过了第三。由于水的海岸不使用第三个峰，因此可能会形成一个洞或重叠。我们可以通过更改嘴的几何形状来解决此问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二个问题是泡沫和河流材料之间存在急剧的过渡。为了解决这个问题，我们需要另一种可以将河流和水的影响混合在一起的材料。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这意味着嘴需要一种特殊的方法，因此让我们为它们创建一个单独的方法。</font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当有河流沿当前方向行驶时</font><font style="vertical-align: inherit;">，应调用它</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWaterShore</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, HexCell neighbor, Vector3 center </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary(e1, e2); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { waterShore.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); waterShore.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); waterShore.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); waterShore.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); waterShore.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不需要混合两种效果的区域来填充整个条带。</font><font style="vertical-align: inherit;">梯形足以满足我们的需要。</font><font style="vertical-align: inherit;">因此，我们可以在侧面使用两个沿海三角形。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { waterShore.AddTriangle(e2.v1, e1.v2, e1.v1); waterShore.AddTriangle(e2.v5, e1.v5, e1.v4); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); waterShore.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ece/ca1/fc9/ececa1fc9852f7350a54e00fa71df0b3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">梯形孔为混合区域。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UV2坐标 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要创建河流效果，我们需要UV坐标。</font><font style="vertical-align: inherit;">但是要创建泡沫效果，还需要UV坐标。</font><font style="vertical-align: inherit;">也就是说，在混合它们时，我们需要两组UV坐标。</font><font style="vertical-align: inherit;">幸运的是，Unity引擎网格物体最多可以支持四个UV集。</font><font style="vertical-align: inherit;">我们只需要添加</font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对第二组的支持即可。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates, useUV2Coordinates; [NonSerialized] List&lt;Vector2&gt; uvs, uv2s; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUV2Coordinates) { uv2s = ListPool&lt;Vector2&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">0</span></span>, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUV2Coordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">1</span></span>, uv2s); ListPool&lt;Vector2&gt;.Add(uv2s); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 要添加第二组UV，我们复制使用UV的方法并更改所需的方式。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(uv1); uv2s.Add(uv2); uv2s.Add(uv3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3, Vector3 uv4</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(uv1); uv2s.Add(uv2); uv2s.Add(uv3); uv2s.Add(uv4); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMax, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMax</span></span></span><span class="hljs-function">)</span></span> { uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMin)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMin)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMax)); uv2s.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMax)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 河明暗器功能 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们将在两个着色器中使用river效果，因此将代码从</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器移动</font><font style="vertical-align: inherit;">到新的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> include file函数</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> River (float2 riverUV, sampler2D noiseTex) { float2 uv = riverUV; uv.x = uv.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> + _Time.y * <span class="hljs-number"><span class="hljs-number">0.005</span></span>; uv.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(noiseTex, uv); float2 uv2 = riverUV; uv2.x = uv2.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> - _Time.y * <span class="hljs-number"><span class="hljs-number">0.0052</span></span>; uv2.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.23</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(noiseTex, uv2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noise.x * noise2.w; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器</font><font style="vertical-align: inherit;">以使用此新功能。</font></font><br><br><pre> <code class="hljs pgsql"> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "Water.cginc" sampler2D _MainTex; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, _MainTex); fixed4 c = saturate(_Color + river); … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 口对象 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加</font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">嘴</font><font style="vertical-align: inherit;">以</font><font style="vertical-align: inherit;">支撑网格物体。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads, water, waterShore, estuaries; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); estuaries.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); estuaries.Apply(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建着色器，材质和嘴巴对象，复制海岸并进行更改。</font><font style="vertical-align: inherit;">将其连接到片段，并使其使用UV和UV2坐标。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/77a/7fc/54077a7fc8653228cd723ca855330fed.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象河口。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 口三角剖分 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以通过在河的末端和水的边缘的中间放置一个三角形来解决孔洞或重叠的问题。</font><font style="vertical-align: inherit;">由于我们的嘴部着色器是海岸着色器的副本，因此我们设置UV坐标以匹配泡沫效果。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EdgeVertices e1, EdgeVertices e2</span></span></span><span class="hljs-function">)</span></span> { … estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f02/bb6/f76/f02bb6f768f915d39c05296055cc0b83.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中间三角形。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以通过在中间三角形的两侧添加一个四边形来填充整个梯形。</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuad(e1.v2, e1.v3, e2.v1, e2.v2); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef2/672/e7e/ef2672e7e62b9d66463e4fc44dc43b7a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准备好梯形。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们将四边形方向向左旋转，使其对角线连接缩短，结果我们得到对称的几何形状。</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuad(e2.v1, e1.v2, e2.v2, e1.v3); estuaries.AddTriangle(e1.v3, e2.v2, e2.v4); estuaries.AddQuad(e1.v3, e1.v4, e2.v4, e2.v5); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">// estuaries.AddQuadUV(0f, 0f, 0f, 1f);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd5/dd0/7d1/cd5dd07d1b9f1fb8126e6a5a7c1bc29b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旋转四边形，对称几何</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 河水流量 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了支持河流效果，我们需要添加UV2坐标。</font><font style="vertical-align: inherit;">中间三角形的底部在河流的中间，因此其坐标U应该等于0.5。</font><font style="vertical-align: inherit;">由于河流沿水的方向流动，因此左点接收的U坐标等于1，右点接收的U坐标值为0。我们将Y坐标设置为0和1，对应于水流的方向。</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三角形两侧的四边形应与此方向一致。</font><font style="vertical-align: inherit;">对于超过河流宽度的点，我们保持相同的U坐标。</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a98/475/d50/a98475d50fe84d16eeeff5397f6aa43f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV2梯形。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为确保正确设置UV2坐标，请使</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estuary</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器</font><font style="vertical-align: inherit;">渲染它们。</font><font style="vertical-align: inherit;">我们可以通过添加到输入结构中来访问这些坐标</font></font><code>float2 uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="hljs pgsql"> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 uv2_MainTex; float3 worldPos; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { <span class="hljs-type"><span class="hljs-type">float</span></span> shore = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y; <span class="hljs-type"><span class="hljs-type">float</span></span> foam = Foam(shore, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> waves = Waves(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz, _MainTex); waves *= <span class="hljs-number"><span class="hljs-number">1</span></span> - shore; fixed4 c = fixed4(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/416/d95/efd416d95c7827f264f2f0e8360e6fde.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV2坐标。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一切看起来都不错，您可以使用着色器创建河流效果。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, _MainTex); fixed4 c = saturate(_Color + river); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e3/2c9/fda/0e32c9fda58b356534c2070d0b74adae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用UV2创建河流效果。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们以如下方式创建河流：在对单元格之间的连接进行三角测量时，V河的坐标从0.8更改为1。因此，在这里，我们也应该使用此间隔，而不是从0到1。但是，沿海连接比普通单元连接多50％ 。</font><font style="vertical-align: inherit;">因此，为了最适合河道，我们必须将值从0.8更改为1.1。</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27d/beb/7c6/27dbeb7c67553163422fd560e64ddb03.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/4d9/2e3/b0c4d92e3797274e2534a6921334d184.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">河流与河口同步流动。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 流量设定 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当河水在一条直线上移动时。</font><font style="vertical-align: inherit;">但是，当水流入更大的区域时，它会膨胀。</font><font style="vertical-align: inherit;">电流将弯曲。</font><font style="vertical-align: inherit;">我们可以通过折叠UV2坐标来模拟这一点。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不要将上U坐标在河的宽度之外保持恒定，而是将它们移动0.5。</font><font style="vertical-align: inherit;">最左边的点是1.5，最右边的是-0.5。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同时，我们通过移动左右底点的U坐标来扩展流程。</font><font style="vertical-align: inherit;">将左一个从1更改为0.7，右一个从0更改为0.3。</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); … estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/850/99d/976/85099d97610434a630621e9e06f885ad.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/567/f72/0c1567f72c979734719b298c7850b59e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扩河。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要完成曲率效果，请更改相同四个点的V坐标。</font><font style="vertical-align: inherit;">由于水从河的末端流走，因此我们将较高点的V坐标增加到1。为创建更好的曲线，我们将较低两个点的V坐标增加到1.15。</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/86d/320/1fa86d32037da7fab579ce9a195d1e71.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b07/edb/dfe/b07edbdfeb3615b1a597712a6bda5c8e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这条河的弯道。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 河流和海岸混合 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们剩下的就是将海岸和河流的影响混合在一起。</font><font style="vertical-align: inherit;">为此，我们使用线性插值，将惯性运动值用作插值器。</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> shoreWater = max(foam, waves); <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv2_MainTex, _MainTex); <span class="hljs-type"><span class="hljs-type">float</span></span> water = lerp(shoreWater, river, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x); fixed4 c = saturate(_Color + water);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管这应该可行，但是您可能会遇到编译错误。</font><font style="vertical-align: inherit;">编译器抱怨重新定义</font></font><code>_MainTex_ST</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">原因是由于同时使用</font></font><code>uv_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">引起的Unity表面着色器编译器内部错误</font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们需要找到一种解决方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而不是使用</font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它，我们将不得不手动传输辅助UV坐标。</font><font style="vertical-align: inherit;">为此，请重命名</font></font><code>uv2_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><code>riverUV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后向着色器添加一个顶点函数，该着色器为其指定坐标。</font></font><br><br><pre> <code class="hljs pgsql"> #pragma surface surf Standard alpha vertex:vert … struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float2 riverUV; float3 worldPos; }; … <span class="hljs-type"><span class="hljs-type">void</span></span> vert (<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.riverUV = v.texcoord1.xy; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { … <span class="hljs-type"><span class="hljs-type">float</span></span> river = River(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.riverUV, _MainTex); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/904/b40/c98/904b40c98323b2e9f32bd16513344181.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于海岸值的插值。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插值有效，但顶部的左侧和右侧顶点除外。</font><font style="vertical-align: inherit;">在这些时候，河流应该消失了。</font><font style="vertical-align: inherit;">因此，我们不能使用海岸的价值。</font><font style="vertical-align: inherit;">我们将不得不使用一个不同的值，在这两个顶点处的值为0。幸运的是，我们仍然具有第一个UV集的U坐标，因此我们可以将其存储在那里。</font></font><br><br><pre> <code class="cs hljs"> estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); estuaries.AddQuadUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); <span class="hljs-comment"><span class="hljs-comment">// estuaries.AddQuadUV(0f, 0f, 0f, 1f);</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/e93/432/b34e93432248fb7be818b53aca4d8b20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的搭配。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，河水在不断扩张的河流，沿海水域和泡沫之间相互融合。</font><font style="vertical-align: inherit;">尽管这并不能与瀑布完全匹配，但是这种效果在瀑布中也看起来不错。</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">出海口统一</font></a><i><font style="vertical-align: inherit;">行动</font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 来自水体的河流 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已经有河流流入水域，但是并没有支持向不同方向流动的河流。</font><font style="vertical-align: inherit;">有河流从那里流出的湖泊，因此我们也需要添加它们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当河流从水体中流出时，它实际上会流向更高的高度。</font><font style="vertical-align: inherit;">目前这是不可能的。</font><font style="vertical-align: inherit;">如果水位与目标点的高度相对应，我们需要例外，并允许这种情况。</font><font style="vertical-align: inherit;">让我们添加一个</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私有方法，该方法根据我们的新标准检查邻居是否是流出河的正确目标点。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValidRiverDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell neighbor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor &amp;&amp; ( elevation &gt;= neighbor.elevation || waterLevel == neighbor.elevation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们将使用新方法来确定是否有可能创建流出的河流。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } HexCell neighbor = GetNeighbor(direction); <span class="hljs-comment"><span class="hljs-comment">// if (!neighbor || elevation &lt; neighbor.elevation) { if (!IsValidRiverDestination(neighbor)) { return; } RemoveOutgoingRiver(); … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，在更改单元格或水位的高度时，您需要检查河流。</font><font style="vertical-align: inherit;">让我们创建一个私有方法来执行此任务。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateRivers</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasOutgoingRiver &amp;&amp; !IsValidRiverDestination(GetNeighbor(outgoingRiver)) ) { RemoveOutgoingRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasIncomingRiver &amp;&amp; !GetNeighbor(incomingRiver).IsValidRiverDestination(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) ) { RemoveIncomingRiver(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将在</font></font><code>Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">属性中使用此新方法</font></font><code>WaterLevel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … <span class="hljs-comment"><span class="hljs-comment">// if ( // hasOutgoingRiver &amp;&amp; // elevation &lt; GetNeighbor(outgoingRiver).elevation // ) { // RemoveOutgoingRiver(); // } // if ( // hasIncomingRiver &amp;&amp; // elevation &gt; GetNeighbor(incomingRiver).elevation // ) { // RemoveIncomingRiver(); // } ValidateRivers(); … } } public int WaterLevel { … set { if (waterLevel == value) { return; } waterLevel = value; ValidateRivers(); Refresh(); } }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c04/ca4/b49/c04ca4b49ccff20e71dba70dc1a2bea7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出入河湖。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 扭转潮流 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们创建了</font></font><code>HexGridChunk.TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，暗示河流只能流入水域。</font><font style="vertical-align: inherit;">因此，结果，河道总是沿一个方向移动。</font><font style="vertical-align: inherit;">当处理从水体流出的河流时，我们需要逆向流动。</font><font style="vertical-align: inherit;">为此，您需要</font></font><code>TriangulateEstuary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解流向。</font><font style="vertical-align: inherit;">因此，我们给他一个布尔参数，该布尔参数确定我们是否在处理传入的河流。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver </span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当从中调用此方法时，我们将传递此信息</font></font><code>TriangulateWaterShore</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { TriangulateEstuary(e1, e2, cell.IncomingRiver == direction); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们需要通过更改UV2的坐标来扩展河流流量。</font><font style="vertical-align: inherit;">需要镜像出河的U坐标：-0.5变为1.5，0变为1，1变为0，1.5变为-0.5。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用V坐标，情况会稍微复杂一些。</font><font style="vertical-align: inherit;">如果您看一下我们如何处理反向河流连接，那么0.8应该是0，而1应该是-0.2。</font><font style="vertical-align: inherit;">这意味着1.1变为-0.3，而1.15变为-0.35。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于每种情况下的UV2坐标都非常不同，因此让我们为它们编写一个单独的代码。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEstuary</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, EdgeVertices e2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> incomingRiver </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (incomingRiver) { estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">1.15f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.2f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.3f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.35f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>) ); estuaries.AddTriangleUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); estuaries.AddQuadUV2( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.3f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.35f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1.5f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.2f</span></span>) ); } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的河流路线。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第9部分：救济特征 </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 向浮雕中添加对象。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们创建对对象密度级别的支持。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们在关卡中使用各种对象。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 混合三种不同类型的对象。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这一部分中，我们将讨论将对象添加到地形。</font><font style="vertical-align: inherit;">我们将创建诸如建筑物和树木之类的对象。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8b/1ec/f84/b8b1ecf8496a03d50c881bbd47c262ad.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">森林，农业用地与城市化之间的冲突。</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 添加对对象的支持 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管浮雕的形状有所变化，但到目前为止，没有任何变化。</font><font style="vertical-align: inherit;">这是一片死气沉沉的土地。</font><font style="vertical-align: inherit;">为了让生活充满活力，您需要添加此类对象。</font><font style="vertical-align: inherit;">像树木和房屋。</font><font style="vertical-align: inherit;">这些对象不是浮雕网格的一部分，而是单独的对象。</font><font style="vertical-align: inherit;">但这并不能阻止我们在对地形进行三角剖分时添加它们。</font></font><br><br> <code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不在乎网格如何工作。</font><font style="vertical-align: inherit;">他只是命令他的一个孩子</font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加一个三角形或四边形。</font><font style="vertical-align: inherit;">同样，它可以具有一个子元素，用于处理对象在其上的放置。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 对象管理器 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们创建一个组件</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该组件</font><font style="vertical-align: inherit;">负责单个片段中的对象。</font><font style="vertical-align: inherit;">我们使用与</font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给他方法</font><font style="vertical-align: inherit;">相同的方案</font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">由于需要将对象放置在某处，因此该方法将</font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接收position参数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将从一个空白的实现开始，目前暂时什么也不做。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexFeatureManager</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> {} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以在中添加指向此类组件的链接</font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后，您可以像所有子元素一样将其包括在三角测量过程中</font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexFeatureManager features; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); water.Clear(); waterShore.Clear(); estuaries.Clear(); features.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); water.Apply(); waterShore.Apply(); estuaries.Apply(); features.Apply(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 首先，在每个单元格的中心放置一个对象 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } features.AddFeature(cell.Position); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们需要一个真正的对象管理器。</font><font style="vertical-align: inherit;">向</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制件中添加</font><font style="vertical-align: inherit;">一个子代，并给它一个组件</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后，您可以将片段连接到它。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eeb/1f4/626/eeb1f462652650c6dfe5e3cb34a2ec12.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51b/7ec/8f2/51b7ec8f20b4a79589fd2b464744230b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/c6f/8cd/620c6f8cd7c54c52597fcc289b160c57.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象管理器添加到片段预制中。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 预制物件 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将创建什么地形对象？</font><font style="vertical-align: inherit;">对于第一个测试，立方体非常适合。</font><font style="vertical-align: inherit;">让我们创建一个足够大的多维数据集，例如，缩放比例为（3，3，3），然后将其变成预制件。</font><font style="vertical-align: inherit;">也为他创造材料。</font><font style="vertical-align: inherit;">我使用默认材质和红色。</font><font style="vertical-align: inherit;">让我们删除它的对撞机，因为我们不需要它。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7a/1b1/315/a7a1b1315e7f2756ac2940dac661f95a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制立方体。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象管理器将需要一个指向该预制件的链接，因此将其添加到</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后进行连接。</font><font style="vertical-align: inherit;">由于需要访问转换组件才能放置对象，因此我们将其用作链接的类型。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform featurePrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfc/34d/e84/cfc34de84fbc12ac5fde17d7d1d09b58.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制对象管理器。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建对象实例 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构已经准备就绪，我们可以开始添加地形要素了！</font><font style="vertical-align: inherit;">只需在其中创建一个预制实例</font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并设置其位置即可。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); instance.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd8/59c/ae5/dd859cae56fa9439e91d0ccb5d659f62.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地形要素实例。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从现在开始，地形将充满立方体。</font><font style="vertical-align: inherit;">至少是立方体的上半部分，因为在Unity中立方体网格的本地原点在立方体的中心，而底部在凸版的表面下方。</font><font style="vertical-align: inherit;">要将立方体放置在地形上，我们需要将其上移一半的高度。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/6be/89b/bb06be89b647d5ff29f1894bfdcf199b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浮雕表面上的立方体。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们使用另一个网格怎么办？</font></font></b> <div class="spoiler_text">       .     ,      ,        .       . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，我们的单元会变形，因此我们需要扭曲对象的位置。</font><font style="vertical-align: inherit;">因此，我们摆脱了完美的网格重复性。</font></font><br><br><pre> <code class="cs hljs"> instance.localPosition = HexMetrics.Perturb(position);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e5/7ec/a43/9e57eca43cf9127691cb5eb11bc6a11a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象的位置变形。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 破坏救济物 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每次更新片段时，我们都会创建新的救济对象。</font><font style="vertical-align: inherit;">这意味着当我们在相同位置创建越来越多的对象时。</font><font style="vertical-align: inherit;">为避免重复，清洁碎片时我们需要清除旧物体。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最快的方法是创建一个游戏容器对象，并将所有释放对象变成其子对象。</font><font style="vertical-align: inherit;">然后，当被调用时，</font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将销毁该容器并创建一个新容器。</font><font style="vertical-align: inherit;">容器本身将是其管理者的孩子。</font></font><br><br><pre> <code class="cs hljs"> Transform container; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (container) { Destroy(container.gameObject); } container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GameObject(<span class="hljs-string"><span class="hljs-string">"Features Container"</span></span>).transform; container.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能每次创建和销毁救济对象的效率都很低。</font></font></b> <div class="spoiler_text"> , ,   .       .      .   ,  ,      ,    .          <code>HexFeatureManager.Apply</code> .      .  ,    ,       . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 救济物的放置 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我们将对象放置在每个单元格的中心时。</font><font style="vertical-align: inherit;">对于空的单元格，这看起来很正常，但是在包含河流和道路以及被水淹没的单元格上，这似乎很奇怪。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01d/e88/ab8/01de88ab8777d38afeb4ca374571a2f1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象无处不在。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，让我们在放置对象之前检查</font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单元格是否为空。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell.Position); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5db/b98/75f/5dbb9875f8510c7f9224f8ba10465ae4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有限的住宿。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 每个方向一个对象 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个单元格只有一个对象不是太多。</font><font style="vertical-align: inherit;">仍然有足够的空间容纳一堆物品。</font><font style="vertical-align: inherit;">因此，我们向该单元格的六个三角形中的每个三角形的中心添加一个附加对象，即每个方向一个。</font><font style="vertical-align: inherit;">当我们知道该单元格中没有河流时，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将以另一种方法进行此操作</font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们仍然需要检查是否在水下以及牢房中是否有道路。</font><font style="vertical-align: inherit;">但是在这种情况下，我们只对沿当前方向行驶的道路感兴趣。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithoutRiver(direction, cell, center, e); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature((center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/b60/d4b/7e7b60d4b54d2f9a7b3119e78554507a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设施很多，但是不在河流附近。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这会创建更多对象！</font><font style="vertical-align: inherit;">它们出现在道路附近，但仍然避开河流。</font><font style="vertical-align: inherit;">要沿河流放置对象，我们还可以在其中添加对象</font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，仅当三角形不在水下且上面没有路时，才再次出现。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature((center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30c/90a/f9f/30c90af9ffb31cec360ea027fc4f1815.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物体出现在河边。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以渲染这么多对象吗？</font></font></b> <div class="spoiler_text">       ,    dynamic batching  Unity.    ,       .         batch.     « »,       .    instancing,          dynamic batching. </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 各种物体 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们所有的浮雕对象都具有相同的方向，这看起来完全不自然。</font><font style="vertical-align: inherit;">让我们给每个人一个随机的转折。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b42/8bd/0bc/b428bd0bcb9b27676853f7bb1e491165.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随机回合。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此结果变得更加多样化。</font><font style="vertical-align: inherit;">不幸的是，每次更新片段时，对象都会收到新的随机旋转。</font><font style="vertical-align: inherit;">编辑单元格不应更改附近的对象，因此我们需要另一种方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们具有始终相同的噪声纹理。</font><font style="vertical-align: inherit;">但是，此纹理包含Perlin梯度噪声，并且局部一致。</font><font style="vertical-align: inherit;">这正是使单元格中顶点的位置失真时所需要的。</font><font style="vertical-align: inherit;">但是转弯不必保持一致。</font><font style="vertical-align: inherit;">所有转弯都应同样可能且混合。</font><font style="vertical-align: inherit;">因此，我们需要一个具有非渐变随机值的纹理，无需双线性滤波即可对其进行采样。</font><font style="vertical-align: inherit;">本质上，这是一个哈希网格，它构成了梯度噪声的基础。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建哈希表 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以从浮点值数组创建哈希表，并用随机值填充一次。</font><font style="vertical-align: inherit;">因此，我们根本不需要纹理。</font><font style="vertical-align: inherit;">让我们将其添加到中</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">256 x 256的大小足以实现足够的变化。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hashGridSize = <span class="hljs-number"><span class="hljs-number">256</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] hashGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[hashGridSize * hashGridSize]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随机值由始终提供相同结果的数学公式生成。</font><font style="vertical-align: inherit;">结果序列取决于种子的数量，默认情况下，该数量等于时间的当前值。</font><font style="vertical-align: inherit;">这就是为什么在每个游戏环节我们都会得到不同的结果的原因。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了确保始终创建相同的对象，我们需要将种子参数添加到初始化方法中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seed</span></span></span><span class="hljs-function">)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[hashGridSize * hashGridSize]; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们已经初始化了随机数流，我们将始终从中获得相同的序列。</font><font style="vertical-align: inherit;">因此，在生成地图之后发生的看似随机事件也将始终相同。</font><font style="vertical-align: inherit;">我们可以通过在初始化随机数生成器之前存储其状态来避免这种情况。</font><font style="vertical-align: inherit;">完成工作后，我们可以问他以前的状态。</font></font><br><br><pre> <code class="cs hljs"> Random.State currentState = Random.state; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } Random.state = currentState;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈希表</font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在分配噪声纹理的同时</font><font style="vertical-align: inherit;">被初始化</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">也就是说，在</font></font><code>HexGrid.Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和中</font></font><code>HexGrid.Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们这样做是为了避免不必要地频繁生成值。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> seed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!HexMetrics.noiseSource) { HexMetrics.noiseSource = noiseSource; HexMetrics.InitializeHashGrid(seed); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用种子变量允许我们选择地图的种子值。</font><font style="vertical-align: inherit;">任何值都可以。</font><font style="vertical-align: inherit;">我选择了1234。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60c/8b3/5a3/60c8b35a3b6a92b61165ed3a00473076.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">种子的选择。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使用哈希表 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要使用哈希表，请添加到</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">采样方法。</font><font style="vertical-align: inherit;">像一样</font></font><code>SampleNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它使用XZ位置的坐标来获取值。</font><font style="vertical-align: inherit;">通过将坐标限制为整数值，然后获取整数除以表的大小，可以找到哈希索引。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.x % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.z % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashGrid[x + z * hashGridSize]; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">％做什么？</font></font></b> <div class="spoiler_text">   ,     ,    —  . ,  −4, −3, −2, −1, 0, 1, 2, 3, 4 modulo 3   −1, 0, −2, −1, 0, 1, 2, 0, 1. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这适用于正坐标，但不适用于负坐标，因为对于此类数字，余数将为负。</font><font style="vertical-align: inherit;">我们可以通过将表的大小添加到负面结果中来解决此问题。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.x % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)position.z % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { z += hashGridSize; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们为每个平方单位创建自己的价值。</font><font style="vertical-align: inherit;">但是，实际上，我们不需要这样的表密度。</font><font style="vertical-align: inherit;">对象彼此隔开。</font><font style="vertical-align: inherit;">我们可以通过在计算索引之前减小位置比例来拉伸表格。</font><font style="vertical-align: inherit;">一个4乘4平方的唯一值就足够了。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hashGridScale = <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(position.x * hashGridScale) % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { x += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(position.z * hashGridScale) % hashGridSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { z += hashGridSize; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hashGrid[x + z * hashGridSize]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们回到</font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并使用新的哈希表来获取值。</font><font style="vertical-align: inherit;">应用它指定旋转后，在编辑地形时对象将保持静止。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> hash = HexMetrics.SampleHashGrid(position); Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 放置阈值 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管对象具有不同的旋转角度，但是在其位置上仍然可以看到图案。</font><font style="vertical-align: inherit;">每个单元都有七个对象。</font><font style="vertical-align: inherit;">我们可以给这个方案增加混乱，任意跳过一些对象。</font><font style="vertical-align: inherit;">我们如何决定是否添加对象？</font><font style="vertical-align: inherit;">当然，请检查另一个随机值！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，现在，我们需要两个而不是一个哈希值。</font><font style="vertical-align: inherit;">可以通过使用哈希代替表数组类型的</font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">来增加对它们的支持</font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是向量运算对于散列值没有意义，因此让我们为此创建一个特殊的结构。</font><font style="vertical-align: inherit;">她只需要两个浮点值。</font><font style="vertical-align: inherit;">让我们添加一个静态方法来创建一对随机值。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexHash { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不需要序列化吗？</font></font></b> <div class="spoiler_text">        ,  ,        Unity. ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对其进行更改，</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以使其使用新结构。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HexHash[] hashGrid; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> seed</span></span></span><span class="hljs-function">)</span></span> { hashGrid = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexHash[hashGridSize * hashGridSize]; Random.State currentState = Random.state; Random.InitState(seed); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; hashGrid.Length; i++) { hashGrid[i] = HexHash.Create(); } Random.state = currentState; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleHashGrid</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在</font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以访问两个哈希值。</font><font style="vertical-align: inherit;">让我们使用第一个来决定是添加对象还是跳过对象。</font><font style="vertical-align: inherit;">如果该值等于或大于0.5，则跳过。</font><font style="vertical-align: inherit;">这样，我们将摆脱大约一半的对象。</font><font style="vertical-align: inherit;">第二个值将照常用于确定旋转角度。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash.a &gt;= <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Transform instance = Instantiate(featurePrefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.b, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e89/e69/761/e89e697613f8eef3d149b07720e8a26a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物体的密度降低了50％。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 绘图对象 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与其将对象放置在各处，不如让它们可编辑。</font><font style="vertical-align: inherit;">但是我们不会绘制单独的对象，而是将对象的级别添加到每个单元格中。</font><font style="vertical-align: inherit;">此级别将控制对象出现在单元中的可能性。</font><font style="vertical-align: inherit;">默认情况下，该值为零，即不存在对象。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们地形上的红色立方体看起来不像自然物体，因此我们将其称为建筑物。</font><font style="vertical-align: inherit;">它们将代表城市化。</font><font style="vertical-align: inherit;">让我们增加</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">城市化水平。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UrbanLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (urbanLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { urbanLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urbanLevel;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以使水下单元格的城市化水平等于零，但这不是必需的，无论如何我们将跳过水下对象的创建。</font><font style="vertical-align: inherit;">也许在某个时候，我们将添加城市化的水体，例如码头和水下建筑物。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 密度滑块 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了改变城市化水平，我们增加了</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个滑块。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel; … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyUrbanLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyUrbanLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetUrbanLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeUrbanLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将另一个滑块添加到UI并将其与适当的方法结合。</font><font style="vertical-align: inherit;">我将在屏幕的右侧放置一个新面板，以避免溢出左侧面板。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们需要几个级别？</font><font style="vertical-align: inherit;">让我们详细介绍四个，分别表示零，低，中和高密度。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/e64/996/02fe649968954603df834d2a3b5f633b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/9e4/6f5/95e9e46f5ff83a9b7d713e85db86d67a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">城市化滑块。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 阈值变化 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们已经有了城市化水平，我们需要使用它来确定是否放置物体。</font><font style="vertical-align: inherit;">为此，我们需要将城市化水平作为的附加参数</font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">让我们再迈出一步，只转移单元格本身。</font><font style="vertical-align: inherit;">将来，它将为我们带来更多便利。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用城市化水平的最快方法是将其乘以0.25，然后将该值用作跳过对象的新阈值。</font><font style="vertical-align: inherit;">因此，每个级别的物体出现的可能性都会增加25％。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash.a &gt;= cell.UrbanLevel * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，让我们将单元格传递给</font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature(cell, (center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } … } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRoadThroughEdge(direction)) { features.AddFeature(cell, (center + e.v1 + e.v5) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>)); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd8/7e9/de5/fd87e9de5b6b6ea4b4b490549ae5cbf5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">绘制城市化密度水平。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 几种救济物预制件 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物体出现可能性的差异不足以在低水平的城市化与高水平的城市化之间建立明显的隔离。在某些单元中，建筑物的数量或多或少都将少于预期数量。通过为每个级别使用我们自己的预制件，我们可以使差异更加清晰。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将摆脱这个领域</font></font><code>featurePrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而将其替换为用于城市化预制件的阵列。为了获得合适的预制件，我们将从城市化水平中减去一个，并将其用作指标。</font></font><br><br><pre> <code class="cs hljs">&lt;del&gt;<span class="hljs-comment"><span class="hljs-comment">// public Transform featurePrefab;&lt;/del&gt; public Transform[] urbanPrefabs; public void AddFeature (HexCell cell, Vector3 position) { … Transform instance = Instantiate(urbanPrefabs[cell.UrbanLevel - 1]); … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建对象的预制件的两个副本，重命名并更改它们，以便它们指示三个不同的城市化水平。</font><font style="vertical-align: inherit;">级别1是低密度的，因此我们使用单位长度为边的立方体表示棚屋。</font><font style="vertical-align: inherit;">我会将2层预制件的比例缩放为（1.5，2，1.5），以使其看起来像一座两层楼的建筑。</font><font style="vertical-align: inherit;">对于3层较高的建筑物，我使用了比例尺（2、5、2）。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b83/4ad/cb6/b834adcb61a34d1e30cdec28925f066f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4f/41d/552/d4f41d5529d4716924345520ffc36280.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为城市化的每个级别使用不同的预制件。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 预制混合物 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不需要严格限制建筑物的类型。您可以将它们混在一起，就像在现实世界中一样。让我们使用三个，而不是每个级别一个阈值，每种类型的建筑物一个。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第1级，我们在40％的情况下使用棚屋布置。这里根本没有其他建筑物。对于级别，我们使用三个值（0.4、0、0）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第2层，用更大的建筑物代替棚屋，并增加20％的机会增加棚屋。我们不会做高层建​​筑。也就是说，我们使用阈值三个值（0.2、0.4、0）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第3层，我们将高层建筑替换为中型建筑，再次替换棚屋，再增加20％的棚屋机会。阈值将等于（0.2，0.2，0.4）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，我们的想法是随着城市化水平的提高，我们将升级现有建筑物并将新建筑物添加到空旷的地方。要删除现有建筑物，我们需要使用相同的哈希值间隔。如果级别1的0到0.4之间的哈希值是棚屋，那么级别3的相同间隔将创建高层建筑物。在第3层，应创建具有0-0.4范围内的哈希值，0.4-0.6范围内的两层建筑物以及0.6-0.8范围内的棚屋的高层建筑物。如果从最大到最小检查它们，则可以使用三个阈值（0.4、0.6、0.8）来完成。然后，级别2的阈值将变为（0，0.4，0.6），级别1的阈值将变为（0，0，0.4）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们将这些阈值保存在</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为数组的集合，其方法允许您获取特定级别的阈值。</font><font style="vertical-align: inherit;">由于我们仅对带有对象的级别感兴趣，因此忽略级别0。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[][] featureThresholds = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] {<span class="hljs-number"><span class="hljs-number">0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFeatureThresholds</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> featureThresholds[level]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，添加到</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用哈希级别和值来选择预制的方法。</font><font style="vertical-align: inherit;">如果该级别大于零，那么我们使用减少了一个级别的阈值来获得阈值。</font><font style="vertical-align: inherit;">然后，我们循环遍历阈值，直到其中一个阈值超过哈希值为止。</font><font style="vertical-align: inherit;">这意味着我们已经找到了预制件。</font><font style="vertical-align: inherit;">如果找不到，则返回null。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanPrefabs[i]; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这种方法要求对预制件的链接进行重新排序，以使它们从高密度变为低密度。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/eb5/80e/4dceb580e2410400a003b2ecad72d5c5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制订单倒置。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将使用新方法</font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来选择预制件。</font><font style="vertical-align: inherit;">如果没有收到，则跳过该对象。</font><font style="vertical-align: inherit;">否则，创建它的一个实例，然后像以前一样继续。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); <span class="hljs-comment"><span class="hljs-comment">// if (hash.a &gt;= cell.UrbanLevel * 0.25f) { // return; // } // Transform instance = Instantiate(urbanPrefabs[cell.UrbanLevel - 1]); Transform prefab = PickPrefab(cell.UrbanLevel, hash.a); if (!prefab) { return; } Transform instance = Instantiate(prefab); position.y += instance.localScale.y * 0.5f; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(0f, 360f * hash.b, 0f); instance.SetParent(container, false); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d33/6f0/fcb/d336f0fcbf85285b38bb9c3de27ad77f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">混合预制件。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 水平变化 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们有混合的建筑物，但是到目前为止只有三座。</font><font style="vertical-align: inherit;">我们可以通过将预制件的集合与城市化密度的各个级别联系起来，进一步提高可变性。</font><font style="vertical-align: inherit;">之后，可以随机选择其中之一。</font><font style="vertical-align: inherit;">这将需要一个新的随机值，因此添加第三个c </font></font><code>HexHash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们将其</font></font><code>HexFeatureManager.urbanPrefabs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变成一个数组数组，然后向method中添加一个</font></font><code>PickPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数</font></font><code>choice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们使用它来选择内置数组的索引，将其乘以该数组的长度，然后将其转换为整数。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[][] urbanPrefabs; … <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urbanPrefabs[i][(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(choice * urbanPrefabs[i].Length)]; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们根据第二个哈希（B）的值来证明我们的选择。</font><font style="vertical-align: inherit;">然后，您需要从B转到C。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); Transform prefab = PickPrefab(cell.UrbanLevel, hash.a, hash.b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!prefab) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Transform instance = Instantiate(prefab); position.y += instance.localScale.y * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.localPosition = HexMetrics.Perturb(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.c, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在继续之前，我们需要考虑</font></font><code>Random.value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能返回值1的内容。因此，数组索引可能会超出范围。</font><font style="vertical-align: inherit;">为了防止这种情况的发生，让我们稍微调整一下哈希值。</font><font style="vertical-align: inherit;">我们只是将它们全部缩放，以免担心我们使用的特定对象。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，检查器不会显示数组的数组。</font><font style="vertical-align: inherit;">因此，我们无法对其进行配置。</font><font style="vertical-align: inherit;">要解决此限制，请创建一个可序列化的结构以将内置数组封装到其中。</font><font style="vertical-align: inherit;">让我们给她一个方法，该方法可以从选择转换为数组索引并返回一个预制。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexFeatureCollection { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[] prefabs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pick</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prefabs[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(choice * prefabs.Length)]; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此类集合的数组代替内置数组。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public Transform[][] urbanPrefabs; public HexFeatureCollection[] urbanCollections; … Transform PickPrefab (int level, float hash, float choice) { if (level &gt; 0) { float[] thresholds = HexMetrics.GetFeatureThresholds(level - 1); for (int i = 0; i &lt; thresholds.Length; i++) { if (hash &lt; thresholds[i]) { return urbanCollections[i].Pick(choice); } } } return null; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以为每个密度级别分配几座建筑物。</font><font style="vertical-align: inherit;">由于它们是独立的，因此我们不必在每个级别使用相同的数量。</font><font style="vertical-align: inherit;">我只在每个级别上使用了两个选项，为每个级别添加了一个更长的较低选项。</font><font style="vertical-align: inherit;">我为它们选择了比例（3.5、3、2），（2.75、1.5、1.5）和（1.75、1、1）。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/a6e/c9f/b71a6ec9f2c379c223e007dda071c94b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a72/618/81d/a7261881d23703b54aaf22ba59942d2a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个密度级别有两种类型的建筑物。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 几种物体 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在现有方案中，我们可以创建相当有价值的城市结构。</font><font style="vertical-align: inherit;">但救济可能不仅包括建筑物。</font><font style="vertical-align: inherit;">农场或植物怎么样？</font><font style="vertical-align: inherit;">让我们</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为它们</font><font style="vertical-align: inherit;">添加</font><font style="vertical-align: inherit;">级别。</font><font style="vertical-align: inherit;">它们不是互斥的并且可以混合。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FarmLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> farmLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (farmLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { farmLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PlantLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> plantLevel; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (plantLevel != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { plantLevel = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> urbanLevel, farmLevel, plantLevel;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，这需要</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外两个滑块的</font><font style="vertical-align: inherit;">支持</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel, activeFarmLevel, activePlantLevel; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel, applyFarmLevel, applyPlantLevel; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyFarmLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyFarmLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFarmLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activeFarmLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyPlantLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyPlantLevel = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPlantLevel</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level</span></span></span><span class="hljs-function">)</span></span> { activePlantLevel = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)level; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyFarmLevel) { cell.FarmLevel = activeFarmLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyPlantLevel) { cell.PlantLevel = activePlantLevel; } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将它们添加到用户界面。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/70b/f35/95670bf35594faa69fe46201b78080f7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三个滑块。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，将需要其他集合</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexFeatureCollection[] urbanCollections, farmCollections, plantCollections;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5d/001/cec/f5d001cecb2bee3c60a0dad637de7dc9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">救济对象的三个集合。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我为农场和工厂创建了每个密度级别的两个预制件，以及建筑物集合。对于所有这些，我都使用了多维数据集。农场有浅绿色的物质，植物有深绿色的物质。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我制作了高度为0.1个单位的农场立方体，以表示农田的方形分配。作为高密度标度，我选择了（2.5，0.1，2.5）和（3.5，0.1，2）。平均而言，站点的面积为1.75，大小为2.5 x 1.25。在区域1处获得的密度较低，尺寸为1.5 x 0.75。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制植物表示高大的树木和大型灌木。高密度预制件最大，分别为（1.25，4.5，1.25）和（1.5，3，1.5）。平均比例为（0.75、3、0.75）和（1、1.5、1）。最小的植物大小分别为（0.5、1.5、0.5）和（0.75、1、0.75）。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 浮雕特征的选择 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每种类型的对象都必须接收自己的哈希值，以便它们具有不同的创建模式，并且可以混合使用它们。</font><font style="vertical-align: inherit;">添加</font></font><code>HexHash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个附加值。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, b, c, d, e; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexHash </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexHash hash; hash.a = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.b = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.c = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.d = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; hash.e = Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * <span class="hljs-number"><span class="hljs-number">0.999f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，您必须</font></font><code>HexFeatureManager.PickPrefab</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用不同的集合。</font><font style="vertical-align: inherit;">添加参数以简化过程。</font><font style="vertical-align: inherit;">另外，将所选预制件的变体使用的哈希更改为D，并将旋转的哈希更改为E。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Transform </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PickPrefab</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexFeatureCollection[] collection, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> level, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> choice </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] thresholds = HexMetrics.GetFeatureThresholds(level - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thresholds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash &lt; thresholds[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection[i].Pick(choice); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { HexHash hash = HexMetrics.SampleHashGrid(position); Transform prefab = PickPrefab( urbanCollections, cell.UrbanLevel, hash.a, hash.d ); … instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.e, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目前</font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择预制城市化。</font><font style="vertical-align: inherit;">这是正常现象，我们需要更多选择。</font><font style="vertical-align: inherit;">因此，我们从农场中添加了另一个预制件。</font><font style="vertical-align: inherit;">作为哈希值，请使用B。选项的选择将再次为D。</font></font><br><br><pre> <code class="cs hljs"> Transform prefab = PickPrefab( urbanCollections, cell.UrbanLevel, hash.a, hash.d ); Transform otherPrefab = PickPrefab( farmCollections, cell.FarmLevel, hash.b, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!prefab) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结果，我们将创建哪种预制实例？</font><font style="vertical-align: inherit;">如果其中之一为空，则选择是显而易见的。</font><font style="vertical-align: inherit;">但是，如果两者都存在，那么我们需要做出决定。</font><font style="vertical-align: inherit;">我们只添加具有最低哈希值的预制件。</font></font><br><br><pre> <code class="cs hljs"> Transform otherPrefab = PickPrefab( farmCollections, cell.FarmLevel, hash.b, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baf/369/d71/baf369d71420a1ded309880b38d94c53.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">城乡混合体。</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，使用C哈希值对植物进行相同的处理。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } otherPrefab = PickPrefab( plantCollections, cell.PlantLevel, hash.c, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.c &lt; hash.a) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，我们不能只复制代码。</font><font style="vertical-align: inherit;">当我们选择农村而不是城市对象时，我们需要将植物的哈希与农场的哈希进行比较，而不是与城市的哈希进行比较。</font><font style="vertical-align: inherit;">因此，我们需要跟踪我们决定选择的哈希并与之进行比较。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> usedHash = hash.a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.b &lt; hash.a) { prefab = otherPrefab; usedHash = hash.b; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; usedHash = hash.b; } otherPrefab = PickPrefab( plantCollections, cell.PlantLevel, hash.c, hash.d ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prefab) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab &amp;&amp; hash.c &lt; usedHash) { prefab = otherPrefab; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherPrefab) { prefab = otherPrefab; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8eb/2e2/215/8eb2e2215e6219b08e8bc42612b31493.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">城市，农村和植物的混合物。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第10部分：墙 </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们围住单元格。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们沿着细胞边缘建造墙。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们穿越河流和道路。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 避免浇水，并与悬崖相连。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在这一部分中，我们将在墙的单元之间添加。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/924/d07/0cd/924d070cd67c3baccf02a0284ef9cdc4.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有什么比一堵高墙更具吸引力了。</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 墙面编辑 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了支撑墙壁，我们需要知道将墙壁放置在何处。</font><font style="vertical-align: inherit;">我们将它们沿着连接它们的边缘放在单元之间。</font><font style="vertical-align: inherit;">由于已经存在的对象位于单元的中央，因此我们不必担心壁会穿过它们。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/bbb/c11/7a1bbbc1158301bb0091638858fa79fd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沿边缘的墙壁。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙是地形物体，尽管很大。</font><font style="vertical-align: inherit;">与其他对象一样，我们不会直接对其进行编辑。</font><font style="vertical-align: inherit;">相反，我们将更改单元格。</font><font style="vertical-align: inherit;">我们不会在墙壁上有单独的部分，但是会把整个细胞围起来。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 城墙财产 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要支持围栅单元，请添加到</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性</font></font><code>Walled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个简单的开关。</font><font style="vertical-align: inherit;">由于墙壁位于单元之间，因此我们需要更新已编辑的单元及其相邻单元。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Walled { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> walled; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (walled != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { walled = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> walled;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 编辑器开关 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要切换单元格的“隔离状态”，我们需要添加</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对切​​换的支持。</font><font style="vertical-align: inherit;">因此，我们添加了另一个字段</font></font><code>OptionalToggle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及其设置方法。</font></font><br><br><pre> <code class="cs hljs"> OptionalToggle riverMode, roadMode, walledMode; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWalledMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { walledMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与河流和道路不同，围墙不是从一个单元到另一个单元的，而是在它们之间。</font><font style="vertical-align: inherit;">因此，我们无需考虑拖放。</font><font style="vertical-align: inherit;">当墙壁开关处于活动状态时，我们仅基于此开关的状态来设置当前单元的隔离状态。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.No) { cell.RemoveRoads(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (walledMode != OptionalToggle.Ignore) { cell.Walled = walledMode == OptionalToggle.Yes; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag) { … } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们复制UI开关的先前元素之一，并对其进行更改，以使它们控制“围栏”的状态。</font><font style="vertical-align: inherit;">我将它们与其他对象一起放在UI面板中。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ac/f7f/0ca/0acf7f0caaaae171e31d42141fa75947.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开关“围栏”。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 创建墙 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于壁遵循单元的轮廓，因此它们不应具有恒定的形状。</font><font style="vertical-align: inherit;">因此，我们不能像其他地形特征那样仅对它们使用预制件。</font><font style="vertical-align: inherit;">相反，我们需要像使用浮雕一样构建一个网格。</font><font style="vertical-align: inherit;">这意味着我们的预制片段需要另一个子元素</font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">复制其他子网格之一，并使新的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walls</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">投射阴影。</font><font style="vertical-align: inherit;">除了顶点和三角形外，它们不需要任何其他内容，因此</font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须禁用</font><font style="vertical-align: inherit;">所有选项</font><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/615/387/31d/61538731d2eed271c9348c4da2f5d844.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2bf/c6e/af5/2bfc6eaf5ff31f5467ab252c00b7bcce.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">子公司预制墙。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙壁是城市物体，这是合乎逻辑的，所以对于它们，我使用建筑物的红色材料。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 墙面管理 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于墙壁是救济的对象，因此必须加以处理</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，我们将给救济对象的管理者一个指向</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walls</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象的链接</font><font style="vertical-align: inherit;">，并使它调用</font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">方法</font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh walls; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … walls.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { walls.Apply(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/8f9/0f3/31d8f90f315c7aa43910c67aab6b73cb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙连接到地形管理器。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Walls不应该成为Feature的子代吗？</font></font></b> <div class="spoiler_text">       ,   .             ,    <em>Walls</em>    <em>Hex Grid Chunk</em> . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们需要向管理器添加一个方法，该方法允许我们向其添加墙。</font><font style="vertical-align: inherit;">由于墙壁沿着单元之间的边缘，因此他需要知道边缘和单元的相应顶点。</font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会</font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在对单元格及其邻居之一进行三角剖分时</font><font style="vertical-align: inherit;">使其通过</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从这个角度来看，当前单元格在墙的近侧，另一个在远侧。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"></font><code>HexGridChunk.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在完成所有其他连接工作之后以及紧接过渡到三角形三角形之前，</font><font style="vertical-align: inherit;">我们将调用此新方法</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将让救济对象的管理者自己决定墙应实际位于的位置。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { … } features.AddWall(e1, cell, e2, neighbor); HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { … } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 建造墙段 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整个墙壁将蜿蜒穿过细胞的几个边缘。</font><font style="vertical-align: inherit;">每个边缘仅包含一个墙元素。</font><font style="vertical-align: inherit;">从近单元的角度来看，该段从肋的左侧开始，在右侧终止。</font><font style="vertical-align: inherit;">让我们添加一个</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单独的方法，该方法在一条边的角上使用四个顶点。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/2a0/d7b/f322a0d7bc325b13f65c62cfb76b2d0c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">近端和远端。</font></font></i> <br><br> <code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以使用边缘的第一个和最后一个边缘调用此方法。</font><font style="vertical-align: inherit;">但是，仅当我们在围栅单元和非围栅单元之间建立连接时，才应添加墙。</font><font style="vertical-align: inherit;">哪一个单元在内部和哪个单元在外部都没有关系，仅考虑其状态的差异。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v5, far.v5); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙的最简单部分是四分之一，位于肋骨的中间。</font><font style="vertical-align: inherit;">我们会发现其较低的峰，从最近到最远的峰插值到中间。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙应该多高？</font><font style="vertical-align: inherit;">让我们将其高度设置为</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我将它们设置为一个单元格高度级别的大小。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallHeight = <span class="hljs-number"><span class="hljs-number">3f</span></span>;</code> </pre> <br> <code>HexFeatureManager.AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以使用此高度来定位四边形的第三和第四顶点，并将其添加到网格中</font></font><code>walls</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 v1, v2, v3, v4; v1 = v3 = left; v2 = v4 = right; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以编辑墙壁，它们将显示为四边形条纹。</font><font style="vertical-align: inherit;">但是，我们不会看到连续的墙。</font><font style="vertical-align: inherit;">每个四边形仅在一侧可见。</font><font style="vertical-align: inherit;">它的脸朝向添加它的单元格。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5a/2f0/442/e5a2f0442a2d1812b73dd2977d80d565.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单面四边形墙。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以通过以相反的方式添加第二个四边形来快速解决此问题。</font></font><br><br><pre> <code class="cs hljs"> walls.AddQuad(v1, v2, v3, v4); walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/302/e53/129/302e53129e87c3432848772688e9d896.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双边墙。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，所有墙壁都可以完整看到，但是在三个单元相交的单元的角落仍然有孔。</font><font style="vertical-align: inherit;">我们稍后会填写。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 厚壁 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管墙壁的两侧都已经可见，但是它们没有厚度。</font><font style="vertical-align: inherit;">实际上，墙壁很薄，就像纸一样，并且在一定角度几乎看不见。</font><font style="vertical-align: inherit;">因此，让我们通过增加厚度来使它们完整。</font><font style="vertical-align: inherit;">在中设置其厚度</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我选择0.75单位的值，对我来说似乎很合适。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallThickness = <span class="hljs-number"><span class="hljs-number">0.75f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要使两堵墙变厚，需要将两个四边形分开到侧面。</font><font style="vertical-align: inherit;">它们应朝相反的方向移动。</font><font style="vertical-align: inherit;">一侧应移向近边缘，另一侧应移向远边缘。</font><font style="vertical-align: inherit;">偏移向量是相等的</font></font><code>far - near</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要使</font><font style="vertical-align: inherit;">墙的顶部保持平坦，我们需要将其分量Y设置为0。</font><font style="vertical-align: inherit;">由于需要对壁段的左侧和右侧都进行此操作，因此，请向该</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">添加</font><font style="vertical-align: inherit;">偏移向量</font><font style="vertical-align: inherit;">以</font><font style="vertical-align: inherit;">进行计算。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallThicknessOffset</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { Vector3 offset; offset.x = far.x - near.x; offset.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; offset.z = far.z - near.z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> offset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使壁保留在肋骨的中心，沿该矢量的实际移动距离应等于每侧厚度的一半。</font><font style="vertical-align: inherit;">为了确保我们确实移动了正确的距离，我们在缩放位移向量之前对其进行了归一化。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> offset.normalized * (wallThickness * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用此方法</font></font><code>HexFeatureManager.AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来更改四边形的位置。</font><font style="vertical-align: inherit;">由于位移矢量从最近的单元格到最远的单元格，因此从近四边形减去它，然后加到远一单元格上。</font></font><br><br><pre> <code class="cs hljs"> Vector3 left = Vector3.Lerp(nearLeft, farLeft, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 right = Vector3.Lerp(nearRight, farRight, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); Vector3 leftThicknessOffset = HexMetrics.WallThicknessOffset(nearLeft, farLeft); Vector3 rightThicknessOffset = HexMetrics.WallThicknessOffset(nearRight, farRight); Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4); v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/746/08b/df774608b2b06114b4afbc6ec2904e61.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有偏移量的墙。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，四边形有偏差，尽管这并不十分明显。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">壁厚是否相同？</font></font></b> <div class="spoiler_text">    ,      «-»     .      ,    .       .       ,   .    ,    .  , -      ,     .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 墙顶 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了使墙的厚度从上方可见，我们需要在墙的顶部添加一个四边形。</font><font style="vertical-align: inherit;">最简单的方法是记住第一个四边形的两个上顶点，并将它们与第二个四边形的两个上顶点连接起来。</font></font><br><br><pre> <code class="cs hljs"> Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v1, v2, v3, v4); Vector3 t1 = v3, t2 = v4; v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = v4.y = left.y + HexMetrics.wallHeight; walls.AddQuad(v2, v1, v4, v3); walls.AddQuad(t1, t2, v3, v4);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/15d/627/1d715d627770a9e7a17bf135a461833d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙壁与顶部。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 转弯 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在单元的角落仍然有孔。</font><font style="vertical-align: inherit;">为了填充它们，我们需要在单元格之间的三角形区域添加一个线段。</font><font style="vertical-align: inherit;">每个角连接三个单元。</font><font style="vertical-align: inherit;">每个单元可能有也可能没有墙。</font><font style="vertical-align: inherit;">即，八个配置是可能的。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed9/277/8ee/ed92778ee39106d3a448892a124d366c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">角度配置。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们仅将壁放置在具有不同栅栏状态的单元之间。</font><font style="vertical-align: inherit;">这样可以将配置数量减少到六个。</font><font style="vertical-align: inherit;">在每个单元中，一个单元位于壁的曲线内。</font><font style="vertical-align: inherit;">让我们将此单元格视为壁弯曲的参考点。</font><font style="vertical-align: inherit;">从该单元的角度来看，墙从与左单元共同的边缘开始，到与右单元共同的边缘结束。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48e/f68/19a/48ef6819a839339a17d1513f7ca546b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">单元角色。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也就是说，我们需要创建一个方法，</font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其参数为拐角的三个顶点。</font><font style="vertical-align: inherit;">尽管我们可以编写代码来对该部分进行三角剖分，但实际上这是该方法的特例</font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">锚点在两个顶点附近都起作用。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，</font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为角度的三个顶点及其像元</font><font style="vertical-align: inherit;">创建方法的变体</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该方法的目的是确定角度（如果存在），它是参考点。</font><font style="vertical-align: inherit;">因此，他必须考虑所有八个可能的配置并要求其中</font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">六个。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 c1, HexCell cell1, Vector3 c2, HexCell cell2, Vector3 c3, HexCell cell3 </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell1.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell2.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell3.Walled) { AddWallSegment(c3, cell3, c1, cell1, c2, cell2); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c2, cell2, c3, cell3, c1, cell1); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallSegment(c1, cell1, c2, cell2, c3, cell3); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell2.Walled) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c1, cell1, c2, cell2, c3, cell3); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallSegment(c2, cell2, c3, cell3, c1, cell1); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell3.Walled) { AddWallSegment(c3, cell3, c1, cell1, c2, cell2); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要添加角线段，请在末尾调用此方法</font></font><code>HexGridChunk.TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … features.AddWall(bottom, bottomCell, left, leftCell, right, rightCell); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8e/e63/304/a8ee63304fce04d4db9dcdf46076b3a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙壁有角，但仍然有孔。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 封闭孔 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">壁上仍然有孔，因为壁段的高度是可变的。沿边缘的线段具有恒定的高度，而角线段则位于两个不同的边缘之间。由于每个边缘可以有其自己的高度，因此在拐角处会出现孔。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要解决此问题，请对其进行更改</font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以使其分别存储左右顶部顶点的Y坐标。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> leftTop = left.y + HexMetrics.wallHeight; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rightTop = right.y + HexMetrics.wallHeight; Vector3 v1, v2, v3, v4; v1 = v3 = left - leftThicknessOffset; v2 = v4 = right - rightThicknessOffset; v3.y = leftTop; v4.y = rightTop; walls.AddQuad(v1, v2, v3, v4); Vector3 t1 = v3, t2 = v4; v1 = v3 = left + leftThicknessOffset; v2 = v4 = right + rightThicknessOffset; v3.y = leftTop; v4.y = rightTop; walls.AddQuad(v2, v1, v4, v3);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cd/f1d/a88/9cdf1da889ce427e1d519a284532d6a8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">封闭的墙壁。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，墙壁已关闭，但您可能仍会在墙壁的阴影中看到孔。这是由</font><font style="vertical-align: inherit;">方向阴影设置</font><font style="vertical-align: inherit;">的“ </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正常偏移”</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数引起的</font><font style="vertical-align: inherit;">。当它大于零时，投射阴影的对象的三角形沿曲面的法线移动。这样可以避免自遮蔽，但同时在三角形朝不同方向看的情况下也会产生孔洞。在这种情况下，可以在精细几何形状的阴影（例如我们的墙）中创建孔。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以通过将法向偏差降低为零来消除这些阴影伪影。或将</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cast Shadows</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网格渲染器的墙</font><font style="vertical-align: inherit;">模式更改为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双面</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这将使阴影投射对象渲染每个墙壁三角形的两侧以进行渲染，这将关闭所有孔。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b14/9d5/d0b/b149d5d0bb36f049faa5ca9d49261618.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阴影中没有更多的孔了。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 壁架墙 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们的墙足够直。</font><font style="vertical-align: inherit;">对于平坦的地形，这一点都还不错，但是当墙壁与壁架重合时，这看起来很奇怪。</font><font style="vertical-align: inherit;">当墙的相对两侧的单元之间存在一个高度差时，就会发生这种情况。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/065/481/c1a/065481c1a0859ced22d0ae6568acbe86.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">壁架上的直墙。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 跟随边缘 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与其为整个边缘创建一个线段，不如为边缘条的每个部分创建一个线段。</font><font style="vertical-align: inherit;">我们可以通过</font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">edge </font><font style="vertical-align: inherit;">版本中</font><font style="vertical-align: inherit;">调用四次来做到这一点</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); AddWallSegment(near.v2, far.v2, near.v3, far.v3); AddWallSegment(near.v3, far.v3, near.v4, far.v4); AddWallSegment(near.v4, far.v4, near.v5, far.v5); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a96/8aa/0f9/a968aa0f984b31e81dc9edb12e8d31bb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弯曲的墙壁。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，墙壁会重复变形的边缘形状。</font><font style="vertical-align: inherit;">结合壁架，看起来更好。</font><font style="vertical-align: inherit;">此外，它还在平坦的浮雕上创建了更多有趣的墙。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将墙壁放在地面上 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看着壁架上的墙壁，您会发现一个问题。墙壁悬在地面上！对于倾斜的平坦边缘来说确实如此，但通常不会那么明显。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/039/8f0/a59/0398f0a59aca756824e162c3fba5a891.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙壁悬在空中。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了解决这个问题，我们需要降低墙壁。最简单的方法是降低整个墙壁，使其顶部保持平坦。同时，上侧的一部分墙会稍微降低到浮雕中，但这将适合我们。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要降低墙的高度，我们需要确定哪一侧较低-近或远。我们可以只使用最低边的高度，而不必走得太低。您可以将Y坐标从低到高插值，其偏移量小于0.5。由于壁偶尔仅会变得高于壁架的较低台阶，因此我们可以将壁架的垂直台阶用作偏移量。壁架构造的不同壁厚可能需要不同的偏移量。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/960/61c/817/96061c817bfdc69db9682e0799ba3751.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">降低的墙。</font></font></i> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">除了平均近顶点和远顶点的X和Z坐标外，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们还添加了</font><font style="vertical-align: inherit;">处理该插值</font><font style="vertical-align: inherit;">的</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>WallLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它基于一种方法</font></font><code>TerraceLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallElevationOffset = verticalTerraceStepSize; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near.x += (far.x - near.x) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; near.z += (far.z - near.z) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = near.y &lt; far.y ? wallElevationOffset : (<span class="hljs-number"><span class="hljs-number">1f</span></span> - wallElevationOffset); near.y += (far.y - near.y) * v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> near; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">强制使用</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此方法确定左顶点和右顶点。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { Vector3 left = HexMetrics.WallLerp(nearLeft, farLeft); Vector3 right = HexMetrics.WallLerp(nearRight, farRight); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/957/a4c/b49/957a4cb498eb8a712064a0b99a4041be.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">站在地面上的墙壁。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 墙体变形变化 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们的墙壁高度一致。尽管它们靠近扭曲的边缘，但它们仍未完全对应于扭曲的边缘。发生这种情况是因为我们首先确定墙壁的顶部，然后将其变形。由于这些顶点位于近端和远端边缘的顶点之间，因此它们的变形会略有不同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">壁不正确地跟随肋的事实不是问题。但是，壁顶部的变形会改变厚度相对均匀的厚度。如果我们根据变形的顶点排列墙，然后添加未变形的四边形，则其厚度应该不会有太大变化。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { nearLeft = HexMetrics.Perturb(nearLeft); farLeft = HexMetrics.Perturb(farLeft); nearRight = HexMetrics.Perturb(nearRight); farRight = HexMetrics.Perturb(farRight); … walls.AddQuadUnperturbed(v1, v2, v3, v4); … walls.AddQuadUnperturbed(v2, v1, v4, v3); walls.AddQuadUnperturbed(t1, t2, v3, v4); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/fa3/03d/b10fa303dc91a50665bf92b47feed5e7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙壁的顶部未变形。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于这种方法，墙壁将不再像以前那样精确地跟随边缘。</font><font style="vertical-align: inherit;">但是作为回报，它们将变得不那么破裂，并且厚度将更恒定。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d38/7f6/b6f/d387f6b6f1c4fed424d2582a8ef5c12c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">壁厚更一致。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 墙上的洞 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们忽略了河流或道路横穿隔离墙的可能性。</font><font style="vertical-align: inherit;">发生这种情况时，我们必须在墙壁上打一个洞，河流或道路可以通过。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，添加</font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个布尔参数以指示河流或道路是否通过一条边。</font><font style="vertical-align: inherit;">尽管我们可以用不同的方式处理它们，但在两种情况下我们都只删除两个中间部分。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver || hasRoad) { <span class="hljs-comment"><span class="hljs-comment">// Leave a gap. } else { AddWallSegment(near.v2, far.v2, near.v3, far.v3); AddWallSegment(near.v3, far.v3, near.v4, far.v4); } AddWallSegment(near.v4, far.v4, near.v5, far.v5); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在它</font></font><code>HexGridChunk.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该提供必要的数据。</font><font style="vertical-align: inherit;">由于他已经需要相同的信息，因此让我们将其缓存在布尔变量中，并只记录一次对相应方法的调用。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRiver = cell.HasRiverThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoad = cell.HasRoadThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver) { … } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor, hasRoad); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, cell.Color, e2, neighbor.Color, hasRoad); } features.AddWall(e1, cell, e2, neighbor, hasRiver, hasRoad); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/d05/425/64cd0542540b5d9347a071d727fe2fa4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙壁上的孔供河流和道路通过。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们覆盖墙壁 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些新的开口创造了完成墙壁的地方。</font><font style="vertical-align: inherit;">我们需要用四边形封闭这些端点，以便我们无法看穿墙壁的侧面。</font><font style="vertical-align: inherit;">让我们为此创建一个</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>AddWallCap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它的工作方式类似于</font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但只需要一对近峰。</font><font style="vertical-align: inherit;">让他添加一个四边形，从墙的近端到远端。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallCap</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near = HexMetrics.Perturb(near); far = HexMetrics.Perturb(far); Vector3 center = HexMetrics.WallLerp(near, far); Vector3 thickness = HexMetrics.WallThicknessOffset(near, far); Vector3 v1, v2, v3, v4; v1 = v3 = center - thickness; v2 = v4 = center + thickness; v3.y = v4.y = center.y + HexMetrics.wallHeight; walls.AddQuadUnperturbed(v1, v2, v3, v4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当</font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发现需要孔时，在第二对和第四对边缘之间添加一个覆盖。</font><font style="vertical-align: inherit;">对于第四对顶点，您需要切换方向，否则四边形将向内看。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nearCell.Walled != farCell.Walled) { AddWallSegment(near.v1, far.v1, near.v2, far.v2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRiver || hasRoad) { AddWallCap(near.v2, far.v2); AddWallCap(far.v4, near.v4); } … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/98c/828/41398c82892a2c1f706ca85c9230813a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙壁上的封闭孔。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">围绕地图边缘的孔怎么办？</font></font></b> <div class="spoiler_text">   ,     .        .    ,        . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 避免悬崖和水 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，让我们看一下包含悬崖或水的边缘。</font><font style="vertical-align: inherit;">由于悬崖本质上是大墙，因此在其上放置额外的墙是不合逻辑的。</font><font style="vertical-align: inherit;">另外，它看起来会很糟糕。</font><font style="vertical-align: inherit;">水下墙也是完全不合逻辑的，海岸墙的限制也是如此。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/94e/027/45a94e027094c6ebdae0763663d6eb8e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙壁在峭壁上和在水中。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以通过额外的检查来去除这些不必要的边缘上的墙</font></font><code>AddWall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">墙不能在水下，与之共通的肋骨不能是悬崖。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWall</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices near, HexCell nearCell, EdgeVertices far, HexCell farCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRiver, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( nearCell.Walled != farCell.Walled &amp;&amp; !nearCell.IsUnderwater &amp;&amp; !farCell.IsUnderwater &amp;&amp; nearCell.GetEdgeType(farCell) != HexEdgeType.Cliff ) { … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/baf/75a/128baf75ace7d0cf4ed5f12ef380eec8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">去除了沿肋骨的障碍墙，但角落仍然保留。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 去除墙角 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">去除不必要的角部段将需要更多的努力。</font><font style="vertical-align: inherit;">最简单的情况是支撑池在水下。</font><font style="vertical-align: inherit;">这样可以确保附近没有可连接的墙段。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pivotCell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/475/9f3/ecc4759f38ced7802ad8743626f91d51.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有更多的水下支持室。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们需要看看其他两个单元。</font><font style="vertical-align: inherit;">如果其中之一在水下或通过中断连接到支撑单元，则沿该肋没有壁。</font><font style="vertical-align: inherit;">如果至少一侧为真，则此角不应有墙段。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们分别确定是否有左墙或右墙。</font><font style="vertical-align: inherit;">我们将结果放入布尔变量中，以使其更易于使用。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pivotCell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasLeftWall = !leftCell.IsUnderwater &amp;&amp; pivotCell.GetEdgeType(leftCell) != HexEdgeType.Cliff; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRighWall = !rightCell.IsUnderwater &amp;&amp; pivotCell.GetEdgeType(rightCell) != HexEdgeType.Cliff; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall &amp;&amp; hasRighWall) { AddWallSegment(pivot, left, pivot, right); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cd/f17/82d/8cdf1782d522d5b9e19e461ee5253436.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">去除了所有干扰角。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 死角 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当左右边缘都没有墙时，工作就完成了。</font><font style="vertical-align: inherit;">但是，如果墙壁仅在一个方向上，则意味着墙壁上还有另一个孔。</font><font style="vertical-align: inherit;">因此，您需要关闭它。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallSegment(pivot, left, pivot, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(pivot, left); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallCap(right, pivot); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20e/c4d/176/20ec4d17689500d123fc5fd41d447e88.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们关闭墙壁。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 墙壁与悬崖的连接 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一种情况下，墙壁看起来不完美。</font><font style="vertical-align: inherit;">当墙到达悬崖的底部时，它结束了。</font><font style="vertical-align: inherit;">但是由于悬崖并非完全垂直，因此在墙壁和悬崖边缘之间会形成一个狭窄的孔。</font><font style="vertical-align: inherit;">在悬崖的顶部，不会出现这样的问题。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/633/5c6/9a7/6335c69a7f45dcd1c2a0609503b2504a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙壁和悬崖壁之间的孔。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果墙一直延伸到悬崖的边缘，那就更好了。</font><font style="vertical-align: inherit;">为此，我们可以在墙的当前端与悬崖的角顶之间添加另一个墙段。</font><font style="vertical-align: inherit;">由于此部分的大部分将隐藏在悬崖内部，因此我们可以不将悬崖内部的壁厚减小到零。</font><font style="vertical-align: inherit;">因此，对于我们来说，创建一个楔形就足够了：两个四边形指向该点，而三角形位于它们的顶部。</font><font style="vertical-align: inherit;">让我们为此创建一个方法</font></font><code>AddWallWedge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这可以通过复制</font></font><code>AddWallCap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并添加楔形点</font><font style="vertical-align: inherit;">来完成</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallWedge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far, Vector3 point</span></span></span><span class="hljs-function">)</span></span> { near = HexMetrics.Perturb(near); far = HexMetrics.Perturb(far); point = HexMetrics.Perturb(point); Vector3 center = HexMetrics.WallLerp(near, far); Vector3 thickness = HexMetrics.WallThicknessOffset(near, far); Vector3 v1, v2, v3, v4; Vector3 pointTop = point; point.y = center.y; v1 = v3 = center - thickness; v2 = v4 = center + thickness; v3.y = v4.y = pointTop.y = center.y + HexMetrics.wallHeight; <span class="hljs-comment"><span class="hljs-comment">// walls.AddQuadUnperturbed(v1, v2, v3, v4); walls.AddQuadUnperturbed(v1, point, v3, pointTop); walls.AddQuadUnperturbed(point, v2, pointTop, v4); walls.AddTriangleUnperturbed(pointTop, v3, v4); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为</font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于角部，我们将当壁进入仅在一个方向，并且该壁位于比另一侧的高度低调用此方法。</font><font style="vertical-align: inherit;">在这些条件下，我们遇到了悬崖的边缘。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasLeftWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { AddWallSegment(pivot, left, pivot, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { AddWallWedge(pivot, left, right); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(pivot, left); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRighWall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightCell.Elevation &lt; leftCell.Elevation) { AddWallWedge(right, pivot, left); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddWallCap(right, pivot); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/30f/33a/b5c30f33ac93582e2ce319996d9ed1ac.png"></div><br> <i> ,   .</i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">unitypackage</a> <br><br><h1>  11:    </h1><br><ul><li>    . </li><li>     . </li><li>     . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef5/a07/5ea/ef5a075ea4c14c810825388be274f817.jpg"></div><br> <i>  .</i> <br><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在上一部分中，我们添加了墙面支撑。这些是简单的直壁段，没有明显差异。现在，我们将通过在其上添加塔来使墙更有趣。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须按程序创建墙段以匹配浮雕。塔不是必需的，我们可以使用常规的预制件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以用红色材料创建一个由两个立方体组成的简单塔。塔的底部尺寸为2 x 2个单位，高度为4个单位，也就是说，它比墙更厚且更高。在此立方体上方，我们将放置一个表示塔顶的单位立方体。像所有其他预制件一样，这些立方体不需要对撞机。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于塔模型由多个对象组成，因此我们将它们设为根对象的子代。</font><font style="vertical-align: inherit;">放置它们，使根的本地原点位于塔的底部。</font><font style="vertical-align: inherit;">因此，我们可以放置塔而不必担心它们的高度。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f1/a54/335/2f1a54335d81a6682707e740107362c6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制塔。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在此预制中添加链接</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并进行连接。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform wallTower;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f76/df1/c7e/f76df1c7e5b1c808d2ae636f7e823487.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接到预制塔。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 建筑塔 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从在每个墙段的中间放置塔开始。</font><font style="vertical-align: inherit;">为此，我们将在方法末尾创建一个塔</font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">她的位置将是该段左，右点的平均值。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight </span></span></span><span class="hljs-function">)</span></span> { … Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/559/541/487/559541487b79dd6877b4456dbdf010b1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个墙段一塔。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们沿着墙有很多塔，但是它们的方向没有改变。</font><font style="vertical-align: inherit;">我们需要更改其旋转角度，以使其与墙对齐。</font><font style="vertical-align: inherit;">由于我们具有墙的左右两个点，因此我们知道哪个方向是正确的。</font><font style="vertical-align: inherit;">我们可以利用这些知识来确定墙段的方向，从而确定塔的方向。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无需自己计算旋转量，我们只需将一个</font></font><code>Transform.right</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向量</font><font style="vertical-align: inherit;">分配给property即可</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">统一代码将改变对象的旋转，以使其局部方向右与所传输的矢量相对应。</font></font><br><br><pre> <code class="cs hljs"> Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Vector3 rightDirection = right - left; rightDirection.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; towerInstance.transform.right = rightDirection; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/2c3/777/5d32c3777d5b63db90ddf9f8fbbf1dee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">塔与墙对齐。</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transform.right分配如何工作？</font></font></b> <div class="spoiler_text">     <code>Quaternion.FromToRotation</code>   .   . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 right { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotation * Vector3.right; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { rotation = Quaternion.FromToRotation(Vector3.right, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } }</code> </pre> </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 减少塔数 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">每个墙段一个塔太多。</font><font style="vertical-align: inherit;">让我们通过向</font></font><code>AddWallSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">布尔值</font><font style="vertical-align: inherit;">添加</font><font style="vertical-align: inherit;">参数</font><font style="vertical-align: inherit;">来使添加塔成为可选操作</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">将其设置为默认值</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这种情况下，所有的塔都将消失。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 nearLeft, Vector3 farLeft, Vector3 nearRight, Vector3 farRight, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addTower = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addTower) { Transform towerInstance = Instantiate(wallTower); towerInstance.transform.localPosition = (left + right) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; Vector3 rightDirection = right - left; rightDirection.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; towerInstance.transform.right = rightDirection; towerInstance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们将塔仅放置在牢房的角落。</font><font style="vertical-align: inherit;">结果，我们得到的塔数更少，并且它们之间的距离相当恒定。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddWallSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 pivot, HexCell pivotCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { … AddWallSegment(pivot, left, pivot, right, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/823/d7b/d60823d7b381eccaf5916bf2bc636061.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">塔只在角落。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看起来足够好，但是我们可能需要更少的塔定期放置。</font><font style="vertical-align: inherit;">与其他地形特征一样，我们可以使用哈希表来决定是否将塔楼放在角落。</font><font style="vertical-align: inherit;">为此，我们使用角的中心对表进行采样，然后将哈希值之一与塔的阈值进行比较。</font></font><br><br><pre> <code class="cs hljs"> HexHash hash = HexMetrics.SampleHashGrid( (pivot + left + right) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasTower = hash.e &lt; HexMetrics.wallTowerThreshold; AddWallSegment(pivot, left, pivot, right, hasTower);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阈值为</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">值为0.5时，将在一半情况下创建塔，但是我们可以创建具有许多塔或根本没有塔的墙。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallTowerThreshold = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b54/40c/f0f/b5440cf0ffa4f615f2dcbf37532bbb0a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随机塔。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们从山坡上卸下塔楼 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，无论地形如何，我们都可以放置塔。</font><font style="vertical-align: inherit;">但是，在塔的斜坡上看起来不合逻辑。</font><font style="vertical-align: inherit;">在这里，墙壁成一定角度，可以切穿塔顶。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24c/c5e/2dd/24cc5e2ddb97b83d14e0826bc64e3f20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">塔在斜坡上。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了避免倾斜，我们将检查左右角单元是否在相同的高度。</font><font style="vertical-align: inherit;">仅在这种情况下才可以放置塔。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasTower = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation == rightCell.Elevation) { HexHash hash = HexMetrics.SampleHashGrid( (pivot + left + right) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>) ); hasTower = hash.e &lt; HexMetrics.wallTowerThreshold; } AddWallSegment(pivot, left, pivot, right, hasTower);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/770/1b4/fd9/7701b4fd9d0a4952fce2a9e00bbb4571.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">斜坡的墙壁上不再有塔。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们将墙壁和塔楼放在地面上 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管我们避免在倾斜的地方使用墙，但墙两侧的浮雕仍可以具有不同的高度。</font><font style="vertical-align: inherit;">墙壁可以沿着壁架延伸，而相同高度的单元可以具有不同的垂直位置。</font><font style="vertical-align: inherit;">因此，塔架的底部可能在空中。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/4d8/b10/cd24d8b1012804af5d073c3901c874ad.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">塔在空中。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，斜坡上的墙壁也可以悬挂在空中，但这并不像塔楼那么明显。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b6/ae3/d24/8b6ae3d2489f253ae1a78593af0abd6c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">墙壁在空中。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这可以通过将墙壁和塔的底部拉伸到地面来解决。</font><font style="vertical-align: inherit;">为此，请为中的墙添加Y偏移</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">一单位下来就足够了。</font><font style="vertical-align: inherit;">将塔的高度增加相同的数量。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallHeight = <span class="hljs-number"><span class="hljs-number">4f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> wallYOffset = <span class="hljs-number"><span class="hljs-number">-1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们对其进行更改，</font></font><code>HexMetrics.WallLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以便在确定Y坐标时考虑新的偏移量。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WallLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 near, Vector3 far</span></span></span><span class="hljs-function">)</span></span> { near.x += (far.x - near.x) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; near.z += (far.z - near.z) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = near.y &lt; far.y ? wallElevationOffset : (<span class="hljs-number"><span class="hljs-number">1f</span></span> - wallElevationOffset); near.y += (far.y - near.y) * v + wallYOffset; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> near; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们还需要更改塔的预制件，因为基座现在将在地下一层。</font><font style="vertical-align: inherit;">因此，我们将基础立方体的高度增加了一个单位，并相应地更改了立方体的局部位置。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/e4e/503/f2de4e50398fbae4ee296737dbe3a922.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecd/5d7/0eb/ecd5d70ebb620e3bae84f17aedb4a2a9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在地面上的墙壁和塔。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2> 桥梁 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这个阶段，我们有河流和道路，但是道路无法以任何方式穿越河流。</font><font style="vertical-align: inherit;">现在是添加网桥的合适时间。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们从一个简单的可缩放立方体开始，它将扮演预制桥梁的角色。</font><font style="vertical-align: inherit;">河流的宽度各不相同，但两侧道路中心之间大约有七个距离单位。</font><font style="vertical-align: inherit;">因此，我们给它一个近似的比例（3，1，7）。</font><font style="vertical-align: inherit;">添加预制的红色城市材料，并摆脱其对撞机。</font><font style="vertical-align: inherit;">与塔一样，将立方体按相同比例放置在根对象中。</font><font style="vertical-align: inherit;">因此，桥本身的几何形状并不重要。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在桥的预制件上添加一个链接，</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并为其分配一个预制件。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform wallTower, bridge;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/808/ac6/dc5/808ac6dc523d16d2005da48dcf4d1f65.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已分配桥梁预制件。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 桥的位置 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要放置桥，我们需要一种方法</font></font><code>HexFeatureManager.AddBridge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">桥梁应位于河流中心和河流两侧之间。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 roadCenter1, Vector3 roadCenter2</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们将传输未变形的道路中心，因此在放置桥梁之前，我们将必须对它们进行变形。 </font></font><br><br><pre> <code class="cs hljs"> roadCenter1 = HexMetrics.Perturb(roadCenter1); roadCenter2 = HexMetrics.Perturb(roadCenter2); Transform instance = Instantiate(bridge);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了正确对准桥，我们可以使用与旋转塔时相同的方法。</font><font style="vertical-align: inherit;">在这种情况下，道路中心定义桥梁的前向矢量。</font><font style="vertical-align: inherit;">由于我们保持在同一像元内，因此此向量肯定是水平的，因此我们不需要将其分量Y归零。</font></font><br><br><pre> <code class="cs hljs"> Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.forward = roadCenter2 - roadCenter1; instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们在直河上架起桥梁 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">唯一需要桥梁的河流构造是直的和弯曲的。道路可以通过端点，而在之字形道路只能在附近。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，让我们找出直河。在内部，</font></font><code>HexGridChunk.TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一操作员</font></font><code>else if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这些河流附近布置道路。因此，我们将在此处添加网桥。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在河的一侧。道路的中心从河上移开，然后单元的中心也移动了。要在另一侧找到道路的中心，我们需要将相反的方向移动相同的量。必须在更改中心本身之前完成此操作。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { … roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97c/c7f/420/97cc7f42004ba86c6cd0333af352f24b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">直河上的桥梁。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">桥梁出现了！</font><font style="vertical-align: inherit;">但是现在，在河不流经的每个方向上都有一个桥梁实例。</font><font style="vertical-align: inherit;">我们需要确保在单元中仅生成一个桥实例。</font><font style="vertical-align: inherit;">这可以通过选择相对于河流的一个方向并在其基础上生成桥梁来完成。</font><font style="vertical-align: inherit;">您可以选择任何方向。</font></font><br><br><pre> <code class="cs hljs"> roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == direction.Next()) { features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，我们仅在河两岸都有道路时才需要加桥。</font><font style="vertical-align: inherit;">目前，我们已经确定当前的道路。</font><font style="vertical-align: inherit;">因此，您需要检查在河的另一边是否有道路。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == direction.Next() &amp;&amp; ( cell.HasRoadThroughEdge(direction.Next2()) || cell.HasRoadThroughEdge(direction.Opposite()) )) { features.AddBridge(roadCenter, center - corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/635/a47/978/635a4797816f9f35297f67224a0ec449.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双方道路之间的桥梁。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 弯曲的河流上的桥梁 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弯曲河流上的桥梁工作原理相似，但拓扑结构略有不同。</font><font style="vertical-align: inherit;">当我们在曲线的外部时，我们将添加一个桥。</font><font style="vertical-align: inherit;">这发生在最后一个块中</font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它使用中间方向来偏移道路的中心。</font><font style="vertical-align: inherit;">我们将需要以不同的比例两次使用此偏移量，因此将其保存到变量中。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !cell.HasRoadThroughEdge(middle) &amp;&amp; !cell.HasRoadThroughEdge(middle.Previous()) &amp;&amp; !cell.HasRoadThroughEdge(middle.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲线外部的位移比例为0.25，内部为</font></font><code>HexMetrics.innerToOuter * 0.7f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们用它来放置桥。</font></font><br><br><pre> <code class="cs hljs"> Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/f9e/da9/612f9eda9f9e4cd31ba20dfe2db7687b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弯曲的河流上的桥梁。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次，我们需要避免重复的桥接。</font><font style="vertical-align: inherit;">我们可以通过仅从中间方向添加桥来做到这一点。</font></font><br><br><pre> <code class="cs hljs"> Vector3 offset = HexMetrics.GetSolidEdgeMiddle(middle); roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction == middle) { features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 同样，您需要确保道路在对面。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( direction == middle &amp;&amp; cell.HasRoadThroughEdge(direction.Opposite()) ) { features.AddBridge( roadCenter, center - offset * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/744/33c/275/74433c2750e413c44d17139982ecff3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双方道路之间的桥梁。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 桥梁缩放 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们扭曲了地形，因此道路中心和河流对岸之间的距离会发生变化。</font><font style="vertical-align: inherit;">有时桥太短，有时太长。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/770/f2c/e53/770f2ce537ab16628c799eceb6ca4ad7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">距离可变，但桥长不变。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管我们创建的桥的长度为7个单位，但您可以对其进行缩放以匹配道路中心之间的真实距离。</font><font style="vertical-align: inherit;">这意味着桥梁模型变形了。</font><font style="vertical-align: inherit;">由于距离变化不大，因此变形比不适合长度的桥更容易接受。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了进行适当的缩放，我们需要知道桥梁预制件的初始长度。</font><font style="vertical-align: inherit;">我们将此长度存储在中</font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bridgeDesignLength = <span class="hljs-number"><span class="hljs-number">7f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以将沿桥梁Z实例的比例分配给道路中心之间的距离，再除以原始长度。</font><font style="vertical-align: inherit;">由于桥的预制件的根部具有相同的比例，因此桥将正确拉伸。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 roadCenter1, Vector3 roadCenter2</span></span></span><span class="hljs-function">)</span></span> { roadCenter1 = HexMetrics.Perturb(roadCenter1); roadCenter2 = HexMetrics.Perturb(roadCenter2); Transform instance = Instantiate(bridge); instance.localPosition = (roadCenter1 + roadCenter2) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; instance.forward = roadCenter2 - roadCenter1; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> length = Vector3.Distance(roadCenter1, roadCenter2); instance.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3( <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, length * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / HexMetrics.bridgeDesignLength) ); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21e/b73/49c/21eb7349c5e7ae6d5480b2e61d19e046.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 不断变化的桥梁长度。 </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 桥梁建设 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替简单的多维数据集，我们可以使用更有趣的桥模型。</font><font style="vertical-align: inherit;">例如，您可以创建由三个缩放和旋转的多维数据集组成的粗糙拱形桥。</font><font style="vertical-align: inherit;">当然，您可以创建更复杂的3D模型，包括道路的一部分。</font><font style="vertical-align: inherit;">但是请注意，整个对象将略微压缩和拉伸。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eee/83f/3b6/eee83f3b67cf879abe3114117614af08.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a9/741/f7f/8a9741f7f024aa8914e29b12c1ae9d94.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同长度的拱形桥。</font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 特殊物品 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，我们的单元格可以包含城市，农村和植物对象。即使它们每个都有三个级别，但与单元格的大小相比，所有对象都非常小。如果我们需要一幢大型建筑，例如城堡，该怎么办？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们向地形添加一种特殊类型的对象。这样的物体太大，以至于占据了整个单元。这些对象中的每一个都是唯一的，并且需要自己的预制件。例如，一个简单的城堡可以由一个中央立方体和四个角楼组成。中央立方体的刻度（6、4、6）将产生足够大的锁，即使在严重变形的单元中也可以安装。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/9bf/0dc/7e19bf0dc5f1568bf4b21ec467ba9063.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">城堡的预制件。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个特殊的对象可以是之字形，例如，由三个相互叠置的立方体构成。</font><font style="vertical-align: inherit;">对于下部立方体，刻度（8、2.5、8）是合适的。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ad/7d3/291/1ad7d3291224358562b3472f528973a1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制锯齿形。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊对象可以是任何对象，不一定是建筑对象。</font><font style="vertical-align: inherit;">例如，一组高达十个单位高的大树可以指示一个充满巨型植物的细胞。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bb/e91/907/1bbe91907deba70f6ab9d02cd13de795.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预制大型植物。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加到</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阵列以跟踪这些预制件。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform[] special;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 首先，向阵列中添加一个城堡，然后添加ziggurat，然后添加大型植物。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbc/2e3/e94/bbc2e3e949b25efc800a8f2e799490c7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊对象的定制。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使细胞变得特别 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在</font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，需要特殊对象的索引，该索引确定特殊对象的类型（如果存在）。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> specialIndex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 像其他救济对象一样，让我们​​为其提供接收和设置此值的能力。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> specialIndex; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，该单元格不包含特殊对象。</font><font style="vertical-align: inherit;">我们用索引0表示它。添加使用此方法确定单元格是否特殊的属性。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsSpecial { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> specialIndex &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要编辑单元格，请添加对特殊对象索引的支持</font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它的工作方式类似于城市，农村和工厂设施的水平。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeUrbanLevel, activeFarmLevel, activePlantLevel, activeSpecialIndex; … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyUrbanLevel, applyFarmLevel, applyPlantLevel, applySpecialIndex; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplySpecialIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applySpecialIndex = toggle; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetSpecialIndex</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeSpecialIndex = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)index; } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyWaterLevel) { cell.WaterLevel = activeWaterLevel; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applySpecialIndex) { cell.SpecialIndex = activeSpecialIndex; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyUrbanLevel) { cell.UrbanLevel = activeUrbanLevel; } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将滑块添加到UI中以控制特殊对象。</font><font style="vertical-align: inherit;">由于我们有三个对象，因此在滑块中使用间隔0–3。</font><font style="vertical-align: inherit;">零表示没有物体，一个-城堡，两个-锯齿形琴，三个-巨型植物。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab4/2ea/9bf/ab42ea9bf68565a294f4ded5d2d7ebf0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊对象的滑块。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 添加特殊对象 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在我们可以为单元格分配特殊的对象。</font><font style="vertical-align: inherit;">为了使它们出现，我们需要添加到</font></font><code>HexFeatureManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一种方法。</font><font style="vertical-align: inherit;">它仅创建所需特殊对象的实例并将其放置在所需位置。</font><font style="vertical-align: inherit;">由于零表示不存在对象，因此在访问预制阵列之前，必须从单元的特殊对象的索引中减去单位。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSpecialFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(special[cell.SpecialIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>]); instance.localPosition = HexMetrics.Perturb(position); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 让我们使用哈希表对对象进行任意旋转。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSpecialFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Transform instance = Instantiate(special[cell.SpecialIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>]); instance.localPosition = HexMetrics.Perturb(position); HexHash hash = HexMetrics.SampleHashGrid(position); instance.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">360f</span></span> * hash.e, <span class="hljs-number"><span class="hljs-number">0f</span></span>); instance.SetParent(container, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对单元格进行三角剖分时，我们</font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将检查该单元格是否包含特殊对象。</font><font style="vertical-align: inherit;">如果是这样，那么我们就像一样调用我们的新方法</font></font><code>AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b69/242/657/b692426576e292bbdc9ed0752624db51.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊对象。</font><font style="vertical-align: inherit;">它们比平常大得多。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 避开河流 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 由于特殊对象位于单元格的中心，因此它们不会与河流结合，因为它们会悬在河流上方。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a51/92f/cc2/a5192fcc2c5718f33bafc631f60a07a8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在河上的对象。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了防止在河流上创建特殊对象，我们更改了属性</font></font><code>HexCell.SpecialIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">仅当单元格中没有河流时，我们才会更改索引。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &amp;&amp; !HasRiver) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RefreshSelfOnly(); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，添加河流时，我们将需要除去所有特殊对象。</font><font style="vertical-align: inherit;">河水应将它们洗净。</font><font style="vertical-align: inherit;">这可以通过在方法中将</font></font><code>HexCell.SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊对象的索引设置为0 </font><font style="vertical-align: inherit;">来完成</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { … hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; specialIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; neighbor.incomingRiver = direction.Opposite(); neighbor.specialIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们避开道路 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">像河流一样，道路上的特殊物体也很差劲，但并非一切都那么可怕。</font><font style="vertical-align: inherit;">您甚至可以原样离开道路。</font><font style="vertical-align: inherit;">一些设施可能与道路兼容，而其他设施则可能不兼容。</font><font style="vertical-align: inherit;">因此，可以使它们依赖于对象。</font><font style="vertical-align: inherit;">但是我们将使其变得更容易。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3b/ebf/939/b3bebf9399ed016e8d79a4c1ee53ace8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在路上的对象。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，请让特殊的物体挡路。</font><font style="vertical-align: inherit;">因此，在更改特殊对象的索引时，我们还将从单元格中删除所有道路。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpecialIndex { … <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (specialIndex != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &amp;&amp; !HasRiver) { specialIndex = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; RemoveRoads(); RefreshSelfOnly(); } } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果我们删除特定对象怎么办？</font></font></b> <div class="spoiler_text">      0,   ,       .            . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此外，这意味着在添加道路时，我们将必须执行其他检查。</font><font style="vertical-align: inherit;">仅当所有像元都不是具有特殊对象的像元时，我们才添加道路。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction) &amp;&amp; !IsSpecial &amp;&amp; !GetNeighbor(direction).IsSpecial &amp;&amp; GetElevationDifference(direction) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 避免其他物体 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特殊对象不能与其他类型的对象混合。</font><font style="vertical-align: inherit;">如果它们重叠，则看起来会不整洁。</font><font style="vertical-align: inherit;">它也可能取决于特定的对象，但是我们将使用相同的方法。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03b/7f1/8fc/03b7f18fc9f9d7543bdb0d9c24a074e2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与其他对象相交的对象。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，我们将隐藏较小的对象，就像它们在水下一样。</font><font style="vertical-align: inherit;">这次我们将签入</font></font><code>HexFeatureManager.AddFeature</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddFeature</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 避免饮水 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们也有水问题。</font><font style="vertical-align: inherit;">洪水期间特殊功能会持续存在吗？</font><font style="vertical-align: inherit;">由于我们要摧毁淹没单元中的小物体，因此对特殊物体也要这样做。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/479/e79/8d9479e79cb0555c81f562dc32937552.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">水中的物体。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于</font></font><code>HexGridChunk.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们执行了洪水和特殊，和普通对象相同的检查。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; !cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater &amp;&amp; cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于两个操作员</font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在都在检查电池是否在水下，因此我们可以转移测试并仅执行一次。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.IsUnderwater) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cell.HasRiver &amp;&amp; !cell.HasRoads) { features.AddFeature(cell, cell.Position); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IsSpecial) { features.AddSpecialFeature(cell, cell.Position); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于实验来说，这么多的对象对我们来说就足够了。</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">统一包装</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425463/">https://habr.com/ru/post/zh-CN425463/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425449/index.html">更新上下文广告的方法：Yandex.Direct Turbo Pages</a></li>
<li><a href="../zh-CN425453/index.html">从太空侵略者到半条命2：Dzdoks游戏的故事</a></li>
<li><a href="../zh-CN425457/index.html">二十个谜题（疯狂，惊人的几何形状）</a></li>
<li><a href="../zh-CN425459/index.html">升级到Windows 1809（有时）会破坏配置文件中的所有文件</a></li>
<li><a href="../zh-CN425461/index.html">发展与安全：塞思·沃戈（Seth Wargo）和丽兹·赖斯（Liz Rice）访谈</a></li>
<li><a href="../zh-CN425465/index.html">设计师如何赚钱，这是工作和寻找想法的理想工具</a></li>
<li><a href="../zh-CN425467/index.html">引擎雷诺D4F> B4D（又名SCe）。 代际变化。 驾驶者外观</a></li>
<li><a href="../zh-CN425469/index.html">Python作者不再领导开发。 它会使语言变得更好还是更坏？</a></li>
<li><a href="../zh-CN425471/index.html">使用Python处理图片</a></li>
<li><a href="../zh-CN425473/index.html">关于Python和通信的会议</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>