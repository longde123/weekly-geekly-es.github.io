<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüé® üßìüèæ üíë L'algorithme d'interaction de centaines de milliers de particules uniques sur le GPU, dans GLES3 et WebGL2 üë©üèø‚Äçü§ù‚Äçüë®üèª ‚öïÔ∏è üë©üèª‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Description de l'algorithme logique et analyse d'un exemple de travail sous la forme d'un jeu techno-d√©mo 


 Version WebGL2 de cette d√©mo https://dan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>L'algorithme d'interaction de centaines de milliers de particules uniques sur le GPU, dans GLES3 et WebGL2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474676/"><h1 id="opisanie-algoritma-logiki-i-razbor-rabochego-primera-v-vide-tehno-demki-igry">  Description de l'algorithme logique et analyse d'un exemple de travail sous la forme d'un jeu techno-d√©mo </h1><br><p>  Version WebGL2 de cette d√©mo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://danilw.itch.io/flat-maze-web pour d'</a> autres liens, voir l'article. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HawWnuMn1mc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 id="statya-razbita-na-dve-chasti-snachala-pro-logiku-i-vtoraya-chast-pro-primenenie-v-igre-pervaya-chast">  L'article est divis√© en deux parties, d'abord sur la logique, et la deuxi√®me partie sur l'application dans le jeu, la <em>premi√®re partie</em> : </h3><br><ul><li>  Caract√©ristiques cl√©s </li><li>  Liens et br√®ve description. </li><li>  L'algorithme de la logique. </li><li> Les limites de la logique.  Bogues / fonctionnalit√©s et bogues d'angle. </li><li>  Acc√®s aux donn√©es d'index. </li></ul><br><h3 id="dalshe-opisanie-igrovoy-demki-vtoraya-chast">  Description plus d√©taill√©e de la d√©mo du jeu, <em>deuxi√®me partie</em> : </h3><br><ul><li>  Fonctionnalit√©s utilis√©es de cette logique.  Et le rendu rapide d'un million de particules de pixels. </li><li>  Impl√©mentation, quelques commentaires sur le code, description de la collision dans deux directions.  Et l'interaction avec le joueur. </li><li>  Liens vers les graphiques utilis√©s avec opengameart et un shader pour les ombres.  Et le lien de l'article vers cyberleninka.ru </li></ul><a name="habracut"></a><br><h1 id="chast-1">  Partie 1 </h1><br><h1 id="1-klyuchevye-osobennosti">  1. Caract√©ristiques cl√©s </h1><br><p> <strong>L'id√©e</strong> est une collision / physique de centaines de milliers de particules entre elles, en temps r√©el, o√π chaque particule a un identifiant unique. </p><br><p>  Lorsque chaque particule est index√©e, <strong>il est possible de contr√¥ler tous les param√®tres de n'importe quelle particule</strong> , par exemple la masse, sa sant√© (hp) ou les dommages, l'acc√©l√©ration, la d√©c√©l√©ration, les objets √† rencontrer et les r√©actions √† l'√©v√©nement en fonction du type / indice de la particule, ainsi que des temporisateurs uniques pour chaque particule , et ainsi de suite si n√©cessaire. </p><br><p>  <strong>Toute la logique sur GLSL est enti√®rement portable sur n'importe quel moteur de jeu</strong> et tout syst√®me d'exploitation prenant en charge GLES3. </p><br><p>  <em>Le nombre maximum de particules</em> est √©gal √† la taille du framebuffer (fbo, tous les pixels). </p><br><p>  <em>Un nombre confortable de particules</em> (lorsqu'il y a de la place pour que les particules interagissent) est <code>(Resolution.x*Resolution.y/2)/2</code> est chaque deuxi√®me pixel en <code>x</code> et chaque deuxi√®me pixel en <code>y</code> , c'est pourquoi la description logique le dit. </p><br><p>  La premi√®re partie de l'article montre la logique minimale; dans la seconde, en utilisant l'exemple d'un jeu, la logique avec un grand nombre de conditions d'interaction. </p><br><h1 id="2-ssylki-i-kratkoe-opisanie">  2. Liens et br√®ve description </h1><br><p>  J'ai fait trois d√©mos sur cette logique: </p><br><p>  <strong>1. Sur GLSL fragment-shader</strong> , sur shadertoy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.shadertoy.com/view/tstSz7</a> , voir le code BufferC dedans toute la logique.  Ce code vous permet √©galement d'afficher des centaines de milliers de particules avec leurs UV, dans une position arbitraire, sur un fragment-shader sans utiliser de particules instanci√©es. </p><br><p><img src="https://habrastorage.org/webt/8a/-w/l7/8a-wl7z8v954zwdyxqaph8eusao.png"></p><br><p>  <strong>2. Logique de portage sur les particules instanci√©es</strong> (utilis√©e par Godot comme moteur) </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/fRu9PA4XHPQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Liens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Version Web</a> , <a href="">exe (win)</a> , projet de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sources</a> <em>particules_2D_self_collision</em> . </p><br><p>  Br√®ve description: <strong>Ceci est une mauvaise d√©monstration sur les particules instanci√©es</strong> , car je fais l'augmentation maximale l√† o√π toute la carte est visible, les particules 640x360 (230k) sont toujours trait√©es, c'est beaucoup.  <strong>Voir ci-dessous dans la description du jeu, l√† je l'ai bien fait, sans particules suppl√©mentaires.</strong>  (il y a une erreur d'indice de particules dans la vid√©o, c'est corrig√© dans le code) </p><br><p>  <strong>3. Le jeu, √† ce sujet ci-dessous dans la description du jeu.</strong>  Liens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Version Web</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exe (win)</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sources</a> </p><br><h1 id="3-algoritm-raboty-logiki">  3. L'algorithme de la logique </h1><br><p>  En bref: </p><br><p>  La logique est similaire √† celle du sable tombant, chaque pixel pr√©serve la valeur fractionnelle de la position (d√©calage √† l'int√©rieur de son pixel) et l'acc√©l√©ration actuelle. </p><br><p>  La logique v√©rifie les pixels dans le rayon 1, que leur prochaine position veut aller √† ce pixel <em>(√† cause de cette restriction, voir les restrictions ci-dessous)</em> , aussi les pixels dans le rayon 2 pour la r√©pulsion (collision). </p><br><p>  L'index unique est sauvegard√© en traduisant la logique en int-float, et en r√©duisant la taille pour la position donn√©e <code>pos</code> et la vitesse <code>pos</code> . </p><br><p>  Les donn√©es sont stock√©es de cette mani√®re: <em>(√† cause de ce bogue, voir restrictions)</em> </p><br><pre> <code class="plaintext hljs">pixel.rgba r=[0xfffff-posx, 0xf-data] g=[0xfffff-posy, 0xf-data] b=[0xffff-velx, 0xff-data] a=[0xffff-vely, 0xff-data]</code> </pre> <br><p><img src="https://habrastorage.org/webt/46/ad/io/46adionlolw3vm5zfry5javhgxk.png"></p><br><p>  <strong>Dans le code</strong> , num√©ros de ligne pour BufC <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.shadertoy.com/view/tstSz7</a> , 115 transition-check, 139 collision-checks. </p><br><p>  Ce sont de simples boucles pour prendre des valeurs adjacentes.  Et la condition est, si la position est prise √©gale √† la position du pixel actuel, alors nous d√©pla√ßons ces donn√©es vers ce pixel <em>(en raison de cette restriction)</em> , et la valeur de <code>vel</code> change en fonction des pixels voisins, le cas √©ch√©ant. </p><br><p>  <em>C'est toute la logique des particules.</em> </p><br><p>  <strong>Il est pr√©f√©rable de placer les particules √† une distance de 1 pixel les unes des autres</strong> si elles sont plus proches que 1 pixel, puis il y aura r√©pulsion, par exemple, une carte avec un labyrinthe dans le jeu, les particules se tiennent √† leur place sans se d√©placer en raison de la distance de 1 pixel entre elles. </p><br><p>  Vient ensuite le rendu (rendu), <em>dans le cas du fragment-shader, les</em> pixels sont pris dans un rayon de 1 pour afficher les zones d'intersection.  <em>Dans le cas de particules instanci√©es, un</em> pixel est pris √† l'adresse <code>INSTANCE_ID</code> traduit d'une vue lin√©aire en un tableau bidimensionnel. </p><br><h1 id="4-ogranicheniya-logiki-bagiosobennosti-i-bagi-angle">  4. Limitations de la logique.  Bogues / fonctionnalit√©s et bogues ANGLE </h1><br><ol><li>  <strong>La taille de pixel</strong> , <code>BALL_SIZE</code> dans le code, doit √™tre dans les limites de calcul, sup√©rieure √† <code>sqrt(2)/2</code> et inf√©rieure √† <code>1</code> .  Plus proche de 1, moins d'espace pour marcher √† l'int√©rieur du pixel (le pixel lui-m√™me), moins il y a d'espace.  Une telle taille est n√©cessaire pour que les pixels ne tombent pas entre eux, moins de 1 peut √™tre d√©fini lorsque vous avez de petits objets, une illusion d'objets de moins de 1 pixel (calcul√©e) est cr√©√©e. </li><li>  <strong>La vitesse</strong> ne peut pas d√©passer <code>1</code> pixel sinon les pixels dispara√Ætront.  Mais il est possible d'avoir une vitesse sup√©rieure √† <code>1</code> par trame, si vous effectuez plusieurs <em>framebuffer (fbo / viewport)</em> et traitez plusieurs √©tapes logiques √† la fois, la vitesse de trame augmentera du nombre de fois √©gal au nombre de fbo suppl√©mentaires.  C'est ce que j'ai fait dans la d√©monstration de fruits, et en utilisant le lien vers shadertoy (bufC copi√© dans bufD). </li><li>  <strong>Limitation de la pression</strong> (comme la gravit√© ou une autre carte force-normale).  Si plusieurs pixels voisins en prennent la position (voir l'image ci-dessus), alors un seul est enregistr√©, les pixels restants disparaissent.  <em>C'est facile √† remarquer dans la d√©mo sur shadertoy,</em> placez la souris sur Force, changez la valeur de <code>MOUSE_F</code> en <em>commun</em> √† <code>10</code> , et dirigez les particules vers le coin de l'√©cran, elles dispara√Ætront les unes dans les autres.  Ou la m√™me chose avec la valeur de gravit√© <code>maxG</code> en <em>commun</em> . </li><li>  <strong>Bug dans l'angle.</strong>  Pour que cette logique fonctionne dans les particules GPU (instanci√©es), il est pr√©f√©rable (moins cher, plus rapide) de calculer la position, et tous les autres param√®tres de particules √† afficher, dans l' <em>instance-shader</em> .  Mais Angle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne permet pas l'</a> utilisation de plus d'une texture fbo pour un shader, donc le calcul d'une partie de la logique doit √™tre transf√©r√© √† <em>Vertex-shader</em> o√π transf√©rer le num√©ro d'index du shader d'instance.  C'est ce que j'ai fait dans les deux d√©mos avec des particules GPU. </li><li>  <strong>Un bug s√©rieux</strong> dans les deux d√©mos (sauf pour le jeu) la valeur de position sera perdue si ce n'est pas un multiple de <code>1/0xfffff</code> test de bug est ici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.shadertoy.com/view/WdtSWS</a> <br>  Plus pr√©cis√©ment, ce n'est pas un bug, et il devrait en √™tre ainsi, pour plus de simplicit√©, dans le cadre de cet algorithme, je l'ai appel√© un bug. </li></ol><br><p>  <strong>Correction d'un bug:</strong> <br>  <em>Ne convertissez pas la valeur de position en flottant</em> , car <code>0xff</code> dispara√Ætra, 8 bits disponibles pour les donn√©es, mais la valeur <code>0xffff</code> pour les donn√©es restera, ce qui peut suffire pour beaucoup de choses. <br>  <em>C'est ce que j'ai fait dans la d√©mo du jeu</em> , j'utilise uniquement <code>0xffff</code> pour les donn√©es o√π le type de particule, le minuteur d'animation, la sant√© sont stock√©s et il y a encore de l'espace libre. </p><br><h1 id="5-dostup-k-dannym-po-indeksu">  5. Acc√®s aux donn√©es d'index </h1><br><p>  instanced-particule a son propre <code>INSTANCE_ID</code> , il prend un pixel de la texture du framebuffer avec la logique des particules (bufC, exemple pour shader), si l√† nous d√©compressons la particule (voir stockage de donn√©es) <em>ID de cette particule</em> , par <em>cet ID</em> nous lisons la texture avec des donn√©es pour les particules (bufB , un exemple sur un shader). </p><br><p>  Dans l'exemple shadertoy, bufB ne stocke que la couleur de chaque particule, mais il est √©vident qu'il peut y avoir des donn√©es, comme la masse, l'acc√©l√©ration, la d√©c√©l√©ration ont √©crit plus t√¥t, ainsi que toutes les actions logiques (par exemple, vous pouvez d√©placer n'importe quelle particule √† n'importe quelle position (t√©l√©port) si c'est fait) l'action logique correspondante dans le code), vous pouvez √©galement contr√¥ler le mouvement de n'importe quelle particule ou groupe √† partir du clavier ... </p><br><p>  <strong>Je veux dire que vous pouvez faire n'importe quoi avec chacune des particules comme s'il s'agissait de particules ordinaires dans un tableau sur le processeur, l'acc√®s bidirectionnel √† partir de la particule GPU peut changer son √©tat, mais aussi √† partir du CPU, vous pouvez changer l'√©tat des particules par index (en utilisant des actions logiques et de la texture tampon de donn√©es).</strong> </p><br><h1 id="chast-2">  2e partie </h1><br><h1 id="1-ispolzuemye-vozmozhnosti-etoy-logiki-i-bystryy-rendering-milliona-chastic-pikseley">  1. Fonctionnalit√©s utilis√©es de cette logique.  Et rendu rapide d'un million de particules de pixels </h1><br><p>  La taille du framebuffer (fbo / viewport) pour les particules est de 1280x720, les pi√®ces sont situ√©es apr√®s 1, c'est 230 mille particules actives (√©l√©ments actifs dans le labyrinthe). <br>  <em>Il n'y a toujours pas plus de 12 000 particules instanci√©es par le GPU sur l'√©cran.</em> </p><br><p>  <strong>La logique utilise:</strong> </p><br><ul><li>  La logique du lecteur est distincte de la logique des particules et ne lit que les donn√©es du tampon de particules. </li><li>  Le joueur ralentit lorsqu'il entre en collision avec des objets. </li><li>  Les objets de type monstre infligent des d√©g√¢ts au joueur. </li><li>  Le joueur a 2 attaques, l'une repousse tout autour, la seconde cr√©e des particules comme une <em>boule de feu</em> (l'image est comme √ßa) </li><li>  Le type <em>boule de feu</em> a sa propre masse, et le suivi bilat√©ral des collisions avec d'autres particules fonctionne. </li><li>  d'autres particules telles que le <em>pl√¢tre</em> et les <em>zombies</em> (un type de pl√¢tre est invuln√©rable) sont d√©truites lors d'une collision avec une <em>boule de feu</em> </li><li>  <em>boule de feu</em> s'√©teint apr√®s une collision </li><li>  niveaux <em>physiques</em> - les arbres et les carr√©s sont repouss√©s par le joueur, les autres particules n'interagissent pas, aucune acc√©l√©ration n'agit sur la <em>boule de feu</em> </li><li>  les minuteries d'animation sont uniques √† chaque particule </li></ul><br><p>  Par rapport √† la d√©monstration de fruits, o√π il y a des frais g√©n√©raux, <strong>dans ce jeu, le nombre de particules instanci√©es par le GPU n'est que de 12 mille.</strong> </p><br><p>  Cela ressemble √† ceci: </p><br><p><img src="https://habrastorage.org/webt/lk/kt/9-/lkkt9-59aoftj47pqbpy4q5anfk.png"></p><br><p>  Leur nombre d√©pend du zoom ( <em>zoom</em> ) actuel de la carte, et l'augmentation est limit√©e √† une certaine valeur, donc seuls ceux qui sont visibles √† l'√©cran sont pris en compte. <br>  L'√©cran change avec le joueur, la logique de calcul des d√©calages est un peu complexe, et tr√®s situationnelle, je doute qu'elle trouvera application dans un autre projet. </p><br><h1 id="2-realizaciya-nemnogo-kommentariev-k-kodu">  2. Impl√©mentation, quelques commentaires sur le code. </h1><br><p>  Tout le code du jeu est sur le GPU. </p><br><p>  <strong>La logique de calcul du d√©calage des particules</strong> dans un √©cran avec une augmentation de la fonction <em>vertex</em> dans le fichier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">/shaders/scene2/particle_logic2.shader</a> est un fichier de shader de particules (vertex et fragment), pas un shader instanci√©, un shader instanci√© ne fait rien, ne passe que son index en raison de bug d√©crit ci-dessus. </p><br><p>  <strong>particules par type</strong> et toute la logique de l'interaction des particules dans un fichier, il s'agit d'un fichier d'un fichier shader <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">frame shaders / scene2 / particules_fbo_logic.shader</a> </p><br><pre> <code class="plaintext hljs">// 1-2 ghost // 3-zombi // 4-18 blocks // +20 is on fire // 40 is bullet(right) 41 left 42 top 43 down</code> </pre> <br><p>  pixel de <strong>stockage de donn√©es</strong> <code>[pos.x, pos.y, [0xffff-vel.x, 0xff-data1],[0xffff-vel.y, 0xff-data2]]</code> <br>  data1 est un type, data2 est un HP ou une minuterie. </p><br><p>  <em>La minuterie passe sur des images dans chaque particule</em> , la valeur maximale de la minuterie est de 255, je n'en ai pas tellement besoin, j'utilise seulement 1-16 maximum ( <code>0xf</code> ), et <code>0xf</code> reste inutilis√© o√π, par exemple, vous pouvez stocker la vraie valeur HP, elle n'est pas utilis√©e pour moi.  (c'est-√†-dire, oui, <strong>j'utilise <code>0xff</code> pour la minuterie</strong> , mais en fait je n'ai que moins de 16 images d'animation, et <code>0xf</code> suffisant, mais je n'avais pas besoin de donn√©es suppl√©mentaires) <br>  En fait, <code>0xff</code> utilis√© que sur la minuterie de la combustion des arbres, ils se transforment en zombies apr√®s 255 images.  La logique de temporisation est partiellement dans le <code>type_hp_logic</code> dans le shader de framebuffer de particules (lien ci-dessus). </p><br><h1 id="primer-raboty-kollizii-v-dve-storony-kogda-fireball-gasnet-pri-pervom-udare-i-obekt-s-kotorym-byl-udar-tozhe-vypolnyaet-svoe-deystvie">  <strong>Un exemple d'une op√©ration de collision bidirectionnelle</strong> lorsqu'une <em>boule de feu</em> s'√©teint au premier coup, et l'objet avec lequel elle a √©t√© frapp√©e effectue √©galement son action. </h1><br><p>  File <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shaders / scene2 / particules_fbo_logic.shader</a> ligne 438: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((real_index == <span class="hljs-number"><span class="hljs-number">40</span></span>) || (real_index == <span class="hljs-number"><span class="hljs-number">41</span></span>) || (real_index == <span class="hljs-number"><span class="hljs-number">42</span></span>) || (real_index == <span class="hljs-number"><span class="hljs-number">43</span></span>)) &amp;&amp; (type_hp.y &gt; <span class="hljs-number"><span class="hljs-number">22</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h_id = get_id(fragCoord + vec2(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(x), <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(y))); ivec2 htype_hp = unpack_type_hp(h_id); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hreal_index = htype_hp.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((hreal_index != <span class="hljs-number"><span class="hljs-number">40</span></span>) &amp;&amp; (hreal_index != <span class="hljs-number"><span class="hljs-number">41</span></span>) &amp;&amp; (hreal_index != <span class="hljs-number"><span class="hljs-number">42</span></span>) &amp;&amp; (hreal_index != <span class="hljs-number"><span class="hljs-number">43</span></span>)) type_hp.y = <span class="hljs-number"><span class="hljs-number">22</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!need_upd) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h_id = get_id(fragCoord + vec2(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(x), <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(y))); ivec2 htype_hp = unpack_type_hp(h_id); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hreal_index = htype_hp.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((hreal_index == <span class="hljs-number"><span class="hljs-number">40</span></span>) || (hreal_index == <span class="hljs-number"><span class="hljs-number">41</span></span>) || (hreal_index == <span class="hljs-number"><span class="hljs-number">42</span></span>) || (hreal_index == <span class="hljs-number"><span class="hljs-number">43</span></span>)) &amp;&amp; (htype_hp.y &gt; <span class="hljs-number"><span class="hljs-number">22</span></span>)) { need_upd = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } }</code> </pre> <br><p>  <code>real_index</code> est un type, les types sont r√©pertori√©s ci-dessus, 40-43 est une <em>boule de feu</em> . <br>  en outre <code>type_hp.y &gt; 22</code> est la valeur de la minuterie, si elle est sup√©rieure √† 22, alors la <em>boule de feu</em> n'a rien rencontr√©. <br>  <code>h_id = get_id(...</code> prendre la valeur du type et HP (timer) de la particule rencontr√©e <br>  <code>hreal_index != 40...</code> type ignor√© (autre <em>boule de feu</em> ) <br>  <code>type_hp.y = 22</code> une minuterie est r√©gl√©e sur 22, c'est un indicateur que cette <em>boule de feu est entr√©e en</em> collision avec un objet. <br>  <code>else { if (!need_upd)</code> variable need_upd v√©rifie qu'il n'y a pas de collisions r√©p√©t√©es, puisque la fonction est en boucle, on rencontre une <em>boule de feu</em> . <br>  <code>h_id = get_id(...</code> s'il n'y a pas encore eu de collision, nous prenons un objet de type et timer. <br>  <code>hreal_index == 40...htype_hp.y &gt; 22</code> que l'objet de collision est une <em>boule de feu</em> et qu'il ne s'√©teint pas. <br>  <code>need_upd = true</code> qu'il est n√©cessaire de mettre √† jour le type car il a rencontr√© une <em>boule de feu</em> . </p><br><p>  ligne suppl√©mentaire 481 <br>  <code>if((need_upd)&amp;&amp;(real_index&lt;24)){</code> real_index &lt;24 par type inf√©rieur √† 24, il y a des arbres zombies et fant√¥mes non br√ªlants, puis dans cette condition, nous mettons √† jour le type en fonction du type actuel. </p><br><p>  Ainsi, presque toute interaction d'objets peut √™tre effectu√©e. </p><br><h1 id="vzaimodeystvie-s-igrokom">  <strong>Interaction avec le joueur:</strong> </h1><br><p>  File <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shaders / scene2 / logic.shader</a> line 143 function <code>player_collision</code> </p><br><p>  Cette logique lit les pixels autour du joueur dans un rayon de 4x4 pixels, prend la position de chacun des pixels et la compare √† la position du joueur, si un √©l√©ment est trouv√©, puis la v√©rification de type est la suivante, s'il s'agit d'un monstre, nous prenons HP du joueur. </p><br><p>  <em>Cela fonctionne un peu inexact et je n'ai pas voulu le r√©parer</em> , cette fonction peut √™tre rendue plus pr√©cise. </p><br><p>  <strong>Les particules s'√©loignent du joueur et l'effet de r√©pulsion lors d'une attaque:</strong> </p><br><p>  Un framebuffer (viewport) est utilis√© pour √©crire la normale des actions en cours, et les particules ( <em>particules_fbo_logic.shader</em> ) prennent cette texture (de la normale) √† sa position et appliquent la valeur √† sa vitesse et sa position.  Le code entier de cette logique est litt√©ralement juste quelques lignes, fichier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">force_collision.shader</a> </p><br><p>  <strong>Au clic du bouton gauche de la souris, des obus de</strong> <em>boule de feu</em> <strong>volent;</strong> leur apparence n'est <em>pas tr√®s naturelle</em> , ils n'ont pas corrig√© et sont partis sous cette forme. </p><br><p>  Vous pouvez soit cr√©er une zone (forme) normale pour les particules d'apparition avec un d√©calage apparaissant par rapport au joueur (cela n'est pas fait). <br>  Ou vous pouvez faire de la <em>boule de feu un</em> objet distinct en tant que joueur et dessiner normalement dans un tampon pour √©loigner les particules de la <em>boule de feu</em> , c'est-√†-dire par analogie avec le joueur ... <br>  Qui a besoin de penser qu'ils le d√©couvriront par eux-m√™mes. </p><br><h1 id="3-ssylki-na-ispolzuemuyu-grafiku-s-opengameart-i-sheyder-teney">  3. Liens vers les graphiques utilis√©s avec opengameart et le shadow shader </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>On m'a donn√© un lien vers un article sur cyberleninka.ru</strong></a> <br>  Dans lequel la description de l'algorithme que j'ai utilis√©, <em>il y a</em> peut-√™tre <em>une description plus d√©taill√©e et correcte</em> que dans cet article, mon article. </p><br><p>  <strong>Le shader d'ombres</strong> fonctionne tr√®s simplement, bas√© sur ce shader <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.shadertoy.com/view/XsK3RR</a> (j'ai un code modifi√©) <br>  Shader construit une <em>carte lumineuse radiale 1D</em> </p><br><p><img src="https://habrastorage.org/webt/e2/rh/op/e2rhopezigurqa3rkvhrb44vxxw.png"></p><br><p>  et ombrage dans le code de peinture au sol <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">shaders / scene2 / mainImage.shader</a> </p><br><p>  <strong>Liens vers les graphiques utilis√©s</strong> , tous les graphiques du jeu depuis le site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://opengameart.org</a> <br>  <em>boule de feu</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://opengameart.org/content/animated-traps-and-obstacles</a> <br>  personnage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://opengameart.org/content/legend-of-faune</a> <br>  arbres et blocs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://opengameart.org/content/lolly-set-01</a> <br>  (et quelques autres photos avec opengameart) </p><br><p>  <strong>Les graphiques dans le menu ont √©t√©</strong> obtenus par le shader 2D_GI, un utilitaire pour cr√©er de tels menus: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HTuG5UOMC74" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Qui a lu jusqu'au bout - bravo :) <br>  Si vous avez des questions, demandez, je peux compl√©ter la description sur demande. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr474676/">https://habr.com/ru/post/fr474676/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr474664/index.html">Pour augmenter l'attention, notre cerveau n'augmente pas la concentration, mais utilise des filtres d'information</a></li>
<li><a href="../fr474666/index.html">Comment ne pas r√©√©crire un projet dans Rust</a></li>
<li><a href="../fr474668/index.html">Actions GitHub en tant que CI / CD pour un site sur un g√©n√©rateur statique et des pages GitHub</a></li>
<li><a href="../fr474672/index.html">React, JSX, importation de modules ES (y compris dynamiques) dans un navigateur sans Webpack</a></li>
<li><a href="../fr474674/index.html">Vision industrielle et m√©decine</a></li>
<li><a href="../fr474678/index.html">Khronos Group a cr√©√© un r√©f√©rentiel unifi√© avec des exemples Vulkan</a></li>
<li><a href="../fr474680/index.html">AI et 2048. Partie 2: √©cr√™tage Minimax + alpha beta</a></li>
<li><a href="../fr474686/index.html">Histoire fantastique "Salut" (10 min.)</a></li>
<li><a href="../fr474690/index.html">Cr√©ation d'une console √† hauteur variable pour un travail plus pratique sur un ordinateur</a></li>
<li><a href="../fr474692/index.html">Revue Skaffold pour le d√©veloppement de Kubernetes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>