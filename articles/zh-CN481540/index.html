<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🍳 🤴🏾 🥢 通过DMABUF重新加载OpenGLESv2纹理 🎾 🤱🏻 🚙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我想谈谈通过DMABUF更新OpenGLES纹理有多么容易。 我看着哈勃（Habr），令我惊讶的是，没有找到关于该主题的一篇文章。 在哈勃问答中，Q＆A也没有找到任何东西。 这对我来说有点奇怪。 该技术出现在很早以前，尽管网络上确实没有太多有关该技术的信息，但所有这些技术都是模糊且矛盾的。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>通过DMABUF重新加载OpenGLESv2纹理</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481540/"><iframe width="560" height="315" src="https://www.youtube.com/embed/Cz2cywrC1ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 在本文中，我想谈谈通过DMABUF更新OpenGLES纹理有多么容易。 我看着哈勃（Habr），令我惊讶的是，没有找到关于该主题的一篇文章。 在哈勃问答中，Q＆A也没有找到任何东西。 这对我来说有点奇怪。 该技术出现在很早以前，尽管网络上确实没有太多有关该技术的信息，但所有这些技术都是模糊且矛盾的。 <br><br> 在像上面的演示中那样编写这样的视频播放器之前，我从不同的来源逐步收集了所有这些信息。 在这里，在一个演示中，我基于gstreamer库的自制视频播放器在渲染之前每次都将视频帧加载到OpenGLESv2纹理中。 由Raspberry Pi4驱动。 只需将帧复制到专门分配的内存中，然后DMA将其传输到GPU内存和纹理中。 接下来，我将告诉您我是如何做到的。 <br><a name="habracut"></a><br> 通常，使用OpenGLESv2的程序员仅创建一次纹理，然后将其渲染到场景对象即可。 发生这种情况是因为角色的服装很少更改，有时使用glTexSubImage2D（）重新加载纹理并不困难。 但是，真正的问题始于纹理是动态的，当您需要在渲染期间几乎每帧更新它时。  glTexSubImage2D（）函数非常慢。 好吧，速度有多慢-当然，这完全取决于计算机和图形卡。 我想找到一种解决方案，即使在像Raspberry这样的弱单板卡上也可以使用。 <br><br> 许多现代计算机（包括SoC单板计算机）的体系结构都使得处理器内存与GPU内存分离。 通常，用户程序无法直接访问GPU内存，因此您需要使用各种AP​​I函数，例如相同的glTexSubImage2D（）。 此外，我在某处读到，纹理的内部表示形式可能与传统的图片表示形式（像素序列）有所不同。 我不知道这是真的。 可能吧 <br><br> 那么DMABUF技术给我带来了什么？ 内存是专门分配的，任何线程的进程都可以随时在其中写入像素。  DMA本身会将所有更改转移到GPU内存中的纹理。 那不是很漂亮吗？ <br><br> 我必须马上说出我对PBO-像素缓冲区对象的了解，通常是在PBO的帮助下完成了动态纹理更新，似乎也在那里使用了DMA，但是PBO仅出现在OpenGLESv3中，而不是出现在所有实现中。 所以不，a，这不是我的方式。 <br><br>  Raspberry程序员和游戏开发人员甚至Android程序员都可能对本文感兴趣，因为在那里也使用了OpenGLES，而且我敢肯定，那里也有这种DMABUF技术（至少我敢肯定，您可以在Android上使用它） NDK）。 <br><br> 我将在Raspberry Pi4上使用DMABUF编写程序。 该程序还应该（并且将会）在普通的Intel x86 / x86_64计算机上运行，​​例如在ubuntu下。 <br><br> 在本文中，我假设您已经知道如何使用OpenGLESv2 API对图形进行编程。 虽然，这些挑战不会很多。 通常，我们会拥有ioctl魔术。 <br><br> 因此，首先要做的是确保平台上可用的API必须支持DMABUF。 为此，请检查EGL扩展列表： <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* EglExtString = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)eglQueryString( esContext-&gt;eglDisplay, EGL_EXTENSIONS ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">strstr</span></span>( EglExtString, <span class="hljs-string"><span class="hljs-string">"EGL_EXT_image_dma_buf_import"</span></span>) ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF feature must be supported!!!\n"</span></span>; }</code> </pre> <br> 因此，我们将立即了解是否有使用DMABUF的希望，或者没有希望。 例如，在Raspberry Pi3和以前的所有板上，都没有希望。 通常，通过带有BRCM胸针的特殊库，甚至在某种程度上甚至剥离了OpenGLESv2。 现在在Raspberry Pi4上有一个真正的OpenGLES，扩展名为EGL_EXT_image_dma_buf_import是hooray。 <br><br> 我会立即记下单板Pi4上的操作系统，否则可能还会出现以下问题： <br><br><pre> <code class="plaintext hljs">pi@raspberrypi:~ $ lsb_release -a No LSB modules are available. Distributor ID: Raspbian Description: Raspbian GNU/Linux 10 (buster) Release: 10 Codename: buster pi@raspberrypi:~ $ uname -a Linux raspberrypi 4.19.75-v7l+ #1270 SMP Tue Sep 24 18:51:41 BST 2019 armv7l GNU/Linux</code> </pre><br> 我还注意到EGL_EXT_image_dma_buf_import扩展是在Orange Pi PC（Mali-400）/ PC2（Mali-450）上使用的，除非您当然可以在这些板上运行Mali GPU（在官方程序集中没有，我将其安装在Armbian上，而且我自己做了）内核驱动程序集）。 也就是说，DMABUF几乎无处不在。 只需取用即可。 <br><br> 接下来，您需要打开文件/ dev / dri / card0或/ dev / dri / card1-其中之一，它取决于平台，并且情况有所不同，您需要查找支持DRM_CAP_DUMB_BUFFER的文件： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OpenDrm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(<span class="hljs-string"><span class="hljs-string">"/dev/dri/card0"</span></span>, O_RDWR | O_CLOEXEC); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"cannot open /dev/dri/card0\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> hasDumb = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { close( fd ); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"/dev/dri/card0 has no support for DUMB_BUFFER\n"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//maybe Raspberry Pi4 or other platform fd = open("/dev/dri/card1", O_RDWR | O_CLOEXEC); if( fd &lt; 0 ) { cout &lt;&lt; "cannot open /dev/dri/card1\n"; return -1; } hasDumb = 0; if( drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &amp;hasDumb) &lt; 0 ) { close( fd ); cout &lt;&lt; "/dev/dri/card1 has no support for DUMB_BUFFER\n"; return -1; } } if( !hasDumb ) { close( fd ); cout &lt;&lt; "no support for DUMB_BUFFER\n"; return -1; } //Get DRM authorization drm_magic_t magic; if( drmGetMagic(fd, &amp;magic) ) { cout &lt;&lt; "no DRM magic\n"; close( fd ); return -1; } Window root = DefaultRootWindow( x_display ); if( !DRI2Authenticate( x_display, root, magic ) ) { close( fd ); cout &lt;&lt; "Failed DRI2Authenticate\n"; return -1; } cout &lt;&lt; "DRM fd "&lt;&lt; fd &lt;&lt;"\n"; return fd; }</span></span></code> </pre><br> 顺便说一下，这对我来说是莫名其妙的微妙之处。 某些平台没有提供DRI2Authenticate（）函数的库。 例如，对于Orange Pi PC而言，它并不是处于最佳状态，而是32位版本。 这一切都很奇怪。 但是我在GITHUB上找到了一个这样的存储库： <a href="https://github.com/robclark/libdri2">github.com/robclark/libdri2，</a>它可以被获取，组装和安装，然后一切正常。 奇怪的是，在笔记本电脑上的Ubuntu 18（64位）中没有问题。 <br><br> 如果可以找到并打开/ dev / dri / cardX，则可以继续。 您需要访问KHR（Khronos）的三个非常必要的功能： <br><br><pre> <code class="cpp hljs">PFNEGLCREATEIMAGEKHRPROC funcEglCreateImageKHR = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PFNEGLDESTROYIMAGEKHRPROC funcEglDestroyImageKHR = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; PFNGLEGLIMAGETARGETTEXTURE2DOESPROC funcGlEGLImageTargetTexture2DOES = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; ... funcEglCreateImageKHR = (PFNEGLCREATEIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"eglCreateImageKHR"</span></span>); funcEglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC) eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"eglDestroyImageKHR"</span></span>); funcGlEGLImageTargetTexture2DOES = (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress(<span class="hljs-string"><span class="hljs-string">"glEGLImageTargetTexture2DOES"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( funcEglCreateImageKHR &amp;&amp; funcEglDestroyImageKHR &amp;&amp; funcGlEGLImageTargetTexture2DOES ) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF feature supported!!!\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CloseDrm(); }</code> </pre><br> 现在，我们需要一个为DMABUF创建存储区的函数。 该函数将参数用作位图的宽度，高度，以及将返回DmaFd文件描述符处理程序的指针和指向平面位图内存的指针。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">nt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDmaBuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* DmaFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">** Plane )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dmaFd = *DmaFd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* pplane = *Plane = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Create dumb buffer drm_mode_create_dumb buffer = { 0 }; buffer.width = Width; buffer.height = Height; buffer.handle = 0; buffer.bpp = 32; //Bits per pixel buffer.flags = 0; int ret = drmIoctl( DriCardFd, DRM_IOCTL_MODE_CREATE_DUMB, &amp;buffer); cout &lt;&lt; "DRM_IOCTL_MODE_CREATE_DUMB " &lt;&lt; buffer.handle &lt;&lt; " " &lt;&lt; ret &lt;&lt; "\n"; if (ret &lt; 0) { cout &lt;&lt; "Error cannot DRM_IOCTL_MODE_CREATE_DUMB\n"; return -1; } // Get the dmabuf for the buffer drm_prime_handle prime; memset(&amp;prime, 0, sizeof prime); prime.handle = buffer.handle; prime.flags = /*DRM_CLOEXEC |*/ DRM_RDWR; ret = drmIoctl( DriCardFd, DRM_IOCTL_PRIME_HANDLE_TO_FD, &amp;prime); if (ret &lt; 0) { cout &lt;&lt; "Error cannot DRM_IOCTL_PRIME_HANDLE_TO_FD " &lt;&lt; errno &lt;&lt; " " &lt;&lt; ret &lt;&lt;"\n"; return -1; } dmaFd = prime.fd; // Map the buffer to userspace int Bpp = 32; pplane = mmap(NULL, Width*Height*Bpp/8, PROT_READ | PROT_WRITE, MAP_SHARED, dmaFd, 0); if( pplane == MAP_FAILED ) { cout &lt;&lt; "Error cannot mmap\n"; return -1; } //return valid values *DmaFd = dmaFd; *Plane = pplane; cout &lt;&lt; "DMABUF created "&lt;&lt; dmaFd &lt;&lt; " " &lt;&lt; (void*)Plane &lt;&lt;"\n"; return 0; }</span></span></code> </pre><br> 现在，我们需要创建一个与DmaFd处理程序关联的EGL图像： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDmaBufferImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ESContext* esContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* DmaFd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">** Plane, EGLImageKHR* Image )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dmaFd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* planePtr = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Bpp = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret0 = CreateDmaBuf( Width, Height, &amp;dmaFd, &amp;planePtr ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ret0&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; EGLint img_attrs[] = { EGL_WIDTH, Width, EGL_HEIGHT, Height, EGL_LINUX_DRM_FOURCC_EXT, DRM_FORMAT_ABGR8888, EGL_DMA_BUF_PLANE0_FD_EXT, dmaFd, EGL_DMA_BUF_PLANE0_OFFSET_EXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, EGL_DMA_BUF_PLANE0_PITCH_EXT, Width * Bpp / <span class="hljs-number"><span class="hljs-number">8</span></span>, EGL_NONE }; EGLImageKHR image = funcEglCreateImageKHR( esContext-&gt;eglDisplay, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;img_attrs[<span class="hljs-number"><span class="hljs-number">0</span></span>] ); *Plane = planePtr; *DmaFd = dmaFd; *Image = image; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF pointer "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)planePtr &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"DMA_BUF fd "</span></span> &lt;&lt; (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)dmaFd &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"EGLImageKHR "</span></span> &lt;&lt; image &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br> 最后，我们的考验几乎结束了，我们必须将EGL图像和OpenGLESv2图像链接起来。 该函数返回指向进程地址空间中的内存的指针。 在那里，您可以轻松地从任何处理器线程进行写入，并且随着时间的推移，所有更改都会通过DMABUF自动显示在GPU纹理中。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateVideoTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ESContext* esContext, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Height )</span></span></span><span class="hljs-function"> </span></span>{ CreateDmaBufferImage( esContext, Width, Height, &amp;esContext-&gt;DmaFd, &amp;esContext-&gt;Plane, &amp;esContext-&gt;ImageKHR ); GLuint texId; glGenTextures ( <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;texId ); glBindTexture ( GL_TEXTURE_2D, texId ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE ); funcGlEGLImageTargetTexture2DOES(GL_TEXTURE_2D, esContext-&gt;ImageKHR ); checkGlError( __LINE__ ); UserData *userData = (UserData*)esContext-&gt;userData; userData-&gt;textureV = texId; userData-&gt;textureV_ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> esContext-&gt;Plane; }</code> </pre><br>  GlEGLImageTargetTexture2DOES（..）函数仅执行此绑定。 它使用常规纹理id创建glGenTextures（..），并将其与先前创建的esContext-&gt; ImageKHR EGL图像相关联。 之后，可以在常规着色器中使用纹理userData-&gt; textureV。 指针esContext-&gt; Plane是指向内存中需要写入以更新纹理的区域的指针。 <br><br> 这是一个复制视频帧的代码段： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GstFlowReturn </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_new_sample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( GstAppSink *pAppsink, gpointer pParam )</span></span></span><span class="hljs-function"> </span></span>{ GstFlowReturn ret = GST_FLOW_OK; GstSample *Sample = gst_app_sink_pull_sample(pAppsink); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Sample ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( VideoWidth==<span class="hljs-number"><span class="hljs-number">0</span></span> || VideoHeight==<span class="hljs-number"><span class="hljs-number">0</span></span> ) { GstCaps* caps = gst_sample_get_caps( Sample ); GstStructure* structure = gst_caps_get_structure (caps, <span class="hljs-number"><span class="hljs-number">0</span></span>); gst_structure_get_int (structure, <span class="hljs-string"><span class="hljs-string">"width"</span></span>, &amp;VideoWidth); gst_structure_get_int (structure, <span class="hljs-string"><span class="hljs-string">"height"</span></span>, &amp;VideoHeight); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Stream Resolution "</span></span> &lt;&lt; VideoWidth &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; VideoHeight &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } GstBuffer *Buffer = gst_sample_get_buffer( Sample ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Buffer ) { GstMapInfo MapInfo; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;MapInfo, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(MapInfo)); gboolean Mapped = gst_buffer_map( Buffer, &amp;MapInfo, GST_MAP_READ ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( Mapped ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( dmabuf_ptr ) <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>( dmabuf_ptr, MapInfo.data, MapInfo.size ); gst_buffer_unmap( Buffer, &amp;MapInfo); frame_ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; update_cv.notify_one(); } } gst_sample_unref( Sample ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br> 每当出现新的视频帧时，gstreamer本身都会调用此函数。 我们使用gst_app_sink_pull_sample（）检索它。 该函数具有memcpy（），它将帧复制到DMABUF内存中。 然后设置frame_ready标志，并通过std :: condition_variable update_cv.notify_one（）唤醒呈现的流。 <br><br> 那可能就是全部... <br><br> 虽然没有，我在撒谎。 仍然存在同步问题。 <br><br> 首先是处理器写入内存，但是这些记录可能最终存储在处理器的缓存中，并保存在那里，您需要在记录后进行缓存缓存。 第二个-确切地知道DMA何时已算出并开始渲染就可以了。 老实说，如果我仍然想像第一个，那么第二个-不。 如果您有想法，请在评论中写。 <br><br> 还有一件事。 我正在使用播放视频文件的gstreamer。 我在管道中添加了一个通用的appink，用于接收视频帧。 我从视频帧中获取像素，然后将它们简单地将memcpy（）复制到DMABUF存储区。 呈现在单独的线程main（）中。 但我想摆脱这个副本。 每个副本都是邪恶的。 甚至有一个术语“零复制”。 从文档来看，似乎gstreamer本身可以立即在DMABUF中渲染帧。 不幸的是，我还没有找到一个真实的例子。 我查看了gstreamer的来源-关于它的内容，但是如何确切地使用它尚不清楚。 如果您知道如何在OpenGLESv2纹理中使用gstreamer制作真正的零拷贝帧，请编写。 <br><br> 也许最后一点：在我的项目中，我使用32位位图，这对我而言不是很好。 从gstreamer中获取YUV会更合理，然后视频帧的大小要小得多，但是逻辑很复杂-我必须分别对三个纹理Y，U，V进行3个DMABUF。嗯，着色器也很复杂，您需要将YUV转换为ARGB在着色器中。 <br><br> 您可以<a href="https://github.com/random-prj/video-cube">在github上</a>查看整个项目。 但是，我预先向干净和正确的代码/样式的爱好者致歉。 我承认这是在Google矿山粘贴的帮助下粗心编写的。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN481540/">https://habr.com/ru/post/zh-CN481540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN481530/index.html">Nevanger：提速</a></li>
<li><a href="../zh-CN481532/index.html">内存取证，橡皮鸭和GPO密码。 用r0ot-mi解决问题。 第二部分</a></li>
<li><a href="../zh-CN481534/index.html">是Delphi快死了-错误</a></li>
<li><a href="../zh-CN481536/index.html">域名系统的历史：“战争”协议</a></li>
<li><a href="../zh-CN481538/index.html">20 SEO神话将在2020年消失</a></li>
<li><a href="../zh-CN481542/index.html">验证数字电路。 复习</a></li>
<li><a href="../zh-CN481544/index.html">使用卷积神经网络玩Life（在Keras上）</a></li>
<li><a href="../zh-CN481546/index.html">微处理器和个人计算机的历史：1947年至1974年</a></li>
<li><a href="../zh-CN481548/index.html">JavaScript中的Symbol.iterator</a></li>
<li><a href="../zh-CN481550/index.html">Inmarsat：在家中接收和解码卫星信号</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>