<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥐 🚣🏼 🐷 Kami mulai mempelajari mikrokontroler menggunakan contoh STM32F030f4p6 😃 👩‍👧‍👦 👩🏼‍🤝‍👨🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="0. Sebelum membaca artikel 
 Artikel ini memiliki tujuan sebagai berikut: 



1. perlihatkan cara bekerja secara khusus dengan dewan ini; 
2. tunjukka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami mulai mempelajari mikrokontroler menggunakan contoh STM32F030f4p6</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437234/"><img src="https://habrastorage.org/webt/ex/dh/0-/exdh0-6tdd7sj-4usxbip9chsz0.jpeg"><br><br><h1>  0. Sebelum membaca artikel </h1><br>  Artikel ini memiliki tujuan sebagai berikut: <br><br><ol><li>  perlihatkan cara bekerja secara khusus dengan dewan ini; </li><li>  tunjukkan pendekatan yang dengannya Anda dapat menulis program LED yang berkedip, hanya mengandalkan dokumentasi dan logika; </li><li>  menyajikan materi dalam bahasa yang bisa dimengerti oleh orang yang kurang akrab dengan mikrokontroler. </li></ol><br>  Kode ini akan berubah menjadi minimalis dalam hal menggunakan file tambahan - kami tidak akan menyertakan satu file, kecuali untuk file yang diperlukan untuk membuat firmware yang kosong namun valid.  Yaitu  berdasarkan pada kode firmware, yang berfungsi, tetapi tidak ada gunanya. <br><a name="habracut"></a><br>  Kami membutuhkan dokumentasi berikut: <br><br><ol><li>  Datasheet STM32F030x4 (Saya menggunakan dokumen dari Januari 2017 DocID024849 Rev 3); </li><li>  RM0360 Manual referensi STM32F030x4 / x6 / x8 / xC (Saya menggunakan dokumen dari April 2017 DocID025023 Rev 4); </li><li>  papan sirkuit. </li></ol><br>  Anda dapat mengunduh dokumen-dokumen ini dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud</a> . <br>  Penghitung waktu dalam artikel <i>tidak</i> akan dipertimbangkan dan <i>tidak</i> akan terlibat dalam kode. <br>  Programmer ST-LINK <i>tidak</i> digunakan.  Untuk bekerja dengan papan, adaptor USB-COM (RS232 berdasarkan PL2303HX) digunakan, yang mengemulasi port COM. <br><br><div class="spoiler">  <b class="spoiler_title">Adaptor foto</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wp/em/u8/wpemu8n1juvbuipavxu-mzfa2eq.jpeg"></div></div><br>  Semuanya dikumpulkan pada mesin virtual Windows XP Professional 2002 SP3 yang berjalan melalui VirtualBox versi 5.2.22r126460 pada host Windows X. <br><br><h1>  1. Menginstal driver untuk adaptor USB-COM </h1><br>  Windows tidak membantu, unduh dari situs resmi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prolific</a> (tautan pertama ke permintaan "driver produktif" di Google) driver USB ke UART / Serial / Printer <b>PL2303 Windows Driver</b> (Anda memerlukan yang <i>Driver Standar</i> ).  Atau Anda dapat mengunduh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cloud</a> saya. <br><br>  Instal driver, reboot dan lihat port COM baru. <br><br><div class="spoiler">  <b class="spoiler_title">Cuplikan layar dengan nama penginstal dan port COM yang baru</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tq/tt/dh/tqttdhvov6eiov75df-pqcycz0s.png"></div></div><br>  Pengaturan port dibiarkan standar.  Anda dapat mengubah nomor port COM atas kebijakan Anda.  Dalam pengalaman saya, hanya sekali dalam hidup saya saya melihat sebuah program hanya melihat 4 COM port pertama, jika saya tidak salah itu adalah semacam terminal Bluetooth di Windows. <br><br><div class="spoiler">  <b class="spoiler_title">Pengaturan port COM</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ak/ad/ep/akadepan2w3tldshsr6sys69jo4.png"><br></div></div><br><h1>  2. Mengisi firmware dan mematikan board </h1><br><h2>  2.0 Utilitas pengunduhan untuk bekerja dengan board </h2><br>  Kami mengunduh utilitas <b>FLASHER-STM32</b> dari situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">STM</a> (dalam uraian itu disebut STM32 Flash loader demonstrator (UM0462)), Anda harus mendaftar untuk ini, tetapi ini tidak menakutkan - pada akhirnya kami akan meninggalkan arsip zip dengan installer;  Next-&gt; Next-&gt; Next ... dan semuanya sudah diinstal.  Untuk kenyamanan, saya membuat pintasan ke aplikasi ini di folder yang berfungsi. <br><br><div class="spoiler">  <b class="spoiler_title">Inilah utilitasnya (tangkapan layar situs)</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/oa/4a/xz/oa4axzxm4eljcbpzubyspqghcbe.png"><br></div></div><br>  Secara default, jalur ke utilitas <i>C: Program Files \ STMicroelectronics \ Software \ Flash Loader Demo \ STMFlashLoader Demo.exe</i> . <br><br><h2>  2.1 Nuansa BOOT </h2><br>  Ada jumper BOOT di papan tulis. <br><br><ul><li>  Ketika jumper <b>ditutup</b> , mikrokontroler akan memuat instruksi dari memorinya (mis., Program yang ditulis oleh seorang programmer). </li><li>  Ketika jumper <b>terbuka</b> , mikrokontroler akan menerima informasi tentang jalur RX dan TX, mis.  Ini akan di-flash dari port COM (dari adaptor dalam kasus saya). </li></ul><br><h2>  2.2 Mengkonfigurasi utilitas </h2><br><img src="https://habrastorage.org/webt/pu/oc/h3/puoch3mqjkqfryjvcnxfg9zeycq.png"><br><br>  Jalankan aplikasi ini, sebenarnya yang paling sederhana (berisi pengaturan minimum).  Di jendela pertama, pilih: <br><br><ol><li>  antarmuka (saya punya COM-3); </li><li>  kecepatan komputer dan mikrokontroler akan berkomunikasi (IMHO, nilai normal 9600); </li><li>  jumlah bit data (untuk beberapa alasan jendela ini tidak tersedia untuk saya, tetapi sejauh ini ini tidak penting); </li><li>  parity (Saya tidak memiliki paritas, mis. Tidak ada); </li><li>  gema (saya punya OFF); </li><li>  waktu tunggu (saya punya 10 detik). </li></ol><br>  Klik Berikutnya, dan jika semuanya beres, maka kita akan melihat lampu hijau dan "Target dapat dibaca";  jika kita melihat lampu merah, komputer tidak dapat terhubung. <br><br><div class="spoiler">  <b class="spoiler_title">Target dapat dibaca jika mikrokontroler berhasil terdeteksi</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gd/9y/hw/gd9yhwnpu15asiupizayeozvsfo.png"><br></div></div><br>  Urutan langkah-langkah yang selalu membantu: <br><br><ol><li>  Pertama, Anda perlu memeriksa apakah jumper BOOT di papan ditutup. </li><li>  Kedua, dalam hal apa pun, matikan daya mikrokontroler dan lebih disukai jalur TX dan RX yang datang dari adaptor ke papan (Anda tidak dapat melepaskan koneksi ke tanah). </li><li>  Ketiga, dalam program, tekan Kembali ke akhir, mis.  ke halaman pertama, atau bahkan menutupnya dan memulai kembali (secara umum, terkadang macet).  Penting untuk selalu memulai dari halaman pertama sebelum setiap koneksi ke papan melalui program ini. </li><li>  Keempat, angkat kabel dari adaptor ke papan dan coba sambungkan lagi di program (pastikan dari halaman pertama!). </li></ol><br>  Jika semuanya gagal, Anda dapat mencoba mematikan semuanya, nyalakan kembali komputer, dan coba sambungkan kembali ke papan tulis. <br><br>  Karena  Saya bekerja melalui mesin virtual, saya harus menghubungkan kembali adaptor USB-COM beberapa kali sehingga terdeteksi oleh mesin virtual, dan mesin host tidak punya waktu untuk menginstal driver yang rusak. <br><br>  Pilihan lain yang saya temukan bekerja saat menulis artikel ini adalah dengan menekan tombol di papan daripada terus-menerus menarik kabel.  Namun, Anda harus menutup dan membuka jumper BOOT dalam hal apa pun.  Opsi ini berfungsi karena tombol ini dibawa ke kaki reset <abbr title="tanggapan eksternal">NRST</abbr> eksternal. <br><br>  Di jendela berikutnya, pilih Target perangkat Target.  By the way, kadang-kadang di sini Anda dapat melihat (mungkin bug) perangkat kiri secara umum, misalnya, bukannya STM32 lihat STM8 - di suatu tempat ada semacam kegagalan, prosedur perawatan dijelaskan di atas.  Oleh karena itu, pada langkah ini Anda tidak dapat terburu-buru mengklik Berikutnya, tetapi selalu perhatikan fakta bahwa perangkat yang diinginkan dipilih di Target. <br><br><div class="spoiler">  <b class="spoiler_title">Pemilihan Perangkat Target</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/zz/p8/83/zzp88341ayrb95ymtn1bf3-elvq.png"><br></div></div><br>  Bagaimana cara menentukan perangkat yang kita miliki?  - kita melihat chip dan menulis ulang semua yang tertulis di dalamnya.  Kami membuka <i>Lembar Data</i> pada chip kami, bagian <i>Informasi pemesanan</i> menjelaskan surat mana yang bertanggung jawab untuk apa.  Dalam kasus saya itu adalah: <br><br><img src="https://habrastorage.org/webt/pa/kn/ga/pakngat6l5tahlk-y75nledccuy.png"><img src="https://habrastorage.org/webt/f0/fb/jk/f0fbjkrbe8a-g5uqbjdovxzr_fc.png"><br><br><div class="spoiler">  <b class="spoiler_title">Saya memilih chip saya (16K) di Target dan melanjutkan.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qs/u4/v2/qsu4v2uhtvft1sj1uhp2bnount4.png"><br></div></div><br>  Pilihan 4 tindakan dengan chip ditawarkan: <br><br><ol><li>  hapus memori (seluruh atau pilih area tertentu); </li><li>  tulis firmware ke perangkat; </li><li>  baca firmware dari perangkat; </li><li>  aktifkan / nonaktifkan perlindungan baca atau baca. </li></ol><br><h2>  2.3. Baca firmware dari board </h2><br>  Ketika saya menghubungkan papan untuk pertama kalinya, saya memutuskan untuk menyimpan firmware asli, semacam cadangan - kami akan melakukannya sekarang.  Penting untuk menunjukkan di mana harus menyimpan firmware ini dan halaman memori mana yang akan disimpan, juga diusulkan untuk menggunakan format file <i>hex</i> , <i>bin</i> atau <i>s19</i> untuk <i>dipilih</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Pilih halaman memori untuk dibaca</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/b_/vs/yq/b_vsyqyslqo1sib02nymmymvy_m.png"><br></div></div><br>  Jika Anda hanya mengunggah firmware ke papan tulis atau membaca firmware dari papan tulis, maka tidak ada perbedaan antara format file ini.  Berikut ini adalah halaman kemajuan, di mana kadang-kadang proses membeku 99% untuk waktu yang lama (tidak harus 99), tetapi setelah beberapa detik seharusnya berhasil - pada kenyataannya, setelah itu dewan tidak memberikan perilaku yang sesuai dengan firmware yang dimuat.  Sederhananya, Anda perlu menyambung kembali semuanya dan mengisi ulang firmware, tidak ada yang penting tentang ini. <br><br>  File firmware telah disimpan, dan di masa depan dapat diunggah ke papan. <br><br>  Namun, jika proteksi baca diinstal, firmware tidak dapat dibaca. <br><br><div class="spoiler">  <b class="spoiler_title">Jendela kemajuan</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/nb/ta/rs/nbtarsmjtb1-ylmcxaesykldlv0.png"><br></div></div><br><h2>  2.4 Memasang papan </h2><br>  Sekarang isi file firmware, penulisan kode sumber yang diberikan di bawah ini.  Ke depan, saya akan mengatakan bahwa kami akan mengunggah file <i>bin</i> dan <i>hex</i> , karena  lingkungan pengembangan akan mengeluarkannya.  Pengaturan tambahan untuk file <i>s19</i> dan <i>hex</i> adalah identik;  tidak seperti mereka, dalam file <i>bin</i> , Anda dapat memilih alamat dari mana firmware akan direkam, secara default di utilitas itu adalah 8000000 (cocok untuk kami). <br><br><div class="spoiler">  <b class="spoiler_title">Mempersiapkan rekaman</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1k/u8/cf/1ku8cfxnzt_bjob1szyix3u2xpw.png"><br></div></div><br>  Sebelum merekam, Anda dapat menghapus memori flash mikrokontroler dengan memilih satu dari tiga opsi: <br><br><ul><li>  Hapus halaman yang diperlukan (kosongkan bagian memori yang diperlukan); </li><li>  No Erase (tanpa pemurnian); </li><li>  Global Erase (pembersihan penuh). </li></ul><br>  Padahal, pembersihan adalah proses penulisan nol ke memori. <br><br>  Masih ada byte opsional, tetapi sejauh ini Anda tidak dapat menyentuhnya.  Klik Berikutnya, tunggu prosesnya selesai, dan Anda selesai. <br><br>  Jika Anda ingin merekam firmware saya, Anda dapat menemukannya di cloud, file <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blink.bin</a></i> .  Saat menggunakan firmware ini, LED bawaan berkedip dari kaki PA4 akan berkedip. <br><br><h1>  3. Penulisan kode </h1><br><h2>  3.0 Menginstal Lingkungan Pengembangan CooCox CoIDE </h2><br>  Anda dapat mengunduh IDE dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SoftPedia.com</a> , sebelumnya Anda dapat mengunduh dari situs web STM dan dari situs IDE itu sendiri, tetapi karena IDE tidak lagi didukung, itu menjadi tidak mungkin.  Tidak ada yang penting bahwa IDE tidak lagi didukung, tidak, karena  untuk menulis kode, yang utama adalah kompiler.  Saya mengunduh kedua versi, tetapi saya menggunakan versi 1.7.8. <br>  Peluncuran pertama dari lingkungan dijelaskan dengan baik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , Next-&gt; Next-&gt; Next ... dan tidak ada yang rumit.  Saya hanya akan menambahkan yang pertama itu lebih baik untuk membuat proyek, dan kemudian yang lainnya. <br><br>  Namun, jika Anda kehilangan tab Repositori, Anda dapat menemukannya di menu <i>View -&gt; Repository</i> . <br>  Anda dapat mengunduh alat (kompiler) untuk lingkungan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> atau meminta Google "alat gnu untuk lengan";  Saya mengunduh opsi yang memiliki sha1.exe di bagian akhir. <br><br><h2>  3.1 Kerangka Sumber </h2><br>  Jadi, proyek telah dibuat, chip telah dipilih, sekarang kami akan menambahkan set minimum sumber ke proyek, yang tanpanya tidak akan bisa hidup sama sekali. <br><br><div class="spoiler">  <b class="spoiler_title">Ini adalah bagaimana proyek seharusnya terlihat ketika baru saja dibuat, yaitu</b>  <b class="spoiler_title">hanya ada file main.c utama dan tidak lebih</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/db/rf/qh/dbrfqhef0pg7j3perjtzm3b3okc.png"><br></div></div><br>  <b>Pilih CMSIS BOOT</b> dan lingkungan akan secara otomatis <b>memilih M0 Cmsis Core</b> , karena  dependensi membutuhkan ini. <br><br><div class="spoiler">  <b class="spoiler_title">Sekarang kita mendapatkan set sumber minimum</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/u8/qt/fku8qtl8uhcttxq_xswbovf-10c.png"><br></div></div><br>  Pasang proyek (ikon Bangun, atau tombol F7).  Untuk alasan yang tidak saya ketahui, file hex tidak dikumpulkan (ada peringatan di konsol);  Saya menginstal ulang IDE dan kompiler beberapa kali, menciptakan kembali proyek, tetapi untuk beberapa alasan hasilnya seperti pada mesin virtual;  di komputer lain (bukan virtual, tapi nyata) semuanya satu-satu dan outputnya berfungsi hex.  Untungnya ada bin. <br><br><div class="spoiler">  <b class="spoiler_title">Proyek ini berhasil dirakit</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ap/zn/ct/apznctscxqdbgullp11rzqxtyj4.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Saya menyarankan Anda untuk memperhatikan ukuran file, itu dapat dilihat pada akhir output di konsol, atau Anda dapat melihatnya dengan cara standar (di sini, omong-omong, Anda dapat melihat bahwa hex kosong);</b>  <b class="spoiler_title">Pada saat yang sama, tangkapan layar ini menunjukkan bahwa file firmware ada di folder proyek, kemudian Debug / bin /</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ho/ue/wd/houewdyn-cyjvmn-js5sbah-yru.png"><br></div></div><br>  Meskipun kode tidak melakukan apa pun, saya mengunggahnya ke papan untuk memastikan bahwa Anda dapat mengunggahnya (yang, misalnya, utilitas tidak menolaknya).  Saya menyarankan pembaca untuk melakukan ini.  Jika tidak berhasil, coba lagi dan lagi, dan tulis komentar. <br><br><h2>  3.2 Algoritma Jari </h2><br>  Untuk mulai dengan, kami membuat sketsa algoritma bagaimana, dari sudut pandang manusia, mikrokontroler akan berkedip LED.  Dan untuk alasan ini sedikit. <br><br>  Setiap peralatan bekerja karena energi yang tersimpan, misalnya, beberapa mesin dapat berjalan pada jenis bahan bakar yang berbeda, tetapi untuk ini mesin perlu disesuaikan dengan jenis bahan bakar yang akan kita makan dengan itu.  Demikian pula, mikrokontroler perlu disesuaikan (dicari) untuk sumber energi - ini akan menjadi <i>blok pertama dari</i> algoritma. <br>  Kami beralasan lebih lanjut.  Komputer desktop memiliki monitor, pengeras suara, keyboard, mouse ... dan Anda dapat melihat bahwa beberapa perangkat memberikan informasi kepada kami, dan dengan bantuan orang lain, kami memberikan informasi ke komputer, tetapi semuanya terhubung ke kotak yang sama dengan semuanya (unit sistem).  Anda dapat menebak bahwa mikrokontroler dapat menerima dan memberikan informasi, yang berarti kakinya dapat menerima sinyal atau memberikan sinyal - ini akan menjadi <i>blok</i> algoritma berikutnya. <br><br>  Selanjutnya, mikrokontroler harus menyalakan LED, tunggu sebentar, matikan LED, tunggu sebentar dan nyalakan-tunggu-matikan ... <br><br>  Hasilnya, algoritme akan terlihat seperti ini <br><br><img src="https://habrastorage.org/webt/h1/m4/oo/h1m4oou5txdafrybbwobj69vahm.png" height="361" width="192"><br><br>  Tujuan dari diagram alur ini adalah untuk menunjukkan dengan jelas apa yang dilakukan oleh algoritma;  Pertama-tama, skema ini ditulis untuk Anda sendiri, sehingga semua orang bebas untuk menulis / menggambar sesuai keinginannya (untuk dirinya sendiri).  Saya percaya bahwa skema harus bertujuan sesederhana, mudah dibaca, dan seintuitif mungkin, untuk memiliki tingkat abstraksi yang tinggi. <br><br>  Sesuai dengan algoritma ini, kami akan menulis kode. <br><br><h2>  3.3 Bekerja dengan dokumentasi </h2><br>  Saya sarankan membaca bagian artikel ini dengan <i>stm32f0xx.h</i> file yang terbuka, yang terletak di folder <i>cmsis_boot</i> proyek kami, dan dokumentasi terbuka. <br><br><h3>  3.3.1 Memilih sumber jam </h3><br>  Pertama, Anda perlu memberikan daya ke mikrokontroler.  Mikrokontroler menerima 5 Volts dari adaptor (diukur dengan multimeter), tetapi muncul pertanyaan "frekuensi apa yang digunakan mikrokontroler", karena diketahui bahwa elektronik beroperasi pada frekuensi yang berbeda.  Pertama, buka <i>datasheet</i> , dalam konten Anda dapat melihat dua bagian yang relevan dengan artinya: <i>Manajemen daya</i> , <i>Jam dan startup</i> .  Yang pertama adalah tentang mode tegangan dan daya rendah.  Bagian kedua menyembunyikan apa yang kami minati saat ini.  Sudah dalam kalimat pertama ia mengatakan "osilator RC 8 MHz internal dipilih sebagai jam CPU default pada reset", yang berarti bahwa <i>secara default setelah mengatur ulang MC, rantai RC 8 MHz internal</i> dipilih sebagai <i>sumber jam utama</i> . <br>  Berikutnya adalah beberapa skema pohon Jam yang tidak dapat dipahami, yang akan kita bahas nanti. <br><a name="Clock_tree"></a><br><br><div class="spoiler">  <b class="spoiler_title">Pohon jam</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/sg/nl/ul/sgnlul1krp_mdiqntf5it8a0eni.png"></div></div><br>  Sebenarnya, Anda dapat mengandalkan frasa "secara default setelah mengatur ulang MK ..." dan membaca bagian artikel ini secara diagonal. <br><br>  Sekarang Anda perlu terganggu oleh papan dan mencari LED internal.  Saya tahu bahwa dioda dalam rangkaian dilambangkan dengan <i>D1</i> , <i>D2</i> ..., yaitu.  <i>D == dioda</i> , di papan saya dekat resistor <i>R7</i> adalah dioda <i>D1</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Foto papan</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ma/ze/ke/mazekeve26x9-imexuqb2k1knb8.png" width="462" height="330"><br></div></div><br>  Mungkin, setelah memeriksa papan dengan hati-hati, Anda dapat melacak ke kaki mana dioda terhubung, tetapi saya akan beralih ke papan sirkuit.  Sayangnya, elemen papan tidak sama persis dengan elemen di sirkuit di lokasi mereka;  tetapi saya senang bahwa saya menemukan skema seperti itu di Internet (kalau tidak saya tidak bisa menemukan apa pun untuk waktu yang lama). <br><br><img src="https://habrastorage.org/webt/id/gz/tw/idgztwbtwraskhguvq-9alkrp18.png"><br><br>  Dalam diagram kita melihat bahwa katoda dioda terhubung ke ground melalui jumper <i>J2</i> , dan anoda terhubung ke pin <i>PA4</i> melalui resistor.  <i>PA4</i> berarti output port <i>A</i> ke-4, yang berarti bahwa untuk menyalakan dan mematikan LED, perlu untuk memasok tegangan ke output <i>PA4</i> . <br><br>  Selanjutnya, Anda perlu menentukan bagaimana menerapkan tegangan ke output ini.  Ini sama sekali tidak intuitif bagi saya, dan untuk waktu yang lama saya menjelajahi dokumentasi memanjang dan sampai saya menemukan <b>diagram Blok</b> di bagian <i>Deskripsi</i> di bagian paling awal lembar data.  Dan di dalamnya saya melihat trek berharga <i>PA [15: 0] &lt;=&gt; Port GPIO A &lt;=&gt; AHB decoder &lt;=&gt; Matriks bus &lt;=&gt; Cortex-M0</i> , i.e.  Port <i>A</i> adalah port I / O untuk tujuan umum dan terhubung ke bus <abbr title="Bus kinerja tinggi canggih"><i>AHB</i></abbr> . <br><br><div class="spoiler">  <b class="spoiler_title">Diagram blok</b> <div class="spoiler_text">  (Gambar dapat diklik) <br> <a href=""><img src="https://habrastorage.org/webt/_e/hf/d0/_ehfd0kdf5v87xxud5yj4abp3xu.png"></a> <br></div></div><br>  Saya perhatikan bahwa dalam elektronik sudah biasa untuk memecah output mikrokontroler ke dalam port, dan biasanya port tersebut memiliki 16 output.  Diagram menunjukkan bahwa port <i>A</i> , <i>B</i> dan <i>C</i> hanya memiliki 16, tetapi port <i>D</i> dan <i>F</i> memiliki lebih sedikit (mungkin kurang dari 16 pin, lebih - tidak). <br><br>  Mari kita kembali ke skema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon Jam</a> dan menemukan output ditandatangani oleh <i>AHB</i> .  Kami akan mencari tahu pada frekuensi apa output ini bekerja.  Ke <i>AHB adalah</i> sinyal <i>HCLK</i> , yang meninggalkan pembagi <i>HPRE</i> .  Pembagi ini menerima sinyal <abbr title="SYStem CLocK"><i>SYSCLK</i></abbr> dari sakelar <abbr title="Jam sistem sWitch"><i>SW</i></abbr> .  Manakah dari sinyal pada input <i>SW yang</i> akan digunakan sebagai <i>SYSCLK</i> secara <i>terprogram diatur</i> - maka kita akan mengatur ini dalam kode.  Pilihan yang ditawarkan: <br><br><ol><li>  <i><abbr title="Internal kecepatan tinggi">HSI</abbr></i> - sinyal dari generator frekuensi tinggi internal, diproduksi oleh resonator kuarsa 8 MHz, yang saya solder sebelum bekerja dengan board ini; </li><li>  <i><abbr title="Phase Lock Loop CLocK">PLLCLK</abbr></i> - sinyal dari pengganda frekuensi <i>PLLMUL</i> ; </li><li>  <i><abbr title="Eksternal berkecepatan tinggi">HSE</abbr></i> - sinyal dari generator frekuensi tinggi eksternal. </li></ol><br>  Opsi apa pun cocok untuk tugas kami, saya sarankan memilih yang paling sederhana dan paling terjangkau - <i>HSI</i> . <br><br>  Kami akan masuk ke <i>manual Referensi</i> dan membuka bagian <i>7 Reset dan clock control (RCC)</i> , khususnya <i>7.2.6 Pemilihan jam sistem</i> , di mana sekali lagi kami menemukan kata-kata yang sama yang ditemukan dalam lembar data: “setelah reset sistem, osilator <i>HSI</i> dipilih sebagai sistem jam "- mis.  kami bahkan tidak perlu melakukan apa pun, MK akan mulai pada <i>HSI</i> . <br><br>  Untuk memastikan bahwa MK akan benar-benar bekerja dari sumber ini, saya akan menulis ini secara eksplisit di program;  Gulir ke register yang bertanggung jawab untuk mengatur ulang dan mencatat waktu (bagian <i>7.4 register RCC</i> ).  Register pertama yang dijelaskan dalam dokumentasi adalah <b>Clock control register (RCC_CR)</b> ;  Di bawah ini adalah deskripsi dari bit, yang bertanggung jawab untuk apa. <br><br><div class="spoiler">  <b class="spoiler_title">Register kontrol jam</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/qq/i4/ll/qqi4llshdqrtgidy2_x-hxx9yhe.png"><br></div></div><br>  Kami tertarik pada bit nol <i>HSION</i> , yang bertanggung jawab untuk menyalakan resonator ( <i>0</i> - off, <i>1</i> - on). <br><br>  Oleh karena itu, perlu untuk menulis satu ke register <i>RCC_CR</i> .  (nol bit adalah satu, atau 2 <sup>0</sup> = 1). <br><br>  Sekarang kita temukan di file <i>stm32f0xx.h</i> definisi <b>RCC</b> ( <i>#define RCC</i> ). <br><br><div class="spoiler">  <b class="spoiler_title">RCC-&gt; RC</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vn/ej/0x/vnej0xmqlqnrgeprbgyjo9cpjt8.png"><br></div></div><br>  Seperti yang Anda lihat, ini adalah struktur yang terletak di <i>RCC_BASE</i> ;  alamat <i>0x40021000</i> , jika Anda memperluas semua <i>definisi</i> , alamat yang sama dapat dilihat di <i>manual Referensi</i> di bagian <i>2.2.2 Peta memori dan daftarkan alamat batas</i> dan dalam lembar data di bagian <i>5 Pemetaan memori</i> (area <i>AHB</i> ). <br><br>  Untuk menulis sebuah unit untuk mengaktifkan <i>HSI</i> dalam register <i>CR</i> blok <i>RCC</i> , Anda memerlukan satu baris kode <br><br><pre><code class="plaintext hljs">RCC-&gt;CR |= 0x1;</code> </pre> <br><h3>  3.3.2 Mengatur kaki </h3><br>  Mengirim sinyal ke kaki mikrokontroler untuk menyalakan LED dan menghentikan sinyal sehingga LED padam adalah tindakan sederhana, dan karenanya ini merujuk pada fungsi <i><abbr title="Input / Output Tujuan Umum">GPIO</abbr></i> (port input-output tujuan umum). <br><br>  Secara default, kaki-kaki MK tidak terhubung, mis.  outputnya tidak pasti.  Hal ini diperlukan untuk menghubungkan port, kaki yang akan memberi daya pada LED.  Sebelumnya, kami menentukan bahwa port <i>GPIO</i> terhubung ke bus <i>AHB</i> - Anda harus mengaktifkan bus ini.  Melanjutkan membolak-balik bagian <i>7.4 register RCC</i> (mengontrol dan mengatur ulang register kontrol), kami menemukan bagian <i>7.4.6 AHB jam periferal mengaktifkan register</i> ( <b>RCC_AHBENR</b> , <i>jam</i> bus <i>AHB</i> <i>mengaktifkan register</i> ).  Sebelumnya, saya memutuskan bahwa LED saya terhubung ke kaki <i>PA4</i> - karena itu, saya perlu menulis unit ke bit ke-17 dari register untuk memasang port <i>A.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Jam periferal AHB memungkinkan register</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/u7/s5/vs/u7s5vsoduvggexg9chpopozlzdw.png"><br></div></div><br>  Dengan demikian, kodenya harus <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= (1 &lt;&lt; 17);</code> </pre> <br>  atau, yang merupakan hal yang sama <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= 0x20000;</code> </pre> <br>  baik menggunakan file <i>#define</i> <i>stm32f0xx.h</i> tulis <br><br><pre> <code class="plaintext hljs">RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">RCC-&gt; AHBENR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/19/ex/ke/19exkey4g-yyfkz4pmvrrgilnlk.png"><br></div></div><br>  Kami telah memberdayakan port <i>A</i> , sekarang kami perlu memberi tahu MK bahwa <i>PA4</i> akan berfungsi saat <i>keluar</i> - kami akan membaca bagian <i>8 I / Os Tujuan Umum (GPIO)</i> ;  pengantar bagian ini sudah mengatakan "Setiap port I / O tujuan umum memiliki empat register konfigurasi 32-bit ( <b>GPIOx_MODER</b> , <b>GPIOx_OTYPER</b> , <b>GPIOx_OSPEEDR</b> dan <b>GPIOx_PUPDR</b> ), dua register data 32-bit ( <b>GPIOx_IDR</b> dan <b>GPIOx_ODR</b> ) ..." - <i>untuk masing-masing GPIO Port memiliki 4 register tuning dan 2 register data</i> - inilah yang kami butuhkan (konfigurasikan port <i>A</i> , atau lebih tepatnya output <i>PA4</i> , dan secara berkala kirim <i>0</i> dan <i>1 ke sana</i> ).  Untuk pemahaman yang lebih baik (teori) tentang apa yang terjadi, Anda dapat membaca bagian ini, tetapi saya gulir ke bawah ke bagian <i>8.4 GPIO mendaftar</i> dan mengkonfigurasi port sesuai dengan deskripsi. <br><br><ol><li>  <b>mode</b> port - keluar.  Sesuai dengan dokumentasi, perlu untuk menulis <i>01</i> di area yang sesuai ( <i>MODER4</i> ) dari register yang sesuai ( <i>GPIOA_MODER</i> ), yaitu  bit <i>9</i> dan <i>8</i> : di bit ke-9 harus nol, di unit ke-8: <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= (1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= 0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Register mode port GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/tv/xf/vt/tvxfvtoiw91rguuz-rtmgcrk8fo.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; MODER</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/co/df/x5/codfx50xu4hopklififyeecpiqu.png"><br></div></div><br></li><li>  <b>jenis</b> output.  Jujur, saya masih belum sepenuhnya mengetahui sirkuit dari kasus ini (saya akan mengerti, membaca kembali forum lagi, dll.), Tetapi mempelajari sumber daya lain tentang konfigurasi output MK, serta logika dan intuisi, menunjukkan bahwa harus ada <b>dorongan -menarik</b> dan sesudahnya harus <i>pull-up</i> .  Bagaimanapun, kodenya ditulis, semuanya berfungsi dan tidak ada yang habis.  Ada risiko nyata terbakar jika Anda memilih jenis <b>saluran terbuka</b> dan korsleting output ini dengan perangkat lain, seperti  Ini adalah jalan keluar terbuka dan tidak dilindungi oleh apa pun.  Selain itu, kami memiliki resistor pembatas arus di depan dioda - itu pasti tidak akan terbakar di sini. <br><br>  Setelah dokumentasi, perlu untuk menulis nol di bit ke-4;  Dokumentasi juga menyatakan bahwa setelah reset akan ada nol. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~(1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT_4;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Register tipe keluaran port GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ii/3k/ch/ii3kcht4jvsbnd7yybouiilgmhk.png"><br></div></div><br></li><li>  <b>kecepatan</b> output.  Dalam kasus kami, itu tidak masalah, tetapi demi kesetiaan saya akan menulis di sini nol. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~(1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDER_OSPEEDR4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Register kecepatan keluaran port GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/47/xg/fr/47xgfrtfqdl5ai0eztsrqej1i1k.png"><br></div></div><br></li><li>  <b>tumpangan</b> .  Karena  output akan memberi daya pada LED, Anda harus menariknya ke daya, mis.  <b>pull-up</b> . <br><br>  Diperlukan untuk mengencangkan pin ke 4 port <i>A</i> ;  dokumentasi mengatakan bahwa untuk ini perlu untuk menulis masing-masing nol dan satu dalam <i>9</i> dan <i>8</i> bit. <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= (1 &lt;&lt; 8); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= 0x100; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;PUPDR |= GPIO_PUPDR_PUPDR4_0;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Register pull-up / pull-down port GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/pg/pa/zk/pgpazkwfltwme4jy0wwrhp9imqi.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; PUPDR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bo/ee/na/boeenaff6fxjiemjuiky9ukhb6w.png"><br></div></div><br></li></ol><br><h3>  3.3.3 LED on / off dan tunda </h3><br>  Sebelumnya kita membaca bahwa masing-masing port memiliki register, termasuk register data <i><abbr title="Input register data">IDR</abbr></i> dan <i><abbr title="Daftar Data Keluaran">ODR</abbr></i> - register input dan output data, masing-masing.  Angka nol logis dan angka pada kaki MK - apakah ini data?  - ya, data.  Data dapat berasal dari luar mikrokontroler (menjadi <i>input</i> ) dan keluar dari mikrokontroler dan pergi ke perangkat lain (menjadi <i>output</i> ).  Unit pada kaki MK adalah adanya level tegangan tinggi, mis.  jika Anda membawa satu ke output, maka akan ada tegangan, dan LED ini dapat menyalakan LED kami.  Output dari sebuah unit ke kaki mikrokontroler adalah sesuatu yang lain daripada menulis unit ini ke register output <i>ODR</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Register data keluaran port GPIO</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/or/vw/el/orvwel6seyhwvx6pbxdcow6ufpm.png"><br></div></div><br>  Menurut dokumentasi, kita melihat bahwa untuk setiap port ( <i>A</i> , <i>B</i> , <i>C</i> , <i>D</i> , <i>F</i> ) ada register 32-bit.  port tidak dapat memiliki lebih dari 16 pin, maka hanya 16 bit pertama dari register yang digunakan.  Setiap bit sesuai dengan nomor port (pin).  Untuk mengeluarkan unit ke leg <i>PA4</i> , seseorang harus menulis unit ke bit ke-4, untuk menghasilkan nol - tulis nol ke bit ke-4, mis.  lepaskan tegangan dari output. <br><br><img src="https://habrastorage.org/webt/pr/0n/pr/pr0npr4jplwjahmcflj_nlksq5i.png" width="400" height="156"><br><br><div class="spoiler">  <b class="spoiler_title">GPIOA-&gt; ODR</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/hs/yy/v4/hsyyv4z5u2kf6fkqqe5wk9t6ti4.png"><br></div></div><br>  Kode untuk menyalakan LED akan terlihat seperti ini <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= (1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= 0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR |= GPIO_ODR_4;</code> </pre> <br>  Kode untuk mematikan LED <br><br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~(1 &lt;&lt; 4); // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~0x10; // </code> </pre> <br><pre> <code class="plaintext hljs">GPIOA-&gt;ODR &amp;= ~GPIO_ODR_4;</code> </pre> <br>  Tetapi jika Anda menulis baris untuk mematikan LED setelah baris untuk menyalakan, LED tidak akan berkedip (jika Anda tertarik pada apa yang terjadi - Anda dapat mencoba; tidak ada yang akan terbakar, ini sudah dibahas di atas) - maka Anda perlu menunda.  Pengatur waktu digunakan untuk penundaan, tetapi pengukur waktu layak untuk artikel terpisah (karena kerumitannya), jadi kami akan membuat penundaan penopang: kami akan menggerakkan siklus idle.  Ada satu poin: <b>jika optimasi kompiler diaktifkan</b> , <b>kompiler akan memotong</b> siklus idle kami dan tidak akan ada penundaan.  Pastikan optimasi tidak diaktifkan.  Untuk melakukan ini, mari kita masuk ke konfigurasi proyek (klik kanan pada nama proyek di pohon proyek) dan periksa baris <i>Compile Control String</i> di tab <i>Compile</i> : itu harus memiliki argumen <i>-O0</i> ("tentang nol" berarti optimasi dinonaktifkan).  Jika Anda mengumpulkan semuanya sesuai dengan instruksi saya, maka kemungkinan besar Anda juga akan memiliki <i>-O0</i> , karena  secara default dan saya tidak menyentuh apa pun di sini.  Argumen <i>-O1 -O2 -O3</i> berarti optimasi level yang sesuai diaktifkan. <br><br><div class="spoiler">  <b class="spoiler_title">Periksa Optimalisasi Kompiler</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vc/ps/pu/vcpspuz5xfupw1pa5n-e5at9_nm.png"><br></div></div><br>  Siklus idle dapat ditulis seperti ini: <br><br><pre> <code class="plaintext hljs">int t = 4000000; while(t &gt; 0) t--;</code> </pre><br>  Saya tidak menetapkan nilai <i>t</i> seperti itu, saya beralasan seperti ini: jika mikrokontroler berjalan pada 8MHz, maka itu akan mengeksekusi sekitar 8.000.000 instruksi dalam satu detik, jika Anda membesar-besarkan secara dalam, maka untuk penundaan setengah detik Anda harus menjalankan siklus 4.000.000 kali. <br>  Siklus idle perlu dijalankan setelah menyalakan LED, dan setelah mematikannya, dan semua ini bersamaan. <br><br><h3>  3.4 Menulis Kode dan Menjalankan </h3><br>  Mari kita kumpulkan semua baris kode yang kita tulis sebelumnya.  Anda juga perlu memasukkan file header <i>stm32f0xx.h</i> , sebagai  kami mengandalkannya dan mengambil darinya definisi struktur, alamat, dan nilai.  Hasilnya harus: <br><br><pre> <code class="plaintext hljs">#include "stm32f0xx.h" int main(void) { int t; //  '' RCC-&gt;CR |= 0x1; //   HSI RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; //   A GPIOA-&gt;MODER |= GPIO_MODER_MODER4_0; // PA4   GPIOA-&gt;OTYPER &amp;= ~GPIO_OTYPER_OT_4; //  push-pull  PA4 GPIOA-&gt;OSPEEDR &amp;= ~GPIO_OSPEEDER_OSPEEDR4_0; //    PA4 GPIOA-&gt;PUPDR |= GPIO_PUPDR_PUPDR4_0; //  pull-up  PA4 while(1) { GPIOA-&gt;ODR |= GPIO_ODR_4; //    PA4 t = 4000000; while(t &gt; 0) t--; //  GPIOA-&gt;ODR &amp;= ~GPIO_ODR_4; //    PA4 t = 4000000; while(t &gt; 0) t--; //  } }</code> </pre><br>  Klik Rebuild dan isi kode di papan tulis melalui utilitas. <br><br><img src="https://habrastorage.org/webt/fo/rr/1d/forr1d6ruw6sohn7eyomgs4yb_g.png"><br><br>  Agar board meluncurkan firmware baru, jangan lupa untuk menutup jumper BOOT dan melakukan reset (RESET). <br><br><h1>  4. Kesimpulan </h1><br>  Kode ditulis, semuanya berfungsi.  Pasukan dikeluarkan tidak terukur.  Saya senang bahwa berdasarkan dokumentasi, ternyata menulis kode kerja, sebagian besar karena fakta bahwa STM memiliki dokumentasi berkualitas tinggi. <br><br>  Rencananya adalah menulis artikel tentang cara mengumpulkan semuanya dengan tangan, tanpa IDE, melalui konsol, <i>old old school</i> , idealnya sehingga semua ini dapat dilakukan dari bawah Linux.  Sekarang saya sedang mengerjakan PWM dan ADC (juga di forum ini) - Saya juga akan menulis artikel tentang itu. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437234/">https://habr.com/ru/post/id437234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437224/index.html">Menerjemahkan templat debu ke BEJ</a></li>
<li><a href="../id437226/index.html">Kelvin Point Shadow</a></li>
<li><a href="../id437228/index.html">Bitcoin, sebagai mata uang, akan mengarah pada krisis ekonomi</a></li>
<li><a href="../id437230/index.html">Periklanan online yang sangat berbeda. Tiga sumbu vs AI, Teknologi Iklan, dan DOOH</a></li>
<li><a href="../id437232/index.html">Bagus juga</a></li>
<li><a href="../id437236/index.html">ESET: Analisis Komponen Zebrocy Baru</a></li>
<li><a href="../id437238/index.html">Orange Pi 3 dirilis - mini-pc $ 30 penuh di Linux</a></li>
<li><a href="../id437240/index.html">Bagaimana cara mengintegrasikan Zimbra Collaboration Suite dengan Active Directory</a></li>
<li><a href="../id437242/index.html">Penguasaan manajer produk. Permintaan fitur</a></li>
<li><a href="../id437244/index.html">Google mengajarkan pengguna untuk mengenali email phising</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>