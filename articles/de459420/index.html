<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤹🏿 👧🏾 😦 Der häufigste Rechen bei der Verwendung von printf in Programmen für Mikrocontroller 👩‍❤️‍💋‍👨 🖐🏻 ⚛️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von Zeit zu Zeit muss ich in meinen Projekten printf in Verbindung mit einer seriellen Schnittstelle verwenden (UART oder eine Abstraktion über USB, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der häufigste Rechen bei der Verwendung von printf in Programmen für Mikrocontroller</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459420/">  Von Zeit zu Zeit muss ich in meinen Projekten printf in Verbindung mit einer seriellen Schnittstelle verwenden (UART oder eine Abstraktion über USB, die eine serielle Schnittstelle nachahmt).  Und wie immer vergeht viel Zeit zwischen den Anwendungen, und es gelingt mir, alle Nuancen, die berücksichtigt werden müssen, vollständig zu vergessen, damit es in einem großen Projekt normal funktioniert. <br><br>  In diesem Artikel habe ich meine eigenen Top-Nuancen zusammengestellt, die bei der Verwendung von printf in Programmen für Mikrocontroller auftreten, sortiert nach Beweisen von den offensichtlichsten bis zu den völlig nicht offensichtlichen. <br><a name="habracut"></a><br><h2>  Kurze Einführung </h2><br>  Tatsächlich reicht es aus, printf in Programmen für Mikrocontroller zu verwenden: <ul><li>  Fügen Sie die Header-Datei in den Projektcode ein. </li><li>  Definieren Sie die _write-Systemfunktion neu, um sie an die serielle Schnittstelle auszugeben. </li><li>  Beschreiben der Stubs von Systemaufrufen, die der Linker benötigt (_fork, _wait und andere). </li><li>  Verwenden Sie den printf-Aufruf im Projekt. </li></ul><br>  In der Tat ist nicht alles so einfach. <br><br><h2>  Beschreiben Sie alle Stubs, nicht nur gebrauchte. </h2><br>  Das Vorhandensein einer Reihe von vagen Links im Layout des Projekts ist zunächst überraschend, aber nach einigem Lesen wird klar, was und warum.  In all meinen Projekten verbinde ich dieses <a href="">Submodul</a> .  Daher definiere ich im Hauptprojekt nur die Methoden neu, die ich benötige (in diesem Fall nur _write), und der Rest bleibt unverändert. <br><br>  Es ist wichtig zu beachten, dass alle Stubs C-Funktionen sein müssen.  Nicht C ++ (oder in externes "C" eingeschlossen).  Andernfalls schlägt das Layout fehl (denken Sie an die Namensänderung während der Assembly mit G ++). <br><br><h2>  In _write kommt 1 Zeichen </h2><br>  Trotz der Tatsache, dass der Prototyp der _write-Methode ein Argument hat, das die Länge der Ausgabenachricht übergibt, hat er den Wert 1 (tatsächlich werden wir ihn selbst immer auf 1 setzen, aber dazu später mehr). <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _write (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> file, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { ... }</code> </pre> <br>  Im Internet kann man oft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">genau eine solche Implementierung</a> dieser Methode sehen: <br><div class="spoiler">  <b class="spoiler_title">Häufige Implementierung der Funktion _write</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uart_putc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); {} USART_SendData(USART2, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) ch); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _write_r (struct _reent *r, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> file, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * ptr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { r = r; file = file; ptr = ptr; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 int index; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* For example, output string by UART */</span></span></span><span class="hljs-meta"> for(index=0; index&lt;len; index++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ptr[index] == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\n'</span></span></span><span class="hljs-meta">) { uart_putc(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\r'</span></span></span><span class="hljs-meta">); } uart_putc(ptr[index]); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return len; }</span></span></code> </pre> <br></div></div><br>  Eine solche Implementierung hat die folgenden Nachteile: <br><ul><li>  geringe Produktivität; </li><li>  Streaming-Unsicherheit; </li><li>  Unfähigkeit, die serielle Schnittstelle für andere Zwecke zu verwenden; </li></ul><br><br><h3>  Geringe Leistung </h3><br>  Eine langsame Leistung ist auf das Senden von Bytes mithilfe von Prozessorressourcen zurückzuführen: Sie müssen das Statusregister überwachen, anstatt denselben DMA zu verwenden.  Um dieses Problem zu lösen, können Sie den Puffer für das Senden im Voraus vorbereiten und beim Empfangen des Zeichens am Ende der Zeile (oder beim Füllen des Puffers) senden.  Diese Methode erfordert einen Pufferspeicher, verbessert jedoch die Leistung bei häufigem Senden erheblich. <br><div class="spoiler">  <b class="spoiler_title">Beispielimplementierung von _write mit einem Puffer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"uart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;errno.h&gt; #include &lt;sys/unistd.h&gt; extern mc::uart uart_1; extern "C" { //      uart. static const uint32_t buf_size = 254; static uint8_t tx_buf[buf_size] = {0}; static uint32_t buf_p = 0; static inline int _add_char (char data) { tx_buf[buf_p++] = data; if (buf_p &gt;= buf_size) { if (uart_1.tx(tx_buf, buf_p, 100) != mc_interfaces::res::ok) { errno = EIO; return -1; } buf_p = 0; } return 0; } // Putty  \r\n    //    . static inline int _add_endl () { if (_add_char('\r') != 0) { return -1; } if (_add_char('\n') != 0) { return -1; } uint32_t len = buf_p; buf_p = 0; if (uart_1.tx(tx_buf, len, 100) != mc_interfaces::res::ok) { errno = EIO; return -1; } return 0; } int _write (int file, char *data, int len) { len = len; //   . if ((file != STDOUT_FILENO) &amp;&amp; (file != STDERR_FILENO)) { errno = EBADF; return -1; } //     //   \n. if (*data != '\n') { if (_add_char(*data) != 0) { return -1; } } else { if (_add_endl() != 0) { return -1; } } return 1; } }</span></span></span></span></code> </pre> </div></div><br>  Hier ist das uart-Objekt uart_1 für das direkte Senden mit dma verantwortlich.  Das Objekt verwendet FreeRTOS-Methoden, um den Zugriff von Drittanbietern auf das Objekt zum Zeitpunkt des Sendens von Daten aus dem Puffer (Aufnehmen und Zurückgeben von Mutex) zu blockieren.  Daher kann niemand das uart-Objekt verwenden, während er von einem anderen Thread sendet. <br>  Einige Links: <br><ul><li>  _Schreiben Sie hier den Funktionscode als Teil eines realen Projekts </li><li>  Die Uart-Klassenschnittstelle ist <a href="">hier</a> </li><li>  Implementierung der Uart-Klassenschnittstelle unter stm32f4 <a href="">hier</a> und <a href="">hier</a> </li><li>  Instanziierung der Uart-Klasse als Teil des Projekts <a href="">hier</a> </li></ul><br><br><h3>  Streaming-Unsicherheit </h3><br>  Diese Implementierung bleibt ebenfalls ungeschützt, da sich niemand im benachbarten FreeRTOS-Stream die Mühe macht, eine weitere Zeile an printf zu senden und dadurch den aktuell gesendeten Puffer zu mahlen (Mutex innerhalb des Uarts schützt das Objekt vor der Verwendung in verschiedenen Streams, aber die nicht an sie übertragenen Daten )  Wenn das Risiko besteht, dass printf eines anderen Threads aufgerufen wird, muss ein Layer-Objekt implementiert werden, das den Zugriff auf printf vollständig blockiert.  In meinem speziellen Fall interagiert nur ein Thread mit printf, sodass zusätzliche Komplikationen nur die Leistung beeinträchtigen (ständige Erfassung und Freigabe von Mutex innerhalb der Ebene). <br><br><h3>  Unfähigkeit, die serielle Schnittstelle für andere Zwecke zu verwenden </h3><br>  Da wir erst senden, nachdem die gesamte Zeichenfolge empfangen wurde (oder der Puffer voll ist), können Sie anstelle des uart-Objekts die Konvertermethode für die nachfolgende Paketübertragung an eine Schnittstelle der obersten Ebene aufrufen (z. B. Zustellung mit einer Garantie gemäß dem Übertragungsprotokoll ähnlich wie bei Paketen Transaktionsmodbus).  Auf diese Weise können Sie einen Uart sowohl zum Anzeigen von Debugging-Informationen als auch zum Beispiel für die Benutzerinteraktion mit der Verwaltungskonsole verwenden (sofern einer auf dem Gerät verfügbar ist).  Es reicht aus, einen Dekomprimierer auf der Empfängerseite zu schreiben. <br><br><h2>  Standardmäßig funktioniert die Float-Ausgabe nicht </h2><br>  Wenn Sie newlib-nano verwenden, unterstützen printf (sowie alle ihre Derivate wie sprintf / snprintf ... und andere) standardmäßig die Ausgabe von float-Werten nicht.  Dies lässt sich leicht lösen, indem dem Projekt die folgenden Linker-Flags hinzugefügt werden. <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(LD_FLAGS -Wl,-u,vfprintf; -Wl,-u,_printf_float; -Wl,-u,_scanf_float; <span class="hljs-string"><span class="hljs-string">"_"</span></span>)</code> </pre> <br>  Die vollständige Liste der Flags finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Das Programm friert irgendwo im Darm von printf ein </h2><br>  Dies ist ein weiterer Fehler in den Linker-Flags.  Damit die Firmware mit der gewünschten Version der Bibliothek konfiguriert werden kann, müssen Sie die Prozessorparameter explizit angeben. <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(HARDWARE_FLAGS -mthumb; -mcpu=cortex-m4; -mfloat-abi=hard; -mfpu=fpv4-sp-d16;) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(LD_FLAGS <span class="hljs-variable"><span class="hljs-variable">${HARDWARE_FLAGS}</span></span> <span class="hljs-string"><span class="hljs-string">"_"</span></span>)</code> </pre><br>  Die vollständige Liste der Flags finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  printf zwingt den Mikrocontroller zu einem schweren Fehler </h2><br>  Es kann mindestens zwei Gründe geben: <br><ul><li>  Stapelprobleme; </li><li>  Probleme mit _sbrk; </li></ul><br><h3>  Stapelprobleme </h3><br>  Dieses Problem tritt wirklich auf, wenn Sie FreeRTOS oder ein anderes Betriebssystem verwenden.  Das Problem ist die Verwendung des Puffers.  Der erste Absatz besagte, dass in _write jeweils 1 Byte kommt.  Dazu müssen Sie die Verwendung von Pufferung in Ihrem Code verbieten, bevor Sie printf zum ersten Mal verwenden. <br><pre> <code class="cpp hljs">setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>); setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>); setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Aus der Beschreibung der Funktion folgt, dass einer der folgenden Werte auf die gleiche Weise eingestellt werden kann: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOFBF 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set fully buffered */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOLBF 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set line buffered */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IONBF 2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set unbuffered */</span></span></span></span></code> </pre> <br>  Dies kann jedoch zu einem Überlauf des Taskstapels führen (oder zu Unterbrechungen, wenn Sie plötzlich eine sehr schlechte Person sind, die printf von Interrupts aus aufruft). <br><br>  Rein technisch ist es möglich, Stapel für jeden Stream sehr sorgfältig anzuordnen, aber dieser Ansatz erfordert eine sorgfältige Planung und es ist schwierig, die darin enthaltenen Fehler zu erfassen.  Eine viel einfachere Lösung besteht darin, jeweils ein Byte zu empfangen, es in einem eigenen Puffer zu speichern und es dann in dem zuvor analysierten erforderlichen Format auszugeben. <br><br><h3>  Probleme mit _sbrk </h3><br>  Dieses Problem war für mich persönlich das impliziteste.  Und was wissen wir über _sbrk? <br><ul><li>  Ein weiterer Stub, der implementiert werden muss, um einen erheblichen Teil der Standardbibliotheken zu unterstützen. </li><li>  erforderlich, um Speicher auf dem Heap zuzuweisen; </li><li>  wird von allen Arten von Bibliotheksmethoden wie malloc verwendet, kostenlos. </li></ul><br>  Persönlich verwende ich in meinen Projekten in 95% der Fälle FreeRTOS mit neu definierten Methoden new / delete / malloc, die eine Reihe von FreeRTOS verwenden.  Wenn ich also Speicher zuordne, bin ich sicher, dass sich die Zuweisung auf dem FreeRTOS-Heap befindet, der eine vorgegebene Menge an Speicher im bss-Bereich beansprucht.  Sie können die Ebene <a href="">hier</a> ansehen.  Rein technisch sollte es also kein Problem geben.  Eine Funktion sollte einfach nicht aufgerufen werden.  Aber denken wir mal, wenn sie anruft, wo wird sie dann versuchen, sich zu erinnern? <br><br>  Erinnern Sie sich an das Layout des RAM des "klassischen" Projekts für Mikrocontroller: <br><ul><li>  .data; </li><li>  .bss; </li><li>  leerer Raum </li><li>  Anfangsstapel. </li></ul><br>  In Daten haben wir die Anfangsdaten globaler Objekte (Variablen, Strukturen und andere globale Projektfelder).  In bss globale Felder mit einem anfänglichen Nullwert und sorgfältig eine Reihe von FreeRTOS.  Es ist nur ein Array im Speicher.  mit denen dann die Methoden aus der Datei heap_x.c arbeiten.  Als nächstes kommt der leere Raum, nach dem (oder besser gesagt vom Ende) der Stapel ist.  Weil  FreeRTOS wird in meinem Projekt verwendet, dann wird dieser Stapel nur verwendet, bis der Scheduler startet.  Daher ist seine Verwendung in den meisten Fällen auf Kollobyte beschränkt (in der Tat normalerweise eine 100-Byte-Grenze). <br><br>  Aber wo wird dann mit _sbrk Speicher zugewiesen?  Schauen Sie sich an, welche Variablen sie aus dem Linker-Skript verwendet. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *__attribute__ ((weak)) _sbrk (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> incr) { <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_start; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_end; ...</code> </pre> <br>  Jetzt finden wir sie im Linker-Skript (mein Skript unterscheidet sich geringfügig von dem, das st bereitstellt, aber dieser Teil ist dort ungefähr gleich): <br><pre> <code class="bash hljs">__stack = ORIGIN(SRAM) + LENGTH(SRAM); __main_stack_size = 1024; __main_stack_limit = __stack - __main_stack_size; ...  flash,    ... .bss (NOLOAD) : ALIGN(4) { ... . = ALIGN(4); __bss_end = .; } &gt;SRAM __heap_start = __bss_end; __heap_end = __main_stack_limit;</code> </pre> <br>  Das heißt, es wird Speicher zwischen dem Stapel (1 KB von 0x20020000 nach unten mit 128 KB RAM) und bss verwendet. <br><br>  Verstanden.  Aber er hatte eine Neudefinition der Methoden malloc, free und anderer.  Verwenden Sie _sbrk schließlich ist nicht notwendig?  Wie sich herausstellte, ein Muss.  Darüber hinaus verwendet diese Methode nicht printf, sondern die Methode zum Festlegen des <b>Puffermodus</b> - <b>setvbuf</b> (oder besser _malloc_r, das in der Bibliothek nicht als schwache Funktion deklariert ist. Im Gegensatz zu malloc, das leicht ersetzt werden kann). <br><img src="https://habrastorage.org/webt/me/cf/er/mecfercw11rpbrxrfn0twjyqvva.jpeg"><br>  Da ich sicher war, dass sbrk nicht verwendet wurde, platzierte ich eine Reihe von FreeRTOS (bss-Abschnitt) in der Nähe des Stapels (weil ich sicher wusste, dass der Stapel zehnmal weniger als erforderlich verwendet wurde). <br><br>  Lösungen zu Problem 3: <br><ul><li>  Einzug zwischen bss und dem Stapel; </li><li>  _malloc_r überschreiben, damit _sbrk nicht aufgerufen wird (eine Methode von der Bibliothek trennen); </li><li>  sbrk via malloc neu schreiben und kostenlos. </li></ul><br>  Ich habe mich für die erste Option entschieden, da es nicht erfolgreich war, den Standard _malloc_r (der sich in libg_nano.a (lib_a-nano-mallocr.o) befindet) zu ersetzen (die Methode wurde nicht als __attribute__ ((schwach) deklariert), sondern nur eine einzige Funktion aus der Bi-Bibliothek auszuschließen Es ist mir nicht gelungen, eine Verknüpfung herzustellen.  Ich wollte sbrk wirklich nicht für einen Anruf umschreiben. <br><br>  Die endgültige Lösung bestand darin, separate Partitionen im RAM für den anfänglichen Stapel und _sbrk zuzuweisen.  Dies stellt sicher, dass Abschnitte während der Einrichtungsphase nicht übereinander gestapelt werden.  Innerhalb von sbrk gibt es auch einen Scheck für das Verlassen des Abschnitts.  Ich musste eine kleine Korrektur vornehmen, damit der Fluss beim Erkennen eines Übergangs ins Ausland in einer while-Schleife hängen bleibt (da die Verwendung von sbrk nur in der Anfangsphase der Initialisierung erfolgt und in der Phase des Debuggens des Geräts verarbeitet werden sollte). <br><div class="spoiler">  <b class="spoiler_title">Geändertes mem.ld</b> <div class="spoiler_text"><pre> <code class="bash hljs">MEMORY { FLASH (RX) : ORIGIN = 0x08000000, LENGTH = 1M CCM_SRAM (RW) : ORIGIN = 0x10000000, LENGTH = 64K SRAM (RW) : ORIGIN = 0x20000000, LENGTH = 126K SBRK_HEAP (RW) : ORIGIN = 0x2001F800, LENGTH = 1K MAIN_STACK (RW) : ORIGIN = 0x2001FC00, LENGTH = 1K }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Änderungen an section.ld</b> <div class="spoiler_text"><pre> <code class="bash hljs">__stack = ORIGIN(MAIN_STACK) + LENGTH(MAIN_STACK); __heap_start = ORIGIN(SBRK_HEAP); __heap_end = ORIGIN(SBRK_HEAP) + LENGTH(SBRK_HEAP);</code> </pre> </div></div><br>  Sie können <a href="">mem.ld</a> und <a href="">section.ld</a> in meinem Sandbox-Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Commit</a> <a href="">anzeigen</a> . <br><br>  UPD 07/12/2019: Die Liste der Flags für die Arbeit mit printf mit Gleitkommawerten wurde korrigiert.  Ich habe den Link zu den funktionierenden CMakeLists mit korrigierten Kompilierungs- und Layout-Flags korrigiert (es gab Nuancen mit der Tatsache, dass die Flags einzeln und durch ";" aufgelistet werden sollten, während es in einer Zeile oder in verschiedenen Zeilen keine Rolle spielt). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459420/">https://habr.com/ru/post/de459420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459404/index.html">Idee: anonyme Registrierung / Autorisierung über das Ethereum + Metamask-Netzwerk, ohne E-Mails usw.</a></li>
<li><a href="../de459408/index.html">Wie ich versucht habe, eine Kartensuche nach Treibern zu reparieren. Teil 3 (endgültig)</a></li>
<li><a href="../de459410/index.html">So schreiben Sie Code, damit Ihre Kollegen nicht schwören</a></li>
<li><a href="../de459414/index.html">Schreiben einer API für Reaktionskomponenten, Teil 4: Vorsicht vor der Apropakalypse</a></li>
<li><a href="../de459416/index.html">Schreiben einer API für Reaktionskomponenten, Teil 5: Verwenden Sie einfach die Komposition</a></li>
<li><a href="../de459422/index.html">Wir schreiben API für React-Komponenten, Teil 6: Wir erstellen die Kommunikation zwischen Komponenten</a></li>
<li><a href="../de459426/index.html">Wie das Design von Yandex.Avto erstellt wurde</a></li>
<li><a href="../de459428/index.html">Intel Quartus Prime - alles, was Sie für die Arbeit mit Intel FPGA benötigen</a></li>
<li><a href="../de459430/index.html">Mobile Anwendung mit automatischer Formularerstellung: unser Fall</a></li>
<li><a href="../de459432/index.html">RD-180: Können die USA Raketentriebwerke herstellen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>