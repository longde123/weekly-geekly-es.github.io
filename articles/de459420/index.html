<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§πüèø üëßüèæ üò¶ Der h√§ufigste Rechen bei der Verwendung von printf in Programmen f√ºr Mikrocontroller üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üñêüèª ‚öõÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von Zeit zu Zeit muss ich in meinen Projekten printf in Verbindung mit einer seriellen Schnittstelle verwenden (UART oder eine Abstraktion √ºber USB, d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Der h√§ufigste Rechen bei der Verwendung von printf in Programmen f√ºr Mikrocontroller</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459420/">  Von Zeit zu Zeit muss ich in meinen Projekten printf in Verbindung mit einer seriellen Schnittstelle verwenden (UART oder eine Abstraktion √ºber USB, die eine serielle Schnittstelle nachahmt).  Und wie immer vergeht viel Zeit zwischen den Anwendungen, und es gelingt mir, alle Nuancen, die ber√ºcksichtigt werden m√ºssen, vollst√§ndig zu vergessen, damit es in einem gro√üen Projekt normal funktioniert. <br><br>  In diesem Artikel habe ich meine eigenen Top-Nuancen zusammengestellt, die bei der Verwendung von printf in Programmen f√ºr Mikrocontroller auftreten, sortiert nach Beweisen von den offensichtlichsten bis zu den v√∂llig nicht offensichtlichen. <br><a name="habracut"></a><br><h2>  Kurze Einf√ºhrung </h2><br>  Tats√§chlich reicht es aus, printf in Programmen f√ºr Mikrocontroller zu verwenden: <ul><li>  F√ºgen Sie die Header-Datei in den Projektcode ein. </li><li>  Definieren Sie die _write-Systemfunktion neu, um sie an die serielle Schnittstelle auszugeben. </li><li>  Beschreiben der Stubs von Systemaufrufen, die der Linker ben√∂tigt (_fork, _wait und andere). </li><li>  Verwenden Sie den printf-Aufruf im Projekt. </li></ul><br>  In der Tat ist nicht alles so einfach. <br><br><h2>  Beschreiben Sie alle Stubs, nicht nur gebrauchte. </h2><br>  Das Vorhandensein einer Reihe von vagen Links im Layout des Projekts ist zun√§chst √ºberraschend, aber nach einigem Lesen wird klar, was und warum.  In all meinen Projekten verbinde ich dieses <a href="">Submodul</a> .  Daher definiere ich im Hauptprojekt nur die Methoden neu, die ich ben√∂tige (in diesem Fall nur _write), und der Rest bleibt unver√§ndert. <br><br>  Es ist wichtig zu beachten, dass alle Stubs C-Funktionen sein m√ºssen.  Nicht C ++ (oder in externes "C" eingeschlossen).  Andernfalls schl√§gt das Layout fehl (denken Sie an die Namens√§nderung w√§hrend der Assembly mit G ++). <br><br><h2>  In _write kommt 1 Zeichen </h2><br>  Trotz der Tatsache, dass der Prototyp der _write-Methode ein Argument hat, das die L√§nge der Ausgabenachricht √ºbergibt, hat er den Wert 1 (tats√§chlich werden wir ihn selbst immer auf 1 setzen, aber dazu sp√§ter mehr). <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _write (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> file, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { ... }</code> </pre> <br>  Im Internet kann man oft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">genau eine solche Implementierung</a> dieser Methode sehen: <br><div class="spoiler">  <b class="spoiler_title">H√§ufige Implementierung der Funktion _write</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uart_putc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); {} USART_SendData(USART2, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) ch); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _write_r (struct _reent *r, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> file, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * ptr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { r = r; file = file; ptr = ptr; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 int index; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* For example, output string by UART */</span></span></span><span class="hljs-meta"> for(index=0; index&lt;len; index++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ptr[index] == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\n'</span></span></span><span class="hljs-meta">) { uart_putc(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\r'</span></span></span><span class="hljs-meta">); } uart_putc(ptr[index]); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return len; }</span></span></code> </pre> <br></div></div><br>  Eine solche Implementierung hat die folgenden Nachteile: <br><ul><li>  geringe Produktivit√§t; </li><li>  Streaming-Unsicherheit; </li><li>  Unf√§higkeit, die serielle Schnittstelle f√ºr andere Zwecke zu verwenden; </li></ul><br><br><h3>  Geringe Leistung </h3><br>  Eine langsame Leistung ist auf das Senden von Bytes mithilfe von Prozessorressourcen zur√ºckzuf√ºhren: Sie m√ºssen das Statusregister √ºberwachen, anstatt denselben DMA zu verwenden.  Um dieses Problem zu l√∂sen, k√∂nnen Sie den Puffer f√ºr das Senden im Voraus vorbereiten und beim Empfangen des Zeichens am Ende der Zeile (oder beim F√ºllen des Puffers) senden.  Diese Methode erfordert einen Pufferspeicher, verbessert jedoch die Leistung bei h√§ufigem Senden erheblich. <br><div class="spoiler">  <b class="spoiler_title">Beispielimplementierung von _write mit einem Puffer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"uart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;errno.h&gt; #include &lt;sys/unistd.h&gt; extern mc::uart uart_1; extern "C" { //      uart. static const uint32_t buf_size = 254; static uint8_t tx_buf[buf_size] = {0}; static uint32_t buf_p = 0; static inline int _add_char (char data) { tx_buf[buf_p++] = data; if (buf_p &gt;= buf_size) { if (uart_1.tx(tx_buf, buf_p, 100) != mc_interfaces::res::ok) { errno = EIO; return -1; } buf_p = 0; } return 0; } // Putty  \r\n    //    . static inline int _add_endl () { if (_add_char('\r') != 0) { return -1; } if (_add_char('\n') != 0) { return -1; } uint32_t len = buf_p; buf_p = 0; if (uart_1.tx(tx_buf, len, 100) != mc_interfaces::res::ok) { errno = EIO; return -1; } return 0; } int _write (int file, char *data, int len) { len = len; //   . if ((file != STDOUT_FILENO) &amp;&amp; (file != STDERR_FILENO)) { errno = EBADF; return -1; } //     //   \n. if (*data != '\n') { if (_add_char(*data) != 0) { return -1; } } else { if (_add_endl() != 0) { return -1; } } return 1; } }</span></span></span></span></code> </pre> </div></div><br>  Hier ist das uart-Objekt uart_1 f√ºr das direkte Senden mit dma verantwortlich.  Das Objekt verwendet FreeRTOS-Methoden, um den Zugriff von Drittanbietern auf das Objekt zum Zeitpunkt des Sendens von Daten aus dem Puffer (Aufnehmen und Zur√ºckgeben von Mutex) zu blockieren.  Daher kann niemand das uart-Objekt verwenden, w√§hrend er von einem anderen Thread sendet. <br>  Einige Links: <br><ul><li>  _Schreiben Sie hier den Funktionscode als Teil eines realen Projekts </li><li>  Die Uart-Klassenschnittstelle ist <a href="">hier</a> </li><li>  Implementierung der Uart-Klassenschnittstelle unter stm32f4 <a href="">hier</a> und <a href="">hier</a> </li><li>  Instanziierung der Uart-Klasse als Teil des Projekts <a href="">hier</a> </li></ul><br><br><h3>  Streaming-Unsicherheit </h3><br>  Diese Implementierung bleibt ebenfalls ungesch√ºtzt, da sich niemand im benachbarten FreeRTOS-Stream die M√ºhe macht, eine weitere Zeile an printf zu senden und dadurch den aktuell gesendeten Puffer zu mahlen (Mutex innerhalb des Uarts sch√ºtzt das Objekt vor der Verwendung in verschiedenen Streams, aber die nicht an sie √ºbertragenen Daten )  Wenn das Risiko besteht, dass printf eines anderen Threads aufgerufen wird, muss ein Layer-Objekt implementiert werden, das den Zugriff auf printf vollst√§ndig blockiert.  In meinem speziellen Fall interagiert nur ein Thread mit printf, sodass zus√§tzliche Komplikationen nur die Leistung beeintr√§chtigen (st√§ndige Erfassung und Freigabe von Mutex innerhalb der Ebene). <br><br><h3>  Unf√§higkeit, die serielle Schnittstelle f√ºr andere Zwecke zu verwenden </h3><br>  Da wir erst senden, nachdem die gesamte Zeichenfolge empfangen wurde (oder der Puffer voll ist), k√∂nnen Sie anstelle des uart-Objekts die Konvertermethode f√ºr die nachfolgende Paket√ºbertragung an eine Schnittstelle der obersten Ebene aufrufen (z. B. Zustellung mit einer Garantie gem√§√ü dem √úbertragungsprotokoll √§hnlich wie bei Paketen Transaktionsmodbus).  Auf diese Weise k√∂nnen Sie einen Uart sowohl zum Anzeigen von Debugging-Informationen als auch zum Beispiel f√ºr die Benutzerinteraktion mit der Verwaltungskonsole verwenden (sofern einer auf dem Ger√§t verf√ºgbar ist).  Es reicht aus, einen Dekomprimierer auf der Empf√§ngerseite zu schreiben. <br><br><h2>  Standardm√§√üig funktioniert die Float-Ausgabe nicht </h2><br>  Wenn Sie newlib-nano verwenden, unterst√ºtzen printf (sowie alle ihre Derivate wie sprintf / snprintf ... und andere) standardm√§√üig die Ausgabe von float-Werten nicht.  Dies l√§sst sich leicht l√∂sen, indem dem Projekt die folgenden Linker-Flags hinzugef√ºgt werden. <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(LD_FLAGS -Wl,-u,vfprintf; -Wl,-u,_printf_float; -Wl,-u,_scanf_float; <span class="hljs-string"><span class="hljs-string">"_"</span></span>)</code> </pre> <br>  Die vollst√§ndige Liste der Flags finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Das Programm friert irgendwo im Darm von printf ein </h2><br>  Dies ist ein weiterer Fehler in den Linker-Flags.  Damit die Firmware mit der gew√ºnschten Version der Bibliothek konfiguriert werden kann, m√ºssen Sie die Prozessorparameter explizit angeben. <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(HARDWARE_FLAGS -mthumb; -mcpu=cortex-m4; -mfloat-abi=hard; -mfpu=fpv4-sp-d16;) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(LD_FLAGS <span class="hljs-variable"><span class="hljs-variable">${HARDWARE_FLAGS}</span></span> <span class="hljs-string"><span class="hljs-string">"_"</span></span>)</code> </pre><br>  Die vollst√§ndige Liste der Flags finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  printf zwingt den Mikrocontroller zu einem schweren Fehler </h2><br>  Es kann mindestens zwei Gr√ºnde geben: <br><ul><li>  Stapelprobleme; </li><li>  Probleme mit _sbrk; </li></ul><br><h3>  Stapelprobleme </h3><br>  Dieses Problem tritt wirklich auf, wenn Sie FreeRTOS oder ein anderes Betriebssystem verwenden.  Das Problem ist die Verwendung des Puffers.  Der erste Absatz besagte, dass in _write jeweils 1 Byte kommt.  Dazu m√ºssen Sie die Verwendung von Pufferung in Ihrem Code verbieten, bevor Sie printf zum ersten Mal verwenden. <br><pre> <code class="cpp hljs">setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>); setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>); setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Aus der Beschreibung der Funktion folgt, dass einer der folgenden Werte auf die gleiche Weise eingestellt werden kann: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOFBF 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set fully buffered */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOLBF 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set line buffered */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IONBF 2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set unbuffered */</span></span></span></span></code> </pre> <br>  Dies kann jedoch zu einem √úberlauf des Taskstapels f√ºhren (oder zu Unterbrechungen, wenn Sie pl√∂tzlich eine sehr schlechte Person sind, die printf von Interrupts aus aufruft). <br><br>  Rein technisch ist es m√∂glich, Stapel f√ºr jeden Stream sehr sorgf√§ltig anzuordnen, aber dieser Ansatz erfordert eine sorgf√§ltige Planung und es ist schwierig, die darin enthaltenen Fehler zu erfassen.  Eine viel einfachere L√∂sung besteht darin, jeweils ein Byte zu empfangen, es in einem eigenen Puffer zu speichern und es dann in dem zuvor analysierten erforderlichen Format auszugeben. <br><br><h3>  Probleme mit _sbrk </h3><br>  Dieses Problem war f√ºr mich pers√∂nlich das impliziteste.  Und was wissen wir √ºber _sbrk? <br><ul><li>  Ein weiterer Stub, der implementiert werden muss, um einen erheblichen Teil der Standardbibliotheken zu unterst√ºtzen. </li><li>  erforderlich, um Speicher auf dem Heap zuzuweisen; </li><li>  wird von allen Arten von Bibliotheksmethoden wie malloc verwendet, kostenlos. </li></ul><br>  Pers√∂nlich verwende ich in meinen Projekten in 95% der F√§lle FreeRTOS mit neu definierten Methoden new / delete / malloc, die eine Reihe von FreeRTOS verwenden.  Wenn ich also Speicher zuordne, bin ich sicher, dass sich die Zuweisung auf dem FreeRTOS-Heap befindet, der eine vorgegebene Menge an Speicher im bss-Bereich beansprucht.  Sie k√∂nnen die Ebene <a href="">hier</a> ansehen.  Rein technisch sollte es also kein Problem geben.  Eine Funktion sollte einfach nicht aufgerufen werden.  Aber denken wir mal, wenn sie anruft, wo wird sie dann versuchen, sich zu erinnern? <br><br>  Erinnern Sie sich an das Layout des RAM des "klassischen" Projekts f√ºr Mikrocontroller: <br><ul><li>  .data; </li><li>  .bss; </li><li>  leerer Raum </li><li>  Anfangsstapel. </li></ul><br>  In Daten haben wir die Anfangsdaten globaler Objekte (Variablen, Strukturen und andere globale Projektfelder).  In bss globale Felder mit einem anf√§nglichen Nullwert und sorgf√§ltig eine Reihe von FreeRTOS.  Es ist nur ein Array im Speicher.  mit denen dann die Methoden aus der Datei heap_x.c arbeiten.  Als n√§chstes kommt der leere Raum, nach dem (oder besser gesagt vom Ende) der Stapel ist.  Weil  FreeRTOS wird in meinem Projekt verwendet, dann wird dieser Stapel nur verwendet, bis der Scheduler startet.  Daher ist seine Verwendung in den meisten F√§llen auf Kollobyte beschr√§nkt (in der Tat normalerweise eine 100-Byte-Grenze). <br><br>  Aber wo wird dann mit _sbrk Speicher zugewiesen?  Schauen Sie sich an, welche Variablen sie aus dem Linker-Skript verwendet. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *__attribute__ ((weak)) _sbrk (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> incr) { <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_start; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_end; ...</code> </pre> <br>  Jetzt finden wir sie im Linker-Skript (mein Skript unterscheidet sich geringf√ºgig von dem, das st bereitstellt, aber dieser Teil ist dort ungef√§hr gleich): <br><pre> <code class="bash hljs">__stack = ORIGIN(SRAM) + LENGTH(SRAM); __main_stack_size = 1024; __main_stack_limit = __stack - __main_stack_size; ...  flash,    ... .bss (NOLOAD) : ALIGN(4) { ... . = ALIGN(4); __bss_end = .; } &gt;SRAM __heap_start = __bss_end; __heap_end = __main_stack_limit;</code> </pre> <br>  Das hei√üt, es wird Speicher zwischen dem Stapel (1 KB von 0x20020000 nach unten mit 128 KB RAM) und bss verwendet. <br><br>  Verstanden.  Aber er hatte eine Neudefinition der Methoden malloc, free und anderer.  Verwenden Sie _sbrk schlie√ülich ist nicht notwendig?  Wie sich herausstellte, ein Muss.  Dar√ºber hinaus verwendet diese Methode nicht printf, sondern die Methode zum Festlegen des <b>Puffermodus</b> - <b>setvbuf</b> (oder besser _malloc_r, das in der Bibliothek nicht als schwache Funktion deklariert ist. Im Gegensatz zu malloc, das leicht ersetzt werden kann). <br><img src="https://habrastorage.org/webt/me/cf/er/mecfercw11rpbrxrfn0twjyqvva.jpeg"><br>  Da ich sicher war, dass sbrk nicht verwendet wurde, platzierte ich eine Reihe von FreeRTOS (bss-Abschnitt) in der N√§he des Stapels (weil ich sicher wusste, dass der Stapel zehnmal weniger als erforderlich verwendet wurde). <br><br>  L√∂sungen zu Problem 3: <br><ul><li>  Einzug zwischen bss und dem Stapel; </li><li>  _malloc_r √ºberschreiben, damit _sbrk nicht aufgerufen wird (eine Methode von der Bibliothek trennen); </li><li>  sbrk via malloc neu schreiben und kostenlos. </li></ul><br>  Ich habe mich f√ºr die erste Option entschieden, da es nicht erfolgreich war, den Standard _malloc_r (der sich in libg_nano.a (lib_a-nano-mallocr.o) befindet) zu ersetzen (die Methode wurde nicht als __attribute__ ((schwach) deklariert), sondern nur eine einzige Funktion aus der Bi-Bibliothek auszuschlie√üen Es ist mir nicht gelungen, eine Verkn√ºpfung herzustellen.  Ich wollte sbrk wirklich nicht f√ºr einen Anruf umschreiben. <br><br>  Die endg√ºltige L√∂sung bestand darin, separate Partitionen im RAM f√ºr den anf√§nglichen Stapel und _sbrk zuzuweisen.  Dies stellt sicher, dass Abschnitte w√§hrend der Einrichtungsphase nicht √ºbereinander gestapelt werden.  Innerhalb von sbrk gibt es auch einen Scheck f√ºr das Verlassen des Abschnitts.  Ich musste eine kleine Korrektur vornehmen, damit der Fluss beim Erkennen eines √úbergangs ins Ausland in einer while-Schleife h√§ngen bleibt (da die Verwendung von sbrk nur in der Anfangsphase der Initialisierung erfolgt und in der Phase des Debuggens des Ger√§ts verarbeitet werden sollte). <br><div class="spoiler">  <b class="spoiler_title">Ge√§ndertes mem.ld</b> <div class="spoiler_text"><pre> <code class="bash hljs">MEMORY { FLASH (RX) : ORIGIN = 0x08000000, LENGTH = 1M CCM_SRAM (RW) : ORIGIN = 0x10000000, LENGTH = 64K SRAM (RW) : ORIGIN = 0x20000000, LENGTH = 126K SBRK_HEAP (RW) : ORIGIN = 0x2001F800, LENGTH = 1K MAIN_STACK (RW) : ORIGIN = 0x2001FC00, LENGTH = 1K }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">√Ñnderungen an section.ld</b> <div class="spoiler_text"><pre> <code class="bash hljs">__stack = ORIGIN(MAIN_STACK) + LENGTH(MAIN_STACK); __heap_start = ORIGIN(SBRK_HEAP); __heap_end = ORIGIN(SBRK_HEAP) + LENGTH(SBRK_HEAP);</code> </pre> </div></div><br>  Sie k√∂nnen <a href="">mem.ld</a> und <a href="">section.ld</a> in meinem Sandbox-Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Commit</a> <a href="">anzeigen</a> . <br><br>  UPD 07/12/2019: Die Liste der Flags f√ºr die Arbeit mit printf mit Gleitkommawerten wurde korrigiert.  Ich habe den Link zu den funktionierenden CMakeLists mit korrigierten Kompilierungs- und Layout-Flags korrigiert (es gab Nuancen mit der Tatsache, dass die Flags einzeln und durch ";" aufgelistet werden sollten, w√§hrend es in einer Zeile oder in verschiedenen Zeilen keine Rolle spielt). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459420/">https://habr.com/ru/post/de459420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459404/index.html">Idee: anonyme Registrierung / Autorisierung √ºber das Ethereum + Metamask-Netzwerk, ohne E-Mails usw.</a></li>
<li><a href="../de459408/index.html">Wie ich versucht habe, eine Kartensuche nach Treibern zu reparieren. Teil 3 (endg√ºltig)</a></li>
<li><a href="../de459410/index.html">So schreiben Sie Code, damit Ihre Kollegen nicht schw√∂ren</a></li>
<li><a href="../de459414/index.html">Schreiben einer API f√ºr Reaktionskomponenten, Teil 4: Vorsicht vor der Apropakalypse</a></li>
<li><a href="../de459416/index.html">Schreiben einer API f√ºr Reaktionskomponenten, Teil 5: Verwenden Sie einfach die Komposition</a></li>
<li><a href="../de459422/index.html">Wir schreiben API f√ºr React-Komponenten, Teil 6: Wir erstellen die Kommunikation zwischen Komponenten</a></li>
<li><a href="../de459426/index.html">Wie das Design von Yandex.Avto erstellt wurde</a></li>
<li><a href="../de459428/index.html">Intel Quartus Prime - alles, was Sie f√ºr die Arbeit mit Intel FPGA ben√∂tigen</a></li>
<li><a href="../de459430/index.html">Mobile Anwendung mit automatischer Formularerstellung: unser Fall</a></li>
<li><a href="../de459432/index.html">RD-180: K√∂nnen die USA Raketentriebwerke herstellen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>