<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤴🏼 ⛸️ 🌊 Operator pesawat ruang angkasa baru di C ++ 20 😭 🎇 🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ 20 menambahkan operator baru yang disebut "pesawat ruang angkasa": <=> . Belum lama berselang, Simon Brand menerbitkan sebuah posting yang berisi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Operator pesawat ruang angkasa baru di C ++ 20</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/458242/"> C ++ 20 menambahkan operator baru yang disebut "pesawat ruang angkasa": <code>&lt;=&gt;</code> .  Belum lama berselang, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Simon Brand</a> menerbitkan sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting</a> yang berisi informasi konseptual terperinci tentang apa operator ini dan untuk tujuan apa ia digunakan.  Tugas utama tulisan ini adalah mempelajari aplikasi spesifik operator baru "aneh" dan <code>operator==</code> analognya <code>operator==</code> , serta merumuskan beberapa rekomendasi untuk penggunaannya dalam pengkodean sehari-hari. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ny/pa/bp/nypabpd9lxsd9ifx_f7_zitj7ti.png"></div><a name="habracut"></a><br><h2>  Perbandingan </h2><br>  Sudah lazim melihat kode seperti berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value == rhs.value; }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rhs);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value;  }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);    }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs)  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rhs &lt; *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;        }  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt; rhs);    } };</code> </pre> <br>  <i>Catatan: pembaca yang penuh perhatian akan melihat bahwa ini sebenarnya lebih sedikit verbose daripada seharusnya dalam kode sebelum C ++ 20.</i>  <i>Lebih lanjut tentang ini nanti.</i> <br><br>  Anda perlu menulis banyak kode standar untuk memastikan bahwa jenis kami dapat dibandingkan dengan jenis yang sama.  Oke, kita akan mencari tahu sebentar.  Kemudian datang seseorang yang menulis seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(is_lt(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); }</code> </pre> <br>  Hal pertama yang Anda perhatikan adalah bahwa program tidak akan dikompilasi. <br><br> <code>error C3615: constexpr function 'is_lt' cannot result in a constant expression</code> <br> <br>  Masalahnya adalah bahwa <code>constexpr</code> dilupakan dalam fungsi perbandingan.  Kemudian beberapa akan menambahkan <code>constexpr</code> ke semua operator perbandingan.  Beberapa hari kemudian, seseorang akan menambahkan <code>is_gt</code> , tetapi perhatikan bahwa semua operator pembanding tidak memiliki spesifikasi pengecualian, dan Anda harus melalui proses yang sama yaitu menambahkan <code>noexcept</code> untuk masing-masing dari 5 kelebihan beban. <br><br>  Di sinilah operator pesawat ruang angkasa C ++ 20 yang baru datang untuk membantu kami.  Mari kita lihat bagaimana Anda dapat menulis <code>IntWrapper</code> asli di dunia C ++ 20: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Perbedaan pertama yang mungkin Anda perhatikan adalah penyertaan baru <code>&lt;compare&gt;</code> .  Header <code>&lt;compare&gt;</code> bertanggung jawab untuk mengisi kompilator dengan semua jenis kategori perbandingan yang diperlukan untuk operator pesawat ruang angkasa, sehingga ia mengembalikan jenis yang cocok untuk fungsi default kami.  Dalam cuplikan di atas, tipe pengembalian <code>auto</code> akan menjadi <code>std::strong_ordering</code> . <br><br>  Kami tidak hanya menghapus 5 baris tambahan, tetapi kami bahkan tidak perlu menentukan apa pun, kompiler akan melakukannya untuk kami.  <code>is_lt</code> tetap tidak berubah dan hanya berfungsi, sementara tetap <code>constexpr</code> , meskipun kami tidak secara eksplisit menentukan ini di <code>operator&lt;=&gt;</code> default kami <code>operator&lt;=&gt;</code> .  Ini bagus, tetapi beberapa orang mungkin bingung mengapa <code>is_lt</code> diizinkan untuk dikompilasi bahkan jika itu tidak menggunakan operator pesawat ruang angkasa sama sekali.  Mari kita temukan jawaban untuk pertanyaan ini. <br><br><h2>  Menulis Ulang Ekspresi </h2><br>  Dalam C ++ 20, kompiler diperkenalkan ke dalam konsep baru terkait dengan ekspresi "ditulis ulang".  Operator pesawat ruang angkasa, bersama dengan <code>operator==</code> , adalah salah satu dari dua kandidat pertama yang dapat ditulis ulang.  Untuk contoh yang lebih spesifik dari penulisan ulang ekspresi, mari kita lihat contoh yang diberikan di <code>is_lt</code> . <br><br>  Saat menyelesaikan kelebihan beban, kompiler akan memilih dari sekumpulan kandidat yang paling cocok, yang masing-masing sesuai dengan operator yang kita butuhkan.  Proses pemilihan berubah sangat sedikit untuk operasi perbandingan dan operasi ekivalensi, ketika kompiler juga harus mengumpulkan kandidat transkrip dan disintesis khusus ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">[over.match.oper] /3.4</a> ). <br><br>  Untuk ekspresi kita <code>a &lt; b</code> standar menyatakan bahwa kita dapat mencari tipe <code>a</code> untuk <code>operator&lt;=&gt;</code> atau fungsi <code>operator&lt;=&gt;</code> yang menerima jenis ini.  Inilah yang dilakukan oleh kompiler dan menemukan bahwa tipe <code>a</code> sebenarnya berisi <code>IntWrapper::operator&lt;=&gt;</code> .  Kompiler kemudian diizinkan untuk menggunakan operator ini dan menulis ulang ekspresi <code>a &lt; b</code> as <code>(a &lt;=&gt; b) &lt; 0</code> .  Ungkapan ditulis ulang ini kemudian digunakan sebagai kandidat untuk resolusi overload normal. <br><br>  Anda mungkin bertanya mengapa ungkapan yang ditulis ulang ini benar.  Ketepatan ekspresi sebenarnya mengikuti dari semantik yang disediakan oleh operator pesawat ruang angkasa.  <code>&lt;=&gt;</code> adalah perbandingan tiga arah, yang menyiratkan bahwa Anda tidak hanya mendapatkan hasil biner, tetapi juga pesanan (dalam kebanyakan kasus).  Jika Anda memiliki pesanan, Anda dapat mengungkapkan pesanan ini dalam hal operasi perbandingan apa pun.  Contoh cepat, ekspresi 4 &lt;=&gt; 5 dalam C ++ 20 akan mengembalikan hasil <code>std::strong_ordering::less</code> .  Hasil dari <code>std::strong_ordering::less</code> menyiratkan bahwa <code>4</code> tidak hanya berbeda dari <code>5</code> tetapi juga sangat kurang dari nilai ini, yang membuat aplikasi operasi <code>(4 &lt;=&gt; 5) &lt; 0</code> benar dan akurat untuk menggambarkan hasil kami. <br><br>  Dengan menggunakan informasi di atas, kompiler dapat menggunakan operator pembanding umum (mis., <code>&lt;</code> , <code>&gt;</code> , Dll.) Dan menulis ulang dalam hal operator ruang angkasa.  Dalam standar, ekspresi ditulis ulang sering disebut sebagai <code>(a &lt;=&gt; b) @ 0</code> mana <code>@</code> mewakili operasi perbandingan. <br><br><h2>  Menyintesis Ekspresi </h2><br>  Pembaca mungkin telah memperhatikan referensi halus untuk ekspresi "disintesis" di atas, dan mereka juga memainkan peran dalam proses penulisan ulang pernyataan ini.  Pertimbangkan fungsi berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_gt_42</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> &lt; a; }</code> </pre> <br>  Jika kami menggunakan definisi asli kami untuk <code>IntWrapper</code> , kode ini tidak akan dikompilasi. <br><br> <code>error C2677: binary '&lt;': no global operator found which takes type 'const IntWrapper' (or there is no acceptable conversion)</code> <br> <br>  Ini masuk akal sebelum C ++ 20, dan cara untuk menyelesaikan masalah ini adalah menambahkan beberapa fungsi <code>friend</code> tambahan ke <code>IntWrapper</code> yang menempati sisi kiri <code>int</code> .  Jika Anda mencoba membuat contoh ini menggunakan kompiler dan <code>IntWrapper</code> C ++ 20, Anda mungkin memperhatikan bahwa, sekali lagi, itu hanya berfungsi.  Mari kita lihat mengapa kode di atas masih dikompilasi di C ++ 20. <br><br>  Saat mengatasi kelebihan beban, kompiler juga akan mengumpulkan apa yang standar sebut kandidat "disintesis", atau ekspresi ditulis ulang dengan urutan parameter terbalik.  Dalam contoh di atas, kompiler akan mencoba menggunakan ekspresi yang ditulis ulang <code>(42 &lt;=&gt; a) &lt; 0</code> , tetapi akan menemukan bahwa tidak ada konversi dari <code>IntWrapper</code> ke <code>int</code> untuk memenuhi sisi kiri, sehingga ekspresi yang ditulis ulang dibuang.  Kompilator juga memanggil ekspresi “disintesis” <code>0 &lt; (a &lt;=&gt; 42)</code> dan mendeteksi bahwa konversi dari <code>int</code> ke <code>IntWrapper</code> melalui konstruktor konversi, sehingga kandidat ini digunakan. <br><br>  Tujuan dari ekspresi yang disintesis adalah untuk menghindari kebingungan penulisan templat fungsi <code>friend</code> untuk mengisi celah di mana objek Anda dapat dikonversi dari tipe lain.  Ekspresi yang disintesis digeneralisasi ke <code>0 @ (b &lt;=&gt; a)</code> . <br><br><h2>  Jenis yang lebih kompleks </h2><br>  Operator pesawat ruang angkasa yang dihasilkan oleh kompiler tidak berhenti di masing-masing anggota kelas, tetapi menghasilkan kumpulan perbandingan yang benar untuk semua sub objek dalam tipe Anda: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Basics</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f;  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d;  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Basics&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai[<span class="hljs-number"><span class="hljs-number">1</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ac[<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> af[<span class="hljs-number"><span class="hljs-number">3</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ad[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>];  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arrays&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bases</span></span></span><span class="hljs-class"> :</span></span> Basics, Arrays {  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Bases&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases a = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> Bases b = { { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.</span></span> },                        { { <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> }, { <span class="hljs-number"><span class="hljs-number">1.f</span></span>, <span class="hljs-number"><span class="hljs-number">2.f</span></span>, <span class="hljs-number"><span class="hljs-number">3.f</span></span> }, { { <span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">2.</span></span> }, { <span class="hljs-number"><span class="hljs-number">3.</span></span>, <span class="hljs-number"><span class="hljs-number">4.</span></span> } } } };  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a == b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a != b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &lt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &lt;= b);  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(!(a &gt; b));  <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(a &gt;= b); }</code> </pre> <br>  Kompiler tahu bagaimana memperluas anggota kelas yang array ke dalam daftar sub-objek mereka dan membandingkannya secara rekursif.  Tentu saja, jika Anda ingin menulis sendiri fungsi-fungsi ini, Anda masih akan mendapat manfaat dari menulis ulang ekspresi oleh kompiler. <br><br><h2>  Tampak seperti bebek, berenang seperti bebek, dan dukun seperti <code>operator==</code> </h2><br>  Beberapa orang yang sangat pintar dalam komite standardisasi telah memperhatikan bahwa operator pesawat ruang angkasa akan selalu melakukan perbandingan unsur-unsur leksikografis, apa pun yang terjadi.  Eksekusi tanpa syarat dari perbandingan leksikografis dapat menyebabkan kode yang tidak efisien, khususnya, dengan operator kesetaraan. <br><br>  Contoh kanonik membandingkan dua garis.  Jika Anda memiliki string <code>"foobar"</code> dan Anda membandingkannya dengan string <code>"foo"</code> menggunakan ==, Anda dapat mengharapkan operasi ini hampir konstan.  Algoritma perbandingan string yang efektif adalah sebagai berikut: <br><br><ul><li>  Pertama, bandingkan ukuran kedua garis tersebut.  Jika ukurannya berbeda, maka kembalikan <code>false</code> </li><li>  Kalau tidak, melangkahlah melalui setiap elemen dari dua garis selangkah demi selangkah dan membandingkannya sampai ada perbedaan atau semua elemen berakhir.  Kembalikan hasilnya. </li></ul><br>  Sesuai dengan aturan operator pesawat ruang angkasa, kita harus mulai dengan membandingkan setiap elemen hingga kita menemukan yang berbeda.  Dalam contoh kami, <code>"foobar"</code> dan <code>"foo"</code> hanya ketika membandingkan <code>'b'</code> dan <code>'\0'</code> akhirnya Anda mengembalikan <code>false</code> . <br><br>  Untuk mengatasi ini, ada artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P1185R2</a> , yang merinci bagaimana kompiler menulis ulang dan menghasilkan <code>operator==</code> secara independen dari operator pesawat ruang angkasa.  <code>IntWrapper</code> kami dapat ditulis sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;compare&gt; struct IntWrapper {  int value;  constexpr IntWrapper(int value): value{value} { }  auto operator&lt;=&gt;(const IntWrapper&amp;) const = default;  bool operator==(const IntWrapper&amp;) const = default; };</span></span></span></span></code> </pre> <br>  Satu langkah lagi ... namun, ada kabar baik;  Anda tidak perlu menulis kode di atas, karena hanya menulis <code>auto operator&lt;=&gt;(const IntWrapper&amp;) const = default</code> cukup bagi kompiler untuk secara implisit menghasilkan <code>operator==</code> terpisah dan lebih efisien <code>operator==</code> untuk Anda! <br><br>  Kompiler menerapkan aturan "penulisan ulang" yang sedikit dimodifikasi, khusus untuk <code>==</code> dan <code>!=</code> , Di mana dalam operator ini mereka ditulis ulang dalam hal <code>operator==</code> daripada <code>operator&lt;=&gt;</code> .  Ini artinya <code>!=</code> Juga mendapat manfaat dari pengoptimalan. <br><br><h2>  Kode lama tidak akan rusak </h2><br>  Pada titik ini, Anda mungkin berpikir: baik, jika kompiler diizinkan untuk melakukan operasi penulisan ulang operator ini, apa yang akan terjadi jika saya mencoba mengecoh kompiler: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-class"> {</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function">: value</span></span>{value} { }  <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;=&gt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp;) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt;(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IntWrapper&amp; rhs) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &lt; rhs.value; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_lt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntWrapper&amp; b)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  Jawabannya bukan masalah besar.  Model resolusi kelebihan dalam C ++ adalah arena di mana semua kandidat berbenturan.  Dalam pertempuran khusus ini, kami memiliki tiga dari mereka: <br><br><ul><li> <code>IntWrapper::operator&lt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> <li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; a, const IntWrapper&amp; b)</code> </li> </ul><br>  (ditulis ulang) <br><br><ul><li> <code>IntWrapper::operator&lt;=&gt;(const IntWrapper&amp; b, const IntWrapper&amp; a)</code> </li> </ul><br>  (disintesis) <br><br>  Jika kami mengadopsi aturan resolusi kelebihan di C ++ 17, hasil dari panggilan ini akan dicampur, tetapi aturan resolusi kelebihan C ++ 20 diubah sehingga kompilator dapat menyelesaikan situasi ini ke beban berlebih yang paling logis. <br><br>  Ada fase resolusi kelebihan ketika kompiler harus menyelesaikan serangkaian lintasan tambahan.  Dalam C ++ 20, sebuah mekanisme baru telah muncul, di mana preferensi diberikan kepada overload yang tidak ditimpa atau disintesis, yang membuat <code>IntWrapper::operator&lt;</code> kami <code>IntWrapper::operator&lt;</code> membebani kandidat terbaik dan menyelesaikan ambiguitas.  Mekanisme yang sama mencegah penggunaan kandidat yang disintesis alih-alih ekspresi yang ditulis ulang. <br><br><h2>  Pikiran terakhir </h2><br>  Operator pesawat ruang angkasa adalah tambahan selamat datang untuk C ++, karena dapat membantu menyederhanakan kode Anda dan menulis lebih sedikit, dan kadang-kadang lebih sedikit lebih baik.  Jadi, kencangkan sabuk pengaman C ++ 20 Anda! <br><br>  Kami mendesak Anda untuk keluar dan mencoba operator pesawat ruang angkasa, ini tersedia sekarang di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visual Studio 2019 di</a> bawah <code>/std:c++latest</code> !  Sebagai catatan, perubahan yang dilakukan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">P1185R2</a> akan tersedia di Visual Studio 2019 versi 16.2.  Harap diingat bahwa operator pesawat ruang angkasa adalah bagian dari C ++ 20 dan dapat mengalami beberapa perubahan hingga saat C ++ 20 selesai. <br><br>  Seperti biasa, kami menunggu tanggapan Anda.  Jangan ragu untuk mengirim komentar melalui email ke <a href="">visualcpp@microsoft.com</a> , melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter @visualc</a> , atau Facebook <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Microsoft Visual Cpp</a> . <br><br>  Jika Anda mengalami masalah lain dengan MSVC di VS 2019, beri tahu kami melalui opsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Laporkan Masalah"</a> , baik dari penginstal atau dari Visual Studio IDE itu sendiri.  Untuk saran atau laporan bug, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kirimkan</a> kepada kami melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevComm.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458242/">https://habr.com/ru/post/id458242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458220/index.html">Intisari materi menarik untuk pengembang ponsel # 304 (pada 24 - 30 Juni)</a></li>
<li><a href="../id458222/index.html">Memecah permainan memori: seluruh cerita detektif</a></li>
<li><a href="../id458224/index.html">Perangkat lunak untuk Boeing-737 Max ditulis oleh agen outsourcing yang menghasilkan $ 9 per jam</a></li>
<li><a href="../id458228/index.html">Mengapa kita membutuhkan fungsi virtual</a></li>
<li><a href="../id458240/index.html">Bagaimana kecerdasan buatan, drone, dan kamera memastikan keamanan jalan dan jembatan</a></li>
<li><a href="../id458244/index.html">Daftar tak berujung dan konyol tentang apa yang perlu Anda ketahui agar dapat menggunakan jaringan Wi-Fi publik dengan aman</a></li>
<li><a href="../id458246/index.html">Kebetulan kebetulan dalam hidup, atau ternyata Anda dihadiahi kue di pabrik traktor</a></li>
<li><a href="../id458248/index.html">Sederhanakan Kode Anda Dengan Ilmu Roket: Operator Pesawat Luar Angkasa C ++ 20</a></li>
<li><a href="../id458250/index.html">BTRFS untuk yang terkecil</a></li>
<li><a href="../id458252/index.html">Model matematika teleskop radio super panjang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>