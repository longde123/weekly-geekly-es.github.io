<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòÅ ü§òüèΩ üçÆ Conceptos b√°sicos del motor de JavaScript: formularios generales y almacenamiento en cach√© en l√≠nea. Parte 1 üë©üèΩ‚Äçüåæ ‚ôäÔ∏è üë©üèø‚Äçüåæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola amigos A finales de abril, estamos lanzando un nuevo curso "Seguridad de los sistemas de informaci√≥n" . Y ahora queremos compartir con ustedes un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conceptos b√°sicos del motor de JavaScript: formularios generales y almacenamiento en cach√© en l√≠nea. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/446446/">  Hola amigos  A finales de abril, estamos lanzando un nuevo curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Seguridad de los sistemas de informaci√≥n"</a> .  Y ahora queremos compartir con ustedes una traducci√≥n del art√≠culo, que sin duda ser√° muy √∫til para el curso.  El art√≠culo original se puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontrar aqu√≠</a> . <br><br>  El art√≠culo describe los fundamentos clave, son comunes a todos los motores de JavaScript, y no solo a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V8</a> , en el que est√°n trabajando los autores del motor ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Benedict</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Matias</a> ).  Como desarrollador de JavaScript, puedo decir que una comprensi√≥n m√°s profunda de c√≥mo funciona el motor de JavaScript lo ayudar√° a descubrir c√≥mo escribir c√≥digo eficiente. <br><br><img src="https://habrastorage.org/webt/14/ef/xe/14efxewawb3ttgslcsxyzicgjy0.png"><br><a name="habracut"></a><br><blockquote>  <b>Nota</b> : si prefiere ver presentaciones que leer art√≠culos, mire este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">video</a> .  De lo contrario, s√°ltelo y siga leyendo. </blockquote>  <b>Motor JavaScript de canalizaci√≥n (canalizaci√≥n)</b> <br><br>  Todo comienza con el hecho de que escribes c√≥digo JavaScript.  Despu√©s de eso, el motor de JavaScript procesa el c√≥digo fuente y lo presenta como un √°rbol de sintaxis abstracta (AST).  Basado en el AST construido, el int√©rprete finalmente puede ponerse a trabajar y comenzar a generar bytecode.  Genial  Este es el momento en que el motor ejecuta el c√≥digo JavaScript. <br><br><img src="https://habrastorage.org/webt/i6/8r/f2/i68rf23urqlxa20gzhubwz2-snq.jpeg"><br><br>  Para que funcione m√°s r√°pido, puede enviar bytecode al compilador de optimizaci√≥n junto con los datos de creaci√≥n de perfiles.  El compilador de optimizaci√≥n realiza ciertas suposiciones basadas en datos de perfil, luego genera un c√≥digo de m√°quina altamente optimizado. <br><br>  Si en alg√∫n momento las suposiciones resultan ser incorrectas, el compilador de optimizaci√≥n des-optimizar√° el c√≥digo y volver√° a la etapa de int√©rprete. <br><br>  <b>Tuber√≠as de int√©rprete / compilador en motores JavaScript</b> <br><br>  Ahora echemos un vistazo m√°s de cerca a las partes de la tuber√≠a que ejecutan su c√≥digo JavaScript, es decir, d√≥nde se interpreta y optimiza el c√≥digo, y tambi√©n veamos algunas diferencias entre los principales motores JavaScript. <br><br>  En el coraz√≥n de todo hay una tuber√≠a que contiene un int√©rprete y un compilador optimizador.  El int√©rprete genera r√°pidamente un c√≥digo de bytes no optimizado, el compilador de optimizaci√≥n, a su vez, trabaja m√°s tiempo, pero la salida tiene un c√≥digo de m√°quina altamente optimizado. <br><br><img src="https://habrastorage.org/webt/gh/ap/o6/ghapo68sxzyqniyjqw0v0xewpry.jpeg"><br><br>  El siguiente es un canal que muestra c√≥mo funciona V8, el motor de JavaScript utilizado por Chrome y Node.js. <br><br><img src="https://habrastorage.org/webt/8i/nu/0w/8inu0wkuzc8_enexkp8o7pn7jgi.jpeg"><br><br>  El int√©rprete en V8 se llama Ignition, que es responsable de generar y ejecutar bytecode.  Recopila datos de creaci√≥n de perfiles que se pueden utilizar para acelerar la ejecuci√≥n en el siguiente paso mientras se procesa el c√≥digo de bytes.  Cuando una funci√≥n se <i>calienta</i> , por ejemplo, si se inicia con frecuencia, el bytecode generado y los datos de perfil se transfieren al TurboFan, es decir, al compilador de optimizaci√≥n para generar c√≥digo de m√°quina altamente optimizado basado en los datos de perfil. <br><br><img src="https://habrastorage.org/webt/ww/n5/zi/wwn5zi7l8vzzcfaik86qwhdtprc.jpeg"><br><br>  Por ejemplo, el motor JavaScript SpiderMonkey de Mozilla, que se usa en Firefox y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SpiderNode</a> , funciona de manera un poco diferente.  No tiene uno, sino dos compiladores optimizadores.  El int√©rprete est√° optimizado en un compilador b√°sico (compilador de l√≠nea de base), que produce un c√≥digo optimizado.  Junto con los datos de perfil recopilados durante la ejecuci√≥n del c√≥digo, el compilador IonMonkey puede generar c√≥digo altamente optimizado.  Si la optimizaci√≥n especulativa falla, IonMonkey vuelve al c√≥digo de l√≠nea de base. <br><br><img src="https://habrastorage.org/webt/gu/ek/ps/guekpsu0p1nqwv-pynj7ts8skdo.jpeg"><br><br>  Chakra: el motor JavaScript de Microsoft, utilizado en Edge y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Node-ChakraCore</a> , tiene una estructura muy similar y utiliza dos compiladores optimizadores.  El int√©rprete est√° optimizado en SimpleJIT (donde JIT significa "compilador Just-In-Time", que produce c√≥digo algo optimizado. Junto con los datos de creaci√≥n de perfiles, FullJIT puede crear c√≥digo a√∫n m√°s optimizado. <br><br><img src="https://habrastorage.org/webt/z-/bl/0v/z-bl0va0qlsrvgandnxrb08q52g.jpeg"><br><br>  JavaScriptCore (abreviado como JSC), el motor JavaScript de Apple utilizado por Safari y React Native, generalmente tiene tres compiladores de optimizaci√≥n diferentes.  LLInt es un int√©rprete de bajo nivel que est√° optimizado para el compilador base, que a su vez est√° optimizado para el compilador DFG (Data Flow Graph), y ya est√° optimizado para el compilador FTL (Faster Than Light). <br><br>  ¬øPor qu√© algunos motores tienen m√°s compiladores optimizadores que otros?  Se trata de compromisos.  El int√©rprete puede procesar bytecode r√°pidamente, pero bytecode por s√≠ solo no es particularmente eficiente.  El compilador de optimizaci√≥n, por otro lado, funciona un poco m√°s, pero produce un c√≥digo de m√°quina m√°s eficiente.  Esto es un compromiso entre obtener r√°pidamente el c√≥digo (int√©rprete) o esperar y ejecutar el c√≥digo con el m√°ximo rendimiento (compilador de optimizaci√≥n).  Algunos motores eligen agregar varios compiladores de optimizaci√≥n con diferentes caracter√≠sticas de tiempo y eficiencia, lo que le permite proporcionar el mejor control sobre esta soluci√≥n de compromiso y comprender el costo de las complicaciones adicionales del dispositivo interno.  Otra compensaci√≥n es el uso de memoria; consulte este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> para una mejor comprensi√≥n. <br><br>  Acabamos de examinar las principales diferencias entre las tuber√≠as del compilador del int√©rprete y el optimizador para varios motores JavaScript.  A pesar de estas diferencias de alto nivel, todos los motores de JavaScript tienen la misma arquitectura: todos tienen un analizador y alg√∫n tipo de canalizaci√≥n de int√©rprete / compilador. <br><br>  <b>Modelo de objeto de JavaScript</b> <br><br>  Veamos qu√© m√°s tienen en com√∫n los motores de JavaScript y qu√© trucos usan para acelerar el acceso a las propiedades de los objetos de JavaScript.  Resulta que todos los motores principales hacen esto de manera similar. <br><br>  La especificaci√≥n ECMAScript define todos los objetos como diccionarios con claves de cadena que coinciden con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">los</a> atributos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">propiedad</a> . <br><br><img src="https://habrastorage.org/webt/7s/vv/qq/7svvqqqqfcqi2y-v88nlstidtik.jpeg"><br><br>  Adem√°s del propio <code>[[Value]]</code> , la especificaci√≥n define las siguientes propiedades: <br><br><ul><li>  <code>[[Writable]]</code> determina si una propiedad puede ser reasignada; </li><li>  <code>[[Enumerable]]</code> determina si la propiedad se muestra en bucles for-in; </li><li>  <code>[[Configurable]]</code> determina si una propiedad se puede eliminar. </li></ul><br>  La notaci√≥n <code>[[  ]]</code> parece extra√±a, pero as√≠ es como la especificaci√≥n describe las propiedades en JavaScript.  Todav√≠a puede obtener estos atributos de propiedad para cualquier objeto y propiedad en JavaScript utilizando la API <code>Object.getOwnPropertyDescriptor</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(object, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí { value: 42, writable: true, enumerable: true, configurable: true }</span></span></code> </pre> <br>  Ok, entonces JavaScript define objetos.  ¬øQu√© pasa con las matrices? <br><br>  Puedes imaginar las matrices como objetos especiales.  La √∫nica diferencia es que las matrices tienen un procesamiento de √≠ndice especial.  Aqu√≠, un √≠ndice de matriz es un t√©rmino especial en la especificaci√≥n ECMAScript.  JavaScript tiene l√≠mites en el n√∫mero de elementos en una matriz, hasta 2¬≥¬≤ - 1.  Un √≠ndice de matriz es cualquier √≠ndice disponible de este rango, es decir, cualquier valor entero de 0 a 2¬≥¬≤ - 2. <br><br>  Otra diferencia es que las matrices tienen la propiedad m√°gica de la <code>length</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; array.length; <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 2 array[2] = 'c'; array.length; // ‚Üí 3</span></span></code> </pre> <br>  En este ejemplo, la matriz tiene una longitud de 2 en el momento de la creaci√≥n.  Luego asignamos otro elemento al √≠ndice 2 y la longitud aumenta autom√°ticamente. <br><br>  JavaScript define matrices y objetos.  Por ejemplo, todas las claves, incluidos los √≠ndices de matriz, se representan expl√≠citamente como cadenas.  El primer elemento de la matriz se almacena bajo la clave '0'. <br><br><img src="https://habrastorage.org/webt/a0/nr/18/a0nr18etozy9wzmzzsd9zbykxt0.jpeg"><br><br>  La propiedad de <code>length</code> es solo otra propiedad que resulta no enumerable ni configurable. <br><br>  Tan pronto como se agrega un elemento a la matriz, JavaScript actualiza autom√°ticamente el atributo de la propiedad <code>[[Value]]</code> propiedad de <code>length</code> . <br><br><img src="https://habrastorage.org/webt/ws/hs/89/wshs896vflemplsrai-wqu5brkw.jpeg"><br><br>  En general, podemos decir que las matrices se comportan de manera similar a los objetos. <br><br>  <b>Optimizaci√≥n del acceso a las propiedades.</b> <br><br>  Ahora que sabemos c√≥mo se definen los objetos en JavaScript, echemos un vistazo a c√≥mo los motores de JavaScript le permiten trabajar con objetos de manera eficiente. <br><br>  En la vida cotidiana, el acceso a las propiedades es la operaci√≥n m√°s com√∫n.  Es extremadamente importante que el motor haga esto r√°pidamente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-string"><span class="hljs-string">'qux'</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">// Here, we're accessing the property `foo` on `object`: doSomething(object.foo); // ^^^^^^^^^^</span></span></code> </pre> <br>  <b>Formas</b> <br><br>  En los programas de JavaScript, es una pr√°ctica bastante com√∫n asignar las mismas claves de propiedad a muchos objetos.  Dicen que tales objetos tienen la misma <i>forma</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// `object1` and `object2` have the same shape.</span></span></code> </pre> <br>  Tambi√©n la mec√°nica com√∫n es el acceso a la propiedad de objetos de la misma forma: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object.x); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^ } const object1 = { x: 1, y: 2 }; const object2 = { x: 3, y: 4 }; logX(object1); logX(object2);</span></span></code> </pre> <br>  Sabiendo esto, los motores de JavaScript pueden optimizar el acceso a la propiedad de un objeto en funci√≥n de su forma.  Mira c√≥mo funciona. <br><br>  Supongamos que tenemos un objeto con propiedades x e y, utiliza la estructura de datos del diccionario, de la que hablamos anteriormente;  Contiene cadenas clave que apuntan a sus respectivos atributos. <br><br><img src="https://habrastorage.org/webt/ss/ne/v9/ssnev9md3jko58annrfjraz35ay.jpeg"><br><br>  Si accede a una propiedad, como <code>object.y,</code> el motor de JavaScript busca un JSObject con la clave <code>'y'</code> , luego carga los atributos de propiedad que coinciden con esta consulta y finalmente devuelve <code>[[Value]]</code> . <br><br>  Pero, ¬ød√≥nde se almacenan estos atributos de propiedad en la memoria?  ¬øDeber√≠amos almacenarlos como parte de un JSObject?  Si hacemos esto, veremos m√°s objetos de esta forma m√°s adelante, en cuyo caso, es un desperdicio de espacio almacenar un diccionario completo que contenga los nombres de propiedades y atributos en el propio JSObject, ya que los nombres de propiedades se repiten para todos los objetos de la misma forma.  Esto causa mucha duplicaci√≥n y conduce a una mala asignaci√≥n de memoria.  Para la optimizaci√≥n, los motores almacenan la forma del objeto por separado. <br><br><img src="https://habrastorage.org/webt/mc/yr/mt/mcyrmt9jarqodgtvnwoxzatiwyy.jpeg"><br><br>  Esta <code>Shape</code> contiene todos los nombres de propiedades y atributos excepto <code>[[Value]]</code> .  En cambio, el formulario contiene los valores de desplazamiento dentro del JSObject, por lo que el motor de JavaScript sabe d√≥nde buscar los valores.  Cada objeto JSO con un formulario com√∫n indica una instancia espec√≠fica del formulario.  Ahora cada JSObject tiene que almacenar solo valores que sean √∫nicos para el objeto. <br><br><img src="https://habrastorage.org/webt/-0/-q/t5/-0-qt5an58iyuoeskzaibbtgcno.jpeg"><br><br>  La ventaja se hace evidente en cuanto tenemos muchos objetos.  Su n√∫mero no importa, porque si tienen un formulario, guardamos informaci√≥n sobre el formulario y la propiedad solo una vez. <br><br>  Todos los motores de JavaScript usan formularios como un medio de optimizaci√≥n, pero no los nombran directamente como <code>shapes</code> : <br><br><ol><li>  La documentaci√≥n acad√©mica los llama clases ocultas (similares a las clases de JavaScript); </li><li>  V8 los llama Mapas; </li><li>  Chakra los llama Tipos; </li><li>  JavaScriptCore los llama estructuras; </li><li>  SpiderMonkey los llama formas. </li></ol><br>  En este art√≠culo, seguimos llam√°ndolos <code>shapes</code> . <br><br>  <b>Cadenas de transici√≥n y √°rboles.</b> <br><br>  ¬øQu√© sucede si tiene un objeto de cierta forma, pero le agrega una nueva propiedad?  ¬øC√≥mo define el motor JavaScript un nuevo formulario? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = {}; object.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; object.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Los formularios crean lo que se llaman cadenas de transici√≥n en el motor de JavaScript.  Aqu√≠ hay un ejemplo: <br><br><img src="https://habrastorage.org/webt/tm/tz/np/tmtznpiuyzkz9vpxqe6byhw2x-k.jpeg"><br><br>  Un objeto inicialmente no tiene propiedades; corresponde a una forma vac√≠a.  La siguiente expresi√≥n agrega la propiedad <code>'x'</code> con valor 5 a este objeto, luego el motor pasa a la forma que contiene la propiedad <code>'x'</code> y el valor 5 se agrega a JSObject en el primer desplazamiento 0. La siguiente l√≠nea agrega la propiedad <code>'y'</code> , luego el motor pasa a la siguiente un formulario que ya contiene <code>'x'</code> e <code>'y'</code> , y tambi√©n agrega el valor 6 a JSObject en el desplazamiento 1. <br><blockquote>  <b>Nota</b> : La secuencia en la que se agregan las propiedades afecta la forma.  Por ejemplo, {x: 4, y: 5} dar√° como resultado una forma diferente a {y: 5, x: 4}. <br></blockquote>  Ni siquiera necesitamos almacenar la tabla de propiedades completa para cada formulario.  En cambio, cada formulario necesita conocer solo una nueva propiedad que est√°n tratando de incluir en ella.  Por ejemplo, en este caso, no necesitamos almacenar informaci√≥n sobre 'x' en la √∫ltima forma, ya que se puede encontrar antes en la cadena.  Para que esto funcione, el formulario se combina con su formulario anterior. <br><br><img src="https://habrastorage.org/webt/ks/ou/pv/ksoupve8bep3jsp0v7u2ahyv9jg.jpeg"><br><br>  Si escribe <code>ox</code> en su c√≥digo JavaScript, JavaScript buscar√° la propiedad <code>'x'</code> largo de la cadena de transici√≥n hasta que detecte un formulario que ya tenga la propiedad <code>'x'</code> . <br><br>  Pero, ¬øqu√© sucede si es imposible crear una cadena de transici√≥n?  Por ejemplo, ¬øqu√© sucede si tiene dos objetos vac√≠os y les agrega diferentes propiedades? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; object2.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  En este caso, aparece una rama y, en lugar de la cadena de transici√≥n, obtenemos un √°rbol de transici√≥n: <br><br><img src="https://habrastorage.org/webt/bc/ga/ax/bcgaaxeskfqwqt8geu_pxmqwdou.jpeg"><br><br>  Creamos un objeto vac√≠o <code>a</code> y le agregamos la propiedad <code>'x'</code> .  Como resultado, tenemos un <code>JSObject</code> contiene un solo valor y dos formularios: vac√≠o y un formulario con una sola propiedad <code>'x'</code> . <br><br>  El segundo ejemplo comienza con el hecho de que tenemos un objeto vac√≠o <code>b</code> , pero luego agregamos otra propiedad <code>'y'</code> .  Como resultado, aqu√≠ obtenemos dos cadenas de formas, pero al final obtenemos tres cadenas. <br><br>  ¬øSignifica esto que siempre comenzamos con un formulario vac√≠o?  No necesariamente  Los motores utilizan alguna optimizaci√≥n de literales de objetos, que ya contienen propiedades.  Digamos que agregamos x, comenzando con un literal de objeto vac√≠o, o tenemos un literal de objeto que ya contiene <code>x</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> };</code> </pre> <br>  En el primer ejemplo, comenzamos con un formulario vac√≠o y vamos a una cadena que tambi√©n contiene <code>x</code> , tal como vimos anteriormente. <br><br>  En el caso de <code>object2</code> tiene sentido crear directamente objetos que ya tengan x desde el principio, en lugar de comenzar con un objeto vac√≠o y una transici√≥n. <br><br><img src="https://habrastorage.org/webt/qv/_0/l-/qv_0l-f5eekqflfmto7lfd-awwq.jpeg"><br><br>  El literal de un objeto que contiene la propiedad <code>'x'</code> comienza con un formulario que contiene <code>'x'</code> desde el principio, y el formulario vac√≠o se omite efectivamente.  Esto es (al menos) lo que hacen V8 y SpiderMonkey.  La optimizaci√≥n acorta la cadena de transici√≥n y hace que sea m√°s conveniente ensamblar objetos a partir de literales. <br><br>  La publicaci√≥n del blog de Benedict sobre el sorprendente polimorfismo de las aplicaciones en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">React</a> habla sobre c√≥mo tales sutilezas pueden afectar el rendimiento. <br><br>  Adem√°s, ver√° un ejemplo de puntos de un objeto tridimensional con las propiedades <code>'x'</code> , <code>'y'</code> , <code>'z'</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = {}; point.x = <span class="hljs-number"><span class="hljs-number">4</span></span>; point.y = <span class="hljs-number"><span class="hljs-number">5</span></span>; point.z = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Como entendi√≥ anteriormente, creamos un objeto con tres formas en la memoria (sin contar la forma vac√≠a).  Para acceder a la propiedad <code>'x'</code> de este objeto, por ejemplo, si escribe <code>point.x</code> en su programa, el motor de JavaScript debe seguir una lista vinculada: comenzando desde el formulario en la parte inferior y luego gradualmente avanzando hacia el formulario que tiene <code>'x'</code> en lo m√°s alto. <br><br><img src="https://habrastorage.org/webt/tv/rn/mp/tvrnmp1s5p25dseplockgifr6x0.jpeg"><br><br>  Resulta muy lento, especialmente si lo haces con frecuencia y con muchas propiedades del objeto.  El tiempo de residencia de una propiedad es <code>O(n)</code> , es decir, es una funci√≥n lineal que se correlaciona con el n√∫mero de propiedades del objeto.  Para acelerar las b√∫squedas de propiedades, los motores de JavaScript agregan una estructura de datos ShapeTable.  ShapeTable es un diccionario donde las claves se asignan de cierta manera con los formularios y producen la propiedad deseada. <br><br><img src="https://habrastorage.org/webt/y8/vh/40/y8vh40rwdlx99jdv-rpumbe1u3u.jpeg"><br><br>  Espera un segundo, ahora volvemos a la b√∫squeda del diccionario ... ¬°Esto es exactamente con lo que comenzamos cuando ponemos formularios en primer lugar!  Entonces, ¬øpor qu√© nos importan los formularios? <br>  El hecho es que los formularios contribuyen a otra optimizaci√≥n llamada <i>cach√©s en l√≠nea.</i> <br><br>  Hablaremos sobre el concepto de cach√©s en l√≠nea o circuitos integrados en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segunda parte del</a> art√≠culo, y ahora queremos invitarlo a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seminario web abierto gratuito</a> , que ser√° realizado por el famoso analista de virus y maestro a tiempo parcial, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alexander Kolesnikov</a> , el 9 de abril. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446446/">https://habr.com/ru/post/446446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446434/index.html">Escala de Zimbra Collaboration Suite</a></li>
<li><a href="../446436/index.html">C√≥mo generar hip√≥tesis sobre las necesidades de los consumidores potenciales de su producto futuro</a></li>
<li><a href="../446438/index.html">Nuestra experiencia de creaci√≥n de API de puerta de enlace</a></li>
<li><a href="../446440/index.html">El libro Reacciona r√°pido. Aplicaciones web en React, JSX, Redux y GraphQL ¬ª</a></li>
<li><a href="../446444/index.html">De Skype a WebRTC: c√≥mo organizamos la comunicaci√≥n de video web</a></li>
<li><a href="../446448/index.html">5 reglas b√°sicas para realizar entrevistas problem√°ticas para identificar las necesidades del consumidor</a></li>
<li><a href="../446452/index.html">Misi√≥n lunar "Bereshit": el 4 de abril de 2019, se complet√≥ la transici√≥n a la √≥rbita lunar, 7 d√≠as de vuelo por delante, 6 maniobras y 1 aterrizaje</a></li>
<li><a href="../446454/index.html">Desarrollo del servidor web de Golang: de f√°cil a complejo</a></li>
<li><a href="../446456/index.html">Sustituci√≥n de importaciones en la pr√°ctica. Parte 1. Opciones</a></li>
<li><a href="../446458/index.html">DRO universal basado en Arduino Nano - shDRO. Parte 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>