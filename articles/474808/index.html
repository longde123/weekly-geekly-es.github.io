<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🏫 👩🏾‍🎤 🚔 Lanzamiento de Rust 1.39.0: asíncrono / espera, atributos para parámetros de función, nuevas funciones constantes 👨🏼‍🎓 📯 🚆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El equipo de Rust se complace en anunciar el lanzamiento de una nueva versión, 1.39.0. Rust es un lenguaje de programación que permite a todos crear s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lanzamiento de Rust 1.39.0: asíncrono / espera, atributos para parámetros de función, nuevas funciones constantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474808/"><p>  El equipo de Rust se complace en anunciar el lanzamiento de una nueva versión, 1.39.0.  Rust es un lenguaje de programación que permite a todos crear software confiable y eficiente. </p><br><p> Si instaló la versión anterior de Rust usando <code>rustup</code> , para actualizar a la versión 1.39.0 solo necesita ejecutar el siguiente comando: </p><br><pre> <code class="plaintext hljs">$ rustup update stable</code> </pre> <br><p>  Si aún no ha instalado <code>rustup</code> , puede <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">instalarlo</a> desde la página correspondiente de nuestro sitio web, así como ver las <a href="">notas de lanzamiento detalladas</a> en GitHub. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1390">  Lo que se incluye en la versión estable 1.39.0 </h2><br><p>  Las innovaciones más significativas incluyen la <code>.await</code> <code>async</code> / <code>.await</code> , referencias compartidas a valores móviles en <code>match-guards</code> y los atributos de los parámetros de función.  Consulte las <a href="">notas detalladas de la versión</a> para obtener más información. </p><a name="habracut"></a><br><h3 id="s-await-zakoncheno-vstrechayte-async-fn">  Con <code>.await</code> terminado, conoce a <code>async fn</code> </h3><br><p>  Anteriormente en Rust 1.36.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anunciamos</a> la disponibilidad del rasgo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Future</code></a> .  Entonces notamos que: </p><br><blockquote>  Esperamos que esta innovación permita que las cajas populares, las bibliotecas y todo el ecosistema se preparen para la <code>.await</code> <code>async</code> / <code>.await</code> , que se planea estabilizar en el futuro cercano. </blockquote><p>  La promesa se da, la promesa se cumple.  Nos complace anunciar que la <code>.await</code> <code>async</code> / <code>.await</code> tan esperada, que nos permite definir funciones y bloques <code>async</code> ( <code>async</code> ) y esperar su ejecución ( <code>.await</code> ), ¡finalmente es estable! </p><br><p>  Una función asincrónica definida usando la sintaxis <code>async fn</code> (en lugar de la <code>fn</code> habitual) no hace nada excepto que cuando se llama, devuelve un objeto que implementa el rasgo <code>Future</code> .  Este objeto es un cálculo suspendido, que se puede completar con la sintaxis <code>.await</code> .  Además, <code>async fn</code> , <code>async { ... }</code> y <code>async move { ... }</code> actúan como cierres y pueden usarse para definir literales asíncronos. </p><br><p>  Puede leer más sobre el lanzamiento de <code>async</code> / <code>.await</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la publicación del blog Niko Matsakis</a> . </p><br><h3 id="razdelyaemye-ssylki-k-peremeschaemym-znacheniyam-v-match-guards">  Enlaces compartidos a valores de itinerancia en <code>match-guards</code> </h3><br><p>  Al hacer coincidir una imagen, una variable conocida como enlace se puede vincular de una de las siguientes maneras: </p><br><ul><li><p>  Por referencia, inmutable o mutable.  Esto se puede hacer explícitamente, por ejemplo, con la sintaxis <code>ref my_var</code> o <code>ref mut my_var</code> respectivamente.  Casi siempre, el modo de captura se mostrará automáticamente. </p><br></li><li><p>  Por valor: ya sea copiando (si el tipo de la variable enlazada implementa el rasgo <code>Copy</code> ) o transfiriéndolo <strong><em>a la propiedad</em></strong> . </p><br></li></ul><br><p>  Ahora está permitido usar variables de plantilla en las restricciones if de la plantilla, si la propiedad se transfiere a esta variable (es decir, la variable en la plantilla de enlaces por movimiento).  Anteriormente, se descartaría el siguiente código: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array: <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>]&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> array { nums <span class="hljs-comment"><span class="hljs-comment">// ---- `nums`    (by move). if nums.iter().sum::&lt;u8&gt;() == 10 // ^------ `.iter()`     `nums` =&gt; { drop(nums); // ----------- `nums`      } _ =&gt; unreachable!(), } }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">A partir de Rust 1.39.0</a> , el compilador aceptará el fragmento anterior sin advertencias ni errores.  Esperamos que esta innovación aumente la usabilidad de la expresión de <code>match</code> . </p><br><h3 id="atributy-dlya-parametrov-funkciy">  Atributos para parámetros de función </h3><br><p>  A partir de Rust 1.39.0, los atributos se pueden aplicar a parámetros de función, cierres y punteros de función.  Anteriormente, la función <code>len()</code> podía representarse de la siguiente manera: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[cfg(windows)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span></span>(slice: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { slice.len() } <span class="hljs-meta"><span class="hljs-meta">#[cfg(not(windows))]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span></span>(slice: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { slice.len() }</code> </pre> <br><p>  Pero Rust 1.39.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hace que escribir el</a> código anterior sea mucho más simple: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">#[cfg(windows)]</span></span> slice: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>], <span class="hljs-comment"><span class="hljs-comment">//        Windows. #[cfg(not(windows))] slice: &amp;[u8], //       . ) -&gt; usize { slice.len() }</span></span></code> </pre> <br><p>  Los atributos utilizables incluyen: </p><br><ol><li><p>  Compilación condicional: <code>cfg</code> y <code>cfg_attr</code> ; </p><br></li><li><p>  Gestión de cheques: <code>allow</code> , <code>warn</code> , <code>deny</code> y <code>forbid</code> ; </p><br></li><li><p>  Atributos auxiliares utilizados por macros de atributos de procedimiento para elementos de sintaxis. </p><br><p>  Esperamos que esta innovación ayude al ecosistema a escribir DSL basadas en macro más expresivas. </p><br></li></ol><br><h3 id="migracionnye-preduprezhdeniya-proverki-zaimstvovaniy-stanovyatsya-seryoznymi-oshibkami-v-rust-2018">  Las advertencias de migración de cheques de préstamo se convierten en errores graves en Rust 2018 </h3><br><p>  En la versión 1.35.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anunciamos</a> que el nuevo analizador de préstamos (NLL) llegó a los editores de Rust 2015 después de que se lanzó a los editores de Rust 2018 en la versión <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">1.31</a> . </p><br><p>  Como se indicó en la versión 1.35.0, el analizador de préstamos anterior fue diseñado con errores que permitían el uso inseguro de la memoria.  Estos errores se corrigieron utilizando un nuevo analizador que implementa NLL.  Dado que estas correcciones podrían romper el código de trabajo, el equipo de Rust decidió introducirlas gradualmente, verificando que el analizador anterior debería aceptar el código, que el nuevo analizador rechazaría.  Si es así, los errores se convertirán en advertencias. </p><br><p>  A partir de Rust 1.39.0, estas advertencias ahora son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">errores en la edición Rust 2018</a> . <br>  En la próxima versión de Rust 1.40.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta regla también se aplicará al código de revisión de Rust 2015</a> , que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eliminará por</a> completo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el antiguo analizador de préstamos</a> del compilador. </p><br><p>  Si se ve afectado por estos cambios, o desea saber más, consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicación del blog Niko Matsakis</a> . </p><br><h3 id="bolshe-konstantnyh-funkciy-v-standartnoy-biblioteke">  Funciones más constantes en la biblioteca estándar. </h3><br><p>  A partir de Rust 1.39.0, las siguientes funciones están marcadas como <code>const fn</code> ( <code>const fn</code> ): </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Vec::new</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>String::new</code></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>LinkedList::new</code></a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>str::len</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>[T]::len</code></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>str::as_bytes</code></a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>abs</code></a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>wrapping_abs</code></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>overflowing_abs</code></a> . </li></ul><br><h3 id="stabilizirovannye-funkcii-v-standartnoy-biblioteke">  Funciones estables en la biblioteca estándar. </h3><br><p>  Las siguientes funciones se han estabilizado en Rust 1.39.0: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Pin::into_inner</code></a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Instant::checked_duration_since</code></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Instant::saturating_duration_since</code></a> . </li></ul><br><h3 id="drugie-izmeneniya">  Otros cambios </h3><br><p>  <a href="">La sintaxis</a> , el <a href="">administrador de paquetes de carga</a> y el <a href="">analizador Clippy</a> también <a href="">han</a> sufrido algunos cambios. </p><br><p>  Lea <a href="">las notas de compatibilidad</a> para ver si estos cambios le afectan. </p><br><h2 id="uchastniki-1390">  Miembros 1.39.0 </h2><br><p>  Mucha gente se unió para crear Rust 1.39.0.  No podríamos haber hecho esto sin todos ustedes, ¡ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gracias</a> ! </p><br><h2 id="ot-perevodchikov">  De traductores </h2><br><p>  Con cualquier pregunta sobre el idioma Rust, podrán ayudarlo en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chat de Telegram</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ruso</a> o en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chat</a> similar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para los recién llegados</a> . </p><br><p>  Este artículo fue traducido conjuntamente por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">andreevlex</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">blandger</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">funkill</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Hippolot</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/474808/">https://habr.com/ru/post/474808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../474792/index.html">6-8 de diciembre - Rosbank Tech.Madness Hackathon</a></li>
<li><a href="../474796/index.html">¿Qué es el Internet de las cosas y cómo ayudará a las empresas a ganar más?</a></li>
<li><a href="../474800/index.html">Rendimiento en .NET Core</a></li>
<li><a href="../474804/index.html">El progreso tecnológico ruso en el deporte: interfaces neuronales, cámaras IP, CRM deportivo y BigData desde un automóvil de carreras</a></li>
<li><a href="../474806/index.html">UDP Flood de Google o cómo no privar a todo Youtube</a></li>
<li><a href="../474810/index.html">Cómo funciona la criptografía de curva elíptica en TLS 1.3</a></li>
<li><a href="../474812/index.html">Shader no es mágico. Escribiendo sombreadores en Unity. Sombreadores de vértices</a></li>
<li><a href="../474814/index.html">Antigüedades: el mensajero de la decadencia o la obsolescencia no planificada</a></li>
<li><a href="../474816/index.html">Proyectos de mascotas - vida pequeña</a></li>
<li><a href="../474818/index.html">¿Hay números aleatorios en CSS?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>