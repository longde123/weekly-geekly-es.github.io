<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîî ü§æüèø üë©üèæ‚Äçü§ù‚Äçüë©üèΩ MVCC dalam PostgreSQL-3. Versi baris üêÑ ü§Ωüèº üéóÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yah, kita sudah membahas isolasi dan membuat penyimpangan tentang struktur data tingkat rendah . Dan kami akhirnya mencapai hal yang paling menarik, y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dalam PostgreSQL-3. Versi baris</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/477648/">  Yah, kita sudah membahas <a href="https://habr.com/ru/company/postgrespro/blog/467437/">isolasi</a> dan membuat penyimpangan tentang <a href="https://habr.com/ru/company/postgrespro/blog/469087/">struktur data tingkat rendah</a> .  Dan kami akhirnya mencapai hal yang paling menarik, yaitu, versi baris (tupel). <br><br><h1>  Header Tuple </h1><br>  Seperti yang telah disebutkan, beberapa versi dari setiap baris dapat secara bersamaan tersedia di database.  Dan kita perlu entah bagaimana membedakan satu versi dari yang lain.  Untuk tujuan ini, setiap versi diberi label dengan "waktu" ( <code>xmin</code> ) dan "waktu" ( <code>xmax</code> ) yang efektif.  Tanda kutip menunjukkan bahwa penghitung kenaikan khusus digunakan daripada waktu itu sendiri.  Dan penghitung ini adalah <em>pengidentifikasi transaksi</em> . <br><br>  (Seperti biasa, pada kenyataannya ini lebih rumit: ID transaksi tidak selalu dapat meningkat karena kedalaman bit counter yang terbatas. Tetapi kami akan mengeksplorasi lebih detail tentang ini ketika diskusi kami mencapai titik beku.) <br><a name="habracut"></a><br>  Ketika sebuah baris dibuat, nilai <code>xmin</code> ditetapkan sama dengan ID transaksi yang melakukan perintah INSERT, sementara <code>xmax</code> tidak diisi. <br><br>  Ketika satu baris dihapus, nilai <code>xmax</code> dari versi saat ini diberi label dengan ID transaksi yang dilakukan HAPUS. <br><br>  Perintah UPDATE sebenarnya melakukan dua operasi berikutnya: HAPUS dan INSERT.  Di versi baris saat ini, <code>xmax</code> diset sama dengan ID transaksi yang melakukan UPDATE.  Kemudian versi baru dari baris yang sama dibuat, di mana nilai <code>xmin</code> sama dengan <code>xmax</code> dari versi sebelumnya. <br><br>  Bidang <code>xmin</code> dan <code>xmax</code> termasuk dalam header versi baris.  Selain bidang-bidang ini, tupel header berisi yang lain, seperti: <br><br><ul><li>  <code>infomask</code> - beberapa bit yang menentukan sifat-sifat tuple yang diberikan.  Ada beberapa dari mereka, dan kami akan membahasnya setiap waktu. </li><li>  <code>ctid</code> - referensi ke versi baris berikutnya yang sama, lebih baru.  <code>ctid</code> dari referensi versi baris terbaru, terbaru, dan sangat versi itu.  Angka tersebut dalam bentuk <code>(x,y)</code> , di mana <code>x</code> adalah nomor halaman dan <code>y</code> adalah nomor urut pointer dalam array. </li><li>  Bitmap NULLs, yang menandai kolom-kolom dari versi tertentu yang berisi NULL.  NULL bukan nilai reguler tipe data, dan oleh karena itu, kami harus menyimpan karakteristik ini secara terpisah. </li></ul><br>  Hasilnya, tajuknya terlihat cukup besar: minimal 23 byte per setiap tuple, tetapi biasanya lebih besar karena bitmap NULLs.  Jika tabel ‚Äúsempit‚Äù (artinya, berisi beberapa kolom), byte overhead dapat menempati lebih banyak ruang daripada informasi yang bermanfaat. <br><br><h1>  Masukkan </h1><br>  Mari kita lihat lebih detail bagaimana operasi pada baris dilakukan pada level rendah, dan kita mulai dengan insert. <br><br>  Untuk bereksperimen, kami akan membuat tabel baru dengan dua kolom dan indeks pada salah satunya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre><br>  Kami memulai transaksi untuk memasukkan baris. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  Ini adalah ID transaksi kami saat ini: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  Mari kita melihat isi halaman.  Fungsi <code>heap_page_items</code> dari ekstensi "pageinspect" memungkinkan kami untuk mendapatkan informasi tentang pointer dan versi baris: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  Perhatikan bahwa kata "heap" di PostgreSQL menunjukkan tabel.  Ini adalah satu lagi penggunaan istilah yang aneh: heap adalah <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">struktur data yang</a> diketahui, yang tidak ada hubungannya dengan tabel.  Kata ini digunakan di sini dalam arti bahwa "semuanya menumpuk", tidak seperti dalam indeks yang diurutkan. <br><br>  Fungsi ini menunjukkan data "apa adanya", dalam format yang sulit dipahami.  Untuk mengklarifikasi hal-hal tersebut, kami hanya menyisakan sebagian informasi dan menafsirkannya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  Kami melakukan yang berikut: <br><br><ul><li>  Menambahkan nol ke nomor penunjuk agar terlihat seperti <code>t_ctid</code> : (nomor halaman, nomor penunjuk). </li><li>  Menafsirkan status pointer <code>lp_flags</code> .  Ini "normal" di sini, yang berarti bahwa penunjuk sebenarnya mereferensikan versi baris.  Kami akan membahas nilai-nilai lain nanti. </li><li>  Dari semua bit informasi, kami memilih hanya dua pasangan sejauh ini.  bit <code>xmin_aborted</code> dan <code>xmin_aborted</code> menunjukkan apakah transaksi dengan ID <code>xmin</code> dilakukan (dibatalkan).  Sepasang bit serupa berkaitan dengan transaksi dengan ID <code>xmax</code> . </li></ul><br>  Apa yang kita amati?  Ketika sebuah baris dimasukkan, pada halaman tabel akan muncul sebuah pointer yang memiliki nomor 1 dan merujuk pada versi pertama dan satu-satunya dari baris tersebut. <br><br>  Bidang <code>xmin</code> dalam tupel diisi dengan ID transaksi saat ini.  Karena transaksi masih aktif, bit <code>xmin_aborted</code> dan <code>xmin_aborted</code> tidak disetel. <br><br>  Bidang <code>ctid</code> dari versi baris merujuk ke baris yang sama.  Itu berarti tidak ada versi yang lebih baru tersedia. <br><br>  Kolom <code>xmax</code> diisi dengan angka konvensional 0 karena tupel tidak dihapus, yaitu mutakhir.  Transaksi akan mengabaikan nomor ini karena set bit <code>xmax_aborted</code> . <br><br>  Mari kita bergerak satu langkah lagi untuk meningkatkan keterbacaan dengan menambahkan bit informasi ke ID transaksi.  Dan mari kita buat fungsinya karena kita akan membutuhkan kueri lebih dari sekali: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Apa yang terjadi di header versi baris itu jauh lebih jelas dalam formulir ini: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Kita bisa mendapatkan informasi yang serupa, tetapi jauh lebih tidak detail, dari tabel itu sendiri dengan menggunakan <code>xmin</code> dan <code>xmax</code> pseudo-kolom: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1>  Berkomitmen </h1><br>  Ketika transaksi berhasil, statusnya harus diingat, yaitu, transaksi harus ditandai sebagai komitmen.  Untuk tujuan ini, struktur XACT digunakan.  (Sebelum versi 10 itu disebut CLOG (commit log), dan Anda masih cenderung menemukan nama ini.) <br><br>  XACT bukan tabel katalog sistem, tetapi file dalam direktori PGDATA / pg_xact.  Dua bit dialokasikan dalam file-file ini untuk setiap transaksi - "berkomitmen" dan "dibatalkan" - persis dengan cara yang sama seperti pada tuple header.  Informasi ini tersebar di beberapa file hanya untuk kenyamanan;  kita akan kembali ke ini ketika kita membahas pembekuan.  PostgreSQL berfungsi dengan file-file ini halaman demi halaman, seperti yang lainnya. <br><br>  Jadi, ketika transaksi dilakukan, bit "berkomitmen" diatur untuk transaksi ini di XACT.  Dan inilah yang terjadi ketika transaksi dilakukan (meskipun kami belum menyebutkan log write-ahead). <br><br>  Ketika beberapa transaksi lain mengakses halaman tabel yang baru saja kita lihat, yang pertama harus menjawab beberapa pertanyaan. <br><br><ol><li>  Apakah transaksi <code>xmin</code> selesai?  Jika tidak, tupel yang dibuat tidak boleh terlihat. <br>  Ini diperiksa dengan melihat melalui struktur lain, yang terletak di memori bersama contoh dan disebut ProcArray.  Struktur ini menyimpan daftar semua proses aktif, bersama dengan ID transaksi saat ini (aktif) untuk masing-masing. </li><li>  Jika transaksi selesai, apakah itu dilakukan atau dibatalkan?  Jika diputar kembali, tuple juga tidak boleh terlihat. <br>  Inilah yang dibutuhkan XACT.  Tetapi mahal untuk memeriksa XACT setiap kali, meskipun halaman terakhir XACT disimpan dalam buffer dalam memori bersama.  Oleh karena itu, setelah menemukan, status transaksi ditulis ke <code>xmin_committed</code> dan <code>xmin_aborted</code> bit dari tuple.  Jika salah satu dari bit-bit ini ditetapkan, status transaksi diperlakukan sebagai diketahui dan transaksi berikutnya tidak perlu memeriksa XACT. </li></ol><br>  Mengapa transaksi yang melakukan penyisipan tidak mengatur bit-bit ini?  Ketika penyisipan dilakukan, transaksi belum mengetahui apakah itu akan berhasil diselesaikan.  Dan pada saat komit, sudah tidak jelas baris mana dan di mana halaman diubah.  Mungkin ada banyak halaman seperti itu, dan tidak praktis untuk melacaknya.  Selain itu, beberapa halaman dapat diusir ke disk dari cache buffer;  membacanya lagi untuk mengubah bit berarti perlambatan signifikan dari komit. <br><br>  Sisi kebalikan dari penghematan biaya adalah bahwa setelah pembaruan, transaksi apa pun (bahkan yang melakukan SELECT) dapat mulai mengubah halaman data dalam cache buffer. <br><br>  Jadi, kami melakukan perubahan. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Tidak ada yang berubah di halaman (tapi kami tahu bahwa status transaksi sudah ditulis ke XACT): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Sekarang transaksi yang pertama kali mengakses halaman harus menentukan status transaksi <code>xmin</code> dan akan menuliskannya ke bit informasi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1>  Hapus </h1><br>  Ketika sebuah baris dihapus, ID dari transaksi penghapusan saat ini ditulis ke bidang <code>xmax_aborted</code> dari versi terbaru dan bit <code>xmax_aborted</code> -reset. <br><br>  Perhatikan bahwa nilai <code>xmax</code> terkait dengan transaksi aktif berfungsi sebagai kunci baris.  Jika transaksi lain akan memperbarui atau menghapus baris ini, itu harus menunggu sampai transaksi <code>xmax</code> selesai.  Kita akan membicarakan tentang kunci lebih detail nanti.  Pada titik ini, hanya perhatikan bahwa jumlah kunci baris tidak terbatas sama sekali.  Mereka tidak menempati memori, dan kinerja sistem tidak terpengaruh oleh angka itu.  Namun, transaksi jangka panjang memiliki kelemahan lain, yang juga akan dibahas nanti. <br><br>  Mari kita hapus satu baris. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  Kami melihat bahwa ID transaksi ditulis ke bidang <code>xmax</code> , tetapi bit informasi tidak disetel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1>  Batalkan </h1><br>  Batalkan transaksi berfungsi sama dengan komit, kecuali bahwa bit "dibatalkan" diatur dalam XACT.  Batalkan dilakukan secepat komit.  Meskipun perintah itu disebut ROLLBACK, perubahan tidak dibatalkan: segala sesuatu yang sudah diubah oleh transaksi, tetap tidak tersentuh. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  Saat mengakses halaman, status akan diperiksa dan bit petunjuk <code>xmax_aborted</code> akan ditetapkan.  Meskipun nomor <code>xmax</code> itu sendiri akan tetap di halaman, itu tidak akan dilihat. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1>  Perbarui </h1><br>  Pembaruan berfungsi seolah-olah versi saat ini dihapus pertama dan kemudian yang baru dimasukkan. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  Kueri mengembalikan satu baris (versi baru): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  Tetapi kita dapat melihat kedua versi di halaman: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Versi yang dihapus ditandai dengan ID transaksi saat ini di bidang <code>xmax</code> .  Selain itu, nilai ini telah menimpa yang lama sejak transaksi sebelumnya dibatalkan.  Dan bit <code>xmax_aborted</code> -reset karena status transaksi saat ini belum diketahui. <br><br>  Versi pertama dari baris sekarang merujuk yang kedua, sebagai yang lebih baru. <br><br>  Halaman indeks sekarang berisi pointer kedua dan baris kedua, yang mereferensikan versi kedua di halaman tabel. <br><br>  Cara yang sama seperti untuk menghapus, nilai <code>xmax</code> di versi pertama menunjukkan bahwa baris dikunci. <br><br>  Terakhir, kami melakukan transaksi. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Indeks </h1><br>  Kami hanya berbicara tentang halaman tabel sejauh ini.  Tetapi apa yang terjadi di dalam indeks? <br><br>  Informasi dalam halaman indeks sangat tergantung pada jenis indeks spesifik.  Selain itu, bahkan satu jenis indeks dapat memiliki berbagai jenis halaman.  Sebagai contoh: B-tree memiliki halaman metadata dan halaman "normal". <br><br>  Namun demikian, halaman indeks biasanya memiliki array pointer ke baris dan baris sendiri (seperti halaman tabel).  Selain itu, beberapa ruang di akhir halaman dialokasikan untuk data khusus. <br><br>  Baris dalam indeks juga dapat memiliki struktur yang berbeda tergantung pada tipe indeks.  Sebagai contoh: di pohon-B, baris yang berkaitan dengan halaman daun berisi nilai kunci pengindeksan dan referensi ( <code>ctid</code> ) ke baris tabel yang sesuai.  Secara umum, indeks dapat disusun dengan cara yang sangat berbeda. <br><br>  Poin utamanya adalah bahwa dalam indeks jenis apa pun tidak ada <em>versi</em> baris.  Atau kita dapat menganggap setiap baris hanya diwakili oleh satu versi.  Dengan kata lain, tajuk baris indeks tidak berisi bidang <code>xmin</code> dan <code>xmax</code> .  Untuk saat ini kita dapat mengasumsikan bahwa referensi dari titik indeks ke semua versi baris tabel.  Jadi untuk mengetahui versi baris mana yang terlihat oleh suatu transaksi, PostgreSQL perlu melihat ke dalam tabel.  (Seperti biasa, ini bukan keseluruhan cerita. Terkadang peta visibilitas memungkinkan untuk mengoptimalkan proses, tetapi kita akan membahas ini nanti.) <br><br>  Di sini, di halaman indeks, kami menemukan petunjuk untuk kedua versi: yang terbaru dan yang sebelumnya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1>  Transaksi virtual </h1><br>  Dalam praktiknya, PostgreSQL mengambil keuntungan dari optimasi yang memungkinkan untuk "hemat" mengeluarkan ID transaksi. <br><br>  Jika suatu transaksi hanya membaca data, itu sama sekali tidak mempengaruhi visibilitas tuple.  Oleh karena itu, pertama proses backend memberikan ID virtual (virtual xid) untuk transaksi.  ID ini terdiri dari pengidentifikasi proses dan nomor urut. <br><br>  Penugasan ID virtual ini tidak memerlukan sinkronisasi antara semua proses dan karenanya dilakukan dengan sangat cepat.  Kita akan mempelajari alasan lain menggunakan ID virtual ketika kita membahas pembekuan. <br><br>  Snapshots data tidak mempertimbangkan ID virtual akun sama sekali. <br><br>  Pada titik waktu yang berbeda, sistem dapat melakukan transaksi virtual dengan ID yang sudah digunakan, dan ini tidak masalah.  Tetapi ID ini tidak dapat ditulis ke halaman data karena ketika halaman diakses lain kali, ID tersebut dapat menjadi tidak berarti. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  Tetapi jika suatu transaksi mulai mengubah data, ia menerima ID transaksi yang benar dan unik. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Subtransaksi </h1><br><h2>  Savepoints </h2><br>  Dalam SQL, <em>savepoints</em> didefinisikan, yang memungkinkan memutar kembali beberapa operasi transaksi tanpa aborsi yang lengkap.  Tetapi ini tidak sesuai dengan model di atas karena status transaksi adalah satu untuk semua perubahan dan tidak ada data yang secara fisik dibatalkan. <br><br>  Untuk mengimplementasikan fungsi ini, transaksi dengan savepoint dibagi menjadi beberapa <em>subtransaksi</em> terpisah yang statusnya dapat dikelola secara terpisah. <br><br>  Subtrabaksi memiliki ID sendiri (lebih besar dari ID transaksi utama).  Status subtransaksi ditulis ke XACT dengan cara yang biasa, tetapi status akhir tergantung pada status transaksi utama: jika digulirkan kembali, semua transaksi juga digulung kembali. <br><br>  Informasi tentang subtransaksi bersarang disimpan dalam file-file dari direktori PGDATA / pg_subtrans.  File-file ini diakses melalui buffer dalam memori bersama instance, yang disusun dengan cara yang sama seperti buffer XACT. <br><br>  Jangan bingung subtransaksi dengan transaksi otonom.  Transaksi otonom sama sekali tidak bergantung satu sama lain, sementara subtransaksi memang bergantung.  Tidak ada transaksi mandiri dalam PostgreSQL biasa, yang, mungkin, menjadi lebih baik: mereka sebenarnya sangat jarang dibutuhkan, dan ketersediaannya dalam DBMS lain mengundang penyalahgunaan, yang diderita semua orang. <br><br>  Mari kita membersihkan tabel, memulai transaksi dan memasukkan baris: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Sekarang kita membuat savepoint dan memasukkan baris lain. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  Perhatikan bahwa fungsi <code>txid_current</code> mengembalikan ID transaksi utama daripada subtransaksi. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Mari kembali ke savepoint dan masukkan baris ketiga. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Di halaman, kami terus melihat baris yang ditambahkan oleh subtransaksi gulung belakang. <br><br>  Melakukan perubahan. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Jelas terlihat sekarang bahwa setiap subtransaksi memiliki statusnya sendiri. <br><br>  Perhatikan bahwa SQL tidak mengizinkan penggunaan subtransaksi secara eksplisit, artinya, Anda tidak dapat memulai transaksi baru sebelum menyelesaikan transaksi saat ini.  Teknik ini terlibat secara implisit ketika savepoint digunakan dan juga ketika menangani pengecualian PL / pgSQL, serta dalam beberapa situasi lain yang lebih eksotis. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2>  Kesalahan dan kekompakan operasi </h2><br>  Apa yang terjadi jika kesalahan terjadi saat operasi sedang dilakukan?  Misalnya, seperti ini: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  Terjadi kesalahan.  Sekarang transaksi diperlakukan sebagai dibatalkan dan tidak ada operasi yang diizinkan di dalamnya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  Dan bahkan jika kita mencoba melakukan perubahan, PostgreSQL akan melaporkan rollback: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  Mengapa tidak mungkin melanjutkan eksekusi transaksi setelah gagal?  Masalahnya adalah bahwa kesalahan dapat terjadi sehingga kita akan mendapatkan akses ke bagian dari perubahan, yaitu, atomicity akan rusak tidak hanya untuk transaksi, tetapi bahkan untuk satu operator.  Misalnya, dalam contoh kami, operator dapat memperbarui satu baris sebelum kesalahan terjadi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  Perlu dicatat bahwa psql memiliki mode yang memungkinkan melanjutkan transaksi setelah kegagalan, seolah-olah efek dari operator yang salah dibatalkan. <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Sangat mudah untuk mengetahui bahwa dalam mode ini, psql benar-benar menetapkan savepoint implisit sebelum setiap perintah dan memulai rollback untuk itu jika terjadi kegagalan.  Mode ini tidak digunakan secara default karena membangun savepoint (bahkan tanpa rollback) memerlukan overhead yang signifikan. <br><br>  <a href="https://habr.com/ru/company/postgrespro/blog/479512/">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477648/">https://habr.com/ru/post/id477648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477634/index.html">Layanan microser dan struktur organisasi. Apa jenis tim yang akan memastikan kesuksesan?</a></li>
<li><a href="../id477638/index.html">Dibeli! = Milik Anda: John Deere merampas hak petani untuk memperbaiki traktor mereka sendiri</a></li>
<li><a href="../id477642/index.html">Visi mesin (radio) melihat melalui dinding</a></li>
<li><a href="../id477644/index.html">Mengembalikan UNIX v0 ke PDP-7: Detail Backroom</a></li>
<li><a href="../id477646/index.html">Matematikawan memotong bentuk untuk mencari bagian persamaan</a></li>
<li><a href="../id477650/index.html">Enkripsi lalu lintas TLS menurut algoritma GOST-2012 dengan Stunnel</a></li>
<li><a href="../id477654/index.html">Mencoba instans operator yang ditingkatkan di Jawa 14</a></li>
<li><a href="../id477656/index.html">Jadi tetap saja, mengapa Anda perlu membuatnya?</a></li>
<li><a href="../id477658/index.html">Active Restore: dapatkah pemulihan bencana lebih cepat? Jauh lebih cepat?</a></li>
<li><a href="../id477662/index.html">Akses ke Redd Ban di Jembatan FTDI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>