<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìÄ üóûÔ∏è üë®üèø‚Äç‚öïÔ∏è Shader bukanlah sihir. Menulis shader di Unity. Vertex Shaders üêÜ üê™ üòÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Nama saya Grigory Dyadichenko, dan saya adalah pendiri dan CTO dari Foxsys Studios. Hari ini kita akan berbicara tentang vertex shader....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shader bukanlah sihir. Menulis shader di Unity. Vertex Shaders</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474812/"> Halo semuanya!  Nama saya Grigory Dyadichenko, dan saya adalah pendiri dan CTO dari Foxsys Studios.  Hari ini kita akan berbicara tentang vertex shader.  Artikel ini akan memeriksa praktik dari sudut pandang Unity, contoh yang sangat sederhana, serta banyak tautan untuk mempelajari informasi tentang shader di Unity.  Jika Anda pandai menulis shader, maka Anda tidak akan menemukan sesuatu yang baru untuk diri sendiri.  Siapa pun yang ingin mulai menulis shader di Unity, selamat datang di kucing. <br><br><img src="https://habrastorage.org/webt/zr/9n/wy/zr9nwyvbjnky73iqvvuvvzxpyjs.jpeg"><br><a name="habracut"></a><br><h3>  Sedikit teori </h3><br><br>  Untuk pemahaman yang lebih baik tentang proses shader, mari kita lihat sedikit teori.  Vertex shader atau vertex shader adalah tahap yang dapat diprogram dari shader yang bekerja dengan masing-masing vertex.  Vertex pada gilirannya menyimpan berbagai atribut yang diproses oleh bagian shader ini untuk mendapatkan atribut yang dikonversi pada output. <br><br><h3>  Contoh di mana vertex shader digunakan </h3><br><br><img src="https://habrastorage.org/webt/fk/ry/kc/fkrykcsixvzaihfaa4g6jajebk4.jpeg"><br><br>  <b>Deformasi objek</b> - gelombang realistis, efek riak dari hujan, deformasi ketika peluru mengenai, semua ini dapat dilakukan dengan vertex shaders, dan itu akan terlihat lebih realistis daripada hal yang sama yang dilakukan melalui Bump Mapping di bagian fragmen shader.  Karena ini adalah perubahan geometri.  Shaders Level 3.0 pada subjek ini memiliki teknik yang disebut Pemetaan Penempatan, karena mereka sekarang memiliki akses ke tekstur di bagian sudut shader. <br><br><img src="https://habrastorage.org/webt/8e/tb/uu/8etbuufscvxpmvx3acs8irusgag.jpeg"><br><br>  <b>Animasi objek.</b>  Permainan terlihat lebih hidup dan menarik ketika tanaman bereaksi terhadap karakter atau pohon bergoyang tertiup angin.  Untuk ini, vertex shader juga digunakan. <br><br><img src="https://habrastorage.org/webt/cu/ov/vk/cuovvkcufzn0jn0351xjw9bzfso.jpeg"><br><br>  <b>Pencahayaan kartun atau bergaya.</b>  Dalam banyak permainan, dari sudut pandang gaya, bukan pencahayaan yang terlihat jauh lebih menarik, tetapi gaya.  Pada saat yang sama, tidak masuk akal untuk menghitung apa pun di bagian fragmen. <br><br><img src="https://habrastorage.org/webt/m1/8a/km/m18akmnn364xlwyrh_0r5pb_zjc.png"><br><br>  <b>Menguliti.</b>  Pada saat tertentu di mesin game masalah ini diselesaikan, tetapi bagaimanapun, berguna untuk memahami vertex shader untuk memahami cara kerjanya. <br><br><h3>  Contoh sederhana bekerja dengan vertex </h3><br><img src="https://habrastorage.org/webt/ra/7v/m-/ra7vm-kgn__gsmaeg6xg7aud4ey.jpeg"><br><br>  Saya tidak ingin itu terjadi, seperti dalam pelajaran lama tentang cara menggambar burung hantu, jadi mari kita secara bertahap.  Buat shader permukaan standar.  Ini dapat dilakukan dengan tombol kanan mouse di Project View atau di panel atas pada tab Assets.  Buat-&gt; Shader-&gt; Standard Surface Shader. <br><br>  Dan kami mendapatkan standar yang kosong. <br><br><div class="spoiler">  <b class="spoiler_title">Permukaan shader</b> <div class="spoiler_text"><code>Shader "Custom/SimpleVertexExtrusionShader" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> _MainTex ("Albedo (RGB)", 2D) = "white" {} <br> _Glossiness ("Smoothness", Range(0,1)) = 0.5 <br> _Metallic ("Metallic", Range(0,1)) = 0.0 <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> // Physically based Standard lighting model, and enable shadows on all light types <br> #pragma surface surf Standard fullforwardshadows <br> <br> // Use shader model 3.0 target, to get nicer looking lighting <br> #pragma target 3.0 <br> <br> sampler2D _MainTex; <br> <br> struct Input <br> { <br> float2 uv_MainTex; <br> }; <br> <br> half _Glossiness; <br> half _Metallic; <br> fixed4 _Color; <br> <br> // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader. <br> // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing. <br> // #pragma instancing_options assumeuniformscaling <br> UNITY_INSTANCING_BUFFER_START(Props) <br> // put more per-instance properties here <br> UNITY_INSTANCING_BUFFER_END(Props) <br> <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> // Albedo comes from a texture tinted by color <br> fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; <br> o.Albedo = c.rgb; <br> // Metallic and smoothness come from slider variables <br> o.Metallic = _Metallic; <br> o.Smoothness = _Glossiness; <br> o.Alpha = ca; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> }</code> </div> </div><br>  Cara kerjanya dan secara umum kami akan menganalisisnya secara terperinci dalam artikel setelah praktik dasar, ditambah lagi kami akan memahaminya secara parsial selama implementasi shader.  Untuk saat ini, biarkan beberapa hal tetap seperti yang diberikan.  Singkatnya, tidak ada keajaiban (dalam hal bagaimana parameter dihubungkan, dll.) Hanya untuk kata kunci tertentu, unit menghasilkan kode untuk Anda, sehingga tidak menuliskannya dari awal.  Karena itu, proses ini tidak cukup jelas.  Anda dapat membaca lebih lanjut tentang shader permukaan dan propertinya di Unity di sini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.unity3d.com/Manual/SL-SurfaceShaders.html</a> <br><br>  Kami akan menghapus semua yang tidak perlu dari itu sehingga tidak mengganggu, karena pada saat tertentu tidak diperlukan.  Dan dapatkan shader pendek. <br><br><div class="spoiler">  <b class="spoiler_title">Shader sederhana</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleVertexExtrusionShader" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> <br> #pragma surface surf Standard fullforwardshadows <br> <br> #pragma target 3.0 <br> <br> struct Input <br> { <br> float4 color : COLOR; <br> }; <br> <br> fixed4 _Color; <br> <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> fixed4 c = _Color; <br> o.Albedo = c.rgb; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> } <br></code> <br></div></div><br><img src="https://habrastorage.org/webt/wg/po/iw/wgpoiwtso4uxmmipwrbvtnz1mek.jpeg"><br><br>  Hanya warna pada model dengan pencahayaan.  Dalam hal ini, Unity bertanggung jawab untuk menghitung pencahayaan. <br><br>  Pertama, tambahkan efek paling sederhana dari contoh Unity.  Ekstrusi itu normal, dan pada contohnya kita akan menganalisis cara kerjanya. <br><br>  Untuk melakukan ini, tambahkan <i>vertex: vert</i> modifier ke <i>#pragma surface surf Standard fullforwardshadows</i> line.  Jika kita melewatkan <i>appdata_full v</i> sebagai parameter untuk suatu fungsi, maka pada dasarnya fungsi ini adalah pengubah titik.  Pada intinya, ini adalah bagian dari shader vertex, yang dibuat oleh unit penghasil kode, yang melakukan pemrosesan awal simpul.  Juga di blok <i>Properties</i> , tambahkan bidang <i>_Amount yang</i> menerima nilai dari 0 hingga 1. Untuk menggunakan bidang <i>_Amount</i> di shader, kita juga perlu mendefinisikannya di sana.  Dalam fungsi ini, kita hanya akan beralih ke normal tergantung pada <i>_Amount</i> , di mana 0 adalah posisi vertex standar (nol shift), dan 1 adalah pergeseran tepat ke normal. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleVertexExtrusionShader</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleVertexExtrusionShader" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> _Amount ("Extrusion Amount", Range(0,1)) = 0.5 <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> <br> #pragma surface surf Standard fullforwardshadows vertex:vert <br> <br> #pragma target 3.0 <br> <br> struct Input <br> { <br> float4 color : COLOR; <br> }; <br> <br> fixed4 _Color; <br> float _Amount; <br> <br> void vert (inout appdata_full v) <br> { <br> v.vertex.xyz += v.normal * _Amount; <br> } <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> fixed4 c = _Color; <br> o.Albedo = c.rgb; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> } <br></code> <br></div></div><br>  Anda dapat melihat fitur penting dari shader.  Meskipun shader dieksekusi setiap frame, hasil yang diperoleh selama operasi shader tidak disimpan dalam mesh, tetapi digunakan hanya untuk rendering.  Oleh karena itu, tidak mungkin untuk menghubungkan ke fungsi shader, serta <i>pembaruan</i> dalam skrip.  Mereka diterapkan setiap frame tanpa mengubah data mesh, tetapi hanya memodifikasi mesh untuk rendering lebih lanjut. <br><br>  Misalnya, salah satu cara termudah untuk membuat animasi adalah menggunakan waktu untuk mengubah amplitudo.  Di unit ada variabel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bawaan</a> daftar lengkap yang dapat ditemukan di sini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.unity3d.com/Manual/SL-UnityShaderVariables.html</a> Dalam hal ini, kami akan menulis shader baru berdasarkan shader masa lalu kami.  Alih-alih <i>_Amount, mari</i> kita buat nilai float <i>_Amplitude</i> dan gunakan variabel Unity <i>_SinTime bawaan</i> .  <i>_SinTime</i> adalah sinus waktu, dan oleh karena itu dibutuhkan nilai dari -1 hingga 1. Namun, jangan lupa bahwa semua variabel waktu <i>bawaan</i> di unit shader adalah vektor <i>float4</i> .  Misalnya, <i>_SinTime</i> didefinisikan sebagai <i>(sin (t / 8), sin (t / 4), sin (t / 2), sin (t))</i> , di mana t adalah waktunya.  Karenanya, kami mengambil komponen z sehingga animasinya lebih cepat.  Dan kita mendapatkan: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleVertexExtrusionWithTime</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleVertexExtrusionWithTime" <br> { <br> Properties <br> { <br> _Color ("Color", Color) = (1,1,1,1) <br> _Amplitude ("Extrusion Amplitude", float) = 1 <br> } <br> SubShader <br> { <br> Tags { "RenderType"="Opaque" } <br> LOD 200 <br> <br> CGPROGRAM <br> <br> #pragma surface surf Standard fullforwardshadows vertex:vert <br> <br> #pragma target 3.0 <br> <br> struct Input <br> { <br> float4 color : COLOR; <br> }; <br> <br> fixed4 _Color; <br> float _Amplitude; <br> <br> void vert (inout appdata_full v) <br> { <br> v.vertex.xyz += v.normal * _Amplitude * (1 - _SinTime.z); <br> } <br> void surf (Input IN, inout SurfaceOutputStandard o) <br> { <br> fixed4 c = _Color; <br> o.Albedo = c.rgb; <br> } <br> ENDCG <br> } <br> FallBack "Diffuse" <br> } <br></code> <br></div></div><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Browser Anda tidak mendukung video HTML5. <source src="https://i.giphy.com/media/U5UFh8tOZIAmDyZmzm/giphy.mp4" type="video/mp4"></video></div></div></div><br><br>  Jadi ini adalah contoh sederhana.  Saatnya menggambar burung hantu! <br><br><h3>  Deformasi benda </h3><br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Browser Anda tidak mendukung video HTML5. <source src="https://media.giphy.com/media/pOwf43ETsackhG30CA/giphy.mp4" type="video/mp4"></video></div></div></div><br><br>  Saya sudah menulis seluruh artikel tentang satu efek deformasi dengan analisis terperinci dari matematika proses dan logika pemikiran ketika mengembangkan efek seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/en/post/435828</a> Ini akan menjadi burung hantu kita. <br><br>  Semua shader dalam artikel ditulis dalam hlsl.  Bahasa ini sebenarnya memiliki dokumentasi voluminous sendiri, yang banyak orang lupa dan bertanya-tanya dari mana setengah fungsi kabel berasal, meskipun mereka didefinisikan dalam HLSL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl- fungsi intrinsik</a> <br><br>  Namun pada kenyataannya, permukaan shader dalam sebuah unit adalah topik yang besar dan produktif.  Plus, Anda tidak selalu ingin dipusingkan dengan pencahayaan Unity.  Terkadang Anda perlu menipu dan menulis shader tercepat yang hanya memiliki set efek yang telah ditentukan sebelumnya.  Dalam kesatuan, Anda dapat menulis shader tingkat rendah. <br><br><h3>  Shader tingkat rendah </h3><br><br><img src="https://habrastorage.org/webt/k6/xx/bm/k6xxbmwnws5jw0bjy181o3q9ome.jpeg"><br><br>  Menurut tradisi lama yang baik bekerja dengan shader, selanjutnya kita akan menyiksa kelinci Stanford. <br><br>  Secara umum, yang disebut Unity ShaderLab pada dasarnya adalah visualisasi seorang inspektur dengan bidang-bidang dalam materi dan beberapa penyederhanaan penulisan shader. <br><br>  Ambil struktur umum shaderlab shader: <br><br><div class="spoiler">  <b class="spoiler_title">Struktur shader umum</b> <div class="spoiler_text"> <code>Shader "MyShaderName" <br> { <br> Properties <br> { <br> //   <br> } <br> SubShader //     (   ) <br> { <br> Pass <br> { <br> //   <br> } <br> //        <br> } <br> //     <br> FallBack "VertexLit" //         ,     <br> } <br></code> <br></div></div><br>  Arahan kompilasi seperti <br>  <i>#pragma vertex vert</i> <br>  <i>fragmen #pragma fragmen</i> <br>  tentukan fungsi shader mana yang akan dikompilasi sebagai vertex dan fragmen shader, masing-masing. <br><br>  Mari kita ambil salah satu contoh paling umum - shader untuk menampilkan warna normals: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleNormalVisualization</b> <div class="spoiler_text"> <code>Shader "Custom/SimpleNormalVisualization" <br> { <br> Properties <br> { <br> } <br> SubShader <br> { <br> Pass <br> { <br> CGPROGRAM <br> <br> #pragma vertex vert <br> #pragma fragment frag <br> <br> #include "UnityCG.cginc" <br> <br> struct v2f { <br> float4 pos : SV_POSITION; <br> fixed3 color : COLOR0; <br> }; <br> <br> v2f vert (appdata_base v) <br> { <br> v2f o; <br> o.pos = UnityObjectToClipPos(v.vertex); <br> o.color = v.normal * 0.5 + 0.5; <br> return o; <br> } <br> <br> fixed4 frag (v2f i) : SV_Target <br> { <br> return fixed4 (i.color, 1); <br> } <br> ENDCG <br> } <br> } <br> FallBack "VertexLit" <br> } <br></code> <br></div></div><br><img src="https://habrastorage.org/webt/5t/oy/wv/5toywvw0cewffefffvw5xfvtj60.jpeg"><br><br>  Dalam kasus ini, di bagian simpul, kami menulis nilai normal yang dikonversi ke warna simpul, dan di bagian piksel kami menggunakan warna ini sebagai warna model. <br><br>  Fungsi <i>UnityObjectToClipPos</i> adalah fungsi bantu Unity (dari file <i>UnityCG.cginc</i> ) yang menerjemahkan simpul objek ke posisi yang terkait dengan kamera.  Tanpanya, suatu objek, ketika memasuki visibilitas kamera (frustrum), akan ditarik dalam koordinat layar, terlepas dari posisi transformasi.  Sejak awalnya posisi simpul disajikan dalam koordinat objek.  Nilai hanya relatif terhadap porosnya. <br><br>  Blok ini. <br> <code>struct v2f { <br> float4 pos : SV_POSITION; <br> fixed3 color : COLOR0; <br> };</code> <br>  Ini adalah definisi dari struktur yang akan diproses pada bagian verteks dan dipindahkan ke bagian fragmen.  Dalam hal ini, ditentukan bahwa dua parameter diambil dari mesh - posisi titik dan warna titik.  Anda dapat membaca lebih lanjut tentang data apa yang dapat dilemparkan ke dalam unit di tautan ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.unity3d.com/Manual/SL-VertexProgramInputs.html</a> <br><br>  Klarifikasi penting.  Nama-nama atribut mesh tidak penting.  Yaitu, katakanlah dalam atribut warna Anda dapat menulis vektor penyimpangan dari posisi semula (dengan cara ini mereka kadang-kadang membuat efek ketika karakter berjalan sehingga rumput "menolak" darinya).  Bagaimana atribut ini akan diproses sepenuhnya tergantung pada shader Anda. <br><br><h3>  Kesimpulan </h3><br><br>  Terima kasih atas perhatian anda!  Sangatlah sulit untuk menulis beberapa efek kompleks tanpa bagian yang terpisah-pisah, untuk alasan ini kita akan membahas hal serupa dalam artikel terpisah.  Saya berharap selama artikel ini menjadi sedikit lebih jelas bagaimana kode untuk vertex shader ditulis secara umum, dan di mana Anda dapat menemukan informasi untuk dipelajari, karena shader adalah topik yang sangat mendalam. <br><br>  Dalam artikel mendatang, kami akan menganalisis jenis shader lain, efek individu, dan saya akan mencoba menggambarkan logika pemikiran saya saat membuat efek baru atau kompleks. <br><br>  Sebuah repositori juga telah dibuat di mana semua hasil dari seri artikel ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/Nox7atra/ShaderExamples</a> akan ditambahkan. Saya harap informasi ini akan berguna bagi pemula yang baru memulai perjalanan mereka dalam mempelajari topik ini. <br><br><h4>  Beberapa tautan bermanfaat (termasuk sumber): </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.khronos.org/opengl/wiki/Vertex_Shader</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-reference</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.unity3d.com/en/current/Manual/SL-Reference.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">docs.unity3d.com/Manual/GraphicsTutorials.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.malbred.com/3d-grafika-3d-redaktory/sovremennaya-terminologiya-3d-grafiki/vertex-shader-vershinnyy-sheyder.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3dpapa.ru/accurate-displacement-workflow</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474812/">https://habr.com/ru/post/id474812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474800/index.html">Kinerja dalam .NET Core</a></li>
<li><a href="../id474804/index.html">Kemajuan teknologi Rusia dalam olahraga: antarmuka saraf, kamera IP, CRM olahraga dan BigData dari mobil balap</a></li>
<li><a href="../id474806/index.html">UDP Banjir dari Google atau bagaimana tidak menghilangkan semua Youtube</a></li>
<li><a href="../id474808/index.html">Rilis Rust 1.39.0: async / await, atribut untuk parameter fungsi, fungsi konstan baru</a></li>
<li><a href="../id474810/index.html">Cara kerja kriptografi kurva elips di TLS 1.3</a></li>
<li><a href="../id474814/index.html">Antiquities: messenger dari pembusukan atau keusangan yang tidak direncanakan</a></li>
<li><a href="../id474816/index.html">Proyek kesayangan - kehidupan kecil</a></li>
<li><a href="../id474818/index.html">Apakah ada angka acak di CSS?</a></li>
<li><a href="../id474822/index.html">WISE-PaaS - platform cloud untuk berbagai hal industri Internet</a></li>
<li><a href="../id474826/index.html">Tabel normal dalam penurunan harga</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>