<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏻 🧑🏽‍🤝‍🧑🏽 👨🏽‍🏫 Lemos as fichas técnicas 2: SPI no STM32; Temporizadores PWM e interrupções no STM8 👨🏿‍🍳 👩🏻‍🏭 🖐🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na primeira parte, tentei dizer aos entusiastas eletrônicos que cresceram fora das calças do Arduino como e por que eles deveriam ler folhas de dados ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lemos as fichas técnicas 2: SPI no STM32; Temporizadores PWM e interrupções no STM8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/456094/"><p><img src="https://habrastorage.org/webt/zz/sh/fd/zzshfdfytuphbmlregcazfpxo2a.jpeg"></p><br><p>  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte,</a> tentei dizer aos entusiastas eletrônicos que cresceram fora das calças do Arduino como e por que eles deveriam ler folhas de dados e outras documentações para microcontroladores.  Como o texto era grande, prometi mostrar exemplos práticos em um artigo separado.  Bem, ele se chamava de carga ... </p><br><p>  Hoje vou mostrar como usar folhas de dados para resolver tarefas bastante simples, mas necessárias para muitos projetos, nos controladores STM32 (Blue Pill) e STM8.  Todos os projetos de demonstração são dedicados aos meus LEDs favoritos, vamos acendê-los em grandes quantidades, para os quais teremos que usar todos os tipos de periféricos interessantes. </p><a name="habracut"></a><br><p>  O texto acabou sendo enorme novamente, por conveniência, eu estou fazendo o conteúdo: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pílula azul STM32: 16 LEDs com driver DM634</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">STM8: Configurando Seis Pinos PWM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">STM8: 8 LEDs RGB em três pinos, interrompe</a> </p><br><p>  <em>Disclaimer: Eu não sou engenheiro, não pretendo ter um profundo conhecimento em eletrônica, o artigo é destinado a amantes como eu.</em>  <em>De fato, como público-alvo, eu me considerava dois anos atrás.</em>  <em>Se alguém me dissesse que não é assustador ler fichas técnicas em um chip desconhecido, eu não gastaria muito tempo pesquisando alguns códigos na Internet e inventando muletas com tesoura e um curativo.</em> </p><br><p>  <em>No centro deste artigo, estão as planilhas de dados, não os projetos; portanto, o código pode não ser muito penteado e frequentemente triturado.</em>  <em>Os projetos em si são muito simples, embora adequados para o primeiro contato com o novo chip.</em> </p><br><p>  <em>Espero que meu artigo ajude alguém em um estágio semelhante em um mergulho por hobby.</em> </p><br><h1 id="stm32">  STM32 </h1><br><h1 id="16-svetodiodov-c-dm634-i-spi">  16 LEDs com DM634 e SPI </h1><br><p>  Um pequeno projeto usando o Blue Pill (STM32F103C8T6) e o driver de LED DM634.  Com a ajuda das folhas de dados, lidaremos com o driver, portas IO STM e configuraremos o SPI. </p><br><h2 id="dm634">  DM634 </h2><br><p>  O chip de Taiwan com 16 saídas PWM de 16 bits, pode ser conectado em cadeias.  O modelo mais jovem de 12 bits é conhecido pelo projeto doméstico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lightpack</a> .  Ao mesmo tempo, escolhendo entre o DM63x e o conhecido TLC5940, parei no DM por vários motivos: 1) O TLC no Aliexpress é definitivamente falso, mas esse não é;  2) o DM possui um PWM autônomo com seu próprio gerador de frequência;  3) poderia ser comprado mais barato em Moscou, e não esperar um pacote com Ali.  Bem, é claro, foi interessante aprender a gerenciar o chip sozinho e não usar uma biblioteca pronta.  Os chips agora são apresentados principalmente no pacote SSOP24, e são fáceis de soldar no adaptador. </p><br><p>  Como o fabricante é taiwanês, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">folha</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dados</a> do chip está escrita em inglês chinês, o que significa que será divertido.  Primeiro, observe a <em>conexão</em> dos <em>pinos</em> ( <em>conexão dos pinos</em> ) para entender a qual perna conectar e a descrição dos pinos (descrição dos pinos).  16 conclusões: </p><br><p><img src="https://habrastorage.org/webt/uj/n8/mo/ujn8mooelrxoxg7xzvvfsdh4er8.png"><br>  <sup>Fontes de entrada de corrente contínua (dreno aberto)</sup> </p><br><p>  <strong>Saída de</strong> <strong>pia</strong> / <strong>dreno aberto</strong> - dreno;  fonte de corrente de entrada;  saída ativa conectada ao terra - os LEDs são conectados ao driver por cátodos.  Eletricamente, é claro que isso não é um "dreno aberto", mas nas planilhas de dados essa designação para saídas no modo dreno é comum. </p><br><p><img src="https://habrastorage.org/webt/yk/bq/p4/ykbqp4ivabirkgahd2d7l_9gjny.png"><br>  <sup>Resistores externos entre REXT e GND para definir o valor da corrente de saída</sup> </p><br><p>  Um resistor de referência é instalado entre o pino REXT e o terra, que controla a resistência interna das saídas, veja o gráfico na página 9 da folha de dados.  No DM634, essa resistência também pode ser controlada programaticamente, definindo o <em>brilho global</em> ;  Não vou entrar em detalhes neste artigo, apenas coloquei um resistor de 2,2 - 3 kOhm aqui. </p><br><p>  Para entender como controlar o chip, veja a descrição da interface do dispositivo: </p><br><p><img src="https://habrastorage.org/webt/7s/5n/to/7s5ntogguqr1yb6fu2l5pchaob8.png"></p><br><p>  Sim, aqui está, inglês chinês em toda a sua glória.  É problemático traduzir, você pode entendê-lo, se desejar, mas há outra maneira - observar como a conexão é descrita na folha de dados para o TLC5940 funcionalmente próximo: </p><br><p><img src="https://habrastorage.org/webt/qi/za/j2/qizaj2wq08ppbzehiszsd2spqz8.png"><br>  <sub>... Apenas três pinos são necessários para inserir dados no dispositivo.</sub>  <sub>A borda principal do sinal SCLK muda os dados do pino SIN para o registro interno.</sub>  <sub>Após o download de todos os dados, um pequeno sinal XLAT alto captura os dados seriais nos registros internos.</sub>  <sub>Registradores internos - válvulas de acionamento XLAT.</sub>  <sub>Todos os dados são transmitidos no bit mais significativo para a frente.</sub> </p><br><p>  <strong>Trava</strong> - uma trava / trava / braçadeira. <br>  <strong>Borda ascendente</strong> - <strong>borda</strong> principal do impulso <br>  <strong>MSB primeiro</strong> - o bit <strong>mais significativo</strong> (mais à esquerda) para a frente. <br>  <strong>para registrar dados</strong> - transmita dados sequencialmente (bit a bit). </p><br><p>  A palavra <em>trava é</em> frequentemente encontrada na documentação para chips e é traduzida de várias maneiras, por isso me permitirei entender </p><div class="spoiler">  <b class="spoiler_title">pequeno programa educacional</b> <div class="spoiler_text">  O driver de LED é essencialmente um registro de turno.  “Shift” no nome é um movimento de dados bit a bit dentro do dispositivo: cada novo bit empurrado para dentro empurra toda a cadeia à sua frente.  Como ninguém quer observar o caótico piscar dos LEDs durante o turno, o processo ocorre em registros de buffer separados dos de trabalho por uma <em>trava</em> - esse é um tipo de sala de espera onde os bits são organizados na seqüência desejada.  Quando tudo estiver pronto, o obturador se abre e os bits são enviados para o trabalho, substituindo o lote anterior.  A palavra <em>trava</em> na documentação para microcircuitos quase sempre implica em um amortecedor, independentemente da combinação usada. </div></div><br><p>  Portanto, a transferência de dados para o DM634 é a seguinte: defina a entrada DAI no bit de ordem superior do LED remoto, puxe o DCK para cima e para baixo;  defina a entrada DAI para o próximo bit, puxe DCK;  e assim por diante, até que todos os bits sejam transmitidos ( <em>cronometrados</em> ), após o que puxamos o LAT.  Isso pode ser feito manualmente ( <em>bit-bang</em> ), mas é melhor usar a interface SPI afiada especialmente para isso, pois ela é apresentada em nosso STM32 em duas cópias. </p><br><h2 id="sinyaya-tabletka-stm32f103">  Blue Tablet STM32F103 </h2><br><p>  Introdutório: Os controladores STM32 são muito mais complicados que o Atmega328 do que podem assustar.  Ao mesmo tempo, por razões de economia de energia, quase todos os periféricos são desativados no início e a frequência do relógio é de 8 MHz a partir de uma fonte interna.  Felizmente, os programadores da STM escreveram o código que levou o chip aos 72 MHz "calculados" e os autores de todos os IDEs que eu conhecia o incluíram no procedimento de inicialização, portanto, não precisamos cronometrar (mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">você pode, se realmente quiser</a> ).  Mas você precisa ligar os periféricos. </p><br><p>  Documentação: O popular chip STM32F103C8T6 está instalado no Blue Pill, existem dois documentos úteis para ele: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Folha de dados</a> para os microcontroladores STM32F103x8 e STM32F103xB; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manual de referência</a> para toda a linha STM32F103 e além. </li></ul><br><p>  Em uma folha de dados, podemos estar interessados ​​em: </p><br><ul><li>  Pinagens - pinagens de batatas fritas - no caso de decidirmos fazer pranchas; </li><li>  Mapa da memória - cartão de memória para um chip específico.  No Manual de Referência, há um cartão para toda a linha, que lista os registros que não estão no nosso. </li><li>  Definições dos pinos da tabela - listando as funções principais e alternativas dos pinos;  para a “pílula azul” na Internet, você pode encontrar fotos mais convenientes com uma lista de pinos e suas funções.  Portanto, pesquise imediatamente a pinagem do Blue Pill no Google e mantenha esta foto à mão: </li></ul><br><p><img src="https://habrastorage.org/webt/_q/q_/o4/_qq_o4hwzc3k1nzqluqtaqpuye0.png"><br>  <em>Nota: na imagem da Internet, ocorreu um erro nos comentários, pelo qual obrigado.</em>  <em>A imagem foi substituída, mas esta é uma lição - é melhor verificar informações de folhas que não são de dados.</em> </p><br><p>  Removemos a folha de dados, abrimos o Manual de Referência, agora apenas a usamos. <br>  Procedimento: lidamos com entrada / saída padrão, configuramos o SPI, ligamos os periféricos desejados. </p><br><h3 id="vvod-vyvod">  Entrada-saída </h3><br><p>  A E / S do Atmega328 é extremamente simples, e é por isso que a abundância de opções do STM32 pode ser confusa.  Agora, precisamos apenas de conclusões, mas mesmo existem quatro opções: </p><br><p><img src="https://habrastorage.org/webt/qv/ao/t6/qvaot6ql0b4z6c0bvv71dumovji.png"><br>  <sub>saída de dreno aberto, saída push-pull, saída push-pull alternativa, dreno aberto alternativo</sub> </p><br><p>  “ <em>Push-pull</em> ” ( <em>push-pull</em> ) - a conclusão usual da Arduina, o pino pode ser ALTO ou BAIXO.  Mas com o "dreno aberto" existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dificuldades</a> , embora de fato tudo seja simples aqui: </p><br><p><img src="https://habrastorage.org/webt/qa/e-/al/qae-alom88ushdmghd8wcu2l0q4.png"><br><img src="https://habrastorage.org/webt/en/oh/ny/enohnyxpb5u8cs4_t_m-cmtxbwy.png"><br>  <sub>Configuração de saída / quando a porta é atribuída à saída: / buffer de saída está ativado: / - modo de dreno aberto: “0” ativa N-MOS no registro de saída, “1” deixa a porta no modo Hi-Z no registro de saída (o P-MOS não está ativado ) / - modo push-pull: “0” no registro de saída ativa o N-MOS, “1” no registro de saída ativa o P-MOS.</sub> </p><br><p>  Toda a diferença entre dreno aberto e <em>push-pull</em> é que, no primeiro pino, ele não pode aceitar o estado ALTO: ao gravar uma unidade no registro de saída, ele muda para <em>alta impedância</em> <em>-Z</em> ).  Ao gravar zero, o pino nos dois modos se comporta da mesma maneira, tanto lógica quanto eletricamente. </p><br><p>  No modo de saída normal, o pino simplesmente traduz o conteúdo do registro de saída.  Na "alternativa" é controlado pela periferia correspondente (ver 9.1.4): </p><br><p><img src="https://habrastorage.org/webt/wu/mz/fv/wumzfvlk-fueikoig1wg6npj59u.png"><br>  <sub>Se o bit da porta estiver configurado como uma saída de função alternativa, o registro de saída será desativado e o pino será conectado ao sinal de saída periférico.</sub> </p><br><p>  Uma funcionalidade alternativa para cada pino é descrita na folha de dados das <em>Definições de pinos</em> e está na imagem baixada.  Quando perguntado o que fazer se o pino tiver várias funções alternativas, a resposta fornece uma nota de rodapé na folha de dados: </p><br><p><img src="https://habrastorage.org/webt/g1/hq/mi/g1hqmixkcdtdiius8u45hjfzagy.png"><br>  <sub>Se vários blocos periféricos usarem o mesmo pino, para evitar conflitos entre funções alternativas, apenas um bloco periférico deve ser usado ao mesmo tempo, alternando usando o bit de ativação do relógio periférico (no registro RCC correspondente).</sub> </p><br><p>  Finalmente, os pinos no modo de saída também têm uma velocidade de clock.  Esse é outro recurso de economia de energia; no nosso caso, basta configurá-lo ao máximo e esquecê-lo. </p><br><p>  Então, como usamos SPI, dois pinos (com dados e um sinal de relógio) devem ser uma "função alternativa de pressão" e outro (LAT) deve ser "pressão normal".  Mas antes de atribuí-los, lidaremos com o SPI. </p><br><h3 id="spi">  SPI </h3><br><div class="spoiler">  <b class="spoiler_title">Outro pequeno programa educacional</b> <div class="spoiler_text"><p>  SPI ou Serial Peripherial Interface (interface periférica serial) - uma interface simples e muito eficaz para comunicação de MK com outros MK e o mundo exterior em geral.  O princípio de sua operação já foi descrito acima, sobre o driver de LED chinês (no manual de referência, consulte a seção 25).  O SPI pode operar nos modos mestre ("mestre") e escravo ("escravo").  O SPI possui quatro canais básicos, dos quais nem todos podem estar envolvidos: </p><br><ul><li>  MOSI, Saída Mestre / Entrada Escrava: este pino no modo mestre envia, mas no modo escravo recebe dados; </li><li>  MISO, Master Input / Slave Output: pelo contrário, no mestre aceita, no escravo - dá; </li><li>  SCK, Serial Clock: define a frequência da transferência de dados no mestre ou recebe um sinal de relógio no escravo.  Bate essencialmente os bits; </li><li>  SS, Slave Select: através deste canal, o escravo aprende que quer algo dele.  No STM32, é chamado NSS, onde N = negativo, ou seja,  o controlador se torna escravo se houver terra neste canal.  Combina bem com o modo Open Drain Output, mas essa é uma história diferente. </li></ul></div></div><br><p>  Como todo o resto, o SPI no STM32 é rico em funcionalidades, o que dificulta a compreensão.  Por exemplo, ele pode funcionar não apenas com o SPI, mas também com a interface I2S e, na documentação em que suas descrições são misturadas, é necessário cortar o excesso em tempo hábil.  Nossa tarefa é extremamente simples: você só precisa enviar dados usando apenas MOSI e SCK.  Vamos para a seção 25.3.4 (comunicação half-duplex), onde encontramos <em>1 relógio e 1 fio de dados unidirecional</em> (1 sinal de relógio e 1 fluxo de dados unidirecional): </p><br><p><img src="https://habrastorage.org/webt/3o/wg/pm/3owgpmokhpahr9rkftf5ns2lclw.png"><br>  <sub>Nesse modo, o aplicativo usa o SPI no modo somente transmissão ou somente recebimento.</sub>  <sub>/ O modo somente transmissão é semelhante ao modo duplex: os dados são transmitidos no pino transmissor (MOSI no modo mestre ou MISO no modo escravo), e o pino receptor (MISO ou MOSI, respectivamente) pode ser usado como um pino de entrada / saída regular.</sub>  <sub>Nesse caso, é suficiente que o aplicativo ignore o buffer Rx (se você o ler, não haverá dados transmitidos).</sub> </p><br><p>  Bem, o pino MISO está livre de nós, vamos conectar o sinal LAT a ele.  Lidamos com o Slave Select, que pode ser controlado programaticamente no STM32, o que é extremamente conveniente.  Lemos o parágrafo com o mesmo nome na seção 25.3.1 da Descrição Geral da SPI: </p><br><p><img src="https://habrastorage.org/webt/8t/ng/jf/8tngjfopfxskwyq_gl8tlogcp2o.png"><br>  <sub>Controle de programa NSS (SSM = 1) / Informações sobre a seleção do escravo estão contidas no bit SSI do registro SPI_CR1.</sub>  <sub>O pino NSS externo permanece livre para outras necessidades do aplicativo.</sub> </p><br><p>  É hora de escrever nos registros.  Decidi usar o SPI2, estamos procurando o endereço base na folha de dados - na seção 3.3 Mapa de Memória: </p><br><p><img src="https://habrastorage.org/webt/os/xd/6p/osxd6pdv5zfwombf5xflzfikj5c.png"></p><br><p>  Bem, começamos: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI2_(mem_offset) (*(volatile uint32_t *)(0x40003800 + (mem_offset)))</span></span></code> </pre> <br><p>  Abrimos a seção 25.3.3 com o ditado "Configurando SPI no modo mestre": </p><br><p><img src="https://habrastorage.org/webt/s8/ah/o5/s8aho5pbdv55j5vhhwecvewrm3m.png"></p><br><p>  <strong>1. Defina a velocidade do relógio serial com os bits BR [2: 0] no registro SPI_CR1.</strong> </p><br><p>  Os registros são coletados na seção do manual de referência com o mesmo nome.  CR1 tem um <em>deslocamento de endereço</em> ( <em>deslocamento de endereço</em> ) de 0x00; por padrão, todos os bits são redefinidos ( <em>valor de redefinição</em> 0x0000): </p><br><p><img src="https://habrastorage.org/webt/vt/46/um/vt46umrvbimjon75durupo3zsao.png"></p><br><p>  Os bits BR definem o divisor de frequência do relógio do controlador, determinando assim a frequência na qual o SPI irá operar.  Teremos uma frequência de STM32 de 72 MHz, o driver de LED, de acordo com sua folha de dados, trabalha com uma frequência de até 25 MHz, portanto, é necessário dividir por quatro (BR [2: 0] = 001). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_CR1 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_0 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_1 0x0010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_2 0x0020 _SPI2_ (_SPI_CR1) |= BR_0;</span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// pclk/4</span></span></span></span></code> </pre> <br><p>  <strong>2. Defina os bits CPOL e CPHA para determinar o relacionamento entre a transferência de dados e o clock da interface serial (consulte o diagrama na página 240)</strong> </p><br><p>  Como estamos lendo as fichas de dados aqui, e sem considerar os circuitos, vamos estudar melhor a descrição textual dos bits CPOL e CPHA na página 704 (Descrição Geral da SPI): </p><br><p><img src="https://habrastorage.org/webt/2h/pj/in/2hpjinoa65388hdfarcc9lwnqok.png"><br>  <sub>Fase do relógio e polaridade</sub> <sub><br></sub>  <sub>Usando os bits CPOL e CPHA do registro SPI_CR1, quatro opções para relacionamentos de tempo podem ser selecionadas programaticamente.</sub>  <sub>O bit CPOL (polaridade do relógio) controla o estado do relógio quando nenhum dado está sendo transmitido.</sub>  <sub>Este bit controla os modos mestre e escravo.</sub>  <sub>Se o CPOL for redefinido, o pino SCK estará baixo no modo ocioso.</sub>  <sub>Se o bit CPOL estiver definido, o pino SCK estará em um nível alto no modo ocioso.</sub> <sub><br></sub>  <sub>Se o bit CPHA (fase do relógio) estiver definido, a segunda extremidade do sinal SCK atua como um trap-gate do bit alto (descendente se o CPOL for limpo ou ascendente se o CPOL estiver definido).</sub>  <sub>Os dados são capturados pela segunda alteração no sinal do relógio.</sub>  <sub>Se o bit CPHA for apagado, a borda principal do sinal SCK atua como um trap-gate do bit alto (para baixo se o CPOL estiver definido ou para cima se o CPOL for apagado).</sub>  <sub>Os dados são capturados pela primeira alteração no sinal do relógio.</sub> </p><br><p>  Tendo fumado esse conhecimento, concluímos que os dois bits devem permanecer zeros, porque  precisamos que o sinal SCK permaneça baixo quando não estiver em uso e que os dados sejam transmitidos ao longo da borda principal do pulso (consulte <em>Rising Edge</em> na folha de dados do DM634). </p><br><p>  A propósito, aqui encontramos pela primeira vez um recurso de vocabulário nas folhas de dados do ST: nelas a frase “redefinir bit para zero” é escrita <em>para redefinir um pouco</em> e não <em>para limpar um pouco</em> , como, por exemplo, no Atmega. </p><br><p>  <strong>3. Defina o bit DFF para definir um formato de bloco de dados de 8 ou 16 bits.</strong> </p><br><p>  Peguei especificamente o DM634 de 16 bits, para não me preocupar com a transmissão de dados PWM de 12 bits, como o DM633.  DFF faz sentido colocar em uma unidade: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DFF 0x0800 _SPI2_ (_SPI_CR1) |= DFF; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 16-bit mode</span></span></span></span></code> </pre> <br><p>  <strong>4. Configure o bit LSBFIRST no registro SPI_CR1 para determinar o formato do bloco</strong> </p><br><p>  LSBFIRST, como o próprio nome indica, avança o bit de ordem inferior.  Mas o DM634 deseja receber dados começando com o bit alto.  Portanto, deixamos isso de lado. </p><br><p>  <strong>5. No modo de hardware, se for necessária a entrada do pino NSS, envie um sinal alto para o pino NSS durante toda a sequência de transferência de bytes.</strong>  <strong>No modo de programa NSS, defina os bits SSM e SSI no registro SPI_CR1.</strong>  <strong>Se o pino NSS funcionar na saída, apenas o bit SSOE deve ser definido.</strong> </p><br><p>  Instale o SSM e o SSI para esquecer o modo de hardware NSS: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSI 0x0100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSM 0x0200 _SPI2_ (_SPI_CR1) |= SSM | SSI; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//enable software control of SS, SS high</span></span></span></span></code> </pre> <br><p>  <strong>6. Os bits MSTR e SPE devem ser configurados (eles permanecem configurados apenas se um sinal alto for aplicado ao NSS)</strong> </p><br><p>  Na verdade, com esses bits, atribuímos nosso SPI como mestre e o ativamos: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MSTR 0x0004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPE 0x0040 _SPI2_ (_SPI_CR1) |= MSTR; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//SPI master //  ,  SPI _SPI2_ (_SPI_CR1) |= SPE;</span></span></span></span></code> </pre> <br><p>  O SPI está configurado, vamos escrever funções que enviam bytes para o driver imediatamente.  Continuamos a ler 25.3.3 "Configurando o SPI no modo mestre": </p><br><p><img src="https://habrastorage.org/webt/sb/rg/u5/sbrgu5xwvaj7vc8a9rk2guxfdeq.png"><br>  <sub>Procedimento de transferência de dados</sub> <sub><br></sub>  <sub>A transmissão começa quando um byte é gravado no buffer Tx.</sub> <sub><br></sub>  <sub>O byte de dados é carregado no registro de deslocamento em modo <strong>paralelo</strong> (a partir do barramento interno) durante a transmissão do primeiro bit, após o qual é transmitido em modo <strong>serial</strong> para o pino MOSI, o primeiro ou o último bit para frente, dependendo da configuração do bit LSBFIRST no registro CPI_CR1.</sub>  <sub>O sinalizador TXE é definido depois que os dados são transferidos <strong>do buffer Tx para o registrador de deslocamento</strong> e uma interrupção também é criada se o bit TXEIE for definido no registrador CPI_CR1.</sub> </p><br><p>  Destacamos algumas palavras na tradução para chamar a atenção para um recurso da implementação do SPI nos controladores STM.  No Atmega, o sinalizador TXE ( <em>Tx Vazio</em> , Tx está vazio e pronto para receber dados) é definido somente após a <em>saída do</em> byte inteiro.  E aqui esse sinalizador é definido depois que o byte é inserido no registro de deslocamento interno.  Como é empurrado para lá por todos os bits simultaneamente (em paralelo) e, em seguida, os dados são transmitidos seqüencialmente, o TXE é definido antes do envio completo do byte.  Isso é importante porque  no caso de nosso driver de LED, precisamos puxar o pino LAT depois de enviar <em>todos os</em> dados, ou seja,  Somente a bandeira TXE não será suficiente para nós. </p><br><p>  E isso significa que precisamos de alguma outra bandeira.  Vamos ver em 25.3.7 - "Sinalizadores de status": </p><br><p><img src="https://habrastorage.org/webt/_d/vn/jj/_dvnjjudvkmdyutpylvwfkfknng.png"><br>  &lt;...&gt; <br><img src="https://habrastorage.org/webt/3y/wv/nd/3ywvndaij5blabzqfq2n6wzdbfe.png"><br>  <sub>Bandeira OCUPADA</sub> <sub><br></sub>  <sub>O sinalizador BSY é definido e redefinido pelo hardware (gravar nele não afeta nada).</sub>  <sub>O sinalizador BSY indica o estado da camada de comunicação SPI.</sub> <sub><br></sub>  <sub>É redefinido:</sub> <sub><br></sub>  <sub>quando a transferência estiver concluída (exceto no modo mestre, se a transferência for contínua)</sub> <sub><br></sub>  <sub>quando o SPI está desativado</sub> <sub><br></sub>  <sub>quando ocorre um erro no modo do assistente (MODF = 1)</sub> <sub><br></sub>  <sub>Se a transmissão não for contínua, a bandeira BSY é apagada entre cada transmissão de dados.</sub> </p><br><p>  Ok, venha a calhar.  Descobrimos onde o buffer Tx está localizado.  Para fazer isso, leia o "Registro de dados SPI": </p><br><p><img src="https://habrastorage.org/webt/sj/gk/o7/sjgko7dcnefgkio4jk9xrwt67bs.png"><br>  <sub>Bits 15: 0 DR [15: 0] Registro de Dados</sub> <sub><br></sub>  <sub>Dados recebidos ou dados para transmissão.</sub> <sub><br></sub>  <sub>O registro de dados é dividido em dois buffers - um para gravação (buffer de transmissão) e o segundo para leitura (buffer de recebimento).</sub>  <sub>A gravação no registro de dados grava no buffer Tx e a leitura no registro de dados retornará o valor contido no buffer Rx.</sub> </p><br><p>  Bem, o registro de status, onde há sinalizadores TXE e BSY: </p><br><p><img src="https://habrastorage.org/webt/-k/pi/q9/-kpiq96tkpbqvvr1vly6nlzpwoe.png"></p><br><p>  Escrevemos: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_DR 0x0C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_SR 0x08 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BSY 0x0080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TXE 0x0002 void dm_shift16(uint16_t value) { _SPI2_(_SPI_DR) = value; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//send 2 bytes while (!(_SPI2_(_SPI_SR) &amp; TXE)); //wait until they're sent }</span></span></span></span></code> </pre> <br><p>  Bem, como precisamos transmitir 16 bytes duas vezes, de acordo com o número de saídas do driver de LED, algo como isto: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendLEDdata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LAT_low(); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> k = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k--; dm_shift16(leds[k]); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_SPI2_(_SPI_SR) &amp; BSY); <span class="hljs-comment"><span class="hljs-comment">// finish transmission LAT_pulse(); }</span></span></code> </pre> <br><p>  Mas ainda não sabemos como puxar o pino LAT, portanto, retornaremos à E / S. </p><br><h3 id="naznachaem-piny">  Atribuir pinos </h3><br><p>  No STM32F1, os registros responsáveis ​​pelo estado dos pinos são bastante incomuns.  É claro que existem mais do que o Atmega, mas eles também diferem de outros chips STM.  Seção 9.1 Descrição geral do GPIO: </p><br><p><img src="https://habrastorage.org/webt/ky/w9/ks/kyw9ksdar6bepxsf1u7kvyejfwm.png"><br>  <sub>Cada uma das portas de entrada / saída de uso geral <em>(GPIO)</em> possui dois registros de configuração de 32 bits (GPIOx_CRL e GPIOx_CRH), dois registros de dados de 32 bits (GPIOx_IDR e GPIOx_ODR), um registro de configuração / redefinição de 32 bits (GPIOx_BSRR), 16 bits um registro de redefinição (GPIOx_BRR) e um registro de bloco de 32 bits (GPIOx_LCKR).</sub> </p><br><p>  Incomuns, além de inconvenientes, os dois primeiros registradores estão aqui, porque 16 pinos de porta estão espalhados sobre eles no formato "quatro bits por irmão".  I.e.  os pinos de zero a sétimo estão na CRL e o restante na CRH.  Ao mesmo tempo, o restante dos registradores se encaixam com êxito nos bits de todos os pinos da porta - muitas vezes permanecendo meio "reservados". </p><br><p>  Para simplificar, comece no final da lista. </p><br><p>  Não precisamos de um registro de blocos. </p><br><p>  Os registros de configuração e redefinição são bastante engraçados, pois eles se duplicam parcialmente: você pode escrever tudo apenas em BSRR, onde os 16 bits mais altos redefinirão o pino para zero e os inferiores - configurados para 1, ou use também BRR, os 16 bits inferiores dos quais apenas redefinem o pino .  Eu gosto da segunda opção.  Esses registros são importantes, pois fornecem acesso atômico aos pinos: </p><br><p><img src="https://habrastorage.org/webt/tr/g9/tq/trg9tqg8ksmhfiaokjbslfvvhny.png"><br><img src="https://habrastorage.org/webt/yb/dm/da/ybdmdaayb-f0np1pawunxobfbaa.png"><br>  <sub>Instalação atômica ou redefinição</sub> <sub><br></sub>  <sub>Você não precisa desativar interrupções ao programar GPIOx_ODR no nível de bit: é possível alterar um ou mais bits com uma operação de gravação atômica APB2.</sub>  <sub>Isso é possível escrevendo “1” no registro de configuração / redefinição (GPIOx_BSRR ou, somente para redefinição, em GPIOx_BRR), o bit que você deseja alterar.</sub>  <sub>Outros bits permanecerão inalterados.</sub> </p><br><p>  Os registradores de dados têm nomes bastante falantes - IDR = <em>Input</em> Direction Register, registro de entrada;  ODR = Registro da direção de saída, registro de saída.  No projeto atual, não precisaremos deles. </p><br><p>  E, finalmente, os registros de controle.  Como estamos interessados ​​nos pinos do segundo SPI, ou seja, PB13, PB14 e PB15, analisamos imediatamente o CRH: </p><br><p><img src="https://habrastorage.org/webt/ei/_v/it/ei_vitm85yhwasuf5zjbhksfsoq.png"></p><br><p>  E vemos que será necessário escrever algo em bits do dia 20 ao 31. </p><br><p>  Já descobrimos o que queremos dos pinos, então aqui eu posso fazer sem uma captura de tela, basta dizer que MODE define a direção (entrada, se ambos os bits estão definidos como 0) e a velocidade do pino (precisamos de 50MHz, ou seja, ambos pino em “1”), e CNF define o modo: normal “push-push” - 00, “alternativa” - 10. Por padrão, como vemos acima, todos os pinos têm o terceiro bit da parte inferior (CNF0), ele os define como modo de <em>entrada flutuante</em> . </p><br><p>  Como pretendo fazer outra coisa com esse chip, para simplificar, defini todos os valores possíveis de MODE e CNF para os registros de controle inferior e superior. </p><br><div class="spoiler">  <b class="spoiler_title">Bem, algo assim</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_1 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_1 0x20000000</span></span></code> </pre> </div></div><br><p>  Nossos pinos estão localizados na porta B (o endereço base é 0x40010C00), código: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _PORTB_(mem_offset) (*(volatile uint32_t *)(0x40010C00 + (mem_offset))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BRR 0x14 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BSRR 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRL 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRH 0x04 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  SPI2: MOSI  B15, CLK  B13 //LAT     MISO – B14 //  ,      _PORTB_ (_CRH) &amp;= ~(CNF15_0 | CNF14_0 | CNF13_0 | CNF12_0); //   MOSI  SCK _PORTB_ (_CRH) |= CNF15_1 | CNF13_1; //50 , MODE = 11 _PORTB_ (_CRH) |= MODE15_1 | MODE15_0 | MODE14_1 | MODE14_0 | MODE13_1 | MODE13_0;</span></span></span></span></code> </pre> <br><p>  E, consequentemente, você pode escrever definições para o LAT, o que irá contrair os registros BRR e BSRR: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*** LAT pulse – high, then low */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_pulse() _PORTB_(_BSRR) = (1&lt;&lt;14); _PORTB_(_BRR) = (1&lt;&lt;14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_low() _PORTB_(_BRR) = (1&lt;&lt;14)</span></span></code> </pre> <br><p>  (LAT_low apenas por inércia, de alguma forma sempre foi, deixe-se ficar) </p><br><p>  Agora tudo já está ótimo, simplesmente não está funcionando.  Por ser o STM32, ele economiza eletricidade, o que significa que você precisa habilitar o relógio para os periféricos necessários. </p><br><h2 id="vklyuchaem-taktirovanie">  Ativar o tempo </h2><br><p>  O relógio é responsável pelo relógio, eles também são Clock.  E já podíamos ver a abreviação RCC.  Estamos procurando na documentação: este é Reset e Clock Control. </p><br><p>  Como foi dito acima, felizmente, as pessoas da STM fizeram a parte mais difícil do tópico de timing para nós, muito obrigado por elas (darei um link para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o site de Di Halt</a> para deixar claro o quão <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confuso</a> isso é).  Nós apenas precisamos dos registradores responsáveis ​​por habilitar os relógios periféricos (Peripheral Clock Enable Registers).  Primeiro, encontre o endereço base do RCC, ele está no início do "Cartão de Memória": </p><br><p><img src="https://habrastorage.org/webt/r5/ad/jt/r5adjtnefym8toywwtuxwls-s8e.png"></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _RCC_(mem_offset) (*(volatile uint32_t *)(0x40021000 + (mem_offset)))</span></span></code> </pre> <br><p>  E, em seguida, clique no link para tentar encontrar algo na placa ou, muito melhor, repasse as descrições dos registros de inclusão das seções sobre <em>registros de ativação</em> .  Onde encontramos RCC_APB1ENR e RCC_APB2ENR: </p><br><p><img src="https://habrastorage.org/webt/bt/e7/_6/bte7_6icypsiop8tvagswdtfdpe.png"><br><img src="https://habrastorage.org/webt/pr/d0/l1/prd0l1e_vckbrxqk83wso_h9t5k.png"></p><br><p>  E neles, respectivamente, bits, incluindo clock SPI2, IOPB (porta de E / S B) e funções alternativas (AFIO). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB2ENR 0x18 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB1ENR 0x1C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IOPBEN 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPI2EN 0x4000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AFIOEN 0x0001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   B  .  _RCC_(_APB2ENR) |= IOPBEN | AFIOEN; //  SPI2 _RCC_(_APB1ENR) |= SPI2EN;</span></span></span></span></code> </pre> <br><p>  O código final pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Se houver uma oportunidade e desejar testar, conectamos o DM634 assim: DAI ao PB15, DCK ao PB13, LAT ao PB14.  Alimentamos o motorista de 5 volts, não se esqueça de combinar a terra. </p><br><p><img src="https://habrastorage.org/webt/sx/bz/va/sxbzvazmpgcgwsl0o5pt90gzlnm.jpeg"></p><br><h1 id="stm8-pwm">  STM8 PWM </h1><br><h1 id="shim-na-stm8">  PWM no STM8 </h1><br><p>  Ao planejar este artigo, por exemplo, decidi tentar aprender algumas funcionalidades de um chip desconhecido com apenas uma folha de dados, para não adquirir um sapateiro sem botas.  O STM8 era ideal para esse papel: primeiro, eu tinha duas placas-mãe chinesas com o STM8S103; segundo, não é muito popular; portanto, a tentação de ler e encontrar uma solução na Internet fica na ausência dessas mesmas soluções. </p><br><p>  O chip também possui uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">folha de dados</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">manual de referência RM0016</a> , no primeiro endereço de pinagem e registro, no segundo - tudo o resto.  O STM8 é programado em C no feio IDE <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ST Visual Develop</a> . </p><br><h3 id="taktirovanie-i-vvod-vyvod">  Clock e E / S </h3><br><p>  Por padrão, o STM8 opera com uma frequência de 2 MHz, que deve ser corrigida imediatamente. </p><br><p><img src="https://habrastorage.org/webt/h-/w7/hc/h-w7hclj1kovrmig-mxtjj-n62k.png"><br>  <sub>Relógio HSI (velocidade interna)</sub> <sub><br></sub>  <sub>O relógio HSI é obtido de um oscilador RC interno de 16 MHz com um divisor programável (1 a 8).</sub>  <sub>É definido no registro do divisor de relógio (CLK_CKDIVR).</sub> <sub><br></sub>  <sub>Nota: no início, o oscilador HSI RC com divisor 8 é selecionado como a principal fonte de relógio.</sub> </p><br><p>  Encontramos o endereço do registro na folha de dados, a descrição em refman e vemos que o registro precisa ser limpo: </p><br><pre> <code class="plaintext hljs">#define CLK_CKDIVR *(volatile uint8_t *)0x0050C6 CLK_CKDIVR &amp;= ~(0x18);</code> </pre> <br><p>  Como vamos iniciar o PWM e conectar os LEDs, olhamos para a pinagem: </p><br><p><img src="https://habrastorage.org/webt/uv/ii/kt/uviikt-bigbrftn_ivjxx681d8e.png"></p><br><p>  O chip é pequeno, muitas funções estão suspensas nos mesmos pinos.  O fato de que entre colchetes é "funcionalidade alternativa", é alternado por " <em>opção de bytes</em> " - algo como os fusíveis da Atmega.  Você pode alterar seus valores programaticamente, mas não é necessário, porque  nova funcionalidade é ativada somente após uma reinicialização.  É mais fácil usar o ST Visual Programmer (downloads junto com o Visual Develop) que pode alterar esses bytes.  A pinagem mostra que as conclusões de CH1 e CH2 do primeiro temporizador estão ocultas entre colchetes;  é necessário colocar os bits AFR1 e AFR0 em STVP, e o segundo também transferirá a saída do CH1 do segundo temporizador do PD4 para o PC5. </p><br><p>  Assim, 6 pinos controlam os LEDs: PC6, PC7 e PC3 para o primeiro temporizador, PC5, PD3 e PA3 para o segundo. </p><br><p>  A configuração dos pinos de E / S no STM8 é mais simples e lógica do que no STM32: </p><br><ul><li>  familiarizado com o Atmega <em>Data Direction Register</em> : 1 = saída; </li><li>  o primeiro registro de controle CR1 na saída define o modo push-pull (1) ou dreno aberto (0);  desde que conecto os LEDs ao chip com cátodos, deixo zeros aqui; </li><li>  o segundo registro de controle CR2 na saída define a velocidade do relógio: 1 = 10 MHz </li></ul><br><pre> <code class="plaintext hljs">#define PA_DDR *(volatile uint8_t *)0x005002 #define PA_CR2 *(volatile uint8_t *)0x005004 #define PD_DDR *(volatile uint8_t *)0x005011 #define PD_CR2 *(volatile uint8_t *)0x005013 #define PC_DDR *(volatile uint8_t *)0x00500C #define PC_CR2 *(volatile uint8_t *)0x00500E PA_DDR = (1&lt;&lt;3); //output PA_CR2 |= (1&lt;&lt;3); //fast PD_DDR = (1&lt;&lt;3); //output PD_CR2 |= (1&lt;&lt;3); //fast PC_DDR = ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //output PC_CR2 |= ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //fast</code> </pre> <br><h2 id="nastroyka-shim">  Configuração de PWM </h2><br><p>  Primeiro, vamos definir os termos: </p><br><ul><li>  <strong>Frequência PWM</strong> - frequência com a qual o timer está correndo; </li><li>  <strong>Recarregamento automático, AR</strong> - valor de carregamento automático com o qual o temporizador contará (período de pulso); </li><li>  <strong>Update Event, UEV</strong> - um evento <strong>que ocorre</strong> quando o cronômetro conta como AR; </li><li>  <strong>Ciclo de</strong> trabalho PWM - ciclo de trabalho PWM, geralmente chamado de "ciclo de trabalho"; </li><li>  <strong>Valor</strong> de captura / comparação - valor para captura / comparação, tendo contado até que o timer <em>fará alguma coisa</em> (no caso de PWM, inverte o sinal de saída); </li><li>  <strong>Valor de</strong> pré- <strong>carregamento</strong> - valor pré-carregado.  <em>O valor de comparação</em> não pode mudar enquanto o cronômetro está correndo, caso contrário, o ciclo PWM será interrompido.  Portanto, os novos valores transmitidos são colocados no buffer e retirados dali quando o temporizador chega ao final da contagem e é redefinido; </li><li>  <strong>Modos alinhados à</strong> <strong>borda e alinhados ao</strong> <strong>centro</strong> - alinhamento na borda e no centro, o mesmo que o Atmelovskie <em>Fast PWM</em> e o <em>PWM</em> <em>com correção de fase</em> . </li><li>  <strong>OCiREF, Sinal de referência de comparação de saída</strong> - o sinal de saída de referência, de fato, que no modo PWM está no pino correspondente. </li></ul><br><p>  Como já ficou claro na pinagem, dois temporizadores têm os recursos de PWM - o primeiro e o segundo.  Ambos são de 16 bits, o primeiro possui muitos recursos adicionais (em particular, pode contar tanto para cima quanto para baixo).  Precisamos que ambos trabalhem da mesma maneira, então decidi começar com o segundo obviamente mais pobre, para não usar acidentalmente algo que não está nele.  Algum problema é que a descrição da funcionalidade PWM de todos os cronômetros no manual de referência está no capítulo do primeiro cronômetro (17.5.7 Modo PWM), portanto, é necessário pular para frente e para trás no documento. </p><br><p>  O PWM no STM8 tem uma vantagem importante sobre o PWM Atmega: </p><br><p><img src="https://habrastorage.org/webt/pk/_-/za/pk_-za7gnzo77lvwyw-gvkts1y0.png"><br>  <sub>PWM com alinhamento de arestas</sub> <sub><br></sub>  <sub>Configuração da conta de baixo para cima</sub> <sub><br></sub>  <sub>A contagem ascendente estará ativa se o bit DIR no registro TIM_CR1 for limpo</sub> <sub><br></sub>  <sub>Exemplo</sub> <sub><br></sub>  <sub>O exemplo usa o primeiro modo PWM.</sub>  <sub>O sinal de referência OCiREF PWM é mantido alto enquanto TIM1_CNT &lt;TIM1_CCRi.</sub>  <sub>Caso contrário, é preciso um nível baixo.</sub>  <sub>Se o valor para comparação no TIM1_CCRi for maior que o valor inicial (registre TIM1_ARR), o sinal OCiREF será mantido em 1. <strong>Se o valor para comparação for 0, o OCiREF será mantido em zero.</strong></sub>  <sub>...</sub> </p><br><p>  O temporizador do STM8 durante o <em>evento de atualização</em> verifica primeiro o <em>valor de comparação</em> e somente então fornece um sinal de referência.  O cronômetro da Atmega primeiro embaralha e depois compara, como resultado, ao <code>compare value == 0</code> a saída resulta em uma agulha que precisa ser combatida de alguma forma (por exemplo, invertendo programaticamente a lógica). </p><br><p>  Então, o que queremos fazer: PWM de 8 bits ( <code>AR == 255</code> ), consideramos de baixo para cima o alinhamento ao longo da borda.  Como as lâmpadas estão conectadas ao chip por cátodos, o PWM deve emitir 0 (LED aceso) antes de <em>comparar o valor</em> e 1 depois. </p><br><p>  Já lemos sobre alguns <em>modos PWM</em> , portanto, encontramos o registro desejado do segundo temporizador pesquisando no manual de referência esta frase (18.6.8 - TIMx_CCMR1): </p><br><p><img src="https://habrastorage.org/webt/tt/_3/7s/tt_37syfd9-bib2-ymdxijus9qi.png"><br>  <sub>110: Primeiro modo PWM - ao contar de baixo para cima, o primeiro canal fica ativo enquanto TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Caso contrário, o primeiro canal está inativo.</sub>  <sub>[mais adiante no documento copiar e colar incorreto do timer 1]</sub> <sub><br></sub>  <sub>111: Segundo modo PWM - ao contar de baixo para cima, o primeiro canal fica inativo enquanto TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Caso contrário, o primeiro canal está ativo.</sub> </p><br><p>  Como os LEDs estão conectados aos cátodos MK, o segundo modo é adequado para nós (o primeiro também, mas ainda não sabemos). </p><br><p><img src="https://habrastorage.org/webt/go/ap/x_/goapx_hk5neeok4phdkas_nnfzu.png"><br>  <sub>Bit 3 OC1PE: Ativar pré-carregamento da saída 1</sub> <sub><br></sub>  <sub>0: pré-carregamento do registro com TIMx_CCR1 desativado.</sub>  <sub>Você pode escrever para TIMx_CCR1 a qualquer momento.</sub>  <sub>O novo valor funciona imediatamente.</sub> <sub><br></sub>  <sub>1: O registro de pré-carregamento em TIMx_CCR1 está ativado.</sub>  <sub>As operações de leitura / gravação acessam o registro de pré-carregamento.</sub>  <sub>O valor pré-carregado TIMx_CCR1 é carregado no registrador sombra durante cada evento de atualização.</sub> <sub><br></sub>  <sub>* Nota: para que o modo PWM funcione corretamente, os registros de pré-carregamento devem estar ativados.</sub> <sub>      (  TIMx_CR1   OPM).</sub> <br></p><p> ,  ,  ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCMR1 *(volatile uint8_t *)0x005307 #define TIM2_CCMR2 *(volatile uint8_t *)0x005308 #define TIM2_CCMR3 *(volatile uint8_t *)0x005309 #define PWM_MODE2 0x70 //PWM mode 2, 0b01110000 #define OCxPE 0x08 //preload enable TIM2_CCMR1 = (PWM_MODE2 | OCxPE); TIM2_CCMR2 = (PWM_MODE2 | OCxPE); TIM2_CCMR3 = (PWM_MODE2 | OCxPE);</code> </pre> <br><p> AR     ,   : </p><br><pre> <code class="plaintext hljs">#define TIM2_ARRH *(volatile uint8_t *)0x00530F #define TIM2_ARRL *(volatile uint8_t *)0x005310 TIM2_ARRH = 0; TIM2_ARRL = 255;</code> </pre> <br><p>      -,   ,    .   , ,  256.        TIM2_PSCR     : </p><br><pre> <code class="plaintext hljs">#define TIM2_PSCR *(volatile uint8_t *)0x00530E TIM2_PSCR = 8;</code> </pre> <br><p>       .     <em>Capture/Compare <strong>Enable</strong></em> :  ,      .     ,     , ..       PWM Mode 1. : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCER1 *(volatile uint8_t *)0x00530A #define TIM2_CCER2 *(volatile uint8_t *)0x00530B #define CC1E (1&lt;&lt;0) // CCER1 #define CC2E (1&lt;&lt;4) // CCER1 #define CC3E (1&lt;&lt;0) // CCER2 TIM2_CCER1 = (CC1E | CC2E); TIM2_CCER2 = CC3E;</code> </pre> <br><p>  , ,     TIMx_CR1: </p><br><p><img src="https://habrastorage.org/webt/u8/rj/5v/u8rj5vb2h3oxtgnoe1zzz90fnfm.png"></p><br><pre> <code class="plaintext hljs">#define TIM2_CR1 *(volatile uint8_t *)0x005300 TIM2_CR1 |= 1;</code> </pre> <br><p>    AnalogWrite(),        .    <em>Capture/Compare registers</em> ,      :  8   TIM2_CCRxL    TIM2_CCRxH.    8- ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCR1L *(volatile uint8_t *)0x005312 #define TIM2_CCR2L *(volatile uint8_t *)0x005314 #define TIM2_CCR3L *(volatile uint8_t *)0x005316 void setRGBled(uint8_t r, uint8_t g, uint8_t b) { TIM2_CCR1L = r; TIM2_CCR2L = g; TIM2_CCR3L = b; }</code> </pre> <br><p>   ,       ,   100%  (   255      ).      ,      ,   . </p><br><p>     ,   . </p><br><p>            (  ,   «»   ,        ).            .      , ..       ,   16-     <em>Prescaler High</em>  <em>Low</em> .   …    .   ? </p><br><p>             1,   ,     .  <em>17.7.30 Break register (TIM1_BKR)</em> ,    : </p><br><p><img src="https://habrastorage.org/webt/kb/h8/ue/kbh8ueavruur-vxcqo4fe0c2pdy.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM1_BKR *(volatile uint8_t *)0x00526D TIM1_BKR = (1&lt;&lt;7);</code> </pre> <br><p>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/b9/hb/tn/b9hbtn6retrnp1vpnzxjsjaayoq.jpeg"></p><br><h1 id="stm8-multiplex"> STM8 Multiplex </h1><br><h1 id="multipleksing-na-stm8">   STM8 </h1><br><p>  -   ,          RGB-      .   –  LED-,   ,   -     ,   ,     ( <em>persistence of vision</em> ,   ). -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">-   </a> . </p><br><p>    : </p><br><ul><li>    RGB LED; </li><li>  ,     ; </li><li>    ; </li><li>    RGB LED; </li><li>  ... </li></ul><br><p>   .. ,    ,     «»   .   .   ,    ,         ,   UEV          RGB-. </p><br><p>   LED  ,   «»,      .   : </p><br><pre> <code class="plaintext hljs">uint8_t colors[8][3];</code> </pre> <br><p>  ,     ,        .         </p><br><pre> <code class="plaintext hljs">uint8_t cnt;</code> </pre> <br><h3 id="demuks">  </h3><br><p>     ,   ,  CD74HC238.  – ,    <code>&lt;&lt;</code> .     ( 0, 1  2)      X,        ( <code>1&lt;&lt;X</code> ).        .            ,     –      ,  ,    .   ,       . </p><br><p> CD74HC238      ,       .           P-MOSFET,       , ..   20 ,  <em>absolute maximum ratings</em>  .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> CD74HC238</a>       : </p><br><p><img src="https://habrastorage.org/webt/b3/lz/rv/b3lzrv4xyavibkiwekm3lbvkays.png"><br> <sub>H =   , L =   , X –  </sub> </p><br><p>  E2  E1  , E3, A0, A1  A3   PD5, PC3, PC4  PC5 STM8.      ,   ,     push-pull . </p><br><h2 id="shim">  </h2><br><p>       ,    ,   : </p><br><p> -,      <em>Update Event</em> (UEV),    ,   LED.     <em>Update Interrupt Enable</em>      </p><br><p><img src="https://habrastorage.org/webt/me/kx/6p/mekx6pckxk6qmhkegaudnneach4.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM2_IER *(volatile uint8_t *)0x005303 //enable interrupt TIM2_IER = 1;</code> </pre> <br><p>       ,  <em>ghosting</em> –   .       - ,  ,    UEV,   ,       LED      -   .        (0 =  , 255 =   )      .  I.e.  ,   UEV       . </p><br><p>  : </p><br><pre> <code class="plaintext hljs">//set polarity TIM2_CCER1 |= (CC1P | CC2P); TIM2_CCER2 |= CC3P;</code> </pre> <br><p>   r, g  b  255       . </p><br><h3 id="preryvaniya">  </h3><br><p>    ,            -  .   -    ,     . </p><br><p>         ST Visual Develop,   <code>main.c</code>       <code>stm8_interrupt_vector.c</code> ,    .         <code>NonHandledInterrupt</code> .        . </p><br><p>      ,    : </p><br><p><img src="https://habrastorage.org/webt/ly/ra/gy/lyragyga5skmcrzjojlftjit1qg.png"><br> <sub>13 TIM2 / <br> 14 TIM2 /</sub> </p><br><p>    LED  UEV,     №13. </p><br><p> , -,   <code>stm8_interrupt_vector.c</code>   ,    №13 (IRQ13)    : </p><br><pre> <code class="plaintext hljs">{0x82, TIM2_Overflow}, /* irq13 */</code> </pre> <br><p> -,     <code>main.h</code>  : </p><br><pre> <code class="plaintext hljs">#ifndef __MAIN_H #define __MAIN_H @far @interrupt void TIM2_Overflow (void); #endif</code> </pre> <br><p>  , ,      <code>main.c</code> : </p><br><pre> <code class="plaintext hljs">@far @interrupt void TIM2_Overflow (void) { PD_ODR &amp;= ~(1&lt;&lt;5); //   PC_ODR = (cnt&lt;&lt;3); //      PD_ODR |= (1&lt;&lt;5); //   TIM2_SR1 = 0; //   Update Interrupt Pending cnt++; cnt &amp;= 7; //   LED TIM2_CCR1L = ~colors[cnt][0]; //      TIM2_CCR2L = ~colors[cnt][1]; //     TIM2_CCR3L = ~colors[cnt][2]; // return; }</code> </pre> <br><p>   .     <code>rim</code> –     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programming Manual</a> : </p><br><pre> <code class="plaintext hljs">//enable interrupts _asm("rim");</code> </pre> <br><p>    – <code>sim</code> –  .          «»,         . </p><br><p>   – <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/ri/ul/qs/riulqsjmsnehvg5fb_iofcnjl3u.jpeg"></p><br><p>   -   , ,     .     ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456094/">https://habr.com/ru/post/pt456094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456084/index.html">Kubernetes 1.15: Visão geral dos destaques</a></li>
<li><a href="../pt456086/index.html">Storyboards para iOS: análise dos prós e contras, melhores práticas</a></li>
<li><a href="../pt456088/index.html">Problemas de análise de big data</a></li>
<li><a href="../pt456090/index.html">Introdução ao teste de unidade no Unity</a></li>
<li><a href="../pt456092/index.html">Sete sinais preocupantes de que você depende do clima, mesmo que você não pense</a></li>
<li><a href="../pt456096/index.html">O que o leitor comum de tempos de nerd faz enquanto paira nas nuvens</a></li>
<li><a href="../pt456100/index.html">Agora na nova embalagem - o Kingston A400 no formato M.2 chega ao mercado</a></li>
<li><a href="../pt456102/index.html">Relatórios fáceis em C / C ++</a></li>
<li><a href="../pt456104/index.html">Ezblock Pi - programação sem programação, desta vez para os fãs do Raspberry Pi</a></li>
<li><a href="../pt456106/index.html">Dividimos os recursos mais rapidamente. Experiência de desenvolvimento Android no Badoo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>