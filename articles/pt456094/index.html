<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßïüèª üßëüèΩ‚Äçü§ù‚ÄçüßëüèΩ üë®üèΩ‚Äçüè´ Lemos as fichas t√©cnicas 2: SPI no STM32; Temporizadores PWM e interrup√ß√µes no STM8 üë®üèø‚Äçüç≥ üë©üèª‚Äçüè≠ üñêüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na primeira parte, tentei dizer aos entusiastas eletr√¥nicos que cresceram fora das cal√ßas do Arduino como e por que eles deveriam ler folhas de dados ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lemos as fichas t√©cnicas 2: SPI no STM32; Temporizadores PWM e interrup√ß√µes no STM8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/456094/"><p><img src="https://habrastorage.org/webt/zz/sh/fd/zzshfdfytuphbmlregcazfpxo2a.jpeg"></p><br><p>  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira parte,</a> tentei dizer aos entusiastas eletr√¥nicos que cresceram fora das cal√ßas do Arduino como e por que eles deveriam ler folhas de dados e outras documenta√ß√µes para microcontroladores.  Como o texto era grande, prometi mostrar exemplos pr√°ticos em um artigo separado.  Bem, ele se chamava de carga ... </p><br><p>  Hoje vou mostrar como usar folhas de dados para resolver tarefas bastante simples, mas necess√°rias para muitos projetos, nos controladores STM32 (Blue Pill) e STM8.  Todos os projetos de demonstra√ß√£o s√£o dedicados aos meus LEDs favoritos, vamos acend√™-los em grandes quantidades, para os quais teremos que usar todos os tipos de perif√©ricos interessantes. </p><a name="habracut"></a><br><p>  O texto acabou sendo enorme novamente, por conveni√™ncia, eu estou fazendo o conte√∫do: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">P√≠lula azul STM32: 16 LEDs com driver DM634</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">STM8: Configurando Seis Pinos PWM</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">STM8: 8 LEDs RGB em tr√™s pinos, interrompe</a> </p><br><p>  <em>Disclaimer: Eu n√£o sou engenheiro, n√£o pretendo ter um profundo conhecimento em eletr√¥nica, o artigo √© destinado a amantes como eu.</em>  <em>De fato, como p√∫blico-alvo, eu me considerava dois anos atr√°s.</em>  <em>Se algu√©m me dissesse que n√£o √© assustador ler fichas t√©cnicas em um chip desconhecido, eu n√£o gastaria muito tempo pesquisando alguns c√≥digos na Internet e inventando muletas com tesoura e um curativo.</em> </p><br><p>  <em>No centro deste artigo, est√£o as planilhas de dados, n√£o os projetos; portanto, o c√≥digo pode n√£o ser muito penteado e frequentemente triturado.</em>  <em>Os projetos em si s√£o muito simples, embora adequados para o primeiro contato com o novo chip.</em> </p><br><p>  <em>Espero que meu artigo ajude algu√©m em um est√°gio semelhante em um mergulho por hobby.</em> </p><br><h1 id="stm32">  STM32 </h1><br><h1 id="16-svetodiodov-c-dm634-i-spi">  16 LEDs com DM634 e SPI </h1><br><p>  Um pequeno projeto usando o Blue Pill (STM32F103C8T6) e o driver de LED DM634.  Com a ajuda das folhas de dados, lidaremos com o driver, portas IO STM e configuraremos o SPI. </p><br><h2 id="dm634">  DM634 </h2><br><p>  O chip de Taiwan com 16 sa√≠das PWM de 16 bits, pode ser conectado em cadeias.  O modelo mais jovem de 12 bits √© conhecido pelo projeto dom√©stico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lightpack</a> .  Ao mesmo tempo, escolhendo entre o DM63x e o conhecido TLC5940, parei no DM por v√°rios motivos: 1) O TLC no Aliexpress √© definitivamente falso, mas esse n√£o √©;  2) o DM possui um PWM aut√¥nomo com seu pr√≥prio gerador de frequ√™ncia;  3) poderia ser comprado mais barato em Moscou, e n√£o esperar um pacote com Ali.  Bem, √© claro, foi interessante aprender a gerenciar o chip sozinho e n√£o usar uma biblioteca pronta.  Os chips agora s√£o apresentados principalmente no pacote SSOP24, e s√£o f√°ceis de soldar no adaptador. </p><br><p>  Como o fabricante √© taiwan√™s, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">folha</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dados</a> do chip est√° escrita em ingl√™s chin√™s, o que significa que ser√° divertido.  Primeiro, observe a <em>conex√£o</em> dos <em>pinos</em> ( <em>conex√£o dos pinos</em> ) para entender a qual perna conectar e a descri√ß√£o dos pinos (descri√ß√£o dos pinos).  16 conclus√µes: </p><br><p><img src="https://habrastorage.org/webt/uj/n8/mo/ujn8mooelrxoxg7xzvvfsdh4er8.png"><br>  <sup>Fontes de entrada de corrente cont√≠nua (dreno aberto)</sup> </p><br><p>  <strong>Sa√≠da de</strong> <strong>pia</strong> / <strong>dreno aberto</strong> - dreno;  fonte de corrente de entrada;  sa√≠da ativa conectada ao terra - os LEDs s√£o conectados ao driver por c√°todos.  Eletricamente, √© claro que isso n√£o √© um "dreno aberto", mas nas planilhas de dados essa designa√ß√£o para sa√≠das no modo dreno √© comum. </p><br><p><img src="https://habrastorage.org/webt/yk/bq/p4/ykbqp4ivabirkgahd2d7l_9gjny.png"><br>  <sup>Resistores externos entre REXT e GND para definir o valor da corrente de sa√≠da</sup> </p><br><p>  Um resistor de refer√™ncia √© instalado entre o pino REXT e o terra, que controla a resist√™ncia interna das sa√≠das, veja o gr√°fico na p√°gina 9 da folha de dados.  No DM634, essa resist√™ncia tamb√©m pode ser controlada programaticamente, definindo o <em>brilho global</em> ;  N√£o vou entrar em detalhes neste artigo, apenas coloquei um resistor de 2,2 - 3 kOhm aqui. </p><br><p>  Para entender como controlar o chip, veja a descri√ß√£o da interface do dispositivo: </p><br><p><img src="https://habrastorage.org/webt/7s/5n/to/7s5ntogguqr1yb6fu2l5pchaob8.png"></p><br><p>  Sim, aqui est√°, ingl√™s chin√™s em toda a sua gl√≥ria.  √â problem√°tico traduzir, voc√™ pode entend√™-lo, se desejar, mas h√° outra maneira - observar como a conex√£o √© descrita na folha de dados para o TLC5940 funcionalmente pr√≥ximo: </p><br><p><img src="https://habrastorage.org/webt/qi/za/j2/qizaj2wq08ppbzehiszsd2spqz8.png"><br>  <sub>... Apenas tr√™s pinos s√£o necess√°rios para inserir dados no dispositivo.</sub>  <sub>A borda principal do sinal SCLK muda os dados do pino SIN para o registro interno.</sub>  <sub>Ap√≥s o download de todos os dados, um pequeno sinal XLAT alto captura os dados seriais nos registros internos.</sub>  <sub>Registradores internos - v√°lvulas de acionamento XLAT.</sub>  <sub>Todos os dados s√£o transmitidos no bit mais significativo para a frente.</sub> </p><br><p>  <strong>Trava</strong> - uma trava / trava / bra√ßadeira. <br>  <strong>Borda ascendente</strong> - <strong>borda</strong> principal do impulso <br>  <strong>MSB primeiro</strong> - o bit <strong>mais significativo</strong> (mais √† esquerda) para a frente. <br>  <strong>para registrar dados</strong> - transmita dados sequencialmente (bit a bit). </p><br><p>  A palavra <em>trava √©</em> frequentemente encontrada na documenta√ß√£o para chips e √© traduzida de v√°rias maneiras, por isso me permitirei entender </p><div class="spoiler">  <b class="spoiler_title">pequeno programa educacional</b> <div class="spoiler_text">  O driver de LED √© essencialmente um registro de turno.  ‚ÄúShift‚Äù no nome √© um movimento de dados bit a bit dentro do dispositivo: cada novo bit empurrado para dentro empurra toda a cadeia √† sua frente.  Como ningu√©m quer observar o ca√≥tico piscar dos LEDs durante o turno, o processo ocorre em registros de buffer separados dos de trabalho por uma <em>trava</em> - esse √© um tipo de sala de espera onde os bits s√£o organizados na seq√º√™ncia desejada.  Quando tudo estiver pronto, o obturador se abre e os bits s√£o enviados para o trabalho, substituindo o lote anterior.  A palavra <em>trava</em> na documenta√ß√£o para microcircuitos quase sempre implica em um amortecedor, independentemente da combina√ß√£o usada. </div></div><br><p>  Portanto, a transfer√™ncia de dados para o DM634 √© a seguinte: defina a entrada DAI no bit de ordem superior do LED remoto, puxe o DCK para cima e para baixo;  defina a entrada DAI para o pr√≥ximo bit, puxe DCK;  e assim por diante, at√© que todos os bits sejam transmitidos ( <em>cronometrados</em> ), ap√≥s o que puxamos o LAT.  Isso pode ser feito manualmente ( <em>bit-bang</em> ), mas √© melhor usar a interface SPI afiada especialmente para isso, pois ela √© apresentada em nosso STM32 em duas c√≥pias. </p><br><h2 id="sinyaya-tabletka-stm32f103">  Blue Tablet STM32F103 </h2><br><p>  Introdut√≥rio: Os controladores STM32 s√£o muito mais complicados que o Atmega328 do que podem assustar.  Ao mesmo tempo, por raz√µes de economia de energia, quase todos os perif√©ricos s√£o desativados no in√≠cio e a frequ√™ncia do rel√≥gio √© de 8 MHz a partir de uma fonte interna.  Felizmente, os programadores da STM escreveram o c√≥digo que levou o chip aos 72 MHz "calculados" e os autores de todos os IDEs que eu conhecia o inclu√≠ram no procedimento de inicializa√ß√£o, portanto, n√£o precisamos cronometrar (mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">voc√™ pode, se realmente quiser</a> ).  Mas voc√™ precisa ligar os perif√©ricos. </p><br><p>  Documenta√ß√£o: O popular chip STM32F103C8T6 est√° instalado no Blue Pill, existem dois documentos √∫teis para ele: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Folha de dados</a> para os microcontroladores STM32F103x8 e STM32F103xB; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manual de refer√™ncia</a> para toda a linha STM32F103 e al√©m. </li></ul><br><p>  Em uma folha de dados, podemos estar interessados ‚Äã‚Äãem: </p><br><ul><li>  Pinagens - pinagens de batatas fritas - no caso de decidirmos fazer pranchas; </li><li>  Mapa da mem√≥ria - cart√£o de mem√≥ria para um chip espec√≠fico.  No Manual de Refer√™ncia, h√° um cart√£o para toda a linha, que lista os registros que n√£o est√£o no nosso. </li><li>  Defini√ß√µes dos pinos da tabela - listando as fun√ß√µes principais e alternativas dos pinos;  para a ‚Äúp√≠lula azul‚Äù na Internet, voc√™ pode encontrar fotos mais convenientes com uma lista de pinos e suas fun√ß√µes.  Portanto, pesquise imediatamente a pinagem do Blue Pill no Google e mantenha esta foto √† m√£o: </li></ul><br><p><img src="https://habrastorage.org/webt/_q/q_/o4/_qq_o4hwzc3k1nzqluqtaqpuye0.png"><br>  <em>Nota: na imagem da Internet, ocorreu um erro nos coment√°rios, pelo qual obrigado.</em>  <em>A imagem foi substitu√≠da, mas esta √© uma li√ß√£o - √© melhor verificar informa√ß√µes de folhas que n√£o s√£o de dados.</em> </p><br><p>  Removemos a folha de dados, abrimos o Manual de Refer√™ncia, agora apenas a usamos. <br>  Procedimento: lidamos com entrada / sa√≠da padr√£o, configuramos o SPI, ligamos os perif√©ricos desejados. </p><br><h3 id="vvod-vyvod">  Entrada-sa√≠da </h3><br><p>  A E / S do Atmega328 √© extremamente simples, e √© por isso que a abund√¢ncia de op√ß√µes do STM32 pode ser confusa.  Agora, precisamos apenas de conclus√µes, mas mesmo existem quatro op√ß√µes: </p><br><p><img src="https://habrastorage.org/webt/qv/ao/t6/qvaot6ql0b4z6c0bvv71dumovji.png"><br>  <sub>sa√≠da de dreno aberto, sa√≠da push-pull, sa√≠da push-pull alternativa, dreno aberto alternativo</sub> </p><br><p>  ‚Äú <em>Push-pull</em> ‚Äù ( <em>push-pull</em> ) - a conclus√£o usual da Arduina, o pino pode ser ALTO ou BAIXO.  Mas com o "dreno aberto" existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dificuldades</a> , embora de fato tudo seja simples aqui: </p><br><p><img src="https://habrastorage.org/webt/qa/e-/al/qae-alom88ushdmghd8wcu2l0q4.png"><br><img src="https://habrastorage.org/webt/en/oh/ny/enohnyxpb5u8cs4_t_m-cmtxbwy.png"><br>  <sub>Configura√ß√£o de sa√≠da / quando a porta √© atribu√≠da √† sa√≠da: / buffer de sa√≠da est√° ativado: / - modo de dreno aberto: ‚Äú0‚Äù ativa N-MOS no registro de sa√≠da, ‚Äú1‚Äù deixa a porta no modo Hi-Z no registro de sa√≠da (o P-MOS n√£o est√° ativado ) / - modo push-pull: ‚Äú0‚Äù no registro de sa√≠da ativa o N-MOS, ‚Äú1‚Äù no registro de sa√≠da ativa o P-MOS.</sub> </p><br><p>  Toda a diferen√ßa entre dreno aberto e <em>push-pull</em> √© que, no primeiro pino, ele n√£o pode aceitar o estado ALTO: ao gravar uma unidade no registro de sa√≠da, ele muda para <em>alta imped√¢ncia</em> <em>-Z</em> ).  Ao gravar zero, o pino nos dois modos se comporta da mesma maneira, tanto l√≥gica quanto eletricamente. </p><br><p>  No modo de sa√≠da normal, o pino simplesmente traduz o conte√∫do do registro de sa√≠da.  Na "alternativa" √© controlado pela periferia correspondente (ver 9.1.4): </p><br><p><img src="https://habrastorage.org/webt/wu/mz/fv/wumzfvlk-fueikoig1wg6npj59u.png"><br>  <sub>Se o bit da porta estiver configurado como uma sa√≠da de fun√ß√£o alternativa, o registro de sa√≠da ser√° desativado e o pino ser√° conectado ao sinal de sa√≠da perif√©rico.</sub> </p><br><p>  Uma funcionalidade alternativa para cada pino √© descrita na folha de dados das <em>Defini√ß√µes de pinos</em> e est√° na imagem baixada.  Quando perguntado o que fazer se o pino tiver v√°rias fun√ß√µes alternativas, a resposta fornece uma nota de rodap√© na folha de dados: </p><br><p><img src="https://habrastorage.org/webt/g1/hq/mi/g1hqmixkcdtdiius8u45hjfzagy.png"><br>  <sub>Se v√°rios blocos perif√©ricos usarem o mesmo pino, para evitar conflitos entre fun√ß√µes alternativas, apenas um bloco perif√©rico deve ser usado ao mesmo tempo, alternando usando o bit de ativa√ß√£o do rel√≥gio perif√©rico (no registro RCC correspondente).</sub> </p><br><p>  Finalmente, os pinos no modo de sa√≠da tamb√©m t√™m uma velocidade de clock.  Esse √© outro recurso de economia de energia; no nosso caso, basta configur√°-lo ao m√°ximo e esquec√™-lo. </p><br><p>  Ent√£o, como usamos SPI, dois pinos (com dados e um sinal de rel√≥gio) devem ser uma "fun√ß√£o alternativa de press√£o" e outro (LAT) deve ser "press√£o normal".  Mas antes de atribu√≠-los, lidaremos com o SPI. </p><br><h3 id="spi">  SPI </h3><br><div class="spoiler">  <b class="spoiler_title">Outro pequeno programa educacional</b> <div class="spoiler_text"><p>  SPI ou Serial Peripherial Interface (interface perif√©rica serial) - uma interface simples e muito eficaz para comunica√ß√£o de MK com outros MK e o mundo exterior em geral.  O princ√≠pio de sua opera√ß√£o j√° foi descrito acima, sobre o driver de LED chin√™s (no manual de refer√™ncia, consulte a se√ß√£o 25).  O SPI pode operar nos modos mestre ("mestre") e escravo ("escravo").  O SPI possui quatro canais b√°sicos, dos quais nem todos podem estar envolvidos: </p><br><ul><li>  MOSI, Sa√≠da Mestre / Entrada Escrava: este pino no modo mestre envia, mas no modo escravo recebe dados; </li><li>  MISO, Master Input / Slave Output: pelo contr√°rio, no mestre aceita, no escravo - d√°; </li><li>  SCK, Serial Clock: define a frequ√™ncia da transfer√™ncia de dados no mestre ou recebe um sinal de rel√≥gio no escravo.  Bate essencialmente os bits; </li><li>  SS, Slave Select: atrav√©s deste canal, o escravo aprende que quer algo dele.  No STM32, √© chamado NSS, onde N = negativo, ou seja,  o controlador se torna escravo se houver terra neste canal.  Combina bem com o modo Open Drain Output, mas essa √© uma hist√≥ria diferente. </li></ul></div></div><br><p>  Como todo o resto, o SPI no STM32 √© rico em funcionalidades, o que dificulta a compreens√£o.  Por exemplo, ele pode funcionar n√£o apenas com o SPI, mas tamb√©m com a interface I2S e, na documenta√ß√£o em que suas descri√ß√µes s√£o misturadas, √© necess√°rio cortar o excesso em tempo h√°bil.  Nossa tarefa √© extremamente simples: voc√™ s√≥ precisa enviar dados usando apenas MOSI e SCK.  Vamos para a se√ß√£o 25.3.4 (comunica√ß√£o half-duplex), onde encontramos <em>1 rel√≥gio e 1 fio de dados unidirecional</em> (1 sinal de rel√≥gio e 1 fluxo de dados unidirecional): </p><br><p><img src="https://habrastorage.org/webt/3o/wg/pm/3owgpmokhpahr9rkftf5ns2lclw.png"><br>  <sub>Nesse modo, o aplicativo usa o SPI no modo somente transmiss√£o ou somente recebimento.</sub>  <sub>/ O modo somente transmiss√£o √© semelhante ao modo duplex: os dados s√£o transmitidos no pino transmissor (MOSI no modo mestre ou MISO no modo escravo), e o pino receptor (MISO ou MOSI, respectivamente) pode ser usado como um pino de entrada / sa√≠da regular.</sub>  <sub>Nesse caso, √© suficiente que o aplicativo ignore o buffer Rx (se voc√™ o ler, n√£o haver√° dados transmitidos).</sub> </p><br><p>  Bem, o pino MISO est√° livre de n√≥s, vamos conectar o sinal LAT a ele.  Lidamos com o Slave Select, que pode ser controlado programaticamente no STM32, o que √© extremamente conveniente.  Lemos o par√°grafo com o mesmo nome na se√ß√£o 25.3.1 da Descri√ß√£o Geral da SPI: </p><br><p><img src="https://habrastorage.org/webt/8t/ng/jf/8tngjfopfxskwyq_gl8tlogcp2o.png"><br>  <sub>Controle de programa NSS (SSM = 1) / Informa√ß√µes sobre a sele√ß√£o do escravo est√£o contidas no bit SSI do registro SPI_CR1.</sub>  <sub>O pino NSS externo permanece livre para outras necessidades do aplicativo.</sub> </p><br><p>  √â hora de escrever nos registros.  Decidi usar o SPI2, estamos procurando o endere√ßo base na folha de dados - na se√ß√£o 3.3 Mapa de Mem√≥ria: </p><br><p><img src="https://habrastorage.org/webt/os/xd/6p/osxd6pdv5zfwombf5xflzfikj5c.png"></p><br><p>  Bem, come√ßamos: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI2_(mem_offset) (*(volatile uint32_t *)(0x40003800 + (mem_offset)))</span></span></code> </pre> <br><p>  Abrimos a se√ß√£o 25.3.3 com o ditado "Configurando SPI no modo mestre": </p><br><p><img src="https://habrastorage.org/webt/s8/ah/o5/s8aho5pbdv55j5vhhwecvewrm3m.png"></p><br><p>  <strong>1. Defina a velocidade do rel√≥gio serial com os bits BR [2: 0] no registro SPI_CR1.</strong> </p><br><p>  Os registros s√£o coletados na se√ß√£o do manual de refer√™ncia com o mesmo nome.  CR1 tem um <em>deslocamento de endere√ßo</em> ( <em>deslocamento de endere√ßo</em> ) de 0x00; por padr√£o, todos os bits s√£o redefinidos ( <em>valor de redefini√ß√£o</em> 0x0000): </p><br><p><img src="https://habrastorage.org/webt/vt/46/um/vt46umrvbimjon75durupo3zsao.png"></p><br><p>  Os bits BR definem o divisor de frequ√™ncia do rel√≥gio do controlador, determinando assim a frequ√™ncia na qual o SPI ir√° operar.  Teremos uma frequ√™ncia de STM32 de 72 MHz, o driver de LED, de acordo com sua folha de dados, trabalha com uma frequ√™ncia de at√© 25 MHz, portanto, √© necess√°rio dividir por quatro (BR [2: 0] = 001). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_CR1 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_0 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_1 0x0010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BR_2 0x0020 _SPI2_ (_SPI_CR1) |= BR_0;</span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// pclk/4</span></span></span></span></code> </pre> <br><p>  <strong>2. Defina os bits CPOL e CPHA para determinar o relacionamento entre a transfer√™ncia de dados e o clock da interface serial (consulte o diagrama na p√°gina 240)</strong> </p><br><p>  Como estamos lendo as fichas de dados aqui, e sem considerar os circuitos, vamos estudar melhor a descri√ß√£o textual dos bits CPOL e CPHA na p√°gina 704 (Descri√ß√£o Geral da SPI): </p><br><p><img src="https://habrastorage.org/webt/2h/pj/in/2hpjinoa65388hdfarcc9lwnqok.png"><br>  <sub>Fase do rel√≥gio e polaridade</sub> <sub><br></sub>  <sub>Usando os bits CPOL e CPHA do registro SPI_CR1, quatro op√ß√µes para relacionamentos de tempo podem ser selecionadas programaticamente.</sub>  <sub>O bit CPOL (polaridade do rel√≥gio) controla o estado do rel√≥gio quando nenhum dado est√° sendo transmitido.</sub>  <sub>Este bit controla os modos mestre e escravo.</sub>  <sub>Se o CPOL for redefinido, o pino SCK estar√° baixo no modo ocioso.</sub>  <sub>Se o bit CPOL estiver definido, o pino SCK estar√° em um n√≠vel alto no modo ocioso.</sub> <sub><br></sub>  <sub>Se o bit CPHA (fase do rel√≥gio) estiver definido, a segunda extremidade do sinal SCK atua como um trap-gate do bit alto (descendente se o CPOL for limpo ou ascendente se o CPOL estiver definido).</sub>  <sub>Os dados s√£o capturados pela segunda altera√ß√£o no sinal do rel√≥gio.</sub>  <sub>Se o bit CPHA for apagado, a borda principal do sinal SCK atua como um trap-gate do bit alto (para baixo se o CPOL estiver definido ou para cima se o CPOL for apagado).</sub>  <sub>Os dados s√£o capturados pela primeira altera√ß√£o no sinal do rel√≥gio.</sub> </p><br><p>  Tendo fumado esse conhecimento, conclu√≠mos que os dois bits devem permanecer zeros, porque  precisamos que o sinal SCK permane√ßa baixo quando n√£o estiver em uso e que os dados sejam transmitidos ao longo da borda principal do pulso (consulte <em>Rising Edge</em> na folha de dados do DM634). </p><br><p>  A prop√≥sito, aqui encontramos pela primeira vez um recurso de vocabul√°rio nas folhas de dados do ST: nelas a frase ‚Äúredefinir bit para zero‚Äù √© escrita <em>para redefinir um pouco</em> e n√£o <em>para limpar um pouco</em> , como, por exemplo, no Atmega. </p><br><p>  <strong>3. Defina o bit DFF para definir um formato de bloco de dados de 8 ou 16 bits.</strong> </p><br><p>  Peguei especificamente o DM634 de 16 bits, para n√£o me preocupar com a transmiss√£o de dados PWM de 12 bits, como o DM633.  DFF faz sentido colocar em uma unidade: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DFF 0x0800 _SPI2_ (_SPI_CR1) |= DFF; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 16-bit mode</span></span></span></span></code> </pre> <br><p>  <strong>4. Configure o bit LSBFIRST no registro SPI_CR1 para determinar o formato do bloco</strong> </p><br><p>  LSBFIRST, como o pr√≥prio nome indica, avan√ßa o bit de ordem inferior.  Mas o DM634 deseja receber dados come√ßando com o bit alto.  Portanto, deixamos isso de lado. </p><br><p>  <strong>5. No modo de hardware, se for necess√°ria a entrada do pino NSS, envie um sinal alto para o pino NSS durante toda a sequ√™ncia de transfer√™ncia de bytes.</strong>  <strong>No modo de programa NSS, defina os bits SSM e SSI no registro SPI_CR1.</strong>  <strong>Se o pino NSS funcionar na sa√≠da, apenas o bit SSOE deve ser definido.</strong> </p><br><p>  Instale o SSM e o SSI para esquecer o modo de hardware NSS: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSI 0x0100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SSM 0x0200 _SPI2_ (_SPI_CR1) |= SSM | SSI; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//enable software control of SS, SS high</span></span></span></span></code> </pre> <br><p>  <strong>6. Os bits MSTR e SPE devem ser configurados (eles permanecem configurados apenas se um sinal alto for aplicado ao NSS)</strong> </p><br><p>  Na verdade, com esses bits, atribu√≠mos nosso SPI como mestre e o ativamos: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MSTR 0x0004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPE 0x0040 _SPI2_ (_SPI_CR1) |= MSTR; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//SPI master //  ,  SPI _SPI2_ (_SPI_CR1) |= SPE;</span></span></span></span></code> </pre> <br><p>  O SPI est√° configurado, vamos escrever fun√ß√µes que enviam bytes para o driver imediatamente.  Continuamos a ler 25.3.3 "Configurando o SPI no modo mestre": </p><br><p><img src="https://habrastorage.org/webt/sb/rg/u5/sbrgu5xwvaj7vc8a9rk2guxfdeq.png"><br>  <sub>Procedimento de transfer√™ncia de dados</sub> <sub><br></sub>  <sub>A transmiss√£o come√ßa quando um byte √© gravado no buffer Tx.</sub> <sub><br></sub>  <sub>O byte de dados √© carregado no registro de deslocamento em modo <strong>paralelo</strong> (a partir do barramento interno) durante a transmiss√£o do primeiro bit, ap√≥s o qual √© transmitido em modo <strong>serial</strong> para o pino MOSI, o primeiro ou o √∫ltimo bit para frente, dependendo da configura√ß√£o do bit LSBFIRST no registro CPI_CR1.</sub>  <sub>O sinalizador TXE √© definido depois que os dados s√£o transferidos <strong>do buffer Tx para o registrador de deslocamento</strong> e uma interrup√ß√£o tamb√©m √© criada se o bit TXEIE for definido no registrador CPI_CR1.</sub> </p><br><p>  Destacamos algumas palavras na tradu√ß√£o para chamar a aten√ß√£o para um recurso da implementa√ß√£o do SPI nos controladores STM.  No Atmega, o sinalizador TXE ( <em>Tx Vazio</em> , Tx est√° vazio e pronto para receber dados) √© definido somente ap√≥s a <em>sa√≠da do</em> byte inteiro.  E aqui esse sinalizador √© definido depois que o byte √© inserido no registro de deslocamento interno.  Como √© empurrado para l√° por todos os bits simultaneamente (em paralelo) e, em seguida, os dados s√£o transmitidos seq√ºencialmente, o TXE √© definido antes do envio completo do byte.  Isso √© importante porque  no caso de nosso driver de LED, precisamos puxar o pino LAT depois de enviar <em>todos os</em> dados, ou seja,  Somente a bandeira TXE n√£o ser√° suficiente para n√≥s. </p><br><p>  E isso significa que precisamos de alguma outra bandeira.  Vamos ver em 25.3.7 - "Sinalizadores de status": </p><br><p><img src="https://habrastorage.org/webt/_d/vn/jj/_dvnjjudvkmdyutpylvwfkfknng.png"><br>  &lt;...&gt; <br><img src="https://habrastorage.org/webt/3y/wv/nd/3ywvndaij5blabzqfq2n6wzdbfe.png"><br>  <sub>Bandeira OCUPADA</sub> <sub><br></sub>  <sub>O sinalizador BSY √© definido e redefinido pelo hardware (gravar nele n√£o afeta nada).</sub>  <sub>O sinalizador BSY indica o estado da camada de comunica√ß√£o SPI.</sub> <sub><br></sub>  <sub>√â redefinido:</sub> <sub><br></sub>  <sub>quando a transfer√™ncia estiver conclu√≠da (exceto no modo mestre, se a transfer√™ncia for cont√≠nua)</sub> <sub><br></sub>  <sub>quando o SPI est√° desativado</sub> <sub><br></sub>  <sub>quando ocorre um erro no modo do assistente (MODF = 1)</sub> <sub><br></sub>  <sub>Se a transmiss√£o n√£o for cont√≠nua, a bandeira BSY √© apagada entre cada transmiss√£o de dados.</sub> </p><br><p>  Ok, venha a calhar.  Descobrimos onde o buffer Tx est√° localizado.  Para fazer isso, leia o "Registro de dados SPI": </p><br><p><img src="https://habrastorage.org/webt/sj/gk/o7/sjgko7dcnefgkio4jk9xrwt67bs.png"><br>  <sub>Bits 15: 0 DR [15: 0] Registro de Dados</sub> <sub><br></sub>  <sub>Dados recebidos ou dados para transmiss√£o.</sub> <sub><br></sub>  <sub>O registro de dados √© dividido em dois buffers - um para grava√ß√£o (buffer de transmiss√£o) e o segundo para leitura (buffer de recebimento).</sub>  <sub>A grava√ß√£o no registro de dados grava no buffer Tx e a leitura no registro de dados retornar√° o valor contido no buffer Rx.</sub> </p><br><p>  Bem, o registro de status, onde h√° sinalizadores TXE e BSY: </p><br><p><img src="https://habrastorage.org/webt/-k/pi/q9/-kpiq96tkpbqvvr1vly6nlzpwoe.png"></p><br><p>  Escrevemos: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_DR 0x0C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _SPI_SR 0x08 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BSY 0x0080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TXE 0x0002 void dm_shift16(uint16_t value) { _SPI2_(_SPI_DR) = value; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//send 2 bytes while (!(_SPI2_(_SPI_SR) &amp; TXE)); //wait until they're sent }</span></span></span></span></code> </pre> <br><p>  Bem, como precisamos transmitir 16 bytes duas vezes, de acordo com o n√∫mero de sa√≠das do driver de LED, algo como isto: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendLEDdata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LAT_low(); <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> k = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k--; dm_shift16(leds[k]); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_SPI2_(_SPI_SR) &amp; BSY); <span class="hljs-comment"><span class="hljs-comment">// finish transmission LAT_pulse(); }</span></span></code> </pre> <br><p>  Mas ainda n√£o sabemos como puxar o pino LAT, portanto, retornaremos √† E / S. </p><br><h3 id="naznachaem-piny">  Atribuir pinos </h3><br><p>  No STM32F1, os registros respons√°veis ‚Äã‚Äãpelo estado dos pinos s√£o bastante incomuns.  √â claro que existem mais do que o Atmega, mas eles tamb√©m diferem de outros chips STM.  Se√ß√£o 9.1 Descri√ß√£o geral do GPIO: </p><br><p><img src="https://habrastorage.org/webt/ky/w9/ks/kyw9ksdar6bepxsf1u7kvyejfwm.png"><br>  <sub>Cada uma das portas de entrada / sa√≠da de uso geral <em>(GPIO)</em> possui dois registros de configura√ß√£o de 32 bits (GPIOx_CRL e GPIOx_CRH), dois registros de dados de 32 bits (GPIOx_IDR e GPIOx_ODR), um registro de configura√ß√£o / redefini√ß√£o de 32 bits (GPIOx_BSRR), 16 bits um registro de redefini√ß√£o (GPIOx_BRR) e um registro de bloco de 32 bits (GPIOx_LCKR).</sub> </p><br><p>  Incomuns, al√©m de inconvenientes, os dois primeiros registradores est√£o aqui, porque 16 pinos de porta est√£o espalhados sobre eles no formato "quatro bits por irm√£o".  I.e.  os pinos de zero a s√©timo est√£o na CRL e o restante na CRH.  Ao mesmo tempo, o restante dos registradores se encaixam com √™xito nos bits de todos os pinos da porta - muitas vezes permanecendo meio "reservados". </p><br><p>  Para simplificar, comece no final da lista. </p><br><p>  N√£o precisamos de um registro de blocos. </p><br><p>  Os registros de configura√ß√£o e redefini√ß√£o s√£o bastante engra√ßados, pois eles se duplicam parcialmente: voc√™ pode escrever tudo apenas em BSRR, onde os 16 bits mais altos redefinir√£o o pino para zero e os inferiores - configurados para 1, ou use tamb√©m BRR, os 16 bits inferiores dos quais apenas redefinem o pino .  Eu gosto da segunda op√ß√£o.  Esses registros s√£o importantes, pois fornecem acesso at√¥mico aos pinos: </p><br><p><img src="https://habrastorage.org/webt/tr/g9/tq/trg9tqg8ksmhfiaokjbslfvvhny.png"><br><img src="https://habrastorage.org/webt/yb/dm/da/ybdmdaayb-f0np1pawunxobfbaa.png"><br>  <sub>Instala√ß√£o at√¥mica ou redefini√ß√£o</sub> <sub><br></sub>  <sub>Voc√™ n√£o precisa desativar interrup√ß√µes ao programar GPIOx_ODR no n√≠vel de bit: √© poss√≠vel alterar um ou mais bits com uma opera√ß√£o de grava√ß√£o at√¥mica APB2.</sub>  <sub>Isso √© poss√≠vel escrevendo ‚Äú1‚Äù no registro de configura√ß√£o / redefini√ß√£o (GPIOx_BSRR ou, somente para redefini√ß√£o, em GPIOx_BRR), o bit que voc√™ deseja alterar.</sub>  <sub>Outros bits permanecer√£o inalterados.</sub> </p><br><p>  Os registradores de dados t√™m nomes bastante falantes - IDR = <em>Input</em> Direction Register, registro de entrada;  ODR = Registro da dire√ß√£o de sa√≠da, registro de sa√≠da.  No projeto atual, n√£o precisaremos deles. </p><br><p>  E, finalmente, os registros de controle.  Como estamos interessados ‚Äã‚Äãnos pinos do segundo SPI, ou seja, PB13, PB14 e PB15, analisamos imediatamente o CRH: </p><br><p><img src="https://habrastorage.org/webt/ei/_v/it/ei_vitm85yhwasuf5zjbhksfsoq.png"></p><br><p>  E vemos que ser√° necess√°rio escrever algo em bits do dia 20 ao 31. </p><br><p>  J√° descobrimos o que queremos dos pinos, ent√£o aqui eu posso fazer sem uma captura de tela, basta dizer que MODE define a dire√ß√£o (entrada, se ambos os bits est√£o definidos como 0) e a velocidade do pino (precisamos de 50MHz, ou seja, ambos pino em ‚Äú1‚Äù), e CNF define o modo: normal ‚Äúpush-push‚Äù - 00, ‚Äúalternativa‚Äù - 10. Por padr√£o, como vemos acima, todos os pinos t√™m o terceiro bit da parte inferior (CNF0), ele os define como modo de <em>entrada flutuante</em> . </p><br><p>  Como pretendo fazer outra coisa com esse chip, para simplificar, defini todos os valores poss√≠veis de MODE e CNF para os registros de controle inferior e superior. </p><br><div class="spoiler">  <b class="spoiler_title">Bem, algo assim</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF0_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF1_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF2_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF3_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF4_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF5_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF6_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF7_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_0 0x00000004 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF8_1 0x00000008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_0 0x00000040 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF9_1 0x00000080 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_0 0x00000400 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF10_1 0x00000800 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_0 0x00004000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF11_1 0x00008000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_0 0x00040000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF12_1 0x00080000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_0 0x00400000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF13_1 0x00800000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_0 0x04000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF14_1 0x08000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_0 0x40000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CNF15_1 0x80000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE0_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE1_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE2_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE3_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE4_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE5_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE6_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE7_1 0x20000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_0 0x00000001 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE8_1 0x00000002 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_0 0x00000010 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE9_1 0x00000020 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_0 0x00000100 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE10_1 0x00000200 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_0 0x00001000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE11_1 0x00002000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_0 0x00010000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE12_1 0x00020000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_0 0x00100000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE13_1 0x00200000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_0 0x01000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE14_1 0x02000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_0 0x10000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODE15_1 0x20000000</span></span></code> </pre> </div></div><br><p>  Nossos pinos est√£o localizados na porta B (o endere√ßo base √© 0x40010C00), c√≥digo: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _PORTB_(mem_offset) (*(volatile uint32_t *)(0x40010C00 + (mem_offset))) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BRR 0x14 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _BSRR 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRL 0x00 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRH 0x04 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  SPI2: MOSI  B15, CLK  B13 //LAT     MISO ‚Äì B14 //  ,      _PORTB_ (_CRH) &amp;= ~(CNF15_0 | CNF14_0 | CNF13_0 | CNF12_0); //   MOSI  SCK _PORTB_ (_CRH) |= CNF15_1 | CNF13_1; //50 , MODE = 11 _PORTB_ (_CRH) |= MODE15_1 | MODE15_0 | MODE14_1 | MODE14_0 | MODE13_1 | MODE13_0;</span></span></span></span></code> </pre> <br><p>  E, consequentemente, voc√™ pode escrever defini√ß√µes para o LAT, o que ir√° contrair os registros BRR e BSRR: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*** LAT pulse ‚Äì high, then low */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_pulse() _PORTB_(_BSRR) = (1&lt;&lt;14); _PORTB_(_BRR) = (1&lt;&lt;14) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAT_low() _PORTB_(_BRR) = (1&lt;&lt;14)</span></span></code> </pre> <br><p>  (LAT_low apenas por in√©rcia, de alguma forma sempre foi, deixe-se ficar) </p><br><p>  Agora tudo j√° est√° √≥timo, simplesmente n√£o est√° funcionando.  Por ser o STM32, ele economiza eletricidade, o que significa que voc√™ precisa habilitar o rel√≥gio para os perif√©ricos necess√°rios. </p><br><h2 id="vklyuchaem-taktirovanie">  Ativar o tempo </h2><br><p>  O rel√≥gio √© respons√°vel pelo rel√≥gio, eles tamb√©m s√£o Clock.  E j√° pod√≠amos ver a abrevia√ß√£o RCC.  Estamos procurando na documenta√ß√£o: este √© Reset e Clock Control. </p><br><p>  Como foi dito acima, felizmente, as pessoas da STM fizeram a parte mais dif√≠cil do t√≥pico de timing para n√≥s, muito obrigado por elas (darei um link para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o site de Di Halt</a> para deixar claro o qu√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">confuso</a> isso √©).  N√≥s apenas precisamos dos registradores respons√°veis ‚Äã‚Äãpor habilitar os rel√≥gios perif√©ricos (Peripheral Clock Enable Registers).  Primeiro, encontre o endere√ßo base do RCC, ele est√° no in√≠cio do "Cart√£o de Mem√≥ria": </p><br><p><img src="https://habrastorage.org/webt/r5/ad/jt/r5adjtnefym8toywwtuxwls-s8e.png"></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _RCC_(mem_offset) (*(volatile uint32_t *)(0x40021000 + (mem_offset)))</span></span></code> </pre> <br><p>  E, em seguida, clique no link para tentar encontrar algo na placa ou, muito melhor, repasse as descri√ß√µes dos registros de inclus√£o das se√ß√µes sobre <em>registros de ativa√ß√£o</em> .  Onde encontramos RCC_APB1ENR e RCC_APB2ENR: </p><br><p><img src="https://habrastorage.org/webt/bt/e7/_6/bte7_6icypsiop8tvagswdtfdpe.png"><br><img src="https://habrastorage.org/webt/pr/d0/l1/prd0l1e_vckbrxqk83wso_h9t5k.png"></p><br><p>  E neles, respectivamente, bits, incluindo clock SPI2, IOPB (porta de E / S B) e fun√ß√µes alternativas (AFIO). </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB2ENR 0x18 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _APB1ENR 0x1C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> IOPBEN 0x0008 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SPI2EN 0x4000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AFIOEN 0x0001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//   B  .  _RCC_(_APB2ENR) |= IOPBEN | AFIOEN; //  SPI2 _RCC_(_APB1ENR) |= SPI2EN;</span></span></span></span></code> </pre> <br><p>  O c√≥digo final pode ser encontrado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Se houver uma oportunidade e desejar testar, conectamos o DM634 assim: DAI ao PB15, DCK ao PB13, LAT ao PB14.  Alimentamos o motorista de 5 volts, n√£o se esque√ßa de combinar a terra. </p><br><p><img src="https://habrastorage.org/webt/sx/bz/va/sxbzvazmpgcgwsl0o5pt90gzlnm.jpeg"></p><br><h1 id="stm8-pwm">  STM8 PWM </h1><br><h1 id="shim-na-stm8">  PWM no STM8 </h1><br><p>  Ao planejar este artigo, por exemplo, decidi tentar aprender algumas funcionalidades de um chip desconhecido com apenas uma folha de dados, para n√£o adquirir um sapateiro sem botas.  O STM8 era ideal para esse papel: primeiro, eu tinha duas placas-m√£e chinesas com o STM8S103; segundo, n√£o √© muito popular; portanto, a tenta√ß√£o de ler e encontrar uma solu√ß√£o na Internet fica na aus√™ncia dessas mesmas solu√ß√µes. </p><br><p>  O chip tamb√©m possui uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">folha de dados</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">manual de refer√™ncia RM0016</a> , no primeiro endere√ßo de pinagem e registro, no segundo - tudo o resto.  O STM8 √© programado em C no feio IDE <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ST Visual Develop</a> . </p><br><h3 id="taktirovanie-i-vvod-vyvod">  Clock e E / S </h3><br><p>  Por padr√£o, o STM8 opera com uma frequ√™ncia de 2 MHz, que deve ser corrigida imediatamente. </p><br><p><img src="https://habrastorage.org/webt/h-/w7/hc/h-w7hclj1kovrmig-mxtjj-n62k.png"><br>  <sub>Rel√≥gio HSI (velocidade interna)</sub> <sub><br></sub>  <sub>O rel√≥gio HSI √© obtido de um oscilador RC interno de 16 MHz com um divisor program√°vel (1 a 8).</sub>  <sub>√â definido no registro do divisor de rel√≥gio (CLK_CKDIVR).</sub> <sub><br></sub>  <sub>Nota: no in√≠cio, o oscilador HSI RC com divisor 8 √© selecionado como a principal fonte de rel√≥gio.</sub> </p><br><p>  Encontramos o endere√ßo do registro na folha de dados, a descri√ß√£o em refman e vemos que o registro precisa ser limpo: </p><br><pre> <code class="plaintext hljs">#define CLK_CKDIVR *(volatile uint8_t *)0x0050C6 CLK_CKDIVR &amp;= ~(0x18);</code> </pre> <br><p>  Como vamos iniciar o PWM e conectar os LEDs, olhamos para a pinagem: </p><br><p><img src="https://habrastorage.org/webt/uv/ii/kt/uviikt-bigbrftn_ivjxx681d8e.png"></p><br><p>  O chip √© pequeno, muitas fun√ß√µes est√£o suspensas nos mesmos pinos.  O fato de que entre colchetes √© "funcionalidade alternativa", √© alternado por " <em>op√ß√£o de bytes</em> " - algo como os fus√≠veis da Atmega.  Voc√™ pode alterar seus valores programaticamente, mas n√£o √© necess√°rio, porque  nova funcionalidade √© ativada somente ap√≥s uma reinicializa√ß√£o.  √â mais f√°cil usar o ST Visual Programmer (downloads junto com o Visual Develop) que pode alterar esses bytes.  A pinagem mostra que as conclus√µes de CH1 e CH2 do primeiro temporizador est√£o ocultas entre colchetes;  √© necess√°rio colocar os bits AFR1 e AFR0 em STVP, e o segundo tamb√©m transferir√° a sa√≠da do CH1 do segundo temporizador do PD4 para o PC5. </p><br><p>  Assim, 6 pinos controlam os LEDs: PC6, PC7 e PC3 para o primeiro temporizador, PC5, PD3 e PA3 para o segundo. </p><br><p>  A configura√ß√£o dos pinos de E / S no STM8 √© mais simples e l√≥gica do que no STM32: </p><br><ul><li>  familiarizado com o Atmega <em>Data Direction Register</em> : 1 = sa√≠da; </li><li>  o primeiro registro de controle CR1 na sa√≠da define o modo push-pull (1) ou dreno aberto (0);  desde que conecto os LEDs ao chip com c√°todos, deixo zeros aqui; </li><li>  o segundo registro de controle CR2 na sa√≠da define a velocidade do rel√≥gio: 1 = 10 MHz </li></ul><br><pre> <code class="plaintext hljs">#define PA_DDR *(volatile uint8_t *)0x005002 #define PA_CR2 *(volatile uint8_t *)0x005004 #define PD_DDR *(volatile uint8_t *)0x005011 #define PD_CR2 *(volatile uint8_t *)0x005013 #define PC_DDR *(volatile uint8_t *)0x00500C #define PC_CR2 *(volatile uint8_t *)0x00500E PA_DDR = (1&lt;&lt;3); //output PA_CR2 |= (1&lt;&lt;3); //fast PD_DDR = (1&lt;&lt;3); //output PD_CR2 |= (1&lt;&lt;3); //fast PC_DDR = ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //output PC_CR2 |= ((1&lt;&lt;3) | (1&lt;&lt;5) | (1&lt;&lt;6) | (1&lt;&lt;7)); //fast</code> </pre> <br><h2 id="nastroyka-shim">  Configura√ß√£o de PWM </h2><br><p>  Primeiro, vamos definir os termos: </p><br><ul><li>  <strong>Frequ√™ncia PWM</strong> - frequ√™ncia com a qual o timer est√° correndo; </li><li>  <strong>Recarregamento autom√°tico, AR</strong> - valor de carregamento autom√°tico com o qual o temporizador contar√° (per√≠odo de pulso); </li><li>  <strong>Update Event, UEV</strong> - um evento <strong>que ocorre</strong> quando o cron√¥metro conta como AR; </li><li>  <strong>Ciclo de</strong> trabalho PWM - ciclo de trabalho PWM, geralmente chamado de "ciclo de trabalho"; </li><li>  <strong>Valor</strong> de captura / compara√ß√£o - valor para captura / compara√ß√£o, tendo contado at√© que o timer <em>far√° alguma coisa</em> (no caso de PWM, inverte o sinal de sa√≠da); </li><li>  <strong>Valor de</strong> pr√©- <strong>carregamento</strong> - valor pr√©-carregado.  <em>O valor de compara√ß√£o</em> n√£o pode mudar enquanto o cron√¥metro est√° correndo, caso contr√°rio, o ciclo PWM ser√° interrompido.  Portanto, os novos valores transmitidos s√£o colocados no buffer e retirados dali quando o temporizador chega ao final da contagem e √© redefinido; </li><li>  <strong>Modos alinhados √†</strong> <strong>borda e alinhados ao</strong> <strong>centro</strong> - alinhamento na borda e no centro, o mesmo que o Atmelovskie <em>Fast PWM</em> e o <em>PWM</em> <em>com corre√ß√£o de fase</em> . </li><li>  <strong>OCiREF, Sinal de refer√™ncia de compara√ß√£o de sa√≠da</strong> - o sinal de sa√≠da de refer√™ncia, de fato, que no modo PWM est√° no pino correspondente. </li></ul><br><p>  Como j√° ficou claro na pinagem, dois temporizadores t√™m os recursos de PWM - o primeiro e o segundo.  Ambos s√£o de 16 bits, o primeiro possui muitos recursos adicionais (em particular, pode contar tanto para cima quanto para baixo).  Precisamos que ambos trabalhem da mesma maneira, ent√£o decidi come√ßar com o segundo obviamente mais pobre, para n√£o usar acidentalmente algo que n√£o est√° nele.  Algum problema √© que a descri√ß√£o da funcionalidade PWM de todos os cron√¥metros no manual de refer√™ncia est√° no cap√≠tulo do primeiro cron√¥metro (17.5.7 Modo PWM), portanto, √© necess√°rio pular para frente e para tr√°s no documento. </p><br><p>  O PWM no STM8 tem uma vantagem importante sobre o PWM Atmega: </p><br><p><img src="https://habrastorage.org/webt/pk/_-/za/pk_-za7gnzo77lvwyw-gvkts1y0.png"><br>  <sub>PWM com alinhamento de arestas</sub> <sub><br></sub>  <sub>Configura√ß√£o da conta de baixo para cima</sub> <sub><br></sub>  <sub>A contagem ascendente estar√° ativa se o bit DIR no registro TIM_CR1 for limpo</sub> <sub><br></sub>  <sub>Exemplo</sub> <sub><br></sub>  <sub>O exemplo usa o primeiro modo PWM.</sub>  <sub>O sinal de refer√™ncia OCiREF PWM √© mantido alto enquanto TIM1_CNT &lt;TIM1_CCRi.</sub>  <sub>Caso contr√°rio, √© preciso um n√≠vel baixo.</sub>  <sub>Se o valor para compara√ß√£o no TIM1_CCRi for maior que o valor inicial (registre TIM1_ARR), o sinal OCiREF ser√° mantido em 1. <strong>Se o valor para compara√ß√£o for 0, o OCiREF ser√° mantido em zero.</strong></sub>  <sub>...</sub> </p><br><p>  O temporizador do STM8 durante o <em>evento de atualiza√ß√£o</em> verifica primeiro o <em>valor de compara√ß√£o</em> e somente ent√£o fornece um sinal de refer√™ncia.  O cron√¥metro da Atmega primeiro embaralha e depois compara, como resultado, ao <code>compare value == 0</code> a sa√≠da resulta em uma agulha que precisa ser combatida de alguma forma (por exemplo, invertendo programaticamente a l√≥gica). </p><br><p>  Ent√£o, o que queremos fazer: PWM de 8 bits ( <code>AR == 255</code> ), consideramos de baixo para cima o alinhamento ao longo da borda.  Como as l√¢mpadas est√£o conectadas ao chip por c√°todos, o PWM deve emitir 0 (LED aceso) antes de <em>comparar o valor</em> e 1 depois. </p><br><p>  J√° lemos sobre alguns <em>modos PWM</em> , portanto, encontramos o registro desejado do segundo temporizador pesquisando no manual de refer√™ncia esta frase (18.6.8 - TIMx_CCMR1): </p><br><p><img src="https://habrastorage.org/webt/tt/_3/7s/tt_37syfd9-bib2-ymdxijus9qi.png"><br>  <sub>110: Primeiro modo PWM - ao contar de baixo para cima, o primeiro canal fica ativo enquanto TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Caso contr√°rio, o primeiro canal est√° inativo.</sub>  <sub>[mais adiante no documento copiar e colar incorreto do timer 1]</sub> <sub><br></sub>  <sub>111: Segundo modo PWM - ao contar de baixo para cima, o primeiro canal fica inativo enquanto TIMx_CNT &lt;TIMx_CCR1.</sub>  <sub>Caso contr√°rio, o primeiro canal est√° ativo.</sub> </p><br><p>  Como os LEDs est√£o conectados aos c√°todos MK, o segundo modo √© adequado para n√≥s (o primeiro tamb√©m, mas ainda n√£o sabemos). </p><br><p><img src="https://habrastorage.org/webt/go/ap/x_/goapx_hk5neeok4phdkas_nnfzu.png"><br>  <sub>Bit 3 OC1PE: Ativar pr√©-carregamento da sa√≠da 1</sub> <sub><br></sub>  <sub>0: pr√©-carregamento do registro com TIMx_CCR1 desativado.</sub>  <sub>Voc√™ pode escrever para TIMx_CCR1 a qualquer momento.</sub>  <sub>O novo valor funciona imediatamente.</sub> <sub><br></sub>  <sub>1: O registro de pr√©-carregamento em TIMx_CCR1 est√° ativado.</sub>  <sub>As opera√ß√µes de leitura / grava√ß√£o acessam o registro de pr√©-carregamento.</sub>  <sub>O valor pr√©-carregado TIMx_CCR1 √© carregado no registrador sombra durante cada evento de atualiza√ß√£o.</sub> <sub><br></sub>  <sub>* Nota: para que o modo PWM funcione corretamente, os registros de pr√©-carregamento devem estar ativados.</sub> <sub>      (  TIMx_CR1   OPM).</sub> <br></p><p> ,  ,  ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCMR1 *(volatile uint8_t *)0x005307 #define TIM2_CCMR2 *(volatile uint8_t *)0x005308 #define TIM2_CCMR3 *(volatile uint8_t *)0x005309 #define PWM_MODE2 0x70 //PWM mode 2, 0b01110000 #define OCxPE 0x08 //preload enable TIM2_CCMR1 = (PWM_MODE2 | OCxPE); TIM2_CCMR2 = (PWM_MODE2 | OCxPE); TIM2_CCMR3 = (PWM_MODE2 | OCxPE);</code> </pre> <br><p> AR     ,   : </p><br><pre> <code class="plaintext hljs">#define TIM2_ARRH *(volatile uint8_t *)0x00530F #define TIM2_ARRL *(volatile uint8_t *)0x005310 TIM2_ARRH = 0; TIM2_ARRL = 255;</code> </pre> <br><p>      -,   ,    .   , ,  256.        TIM2_PSCR     : </p><br><pre> <code class="plaintext hljs">#define TIM2_PSCR *(volatile uint8_t *)0x00530E TIM2_PSCR = 8;</code> </pre> <br><p>       .     <em>Capture/Compare <strong>Enable</strong></em> :  ,      .     ,     , ..       PWM Mode 1. : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCER1 *(volatile uint8_t *)0x00530A #define TIM2_CCER2 *(volatile uint8_t *)0x00530B #define CC1E (1&lt;&lt;0) // CCER1 #define CC2E (1&lt;&lt;4) // CCER1 #define CC3E (1&lt;&lt;0) // CCER2 TIM2_CCER1 = (CC1E | CC2E); TIM2_CCER2 = CC3E;</code> </pre> <br><p>  , ,     TIMx_CR1: </p><br><p><img src="https://habrastorage.org/webt/u8/rj/5v/u8rj5vb2h3oxtgnoe1zzz90fnfm.png"></p><br><pre> <code class="plaintext hljs">#define TIM2_CR1 *(volatile uint8_t *)0x005300 TIM2_CR1 |= 1;</code> </pre> <br><p>    AnalogWrite(),        .    <em>Capture/Compare registers</em> ,      :  8   TIM2_CCRxL    TIM2_CCRxH.    8- ,     : </p><br><pre> <code class="plaintext hljs">#define TIM2_CCR1L *(volatile uint8_t *)0x005312 #define TIM2_CCR2L *(volatile uint8_t *)0x005314 #define TIM2_CCR3L *(volatile uint8_t *)0x005316 void setRGBled(uint8_t r, uint8_t g, uint8_t b) { TIM2_CCR1L = r; TIM2_CCR2L = g; TIM2_CCR3L = b; }</code> </pre> <br><p>   ,       ,   100%  (   255      ).      ,      ,   . </p><br><p>     ,   . </p><br><p>            (  ,   ¬´¬ª   ,        ).            .      , ..       ,   16-     <em>Prescaler High</em>  <em>Low</em> .   ‚Ä¶    .   ? </p><br><p>             1,   ,     .  <em>17.7.30 Break register (TIM1_BKR)</em> ,    : </p><br><p><img src="https://habrastorage.org/webt/kb/h8/ue/kbh8ueavruur-vxcqo4fe0c2pdy.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM1_BKR *(volatile uint8_t *)0x00526D TIM1_BKR = (1&lt;&lt;7);</code> </pre> <br><p>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/b9/hb/tn/b9hbtn6retrnp1vpnzxjsjaayoq.jpeg"></p><br><h1 id="stm8-multiplex"> STM8 Multiplex </h1><br><h1 id="multipleksing-na-stm8">   STM8 </h1><br><p>  -   ,          RGB-      .   ‚Äì  LED-,   ,   -     ,   ,     ( <em>persistence of vision</em> ,   ). -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">-   </a> . </p><br><p>    : </p><br><ul><li>    RGB LED; </li><li>  ,     ; </li><li>    ; </li><li>    RGB LED; </li><li>  ... </li></ul><br><p>   .. ,    ,     ¬´¬ª   .   .   ,    ,         ,   UEV          RGB-. </p><br><p>   LED  ,   ¬´¬ª,      .   : </p><br><pre> <code class="plaintext hljs">uint8_t colors[8][3];</code> </pre> <br><p>  ,     ,        .         </p><br><pre> <code class="plaintext hljs">uint8_t cnt;</code> </pre> <br><h3 id="demuks">  </h3><br><p>     ,   ,  CD74HC238.  ‚Äì ,    <code>&lt;&lt;</code> .     ( 0, 1  2)      X,        ( <code>1&lt;&lt;X</code> ).        .            ,     ‚Äì      ,  ,    .   ,       . </p><br><p> CD74HC238      ,       .           P-MOSFET,       , ..   20 ,  <em>absolute maximum ratings</em>  .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> CD74HC238</a>       : </p><br><p><img src="https://habrastorage.org/webt/b3/lz/rv/b3lzrv4xyavibkiwekm3lbvkays.png"><br> <sub>H =   , L =   , X ‚Äì  </sub> </p><br><p>  E2  E1  , E3, A0, A1  A3   PD5, PC3, PC4  PC5 STM8.      ,   ,     push-pull . </p><br><h2 id="shim">  </h2><br><p>       ,    ,   : </p><br><p> -,      <em>Update Event</em> (UEV),    ,   LED.     <em>Update Interrupt Enable</em>      </p><br><p><img src="https://habrastorage.org/webt/me/kx/6p/mekx6pckxk6qmhkegaudnneach4.png"><br> <sub>  </sub> </p><br><pre> <code class="plaintext hljs">#define TIM2_IER *(volatile uint8_t *)0x005303 //enable interrupt TIM2_IER = 1;</code> </pre> <br><p>       ,  <em>ghosting</em> ‚Äì   .       - ,  ,    UEV,   ,       LED      -   .        (0 =  , 255 =   )      .  I.e.  ,   UEV       . </p><br><p>  : </p><br><pre> <code class="plaintext hljs">//set polarity TIM2_CCER1 |= (CC1P | CC2P); TIM2_CCER2 |= CC3P;</code> </pre> <br><p>   r, g  b  255       . </p><br><h3 id="preryvaniya">  </h3><br><p>    ,            -  .   -    ,     . </p><br><p>         ST Visual Develop,   <code>main.c</code>       <code>stm8_interrupt_vector.c</code> ,    .         <code>NonHandledInterrupt</code> .        . </p><br><p>      ,    : </p><br><p><img src="https://habrastorage.org/webt/ly/ra/gy/lyragyga5skmcrzjojlftjit1qg.png"><br> <sub>13 TIM2 / <br> 14 TIM2 /</sub> </p><br><p>    LED  UEV,     ‚Ññ13. </p><br><p> , -,   <code>stm8_interrupt_vector.c</code>   ,    ‚Ññ13 (IRQ13)    : </p><br><pre> <code class="plaintext hljs">{0x82, TIM2_Overflow}, /* irq13 */</code> </pre> <br><p> -,     <code>main.h</code>  : </p><br><pre> <code class="plaintext hljs">#ifndef __MAIN_H #define __MAIN_H @far @interrupt void TIM2_Overflow (void); #endif</code> </pre> <br><p>  , ,      <code>main.c</code> : </p><br><pre> <code class="plaintext hljs">@far @interrupt void TIM2_Overflow (void) { PD_ODR &amp;= ~(1&lt;&lt;5); //   PC_ODR = (cnt&lt;&lt;3); //      PD_ODR |= (1&lt;&lt;5); //   TIM2_SR1 = 0; //   Update Interrupt Pending cnt++; cnt &amp;= 7; //   LED TIM2_CCR1L = ~colors[cnt][0]; //      TIM2_CCR2L = ~colors[cnt][1]; //     TIM2_CCR3L = ~colors[cnt][2]; // return; }</code> </pre> <br><p>   .     <code>rim</code> ‚Äì     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Programming Manual</a> : </p><br><pre> <code class="plaintext hljs">//enable interrupts _asm("rim");</code> </pre> <br><p>    ‚Äì <code>sim</code> ‚Äì  .          ¬´¬ª,         . </p><br><p>   ‚Äì <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> . </p><br><p><img src="https://habrastorage.org/webt/ri/ul/qs/riulqsjmsnehvg5fb_iofcnjl3u.jpeg"></p><br><p>   -   , ,     .     ,    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt456094/">https://habr.com/ru/post/pt456094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456084/index.html">Kubernetes 1.15: Vis√£o geral dos destaques</a></li>
<li><a href="../pt456086/index.html">Storyboards para iOS: an√°lise dos pr√≥s e contras, melhores pr√°ticas</a></li>
<li><a href="../pt456088/index.html">Problemas de an√°lise de big data</a></li>
<li><a href="../pt456090/index.html">Introdu√ß√£o ao teste de unidade no Unity</a></li>
<li><a href="../pt456092/index.html">Sete sinais preocupantes de que voc√™ depende do clima, mesmo que voc√™ n√£o pense</a></li>
<li><a href="../pt456096/index.html">O que o leitor comum de tempos de nerd faz enquanto paira nas nuvens</a></li>
<li><a href="../pt456100/index.html">Agora na nova embalagem - o Kingston A400 no formato M.2 chega ao mercado</a></li>
<li><a href="../pt456102/index.html">Relat√≥rios f√°ceis em C / C ++</a></li>
<li><a href="../pt456104/index.html">Ezblock Pi - programa√ß√£o sem programa√ß√£o, desta vez para os f√£s do Raspberry Pi</a></li>
<li><a href="../pt456106/index.html">Dividimos os recursos mais rapidamente. Experi√™ncia de desenvolvimento Android no Badoo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>