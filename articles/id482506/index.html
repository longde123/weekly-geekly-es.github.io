<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò´ üöº üë∏üèª Entri Data dalam STM32F4xx dari Parallel ADC via DCMI ü¶Ü üòü üçß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diketahui bahwa keluarga mikrokontroler STM32F4xx, yang memiliki inti yang cukup produktif yang cukup cocok untuk tugas ‚Äúnon-daging‚Äù, DSP tidak memili...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Entri Data dalam STM32F4xx dari Parallel ADC via DCMI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482506/"><p>  Diketahui bahwa keluarga mikrokontroler STM32F4xx, yang memiliki inti yang cukup produktif yang cukup cocok untuk tugas ‚Äúnon-daging‚Äù, DSP tidak memiliki antarmuka input data yang lengkap dengan bus paralel paling sederhana dalam mode ‚Äújalur pipa‚Äù (data-clk).  Setelah merokok dm00037051.pdf, saya menemukan opsi yang tidak spesifik, tetapi pada pandangan pertama, cocok - antarmuka DCMI (antarmuka kamera digital). <br><br>  Tentu saja, penggunaan mikrokontroler STM32 untuk DSP klasik yang dimuat (FIR, IIR, FFT) bukanlah pilihan yang optimal, tetapi jika kartu tiba-tiba berbaring dan kemampuan mikrokontroler ini masih cukup, ditambah Anda memerlukan cukup banyak antarmuka kecepatan rendah.  Tentang ini di bawah luka. <br></p><br><br><a name="habracut"></a><br><br><p>  Pada salah satu proyek dengan tenggat waktu dan anggaran "panas", ada kebutuhan untuk mengimplementasikan "sepotong besi" dengan yang optimal: massa, dimensi, konsumsi.  Sebagai fungsi dasar, diperlukan pemrosesan sinyal digital (penyaringan dan analisis statistik), yang berasal dari ADC dalam mode real-time lunak.  Untuk pemrosesan, saya ingin memiliki floating point presisi tunggal.  Sinyal dari ADC diterima pada frekuensi menengah 48 MHz.  Pita sinyal 1 MHz.  Untuk mengimplementasikan transfer spektrum sinyal dari frekuensi menengah ke nol, lebih disukai menggunakan subsampling dari broadband ADC.  Juga, perlu untuk menerima dan mengirimkan informasi melalui Ethernet, SPI, UART, I2C dan bekerja dengan interupsi. <br></p><br><p>  Tenggat waktu implementasi dan fungsi DSP tertentu tidak memungkinkan penggunaan FPGA untuk tujuan ini.  Dengan prosesor sinyal keluarga Blackfin yang terkenal, Perangkat Analog yang terkenal tidak memiliki pengalaman komunikasi dan tidak ada alat debugging dan papan demo di dekat akses.  Hanya ada pengalaman komunikasi yang dekat dan panjang dengan prosesor DSP unggulan ADSP-TS201 TigerSHARC yang mahal.  Selain itu, Blackfin tidak memiliki implementasi perangkat keras IEEE-754.  Juga, perlu untuk menerima blok data terus menerus dengan ADC 128 KB, ditambah 30 KB memproses overhead dan tanpa memori eksternal, sulit untuk mendorong semuanya menjadi sesuatu yang lebih murah. <br></p><br><p>  Secara umum, hanya ada papan STM32F407 (Discovery dan kebiasaan dari Cina) yang tersedia.  Seperti yang saya duga, banyak yang berurusan dengan topik terkait sekarang memiliki bantuan universal.  Ada juga papan ADA-HSMC Terasic tempat AD9228 ADC dual-channel dipasang (12-bit, Fd = 65 msps, bandwidth = 315 MHz). <br></p><br><p>  Opsi yang tidak spesifik, tetapi cukup cocok adalah antarmuka DCMI (antarmuka kamera digital), yang merupakan perangkat keras yang diimplementasikan dalam STM32F4. <br></p><br><p>  Pengoperasian antarmuka ini dijelaskan dalam RM0090, DocID018909, p. 454/1718.  Empat angka berikut diberikan dari dokumen ini. <br></p><br><p>  Jadi, frekuensi input yang diklaim hingga 54 MHz.  Yang cukup - tingkat sub-sampling kami adalah 10 MHz.  Berikut adalah set sinyal antarmuka DCMI yang digunakan: <br></p><br><br><img src="https://habrastorage.org/webt/ko/nl/eu/konleu5wruvzibgudm1jxb2eqnw.png"><br><br><p>  Catatan: D13, D14 hanya tersedia dalam paket 144-pin.  Kami memiliki 100 pin, tetapi kami tidak membutuhkannya.  (meskipun Perangkat Analog memiliki 14 bit ADC - AD9248 yang serupa). <br></p><br><p>  Berikut ini adalah diagram waktu antarmuka secara umum: <br></p><br><br><img src="https://habrastorage.org/webt/5i/y2/5y/5iy25yfo20vatfc5l6amwv1aqm4.png"><br><br><p>  Dan ini adalah diagram waktu antarmuka dalam mode format bingkai JPEG: <br></p><br><br><img src="https://habrastorage.org/webt/bc/zf/px/bczfpxfe2rum9uevbf249qcwcmu.png"><br><br><p>  Kami akan menggunakan mode operasi ini sebagai  dia cocok untuk kita. <br></p><br><p>  Dalam mode ini, sinyal VSYNC ditarik ke daya.  Kami akan menggunakan HSYNC sebagai sinyal eksternal untuk memungkinkan dimulainya penerimaan data melalui antarmuka. <br></p><br><p>  Kami menggunakan mikrokontroler STM32F407RGT6 dalam paket LQFP100. <br></p><br><p>  AD9238 ADC memiliki input untuk mode shutdown (hemat daya) dari saluran yang sesuai PDWN_A (B), dan izin keluarannya adalah OEB_A (B).  Adalah logis untuk mendapatkannya dari pin pengontrol.  Hasilnya, diagram koneksi pin akan terlihat seperti ini: <br></p><p><img src="https://habrastorage.org/webt/07/55/k5/0755k5ui-ippcicwu6ig4dxrhr0.png"><br><br></p><p>  Karena ADC ini tidak memiliki sinyal clock output, maka perlu menggunakan multiply (clock buffer).  Kami menggunakan LMK00101 dari Texas Instruments - nilai bagus untuk harga, jitter rendah, dan yang paling penting, sekali lagi - ada di tangan). <br></p><br><p>  Dalam pemrosesan, kami memperhitungkan bahwa data pada bus paralel ADC muncul dengan penundaan 7 siklus per jam relatif terhadap sinyal jam input. <br></p><br><p>  Kami akan menerima data (tentu saja) melalui DMA.  Berikut adalah kode sumber untuk menginisialisasi DCMI dan DMA. <br></p><br><p>  Kami menyalakan clocking port yang kami butuhkan, DCMI dan DMA2 <br></p><br><pre><code class="cpp hljs">GPIO_InitTypeDef GPIO_InitStructure; <span class="hljs-comment"><span class="hljs-comment">/* Enable DCMI GPIOs clocks */</span></span> RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOE | RCC_AHB1Periph_GPIOB | RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOD, ENABLE); <span class="hljs-comment"><span class="hljs-comment">/* Enable DCMI clock */</span></span> RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_DCMI, ENABLE); RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);</code> </pre> <br><p>  Pin ini (PA5) akan mensimulasikan pembagian ke dalam frame - HSYNC.  Inisialisasi saat keluar <br></p><br><pre> <code class="cpp hljs"> GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz; GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_ResetBits(GPIOA, GPIO_Pin_5); <span class="hljs-comment"><span class="hljs-comment">//HSYNC_PA4 -PA5 -&gt; GND</span></span></code> </pre><br><p>  Konfigurasikan pin yang sesuai dalam mode DCMI <br></p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* PCLK */</span></span> GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_DCMI); <span class="hljs-comment"><span class="hljs-comment">/* D0-D7 */</span></span> GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_DCMI); <span class="hljs-comment"><span class="hljs-comment">//D0* GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_DCMI); //D1* GPIO_PinAFConfig(GPIOC, GPIO_PinSource8, GPIO_AF_DCMI); //D2* GPIO_PinAFConfig(GPIOC, GPIO_PinSource9, GPIO_AF_DCMI); //D3* GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_DCMI); //D4* GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_DCMI); //D5* GPIO_PinAFConfig(GPIOE, GPIO_PinSource5, GPIO_AF_DCMI); //D6* GPIO_PinAFConfig(GPIOE, GPIO_PinSource6, GPIO_AF_DCMI); //D7* GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_DCMI); //D8* GPIO_PinAFConfig(GPIOC, GPIO_PinSource12, GPIO_AF_DCMI); //D9* GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_DCMI); //D10* GPIO_PinAFConfig(GPIOD, GPIO_PinSource2, GPIO_AF_DCMI); //D11* /* VSYNC */ GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_DCMI); /* HSYNC */ GPIO_PinAFConfig(GPIOA, GPIO_PinSource4, GPIO_AF_DCMI); /* DCMI GPIO configuration **************************************************/ /* D0,D1,D2,D3,D4,D8,D9 */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz; GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* D6,D7*/ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6; GPIO_Init(GPIOE, &amp;GPIO_InitStructure); /* D10, D5, VSYNC(PB7) */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); /* D11(PD2) */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; GPIO_Init(GPIOD, &amp;GPIO_InitStructure); /* PCLK(PA6) HSYNC(PA4)*/ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_6; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span></span></code> </pre><br><p>  Hal yang paling menarik di sini adalah mengkonfigurasi DCMI dalam mode yang sesuai dengan bingkai JPEG. <br></p><br><pre> <code class="cpp hljs"> DCMI_InitStructure.DCMI_CaptureMode = DCMI_CaptureMode_Continuous; DCMI_InitStructure.DCMI_SynchroMode = DCMI_SynchroMode_Embedded; DCMI_InitStructure.DCMI_PCKPolarity = DCMI_PCKPolarity_Rising; DCMI_InitStructure.DCMI_VSPolarity = DCMI_VSPolarity_Low; DCMI_InitStructure.DCMI_HSPolarity = DCMI_HSPolarity_High; DCMI_InitStructure.DCMI_CaptureRate = DCMI_CaptureRate_All_Frame; DCMI_InitStructure.DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_12b;</code> </pre><br><p>  Pengaturan DMA <br></p><br><pre> <code class="cpp hljs"> DCMI_Init(&amp;DCMI_InitStructure); DMA_InitStructure.DMA_Channel = DMA_Channel_1; DMA_InitStructure.DMA_PeripheralBaseAddr = DCMI_DR_ADDRESS; <span class="hljs-comment"><span class="hljs-comment">//0x50050028 DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)DCMI_PendingData; DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory; DMA_InitStructure.DMA_BufferSize = MAX_DOWBLE_BUF; DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word; DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; DMA_InitStructure.DMA_Mode = DMA_Mode_Normal; DMA_InitStructure.DMA_Priority = DMA_Priority_Medium; DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable; DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full; DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single; DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single; DMA_Init(DMA2_Stream1, &amp;DMA_InitStructure);</span></span></code> </pre><br><p>  Pengaturan menyela di akhir penerimaan data dari saluran DMA yang sesuai <br></p><br><pre> <code class="cpp hljs"> NVIC_InitStructure.NVIC_IRQChannel = DMA2_Stream1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="hljs-number"><span class="hljs-number">0</span></span>; NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="hljs-number"><span class="hljs-number">0</span></span>; NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);</code> </pre><br><p>  Kode penangan kami, di mana kami mematikan penerimaan data DCMI dan menetapkan tanda siap data. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EXTI1_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ EXTI_ClearFlag(EXTI_Line1); DMA_ClearITPendingBit(DMA2_Stream1, DMA_IT_TCIF1); DMA_Cmd(DMA2_Stream1, DISABLE); DCMI_Cmd(DISABLE); dma_recv_f = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//GPIO_ResetBits(GPIOE, GPIO_Pin_0); //VSYNC reset }</span></span></code> </pre><br><p>  Semuanya dengan pengaturan.  Sekarang kita menghidupkan saluran DMA kita, blok DCMI, kita mulai menerima data DCMI dalam mode bingkai JPEG. <br></p><br><pre> <code class="plaintext hljs"> /* Enable DMA transfer */ DMA_Cmd(DMA2_Stream1, ENABLE); /* Enable DCMI interface */ DCMI_Cmd(ENABLE); /* Start Image capture */ DCMI_CaptureCmd(ENABLE); DCMI_JPEGCmd(ENABLE);</code> </pre><br><p>  Siklus program utama.  Di sini, polling bendera dan restart penerimaan data. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dma_recv_f = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//,     . uint16_t DCMI_PendingData[8500]; //    DCMI int main(void) { DCMI_Config(); //        __enable_irq(); //  while(1) { while(dma_recv_f!=1){}; //    dma_recv_f = 0; //  /*     */ Re_DMA_Config(DCMI_PendingData, glob_cnt); // DMA } }</span></span></code> </pre><br><p>  Catatan: jika Anda perlu menerima dan memproses data dalam waktu nyata dengan buffering ganda, stm32f4 memiliki mekanisme interupsi ketika setengah buffer penuh.  Dalam pengaturan DMA maka perlu mengatur mode siklus kontinu dari penerimaan data.  Sebagai contoh: <br></p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// DMA2 Stream0 channel0 configuration ************************************** DMA_InitStructure.DMA_Channel = DMA_Channel_1; DMA_InitStructure.DMA_PeripheralBaseAddr = DCMI_DR_ADDRESS; //0x50050028 DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)DCMI_PendingData; DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory; DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; DMA_InitStructure.DMA_BufferSize = buf_size; &lt;b&gt;DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;&lt;/b&gt; //     DMA_InitStructure.DMA_Priority = DMA_Priority_High; DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable; &lt;b&gt;DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;&lt;/b&gt; //  DMA     DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single; DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;</span></span></code> </pre><br><p>  Dalam interrupt handler, maka perlu untuk mereset bit akhir DMA hanya setelah mengisi seluruh buffer, dan program pengguna untuk menunjukkan jumlah buffer saat ini di mana penerimaan data telah berakhir.  Sesuatu seperti ini: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(DMA_GetITStatus(DMA2_Stream1,DMA_IT_TCIF1)){ DMA_ClearITPendingBit(DMA2_Stream0, DMA_IT_TCIF1); num_buf = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ num_buf = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><p>  Pada dasarnya itulah yang diperlukan untuk menerima data dari ADC kami melalui DCMI. <br></p><br><p>  Sayangnya, saat ini saya tidak dapat mendemonstrasikan seluruh mekanisme ini secara langsung.  potongan besi sudah sekitar 3 tahun beroperasi))).  Saya hanya bisa membawa data pendaftaran tes yang disimpan dari waktu-waktu itu. <br></p><br><p>  Berikut adalah sinyal harmonik dari generator SMB100A pada frekuensi 48,001 MHz, sama dengan IF kami dengan offset 1 KHz: <br></p><br><br><img src="https://habrastorage.org/webt/6_/99/_8/6_99_8v4li9yojdlw7weemympik.png"><br><br><p>  Dan ini adalah spektrumnya: <br></p><br><br><img src="https://habrastorage.org/webt/sg/ku/5k/sgku5ku8m1ckzrxxbgwzudr90o0.png"><br><br><p>  Untuk memeriksa kinerja maksimum pada kabel papan tempat memotong roti standar dengan panjang sekitar 200 mm, yang terhubung dengan ADA-HSMC dan STM32F4 Discovery, data yang benar diterima pada frekuensi clock 40 MHz. <br>  Pada papan "asli" yang diproduksi untuk tugas ini, melalui kabel datar sepanjang 100 mm, pada suhu kamar, ternyata menaikkan frekuensi pengambilan sampel hingga maksimum 54 MHz. <br>  Pada frekuensi sampling 10 MHz yang diinginkan, kinerja diuji pada rentang industri: dari -40 hingga +60. <br></p><br><p>  Sebenarnya semuanya.  Terima kasih atas perhatian anda! <br></p><br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482506/">https://habr.com/ru/post/id482506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482496/index.html">Hasil: 9 terobosan teknologi utama tahun 2019</a></li>
<li><a href="../id482498/index.html">Sejarah evolusi antarmuka di Jawa</a></li>
<li><a href="../id482500/index.html">Python atau R: Manakah Pilihan Yang Lebih Baik Untuk Ilmu Data?</a></li>
<li><a href="../id482502/index.html">5,8 juta IOPS: mengapa begitu banyak?</a></li>
<li><a href="../id482504/index.html">Posting dengan posting: hasil kami untuk 2019</a></li>
<li><a href="../id482508/index.html">2019 tentang Habr√© dalam angka: ada lebih banyak pos, minus sama, komentar lebih aktif</a></li>
<li><a href="../id482512/index.html">Mereka seperti kita: ketika memasuki Cina, lupakan mentalitas khusus Asia</a></li>
<li><a href="../id482520/index.html">Perhitungan diskon maksimum yang mungkin dalam proyek dilakukan berdasarkan pesanan berdasarkan beban saat ini</a></li>
<li><a href="../id482522/index.html">Timlid - Inilah caranya</a></li>
<li><a href="../id482526/index.html">Kuliah Yobel oleh Donald Knuth "At the Christmas tree"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>