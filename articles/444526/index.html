<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úñÔ∏è ü§≤üèΩ üëå Pila DOTS: C ++ y C # üë®üèº‚Äçüíª üí£ ü§≥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es una breve introducci√≥n a nuestra nueva pila de tecnolog√≠a orientada a datos ( DOTS ). Compartiremos algunas ideas para ayudarlo a comprender c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pila DOTS: C ++ y C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/444526/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/qr/be/mb/qrbembbqugflv8bnrgozc2uxcpe.png" alt="imagen"></a> <br><br>  Esta es una breve introducci√≥n a nuestra nueva pila de tecnolog√≠a orientada a datos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DOTS</a> ).  Compartiremos algunas ideas para ayudarlo a comprender c√≥mo y por qu√© Unity se ha vuelto as√≠ hoy, y tambi√©n le diremos en qu√© direcci√≥n planeamos desarrollar.  En el futuro, planeamos publicar nuevos art√≠culos en el blog DOTS en el blog de Unity. <br><a name="habracut"></a><br>  Hablemos de C ++.  Este es el lenguaje en el que se escribe la Unidad moderna. <br>  Uno de los problemas m√°s complejos con los que un desarrollador de juegos tiene que lidiar es: el programador debe proporcionar un archivo ejecutable con instrucciones claras para el procesador de destino, y cuando el procesador ejecuta estas instrucciones, el juego debe comenzar. <br><br>  En la parte del c√≥digo que es sensible al rendimiento, sabemos de antemano cu√°les deber√≠an ser las instrucciones finales.  Solo necesitamos una forma simple que nos permita describir constantemente nuestra l√≥gica, y luego verificar y asegurarnos de que se generen las instrucciones que necesitamos. <br><br>  Creemos que el lenguaje C ++ no es demasiado bueno para esta tarea.  Por ejemplo, quiero que mi ciclo se vectorice, pero puede haber un mill√≥n de razones por las cuales el compilador no podr√° vectorizarlo.  O hoy se est√° vectorizando, y ma√±ana no, debido a un cambio aparentemente insignificante.  Incluso es dif√≠cil asegurarse de que todos mis compiladores de C / C ++ incluso vectoricen mi c√≥digo. <br><br>  Decidimos desarrollar nuestra propia "forma bastante conveniente de generar c√≥digo de m√°quina" que cumplir√≠a todos nuestros deseos.  Podr√≠amos pasar mucho tiempo para doblar ligeramente la secuencia completa del dise√±o de C ++ en la direcci√≥n que necesitamos, pero decidimos que ser√≠a mucho m√°s razonable invertir nuestra energ√≠a en el desarrollo de una cadena de herramientas que resuelva por completo todos los problemas de dise√±o que enfrentamos.  Lo desarrollar√≠amos teniendo en cuenta precisamente aquellas tareas que el desarrollador del juego tiene que resolver. <br><br>  ¬øQu√© factores priorizamos? <br><br><ul><li>  Rendimiento = correcto.  Deber√≠a poder decir: "si por alguna raz√≥n este ciclo no est√° vectorizado, entonces debe ser un error del compilador y no una situaci√≥n de la categor√≠a" oh, el c√≥digo comenz√≥ a funcionar solo ocho veces m√°s lento, pero a√∫n as√≠ da valores verdaderos, negocios algo! </li><li>  Plataforma cruzada.  El c√≥digo de entrada que escribo debe permanecer exactamente igual independientemente de la plataforma de destino, ya sea iOS o Xbox. </li><li>  Deber√≠amos tener un ciclo de iteraci√≥n ordenado en el que pueda ver f√°cilmente el c√≥digo de m√°quina generado para cualquier arquitectura cuando cambie mi c√≥digo fuente.  El "visor" de c√≥digo de m√°quina deber√≠a ser de gran ayuda con la capacitaci√≥n / explicaci√≥n cuando necesite comprender lo que hacen todas estas instrucciones de m√°quina. </li><li> Seguridad  Como regla general, los desarrolladores de juegos no ponen la seguridad en una posici√≥n alta en su lista de prioridades, pero creemos que una de las mejores caracter√≠sticas de Unity es que es realmente muy dif√≠cil da√±ar la memoria.  Deber√≠a haber tal modo en el que ejecutamos cualquier c√≥digo, y arreglamos sin ambig√ºedad un error por el cual una letra grande muestra un mensaje sobre lo que sucedi√≥ aqu√≠: por ejemplo, fui m√°s all√° de los l√≠mites al leer / escribir o trat√© de desreferenciar a cero. </li></ul><br>  Entonces, habiendo descubierto lo que es importante para nosotros, pasemos a la siguiente pregunta: ¬øen qu√© idioma es mejor escribir programas a partir de los cuales se generar√° ese c√≥digo de m√°quina?  Digamos que tenemos las siguientes opciones: <br><br><ul><li>  Idioma propio </li><li>  Alguna adaptaci√≥n / subconjunto de C o C ++ </li><li>  Subconjunto de c # </li></ul><br>  ¬øQu√©, C #?  ¬øPara nuestros circuitos internos cuyo rendimiento es especialmente cr√≠tico?  Si  C # es una opci√≥n completamente natural, con la que en el contexto de Unity hay muchas cosas muy bonitas: <br><br><ul><li>  Este es el idioma con el que nuestros usuarios ya est√°n trabajando hoy. </li><li>  Tiene un IDE excelente, tanto para edici√≥n / refactorizaci√≥n como para depuraci√≥n. </li><li>  Ya hay un compilador que convierte C # en un IL intermedio (estamos hablando del compilador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Roslyn</a> para C # de Microsoft), y simplemente puede usarlo en lugar de escribir el suyo.  Tenemos una gran experiencia en la conversi√≥n de un lenguaje intermedio a IL, por lo que solo necesitamos realizar la generaci√≥n de c√≥digo y el posprocesamiento de un programa espec√≠fico. </li><li>  C # carece de muchos problemas de C ++ (infierno con la inclusi√≥n de encabezados, patrones PIMPL, tiempo de compilaci√≥n prolongado) </li></ul><br>  A m√≠ mismo realmente me gusta escribir c√≥digo en C #.  Sin embargo, C # tradicional no es el mejor lenguaje en t√©rminos de rendimiento.  El equipo de desarrollo de C #, los equipos responsables de la biblioteca est√°ndar y el tiempo de ejecuci√≥n en los √∫ltimos a√±os han hecho un gran progreso en esta √°rea.  Sin embargo, mientras trabaja con C #, es imposible controlar exactamente d√≥nde se encuentran sus datos en la memoria.  Y es precisamente este problema el que debemos resolver para aumentar la productividad. <br><br>  Adem√°s, la biblioteca est√°ndar de este lenguaje est√° organizada alrededor de "objetos en el mont√≥n" y "objetos que tienen punteros a otros objetos". <br><br>  Al mismo tiempo, al trabajar con un fragmento de c√≥digo en el que el rendimiento es cr√≠tico, puede prescindir casi por completo de una biblioteca est√°ndar (adi√≥s a Linq, StringFormatter, List, Dictionary), prohibir las operaciones de selecci√≥n (= sin clases, solo estructuras), reflexi√≥n, deshabilitar el recolector de basura y virtual llamadas y agregue algunos contenedores nuevos que se les permite usar (NativeArray y compa√±√≠a).  En este caso, los elementos restantes del lenguaje C # ya se ven muy bien.  Consulte el blog de Aras para ver ejemplos, donde describe un proyecto de trazado de ruta improvisado. <br><br>  Tal subconjunto nos ayudar√° a hacer frente f√°cilmente a todas las tareas que son relevantes al trabajar con ciclos activos.  Como se trata de un subconjunto completo de C #, puede trabajar con √©l como con C # normal.  Podemos recibir errores asociados con el viaje al extranjero al intentar acceder, obtendremos excelentes mensajes de error, admitiremos el depurador y la velocidad de compilaci√≥n ser√° tal que ya lo haya olvidado cuando trabaje con C ++.  A menudo nos referimos a este subconjunto como High Performance C # o HPC #. <br><br><h3>  Compilador de r√°fagas: ¬øqu√© pasa hoy? </h3><br>  Escribimos un generador / compilador de c√≥digo llamado Burst.  Est√° disponible en la versi√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Unity 2018.1</a> y superior como un paquete en el modo "vista previa".  Queda mucho trabajo por hacer con √©l, pero hoy estamos satisfechos con √©l. <br><br>  A veces logramos trabajar m√°s r√°pido que en C ++, a menudo, a√∫n m√°s lentamente que en C ++.  La segunda categor√≠a incluye errores de rendimiento que, estamos convencidos, podr√°n hacer frente. <br><br>  Sin embargo, simplemente comparar el rendimiento no es suficiente.  No menos importante es lo que hay que hacer para lograr dicho rendimiento.  Ejemplo: tomamos el c√≥digo de eliminaci√≥n de nuestro procesador actual de C ++ y lo portamos a Burst.  El rendimiento no ha cambiado, pero en la versi√≥n de C ++ tuvimos que hacer un incre√≠ble acto de equilibrio para persuadir a nuestros compiladores de C ++ para que hagan la vectorizaci√≥n.  La versi√≥n con Burst era aproximadamente cuatro veces m√°s compacta. <br><br>  Honestamente, la historia completa con "debe reescribir su c√≥digo cr√≠tico para el rendimiento en C #" a primera vista no atrajo a nadie en el equipo interno de Unity.  Para la mayor√≠a de nosotros, sonaba como "¬°m√°s cerca del hardware!" Al trabajar con C ++.  Pero ahora la situaci√≥n ha cambiado.  Con C #, controlamos completamente todo el proceso desde la compilaci√≥n del c√≥digo fuente hasta la generaci√≥n del c√≥digo de la m√°quina, y si no nos gusta ning√∫n detalle, simplemente lo tomamos y lo arreglamos. <br><br>  Vamos a portar lenta pero seguramente todos los c√≥digos cr√≠ticos de rendimiento de C ++ a HPC #.  En este idioma, es m√°s f√°cil lograr el rendimiento que necesitamos, es m√°s dif√≠cil escribir un error y es m√°s f√°cil trabajar con √©l. <br><br>  Aqu√≠ hay una captura de pantalla de Burst Inspector, donde puede ver f√°cilmente qu√© instrucciones de ensamblaje se generaron para sus diversos hot loops: <br><br><img src="https://habrastorage.org/webt/sx/ui/ik/sxuiikqzzuyj6y4lhtbv6pbzm0k.png" alt="imagen"><br><br>  La unidad tiene muchos usuarios diferentes.  Algunos de ellos pueden recordar todo el conjunto de instrucciones arm64 de memoria, mientras que otros simplemente crean con entusiasmo, incluso sin un doctorado en ciencias de la computaci√≥n. <br>  Todos los usuarios ganan cuando acelera la fracci√≥n del tiempo de trama que se dedica a ejecutar el c√≥digo del motor (generalmente 90% o m√°s).  La parte de trabajar con el c√≥digo ejecutable del paquete Asset Store se est√° acelerando realmente, ya que los autores del paquete Asset Store est√°n adoptando HPC #. <br><br>  Los usuarios avanzados tambi√©n se beneficiar√°n del hecho de que pueden escribir su propio c√≥digo de alto rendimiento en HPC #. <br><br><h3>  Optimizaci√≥n de puntos </h3><br>  En C ++, es muy dif√≠cil hacer que el compilador tome diferentes decisiones de compromiso para optimizar el c√≥digo en diferentes partes de su proyecto.  La optimizaci√≥n m√°s detallada con la que puede contar es una indicaci√≥n archivo por archivo del nivel de optimizaci√≥n. <br><br>  Burst est√° dise√±ado para que pueda aceptar el √∫nico m√©todo de este programa como entrada, a saber: el punto de entrada al bucle activo.  Burst compila esta funci√≥n, as√≠ como todo lo que llama (se debe garantizar que dichos elementos llamados sean conocidos de antemano: no permitimos funciones virtuales o punteros de funci√≥n). <br><br>  Dado que Burst opera solo en una parte relativamente peque√±a del programa, establecemos el nivel de optimizaci√≥n en 11. Burst incorpora casi todos los sitios de llamadas.  Elimine las verificaciones if, que de lo contrario no se eliminar√≠an, ya que en el formulario incrustado obtenemos informaci√≥n m√°s completa sobre los argumentos de la funci√≥n. <br><br><h3>  ¬øC√≥mo ayuda a resolver problemas comunes de enhebrado? </h3><br>  C ++ (as√≠ como C #) no ayudan particularmente a los desarrolladores a escribir c√≥digo seguro para subprocesos. <br><br>  Incluso hoy, m√°s de una d√©cada despu√©s de que un procesador de juegos t√≠pico comenzara a equiparse con dos o m√°s n√∫cleos, es muy dif√≠cil escribir programas que usen eficientemente varios n√∫cleos. <br><br>  La carrera de datos, el no determinismo y los puntos muertos son los principales desaf√≠os que hacen que sea tan dif√≠cil escribir c√≥digo multiproceso.  En este contexto, necesitamos caracter√≠sticas de la categor√≠a de "aseg√∫rese de que esta funci√≥n y todo lo que llama nunca comenzar√°n a leer o escribir el estado global".  Queremos que todas las violaciones de esta regla den errores de compilaci√≥n y no sigan siendo "reglas a las que esperamos que se adhieran todos los programadores".  Burst arroja un error de compilaci√≥n. <br><br>  Recomendamos encarecidamente a los usuarios de Unity (y mantenemos lo mismo en su c√≠rculo) que escriban c√≥digo para que todas las transformaciones de datos planificadas en √©l se dividan en tareas.  Cada tarea es "funcional" y, como efecto secundario, gratuita.  Indica expl√≠citamente las memorias intermedias de solo lectura y las memorias intermedias de lectura / escritura con las que tiene que trabajar.  Cualquier intento de acceder a otros datos provocar√° un error de compilaci√≥n. <br>  El Programador de tareas garantiza que nadie escriba en su b√∫fer de solo lectura mientras se ejecuta su tarea.  Y garantizamos que durante la duraci√≥n de la tarea nadie leer√° de su b√∫fer, dise√±ado para leer y escribir. <br><br>  Cada vez que asigne una tarea que viole estas reglas, recibir√° un error de compilaci√≥n.  No solo en un evento tan desafortunado como las condiciones de la carrera.  El mensaje de error explicar√° que est√° intentando asignar una tarea que deber√≠a leer desde el b√∫fer A, pero previamente ha asignado una tarea que escribir√° en A. Por lo tanto, si realmente desea hacer esto, la tarea anterior debe especificarse como una dependencia . <br><br>  Creemos que dicho mecanismo de seguridad ayuda a detectar muchos errores antes de que se corrijan y, por lo tanto, garantiza el uso eficiente de todos los n√∫cleos.  Se hace imposible provocar condiciones de carrera o punto muerto.  Se garantiza que los resultados ser√°n deterministas, independientemente de cu√°ntos subprocesos tenga o cu√°ntas veces se interrumpa un subproceso debido a la intervenci√≥n de alg√∫n otro proceso. <br><br><h3>  Domina toda la pila </h3><br>  Cuando podemos llegar al fondo de todos estos componentes, tambi√©n podemos asegurarnos de que sean conscientes unos de otros.  Por ejemplo, una raz√≥n com√∫n para la falla de vectorizaci√≥n es esta: el compilador no puede garantizar que dos punteros no apunten al mismo punto de memoria (aliasing).  Sabemos que dos NativeArray de ninguna manera se superpondr√°n de esta manera, ya que han escrito una biblioteca de colecci√≥n, y podemos usar este conocimiento en Burst, por lo que no nos negaremos a optimizar solo por temor a que dos punteros puedan dirigirse a uno el mismo recuerdo <br><br>  Del mismo modo, escribimos la biblioteca matem√°tica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Unity.Mathematics</a> .  Burst se la conoce "completamente". Burst (en el futuro) podr√° se√±alar la opci√≥n de no optimizarse en casos como math.sin ().  Dado que para Burst, math.sin () no es solo un m√©todo ordinario de C # que debe compilarse, tambi√©n comprender√° las propiedades trigonom√©tricas de sin (), comprender√° que sin (x) == x para valores peque√±os de x (que Burst puede probar independientemente ), entender√° que puede ser reemplazado por la expansi√≥n en la serie Taylor, sacrificando en parte la precisi√≥n.  En el futuro, Burst tambi√©n planea implementar un determinismo multiplataforma y de dise√±o con un punto flotante; creemos que tales objetivos son alcanzables. <br><br><h3>  Las diferencias entre el c√≥digo del motor del juego y el c√≥digo del juego son borrosas </h3><br>  Cuando escribimos el c√≥digo de tiempo de ejecuci√≥n de Unity en HPC #, el motor del juego y el juego como tal est√°n escritos en el mismo idioma.  Podemos distribuir los sistemas de tiempo de ejecuci√≥n que convertimos a HPC # como c√≥digo fuente.  Todos pueden aprender de ellos, mejorarlos, adaptarlos por s√≠ mismos.  Tendremos un campo de juego de cierto nivel, y nada impedir√° que nuestros usuarios escriban un mejor sistema de part√≠culas, f√≠sica del juego o un renderizador de lo que escribimos.  Al acercar nuestros procesos de desarrollo interno a los procesos de desarrollo del usuario, tambi√©n podemos sentirnos mejor en el lugar del usuario, por lo que pondremos todos nuestros esfuerzos en crear un flujo de trabajo √∫nico, en lugar de dos diferentes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444526/">https://habr.com/ru/post/444526/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444516/index.html">Wolfenstein 3D: trazado de rayos con WebGL1</a></li>
<li><a href="../444518/index.html">Hacia una teor√≠a fundamental de la conciencia.</a></li>
<li><a href="../444520/index.html">2. Check Point Getting Started R80.20. Arquitectura de soluciones</a></li>
<li><a href="../444522/index.html">Apocalipsis es cancelado</a></li>
<li><a href="../444524/index.html">Lambdas: de C ++ 11 a C ++ 20. Parte 1</a></li>
<li><a href="../444528/index.html">Situaci√≥n: Jap√≥n puede limitar la descarga de contenido de la red: entendemos y discutimos</a></li>
<li><a href="../444530/index.html">El futuro de la inyecci√≥n de dependencia en Android</a></li>
<li><a href="../444534/index.html">Escaneo de vulnerabilidades y desarrollo seguro. Parte 1</a></li>
<li><a href="../444536/index.html">MVCC-2. Capas, Archivos, P√°ginas</a></li>
<li><a href="../444540/index.html">Intel est√° listo para comenzar la producci√≥n de memoria MRAM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>