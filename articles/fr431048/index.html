<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö£üèº üò• üéà La machine d'√©v√©nement garde le cycle de vie üßùüèº üë©üèª‚Äç‚úàÔ∏è üë®üèΩ‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avertissement: cet article d√©crit une solution non √©vidente √† un probl√®me non √©vident. Avant de se pr√©cipiter  oeufs  mettre en pratique, je recommand...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La machine d'√©v√©nement garde le cycle de vie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431048/"><blockquote>  Avertissement: cet article d√©crit une solution non √©vidente √† un probl√®me non √©vident.  Avant de se pr√©cipiter <del>  oeufs </del>  mettre en pratique, je recommande de lire l'article √† la fin et d'y r√©fl√©chir √† deux fois. </blockquote><p><img src="https://habrastorage.org/webt/sb/cj/hs/sbcjhsnrjjqhgrl0xcpicmvzn40.png" alt="mais_pourquoi"></p><br><p> Bonjour √† tous!  Lorsque vous travaillez avec du code, nous devons souvent faire face √† l' <em>√©tat</em> .  Un tel cas est le cycle de vie des objets.  La gestion d'un objet avec plusieurs √©tats possibles peut √™tre une t√¢che tr√®s simple.  Ajoutez ici une ex√©cution asynchrone et la t√¢che est compliqu√©e par un ordre de grandeur.  Il existe une solution efficace et naturelle.  Dans cet article, je vais parler de la machine d'√©v√©nements et de la fa√ßon de l'impl√©menter dans Go. </p><a name="habracut"></a><br><h2 id="zachem-upravlyat-sostoyaniem">  Pourquoi g√©rer l'√âtat? </h2><br><p>  Pour commencer, d√©finissons le concept lui-m√™me.  L'exemple le plus simple d'un √©tat: fichiers et diverses connexions.  Vous ne pouvez pas simplement prendre et lire un fichier.  Il doit d'abord √™tre ouvert, et √† la fin <del>  de pr√©f√©rence </del>  assurez-vous de fermer.  Il s'av√®re que l'action en cours d√©pend du r√©sultat de l'action pr√©c√©dente: la lecture d√©pend de l'ouverture.  Le r√©sultat enregistr√© est l'√©tat. </p><br><p>  Le principal probl√®me avec l'√âtat est la complexit√©.  Tout √©tat complique automatiquement le code.  Vous devez stocker les r√©sultats des actions en m√©moire et ajouter diverses v√©rifications √† la logique.  C'est pourquoi les architectures sans √©tat sont si attrayantes pour les programmeurs - personne ne veut <del>  des ennuis </del>  difficult√©s.  Si les r√©sultats de vos actions n'affectent pas la logique d'ex√©cution, vous n'avez pas besoin d'un √©tat. </p><br><p>  Cependant, il existe une propri√©t√© qui vous fait tenir compte des difficult√©s.  Un √©tat vous oblige √† suivre un ordre sp√©cifique d'actions.  En g√©n√©ral, de telles situations doivent √™tre √©vit√©es, mais ce n'est pas toujours possible.  Un exemple est le cycle de vie des objets de programme.  Gr√¢ce √† une bonne gestion des √©tats, on peut obtenir un comportement pr√©visible des objets avec un cycle de vie complexe. </p><br><p>  Voyons maintenant comment le faire <em>cool</em> . </p><br><h2 id="avtomat-kak-sposob-resheniya-problem">  Automatique pour r√©soudre les probl√®mes </h2><br><p><img src="https://habrastorage.org/webt/eg/qd/1o/egqd1oejaztizauope6waesapm0.jpeg" alt="AK74"></p><br><p>  Lorsque les gens parlent d'√©tats, les machines √† √©tats finis viennent imm√©diatement √† l'esprit.  C‚Äôest logique, car un automate est le moyen le plus naturel de g√©rer un √©tat. </p><br><blockquote>  Je ne m'attarderai pas sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">th√©orie des automates</a> , il y a plus qu'assez d'informations sur Internet. </blockquote><p>  Si vous cherchez des exemples de machines √† √©tats finis pour Go, vous rencontrerez certainement un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lexer de Rob Pike</a> .  Un excellent exemple d'automate dans lequel les donn√©es trait√©es sont l'alphabet d'entr√©e.  Cela signifie que les transitions d'√©tat sont provoqu√©es par le texte que le lexeur traite.  Solution √©l√©gante √† un probl√®me sp√©cifique. </p><br><p>  La principale chose √† comprendre est qu'un automate est une solution √† un probl√®me strictement sp√©cifique.  Par cons√©quent, avant de le consid√©rer comme un rem√®de √† tous les probl√®mes, vous devez bien comprendre la t√¢che.  Plus pr√©cis√©ment, l'entit√© que vous souhaitez contr√¥ler: </p><br><ul><li>  √©tats - cycle de vie; </li><li>  √©v√©nements - ce qui provoque exactement la transition vers chaque √©tat; </li><li>  r√©sultat du travail - donn√©es de sortie; </li><li>  mode d'ex√©cution (synchrone / asynchrone); </li><li>  principaux cas d'utilisation. </li></ul><br><p>  Le lexer est beau, mais il ne change d'√©tat qu'en raison des donn√©es qu'il traite lui-m√™me.  Mais qu'en est-il de la situation o√π l'utilisateur invoque des transitions?  C'est l√† que la machine √©v√©nementielle peut vous aider. </p><br><h2 id="realnyy-primer">  Exemple r√©el </h2><br><p> Pour plus de clart√©, j'analyserai un exemple de la biblioth√®que <code>phono</code> . </p><br><blockquote>  Pour une immersion compl√®te dans le contexte, vous pouvez lire l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article d'introduction</a> .  Ce n'est pas n√©cessaire pour ce sujet, mais cela aidera √† mieux comprendre ce que nous g√©rons. </blockquote><br><h3 id="a-chem-upravlyaem">  Et que g√©rons-nous? </h3><br><p>  <code>phono</code> est bas√© sur le pipeline DSP.  Il se compose de trois √©tapes de traitement.  Chaque √©tape peut comprendre un √† plusieurs composants: </p><br><p><img src="https://habrastorage.org/webt/go/ym/ep/goymepjg4pds_picireejjsshnq.png" alt="pipe_diagram"></p><br><ol><li>  <code>pipe.Pump</code> (pompe anglaise) est une √©tape obligatoire de <strong>r√©ception du</strong> son, toujours un seul composant. </li><li>  <code>pipe.Processor</code> (gestionnaire anglais) - une √©tape facultative <strong>de traitement du</strong> son, de 0 √† N composants. </li><li>  <code>pipe.Sink</code> (English sink) - une √©tape obligatoire <strong>de transmission du</strong> son, de 1 √† N composants. </li></ol><br><p>  En fait, nous g√©rerons le cycle de vie du convoyeur. </p><br><h3 id="zhiznennyy-cikl">  Cycle de vie </h3><br><p>  Voici √† quoi ressemble le diagramme d'√©tat du <code>pipe.Pipe</code> . </p><br><p><img src="https://habrastorage.org/webt/le/ni/xq/lenixqpvoh0zaq9j2aftrqprtvg.png" alt="pipe_lifecycle"></p><br><p>  <em>Les italiques</em> indiquent les transitions caus√©es par la logique d'ex√©cution interne.  <strong>Gras</strong> - transitions caus√©es par les √©v√©nements.  Le diagramme montre que les √©tats sont divis√©s en 2 types: </p><br><ul><li>  <strong>√©tats de repos</strong> - <code>ready</code> et en <code>paused</code> , vous ne pouvez les sauter que par √©v√©nement </li><li>  <em>√©tats actifs</em> - en <code>running</code> et en <code>pausing</code> , transitions par √©v√©nement et en raison de la logique d'ex√©cution </li></ul><br><p>  Avant une analyse d√©taill√©e du code, un exemple clair de l'utilisation de tous les √©tats: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// PlayWav  .wav    portaudio  -. func PlayWav(wavFile string) error { bufferSize := phono.BufferSize(512) //      w, err := wav.NewPump(wavFile, bufferSize) //  wav pump if err != nil { return err } pa := portaudio.NewSink( //  portaudio sink bufferSize, w.WavSampleRate(), w.WavNumChannels(), ) p := pipe.New( //  pipe.Pipe    ready w.WavSampleRate(), pipe.WithPump(w), pipe.WithSinks(pa), ) p.Run() //    running   p.Run() errc := p.Pause() //    pausing   p.Pause() err = pipe.Wait(errc) //     paused if err != nil { return err } errc = p.Resume() //    running   p.Resume() err = pipe.Wait(errc) //     ready if err != nil { return err } return pipe.Wait(p.Close()) //      }</span></span></code> </pre> <br><p>  Maintenant, tout d'abord. </p><br><blockquote>  Tout le code source est disponible dans le <a href="">r√©f√©rentiel</a> . </blockquote><br><h3 id="sostoyaniya-i-sobytiya">  √âtats et √©v√©nements </h3><br><p>  Commen√ßons par la chose la plus importante. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// state      . type state interface { listen(*Pipe, target) (state, target) //    transition(*Pipe, eventMessage) (state, error) //   } // idleState  .        . type idleState interface { state } // activeState  .         //   . type activeState interface { state sendMessage(*Pipe) state //    } //  . type ( idleReady struct{} activeRunning struct{} activePausing struct{} idlePaused struct{} ) //  . var ( ready idleReady running activeRunning paused idlePaused pausing activePausing )</span></span></code> </pre> <br><p>  Gr√¢ce √† des types distincts, les transitions sont √©galement d√©clar√©es s√©par√©ment pour chaque √©tat.  Cela √©vite l'√©norme <del>  saucisses </del>  fonctions de transition avec des <code>switch</code> imbriqu√©es.  Les √©tats eux-m√™mes ne contiennent aucune donn√©e ni logique.  Pour eux, vous pouvez d√©clarer des variables au niveau du package afin de ne pas le faire √† chaque fois.  L'interface d' <code>state</code> est n√©cessaire pour le polymorphisme.  <code>activeState</code> parlerons d' <code>activeState</code> et <code>idleState</code> peu plus tard. </p><br><p>  Les √©v√©nements sont la deuxi√®me partie la plus importante de notre machine. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// event  . type event int //  . const ( run event = iota pause resume push measure cancel ) // target      . type target struct { state idleState //   errc chan error //   ,     } // eventMessage   ,    . type eventMessage struct { event //   params params //   components []string // id  target //      }</span></span></code> </pre> <br><p>  Pour comprendre pourquoi le type <code>target</code> est n√©cessaire, consid√©rons un exemple simple.  Nous avons cr√©√© un nouveau convoyeur, il est <code>ready</code> .  Maintenant, ex√©cutez-le avec <code>p.Run()</code> .  L'√©v√©nement d' <code>run</code> est envoy√© √† la machine, le pipeline passe √† l'√©tat d' <code>running</code> .  Comment savoir quand le convoyeur est termin√©?  C'est l√† que le type <code>target</code> nous aidera.  Il indique √† quel √©tat de repos s'attendre apr√®s l'√©v√©nement.  Dans notre exemple, une fois le travail termin√©, le pipeline passera √† nouveau √† l'√©tat <code>ready</code> .  La m√™me chose dans le diagramme: </p><br><p><img src="https://habrastorage.org/webt/h8/4i/xv/h84ixvb5dd_2gdbnrcd3kggwyzg.png"></p><br><p>  Maintenant, plus sur les types d'√©tats.  Plus pr√©cis√©ment, sur les <code>activeState</code> <code>idleState</code> et <code>activeState</code> .  Regardons les fonctions d' <code>listen(*Pipe, target) (state, target)</code> pour diff√©rents types d'√©tapes: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// listen     ready. func (s idleReady) listen(p *Pipe, t target) (state, target) { return p.idle(s, t) } // listen     running. func (s activeRunning) listen(p *Pipe, t target) (state, target) { return p.active(s, t) }</span></span></code> </pre> <br><p>  <code>pipe.Pipe</code> a diff√©rentes fonctions pour attendre une transition!  Qu'y a-t-il? </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// idle     .    . func (p *Pipe) idle(s idleState, t target) (state, target) { if s == t.state || s == ready { t = t.dismiss() //  ,  target } for { var newState state var err error select { case e := &lt;-p.events: //   newState, err = s.transition(p, e) //    if err != nil { e.target.handle(err) } else if e.hasTarget() { t.dismiss() t = e.target } } if s != newState { return newState, t // ,    } } } // active     .     , //   . func (p *Pipe) active(s activeState, t target) (state, target) { for { var newState state var err error select { case e := &lt;-p.events: //   newState, err = s.transition(p, e) //    if err != nil { //  ? e.target.handle(err) // ,    } else if e.hasTarget() { // ,  target t.dismiss() //   t = e.target //   } case &lt;-p.provide: //     newState = s.sendMessage(p) //    case err, ok := &lt;-p.errc: //   if ok { //   ,  interrupt(p.cancel) //   t.handle(err) //    } //    ,  return ready, t //    ready } if s != newState { return newState, t // ,    } } }</span></span></code> </pre> <br><p>  Ainsi, nous pouvons √©couter diff√©rentes cha√Ænes dans diff√©rents √©tats.  Par exemple, cela vous permet de ne pas envoyer de messages pendant une pause - nous n'√©coutons tout simplement pas le canal correspondant. </p><br><h3 id="konstruktor-i-start-avtomata">  Constructeur et d√©marrage de la machine </h3><br><p><img src="https://habrastorage.org/webt/bk/h2/zn/bkh2znujbo_omto9lyhcq-ixp-e.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// New      . //      ready. func New(sampleRate phono.SampleRate, options ...Option) *Pipe { p := &amp;Pipe{ UID: phono.NewUID(), sampleRate: sampleRate, log: log.GetLogger(), processors: make([]*processRunner, 0), sinks: make([]*sinkRunner, 0), metrics: make(map[string]measurable), params: make(map[string][]phono.ParamFunc), feedback: make(map[string][]phono.ParamFunc), events: make(chan eventMessage, 1), //    cancel: make(chan struct{}), //     provide: make(chan struct{}), consume: make(chan message), } for _, option := range options { //   option(p)() } go p.loop() //    return p }</span></span></code> </pre> <br><p>  En plus de l'initialisation et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des options fonctionnelles</a> , il y a le d√©but d'une goroutine s√©par√©e avec le cycle principal.  Eh bien, regardez-le: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// loop ,     nil . func (p *Pipe) loop() { var s state = ready //   t := target{} for s != nil { s, t = s.listen(p, t) //      p.log.Debug(fmt.Sprintf("%v is %T", p, s)) } t.dismiss() close(p.events) //    } // listen     ready. func (s idleReady) listen(p *Pipe, t target) (state, target) { return p.idle(s, t) } // transition       . func (s idleReady) transition(p *Pipe, e eventMessage) (state, error) { switch e.event { case cancel: interrupt(p.cancel) return nil, nil case push: e.params.applyTo(p.ID()) p.params = p.params.merge(e.params) return s, nil case measure: for _, id := range e.components { e.params.applyTo(id) } return s, nil case run: if err := p.start(); err != nil { return s, err } return running, nil } return s, ErrInvalidState }</span></span></code> </pre> <br><p>  Le convoyeur est cr√©√© et fig√© en pr√©vision des √©v√©nements. </p><br><h3 id="pora-rabotat">  Le temps de travailler </h3><br><p>  Appelez <code>p.Run()</code> ! </p><br><p><img src="https://habrastorage.org/webt/wv/vi/vs/wvvivsokwwjkjvvcibg-kyvi9m0.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Run   run  . //     pipe.Close  . func (p *Pipe) Run() chan error { runEvent := eventMessage{ event: run, target: target{ state: ready, //    errc: make(chan error, 1), }, } p.events &lt;- runEvent return runEvent.target.errc } // listen     running. func (s activeRunning) listen(p *Pipe, t target) (state, target) { return p.active(s, t) } // transition       . func (s activeRunning) transition(p *Pipe, e eventMessage) (state, error) { switch e.event { case cancel: interrupt(p.cancel) err := Wait(p.errc) return nil, err case measure: e.params.applyTo(p.ID()) p.feedback = p.feedback.merge(e.params) return s, nil case push: e.params.applyTo(p.ID()) p.params = p.params.merge(e.params) return s, nil case pause: return pausing, nil } return s, ErrInvalidState } // sendMessage   . func (s activeRunning) sendMessage(p *Pipe) state { p.consume &lt;- p.newMessage() return s }</span></span></code> </pre> <br><p>  <code>running</code> g√©n√®re des messages et s'ex√©cute jusqu'√† la fin du pipeline. </p><br><h3 id="sdelay-pauzu">  Pause </h3><br><p>  Pendant l'ex√©cution du convoyeur, nous pouvons le mettre en pause.  Dans cet √©tat, le pipeline ne g√©n√©rera pas de nouveaux messages.  Pour ce faire, appelez la m√©thode <code>p.Pause()</code> . </p><br><p><img src="https://habrastorage.org/webt/-2/9k/xz/-29kxztxwy56ftsphj9-blcbkei.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Pause   pause  . //     pipe.Close  . func (p *Pipe) Pause() chan error { pauseEvent := eventMessage{ event: pause, target: target{ state: paused, //    errc: make(chan error, 1), }, } p.events &lt;- pauseEvent return pauseEvent.target.errc } // listen     pausing. func (s activePausing) listen(p *Pipe, t target) (state, target) { return p.active(s, t) } // transition       . func (s activePausing) transition(p *Pipe, e eventMessage) (state, error) { switch e.event { case cancel: interrupt(p.cancel) err := Wait(p.errc) return nil, err case measure: e.params.applyTo(p.ID()) p.feedback = p.feedback.merge(e.params) return s, nil case push: e.params.applyTo(p.ID()) p.params = p.params.merge(e.params) return s, nil } return s, ErrInvalidState } // sendMessage   .   -, //      .    //    ,      .  , // ,   , : // 1.     // 2.      func (s activePausing) sendMessage(p *Pipe) state { m := p.newMessage() if len(m.feedback) == 0 { m.feedback = make(map[string][]phono.ParamFunc) } var wg sync.WaitGroup //     wg.Add(len(p.sinks)) //   Sink for _, sink := range p.sinks { param := phono.ReceivedBy(&amp;wg, sink.ID()) // - m.feedback = m.feedback.add(param) } p.consume &lt;- m //   wg.Wait() // ,     return paused }</span></span></code> </pre> <br><p>  D√®s que tous les destinataires re√ßoivent le message, le pipeline passe √† <code>paused</code> √©tat <code>paused</code> .  Si le message est le dernier, la transition vers l'√©tat <code>ready</code> se produit. </p><br><h3 id="snova-za-rabotu">  De retour au travail! </h3><br><p>  Pour quitter l'√©tat <code>paused</code> , appelez <code>p.Resume()</code> . </p><br><p><img src="https://habrastorage.org/webt/vq/gu/dj/vqgudjnhdlifwyb6acyrkpbmkek.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Resume   resume  . //     pipe.Close  . func (p *Pipe) Resume() chan error { resumeEvent := eventMessage{ event: resume, target: target{ state: ready, errc: make(chan error, 1), }, } p.events &lt;- resumeEvent return resumeEvent.target.errc } // listen     paused. func (s idlePaused) listen(p *Pipe, t target) (state, target) { return p.idle(s, t) } // transition       . func (s idlePaused) transition(p *Pipe, e eventMessage) (state, error) { switch e.event { case cancel: interrupt(p.cancel) err := Wait(p.errc) return nil, err case push: e.params.applyTo(p.ID()) p.params = p.params.merge(e.params) return s, nil case measure: for _, id := range e.components { e.params.applyTo(id) } return s, nil case resume: return running, nil } return s, ErrInvalidState }</span></span></code> </pre> <br><p>  Tout est trivial ici, le pipeline passe √† nouveau en √©tat de <code>running</code> . </p><br><h3 id="svorachivaemsya">  D√©tendez-vous </h3><br><p>  Le convoyeur peut √™tre arr√™t√© depuis n'importe quel √©tat.  Il y a <code>p.Close()</code> . </p><br><p><img src="https://habrastorage.org/webt/va/lt/tz/valttzm_l7cqsibb6mi1ntxh6vy.png"></p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Close   cancel  . //      . //    ,   . func (p *Pipe) Close() chan error { resumeEvent := eventMessage{ event: cancel, target: target{ state: nil, //   errc: make(chan error, 1), }, } p.events &lt;- resumeEvent return resumeEvent.target.errc }</span></span></code> </pre> <br><h2 id="komu-eto-nado">  Qui en a besoin? </h2><br><p>  Pas pour tout le monde.  Pour comprendre exactement comment g√©rer l'√©tat, vous devez comprendre votre t√¢che.  Il existe exactement deux circonstances dans lesquelles <em>vous pouvez</em> utiliser une machine asynchrone bas√©e sur des √©v√©nements: </p><br><ol><li>  Cycle de vie complexe - il y a trois √©tats ou plus avec des transitions non lin√©aires. </li><li>  L'ex√©cution asynchrone est utilis√©e. </li></ol><br><p>  Bien que la machine √©v√©nementielle r√©sout le probl√®me, c'est un mod√®le assez compliqu√©.  Par cons√©quent, il doit √™tre utilis√© avec grand soin et uniquement apr√®s une compr√©hension compl√®te de tous les avantages et inconv√©nients. </p><br><h2 id="ssylki">  Les r√©f√©rences </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">phono</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lexer Rob Pike</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431048/">https://habr.com/ru/post/fr431048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431036/index.html">¬´Le monde entier - analyse¬ª ou ¬´Analysez-le¬ª</a></li>
<li><a href="../fr431040/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 340 (19-25 novembre 2018)</a></li>
<li><a href="../fr431042/index.html">PHP Digest n ¬∞ 144 (12-26 novembre 2018)</a></li>
<li><a href="../fr431044/index.html">Le parquet paiera pour la premi√®re fois le blocage ill√©gal du site</a></li>
<li><a href="../fr431046/index.html">Fonctionnement r√©el de z-index</a></li>
<li><a href="../fr431050/index.html">L'illusion de la puret√©: la min√©ralisation de l'eau affecte-t-elle sa qualit√© et comment le compteur TDS nous aidera-t-il?</a></li>
<li><a href="../fr431052/index.html">Devend Day: cartes, √©quipes, deux requ√™tes</a></li>
<li><a href="../fr431056/index.html">USPACE: Drones Time</a></li>
<li><a href="../fr431058/index.html">Premiers pas avec Unicorn Engine</a></li>
<li><a href="../fr431060/index.html">Usurpation d'identit√© allemande avec authentification en ligne et financement des r√©fugi√©s en Allemagne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>