<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚öïÔ∏è üçø üß¢ Berechnung magischer Quadrate mit einer GPU üñêüèΩ üôÖüèø üêÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr. 

 Das Thema "magische Quadrate" ist ziemlich interessant, weil Einerseits sind sie seit der Antike bekannt, andererseits ist die Berechnu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berechnung magischer Quadrate mit einer GPU</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424845/"> Hallo habr. <br><br>  Das Thema "magische Quadrate" ist ziemlich interessant, weil  Einerseits sind sie seit der Antike bekannt, andererseits ist die Berechnung des "magischen Quadrats" auch heute noch eine sehr schwierige Rechenaufgabe.  Denken Sie daran, um das ‚Äûmagische Quadrat‚Äú NxN zu konstruieren, m√ºssen Sie die Zahlen 1..N * N eingeben, damit die Summe seiner Horizontalen, Vertikalen und Diagonalen gleich der gleichen Zahl ist.  Wenn Sie einfach die Anzahl aller Optionen zum Anordnen der Zahlen f√ºr ein 4x4-Quadrat sortieren, erhalten wir 16!  = 20.922.789.888.000 Optionen. <br><br>  √úberlegen Sie, wie dies effizienter durchgef√ºhrt werden kann. <br><br><img src="https://habrastorage.org/webt/jc/nd/cc/jcndccahc944f3iihffugn_bjsc.png"><br><a name="habracut"></a><br>  Zun√§chst wiederholen wir den Zustand des Problems.  Sie m√ºssen die Zahlen in einem Quadrat anordnen, damit sie sich nicht wiederholen, und die Summe der Horizontalen, Vertikalen und Diagonalen war gleich der gleichen Zahl. <br><br>  Es ist leicht zu beweisen, dass diese Summe immer gleich ist und nach der Formel f√ºr jedes n berechnet wird: <br><br><img src="https://habrastorage.org/webt/06/wm/50/06wm50ycmeo5nszgdlm8iuu8pc4.png"><br><br>  Wir werden 4x4 Quadrate betrachten, also die Summe = 34. <br><br>  Bezeichne alle Variablen mit X, unser Quadrat sieht folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/pw/zm/8z/pwzm8zao36smcgnpgv2bn8clwxk.png"><br><br>  Die erste und offensichtliche Eigenschaft:  Wenn die Summe des Quadrats bekannt ist, k√∂nnen die extremen Stoblts durch die verbleibenden 3 ausgedr√ºckt werden: <br><br> <code>X14 = S - X11 - X12 - X13 <br> X24 = S - X21 - X22 - X23 <br> ... <br> X41 = S - X11 - X21 - X31</code> <br> <br>  So wird aus einem 4x4-Quadrat tats√§chlich ein 3x3-Quadrat, wodurch die Anzahl der Suchoptionen von 16 reduziert wird!  bis zu 9!, d.h.  57 Millionen Mal.  Wenn wir das wissen, beginnen wir Code zu schreiben und sehen, wie kompliziert eine solch ersch√∂pfende Suche nach modernen Computern ist. <br><br><h3>  C ++ - Single-Threaded-Version </h3><br>  Das Prinzip des Programms ist sehr einfach.  Wir nehmen die Menge der Zahlen 1..16 und die for-Schleife √ºber diese Menge, es wird x11 sein.  Dann nehmen wir den zweiten Satz, bestehend aus dem ersten mit Ausnahme der Zahl x11 und so weiter. <br><br>  Eine ungef√§hre Form des Programms sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> squares = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> digits[] = { <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>,<span class="hljs-number"><span class="hljs-number">16</span></span> }; <span class="hljs-function"><span class="hljs-function">Set </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(digits, digits + N*N)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x11 = <span class="hljs-number"><span class="hljs-number">1</span></span>; x11 &lt;= MAX; x11++) { <span class="hljs-function"><span class="hljs-function">Set </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set12</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mset)</span></span></span></span>; set12.erase(x11); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (SetIterator it12 = set12.begin(); it12 != set12.end(); it12++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x12 = *it12; <span class="hljs-function"><span class="hljs-function">Set </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set13</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(set12)</span></span></span></span>; set13.erase(x12); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (SetIterator it13 = set13.begin(); it13 != set13.end(); it13++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x13 = *it13; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x14 = S - x11 - x12 - x13; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x14 &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || x14 &gt; MAX) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x14 == x11 || x14 == x12 || x14 == x13) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sh1 = x11 + x12 + x13 + x14, sh2 = x21 + x22 + x23 + x24, sh3 = x31 + x32 + x33 + x34, sh4 = x41 + x42 + x43 + x44; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sv1 = x11 + x21 + x31 + x41, sv2 = x12 + x22 + x32 + x42, sv3 = x13 + x23 + x33 + x43, sv4 = x14 + x24 + x34 + x44; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sd1 = x11 + x22 + x33 + x44, sd2 = x14 + x23 + x32 + x41; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sh1 != S || sh2 != S || sh3 != S || sh4 != S || sv1 != S || sv2 != S || sv3 != S || sv4 != S || sd1 != S || sd2 != S) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       ,    printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n", x11, x12, x13, x14, x21, x22, x23, x24, x31, x32, x33, x34, x41, x42, x43, x44); squares++; } } printf("CNT: %d\n", squares);</span></span></code> </pre><br>  Den vollst√§ndigen Text des Programms finden Sie unter dem Spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Ganze Quelle</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; #include &lt;stdio.h&gt; #include &lt;ctime&gt; #include "stdafx.h" typedef std::set&lt;int&gt; Set; typedef Set::iterator SetIterator; #define N 4 #define MAX (N*N) #define S 34 int main(int argc, char *argv[]) { // x11 x12 x13 x14 // x21 x22 x23 x24 // x31 x32 x33 x34 // x41 x42 x43 x44 const clock_t begin_time = clock(); int squares = 0; int digits[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 }; Set mset(digits, digits + N*N); for (int x11 = 1; x11 &lt;= MAX; x11++) { Set set12(mset); set12.erase(x11); for (SetIterator it12 = set12.begin(); it12 != set12.end(); it12++) { int x12 = *it12; Set set13(set12); set13.erase(x12); for (SetIterator it13 = set13.begin(); it13 != set13.end(); it13++) { int x13 = *it13; int x14 = S - x11 - x12 - x13; if (x14 &lt; 1 || x14 &gt; MAX) continue; if (x14 == x11 || x14 == x12 || x14 == x13) continue; Set set21(set13); set21.erase(x13); set21.erase(x14); for (SetIterator it21 = set21.begin(); it21 != set21.end(); it21++) { int x21 = *it21; Set set22(set21); set22.erase(x21); for (SetIterator it22 = set22.begin(); it22 != set22.end(); it22++) { int x22 = *it22; Set set23(set22); set23.erase(x22); for (SetIterator it23 = set23.begin(); it23 != set23.end(); it23++) { int x23 = *it23, x24 = S - x21 - x22 - x23; if (x24 &lt; 1 || x24 &gt; MAX) continue; if (x24 == x11 || x24 == x12 || x24 == x13 || x24 == x14 || x24 == x21 || x24 == x22 || x24 == x23) continue; Set set31(set23); set31.erase(x23); set31.erase(x24); for (SetIterator it31 = set31.begin(); it31 != set31.end(); it31++) { int x31 = *it31; Set set32(set31); set32.erase(x31); for (SetIterator it32 = set32.begin(); it32 != set32.end(); it32++) { int x32 = *it32; Set set33(set32); set33.erase(x32); for (SetIterator it33 = set33.begin(); it33 != set33.end(); it33++) { int x33 = *it33, x34 = S - x31 - x32 - x33; if (x34 &lt; 1 || x34 &gt; MAX) continue; if (x34 == x11 || x34 == x12 || x34 == x13 || x34 == x14 || x34 == x21 || x34 == x22 || x34 == x23 || x34 == x24 || x34 == x31 || x34 == x32 || x34 == x33) continue; int x41 = S - x11 - x21 - x31, x42 = S - x12 - x22 - x32, x43 = S - x13 - x23 - x33, x44 = S - x14 - x24 - x34; if (x41 &lt; 1 || x41 &gt; MAX || x42 &lt; 1 || x42 &gt; MAX || x43 &lt; 1 || x43 &gt; MAX || x44 &lt; 1 || x41 &gt; MAX) continue; if (x41 == x11 || x41 == x12 || x41 == x13 || x41 == x14 || x41 == x21 || x41 == x22 || x41 == x23 || x41 == x24 || x41 == x31 || x41 == x32 || x41 == x33 || x41 == x34) continue; if (x42 == x11 || x42 == x12 || x42 == x13 || x42 == x14 || x42 == x21 || x42 == x22 || x42 == x23 || x42 == x24 || x42 == x31 || x42 == x32 || x42 == x33 || x42 == x34 || x42 == x41) continue; if (x43 == x11 || x43 == x12 || x43 == x13 || x43 == x14 || x43 == x21 || x43 == x22 || x43 == x23 || x43 == x24 || x43 == x31 || x43 == x32 || x43 == x33 || x43 == x34 || x43 == x41 || x43 == x42) continue; if (x44 == x11 || x44 == x12 || x44 == x13 || x44 == x14 || x44 == x21 || x44 == x22 || x44 == x23 || x44 == x24 || x44 == x31 || x44 == x32 || x44 == x33 || x44 == x34 || x44 == x41 || x44 == x42 || x44 == x43) continue; int sh1 = x11 + x12 + x13 + x14, sh2 = x21 + x22 + x23 + x24, sh3 = x31 + x32 + x33 + x34, sh4 = x41 + x42 + x43 + x44; int sv1 = x11 + x21 + x31 + x41, sv2 = x12 + x22 + x32 + x42, sv3 = x13 + x23 + x33 + x43, sv4 = x14 + x24 + x34 + x44; int sd1 = x11 + x22 + x33 + x44, sd2 = x14 + x23 + x32 + x41; if (sh1 != S || sh2 != S || sh3 != S || sh4 != S || sv1 != S || sv2 != S || sv3 != S || sv4 != S || sd1 != S || sd2 != S) continue; printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n", x11, x12, x13, x14, x21, x22, x23, x24, x31, x32, x33, x34, x41, x42, x43, x44); squares++; } } } } } } } } } printf("CNT: %d\n", squares); float diff_t = float(clock() - begin_time)/CLOCKS_PER_SEC; printf("T = %.2fs\n", diff_t); return 0; }</span></span></span></span></code> </pre> <br></div></div><br>  Ergebnis: Es wurden insgesamt <b>7040</b> 4x4- <b>Optionen</b> f√ºr ‚Äûmagische Quadrate‚Äú gefunden, und die Suchzeit betrug <b>102 Sekunden</b> . <br><br><img src="https://habrastorage.org/webt/6c/bc/le/6cbcle75t9b9owheenk5k-p7cms.png"><br><br>  √úbrigens ist es interessant zu √ºberpr√ºfen, ob die Liste der Quadrate dieselbe enth√§lt, die auf D√ºrers Gravur abgebildet ist.  Nat√ºrlich gibt es, weil  Das Programm zeigt <i>alle</i> 4x4-Quadrate an: <br><br><img src="https://habrastorage.org/webt/2h/ew/kx/2hewkxuueb6na-r8vxvra-dnrdu.png"><br><br>  Es sei darauf hingewiesen, dass D√ºrer aus einem bestimmten Grund ein Quadrat in das Bild eingef√ºgt hat. Die Zahlen <i>1514</i> geben auch das Jahr der Gravur an. <br><br>  Wie Sie sehen k√∂nnen, funktioniert das Programm (wir markieren die Aufgabe als von Albrecht D√ºrer um 1514 verifiziert;), aber die Ausf√ºhrungszeit ist f√ºr einen Computer mit einem Core i7-Prozessor nicht so gering.  Offensichtlich l√§uft das Programm in einem einzigen Thread, und es ist ratsam, alle anderen Kernel zu verwenden. <br><br><h3>  C ++ - Multithread-Version </h3><br>  Das Umschreiben eines Programms mithilfe von Streams ist grunds√§tzlich unkompliziert, wenn auch etwas umst√§ndlich.  Gl√ºcklicherweise gibt es heute eine fast vergessene Option - die Verwendung von Unterst√ºtzung f√ºr <b>OpenMP</b> (Open Multi-Processing).  Diese Technologie existiert seit 1998 und erm√∂glicht es Prozessoranweisungen, dem Compiler mitzuteilen, welche Teile des Programms parallel ausgef√ºhrt werden sollen.  OpenMP wird auch in Visual Studio unterst√ºtzt. Um ein Programm in ein Multithread-Programm umzuwandeln, f√ºgen Sie dem Code einfach eine Zeile hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> squares = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp parallel for reduction(+: squares) for (int x11 = 1; x11 &lt;= MAX; x11++) { ... } printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CNT: %d\n"</span></span></span><span class="hljs-meta">, squares);</span></span></code> </pre><br>  Die <i>Direktive #pragma omp parallel</i> for gibt an, dass die n√§chste for-Schleife parallel ausgef√ºhrt werden kann, und die zus√§tzlichen Parameterquadrate legen den Variablennamen fest, der f√ºr parallele Threads √ºblich ist (ohne dies funktioniert das Inkrement nicht richtig). <br><br>  Das Ergebnis ist offensichtlich: Die Ausf√ºhrungszeit wurde von 102 auf <b>18</b> Sekunden reduziert. <br><br><img src="https://habrastorage.org/webt/ji/hl/xt/jihlxtqposct3ttitpeipapjmz0.png"><br><br><div class="spoiler">  <b class="spoiler_title">Ganze Quelle</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; #include &lt;stdio.h&gt; #include &lt;ctime&gt; #include "stdafx.h" typedef std::set&lt;int&gt; Set; typedef Set::iterator SetIterator; #define N 4 #define MAX (N*N) #define S 34 int main(int argc, char *argv[]) { // x11 x12 x13 x14 // x21 x22 x23 x24 // x31 x32 x33 x34 // x41 x42 x43 x44 const clock_t begin_time = clock(); int squares = 0; #pragma omp parallel for reduction(+: squares) for (int x11 = 1; x11 &lt;= MAX; x11++) { int digits[] = { 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 }; Set mset(digits, digits + N*N); Set set12(mset); set12.erase(x11); for (SetIterator it12 = set12.begin(); it12 != set12.end(); it12++) { int x12 = *it12; Set set13(set12); set13.erase(x12); for (SetIterator it13 = set13.begin(); it13 != set13.end(); it13++) { int x13 = *it13; int x14 = S - x11 - x12 - x13; if (x14 &lt; 1 || x14 &gt; MAX) continue; if (x14 == x11 || x14 == x12 || x14 == x13) continue; Set set21(set13); set21.erase(x13); set21.erase(x14); for (SetIterator it21 = set21.begin(); it21 != set21.end(); it21++) { int x21 = *it21; Set set22(set21); set22.erase(x21); for (SetIterator it22 = set22.begin(); it22 != set22.end(); it22++) { int x22 = *it22; Set set23(set22); set23.erase(x22); for (SetIterator it23 = set23.begin(); it23 != set23.end(); it23++) { int x23 = *it23, x24 = S - x21 - x22 - x23; if (x24 &lt; 1 || x24 &gt; MAX) continue; if (x24 == x11 || x24 == x12 || x24 == x13 || x24 == x14 || x24 == x21 || x24 == x22 || x24 == x23) continue; Set set31(set23); set31.erase(x23); set31.erase(x24); for (SetIterator it31 = set31.begin(); it31 != set31.end(); it31++) { int x31 = *it31; Set set32(set31); set32.erase(x31); for (SetIterator it32 = set32.begin(); it32 != set32.end(); it32++) { int x32 = *it32; Set set33(set32); set33.erase(x32); for (SetIterator it33 = set33.begin(); it33 != set33.end(); it33++) { int x33 = *it33, x34 = S - x31 - x32 - x33; if (x34 &lt; 1 || x34 &gt; MAX) continue; if (x34 == x11 || x34 == x12 || x34 == x13 || x34 == x14 || x34 == x21 || x34 == x22 || x34 == x23 || x34 == x24 || x34 == x31 || x34 == x32 || x34 == x33) continue; int x41 = S - x11 - x21 - x31, x42 = S - x12 - x22 - x32, x43 = S - x13 - x23 - x33, x44 = S - x14 - x24 - x34; if (x41 &lt; 1 || x41 &gt; MAX || x42 &lt; 1 || x42 &gt; MAX || x43 &lt; 1 || x43 &gt; MAX || x44 &lt; 1 || x41 &gt; MAX) continue; if (x41 == x11 || x41 == x12 || x41 == x13 || x41 == x14 || x41 == x21 || x41 == x22 || x41 == x23 || x41 == x24 || x41 == x31 || x41 == x32 || x41 == x33 || x41 == x34) continue; if (x42 == x11 || x42 == x12 || x42 == x13 || x42 == x14 || x42 == x21 || x42 == x22 || x42 == x23 || x42 == x24 || x42 == x31 || x42 == x32 || x42 == x33 || x42 == x34 || x42 == x41) continue; if (x43 == x11 || x43 == x12 || x43 == x13 || x43 == x14 || x43 == x21 || x43 == x22 || x43 == x23 || x43 == x24 || x43 == x31 || x43 == x32 || x43 == x33 || x43 == x34 || x43 == x41 || x43 == x42) continue; if (x44 == x11 || x44 == x12 || x44 == x13 || x44 == x14 || x44 == x21 || x44 == x22 || x44 == x23 || x44 == x24 || x44 == x31 || x44 == x32 || x44 == x33 || x44 == x34 || x44 == x41 || x44 == x42 || x44 == x43) continue; int sh1 = x11 + x12 + x13 + x14, sh2 = x21 + x22 + x23 + x24, sh3 = x31 + x32 + x33 + x34, sh4 = x41 + x42 + x43 + x44; int sv1 = x11 + x21 + x31 + x41, sv2 = x12 + x22 + x32 + x42, sv3 = x13 + x23 + x33 + x43, sv4 = x14 + x24 + x34 + x44; int sd1 = x11 + x22 + x33 + x44, sd2 = x14 + x23 + x32 + x41; if (sh1 != S || sh2 != S || sh3 != S || sh4 != S || sv1 != S || sv2 != S || sv3 != S || sv4 != S || sd1 != S || sd2 != S) continue; printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n", x11, x12, x13, x14, x21, x22, x23, x24, x31, x32, x33, x34, x41, x42, x43, x44); squares++; } } } } } } } } } printf("CNT: %d\n", squares); float diff_t = float(clock() - begin_time)/CLOCKS_PER_SEC; printf("T = %.2fs\n", diff_t); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  Das ist viel besser - weil  Die Aufgabe ist nahezu perfekt parallelisiert (die Berechnungen in jedem Zweig sind unabh√§ngig voneinander). Die Zeit ist k√ºrzer als die Anzahl der Prozessorkerne.  Leider ist es nicht m√∂glich, viel mehr aus diesem Code herauszuholen, obwohl einige Prozent durch einige Optimierungen gewonnen werden k√∂nnen und k√∂nnen.  Wir gehen zu schwererer Artillerie √ºber, Berechnungen auf der GPU. <br><br><h2>  Rechnen mit NVIDIA CUDA </h2><br>  Wenn Sie nicht auf Details eingehen, kann der auf der Grafikkarte ausgef√ºhrte Berechnungsprozess als mehrere parallele Hardwarebl√∂cke (Bl√∂cke) dargestellt werden, von denen jeder mehrere Prozesse (Threads) ausf√ºhrt. <br><br><img src="https://habrastorage.org/webt/nf/sp/me/nfspmek2x2tkbiix11zrb3ijkfi.png"><br><br>  Zum Beispiel k√∂nnen wir ein Beispiel f√ºr die Funktion des Hinzuf√ºgens von 2 Vektoren aus der CUDA-Dokumentation geben: <br><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">global__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = threadIdx.x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stride = blockDim.x; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = index; i &lt; n; i += stride) y[i] = x[i] + y[i]; }</code> </pre> <br>  Die Arrays x und y sind allen Bl√∂cken gemeinsam, und die Funktion selbst wird somit gleichzeitig auf mehreren Prozessoren ausgef√ºhrt.  Der Schl√ºssel liegt hier in der Parallelit√§t - Grafikkartenprozessoren sind viel einfacher als eine normale CPU, aber es gibt viele davon, und sie konzentrieren sich speziell auf die Verarbeitung numerischer Daten. <br><br>  Das brauchen wir.  Wir haben eine Matrix von Zahlen X11, X12, .., X44.  Beginnen wir mit 16 Bl√∂cken, von denen jeder 16 Prozesse ausf√ºhrt.  Die Blocknummer entspricht der Nummer X11, die Prozessnummer der Nummer X12 und der Code selbst berechnet alle m√∂glichen Quadrate mit f√ºr die ausgew√§hlten X11 und X12.  Es ist einfach, aber es gibt eine Subtilit√§t: Die Daten m√ºssen nicht nur berechnet, sondern auch von der Grafikkarte zur√ºck √ºbertragen werden. Dazu speichern wir die Anzahl der Quadrate, die im Nullelement des Arrays gefunden werden. <br><br>  Der Hauptcode ist sehr einfach: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N 4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SQ_MAX 8*1024 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BLOCK_SIZE (SQ_MAX*N*N + 1) int main(int argc,char *argv[]) { const clock_t begin_time = clock(); int *results = (int*)malloc(BLOCK_SIZE*sizeof(int)); results[0] = 0; int *gpu_out = NULL; cudaMalloc(&amp;gpu_out, BLOCK_SIZE*sizeof(int)); cudaMemcpy(gpu_out, results, BLOCK_SIZE*sizeof(int), cudaMemcpyHostToDevice); squares</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;&lt;MAX, MAX&gt;&gt;&gt;(gpu_out); cudaMemcpy(results, gpu_out, BLOCK_SIZE*sizeof(int), cudaMemcpyDeviceToHost); // Print results int squares = results[0]; for(int p=0; p&lt;SQ_MAX &amp;&amp; p&lt;squares; p++) { int i = MAX*p + 1; printf("[%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d]\n", results[i], results[i+1], results[i+2], results[i+3], results[i+4], results[i+5], results[i+6], results[i+7], results[i+8], results[i+9], results[i+10], results[i+11], results[i+12], results[i+13], results[i+14], results[i+15]); } printf ("CNT: %d\n", squares); float diff_t = float(clock() - begin_time)/CLOCKS_PER_SEC; printf("T = %.2fs\n", diff_t); cudaFree(gpu_out); free(results); return 0; }</span></span></span></span></code> </pre> <br>  Wir w√§hlen den Speicherblock auf der Grafikkarte mit cudaMalloc aus, f√ºhren die Quadratfunktion aus und geben 2 Parameter 16.16 (Anzahl der Bl√∂cke und Anzahl der Threads) an, die den sortierten Nummern 1..16 entsprechen, und kopieren dann die Daten √ºber cudaMemcpy zur√ºck. <br><br>  Die Quadratsfunktion selbst wiederholt im Wesentlichen den Code aus dem vorherigen Teil, mit dem Unterschied, dass das Inkrementieren der Anzahl der gefundenen Quadrate mit atomicAdd erfolgt - dies stellt sicher, dass sich die Variable bei gleichzeitigen Aufrufen korrekt √§ndert. <br><br><div class="spoiler">  <b class="spoiler_title">Gesamter Quellcode</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Compile: // nvcc -o magic4_gpu.exe magic4_gpu.cu #include &lt;stdio.h&gt; #include &lt;ctime&gt; #define N 4 #define MAX (N*N) #define SQ_MAX 8*1024 #define BLOCK_SIZE (SQ_MAX*N*N + 1) #define S 34 // Magic square: // x11 x12 x13 x14 // x21 x22 x23 x24 // x31 x32 x33 x34 // x41 x42 x43 x44 __global__ void squares(int *res_array) { int index1 = blockIdx.x, index2 = threadIdx.x; if (index1 + 1 &gt; MAX || index2 + 1 &gt; MAX) return; const int x11 = index1+1, x12 = index2+1; for(int x13=1; x13&lt;=MAX; x13++) { if (x13 == x11 || x13 == x12) continue; int x14 = S - x11 - x12 - x13; if (x14 &lt; 1 || x14 &gt; MAX) continue; if (x14 == x11 || x14 == x12 || x14 == x13) continue; for(int x21=1; x21&lt;=MAX; x21++) { if (x21 == x11 || x21 == x12 || x21 == x13 || x21 == x14) continue; for(int x22=1; x22&lt;=MAX; x22++) { if (x22 == x11 || x22 == x12 || x22 == x13 || x22 == x14 || x22 == x21) continue; for(int x23=1; x23&lt;=MAX; x23++) { int x24 = S - x21 - x22 - x23; if (x24 &lt; 1 || x24 &gt; MAX) continue; if (x23 == x11 || x23 == x12 || x23 == x13 || x23 == x14 || x23 == x21 || x23 == x22) continue; if (x24 == x11 || x24 == x12 || x24 == x13 || x24 == x14 || x24 == x21 || x24 == x22 || x24 == x23) continue; for(int x31=1; x31&lt;=MAX; x31++) { if (x31 == x11 || x31 == x12 || x31 == x13 || x31 == x14 || x31 == x21 || x31 == x22 || x31 == x23 || x31 == x24) continue; for(int x32=1; x32&lt;=MAX; x32++) { if (x32 == x11 || x32 == x12 || x32 == x13 || x32 == x14 || x32 == x21 || x32 == x22 || x32 == x23 || x32 == x24 || x32 == x31) continue; for(int x33=1; x33&lt;=MAX; x33++) { int x34 = S - x31 - x32 - x33; if (x34 &lt; 1 || x34 &gt; MAX) continue; if (x33 == x11 || x33 == x12 || x33 == x13 || x33 == x14 || x33 == x21 || x33 == x22 || x33 == x23 || x33 == x24 || x33 == x31 || x33 == x32) continue; if (x34 == x11 || x34 == x12 || x34 == x13 || x34 == x14 || x34 == x21 || x34 == x22 || x34 == x23 || x34 == x24 || x34 == x31 || x34 == x32 || x34 == x33) continue; const int x41 = S - x11 - x21 - x31, x42 = S - x12 - x22 - x32, x43 = S - x13 - x23 - x33, x44 = S - x14 - x24 - x34; if (x41 &lt; 1 || x41 &gt; MAX || x42 &lt; 1 || x42 &gt; MAX || x43 &lt; 1 || x43 &gt; MAX || x44 &lt; 1 || x44 &gt; MAX) continue; if (x41 == x11 || x41 == x12 || x41 == x13 || x41 == x14 || x41 == x21 || x41 == x22 || x41 == x23 || x41 == x24 || x41 == x31 || x41 == x32 || x41 == x33 || x41 == x34) continue; if (x42 == x11 || x42 == x12 || x42 == x13 || x42 == x14 || x42 == x21 || x42 == x22 || x42 == x23 || x42 == x24 || x42 == x31 || x42 == x32 || x42 == x33 || x42 == x34 || x42 == x41) continue; if (x43 == x11 || x43 == x12 || x43 == x13 || x43 == x14 || x43 == x21 || x43 == x22 || x43 == x23 || x43 == x24 || x43 == x31 || x43 == x32 || x43 == x33 || x43 == x34 || x43 == x41 || x43 == x42) continue; if (x44 == x11 || x44 == x12 || x44 == x13 || x44 == x14 || x44 == x21 || x44 == x22 || x44 == x23 || x44 == x24 || x44 == x31 || x44 == x32 || x44 == x33 || x44 == x34 || x44 == x41 || x44 == x42 || x44 == x43) continue; int sh1 = x11 + x12 + x13 + x14, sh2 = x21 + x22 + x23 + x24, sh3 = x31 + x32 + x33 + x34, sh4 = x41 + x42 + x43 + x44; int sv1 = x11 + x21 + x31 + x41, sv2 = x12 + x22 + x32 + x42, sv3 = x13 + x23 + x33 + x43, sv4 = x14 + x24 + x34 + x44; int sd1 = x11 + x22 + x33 + x44, sd2 = x14 + x23 + x32 + x41; if (sh1 != S || sh2 != S || sh3 != S || sh4 != S || sv1 != S || sv2 != S || sv3 != S || sv4 != S || sd1 != S || sd2 != S) continue; // Square found: save in array (MAX numbers for each square) int p = atomicAdd(res_array, 1); if (p &gt;= SQ_MAX) continue; int i = MAX*p + 1; res_array[i] = x11; res_array[i+1] = x12; res_array[i+2] = x13; res_array[i+3] = x14; res_array[i+4] = x21; res_array[i+5] = x22; res_array[i+6] = x23; res_array[i+7] = x24; res_array[i+8] = x31; res_array[i+9] = x32; res_array[i+10] = x33; res_array[i+11] = x34; res_array[i+12]= x41; res_array[i+13]= x42; res_array[i+14] = x43; res_array[i+15] = x44; // Warning: printf from kernel makes calculation 2-3x slower // printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n", x11, x12, x13, x14, x21, x22, x23, x24, x31, x32, x33, x34, x41, x42, x43, x44); } } } } } } } } int main(int argc,char *argv[]) { int *gpu_out = NULL; cudaMalloc(&amp;gpu_out, BLOCK_SIZE*sizeof(int)); const clock_t begin_time = clock(); int *results = (int*)malloc(BLOCK_SIZE*sizeof(int)); results[0] = 0; cudaMemcpy(gpu_out, results, BLOCK_SIZE*sizeof(int), cudaMemcpyHostToDevice); squares&lt;&lt;&lt;MAX, MAX&gt;&gt;&gt;(gpu_out); cudaMemcpy(results, gpu_out, BLOCK_SIZE*sizeof(int), cudaMemcpyDeviceToHost); // Print results int squares = results[0]; for(int p=0; p&lt;SQ_MAX &amp;&amp; p&lt;squares; p++) { int i = MAX*p + 1; printf("[%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d]\n", results[i], results[i+1], results[i+2], results[i+3], results[i+4], results[i+5], results[i+6], results[i+7], results[i+8], results[i+9], results[i+10], results[i+11], results[i+12], results[i+13], results[i+14], results[i+15]); } printf ("CNT: %d\n", squares); float diff_t = float(clock() - begin_time)/CLOCKS_PER_SEC; printf("T = %.2fs\n", diff_t); cudaFree(gpu_out); free(results); return 0; }</span></span></code> </pre><br></div></div><br>  Das Ergebnis erfordert keine Kommentare - die Ausf√ºhrungszeit betrug <b>2,7 s</b> , was etwa 30-mal besser ist als die urspr√ºngliche Single-Threaded-Version: <br><br><img src="https://habrastorage.org/webt/nt/g4/yi/ntg4yizkphj817ef5bjf86d7gti.png"><br><br>  Wie in den Kommentaren vorgeschlagen, k√∂nnen Sie noch mehr Hardwarebl√∂cke der Grafikkarte verwenden, sodass die Option von 256 Bl√∂cken ausprobiert wurde.  Das √Ñndern des Codes ist minimal: <br><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">global__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">squares</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *res_array)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index1 = blockIdx.x/MAX, index2 = blockIdx.x%MAX; ... } squares&lt;&lt;&lt;MAX*MAX, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt;&gt;&gt;(gpu_out);</code> </pre> <br>  Dies reduzierte die Zeit um weitere 2 Mal auf <b>1,2 Sekunden</b> .  Ferner k√∂nnen auf jedem Block 16 Prozesse gestartet werden, was die beste Zeit von <b>0,44 s ergibt</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Endg√ºltiger Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;ctime&gt; #define N 4 #define MAX (N*N) #define SQ_MAX 8*1024 #define BLOCK_SIZE (SQ_MAX*N*N + 1) #define S 34 // Magic square: // x11 x12 x13 x14 // x21 x22 x23 x24 // x31 x32 x33 x34 // x41 x42 x43 x44 __global__ void squares(int *res_array) { int index1 = blockIdx.x/MAX, index2 = blockIdx.x%MAX, index3 = threadIdx.x; if (index1 + 1 &gt; MAX || index2 + 1 &gt; MAX || index3 + 1 &gt; MAX) return; const int x11 = index1+1, x12 = index2+1, x13 = index3+1; if (x13 == x11 || x13 == x12) return; int x14 = S - x11 - x12 - x13; if (x14 &lt; 1 || x14 &gt; MAX) return; if (x14 == x11 || x14 == x12 || x14 == x13) return; for(int x21=1; x21&lt;=MAX; x21++) { if (x21 == x11 || x21 == x12 || x21 == x13 || x21 == x14) continue; for(int x22=1; x22&lt;=MAX; x22++) { if (x22 == x11 || x22 == x12 || x22 == x13 || x22 == x14 || x22 == x21) continue; for(int x23=1; x23&lt;=MAX; x23++) { int x24 = S - x21 - x22 - x23; if (x24 &lt; 1 || x24 &gt; MAX) continue; if (x23 == x11 || x23 == x12 || x23 == x13 || x23 == x14 || x23 == x21 || x23 == x22) continue; if (x24 == x11 || x24 == x12 || x24 == x13 || x24 == x14 || x24 == x21 || x24 == x22 || x24 == x23) continue; for(int x31=1; x31&lt;=MAX; x31++) { if (x31 == x11 || x31 == x12 || x31 == x13 || x31 == x14 || x31 == x21 || x31 == x22 || x31 == x23 || x31 == x24) continue; for(int x32=1; x32&lt;=MAX; x32++) { if (x32 == x11 || x32 == x12 || x32 == x13 || x32 == x14 || x32 == x21 || x32 == x22 || x32 == x23 || x32 == x24 || x32 == x31) continue; for(int x33=1; x33&lt;=MAX; x33++) { int x34 = S - x31 - x32 - x33; if (x34 &lt; 1 || x34 &gt; MAX) continue; if (x33 == x11 || x33 == x12 || x33 == x13 || x33 == x14 || x33 == x21 || x33 == x22 || x33 == x23 || x33 == x24 || x33 == x31 || x33 == x32) continue; if (x34 == x11 || x34 == x12 || x34 == x13 || x34 == x14 || x34 == x21 || x34 == x22 || x34 == x23 || x34 == x24 || x34 == x31 || x34 == x32 || x34 == x33) continue; const int x41 = S - x11 - x21 - x31, x42 = S - x12 - x22 - x32, x43 = S - x13 - x23 - x33, x44 = S - x14 - x24 - x34; if (x41 &lt; 1 || x41 &gt; MAX || x42 &lt; 1 || x42 &gt; MAX || x43 &lt; 1 || x43 &gt; MAX || x44 &lt; 1 || x44 &gt; MAX) continue; if (x41 == x11 || x41 == x12 || x41 == x13 || x41 == x14 || x41 == x21 || x41 == x22 || x41 == x23 || x41 == x24 || x41 == x31 || x41 == x32 || x41 == x33 || x41 == x34) continue; if (x42 == x11 || x42 == x12 || x42 == x13 || x42 == x14 || x42 == x21 || x42 == x22 || x42 == x23 || x42 == x24 || x42 == x31 || x42 == x32 || x42 == x33 || x42 == x34 || x42 == x41) continue; if (x43 == x11 || x43 == x12 || x43 == x13 || x43 == x14 || x43 == x21 || x43 == x22 || x43 == x23 || x43 == x24 || x43 == x31 || x43 == x32 || x43 == x33 || x43 == x34 || x43 == x41 || x43 == x42) continue; if (x44 == x11 || x44 == x12 || x44 == x13 || x44 == x14 || x44 == x21 || x44 == x22 || x44 == x23 || x44 == x24 || x44 == x31 || x44 == x32 || x44 == x33 || x44 == x34 || x44 == x41 || x44 == x42 || x44 == x43) continue; int sh1 = x11 + x12 + x13 + x14, sh2 = x21 + x22 + x23 + x24, sh3 = x31 + x32 + x33 + x34, sh4 = x41 + x42 + x43 + x44; int sv1 = x11 + x21 + x31 + x41, sv2 = x12 + x22 + x32 + x42, sv3 = x13 + x23 + x33 + x43, sv4 = x14 + x24 + x34 + x44; int sd1 = x11 + x22 + x33 + x44, sd2 = x14 + x23 + x32 + x41; if (sh1 != S || sh2 != S || sh3 != S || sh4 != S || sv1 != S || sv2 != S || sv3 != S || sv4 != S || sd1 != S || sd2 != S) continue; // Square found: save in array (MAX numbers for each square) int p = atomicAdd(res_array, 1); if (p &gt;= SQ_MAX) continue; int i = MAX*p + 1; res_array[i] = x11; res_array[i+1] = x12; res_array[i+2] = x13; res_array[i+3] = x14; res_array[i+4] = x21; res_array[i+5] = x22; res_array[i+6] = x23; res_array[i+7] = x24; res_array[i+8] = x31; res_array[i+9] = x32; res_array[i+10] = x33; res_array[i+11] = x34; res_array[i+12]= x41; res_array[i+13]= x42; res_array[i+14] = x43; res_array[i+15] = x44; // Warning: printf from kernel makes calculation 2-3x slower // printf("%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n", x11, x12, x13, x14, x21, x22, x23, x24, x31, x32, x33, x34, x41, x42, x43, x44); } } } } } } } int main(int argc,char *argv[]) { int *gpu_out = NULL; cudaMalloc(&amp;gpu_out, BLOCK_SIZE*sizeof(int)); const clock_t begin_time = clock(); int *results = (int*)malloc(BLOCK_SIZE*sizeof(int)); results[0] = 0; cudaMemcpy(gpu_out, results, BLOCK_SIZE*sizeof(int), cudaMemcpyHostToDevice); squares&lt;&lt;&lt;MAX*MAX, MAX&gt;&gt;&gt;(gpu_out); cudaMemcpy(results, gpu_out, BLOCK_SIZE*sizeof(int), cudaMemcpyDeviceToHost); // Print results int squares = results[0]; for(int p=0; p&lt;SQ_MAX &amp;&amp; p&lt;squares; p++) { int i = MAX*p + 1; printf("[%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d]\n", results[i], results[i+1], results[i+2], results[i+3], results[i+4], results[i+5], results[i+6], results[i+7], results[i+8], results[i+9], results[i+10], results[i+11], results[i+12], results[i+13], results[i+14], results[i+15]); } printf ("CNT: %d\n", squares); float diff_t = float(clock() - begin_time)/CLOCKS_PER_SEC; printf("T = %.2fs\n", diff_t); cudaFree(gpu_out); free(results); return 0; }</span></span></span></span></code> </pre><br></div></div><br>  Dies ist h√∂chstwahrscheinlich alles andere als ideal. Sie k√∂nnen beispielsweise noch mehr Bl√∂cke auf der GPU ausf√ºhren, dies macht den Code jedoch verwirrender und schwieriger zu verstehen.  Und nat√ºrlich sind die Berechnungen nicht ‚Äûkostenlos‚Äú - wenn die GPU geladen ist, verlangsamt sich die Windows-Oberfl√§che merklich und der Stromverbrauch des Computers steigt fast zweimal von 65 auf 130 W. <br><br>  <b>Bearbeiten</b> : Wie der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Bodigrim-</a> Benutzer in den Kommentaren aufgefordert hat, gilt eine andere Gleichheit f√ºr das 4x4-Quadrat: Die Summe von 4 "internen" Zellen ist gleich der Summe von "externen" Zellen, es ist auch S. <br><br><img src="https://habrastorage.org/webt/xs/kk/tv/xskktvayrnqo9du8t35zqc_a8hy.png"><br><br> <code>X22 + X23 + X32 + X33 = X11 + X41 + X14 + X44 = S</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies erm√∂glicht es, den Algorithmus zu beschleunigen, indem einige Variablen durch andere ausgedr√ºckt und weitere 1-2 verschachtelte Schleifen entfernt werden. Eine aktualisierte Version des Codes finden Sie im Kommentar unten. </font></font><br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Aufgabe, ‚Äûmagische Quadrate‚Äú zu finden, erwies sich als technisch sehr interessant und gleichzeitig schwierig. </font><font style="vertical-align: inherit;">Selbst bei Berechnungen auf der GPU kann die Suche nach allen 5x5-Quadraten mehrere Stunden dauern, und die Optimierung zum Auffinden magischer Quadrate mit 7x7 und h√∂heren Dimensionen muss noch durchgef√ºhrt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mathematisch und algorithmisch gibt es auch einige ungel√∂ste Probleme:</font></font><br><br><ul><li>   ¬´ ¬ª  N.    22  ,  33   8 (   1,     ),  44   , 7040,          .      . </li><li>  ,      . </li><li>    .  ,         NVIDIA Tesla  ,  -  ,   .        ,     .          ,       ;) </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei Interesse kann ein separater Artikel √ºber die Analyse und die Eigenschaften der magischen Quadrate selbst geschrieben werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS: Auf die Frage, die wahrscheinlich folgen wird: "Warum ist das notwendig?" </font><font style="vertical-align: inherit;">In Bezug auf den Stromverbrauch ist die Berechnung von magischen Quadraten nicht besser oder schlechter als die Berechnung von Bitcoins. Warum also nicht? </font><font style="vertical-align: inherit;">Dar√ºber hinaus ist es ein interessantes Training f√ºr den Geist und eine interessante Aufgabe im Bereich der angewandten Programmierung.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424845/">https://habr.com/ru/post/de424845/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424827/index.html">Die Illusion von Raum: Wie der neue Spiderman R√§ume ohne Geometrie rendert</a></li>
<li><a href="../de424831/index.html">Was ist in die digitale Wirtschaft investiert</a></li>
<li><a href="../de424835/index.html">So reduzieren Sie das Risiko von Investitionen an der B√∂rse: 3 Diversifizierungsfaktoren</a></li>
<li><a href="../de424841/index.html">Speichern Sie ein Bildarchiv f√ºr eine Site im Azure BLOB-Speicher</a></li>
<li><a href="../de424843/index.html">Ist IBOutlet in Ihren iOS-Apps privat?</a></li>
<li><a href="../de424847/index.html">MNaaS und eSIM - Vor- und Nachteile der Virtualisierung f√ºr Mobilfunkbetreiber und deren Kunden</a></li>
<li><a href="../de424849/index.html">Was macht den neuen UCS C480 ML M5 interessant - Server f√ºr maschinelles Lernen von Cisco</a></li>
<li><a href="../de424851/index.html">Was ist falsch daran, IT einzustellen?</a></li>
<li><a href="../de424853/index.html">Die Geschichte eines View Controllers, der sich gut pr√§sentieren wollte</a></li>
<li><a href="../de424855/index.html">Maschinelles Lernen: Scramble mit einem Raumelefanten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>