<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏼 🦁 👍🏼 Buku “Algoritma dan struktur data. Pengambilan Informasi Java » 📐 🚶🏼 😻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Pelajari cara menerapkan algoritma yang efisien berdasarkan pada struktur data paling penting dalam bahasa Java, dan bagaimana mengukur ki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buku “Algoritma dan struktur data. Pengambilan Informasi Java »</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/419503/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ul/ci/2m/ulci2miltdytubvrcl0sem1gltk.jpeg" align="left" alt="gambar"></a>  Halo, Habr!  Pelajari cara menerapkan algoritma yang efisien berdasarkan pada struktur data paling penting dalam bahasa Java, dan bagaimana mengukur kinerja algoritma ini.  Setiap bab disertai dengan latihan untuk membantu mengkonsolidasikan materi. <br><br><ul><li>  Belajar bekerja dengan struktur data, misalnya, dengan daftar dan kamus, pahami cara kerjanya. </li><li>  Tulis aplikasi yang membaca halaman Wikipedia, mem-parsing, dan menyediakan navigasi melalui pohon data yang dihasilkan. </li><li>  Analisis kode dan pelajari cara memprediksi seberapa cepat akan bekerja dan berapa banyak memori yang akan dikonsumsi. </li><li>  Tulis kelas yang mengimplementasikan antarmuka Peta, dan gunakan tabel hash dan pohon pencarian biner. </li><li>  Buat mesin pencarian web sederhana dengan mesin pencari sendiri: itu akan mengindeks halaman web, menyimpan konten mereka dan mengembalikan hasil yang diinginkan. </li></ul><a name="habracut"></a><br><h3>  Kutipan "Tree Walk" </h3><br>  Dalam bab ini, kita akan melihat aplikasi mesin pencari yang akan kita kembangkan sepanjang sisa buku ini.  Saya (penulis) menjelaskan elemen-elemen mesin pencari dan menyajikan aplikasi pertama, robot pencarian yang mengunduh dan menganalisis halaman dari Wikipedia.  Bab ini juga memperkenalkan implementasi pencarian mendalam rekursif dan implementasi berulang menggunakan Deque dari Jawa untuk mengimplementasikan stack "last in, first out". <br><br><h3>  Mesin pencari </h3><br>  Mesin pencari seperti Google Search atau Bing menerima serangkaian istilah pencarian dan mengembalikan daftar halaman web yang relevan dengan istilah-istilah ini.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda</a> dapat membaca lebih lanjut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thinkdast.com</a> , tetapi saya akan menjelaskan apa yang Anda butuhkan saat Anda pergi. <br><br>  Pertimbangkan komponen utama mesin pencari. <br><br><ul><li>  Pengumpulan data (perayapan).  Anda membutuhkan program yang dapat memuat halaman web, menganalisisnya, dan mengekstrak teks dan tautan apa pun ke halaman lain. </li><li>  Pengindeksan  Kami membutuhkan indeks yang memungkinkan kami menemukan kueri penelusuran dan halaman yang memuatnya. </li><li>  Cari (pengambilan).  Anda memerlukan cara untuk mengumpulkan hasil dari indeks dan menentukan halaman yang paling relevan dengan istilah pencarian. </li></ul><br>  Mari kita mulai dengan robot pencarian.  Tujuannya adalah untuk mendeteksi dan memuat sekumpulan halaman web.  Untuk mesin pencari seperti Google dan Bing, tantangannya adalah menemukan semua halaman web, tetapi seringkali robot ini terbatas pada domain yang lebih kecil.  Dalam kasus kami, kami hanya akan membaca halaman dari Wikipedia. <br><br>  Sebagai langkah pertama, kami akan membuat robot pencarian yang membaca halaman Wikipedia, menemukan tautan pertama, membuka halaman lain dan mengulangi langkah-langkah sebelumnya.  Kami akan menggunakan mesin pencari ini untuk menguji hipotesis Getting to Philosophy.  Dikatakan: <br><br><blockquote>  "Dengan mengeklik tautan huruf kecil pertama di teks utama artikel Wikipedia dan kemudian mengulangi tindakan ini untuk artikel selanjutnya, Anda kemungkinan besar akan dibawa ke halaman dengan artikel tentang filsafat." <br></blockquote><br>  Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melihat</a> hipotesis ini dan sejarahnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thinkdast.com/getphil</a> . <br>  Menguji hipotesis akan memungkinkan Anda untuk membuat bagian utama robot pencarian tanpa perlu mem-bypass seluruh Internet atau bahkan seluruh Wikipedia.  Dan saya pikir latihan ini cukup menarik! <br><br>  Dalam beberapa bab, kami akan mengerjakan pengindeks, dan kemudian beralih ke mesin pencari. <br><br><h3>  Penguraian HTML </h3><br>  Saat Anda memuat halaman web, isinya ditulis dalam HyperText Markup Language (HTML).  Misalnya, berikut ini adalah dokumen HTML sederhana: <br><br><pre><code class="hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span>This is a title<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">title</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Hello world!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Frase Ini adalah judul dan Halo dunia!  ("Halo dunia!") - teks yang benar-benar muncul di halaman;  elemen lainnya adalah tag yang menunjukkan bagaimana teks harus ditampilkan. <br><br>  Saat memuat halaman, robot kami perlu mengurai kode HTML untuk mengekstrak teks dan menemukan tautan.  Untuk melakukan ini, kita akan menggunakan jsoup, perpustakaan Java open source yang dirancang untuk memuat dan mem-parsing (mem-parsing) HTML. <br>  Hasil parsing HTML adalah pohon DOM (Document Object Model) yang berisi elemen dokumen, termasuk teks dan tag. <br><br>  Pohon adalah struktur data terkait yang terdiri dari simpul yang mewakili teks, tag, dan elemen lain dari dokumen. <br><br>  Hubungan antara simpul ditentukan oleh struktur dokumen.  Pada contoh sebelumnya, simpul pertama, yang disebut root, adalah tag yang menyertakan tautan ke dua simpul yang dikandungnya dan;  simpul-simpul ini adalah anak-anak dari simpul akar. <br><br>  Sebuah simpul memiliki satu simpul anak, dan sebuah simpul memiliki simpul satu anak <p>  (paragraf, dari bahasa Inggris. paragraf).  Dalam gbr.  6.1 adalah representasi grafis dari pohon ini. <br><br></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/r7/07/uu/r707uude4_ixfv0kd4laaafp9zu.png" alt="gambar"></div><br>  Setiap dhuwur menyertakan tautan ke simpul turunannya;  selain itu, setiap node berisi tautan ke induknya, sehingga Anda dapat memindahkan naik turun pohon dari sembarang simpul.  Pohon DOM untuk halaman nyata biasanya lebih kompleks daripada contoh yang dijelaskan. <br><br>  Sebagian besar browser memiliki alat untuk memeriksa DOM dari halaman yang Anda lihat.  Di Chrome, Anda dapat mengklik kanan pada bagian mana pun dari halaman web dan memilih item Lihat kode di menu yang muncul.  Di Firefox, Anda dapat mengklik kanan dan memilih Jelajahi Item dari menu konteks.  Safari menyediakan alat Web Inspector, yang terletak di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thinkdast.com/safari</a> .  Instruksi untuk Internet Explorer dapat dibaca dengan mengklik tautan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thinkdast.com/explorer</a> . <br><br>  Dalam gbr.  Gambar 6.2 menunjukkan tangkapan layar pohon DOM untuk halaman Wikipedia tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java</a> .  Elemen yang disorot adalah paragraf pertama dari tubuh artikel, yang terkandung dalam elemen &lt;div&gt; dengan id = "mw-content-text".  Kami akan menggunakan pengidentifikasi elemen ini untuk menentukan isi setiap artikel yang kami unggah. <br><br><h3>  Aplikasi Jsoup </h3><br>  Pustaka jsoup memudahkan memuat dan menganalisis halaman web dan menavigasi pohon DOM.  Sebagai contoh: <br><br><pre> <code class="hljs pgsql">String url = "http://en.wikipedia.org/wiki/Java_(programming_language)"; //     <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span> conn = Jsoup.<span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(url); Document doc = conn.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); //         Element content = doc.getElementById("mw-content-text"); Elements paragraphs = content.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>("p");</code> </pre> <br>  Elemen Jsoup.connect menerima URL sebagai string dan membuat koneksi ke server web;  Metode get memuat kode HTML, mem-parsingnya, dan mengembalikan objek Dokumen, yang merupakan DOM. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gb/ez/xu/gbezxuae9aggcurdydsoilnshpo.png" alt="gambar"></div><br>  Objek ini mencakup metode untuk menavigasi pohon dan memilih node.  Bahkan, ia menyediakan begitu banyak metode yang bisa membingungkan.  Contoh berikut menunjukkan dua cara untuk memilih node. <br><br><ul><li>  getElementByld mengambil parameter tipe string dan mencari pohon untuk elemen dengan bidang id yang sesuai.  Setelah menemukannya, ia memilih simpul &lt;div id = "mw-content-text" lang = "en" dir = "ltr" class = "mw-content-ltr"&gt;, yang muncul di setiap halaman Wikipedia untuk mengidentifikasi elemen &lt;div&gt; yang berisi isi halaman, tidak seperti bilah navigasi samping dan elemen lainnya. </li><li>  pilih mengambil String, melintasi pohon, dan mengembalikan semua elemen dengan Tag yang cocok dengan String.  Dalam contoh ini, ia mengembalikan semua tag paragraf yang muncul dalam konten.  Nilai kembali adalah objek tipe Elemen. </li></ul><br>  Sebelum melanjutkan, Anda harus meninjau dokumentasi untuk kelas-kelas ini untuk mengetahui tindakan apa yang dapat mereka lakukan.  Kelas yang paling penting adalah Elemen, Elemen, dan Node, yang dapat Anda baca dengan mengklik tautan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thinkdast.com/jsoupelt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thinkdast.com/jsoupelts,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thinkdast.com/jsoupnode</a> . <br><br>  Kelas Node adalah yang teratas di pohon DOM.  Ada beberapa subclass yang memperpanjang Node, termasuk Elemen, TextNode, DataNode, dan Komentar.  Kelas Elemen adalah kumpulan objek bertipe Elemen. <br><br>  Dalam gbr.  6.3 adalah diagram kelas UML yang menunjukkan hubungan di antara mereka.  Baris dengan panah kosong menunjukkan ekstensi dari satu kelas ke kelas lain.  Misalnya, bagan ini menunjukkan bahwa Elemen memperluas ArrayList.  Kami akan kembali ke diagram kelas UML di bagian dengan nama yang sama di Bab 11. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/29/ys/p_/29ysp__8jqplpznbyty3y6mqmgi.png" alt="gambar"></div><br><h3>  Iterate di atas pohon DOM </h3><br>  Untuk membuat hidup Anda lebih mudah, saya menyediakan kelas WikiNodelterable yang memungkinkan Anda berjalan melalui pohon DOM.  Berikut ini adalah contoh yang menunjukkan cara menggunakan kelas ini: <br><br><pre> <code class="hljs pgsql">Elements paragraphs = content.<span class="hljs-keyword"><span class="hljs-keyword">select</span></span>("p"); Element firstPara = paragraphs.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); Iterable&lt;Node&gt; iter = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> WikiNodeIterable(firstPara); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node node: iter) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node instanceof TextNode) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.print(node); } }</code> </pre> <br>  Contoh ini dimulai dengan saat di mana yang sebelumnya berhenti.  Dia memilih paragraf pertama dalam paragraf dan kemudian membuat kelas WikiNodeIterable yang mengimplementasikan antarmuka Iterable.  Kelas ini mencari secara mendalam, membuat simpul sesuai urutan kemunculannya pada halaman. <br><br>  Dalam contoh saat ini, kami menampilkan Node hanya jika itu adalah TextNode, dan mengabaikan tipe lainnya, khususnya, objek tipe Elemen yang mewakili tag.  Hasilnya adalah teks paragraf HTML biasa tanpa markup.  Kesimpulannya: <br><br><blockquote>  Java adalah bahasa pemrograman komputer tujuan umum yang konkuren, berbasis kelas, berorientasi objek, [13] dan dirancang khusus ... <br><br>  Java adalah bahasa pemrograman komputer universal, yang merupakan bahasa berorientasi objek berdasarkan kelas, dengan kemungkinan pemrograman paralel [13] dan dirancang khusus ... </blockquote><br><h3>  Pencarian Kedalaman </h3><br>  Ada beberapa cara untuk melintasi pohon secara cerdas.  Kami mulai dengan pencarian mendalam-pertama (DFS).  Pencarian dimulai dengan akar pohon dan memilih simpul anak pertama.  Jika yang terakhir memiliki anak, maka simpul anak pertama dipilih lagi.  Ketika puncak tanpa anak-anak menemukan, Anda harus kembali, memindahkan pohon ke simpul orangtua, di mana anak berikutnya dipilih, jika ada.  Jika tidak, Anda harus kembali lagi.  Ketika simpul akar anak terakhir diperiksa, traversal selesai. <br><br>  Ada dua cara yang diterima secara umum untuk menerapkan pencarian mendalam: rekursif dan berulang.  Implementasi rekursif sederhana dan elegan: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">recursiveDFS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Node node</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node instanceof TextNode) { System.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span>.print(node); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node child: node.childNodes()) { recursiveDFS(child); } }</code> </pre> <br>  Metode ini dipanggil untuk setiap Node di pohon, mulai dari root.  Jika Node adalah TextNode, maka isinya akan dicetak.  Jika Node memiliki anak-anak, ia memanggil recursiveDFS untuk masing-masing dari mereka secara berurutan. <br><br>  Dalam contoh saat ini, kami mencetak konten dari setiap TextNode sebelum mengunjungi simpul turunannya, yaitu, ini adalah contoh dari traversal langsung (pre-order).  Anda dapat membaca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyelesaian</a> langsung, mundur (pasca-pesanan) dan simetris (berurutan) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan</a> masuk ke tautan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thinkdast.com/treetrav</a> .  Untuk aplikasi ini, urutan perayapan tidak masalah. <br><br>  Saat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melakukan</a> panggilan rekursif, recursiveDFS menggunakan tumpukan panggilan (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thinkdast.com/callstack</a> ) untuk melacak simpul anak dan memprosesnya dalam urutan yang benar.  Atau, Anda dapat menggunakan struktur data tumpukan untuk melacak node sendiri;  ini akan menghindari rekursi dan beralih ke pohon berulang-ulang. <br><br><h3>  Tumpukan di Jawa </h3><br>  Sebelum menjelaskan versi pencarian kedalaman yang berulang, saya akan melihat struktur data stack.  Kita mulai dengan konsep umum stack, dan kemudian berbicara tentang dua antarmuka Java yang mendefinisikan metode stack: Stack dan Deque. <br><br>  Tumpukan adalah struktur data seperti daftar: tumpukan adalah kumpulan yang mempertahankan urutan elemen.  Perbedaan utama antara tumpukan dan daftar adalah bahwa yang pertama mencakup lebih sedikit metode.  Secara konvensional, stack menyediakan metode: <br><br><ul><li>  dorong, menambahkan elemen ke bagian atas tumpukan; </li><li>  pop, yang melakukan penghapusan dan mengembalikan nilai elemen paling atas dari tumpukan; </li><li>  mengintip, mengembalikan elemen paling atas dari tumpukan tanpa mengubah tumpukan itu sendiri; </li><li>  isEmpty, yang menunjukkan apakah tumpukan kosong. </li></ul><br>  Karena pop selalu mengembalikan elemen paling atas, stack juga disebut LIFO, yang berarti "last in, first out".  Alternatif tumpukan adalah antrian yang mengembalikan item dalam urutan yang sama dengan yang ditambahkan, yaitu, "masuk pertama, keluar pertama", atau FIFO. <br><br>  Sekilas, tidak jelas mengapa tumpukan dan antrian berguna: mereka tidak menyediakan fitur khusus yang tidak dapat diperoleh dari daftar;  pada kenyataannya, mereka bahkan memiliki lebih sedikit peluang.  Jadi mengapa tidak mendaftar selalu?  Ada dua alasan untuk membenarkan tumpukan dan antrian. <br><br>  1. Jika Anda membatasi diri Anda pada serangkaian kecil metode (yaitu, API kecil), maka kode Anda akan lebih mudah dibaca dan lebih sedikit rawan kesalahan.  Misalnya, saat menggunakan daftar untuk mewakili tumpukan, Anda dapat secara tidak sengaja menghapus item dalam urutan yang salah.  Dengan stack API, kesalahan semacam itu benar-benar mustahil.  Dan cara terbaik untuk menghindari kesalahan adalah membuatnya menjadi tidak mungkin. <br><br>  2. Jika struktur data menyediakan API kecil, maka lebih mudah untuk diterapkan secara efisien.  Misalnya, cara sederhana untuk mengimplementasikan tumpukan adalah dengan menggunakan satu daftar.  Mendorong item ke tumpukan, kami menambahkannya ke bagian atas daftar;  muncul elemen, kami menghapusnya dari awal.  Untuk daftar tertaut, menambah dan menghapus dari awal adalah operasi waktu yang konstan, sehingga implementasi ini efektif.  Sebaliknya, API besar lebih sulit untuk diterapkan secara efisien. <br><br>  Ada tiga cara untuk mengimplementasikan tumpukan di Jawa. <br><br>  1. Terapkan ArrayList atau LinkedList.  Saat menggunakan ArrayList, Anda harus ingat untuk menambah dan menghapus dari ujung sehingga operasi ini dilakukan dalam waktu yang konstan.  Hindari menambahkan item ke tempat yang salah atau menghapusnya dengan urutan yang salah. <br><br>  2. Java memiliki kelas Stack yang menyediakan serangkaian metode stack standar.  Tetapi kelas ini adalah bagian lama dari Java: tidak kompatibel dengan Java Collections Framework, yang muncul kemudian. <br><br>  3. Mungkin pilihan terbaik adalah menggunakan salah satu implementasi dari antarmuka Deque, misalnya ArrayDeque. <br><br>  Deque dibentuk dari antrian berujung dua, yang berarti "antrian dua arah."  Di Java, antarmuka Deque menyediakan metode push, pop, peek, dan isEmpty, sehingga dapat digunakan sebagai stack.  Ini berisi metode lain, informasi yang tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">thinkdast.com/deque</a> , tetapi untuk saat ini kami tidak akan menggunakannya. <br><br><h3>  Pencarian Kedalaman Iteratif </h3><br>  Berikut ini adalah versi berulang DFS yang menggunakan ArrayDeque untuk mewakili tumpukan objek tipe Node: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterativeDFS</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Node root)</span></span></span><span class="hljs-function"> </span></span>{ Deque&lt;Node&gt; <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayDeque&lt;Node&gt;(); <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.push(root); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.isEmpty()) { Node node = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node instanceof TextNode) { System.out.print(node); } List&lt;Node&gt; nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Node&gt;(node. chiidNodesQ); Collections.reverse(nodes); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node child: nodes) { <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.push(chiid); } } }</code> </pre> <br>  Parameter root adalah root dari pohon yang ingin kita bypass, jadi kita mulai dengan membuat stack dan menambahkan parameter ini ke dalamnya. <br><br>  Loop berlanjut hingga tumpukan kosong.  Setiap pass mendorong Node keluar dari stack.  Jika TextNode diterima, isinya akan dicetak.  Kemudian, simpul anak ditambahkan ke tumpukan.  Untuk memproses keturunan dalam urutan yang benar, Anda harus mendorong mereka ke tumpukan dengan urutan terbalik;  ini dilakukan dengan menyalin simpul anak ke dalam ArrayList, mengatur ulang elemen di tempatnya, dan kemudian mengulangi ArrayList yang terbalik. <br>  Salah satu keuntungan dari versi pencarian mendalam adalah bahwa lebih mudah untuk diterapkan sebagai Iterator di Jawa;  bagaimana melakukan ini dijelaskan pada bab berikutnya. <br><br>  Tapi pertama-tama, catatan terakhir pada antarmuka Deque: selain ArrayDeque, Java menyediakan implementasi lain dari Deque, teman lama kami LinkedList.  Yang terakhir mengimplementasikan kedua antarmuka: Daftar dan Deque.  Antarmuka yang dihasilkan tergantung pada penggunaannya.  Misalnya, ketika menetapkan LinkedList ke variabel Deque: <br><br><pre> <code class="hljs xml">Deqeue<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span> deque = new LinkedList<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span>();</code> </pre> <br>  Anda dapat menerapkan metode dari antarmuka Deque, tetapi tidak semua metode dari antarmuka Daftar.  Dengan menugaskannya ke Daftar variabel: <br><br><pre> <code class="hljs xml">List<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span> deque = new LinkedList<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span>();</code> </pre> <br>  Anda dapat menggunakan metode Daftar, tetapi tidak semua metode Deque.  Dan menugaskan mereka sebagai berikut: <br><br><pre> <code class="hljs xml">LinkedList<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span> deque = new LinkedList<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Node</span></span></span><span class="hljs-tag">&gt;</span></span>();</code> </pre> <br>  semua metode dapat digunakan.  Tetapi ketika menggabungkan metode dari antarmuka yang berbeda, kodenya akan lebih mudah dibaca dan lebih rentan kesalahan. <br><br>  »Informasi lebih lanjut tentang buku ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web penerbit</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Isi</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kutipan</a> <br><br>  20% diskon kupon untuk <b>Java</b> Fermentor - <b>Jawa</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419503/">https://habr.com/ru/post/id419503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419483/index.html">PowerShell dan Shift + Ins, atau cara mendapatkan kecepatan Hermes saat bekerja dengan GPP</a></li>
<li><a href="../id419485/index.html">Ada aplikasi untuk itu: pengumuman Mobius 2018 Moscow</a></li>
<li><a href="../id419491/index.html">Bagaimana STP Bekerja</a></li>
<li><a href="../id419493/index.html">Mengapa Anda perlu Splunk? Analisis Peristiwa Keamanan</a></li>
<li><a href="../id419495/index.html">Yang "menemukan" konduksi tulang, mengapa digunakan dan seberapa aman untuk pendengaran</a></li>
<li><a href="../id419505/index.html">Anda sekarang dapat menerima paket tanpa pemberitahuan dan paspor melalui surat di seluruh negara.</a></li>
<li><a href="../id419507/index.html">Tinjauan umum tentang printer 3D Rusia PICASO 3D Designer X dari 3Dtool</a></li>
<li><a href="../id419509/index.html">Jaringan Saraf Tiruan Fotonik</a></li>
<li><a href="../id419511/index.html">typeof (T) vs TypeOf⟨T⟩</a></li>
<li><a href="../id419513/index.html">Konfigurasikan kebijakan keamanan kata sandi di Zimbra</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>