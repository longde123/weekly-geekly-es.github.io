<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüëß üë©‚Äçüç≥ üë®üèª‚Äçüîß Cron no Linux: hist√≥rico, uso e dispositivo üë∏üèº üíé üß£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O cl√°ssico escreveu que happy hours n√£o s√£o observados. Naqueles tempos selvagens, n√£o havia programadores nem o Unix, mas hoje em dia os programadore...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cron no Linux: hist√≥rico, uso e dispositivo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/468061/"><img src="https://habrastorage.org/webt/tm/ya/6j/tmya6jd_1sbhnfncczo1nf2g7_y.jpeg"><br><p>  O cl√°ssico escreveu que happy hours n√£o s√£o observados.  Naqueles tempos selvagens, n√£o havia programadores nem o Unix, mas hoje em dia os programadores sabem muito bem: em vez deles, o cron seguir√° o tempo. </p><br><p>  Os utilit√°rios de linha de comando para mim s√£o fracos e rotineiros.  sed, awk, wc, cut e outros programas antigos s√£o executados por scripts em nossos servidores diariamente.  Muitos deles s√£o projetados como tarefas para o cron, um agendador dos anos 70. </p><br><p>  Por um longo tempo, usei o cron superficialmente, sem entrar em detalhes, mas uma vez, tendo encontrado um erro ao executar o script, decidi descobrir isso completamente.  Assim, apareceu este artigo, ao escrever sobre o qual me familiarizei com o POSIX crontab, as principais variantes do cron nas distribui√ß√µes populares do Linux e o dispositivo de algumas delas. </p><br><p>  Usando Linux e executando tarefas no cron?  Interessado na arquitetura de aplicativos do sistema Unix?  Ent√£o estamos a caminho! </p><a name="habracut"></a><br><h1 id="soderzhanie">  Conte√∫do </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Origem das esp√©cies</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Posix crontab</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mais vendidos - Vixie cron 3.0pl1</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cron no Debian e Ubuntu</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cronie no Red Hat, Fedora e CentOS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cronie no SLES e no openSUSE</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vixie cron device</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Posf√°cio</a> </li></ul><br><h1 id="proishozhdenie-vidov">  Origem das esp√©cies </h1><br><p>  A execu√ß√£o peri√≥dica de programas de usu√°rio ou sistema √© uma necessidade √≥bvia para todos os sistemas operacionais.  Portanto, a necessidade de servi√ßos que permitam o planejamento centralizado e a execu√ß√£o de tarefas, os programadores perceberam h√° muito tempo. </p><br><p> Os sistemas operacionais do tipo Unix t√™m origem na Vers√£o 7 Unix, desenvolvida na d√©cada de 1970 pelo Bell Labs, incluindo o famoso Ken Thompson.  Juntamente com a vers√£o 7 Unix, o cron, um servi√ßo para execu√ß√£o regular de tarefas de superusu√°rio, tamb√©m foi fornecido. </p><br><p>  Um cron moderno t√≠pico √© um programa simples, mas o algoritmo da vers√£o original era ainda mais simples: o servi√ßo acordava uma vez por minuto, leia a placa de tarefas de um √∫nico arquivo (/ etc / lib / crontab) e executava as tarefas que deveriam ser executadas para o superusu√°rio no minuto atual . </p><br><p>  Posteriormente, op√ß√µes avan√ßadas para um servi√ßo simples e √∫til vieram com todos os sistemas operacionais do tipo Unix. </p><br><p>  Descri√ß√µes generalizadas do formato crontab e os princ√≠pios b√°sicos do utilit√°rio em 1992 foram inclu√≠dos no padr√£o principal de sistemas operacionais do tipo Unix - POSIX - e, portanto, o cron do padr√£o de fato se tornou o padr√£o de jure. </p><br><p>  Em 1987, Paul Vixie, ap√≥s entrevistar os usu√°rios do Unix para obter sugest√µes para o cron, lan√ßou outra vers√£o do daemon que corrige alguns dos problemas do cron tradicional e estende a sintaxe dos arquivos de tabela. </p><br><p>  Na terceira vers√£o, o Vixie cron come√ßou a atender aos requisitos do POSIX; al√©m disso, o programa possu√≠a uma licen√ßa liberal, ou melhor, n√£o havia nenhuma licen√ßa, exceto os desejos do README: o autor n√£o d√° garantias, voc√™ n√£o pode excluir o nome do autor e s√≥ pode vender o programa com c√≥digo fonte  Esses requisitos acabaram sendo compat√≠veis com os princ√≠pios do software livre, que estavam ganhando popularidade naqueles anos; portanto, algumas das principais distribui√ß√µes Linux que apareceram no in√≠cio dos anos 90 tomaram o Vixie cron como um sistema e ainda o est√£o desenvolvendo. </p><br><p>  Em particular, a Red Hat e o SUSE est√£o desenvolvendo o fork do cronix do Vixie, enquanto o Debian e o Ubuntu est√£o usando o cron do Vixie original com muitos patches. </p><br><p>  Primeiro, vamos nos familiarizar com o utilit√°rio crontab definido pelo usu√°rio descrito no POSIX, ap√≥s o qual analisaremos as extens√µes de sintaxe apresentadas no Vixie cron e o uso de varia√ß√µes do Vixie cron nas distribui√ß√µes populares do Linux.  E, finalmente, a cereja no bolo √© uma an√°lise do dispositivo cron daemon. </p><br><h1 id="posix-crontab">  Posix crontab </h1><br><p>  Se o cron original sempre funcionou para o superusu√°rio, os agendadores modernos geralmente lidam com as tarefas dos usu√°rios comuns, o que √© mais seguro e conveniente. </p><br><p>  Os Cron s s√£o enviados com um conjunto de dois programas: o cron daemon em execu√ß√£o constante e o utilit√°rio crontab dispon√≠vel para os usu√°rios.  O √∫ltimo permite editar tabelas de tarefas espec√≠ficas para cada usu√°rio no sistema, enquanto o daemon inicia tarefas das tabelas de usu√°rio e sistema. </p><br><p>  O <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">padr√£o POSIX</a> n√£o descreve o comportamento do daemon e apenas o programa do usu√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">crontab</a> √© formalizado.  A exist√™ncia de mecanismos para iniciar tarefas do usu√°rio, √© claro, est√° impl√≠cita, mas n√£o descrita em detalhes. </p><br><p>  H√° quatro coisas que voc√™ pode fazer com o utilit√°rio crontab: edite a tabela de tarefas do usu√°rio no editor, carregue a tabela a partir do arquivo, mostre a tabela de tarefas atual e limpe a tabela de tarefas.  Exemplos do utilit√°rio crontab: </p><br><pre><code class="plaintext hljs">crontab -e #    crontab -l #    crontab -r #    crontab path/to/file.crontab #     </code> </pre> <br><p>  Ao chamar <code>crontab -e</code> , o editor especificado na <code>EDITOR</code> ambiente <code>EDITOR</code> padr√£o ser√° usado. </p><br><p>  As pr√≥prias tarefas s√£o descritas no seguinte formato: </p><br><pre> <code class="plaintext hljs"># -  # # ,   * * * * * /path/to/exec -a -b -c # ,   10-    10 * * * * /path/to/exec -a -b -c # ,   10-            10 2 * * * /path/to/exec -a -b -c &gt; /tmp/cron-job-output.log</code> </pre> <br><p>  Os cinco primeiros campos de registro: minutos [1..60], horas [0..23], dias do m√™s [1..31], meses [1..12], dias da semana [0..6], em que 0 - domingo.  O √∫ltimo, sexto, campo √© uma sequ√™ncia que ser√° executada pelo interpretador de comando padr√£o. </p><br><p>  Nos cinco primeiros campos, os valores podem ser listados com uma v√≠rgula: </p><br><pre> <code class="plaintext hljs"># ,         1,10 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  Ou atrav√©s de um h√≠fen: </p><br><pre> <code class="plaintext hljs"># ,          0-9 * * * * /path/to/exec -a -b -c</code> </pre> <br><p>  O acesso do usu√°rio ao agendamento de tarefas √© regulado nos arquivos cron.allow e cron.deny do POSIX, que listam, respectivamente, usu√°rios com acesso ao crontab e usu√°rios sem acesso ao programa.  O padr√£o n√£o regula a localiza√ß√£o desses arquivos. </p><br><p>  Os programas em execu√ß√£o, de acordo com o padr√£o, devem receber no m√≠nimo quatro vari√°veis ‚Äã‚Äãde ambiente: </p><br><ol><li>  HOME √© o diret√≥rio inicial do usu√°rio. </li><li>  LOGNAME - login do usu√°rio. </li><li>  PATH √© o caminho pelo qual encontrar os utilit√°rios de sistema padr√£o. </li><li>  SHELL √© o caminho para o shell usado. </li></ol><br><p>  Vale ressaltar que o POSIX n√£o diz nada sobre a origem dos valores para essas vari√°veis. </p><br><h1 id="hit-prodazh--vixie-cron-30pl1">  Mais vendidos - Vixie cron 3.0pl1 </h1><br><p>  O ancestral comum das variantes populares do cron √© o Vixie cron 3.0pl1, apresentado na lista de correspond√™ncia comp.sources.unix de 1992.  Os principais recursos desta vers√£o ser√£o considerados em mais detalhes. </p><br><p>  O Vixie cron vem em dois programas (cron e crontab).  Como de costume, o daemon √© respons√°vel por ler e iniciar tarefas da tabela de tarefas do sistema e tabelas de tarefas de usu√°rios individuais, e o utilit√°rio crontab √© respons√°vel pela edi√ß√£o de tabelas do usu√°rio. </p><br><h3 id="tablica-zadach-i-fayly-konfiguracii">  Tabela de tarefas e arquivos de configura√ß√£o </h3><br><p>  A tabela de tarefas do superusu√°rio est√° localizada em / etc / crontab.  A sintaxe da tabela do sistema corresponde √† sintaxe do Vixie cron, ajustada pelo fato de a sexta coluna indicar o nome do usu√°rio em nome de quem a tarefa √© iniciada: </p><br><pre> <code class="plaintext hljs">#     vlad * * * * * vlad /path/to/exec</code> </pre> <br><p>  As tabelas de tarefas comuns do usu√°rio est√£o localizadas em / var / cron / tabs / username e usam sintaxe comum.  Quando o utilit√°rio crontab √© iniciado, esses arquivos s√£o editados em nome do usu√°rio. </p><br><p>  As listas de usu√°rios com acesso ao crontab s√£o gerenciadas nos arquivos / var / cron / allow e / var / cron / deny, onde √© suficiente adicionar o nome do usu√°rio como uma linha separada. </p><br><h3 id="rasshirennyy-sintaksis">  Sintaxe estendida </h3><br><p>  Comparado ao crixab POSIX, a solu√ß√£o de Paul Vixie cont√©m v√°rias modifica√ß√µes muito √∫teis na sintaxe da tabela de tarefas do utilit√°rio. </p><br><p>  Uma nova sintaxe da tabela ficou dispon√≠vel: por exemplo, voc√™ pode especificar os dias da semana ou os meses pelo nome (seg, ter e assim por diante): </p><br><pre> <code class="plaintext hljs">#         * * * Jan Mon,Tue /path/to/exec</code> </pre> <br><p>  Voc√™ pode especificar a etapa atrav√©s da qual as tarefas s√£o iniciadas: </p><br><pre> <code class="plaintext hljs">#       */2 * * * Mon,Tue /path/to/exec</code> </pre> <br><p>  Etapas e intervalos podem ser misturados: </p><br><pre> <code class="plaintext hljs">#             0-10/2 * * * * /path/to/exec</code> </pre> <br><p>  Alternativas intuitivas para a sintaxe regular s√£o suportadas (reinicializa√ß√£o, anual, anual, mensal, semanal, di√°ria, meia-noite, a cada hora): </p><br><pre> <code class="plaintext hljs">#     @reboot /exec/on/reboot #     @daily /exec/daily #     @hourly /exec/daily</code> </pre> <br><h3 id="sreda-vypolneniya-zadach">  Ambiente de execu√ß√£o de tarefas </h3><br><p>  O Vixie cron permite alterar o ambiente dos aplicativos em execu√ß√£o. </p><br><p>  As vari√°veis ‚Äã‚Äãde ambiente USER, LOGNAME e HOME n√£o s√£o apenas fornecidas pelo daemon, mas s√£o obtidas do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivo passwd</a> .  A vari√°vel PATH obt√©m o valor "/ usr / bin: / bin" e SHELL obt√©m o valor "/ bin / sh".  Os valores de todas as vari√°veis, exceto LOGNAME, podem ser alterados nas tabelas do usu√°rio. </p><br><p>  Algumas vari√°veis ‚Äã‚Äãde ambiente (principalmente SHELL e HOME) s√£o usadas pelo pr√≥prio cron para executar a tarefa.  Aqui est√° o que pode parecer usar bash em vez do sh padr√£o para executar tarefas personalizadas: </p><br><pre> <code class="plaintext hljs">SHELL=/bin/bash HOME=/tmp/ # exec   bash-  /tmp/ * * * * * /path/to/exec</code> </pre> <br><p>  Por fim, todas as vari√°veis ‚Äã‚Äãde ambiente definidas na tabela (usadas pelo cron ou necess√°rias para o processo) ser√£o transferidas para a tarefa em execu√ß√£o. </p><br><p>  O utilit√°rio crontab usa o editor especificado na vari√°vel de ambiente VISUAL ou EDITOR para editar arquivos.  Se essas vari√°veis ‚Äã‚Äãn√£o estiverem definidas no ambiente em que o crontab foi iniciado, "/ usr / ucb / vi" ser√° usado (o ucb √© provavelmente a Universidade da Calif√≥rnia, Berkeley). </p><br><h1 id="cron-v-debian-i-ubuntu">  cron no Debian e Ubuntu </h1><br><p>  Os desenvolvedores Debian e derivados lan√ßaram uma vers√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">altamente modificada</a> do Vixie cron vers√£o 3.0pl1.  N√£o h√° diferen√ßas na sintaxe dos arquivos de tabela; para os usu√°rios, esse √© o mesmo cron do Vixie.  Maiores novos recursos: suporte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">syslog</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SELinux</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PAM</a> . </p><br><p>  Das mudan√ßas menos vis√≠veis, mas tang√≠veis - a localiza√ß√£o dos arquivos de configura√ß√£o e tabelas de tarefas. </p><br><p>  As tabelas de usu√°rio no Debian est√£o localizadas no diret√≥rio / var / spool / cron / crontabs, a tabela do sistema ainda est√° l√° em / etc / crontab.  As tabelas de tarefas espec√≠ficas da Debian s√£o colocadas em /etc/cron.d, de onde o daemon cron as l√™ automaticamente.  O controle de acesso do usu√°rio √© regulado pelos arquivos /etc/cron.allow e /etc/cron.deny. </p><br><p>  O shell / bin / sh padr√£o ainda √© usado como o shell padr√£o.O Debian atua como um pequeno shell <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dash</a> compat√≠vel com POSIX iniciado sem ler nenhuma configura√ß√£o (no modo n√£o interativo). </p><br><p>  O pr√≥prio Cron nas √∫ltimas vers√µes do Debian √© lan√ßado atrav√©s do systemd, e a configura√ß√£o do lan√ßamento pode ser vista em /lib/systemd/system/cron.service.  N√£o h√° nada de especial na configura√ß√£o do servi√ßo; qualquer gerenciamento de tarefas mais fino pode ser feito por meio de vari√°veis ‚Äã‚Äãde ambiente declaradas diretamente no crontab de cada usu√°rio. </p><br><h1 id="cronie-v-redhat-fedora-i-centos">  cronie no RedHat, Fedora e CentOS </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cronie</a> - fork do Vixie cron vers√£o 4.1.  Como no Debian, a sintaxe n√£o mudou, mas foram adicionados suporte ao PAM e SELinux, trabalhando em um cluster, rastreando arquivos usando o inotify e outros recursos. </p><br><p>  A configura√ß√£o padr√£o est√° nos locais habituais: a tabela do sistema est√° em / etc / crontab, os pacotes colocam suas tabelas em /etc/cron.d, as tabelas de usu√°rio caem em / var / spool / cron / crontabs. </p><br><p>  O daemon √© executado em systemd, a configura√ß√£o do servi√ßo √© /lib/systemd/system/crond.service. </p><br><p>  Na inicializa√ß√£o, as distribui√ß√µes do tipo Red Hat usam / bin / sh por padr√£o, cuja fun√ß√£o √© o bash padr√£o.  Deve-se observar que, ao executar tarefas cron por meio de / bin / sh, o shell bash inicia no modo compat√≠vel com POSIX e n√£o l√™ nenhuma configura√ß√£o adicional ao operar no modo n√£o interativo. </p><br><h1 id="cronie-v-sles-i-opensuse">  cronie no SLES e no openSUSE </h1><br><p>  A distribui√ß√£o SLES alem√£ e seu derivado do openSUSE usam o mesmo cronie.  O daemon aqui tamb√©m √© executado em systemd, a configura√ß√£o do servi√ßo est√° em /usr/lib/systemd/system/cron.service.  Configura√ß√£o: / etc / crontab, /etc/cron.d, / var / spool / cron / tabs.  Como / bin / sh age da mesma forma, iniciada no modo n√£o interativo compat√≠vel com POSIX. </p><br><h1 id="ustroystvo-vixie-cron">  Vixie cron device </h1><br><p>  Os descendentes modernos de cron em compara√ß√£o com o Vixie cron n√£o mudaram radicalmente, mas ainda adquiriram novos recursos que n√£o s√£o necess√°rios para entender os princ√≠pios do programa.  Muitas dessas extens√µes s√£o confusas e confundem o c√≥digo.  O c√≥digo fonte cron original de Paul Vixie √© um prazer de ler. </p><br><p>  Portanto, decidi analisar o dispositivo cron usando o exemplo de um programa comum para os dois ramos do desenvolvimento do cron - o Vixie cron 3.0pl1.  Simplificarei os exemplos removendo ifdefs que complicam a leitura e omitindo os detalhes secund√°rios. </p><br><p>  O trabalho do dem√¥nio pode ser dividido em v√°rias etapas: </p><br><ol><li>  Inicializa√ß√£o do programa. </li><li>  Colete e atualize a lista de tarefas a serem executadas. </li><li>  A opera√ß√£o principal do loop cron. </li><li>  In√≠cio da tarefa. </li></ol><br><p>  Vamos orden√°-los em ordem. </p><br><h3 id="inicializaciya">  Inicializa√ß√£o </h3><br><p>  Quando iniciado, ap√≥s verificar os argumentos do processo, o cron instala os manipuladores de sinal SIGCHLD e SIGHUP.  O primeiro registra a conclus√£o do processo filho, o segundo fecha o descritor de arquivo do arquivo de log: </p><br><pre> <code class="cpp hljs">signal(SIGCHLD, sigchld_handler); signal(SIGHUP, sighup_handler);</code> </pre> <br><p>  O daemon cron no sistema sempre funciona sozinho, apenas como superusu√°rio e no diret√≥rio principal do cron.  As chamadas a seguir criam um bloqueio de arquivo com o PID do processo daemon, verifique se o usu√°rio est√° correto e altere o diret√≥rio atual para o principal: </p><br><pre> <code class="cpp hljs">acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); set_cron_uid(); set_cron_cwd();</code> </pre> <br><p>  O caminho padr√£o est√° definido, que ser√° usado ao iniciar os processos: </p><br><pre> <code class="cpp hljs">setenv(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, _PATH_DEFPATH, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Em seguida, o processo √© "demonizado": ele cria uma c√≥pia filho do processo chamando fork e uma nova sess√£o no processo filho (chamando setsid).  N√£o h√° mais necessidade do processo pai - e ele conclui o trabalho: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> _exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><p>  A finaliza√ß√£o do processo pai libera o bloqueio no arquivo de bloqueio.  Al√©m disso, voc√™ precisa atualizar o PID no arquivo para o filho.  Depois disso, o banco de dados de tarefas √© preenchido: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> database.head = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.tail = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; database.mtime = (<span class="hljs-keyword"><span class="hljs-keyword">time_t</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>; load_database(&amp;database);</code> </pre> <br><p>  O cron adicional prossegue para o ciclo de trabalho principal.  Mas antes disso, d√™ uma olhada no carregamento da lista de tarefas. </p><br><h3 id="sbor-i-obnovlenie-spiska-zadach">  Coletando e Atualizando a Lista de Tarefas </h3><br><p>  A fun√ß√£o load_database √© respons√°vel por carregar a lista de tarefas.  Ele verifica o sistema principal crontab e o diret√≥rio com os arquivos do usu√°rio.  Se os arquivos e o diret√≥rio n√£o foram alterados, a lista de tarefas n√£o √© relida.  Caso contr√°rio, uma nova lista de tarefas come√ßa a se formar. </p><br><p>  Fazendo download de um arquivo do sistema com nomes especiais de arquivo e tabela: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (syscron_stat.st_mtime) { process_crontab(<span class="hljs-string"><span class="hljs-string">"root"</span></span>, <span class="hljs-string"><span class="hljs-string">"*system*"</span></span>, SYSCRONTAB, &amp;syscron_stat, &amp;new_db, old_db); }</code> </pre> <br><p>  Carregando tabelas do usu√°rio em um loop: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> != (dp = readdir(dir))) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> fname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>], tabname[MAXNAMLEN+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dp-&gt;d_name[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(fname, dp-&gt;d_name); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(tabname, CRON_TAB(fname)); process_crontab(fname, fname, tabname, &amp;statbuf, &amp;new_db, old_db); }</code> </pre><br><p>  Em seguida, o banco de dados antigo √© substitu√≠do por um novo. </p><br><p>  Nos exemplos acima, chamar a fun√ß√£o process_crontab garante que o usu√°rio exista que corresponda ao nome do arquivo de tabela (a menos que seja o superusu√°rio) e, em seguida, chame load_user.  O √∫ltimo j√° l√™ o pr√≥prio arquivo linha por linha: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((status = load_env(envstr, file)) &gt;= OK) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (status) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ERR: free_user(u); u = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> done; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: e = load_entry(file, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, pw, envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e) { e-&gt;next = u-&gt;crontab; u-&gt;crontab = e; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: envp = env_set(envp, envstr); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><p>  Aqui, a vari√°vel de ambiente (linhas do formato VAR = value) √© configurada pelas fun√ß√µes load_env / env_set ou a descri√ß√£o da tarefa (* * * * * / path / to / exec) √© lida pela fun√ß√£o load_entry. </p><br><p>  A entidade de entrada retornada por load_entry √© nossa tarefa colocada na lista geral de tarefas.  Na pr√≥pria fun√ß√£o, √© realizada uma longa an√°lise do formato da hora, mas estamos mais interessados ‚Äã‚Äãna forma√ß√£o de vari√°veis ‚Äã‚Äãde ambiente e par√¢metros de inicializa√ß√£o de tarefas: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*         passwd*/</span></span> e-&gt;uid = pw-&gt;pw_uid; e-&gt;gid = pw-&gt;pw_gid; <span class="hljs-comment"><span class="hljs-comment">/*    (/bin/sh),      */</span></span> e-&gt;envp = env_copy(envp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"SHELL=%s"</span></span>, _PATH_BSHELL); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"HOME=%s"</span></span>, pw-&gt;pw_dir); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!env_get(<span class="hljs-string"><span class="hljs-string">"PATH"</span></span>, e-&gt;envp)) { <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"PATH=%s"</span></span>, _PATH_DEFPATH); e-&gt;envp = env_set(e-&gt;envp, envstr); } <span class="hljs-comment"><span class="hljs-comment">/*     passwd */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(envstr, <span class="hljs-string"><span class="hljs-string">"%s=%s"</span></span>, <span class="hljs-string"><span class="hljs-string">"LOGNAME"</span></span>, pw-&gt;pw_name); e-&gt;envp = env_set(e-&gt;envp, envstr);</code> </pre> <br><p>  O ciclo principal tamb√©m funciona com a lista atual de tarefas. </p><br><h3 id="glavnyy-cikl">  Ciclo principal </h3><br><p>  O cron original da Vers√£o 7 Unix funcionava de maneira simples: em um ciclo, reli a configura√ß√£o, executei as tarefas do minuto atual como superusu√°rio e dormi at√© o in√≠cio do pr√≥ximo minuto.  Essa abordagem simples em m√°quinas mais antigas exigia muitos recursos. </p><br><p>  Uma vers√£o alternativa foi proposta no SysV, na qual o daemon adormeceu at√© o pr√≥ximo minuto, para o qual a tarefa foi definida, ou por 30 minutos.  Os recursos para reler as tarefas de configura√ß√£o e verifica√ß√£o nesse modo foram consumidos menos, mas tornou-se inconveniente atualizar rapidamente a lista de tarefas. </p><br><p>  O cron Vixie voltou a verificar as listas de tarefas uma vez por minuto, j√° que no final dos anos 80 os recursos em m√°quinas Unix padr√£o haviam se tornado muito maiores: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  ,       */</span></span> run_reboot_jobs(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime    */</span></span> cron_sync(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (TRUE) { <span class="hljs-comment"><span class="hljs-comment">/*  ,     TargetTime    ,    */</span></span> cron_sleep(); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> load_database(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> cron_tick(&amp;database); <span class="hljs-comment"><span class="hljs-comment">/*  TargetTime     */</span></span> TargetTime += <span class="hljs-number"><span class="hljs-number">60</span></span>; }</code> </pre><br><p>  A fun√ß√£o cron_sleep, que chama as fun√ß√µes job_runqueue (iterando e iniciando tarefas) e do_command (iniciando cada tarefa individual), est√° diretamente envolvida na execu√ß√£o das tarefas.  A √∫ltima fun√ß√£o deve ser considerada em mais detalhes. </p><br><h3 id="zapusk-zadachi">  In√≠cio da tarefa </h3><br><p>  A fun√ß√£o do_command √© executada em um bom estilo Unix, ou seja, faz bifurca√ß√£o para execu√ß√£o de tarefas ass√≠ncronas.  O processo pai continua a lan√ßar tarefas, o processo filho est√° preparando o processo da tarefa: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (fork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*   fork */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*  :          */</span></span> acquire_daemonlock(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> child_process(e, u); <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> _exit(OK_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  H√° muita l√≥gica no processo child_process: leva a sa√≠da padr√£o e os fluxos de erros para si, para que possam ser enviados para o correio (se a vari√°vel de ambiente MAILTO estiver especificada na tabela de tarefas) e, finalmente, aguarda a conclus√£o do processo da tarefa principal. </p><br><p>  O processo da tarefa √© formado por outro fork: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (vfork()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(ERROR_EXIT); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* -   ,   .. */</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setsid(); <span class="hljs-comment"><span class="hljs-comment">/* *     ,    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  ,    , *       */</span></span> setgid(e-&gt;gid); setuid(e-&gt;uid); chdir(env_get(<span class="hljs-string"><span class="hljs-string">"HOME"</span></span>, e-&gt;envp)); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*   SHELL      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *shell = env_get(<span class="hljs-string"><span class="hljs-string">"SHELL"</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*       , *    ,       */</span></span> execle(shell, shell, <span class="hljs-string"><span class="hljs-string">"-c"</span></span>, e-&gt;cmd, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-number"><span class="hljs-number">0</span></span>, e-&gt;envp); <span class="hljs-comment"><span class="hljs-comment">/*  ‚Äî    ?   */</span></span> perror(<span class="hljs-string"><span class="hljs-string">"execl"</span></span>); _exit(ERROR_EXIT); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    :      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br><p>  Aqui, em geral, e todo o cron.  Omiti alguns detalhes interessantes, por exemplo, respondendo a usu√°rios remotos, mas descrevi o principal. </p><br><h1 id="posleslovie">  Posf√°cio </h1><br><p>  Cron √© um programa surpreendentemente simples e √∫til, feito nas melhores tradi√ß√µes do mundo Unix.  Ela n√£o faz nada sup√©rfluo, mas tem feito seu trabalho notavelmente nas √∫ltimas d√©cadas.  Conhecer o c√≥digo da vers√£o que acompanha o Ubuntu n√£o levou mais de uma hora, e eu me diverti muito!  Espero poder compartilhar com voc√™. </p><br><p>  N√£o conhe√ßo voc√™, mas √© um pouco triste para mim perceber que a programa√ß√£o moderna, com sua tend√™ncia a se complicar e se abstrair, deixou de ter tanta simplicidade. </p><br><p>  Existem muitas alternativas modernas ao cron: systemd-timers permitem organizar sistemas complexos com depend√™ncias; no fcron, voc√™ pode controlar de forma mais flex√≠vel o consumo de recursos por tarefas.  Mas, pessoalmente, eu sempre tive o crontab mais simples. </p><br><p>  Em uma palavra, ame o Unix, use programas simples e n√£o se esque√ßa de ler mana para sua plataforma! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468061/">https://habr.com/ru/post/pt468061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468049/index.html">Usando o werf para implementar gr√°ficos Helm complexos</a></li>
<li><a href="../pt468051/index.html">VDS com Windows Server licenciado por 100 rublos: mito ou realidade?</a></li>
<li><a href="../pt468053/index.html">Machine Learning para sua ca√ßa plana. Parte 1</a></li>
<li><a href="../pt468057/index.html">Desenvolvimento de sistema operacional Unix-like - Multitarefa e chamadas de sistema (7)</a></li>
<li><a href="../pt468059/index.html">Minha segunda semana com o Haiku: muitos diamantes escondidos e surpresas agrad√°veis, al√©m de alguns problemas</a></li>
<li><a href="../pt468063/index.html">Angulareact</a></li>
<li><a href="../pt468065/index.html">Modelos de gerenciamento de produtos mentais para todos</a></li>
<li><a href="../pt468067/index.html">Como a composi√ß√£o alfa funciona</a></li>
<li><a href="../pt468071/index.html">Eduard Medvedev, CTO da Tungsten Labs: ‚ÄúCrescemos at√© o ponto em que a tecnologia pode causar grandes danos‚Äù</a></li>
<li><a href="../pt468073/index.html">Andrei Terekhov: "Voc√™ pode dizer o quanto quiser que o americano √© melhor, mas nosso carro nunca quebra"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>