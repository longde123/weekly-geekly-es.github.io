<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüè´ üë∑üèº üë®üèº‚Äçüè≠ Leia o firmware seguro do flash STM32F1xx usando o ChipWhisperer ü•ô üÜë üßëüèø‚Äçü§ù‚ÄçüßëüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No artigo anterior , lidamos com ataques de falha de Vcc usando ChipWhisperer. Nosso objetivo adicional era um estudo em fases do processo de leitura ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Leia o firmware seguro do flash STM32F1xx usando o ChipWhisperer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/483732/"><img src="https://habrastorage.org/webt/8h/fe/kf/8hfekfa930idilbg4asymru0cbm.png"><br><p>  No <a href="https://habr.com/ru/company/ntc-vulkan/blog/480500/">artigo</a> anterior <a href="https://habr.com/ru/company/ntc-vulkan/blog/480500/">,</a> lidamos com ataques de falha de Vcc usando ChipWhisperer.  Nosso objetivo adicional era um estudo em fases do processo de leitura de microcontroladores de firmware protegidos.  Usando esses ataques, um invasor pode obter acesso a todas as senhas de dispositivos e algoritmos de software.  Um exemplo v√≠vido √© o <a href="https://www.youtube.com/watch%3Flist%3DPLhixgUqwRTjyLgF4x-ZLVFL-CRTCrUo03%255E_%255Eamp%255E_%255Etime_continue%3D3%255E_%255Eamp%255E_%255Ev%3DnNBktKw9Is4">hackeamento da</a> carteira criptogr√°fica de hardware <a href="https://www.youtube.com/watch%3Flist%3DPLhixgUqwRTjyLgF4x-ZLVFL-CRTCrUo03%255E_%255Eamp%255E_%255Etime_continue%3D3%255E_%255Eamp%255E_%255Ev%3DnNBktKw9Is4">do</a> Ledger Nano S com a placa MK STM32F042 usando ataques de falha de Vcc. </p><br><p>  Interessante?  Vamos olhar embaixo do gato. </p><a name="habracut"></a><br><p>  Aprendemos sobre a possibilidade de ler firmware protegido em um <a href="https://pdfs.semanticscholar.org/4c01/a7514deacc2c02d010bb14c4fb58d1712adc.pdf">artigo</a> que apresenta os resultados de um ataque de falha de Vcc - ignorando o byte de prote√ß√£o RDP atrav√©s de um gerenciador de inicializa√ß√£o para v√°rios microcontroladores (daqui em diante - MK).  Tamb√©m recomendamos a leitura do <a href="https://limitedresults.com/2019/11/pwn-the-esp32-forever-flash-encryption-and-sec-boot-keys-extraction/">artigo</a> sobre a quebra do ESP32. </p><br><p>  A base te√≥rica do estudo foi a <a href="https://wiki.newae.com/Tutorial_A9_Bypassing_LPC1114_Read_Protect">diretriz para a</a> leitura bem-sucedida do firmware protegido para o LPC1114 atrav√©s de um carregador de m√°scara usando o ChipWhisperer. </p><br><p>  Como no primeiro artigo, decidimos realizar experimentos na placa MK STM32F103RBT6: </p><br><img src="https://habrastorage.org/webt/nc/ul/rw/nculrwzmxjlbwnjkwqzs9wlpq3e.png"><br><p>  <em>Placa STM32F103RBT6</em> </p><br><p>  A capacidade de gravar dados nos setores de mem√≥ria flash e RAM ou de l√™-los, al√©m de executar outras a√ß√µes com a mem√≥ria MK, √© determinada pelo valor do byte de prote√ß√£o (para STM32 - RDP).  Para valores MK diferentes e a finalidade dos bytes de prote√ß√£o, bem como o algoritmo para verifica√ß√£o deles, √© diferente. </p><br><p>  <strong>Configura√ß√£o de hardware</strong> </p><br><p>  Vamos come√ßar o experimento.  Primeiro voc√™ precisa conectar o ChipWhisperer ao MK de acordo com a figura: </p><br><img src="https://habrastorage.org/webt/cw/fs/8s/cwfs8sdseto5gdlv8bcedgk9wzg.png"><br><p>  <em>Diagrama de conex√£o do ChipWhisperer ao STM32 para leitura de firmware protegido atrav√©s de um carregador de m√°scaras</em> </p><br><p>  Os elementos que devem ser removidos da placa STM32F103RBT6 s√£o riscados no diagrama (em contraste com a conex√£o MK padr√£o).  As setas indicam os pontos de conex√£o do ChipWhisperer e as assinaturas indicam seus pinos. </p><br><p>  A presen√ßa de quartzo externo, mostrada no diagrama, n√£o √© necess√°ria porque, ao trabalhar com um carregador de m√°scaras, o MK STM32F103RBT6 usa um REL√ìGIO interno com uma frequ√™ncia de 24 MHz, para que n√£o haja sincroniza√ß√£o entre o ChipWhisperer e o MK. </p><br><p>  Vamos seguir para a configura√ß√£o do ChipWhisperer.  Como observado acima, a frequ√™ncia recomendada do ChipWhisperer √© 24 MHz (ou outro m√∫ltiplo).  Quanto maior a multiplicidade dessa frequ√™ncia, mais precisamente voc√™ pode ajustar o momento do ataque.  Devido √† falta de sincroniza√ß√£o, a sele√ß√£o do par√¢metro scope.glitch.offset √© opcional; qualquer valor pode ser atribu√≠do a ele. </p><br><p> Os par√¢metros scope.glitch.repeat e scope.glitch.width devem ser selecionados dependendo da frequ√™ncia definida do ChipWhisperer.  Com um grande valor de frequ√™ncia, todos os pulsos de curto prazo, cujo n√∫mero √© definido usando scope.glitch.repeat, se fundem em um pulso longo.  Portanto, voc√™ pode selecionar o valor do par√¢metro scope.glitch.width e scope.glitch.repeat fix ou vice-versa.  Descobrimos que a dura√ß√£o ideal do pulso deve ser de cerca de 80 ns (definida como a largura do pulso na metade do m√°ximo). </p><br><p>  Resta selecionar o valor do par√¢metro scope.glitch.ext_offset. </p><br><p>  <strong>Sele√ß√£o scope.glitch.ext_offset</strong> </p><br><p>  Primeiro voc√™ precisa escolher o momento do ataque.  De acordo com o esquema apresentado no <a href="https://www.st.com/content/ccc/resource/technical/document/application_note/51/5f/03/1e/bd/9b/45/be/CD00264342.pdf/files/CD00264342.pdf/jcr:content/translations/en.CD00264342.pdf">documento</a> da empresa STM, o valor do byte de prote√ß√£o √© verificado ap√≥s o recebimento de uma solicita√ß√£o para ler dados do setor flash: </p><br><img src="https://habrastorage.org/webt/m7/b-/ja/m7b-jat7np90pioveykbe8giw6y.jpeg"><br><p>  <em>O algoritmo para responder a uma solicita√ß√£o de leitura de dados do setor flash</em> </p><br><p>  Para verificar a validade desse esquema de verifica√ß√£o, lemos o c√≥digo execut√°vel do carregador de inicializa√ß√£o de um MK semelhante sem prote√ß√£o RDP via ST-Link.  As figuras abaixo mostram partes do algoritmo de processamento de <strong>comandos Read Memory</strong> . </p><br><img src="https://habrastorage.org/webt/tf/1k/uf/tf1kufh_t31hbeol-vhdxzooqba.png"><br><p>  <em>Vis√£o geral do processamento de um comando de leitura de mem√≥ria (a chamada para a fun√ß√£o de verifica√ß√£o RDP e o envio do NACK em caso de falha na verifica√ß√£o s√£o claramente vis√≠veis)</em> </p><br><img src="https://habrastorage.org/webt/as/vk/3h/asvk3h81acmw7vjx75he0tcimga.jpeg"><br><p>  <em>Corpo da fun√ß√£o de valida√ß√£o RDP</em> </p><br><p> Vamos prestar aten√ß√£o ao corpo da fun√ß√£o de verifica√ß√£o RDP: pode ser visto que o registro est√° sendo lido em <code>0x40022000 + 0x1C</code> , um deslocamento l√≥gico de 30 bits e ramifica√ß√£o.  A partir da documenta√ß√£o do <a href="https://www.st.com/content/ccc/resource/technical/document/programming_manual/10/98/e8/d4/2b/51/4b/f5/CD00283419.pdf/files/CD00283419.pdf/jcr:content/translations/en.CD00283419.pdf">manual de programa√ß√£o PM0075 (microcontroladores de mem√≥ria Flash STM32F10xxx)</a> , fica claro que <code>0x40022000</code> √© o endere√ßo base do controlador de mem√≥ria flash e <code>0x1C</code> √© o <strong>deslocamento do</strong> registro <strong>FLASH_OBR</strong> , no qual estamos interessados ‚Äã‚Äãno segundo bit de <strong>RDPRT</strong> : prote√ß√£o de leitura, que cont√©m o status da prote√ß√£o RDP. </p><br><p>  O momento necess√°rio do ataque √© o desenvolvimento da instru√ß√£o <code>LDR</code> (carregando da mem√≥ria).  Esta instru√ß√£o est√° localizada entre a solicita√ß√£o de leitura do firmware (enviando um byte <code>0x11</code> com uma <code>0xEE</code> ) e a resposta <code>ACK</code> / <code>NOACK</code> MK feita pelo UART.  Para corrigir visualmente esse momento, √© necess√°rio conectar o oscilosc√≥pio ao UART1_RX (pino PA10) e UART1_TX (pino PA9) e depois monitorar a altera√ß√£o de tens√£o de acordo com o UART1.  Como resultado, a forma de onda do ataque de for√ßa com o valor scope.glitch.ext_offset selecionado deve ser algo como isto: </p><br><img src="https://habrastorage.org/webt/fz/dm/j5/fzdmj5iyu5zfmcvmbqx0hf2mqms.jpeg"><br><p>  <em>Escolhendo o momento do ataque</em> </p><br><p>  <strong>Script de leitura de firmware</strong> </p><br><p>  Agora voc√™ precisa especificar o momento do acionador CW_TRIG no c√≥digo Python para interceptar o momento de transmitir a soma de verifica√ß√£o via UART1_RX.  O ChipWhisperer possui uma biblioteca para comunica√ß√£o com o carregador de m√°scaras STM32 MK.  No modo normal, esta biblioteca √© usada para baixar firmware de manuais para o MK usando a classe <code>class STM32FSerial(object)</code> da classe localizada no arquivo <code>programmer_stm32fserial.py</code> no caminho <code>software/chipwhisperer/hardware/naeusb/</code> .  Para ativar o gatilho, voc√™ precisa copiar esta classe para o script execut√°vel principal, para que o m√©todo de classe <code>CmdGeneric(self, cmd)</code> fique globalmente acess√≠vel e adicione o comando <code>scope.arm()</code> antes de enviar a soma de verifica√ß√£o (0xEE) da solicita√ß√£o para ler o setor de mem√≥ria.  A aula final √© dada no spoiler abaixo. </p><br><div class="spoiler">  <b class="spoiler_title">Classe para comunica√ß√£o do ChipWhisperer com o STM32</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logging <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chipwhisperer.common.utils <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> util <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chipwhisperer.hardware.naeusb.programmer_stm32fserial <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> supported_stm32f <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> chipwhisperer.capture.api.programmers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Programmer <span class="hljs-comment"><span class="hljs-comment"># class which can normally using internal CW library for reading STM32 firmware by UART class STM32Reader(Programmer): def __init__(self): super(STM32Reader, self).__init__() self.supported_chips = supported_stm32f self.slow_speed = False self.small_blocks = True self.stm = None def stm32prog(self): if self.stm is None: stm = self.scope.scopetype.dev.serialstm32f else: stm = self.stm stm.slow_speed = self.slow_speed stm.small_blocks = self.small_blocks return stm def stm32open(self): stm32f = self.stm32prog() stm32f.open_port() def stm32find(self): stm32f = self.stm32prog() stm32f.scope = self.scope sig, chip = stm32f.find() def stm32readMem(self, addr, lng): stm32f = self.stm32prog() stm32f.scope = self.scope #answer = stm32f.readMemory(addr, lng) answer = self.ReadMemory(addr, lng) return answer def stm32GetID(self): stm32f = self.stm32prog() stm32f.scope = self.scope answer = stm32f.cmdGetID() return answer # Needed for connection to STM after reload by reset_target(scope) method def FindSTM(self): #setup serial port (or CW-serial port?) stm32f = self.stm32prog() try: stm32f.initChip() except IOError: print("Failed to detect chip. Check following: ") print(" 1. Connections and device power. ") print(" 2. Device has valid clock (or remove clock entirely for internal osc).") print(" 3. On Rev -02 CW308T-STM32Fx boards, BOOT0 is routed to PDIC.") raise boot_version = stm32f.cmdGet() chip_id = stm32f.cmdGetID() for t in supported_stm32f: if chip_id == t.signature: # print("Detected known STMF32: %s" % t.name) stm32f.setChip(t) return chip_id, t # print("Detected unknown STM32F ID: 0x%03x" % chip_id) return chip_id, None</span></span></code> </pre> </div></div><br><p>  Observe que o carregador de m√°scaras STM32F1xx permite que voc√™ leia n√£o mais que 256 bytes de firmware de um setor flash especificado em uma √∫nica solicita√ß√£o.  Portanto, ao ler todo o firmware do MK, √© necess√°rio executar v√°rias solicita√ß√µes de leitura durante o ataque de falha de Vcc.  Em seguida, os 256 bytes recebidos devem ser divididos em oito matrizes de 32 bytes e formar um arquivo HEX a partir deles. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo do conversor HEX e fun√ß√µes auxiliares</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int2str_0xFF</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int_number, number_of_bytes)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'{0:0{1}X}'</span></span>.format(int_number,number_of_bytes_in_string) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data_dividing_from_256_to_32_bytes</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_to_divide, mem_sector, mem_step=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mem_sector &gt; <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>: mem_conversion = mem_sector &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span> mem_conversion = mem_sector - (mem_conversion &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) data_out = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(int(<span class="hljs-number"><span class="hljs-number">256</span></span>/mem_step)): data_vector = data_to_divide[(i * mem_step):((i + <span class="hljs-number"><span class="hljs-number">1</span></span>) * mem_step)] mem_calc = mem_conversion + (i * mem_step) data_out += read_and_convert_data_hex_file(data_vector, mem_calc, mem_step) + <span class="hljs-string"><span class="hljs-string">'\n'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_out <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_and_convert_data_hex_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data_to_convert, memory_address, mem_step)</span></span></span><span class="hljs-function">:</span></span> addr_string = memory_address -((memory_address &gt;&gt; <span class="hljs-number"><span class="hljs-number">20</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) data_buffer = <span class="hljs-string"><span class="hljs-string">''</span></span> crcacc = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, len(data_to_convert)): data_buffer += int2str_0xFF(data_to_convert[x], <span class="hljs-number"><span class="hljs-number">2</span></span>) crcacc += data_to_convert[x] crcacc += mem_step temp_addr_string = addr_string <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>): crcacc += temp_addr_string &gt;&gt; i*<span class="hljs-number"><span class="hljs-number">4</span></span> temp_addr_string -= ((temp_addr_string &gt;&gt; i*<span class="hljs-number"><span class="hljs-number">4</span></span>) &lt;&lt; i*<span class="hljs-number"><span class="hljs-number">4</span></span>) crcacc_2nd_symbol = (crcacc &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> crcacc = (crcacc_2nd_symbol &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) - crcacc <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> crcacc == <span class="hljs-number"><span class="hljs-number">0x100</span></span>: crcacc = <span class="hljs-number"><span class="hljs-number">0</span></span> RECTYP = <span class="hljs-number"><span class="hljs-number">0x00</span></span> out_string = <span class="hljs-string"><span class="hljs-string">':'</span></span>+ Int_To_Hex_String(mem_step, <span class="hljs-number"><span class="hljs-number">2</span></span>) +\ Int_To_Hex_String((addr_string),<span class="hljs-number"><span class="hljs-number">4</span></span>) +\ Int_To_Hex_String(RECTYP, <span class="hljs-number"><span class="hljs-number">2</span></span>) +\ data_buffer +\ Int_To_Hex_String(crcacc, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out_string <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_to_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(info_to_output, File_name, directory)</span></span></span><span class="hljs-function">:</span></span> file = open(directory + File_name + <span class="hljs-string"><span class="hljs-string">'.hex'</span></span>, <span class="hljs-string"><span class="hljs-string">'w'</span></span>) file.write(info_to_output) file.close() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset_target</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scope)</span></span></span><span class="hljs-function">:</span></span> scope.io.nrst = <span class="hljs-string"><span class="hljs-string">'low'</span></span> time.sleep(<span class="hljs-number"><span class="hljs-number">0.05</span></span>) scope.io.nrst = <span class="hljs-string"><span class="hljs-string">'high'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple Range = namedtuple(<span class="hljs-string"><span class="hljs-string">'Range'</span></span>, [<span class="hljs-string"><span class="hljs-string">'min'</span></span>, <span class="hljs-string"><span class="hljs-string">'max'</span></span>, <span class="hljs-string"><span class="hljs-string">'step'</span></span>])</code> </pre></div></div><br><p>  A configura√ß√£o das configura√ß√µes do ChipWhisperer agora est√° conclu√≠da.  O script final para ler o firmware √© o seguinte: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># string of start HEX file Start_of_File_Record = ':020000040800F2' # string of end HEX file End_of_File_Record = ':00000001FF' length_of_sector = 256 if length_of_sector % 4 != 0: sys.exit('length_of_sector must be equal to 4') output_to_file_buffer = '' output_to_file_buffer += Start_of_File_Record + '\n' mem_current = mem_start while mem_current &lt; mem_stop: # flush the garbage from the computer's target read buffer target.ser.flush() # run aux stuff that should run before the scope arms here reset_target(scope) # initialize STM32 after each reset prog.FindSTM() try: # reading of closed memory sector data = prog.stm32readMem(mem_current, length_of_sector) except Exception as message: message = str(message) if "Can't read port" in message: # print('Port silence') pass elif 'Unknown response. 0x11: 0x0' in message: # print('Crashed. Reload!') pass elif 'NACK 0x11' in message: # print('Firmware is closed!') pass else: # print('Unknown error:', message, scope.glitch.offset, scope.glitch.width, scope.glitch.ext_offset) pass else: data_to_out = data_dividing_from_256_to_32_bytes (data, mem_current) print(data_to_out) output_to_file_buffer += data_to_out mem_current += length_of_sector output_to_file_buffer += End_of_File_Record + '\n' send_to_file(output_to_file_buffer, File_name, directory)</span></span></code> </pre> <br><p>  Todos comentaram as mensagens de <code>print()</code> ap√≥s a linha, <code>except Exception as</code> ajuda para monitorar o status do MC ao procurar os par√¢metros ideais para o pulso de falha.  Para rastrear o estado espec√≠fico do MK, basta descomentar a mensagem <code>print()</code> necess√°ria. </p><br><p>  <strong>Resultados da leitura</strong> </p><br><p>  O v√≠deo mostra o download do firmware para o MK atrav√©s do programador ST-LINK, transferindo o RDP para o estado de prote√ß√£o e depois lendo o firmware: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CRfg9-1BV0k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Os seguintes erros podem impedir ataques bem-sucedidos de falhas de Vcc: </p><br><p>  ‚Ä¢ ler o setor errado da mem√≥ria; </p><br><p>  ‚Ä¢ remo√ß√£o espont√¢nea de firmware. </p><br><p>  A sele√ß√£o precisa do momento do ataque aumentando a frequ√™ncia do ChipWhisperer ajudar√° a evitar esses erros. </p><br><p>  Ap√≥s desenvolver e depurar o algoritmo para a leitura do firmware protegido, realizamos uma leitura de teste do firmware do programador ST-LINK-V2.1, que funciona no STM32F103CBT6 MK.  Alguns firmware, costuramos um MK "limpo" STM32F103CBT6 e o ‚Äã‚Äãinstalamos em vez do de f√°brica.  Como resultado, o ST-LINK-V2.1 com o MK substitu√≠do funcionou no modo normal, como se n√£o houvesse substitui√ß√£o. </p><br><p>  Tamb√©m tentamos realizar uma s√©rie de ataques ao STM32F303RCT7.  Esse MK durante o ataque se comportou de forma id√™ntica ao STM32F103RBT6, mas a resposta √† solicita√ß√£o de mem√≥ria de leitura continha um byte igual a 0x00, que n√£o coincidia com o resultado esperado.  O motivo dessa falha foi um princ√≠pio mais complexo e desenvolvido de organizar a prote√ß√£o desses MKs. </p><br><p>  Existem dois estados de prote√ß√£o no STM32F1xx MK: a prote√ß√£o est√° desativada (n√≠vel 0) e ativada (n√≠vel 1).  Nos modelos mais antigos, existem tr√™s estados de prote√ß√£o: a prote√ß√£o est√° desativada (N√≠vel 0, RDP = 0x55AA), a prote√ß√£o do flash e da mem√≥ria SRAM (N√≠vel 2, RDP = 0x33CC) e a prote√ß√£o da mem√≥ria flash apenas (o N√≠vel 1, o RDP aceita valores diferentes de de 0x55AA e 0x33CC).  Como o N√≠vel 1 pode receber muitos valores de RDP, a configura√ß√£o do N√≠vel 0 √© bastante dif√≠cil.  Por outro lado, √© poss√≠vel diminuir o n√≠vel de prote√ß√£o do N√≠vel 2 para o N√≠vel 1 pressionando um bit no byte RDP (mostrado na figura abaixo), o que permite o acesso √† mem√≥ria SRAM. </p><br><img src="https://habrastorage.org/webt/dj/by/ef/djbyefc1yji_gpevygy72yzvtjm.jpeg"><br><p>  <em>Compara√ß√£o de valores RDP para diferentes n√≠veis de prote√ß√£o de firmware</em> </p><br><p>  Resta apenas entender como um invasor pode tirar proveito disso.  Por exemplo, usando o m√©todo CBS (Cold-Boot Stepping) descrito <a href="https://www.usenix.org/system/files/conference/woot17/woot17-paper-obermaier.pdf">neste artigo</a> .  Esse m√©todo √© baseado em um instant√¢neo em fases do status da mem√≥ria SRAM (a frequ√™ncia de cada instant√¢neo estava na √°rea de microssegundos) ap√≥s o carregamento do MC para obter chaves de criptografia, senhas ocultas ou qualquer outra informa√ß√£o valiosa.  Os autores sugerem que o m√©todo CBS funcionar√° em todas as s√©ries STM32 MK. </p><br><p>  <strong>Conclus√µes</strong> </p><br><p>  Para resumir nossos experimentos.  Levamos v√°rios dias para concluir um ataque de falha no Vcc usando os dados obtidos em um estudo anterior (que pode ser lido <a href="https://habr.com/ru/company/ntc-vulkan/blog/480500/">aqui</a> ).  Portanto, aprender como realizar esses ataques √© bastante f√°cil. </p><br><p>  Os ataques de falha de Vcc s√£o perigosos porque s√£o dif√≠ceis de se defender.  Para reduzir a probabilidade de realizar com √™xito esses ataques, prop√µe-se usar o MK com um n√≠vel mais alto de prote√ß√£o. </p><br><p> <a href="https://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p>  A Raccoon Security √© uma equipe especial de especialistas no Centro T√©cnico e Cient√≠fico do Vulc√£o na √°rea de seguran√ßa da informa√ß√£o pr√°tica, criptografia, circuitos, engenharia reversa e cria√ß√£o de software de baixo n√≠vel. </p><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt483732/">https://habr.com/ru/post/pt483732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt483718/index.html">Como a VDI est√° transformando o ambiente do escrit√≥rio</a></li>
<li><a href="../pt483722/index.html">Geoanal√≠tica de varejo, parte 1: automatizamos o processo de escolha de um local para uma empresa. 2GIS + MS Azure + ML</a></li>
<li><a href="../pt483724/index.html">Trabalhar com o complexo de pneus personalizados Redd</a></li>
<li><a href="../pt483726/index.html">JavaScript e HTML de baunilha. Sem estruturas. Sem bibliotecas. N√£o tem problema</a></li>
<li><a href="../pt483730/index.html">Programadores Union 2: Chinelos pararam de rir e ficaram pensativos</a></li>
<li><a href="../pt483734/index.html">Que pre√ßo pagamos pelo uso de ass√≠ncrono / aguardar em JS / C # / Rust</a></li>
<li><a href="../pt483736/index.html">Pesquisa reversa de imagens: Um guia da Ag√™ncia de detetives Bellingcat</a></li>
<li><a href="../pt483740/index.html">Configurando o roteamento din√¢mico (em particular o BGP) sobre o t√∫nel OpenVPN no Linux (e provavelmente * BSD)</a></li>
<li><a href="../pt483742/index.html">Procure bugs como um modo de vida</a></li>
<li><a href="../pt483744/index.html">Venda de Ano Novo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>