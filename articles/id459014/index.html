<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòê ü§∫ ‚Ü™Ô∏è Keluar dari zona nyaman Anda: dari nodejs ke dlang üéã üì≥ üîì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada 2017, saya mulai menulis proyek pada nodejs - sebuah implementasi protokol Weinzierl ObjectServer untuk mengakses nilai-nilai KNX. Selama proses ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Keluar dari zona nyaman Anda: dari nodejs ke dlang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459014/"><p> Pada 2017, saya mulai menulis proyek pada nodejs - sebuah implementasi protokol Weinzierl ObjectServer untuk mengakses nilai-nilai KNX.  Selama proses penulisan, kami mempelajari: bekerja dengan protokol biner, menyajikan data, bekerja dengan soket (khususnya soket unix), bekerja dengan basis data redis dan saluran pub / sub. </p><br><p>  Proyek ini telah mencapai versi stabil.  Pada saat ini, saya perlahan-lahan memilih bahasa lain, khususnya Dart dan Flutter sebagai aplikasinya.  Di rak dibersihkan tanpa tindakan yang dibeli pada saat buku pedoman siswa G. Schildt. </p><br><p>  Suatu pemikiran yang gigih untuk menulis ulang proyek di C menetap di kepala saya.  Saya mempertimbangkan opsi Go, Rust, menolak konstruksi sintaksis lainnya.  Tidak ada cara untuk memulai, idenya ditunda untuk sementara waktu. </p><a name="habracut"></a><br><p>  Pada bulan Mei tahun ini, saya memutuskan untuk melihat bahasa D, untuk beberapa alasan yakin bahwa huruf D berarti dinamis.  Saya bertanya-tanya dalam waktu lama di mana dan mengapa pikiran ini ada di kepala saya, jadi saya tidak menemukan jawaban.  TAPI ini tidak penting lagi, karena saya terbawa oleh penulisan ulang sepanjang musim panas. </p><br><h2 id="sut-proekta">  Inti dari proyek </h2><br><p> Modul KNX BAOS 830/832/838 terhubung melalui UART ke komputer, protokol ObjectServer dibungkus dalam FT1.2.  Aplikasi membuat koneksi dengan <code>/dev/ttyXXX</code> , memproses data yang masuk, mengirimkan byte permintaan pengguna yang berasal dari saluran PUB / SUB ke antrian yang sama, atau ke antrian pekerjaan berdasarkan daftar Redis (untuk nodejs, antrian diimplementasikan dalam paket antrian lebah) ) </p><br><pre> <code class="javascript hljs">queue.on(<span class="hljs-string"><span class="hljs-string">"job"</span></span>, data =&gt; { <span class="hljs-comment"><span class="hljs-comment">//   : //  ,     //  ,      }); baos.on("data", data =&gt; { // ,  :    //  ,      //   -     pub/sub });</span></span></code> </pre> <br><h2 id="dinamichnost">  Dinamisme </h2><br><p>  JSON dalam js adalah hal asli, saya tidak tahu bagaimana pemrosesan terjadi dalam bahasa yang diketik secara statis.  Ternyata, sedikit perbedaan.  Misalnya, ambil metode <code>get value</code> .  Sebagai argumen, dibutuhkan nomor - nomor titik data, atau array nomor. </p><br><p>  Di js, pemeriksaan dilakukan: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(payload)) { <span class="hljs-comment"><span class="hljs-comment">//     return values; } if (typeof id === "number") { //     return value; } throw new Error(" id");</span></span></code> </pre> <br><p>  Pada dasarnya sama pada D: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (payload.type() == JSONType.integer) { <span class="hljs-comment"><span class="hljs-comment">//    } else if (payload.type() === JSONType.array) { //    } else { throw Errors.wrong_payload_type; }</span></span></code> </pre> <br><p>  Untuk beberapa alasan, pada saat Rust-sebuah pertimbangan, adalah kurangnya pemahaman bekerja dengan JSON yang memperlambat saya.  Poin lain yang terkait dengan dinamisme: array.  Di js, Anda terbiasa dengan fakta bahwa cukup memanggil metode <code>push</code> untuk menambahkan elemen.  Di C, dinamika diterapkan oleh alokasi memori manual, tetapi saya tidak benar-benar ingin naik ke sana.  Dlang, ternyata, mendukung array dinamis. </p><br><pre> <code class="cpp hljs">ubyte[] res; <span class="hljs-comment"><span class="hljs-comment">//   -     res.length = 1000; //        res.length = count; //        1</span></span></code> </pre> <br><p>  Data UART yang masuk dalam js dikonversi ke <code>Object</code> .  Untuk tujuan ini, struktur, enumerasi dengan nilai, dan gabungan sangat bagus dalam D. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OS_Services { unknown, GetServerItemReq = <span class="hljs-number"><span class="hljs-number">0x01</span></span>, GetServerItemRes = <span class="hljs-number"><span class="hljs-number">0x81</span></span>, SetServerItemReq = <span class="hljs-number"><span class="hljs-number">0x02</span></span>, SetServerItemRes = <span class="hljs-number"><span class="hljs-number">0x82</span></span>, <span class="hljs-comment"><span class="hljs-comment">// ... } // ... struct OS_Message { OS_Services service; OS_MessageDirection direction; bool success; union { // union of possible service returned structs // DatapointDescriptions/DatapointValues/ServerItems/ParameterBytes OS_DatapointDescription[] datapoint_descriptions; OS_DatapointValue[] datapoint_values; OS_ServerItem[] server_items; Exception error; }; }</span></span></code> </pre> <br><p>  Dengan pesan masuk: </p><br><pre> <code class="cpp hljs">ubyte mainService = data.read!ubyte(); ubyte subService = data.read!ubyte(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mainService == OS_MainService) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(subService) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OS_Services.GetServerItemRes: result.direction = OS_MessageDirection.response; result.service= OS_Services.GetServerItemRes; result.success = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; result.server_items = _processServerItemRes(data); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OS_Services.SetServerItemRes: result.direction = OS_MessageDirection.response; <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Dalam js, saya menyimpan nilai byte dalam array, dengan data yang masuk, saya mencari dan mengembalikan sebuah string dengan nama layanan.  Struktur, enumerasi, dan asosiasi terlihat lebih ketat. </p><br><h2 id="rabota-s-massivami-baytovyh-dannyh">  Bekerja dengan array data byte </h2><br><p>  Node.js Saya suka abstraksi <code>Buffer</code> .  Sebagai contoh: akan lebih mudah untuk melakukan konversi dua byte ke integer yang tidak ditandatangani menggunakan metode <code>readUInt16BE(offset)</code> , untuk menulis - <code>writeUInt16BE(value, offset)</code> , buffer yang digunakan secara aktif untuk bekerja dengan protokol biner.  Untuk dlang, saya awalnya memulai paket repositori ke sesuatu yang serupa.  Jawabannya ditemukan di perpustakaan standar <code>std.bitmanip</code> .  Untuk bilangan bulat bertanda 2 byte: panjang <code>ushort start = data.read!ushort()</code> , untuk menulis: <code>result.write!ushort(start, 2);</code>  dimana argumen ke-2 adalah ofset. </p><br><h2 id="ee-promises-asyncawait">  EE, janji, async / menunggu. </h2><br><p>  Bagian terburuk adalah pemrograman tanpa <code>EventEmitter</code> .  Dalam node.js, fungsi pendengar hanya terdaftar, dan pada suatu peristiwa, mereka dipanggil.  Jadi, seseorang tidak harus berpikir keras.  Paket tinylis dan <code>serialport</code> dlang (dependensi aplikasi saya) memiliki metode non-pemblokiran untuk memproses pesan.  Solusinya sederhana: untuk saat ini, memang benar untuk menerima port serial dan pesan pub / sub channel secara bergantian.  Jika ada permintaan pengguna yang masuk ke saluran pub / sub, program harus mengirim pesan ke port serial, dapatkan hasilnya dan mengirim pengguna kembali ke pub / sub.  Diputuskan untuk membuat metode untuk memblokir permintaan serial. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!(_responseReceived || _resetInd || _interrupted)) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { processIncomingData(); processIncomingInterrupts(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_resetInd || _interrupted) { _response.success = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _response.service = OS_Services.unknown; _response.error = Errors.interrupted; _responseReceived = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _ackReceived = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// ... // ... return _response;</span></span></code> </pre> <br><p>  Dalam loop sementara, data disurvei oleh metode metode non-blockingIncomingData <code>processIncomingData()</code> .  Kemungkinan modul KNX dapat di-boot ulang (terputus dan dihubungkan kembali ke bus atau perangkat lunak KNX) juga disediakan.  Juga, penangan <code>processIncomingInterrupts()</code> memeriksa pub layanan / sub saluran untuk permintaan <code>reset</code> .  Tidak ada fungsi janji atau asinkron, tidak seperti implementasi js sebelumnya.  Saya harus berpikir tentang struktur program (yaitu, urutan fungsi panggilan), tetapi, karena tidak adanya abstraksi yang tidak perlu, menjadi lebih mudah untuk diprogram.  Bahkan, ketika <code>await someAsyncMethod</code> dipanggil dalam kode js, fungsi asynchronous disebut sebagai blocking, melewati event loop.  Kemungkinan bahasa itu baik, tetapi Anda bisa melakukannya tanpa itu. </p><br><h2 id="otlichiya">  Perbedaan </h2><br><p>  Antrian pekerjaan.  Implementasi node.js menggunakan paket <code>bee-queue</code> untuk tujuan ini.  Dalam implementasi pada D, permintaan dikirim hanya melalui pub / sub. <br>  Kalau tidak, semuanya hampir identik. </p><br><p>  Versi yang dikompilasi mengkonsumsi 10 kali lebih sedikit RAM, yang mungkin penting untuk komputer papan tunggal. </p><br><h2 id="kompilyaciya">  Kompilasi </h2><br><p>  Kompilasi dilakukan menggunakan ldc pada platform aarch64. </p><br><p>  Untuk menginstal ldc: </p><br><pre> <code class="plaintext hljs">curl -fsS https://dlang.org/install.sh | bash -s ldc</code> </pre> <br><p>  Motherboard telah dirakit, terdiri dari tiga komponen utama: NanoPi Neo Core2 sebagai komputer, modul KNX BAOS 830 untuk komunikasi dengan bus KNX, dan Silvertel Ag9205 untuk daya PoE, di mana pemrograman dilakukan. </p><br><div class="spoiler">  <b class="spoiler_title">Penampilan papan</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/zc/1n/0f/zc1n0f_fs3uyx8pbk02-54_l9dm.jpeg"></p></div></div><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Saya tidak akan menilai bahasa mana yang lebih baik atau lebih buruk.  Untuk masing-masing: js sangat bagus untuk belajar, tingkat abstraksi (janji, penghasil emisi) membuatnya mudah dan cepat untuk membangun struktur aplikasi.  Saya mendekati implementasi dlang dengan rencana yang jelas dan hafal selama satu setengah tahun, apa yang harus dilakukan.  Ketika Anda tahu data apa yang perlu diproses dan bagaimana, pengetikan statis tidak menakutkan.  Metode non-blocking memungkinkan Anda untuk mengatur siklus kerja.  Ini adalah pekerjaan pertama saya di D, sebuah karya yang menarik dan informatif. </p><br><p>  Adapun meninggalkan zona nyaman (seperti yang ditunjukkan dalam judul): dalam kasus saya, rasa takut memiliki mata besar, yang untuk waktu yang lama mencegah saya mencoba sesuatu selain nodejs. </p><br><p>  Kode sumber terbuka dan dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/dobaos/dobaos</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459014/">https://habr.com/ru/post/id459014/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458996/index.html">User Inyerface - bagaimana tidak menyiksa pengguna</a></li>
<li><a href="../id459000/index.html">Bagaimana saya mencoba meningkatkan Halo 2, tetapi hampir merusaknya</a></li>
<li><a href="../id459002/index.html">Cara mengkonfigurasi HTTPS - Generator Konfigurasi SSL akan membantu</a></li>
<li><a href="../id459004/index.html">Algoritma kriptografi Grasshopper: kompleks</a></li>
<li><a href="../id459012/index.html">Membuat aplikasi untuk Bitrix24 dari awal</a></li>
<li><a href="../id459018/index.html">Taktik bermain peran di desktop</a></li>
<li><a href="../id459020/index.html">Mengapa DFSR tidak mereplikasi beberapa file dan cara mengatasinya</a></li>
<li><a href="../id459022/index.html">Komunikasi video mata-ke-mata: upaya untuk menyelesaikan masalah kurangnya kontak mata</a></li>
<li><a href="../id459024/index.html">Bagaimana kami menembus Great Chinese Firewall (bagian 3)</a></li>
<li><a href="../id459028/index.html">Alokasi memori statis dalam mikrokontroler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>