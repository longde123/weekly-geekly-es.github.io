<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÉè üéØ üëΩ Erkundung des Sandshaders des Journey-Spiels üåÇ üöá üóØÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter den vielen Indie-Spielen, die in den letzten 10 Jahren ver√∂ffentlicht wurden, ist eines meiner Lieblingsspiele definitiv Journey . Dank seiner a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erkundung des Sandshaders des Journey-Spiels</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476448/">  Unter den vielen Indie-Spielen, die in den letzten 10 Jahren ver√∂ffentlicht wurden, ist eines meiner Lieblingsspiele definitiv <em>Journey</em> .  Dank seiner atemberaubenden √Ñsthetik und seines wundersch√∂nen Soundtracks ist <em>Journey</em> in nahezu allen Aspekten der Entwicklung zu einem hervorragenden Beispiel geworden. <br><br>  Ich bin ein Spieleentwickler und technischer K√ºnstler, daher war ich von der Art und Weise, wie der Sand gerendert wurde, am meisten fasziniert.  Es ist nicht nur sch√∂n, sondern steht auch in direktem Zusammenhang mit dem grundlegenden Gameplay und dem gesamten Gameplay.  <em>Journey</em> ist buchst√§blich aus Sand gebaut, und ohne solch einen erstaunlichen Effekt k√∂nnte das Spiel selbst einfach nicht existieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/be0/2a8/63fbe02a87ccac8101001a43d953776f.jpg"></div><br>  In diesem Artikel, der in zwei Beitr√§ge unterteilt ist, m√∂chte ich dem <em>Journey-</em> Erbe meine Anerkennung zollen, indem ich Ihnen beibringe, wie Sie mit Shadern genau dasselbe Sand-Rendering erstellen.  Unabh√§ngig davon, ob Sandd√ºnen in Ihrem Spiel ben√∂tigt werden, k√∂nnen Sie in dieser Reihe von Tutorials lernen, wie Sie eine bestimmte √Ñsthetik in Ihrem eigenen Spiel wiederherstellen.  Wenn Sie den in <em>Journey</em> verwendeten sch√∂nen Sand-Shader neu erstellen m√∂chten, m√ºssen Sie zun√§chst verstehen, wie er erstellt wurde.  Und obwohl es √§u√üerst komplex aussieht, besteht es tats√§chlich aus mehreren relativ einfachen Effekten.  Dieser Ansatz, Shader zu schreiben, ist notwendig, um ein erfolgreicher technischer K√ºnstler zu werden.  Daher hoffe ich, dass Sie diese <em>Reise</em> mit mir machen, auf der wir nicht nur die Erstellung von Shadern erforschen, sondern auch lernen, wie man √Ñsthetik und Gameplay kombiniert. <br><a name="habracut"></a><br><h1>  Sandanalyse in Journey </h1><br>  Dieser Artikel basiert, wie viele andere Versuche, das Sand-Rendering von <em>Journey</em> nachzubilden, auf einem Bericht der GDC, den der leitende Ingenieur des Unternehmens, John Edwards, mit dem Titel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Sand-Rendering in Journey</a> " verfasst hat.  In diesem Vortrag spricht John Edwards √ºber alle Effektebenen, die <em>Journey zu</em> den Sandd√ºnen hinzugef√ºgt wurden, um den richtigen Look zu erzielen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wt2yYnBRD3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Der Bericht ist sehr n√ºtzlich, aber im Kontext dieses Tutorials sind viele der von John Edwards getroffenen Einschr√§nkungen und Entscheidungen nicht wichtig.  Wir werden versuchen, die Sand-Shader, die an den <em>Journey-</em> Shader erinnern, haupts√§chlich durch visuelle Referenzen nachzubilden. <br><br>  Beginnen wir mit einem einfachen 3D-Netz einer perfekt glatten D√ºne.  Die Glaubw√ºrdigkeit der Sandverarbeitung h√§ngt von zwei Aspekten ab: Beleuchtung und K√∂rnung.  Eine interessante M√∂glichkeit, das Licht von Sand zu reflektieren, bietet ein modifiziertes <strong>Beleuchtungsmodell</strong> .  Im Kontext der Shader-Codierung bestimmt das Beleuchtungsmodell Schatten und Lichter basierend auf den Eigenschaften des Modells und den Beleuchtungsbedingungen der Szene. <br><br>  All dies reicht jedoch nicht aus, um die Illusion eines Realismus zu erzeugen.  Das Problem ist, dass Sand einfach nicht mit flachen Oberfl√§chen modelliert werden kann.  Sandkorn sollte ber√ºcksichtigt werden.  Aus diesem Grund gibt es zwei separate Effekte, die direkt mit der <strong>Normalen auf der Oberfl√§che zusammenwirken</strong> und dazu verwendet werden k√∂nnen, kleine Sandpartikel auf der Oberfl√§che der D√ºne zu simulieren. <br><br>  Das folgende Diagramm zeigt alle Effekte, die wir in diesem Tutorial lernen werden.  Aus technischer Sicht werden normale Berechnungen durchgef√ºhrt, bevor die Beleuchtung verarbeitet wird.  Zur Erleichterung der Untersuchung werden die Wirkungen in einer anderen Reihenfolge beschrieben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/0b9/8a1/3730b98a1670ef00cf68efb0af0cc08b.png"></div><br><h6>  Diffuse Farbe </h6><br>  Der einfachste Sand Shader-Effekt ist seine <strong>diffuse Farbe</strong> , die grob die <em>matte</em> Komponente des Gesamterscheinungsbildes beschreibt.  Die diffuse Farbe wird basierend auf der <em>tats√§chlichen</em> Farbe des Objekts und den Lichtbedingungen berechnet.  Eine wei√üe Kugel ist nicht √ºberall perfekt wei√ü, da die diffuse Farbe vom einfallenden Licht abh√§ngt.  Diffuse Farben werden mithilfe eines mathematischen Modells berechnet, das die Reflexion von Licht von einer Oberfl√§che approximiert.  Dank eines Berichts von John Edwards mit der GDC kennen wir genau die verwendete Gleichung, die er <strong>diffuses Kontrastreflexionsverm√∂gen</strong> nennt;  es basiert auf dem bekannten <strong>Lambert-</strong> Modell der <strong>Reflexionen</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/509/4c1/65b/5094c165b5f2e1ba10696fec1641482c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br>  <i>Vor und nach der Anwendung der Gleichung</i> <br><br><h6>  Sand normal </h6><br>  Die urspr√ºngliche Geometrie ist v√∂llig glatt.  Um dies zu kompensieren, wird die <strong>Oberfl√§chennormale des</strong> Modells mit einer Technik namens <strong>Bump Mapping</strong> ge√§ndert.  Sie k√∂nnen eine Textur verwenden, um komplexere Geometrien zu simulieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><h6>  Kantenbeleuchtung </h6><br>  Jedes <em>Reise-</em> Level verwendet eine begrenzte Farbpalette.  Aus diesem Grund ist es ziemlich schwierig zu verstehen, wo eine D√ºne endet und eine andere beginnt.  Um die Lesbarkeit zu verbessern, wird die Technik der kleinen Hervorhebung des Sichtbaren nur entlang des D√ºnenrandes angewendet.  Es wird als <strong>Randbeleuchtung bezeichnet</strong> , und es gibt viele M√∂glichkeiten, dies umzusetzen.  F√ºr dieses Tutorial habe ich eine <strong>auf Fresnel-</strong> Reflexionen basierende Methode gew√§hlt, die Reflexionen auf polierten Oberfl√§chen unter sogenannten <em>Einfallswinkeln</em> modelliert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><h6>  Spiegelbild des Ozeans </h6><br>  Einer der unterhaltsamsten Aspekte <em>im</em> Gameplay von <em>Journey</em> ist das ‚ÄûSurfen‚Äú in den Sandd√ºnen.  Dies ist wahrscheinlich der Grund, warum die Spielefirma wollte, dass sich der Sand eher wie eine Fl√ºssigkeit als wie ein Feststoff anf√ºhlt.  Hierf√ºr wurde eine starke Reflexion verwendet, die h√§ufig in Wasserschattierungen zu finden ist.  John Edwards nennt diesen Effekt <strong>Ocean Specular</strong> , und im Tutorial implementieren wir ihn mithilfe der <strong>Blinn-Fong-Reflexion</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><h6>  Blendung Reflexion </h6><br>  Indem Sie dem Sand Shader eine ozeanische Spiegelkomponente hinzuf√ºgen, wirkt er fl√ºssiger.  Dennoch l√§sst sich einer der wichtigsten visuellen Aspekte des Sandes nicht vermitteln: zuf√§llig auftretende Reflexionen.  In echten D√ºnen tritt dieser Effekt auf, weil jedes Sandkorn Licht in seine Richtung reflektiert und sehr oft einer dieser reflektierten Strahlen in unser Auge gelangt.  Eine solche <strong>Glitzerreflexion</strong> (Reflexion von Reflexionen) tritt auch an Orten auf, an denen direktes Sonnenlicht nicht einf√§llt;  es erg√§nzt das ozeanische Spiegelbild und st√§rkt das Gef√ºhl der Glaubw√ºrdigkeit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><h6>  Sandwellen </h6><br>  Durch √Ñndern der Normalen konnten wir den Effekt kleiner Sandk√∂rner auf der D√ºnenoberfl√§che simulieren.  In den D√ºnen der realen Welt treten h√§ufig vom Wind verursachte Wellen auf.  Ihre Form variiert je nach Neigung und Position der D√ºnen im Verh√§ltnis zur Windrichtung.  M√∂glicherweise k√∂nnen solche Muster durch eine H√∂ckertextur erzeugt werden, aber in diesem Fall ist es unm√∂glich, die Form der D√ºnen in Echtzeit zu √§ndern.  Die von John Edwards vorgeschlagene L√∂sung √§hnelt einer Technik namens <strong>Triplanar Shading</strong> : Es werden vier verschiedene Texturen verwendet, die je nach Position und Neigung der D√ºnen gemischt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/828/9b4/997/8289b49971bbe0046845f71284790124.png"></div><br><h1>  Reise Sand Shader Anatomie </h1><br>  Unity bietet viele Shader-Vorlagen, mit denen Sie loslegen k√∂nnen.  Da wir an Materialien interessiert sind, die Licht empfangen und Schatten werfen k√∂nnen, m√ºssen wir mit dem <strong>Surface Shader</strong> (Surface Shader) beginnen. <br><br>  Alle <strong>Surface Shader</strong> werden in zwei Schritten ausgef√ºhrt.  Zun√§chst wird <strong>eine Oberfl√§chenfunktion</strong> aufgerufen, die die Eigenschaften der zu rendernden Oberfl√§che erfasst, z. B. <em>Albedo</em> , <em>Rauheit</em> , <em>Metalleigenschaften</em> , <em>Transparenz</em> und <em>Normalenrichtung</em> .  Dann werden alle diese Eigenschaften auf <strong>die Beleuchtungsfunktion √ºbertragen</strong> , die den Einfluss externer Lichtquellen ber√ºcksichtigt und die Verschattung und Beleuchtung berechnet. <br><br><h2>  Oberfl√§chenfunktion </h2><br>  Beginnen wir mit dem Kern unserer Oberfl√§chenfunktion, der im folgenden <code>surf</code> wird.  Die einzigen Eigenschaften, die wir einstellen m√ºssen, sind die <em>Farbe des Sandes</em> und die <strong>Normale zur Oberfl√§che</strong> .  Die Normale eines 3D-Modells ist ein Vektor, der die Position der Oberfl√§che angibt.  Normale Vektoren werden von der Beleuchtungsfunktion verwendet, um zu berechnen, wie Licht reflektiert wird.  Sie werden normalerweise beim Import des Netzes berechnet.  Sie k√∂nnen jedoch ge√§ndert werden, um eine komplexere Geometrie zu simulieren.  Hier verzerren die <strong>normalen Sand-</strong> und <strong>Sandwelleneffekte</strong> die Sandnorm, um ihre Rauheit zu simulieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); N = SandNormal (N); o.Normal = N; }</code> </pre> <br>  Wenn Sie Normalen nach <code>o.Normal</code> m√ºssen sie im <strong>Tangentialraum</strong> ausgedr√ºckt <strong>werden</strong> .  Dies bedeutet, dass der Vektor relativ zur Oberfl√§che des 3D-Modells ausgew√§hlt wird.  <code>float3(0, 0, 1)</code> bedeutet also, dass das normale 3D-Modell tats√§chlich nicht ge√§ndert wird. <br><br>  Beide Funktionen, <code>RipplesNormal</code> und <code>SandNormal</code> empfangen den normalen Vektor und modifizieren ihn.  Wie das geht, werden wir sp√§ter sehen. <br><br><h2>  Beleuchtung funktion </h2><br>  In der Beleuchtungsfunktion werden alle anderen Effekte implementiert.  Der folgende Code zeigt, wie jede einzelne Komponente in separaten Funktionen berechnet wird (diffuse Farbe, Randbeleuchtung, Ozeanspiegelung und Glitzerreflexion).  Dann werden sie alle kombiniert. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Journey fullforwardshadows float4 LightingJourney (SurfaceOutput s, fixed3 viewDir, UnityGI gi) { float3 diffuseColor = DiffuseColor (); float3 rimColor = RimLighting (); float3 oceanColor = OceanSpecular (); float3 glitterColor = GlitterSpecular (); float3 specularColor = saturate(max(rimColor, oceanColor)); float3 color = diffuseColor + specularColor + glitterColor; return float4(color * s.Albedo, 1); }</span></span></code> </pre> <br>  Die Methode zum Kombinieren von Komponenten ist ziemlich willk√ºrlich und erm√∂glicht es uns, sie zu √§ndern, um die k√ºnstlerischen M√∂glichkeiten zu untersuchen. <br><br>  Typischerweise stapeln sich Spiegelreflexionen √ºber diffuse Farben.  Da wir hier nicht eine, sondern drei Spiegelreflexionen haben ( <em>Randlicht</em> , <em>Ozeanspiegel</em> und <em>Glitzerspiegel</em> ), m√ºssen wir vorsichtiger sein, damit der Sand nicht <em>zu</em> flackert.  Da Rim Light und Ocean Specular Teil desselben Effekts sind, k√∂nnen wir nur den Maximalwert ausw√§hlen.  Glitzerspiegel werden separat hinzugef√ºgt, da diese Komponente flackernden Sand erzeugt. <br><br><h2>  Teil 2. Diffuse Farbe </h2><br>  Im zweiten Teil des Beitrags konzentrieren wir uns auf das im Spiel verwendete Beleuchtungsmodell und darauf.  Wie erstelle ich es in Unity neu? <br><br>  Im vorigen Teil haben wir den Grundstein daf√ºr gelegt, was sich allm√§hlich in unsere Version des Sandshaders Journey verwandeln wird.  Wie bereits erw√§hnt, wird <strong>die Beleuchtungsfunktion</strong> in <strong>Oberfl√§chen-Shadern verwendet</strong> , um den Effekt der Beleuchtung zu berechnen, sodass Schatten und Lichter auf der Oberfl√§che erscheinen.  Wir haben herausgefunden, dass Journey mehrere Effekte hat, die in diese Kategorie fallen.  Wir werden mit dem grundlegendsten (und einfachsten) Effekt beginnen, der im Kern dieses Shaders zu finden ist: seiner <strong>diffusen Beleuchtung</strong> (diffuse / diffuse Beleuchtung). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78f/166/71c/78f16671c754f05e619ce034fad81926.png"></div><br>  Im Moment lassen wir alle anderen Effekte und Komponenten aus und konzentrieren uns auf das <strong>Beleuchten des Sandes</strong> . <br><br>  Die Beleuchtungsfunktion, die wir im vorherigen Teil des Beitrags mit dem Namen <code>LightingJourney</code> , delegiert die Berechnung der diffusen Farbe von Sand einfach an eine Funktion mit dem Namen <code>DiffuseColor</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightingJourney</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SurfaceOutput s, fixed3 viewDir, UnityGI gi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Lighting properties float3 L = gi.light.dir; float3 N = s.Normal; // Lighting calculation float3 diffuseColor = DiffuseColor(N, L); // Final color return float4(diffuseColor, 1); }</span></span></code> </pre> <br>  Da jeder Effekt in sich geschlossen und in seiner eigenen Funktion gespeichert ist, ist unser Code modularer und √ºbersichtlicher. <br><br><h2>  Lambert-Reflexion </h2><br>  Bevor Sie diffuses Licht ‚Äûwie in Journey‚Äú erstellen, sollten Sie sich ansehen, wie die ‚Äûgrundlegende‚Äú Funktion f√ºr diffuses Licht aussieht.  Die einfachste Schattierungstechnik f√ºr matte Materialien hei√üt <strong>Lambertsches Reflexionsverm√∂gen</strong> .  Dieses Modell entspricht in etwa dem Aussehen der meisten nicht gl√§nzenden und nicht metallischen Oberfl√§chen.  Es ist nach dem Schweizer Enzyklop√§disten <strong>Johann Heinrich Lambert benannt</strong> , der sein Konzept 1760 vorschlug. <br><br>  Lamberts Reflexionskonzept basiert auf einer einfachen Idee: Die <em>Helligkeit einer Oberfl√§che h√§ngt von der Menge des auf sie einfallenden Lichts ab</em> .  Geometrisch kann dies in der folgenden Abbildung gezeigt werden, in der die Kugel von einer entfernten Lichtquelle beleuchtet wird.  Obwohl die roten und gr√ºnen Bereiche der Kugel gleich stark beleuchtet werden, unterscheiden sich ihre Oberfl√§chen erheblich.  Wenn das Licht im roten Bereich √ºber eine gr√∂√üere Fl√§che verteilt ist, bedeutet dies, dass jede Einheit des roten Quadrats weniger Licht als gr√ºn empf√§ngt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/d48/495/2cfd484953877a47fe5ba564b399ea35.png"></div><br>  Theoretisch h√§ngt die Lambert-Reflexion vom relativen Winkel zwischen der <em>Oberfl√§che</em> und dem <em>einfallenden Licht ab</em> .  Aus mathematischer Sicht ist dies eine Funktion von der <strong>Normalen zur Oberfl√§che</strong> und der <strong>Beleuchtungsrichtung</strong> .  Diese Gr√∂√üen werden unter Verwendung von zwei Einheitsl√§ngenvektoren ( <strong>Einheitsvektoren genannt</strong> ) ausgedr√ºckt. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> N </script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> L </script>  .  Einzelne Vektoren sind eine Standardmethode, um <em>Richtungen</em> im Kontext der Shader-Codierung anzugeben. <br><br><div class="spoiler">  <b class="spoiler_title">Der Wert von N und L</b> <div class="spoiler_text">  <strong>Normal</strong> zur Oberfl√§che <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.074ex" viewBox="0 -772.3 888.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> N </script>  Ist ein Einheitsvektor, der <em>von</em> der Oberfl√§che selbst <em>weg</em> gerichtet ist. <br><br>  Analog k√∂nnen wir davon ausgehen, dass die <strong>Richtung der Beleuchtung</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.074ex" viewBox="0 -772.3 681.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> L </script>  zeigt <em>von der</em> Lichtquelle und folgt in die Richtung, in die sich das Licht bewegt.  Dies ist jedoch nicht der Fall: Die Beleuchtungsrichtung ist ein einzelner Vektor, der <em>in die</em> Richtung zeigt, aus der das Licht kam. <br><br>  Dies kann verwirrend sein, insbesondere wenn Sie mit dem Erstellen von Shadern noch nicht vertraut sind.  Dank dieser Notation werden Gleichungen jedoch einfacher. </div></div><br><div class="spoiler">  <b class="spoiler_title">Lambert-Spiegelbild in der Einheit</b> <div class="spoiler_text">  Vor Unity 5 <strong>Standard Shader</strong> war die Lambert-Reflexion das Standardmodell f√ºr das Abschatten beleuchteter Oberfl√§chen. <br><br>  Sie k√∂nnen weiterhin im Materialinspektor darauf zugreifen: Im <em>Legacy-Shader hei√üt</em> es <em>Diffuse</em> . <br><br>  Wenn Sie Ihren eigenen Oberfl√§chen-Shader schreiben, steht die Lambert-Reflexion als Beleuchtungsfunktion mit dem Namen <code>Lambert</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Lambert fullforwardshadows</span></span></code> </pre> <br>  Ihre Implementierung finden Sie in der <code>LightingLambert</code> Funktion, die in der Datei <code>CGIncludes\Lighting.cginc</code> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Lambert Reflexion und Klima</b> <div class="spoiler_text">  Lambert-Reflexion ist ein relativ altes Modell, bietet jedoch ein Verst√§ndnis f√ºr komplexe Konzepte wie Oberfl√§chenschattierung.  Es kann auch verwendet werden, um viele andere Ph√§nomene zu erkl√§ren.  Zum Beispiel erkl√§rt dasselbe Diagramm, warum es an den Polen des Planeten k√§lter ist als am √Ñquator. </div></div><br>  Bei genauerer Betrachtung k√∂nnen wir feststellen, dass die Oberfl√§che die maximale Beleuchtungsst√§rke erh√§lt, wenn ihre Normale parallel zur Beleuchtungsrichtung verl√§uft.  Und umgekehrt: Es gibt kein Licht, wenn zwei Einheitsvektoren senkrecht zueinander stehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e1/d06/6c6/0e1d066c6ff998abda8ca5c7607e4c4e.png"></div><br>  Offensichtlich ist der Winkel zwischen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> N </script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> L </script>  kritisch f√ºr die Reflexion nach Lambert.  Dar√ºber hinaus ist die Helligkeit maximal und gleich <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14">100</span><span class="MJXp-mi" id="MJXp-Span-15">%</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.423ex" height="2.298ex" viewBox="0 -832 2335 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-25" x="1501" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> 100 \% </script>  wenn der Winkel ist <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-16"><span class="MJXp-mn" id="MJXp-Span-17">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-30" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> 0 </script>  und minimal ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-18"><span class="MJXp-mn" id="MJXp-Span-19">0</span><span class="MJXp-mi" id="MJXp-Span-20">%</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.098ex" height="2.298ex" viewBox="0 -832 1334 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-30" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-25" x="500" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9"> 0 \% </script>  ), wenn der Winkel dazu neigt <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-msubsup" id="MJXp-Span-22"><span class="MJXp-mn" id="MJXp-Span-23" style="margin-right: 0.05em;">90</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-24" style="vertical-align: 0.5em;"><span class="MJXp-mtext" id="MJXp-Span-25">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">c</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.871ex" height="2.419ex" viewBox="0 -935.7 2527.6 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-39"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-30" x="500" y="0"></use><g transform="translate(1001,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-63" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-69" x="787" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-72" x="1132" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-63" x="1584" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-10"> 90 ^ {\ circ} </script>  .  Wenn Sie mit der <em>Vektoralgebra</em> vertraut sind, k√∂nnen Sie verstehen, dass eine Gr√∂√üe Lamberts Reflexion darstellt <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">I</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.172ex" height="2.057ex" viewBox="0 -780.1 504.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-49" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-11"> I </script>  ist gleich <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-32"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">N</span><span class="MJXp-mtext" id="MJXp-Span-34">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.417ex" height="2.057ex" viewBox="0 -780.1 3624 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-63" x="1138" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-64" x="1572" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-6F" x="2095" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-74" x="2581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4C" x="2942" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-12"> N \ cdot L </script>  Wo ist der Betreiber? <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="MJXp-mtext" id="MJXp-Span-41">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> \ cdot </script>  <strong>Skalarprodukt genannt</strong> . <br><br>  (1) <p><math> </math> $$ display $$ \ begin {equation *} I = N \ cdot L \ end {equation *} $$ display $$ </p><br>  Das Skalarprodukt ist ein Ma√ü f√ºr die "√úbereinstimmung" zweier Vektoren relativ zueinander und variiert im Intervall von <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-52"><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-54">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> + 1 </script>  (f√ºr zwei identische Vektoren) bis <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-55"><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0em; margin-right: 0.111em;">‚àí</span><span class="MJXp-mn" id="MJXp-Span-57">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> -1 </script>  (f√ºr zwei entgegengesetzte Vektoren).  Ein Skalarprodukt ist die Grundlage f√ºr die Schattierung, die ich im Tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Physikalisch basiertes Rendern und Beleuchtungsmodelle</a> ausf√ºhrlich untersucht habe. <br><br><h3>  Implementierung </h3><br>  Und zu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-58"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> N </script>  und zu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> L </script>  Sie k√∂nnen leicht auf die Surface Shader-Beleuchtungsfunktionen √ºber <code>s.Normal</code> und <code>gi.light.dirin</code> .  Der Einfachheit halber werden wir sie im Shader-Code in <code>N</code> und <code>L</code> umbenennen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate( dot(N, L) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  <code>saturate</code> begrenzt den Wert von <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mn" id="MJXp-Span-63">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> 0 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mn" id="MJXp-Span-65">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> 1 </script>  .  Da sich das Skalarprodukt jedoch im Bereich von <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0.111em;">‚àí</span><span class="MJXp-mn" id="MJXp-Span-68">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> -1 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mo" id="MJXp-Span-70" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-71">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> + 1 </script>  Wir m√ºssen nur mit den negativen Werten arbeiten.  Aus diesem Grund wird die Lambert-Reflexion h√§ufig wie folgt implementiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, L) );</code> </pre> <br><h2>  Kontrastreflexion des Umgebungslichts </h2><br>  Obwohl Lamberts Reflexion die meisten Materialien gut abschattet, ist sie weder physikalisch genau noch fotorealistisch.  In √§lteren Spielen wurden Lambert-Shader h√§ufig verwendet.  Spiele, die diese Technik verwenden, <em>scheinen</em> oft alt zu sein, weil sie versehentlich die √Ñsthetik alter Spiele reproduzieren k√∂nnen.  Wenn Sie dies nicht anstreben, sollten Sie Lambert-Reflexionen vermeiden und modernere Technologien verwenden. <br><br>  Ein solches Modell ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">das Oren-Nayyar-Reflexionsmodell</a> , das urspr√ºnglich in dem 1994 von Michael Oren und Sri C. Nayyar ver√∂ffentlichten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Generalization of Lambert's Reflectance Model beschrieben</a> wurde.  Das Oren-Nayyar-Modell ist eine Verallgemeinerung der Lambert-Reflexion und wurde speziell f√ºr raue Oberfl√§chen entwickelt.  Anf√§nglich wollten die Entwickler von Journey die Oren-Nayyar-Reflexion als Grundlage f√ºr ihren Sandshader verwenden.  Diese Idee wurde jedoch aufgrund der hohen Rechenkosten aufgegeben. <br><br>  In seinem Bericht von 2013 erkl√§rt der technische K√ºnstler John Edwards, dass das f√ºr den Sand Journey erstellte Reflexionsmodell auf einer Reihe von Versuchen und Irrt√ºmern basiert. Die Entwickler wollten nicht die fotorealistische Wiedergabe der W√ºste nachbilden, sondern einer konkreten, sofort erkennbaren √Ñsthetik Leben einhauchen. <br><br>  Das resultierende Schattierungsmodell entspricht seiner Meinung nach dieser Gleichung: <br><br>  (2) <p><math> </math> $$ display $$ \ begin {equation *} I = 4 * \ left (\ left (N \ odot \ left [1, 0.3, 1 \ right] \ right) \ cdot L \ right) \ end {equation *} $$ display $$ </p><br>  wo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mtext" id="MJXp-Span-96">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> \ odot </script>  - <strong>Elementweises Produkt</strong> zweier Vektoren. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  Reflexionsmodell (2) Da John Edwards <strong>diffusen Kontrast</strong> nennt, werden wir diesen Namen im gesamten Lernprogramm verwenden. <br><br>  Die Animation unten zeigt den Unterschied zwischen Lambert-Schattierung (links) und diffusem Kontrast gegen√ºber Journey (rechts). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q-hQiDA71Yg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">Was ist die Bedeutung von 4 und 0,3?</b> <div class="spoiler_text">  Obwohl der diffuse Kontrast nicht auf physikalische Genauigkeit ausgelegt ist, k√∂nnen wir dennoch versuchen zu verstehen, was er bewirkt. <br><br>  Im Kern wird immer noch Lambert-Reflexion verwendet.  Der erste offensichtliche Unterschied ist, dass das Gesamtergebnis mit multipliziert wird <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mn" id="MJXp-Span-102"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><script type="math/tex" id="MathJax-Element-25"> 4 </script>  .  Dies bedeutet, dass alle Pixel, die normalerweise empfangen wurden <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-103"><span class="MJXp-mn" id="MJXp-Span-104"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25 </font></font></span><span class="MJXp-mi" id="MJXp-Span-105"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></span></span></span><script type="math/tex" id="MathJax-Element-26"> 25 \% </script>  Die Beleuchtung leuchtet jetzt wie beim Empfang <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-106"><span class="MJXp-mn" id="MJXp-Span-107"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100 </font></font></span><span class="MJXp-mi" id="MJXp-Span-108"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></span></span></span><script type="math/tex" id="MathJax-Element-27"> 100 \% </script>  beleuchtung.  Indem man alles mit multipliziert <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-mn" id="MJXp-Span-110"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><script type="math/tex" id="MathJax-Element-28"> 4 </script>  Eine schwache Schattierung nach Lambert wird viel st√§rker und der √úbergangsbereich zwischen Dunkelheit und Licht ist kleiner.  In diesem Fall wird der Schatten sch√§rfer. <br><br>  Auswirkung der Multiplikation der <code>y</code> Komponente auf die Normalenrichtung <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-111"><span class="MJXp-mn" id="MJXp-Span-112"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,3</font></font></span></span></span><script type="math/tex" id="MathJax-Element-29"> 0.3 </script>  erkl√§ren ist viel schwieriger.  Wenn sich die Komponenten des Vektors √§ndern, √§ndert sich die allgemeine Richtung, in die er zeigt.  Reduzieren Sie den Wert der <code>y</code> Komponente auf alles <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-113"><span class="MJXp-mn" id="MJXp-Span-114"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30 </font></font></span><span class="MJXp-mi" id="MJXp-Span-115"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></span></span></span><script type="math/tex" id="MathJax-Element-30"> 30 \% </script>  Die Reflexion des diffusen Kontrasts bewirkt, dass die Schatten vom urspr√ºnglichen Wert vertikaler werden. <br><br>  Hinweis: Ein Skalarprodukt misst den Winkel zwischen zwei Vektoren nur dann direkt, wenn beide eine L√§nge haben <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-116"><span class="MJXp-mn" id="MJXp-Span-117"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-31"> 1 </script>  .  Die vorgenommene √Ñnderung verringert die normale L√§nge <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-118"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><script type="math/tex" id="MathJax-Element-32"> N </script>  Das ist kein Einheitsvektor mehr. </div></div><br><h2>  Von Graut√∂nen zu Farbe </h2><br>  Alle oben gezeigten Animationen haben Graustufen, da sie die Werte ihres Reflexionsmodells anzeigen, die im Intervall von variieren <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-120"><span class="MJXp-mn" id="MJXp-Span-121">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> 0 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-122"><span class="MJXp-mn" id="MJXp-Span-123">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> 1 </script>  ". Wir k√∂nnen einfach Farben hinzuf√ºgen, indem <code>NdotL</code> als Interpolationskoeffizienten zwischen zwei Farben verwenden: eine f√ºr vollst√§ndig schattierten und eine f√ºr vollst√§ndig beleuchteten Sand. <br><br><pre> <code class="cpp hljs">float3 _TerrainColor; float3 _ShadowColor; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); float3 color = lerp(_ShadowColor, _TerrainColor, NdotL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; }</code> </pre> <br><h2>  Teil 3. Normaler Sand </h2><br>  Im dritten Teil werden wir uns auf die Erstellung normaler Karten konzentrieren, die glatte 3D-Modelle in Sandd√ºnen verwandeln. <br><br>  Im vorherigen Teil des Tutorials haben wir die diffuse Beleuchtung von Journey Sand implementiert.  Wenn Sie nur diesen Effekt verwenden, wirken die W√ºstend√ºnen eher flach und langweilig. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cb/dd6/9a8/8cbdd69a8a92614469132400c0979c79.png"></div><br>  Einer der faszinierendsten Effekte von Journey ist die K√∂rnigkeit des Sandes.  Wenn wir uns einen Screenshot ansehen, sehen wir, dass die D√ºnen nicht glatt und homogen sind, sondern aus Millionen mikroskopisch kleinen Sandk√∂rnern bestehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e93/307/efc/e93307efce359d4830f5894dde30c9e6.jpg"></div><br>  Dieser Effekt kann mit einer Technik namens <strong>Bump Mapping</strong> erzielt werden, bei der Licht von einer ebenen Oberfl√§che reflektiert wird, als w√§re es komplexer.  Sehen Sie, wie dieser Effekt das Erscheinungsbild des Renderings √§ndert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br>  Kleine Unterschiede zeigen sich mit zunehmender: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3d5/b3f/ea73d5b3fb56c941c9b61f022dcb8699.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f8/efa/5c4/2f8efa5c4926a0de947b8ff91e114498.png"></div><br><h2>  Wir besch√§ftigen uns mit normalen Karten </h2><br>  Sand besteht aus unz√§hligen Sandk√∂rnern, von denen jedes seine eigene Form und Zusammensetzung hat (siehe unten).  Jedes einzelne Partikel reflektiert das Licht in eine m√∂glicherweise zuf√§llige Richtung.  Ein Weg, diesen Effekt zu realisieren, besteht darin, ein 3D-Modell zu erstellen, das all diese mikroskopischen Sandk√∂rner enth√§lt.  Aufgrund der unglaublichen Anzahl erforderlicher Polygone ist dieser Ansatz jedoch nicht durchf√ºhrbar. <br><br>  Es gibt jedoch eine andere L√∂sung, mit der h√§ufig eine komplexere Geometrie im Vergleich zu einem echten 3D-Modell simuliert wird.  Jeder Scheitelpunkt oder jede Fl√§che des 3D-Modells ist einem Parameter zugeordnet, der als <strong>Normalenrichtung bezeichnet wird</strong> .  Dies ist ein L√§ngeneinheitsvektor, der zur Berechnung der Lichtreflexion auf der Oberfl√§che eines 3D-Modells verwendet wird.  Das hei√üt, um Sand zu simulieren, m√ºssen Sie diese scheinbar zuf√§llige Verteilung der Sandk√∂rner simulieren und damit, wie sie die Oberfl√§chennormalen beeinflussen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/bc4/cc3/413bc4cc3466b827a1a1d86559d54054.jpg"></div><br>  Dies kann auf unz√§hlige Arten geschehen.  Am einfachsten ist es, eine Textur zu erstellen, die die Richtung der urspr√ºnglichen Normalen des D√ºnenmodells √§ndert. <br><br>  <strong>Normal zur Oberfl√§che</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-124"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-125">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> N </script>  im allgemeinen Fall wird es anhand der Geometrie des 3D-Modells berechnet.  Sie k√∂nnen es jedoch mit der <strong>normalen Karte</strong> √§ndern.  Normale Karten sind Texturen, mit denen Sie komplexere Geometrien simulieren k√∂nnen, indem Sie die lokale Ausrichtung der Normalen zur Oberfl√§che √§ndern.  Diese Technik wird oft als <strong>Bump-Mapping bezeichnet</strong> . <br><br>  Das √Ñndern der Normalen ist eine relativ einfache Aufgabe, die in der <code>surf</code> Funktion des <strong>Surface Shader ausgef√ºhrt werden kann</strong> .  Diese Funktion <code>SurfaceOutput</code> zwei Parameter, von denen einer eine <code>struct</code> namens <code>SurfaceOutput</code> .  Es enth√§lt alle Eigenschaften, die zum Rendern eines Teils eines 3D-Modells erforderlich sind, von der Farbe ( <code>o.Albedo</code> ) bis zur Transparenz ( <code>o.Alpha</code> ).  Ein weiterer Parameter, den es enth√§lt, ist die Normalenrichtung ( <code>o.Normal</code> ), die umgeschrieben werden kann, um die Art und Weise zu √§ndern, in der Licht auf das Modell reflektiert wird. <br><br>  Gem√§√ü der Unity-Dokumentation zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Surface Shadern</a> m√ºssen alle Normalen, die in die <code>o.Normal</code> Struktur geschrieben werden, im <strong>Tangentialraum</strong> ausgedr√ºckt <strong>werden</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SurfaceOutput</span></span></span><span class="hljs-class"> {</span></span> fixed3 Albedo; <span class="hljs-comment"><span class="hljs-comment">// diffuse color fixed3 Normal; // tangent space normal, if written fixed3 Emission; half Specular; // specular power in 0..1 range fixed Gloss; // specular intensity fixed Alpha; // alpha for transparencies };</span></span></code> </pre> <br>  Somit k√∂nnen wir berichten, dass Einheitsvektoren im Koordinatensystem relativ zur Netznormalen ausgedr√ºckt werden m√ºssen.  Wenn Sie beispielsweise in <code>o.Normal</code> schreiben, <code>o.Normal</code> Werte von <code>float3(0, 0, 1)</code> normal unver√§ndert. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Dies liegt daran, dass der Vektor <code>float3(0, 0, 1)</code> tats√§chlich ein normaler Vektor ist, der relativ zur Geometrie des 3D-Modells ausgedr√ºckt wird. <br><br>  <code>o.Normal</code> die Normalen zur Oberfl√§che im <strong>Oberfl√§chen-Shader</strong> zu √§ndern, m√ºssen wir in <code>o.Normal</code> nur einen neuen Vektor in <strong>die Oberfl√§chenfunktion</strong> <code>o.Normal</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = ... <span class="hljs-comment"><span class="hljs-comment">// change the normal here }</span></span></code> </pre> <br>  Im Rest des Beitrags werden wir die anf√§ngliche Ann√§herung erstellen, die wir im sechsten Teil des Tutorials verkomplizieren werden. <br><br><h2>  Sand normal </h2><br>  Am problematischsten ist es zu verstehen, <em>wie sich die</em> Sandk√∂rner normal zur Oberfl√§che ver√§ndern.  Obwohl jedes Sandkorn einzeln Licht in jede Richtung streuen kann, passiert im Gro√üen und Ganzen etwas anderes.  Jeder physikalisch genaue Ansatz sollte die Verteilung normaler Vektoren auf der Sandoberfl√§che untersuchen und mathematisch modellieren.  Solche Modelle gibt es tats√§chlich, aber die in unserem Tutorial vorgestellte L√∂sung ist viel einfacher und gleichzeitig sehr effektiv. <br><br>  An jedem Punkt im Modell wird ein <strong>zuf√§lliger Einheitsvektor</strong> aus der Textur abgetastet.  Dann neigt sich die Normale zur Oberfl√§che um einen bestimmten Betrag in Richtung dieses Vektors.  Mit der richtigen Erzeugung einer zuf√§lligen Textur und der Auswahl einer geeigneten Menge an Mischung k√∂nnen wir die Normale so zur Oberfl√§che verschieben, dass ein Gef√ºhl der K√∂rnigkeit entsteht, ohne die Gesamtkr√ºmmung der D√ºnen zu verlieren. <br><br>  Zuf√§llige Werte k√∂nnen mit einer Textur aus zuf√§lligen Farben abgetastet werden.  Die Komponenten R, G und B jedes Pixels werden als Komponenten X, Y und Z des Normalenvektors verwendet.  Farbkomponenten sind im Sortiment <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-126"><span class="MJXp-mtext" id="MJXp-Span-127">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">t</span><span class="MJXp-mo" id="MJXp-Span-132" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mn" id="MJXp-Span-133">0</span><span class="MJXp-mo" id="MJXp-Span-134" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-135">1</span><span class="MJXp-mtext" id="MJXp-Span-136">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-137">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-138">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-139">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-140">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-141">t</span><span class="MJXp-mo" id="MJXp-Span-142" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> \ left [0, 1 \ right] </script>  Sie m√ºssen also in ein Intervall konvertiert werden <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-143"><span class="MJXp-mtext" id="MJXp-Span-144">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-147">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148">t</span><span class="MJXp-mo" id="MJXp-Span-149" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mo" id="MJXp-Span-150" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mn" id="MJXp-Span-151">1</span><span class="MJXp-mo" id="MJXp-Span-152" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-153" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-154">1</span><span class="MJXp-mtext" id="MJXp-Span-155">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-156">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-157">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-158">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-159">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-160">t</span><span class="MJXp-mo" id="MJXp-Span-161" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> \ left [-1, + 1 \ right] </script>  .  Dann wird der resultierende Vektor normalisiert, so dass seine L√§nge gleich ist <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-162"><span class="MJXp-mn" id="MJXp-Span-163">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> 1 </script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d2/c95/03d/0d2c9503d98fd2463e7e3682743736bd.png"></div><br><div class="spoiler">  <b class="spoiler_title">Erstelle zuf√§llige Texturen</b> <div class="spoiler_text">  Es gibt viele M√∂glichkeiten, zuf√§llige Texturen zu erzeugen.  Um den gew√ºnschten Effekt zu erzielen, ist die allgemeine Verteilung der Zufallsvektoren, die aus der Textur abgetastet werden k√∂nnen, das Wichtigste. <br><br>  Im obigen Bild ist jedes Pixel v√∂llig zuf√§llig.  Es gibt keine allgemeine Richtung (Farbe) in der Textur, da jeder Wert dieselbe Wahrscheinlichkeit hat wie alle anderen.  Diese Textur gibt uns eine Art Sand, der Licht in alle Richtungen streut. <br><br>  W√§hrend eines GDC-Vortrags machte John Edwards klar, dass die zuf√§llige Textur, die f√ºr den Sand in Journey verwendet wurde, aus einer Gau√üschen Verteilung generiert wurde.  Dies stellt sicher, dass die vorherrschende Richtung mit der Normalen auf der Oberfl√§che √ºbereinstimmt. </div></div><br><div class="spoiler">  <b class="spoiler_title">M√ºssen zuf√§llige Vektoren normalisiert werden?</b> <div class="spoiler_text">  Das Bild, mit dem ich Zufallsvektoren abgetastet habe, wurde nach einem v√∂llig zuf√§lligen Verfahren erzeugt.  Nicht nur jedes Pixel wird einzeln erzeugt: Die Komponenten R, G und B eines Pixels sind auch unabh√§ngig voneinander.  Das hei√üt, im allgemeinen Fall wird f√ºr die aus dieser Textur abgetasteten Vektoren nicht garantiert, dass sie eine L√§nge von gleich haben <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-164"><span class="MJXp-mn" id="MJXp-Span-165"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-39"> 1 </script>  . <br><br>  Nat√ºrlich k√∂nnen Sie eine Textur erzeugen, bei der jedes Pixel beim Konvertieren aus <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-166"><span class="MJXp-mtext" id="MJXp-Span-167">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-169"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-171"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-172" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mn" id="MJXp-Span-173"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-174" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-175"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-178"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179"><font style="vertical-align: inherit;">g </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-180"><font style="vertical-align: inherit;">h </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-181"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mo" id="MJXp-Span-182" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;">]</font></span></font><span class="MJXp-mtext" id="MJXp-Span-176">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-178"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-180"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-181"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-182" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"></font></span></span></span><script type="math/tex" id="MathJax-Element-40"> \ left [0, 1 \ right] </script>  in <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-183"><span class="MJXp-mtext" id="MJXp-Span-184">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-185"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-186"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-188"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-189" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mo" id="MJXp-Span-190" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-191"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-192" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mo" id="MJXp-Span-193" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-194"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-196"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-197"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198"><font style="vertical-align: inherit;">g </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-199"><font style="vertical-align: inherit;">h </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-200"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mo" id="MJXp-Span-201" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;">]</font></span></font><span class="MJXp-mtext" id="MJXp-Span-195">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-196"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-197"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-199"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-200"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-201" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"></font></span></span></span><script type="math/tex" id="MathJax-Element-41"> \ left [-1, + 1 \ right] </script>  und in der Tat muss eine L√§nge haben <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-202"><span class="MJXp-mn" id="MJXp-Span-203"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-42"> 1 </script>  .  Hierbei treten jedoch zwei Probleme auf. <br><br> ,             . -,    <em> </em>   mip-,             . <br><br>   ,    . </div></div><br><h2>  Implementierung </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Teil des Tutorials haben wir das Konzept der ‚Äûnormalen Karten‚Äú kennengelernt, als es in der allerersten Gliederung </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Oberfl√§chenfunktion</font></font></strong> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auftauchte </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn Sie sich an das Diagramm am Anfang des Artikels erinnern, sehen Sie, dass zwei Effekte erforderlich sind, um das Rendern von Journey Sand wiederherzustellen. Die erste ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sandnormalen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die wir in diesem Teil des Artikels betrachten, und die zweite ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sandwellen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) werden wir im sechsten Teil untersuchen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); <span class="hljs-comment"><span class="hljs-comment">// Covered in Journey Sand Shader #6 N = SandNormal (N); // Covered in this article o.Normal = N; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Abschnitt haben wir das Konzept des Bump-Mappings eingef√ºhrt, das uns gezeigt hat, dass f√ºr einen Teil des Effekts die Textur abgetastet werden muss (dies wird im Code aufgerufen </font></font><code>uv_SandTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem mit dem obigen Code ist, dass Sie f√ºr Berechnungen die wahre Position des Punktes kennen m√ºssen, den wir zeichnen. Tats√§chlich ben√∂tigen Sie eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV-Koordinate</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Textur abzutasten </font><font style="vertical-align: inherit;">, die bestimmt, von welchem ‚Äã‚ÄãPixel gelesen werden soll. Wenn das von uns verwendete 3D-Modell relativ flach ist und eine UV-Umwandlung aufweist, k√∂nnen wir seine UV-Strahlung verwenden, um eine zuf√§llige Textur abzutasten.</font></font><br><br><pre> <code class="cpp hljs">N = WavesNormal(IN.uv_SandTex.xy, N); N = SandNormal (IN.uv_SandTex.xy, N);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativ k√∂nnen Sie auch die Position </font></font><code>IN.worldPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des gerenderten Punkts </font><font style="vertical-align: inherit;">in der Welt ( </font><font style="vertical-align: inherit;">) verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt k√∂nnen wir uns endlich auf </font></font><code>SandNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Umsetzung konzentrieren. </font><font style="vertical-align: inherit;">Wie bereits erw√§hnt, besteht die Idee darin, ein Pixel aus einer zuf√§lligen Textur abzutasten und es (nach der Konvertierung in einen Einheitsvektor) als neue Norm zu verwenden.</font></font><br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie zoome ich zuf√§llige Textur?</font></font></b> <div class="spoiler_text">    UV- 3D-      ,   .      ,       . <br><br>   ,  Unity   .   ,        <code>_SandText_ST</code> . Unity       (  ) <code>_SandTex</code> . <br><br>  <code>_SandText_ST</code>    :     .        ,          <em>Tiling</em>  <em>Offset</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/a84/059/f29a84059ab970f412217f09c87fcf6f.png"></div><br>       ,     <code>TRANSFORM_TEX</code> : <br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; float4 _SandTex_ST; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, TRANSFORM_TEX(uv, _SandTex)).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kippen Sie die Normalen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das oben gezeigte Code-Snippet funktioniert, f√ºhrt aber nicht zu sehr guten Ergebnissen. Der Grund daf√ºr ist einfach: Wenn wir nur eine v√∂llig zuf√§llige Norm zur√ºckgeben, aber im Wesentlichen das Gef√ºhl der Kr√ºmmung verlieren. Tats√§chlich wird die Richtung der Normalen verwendet, um zu berechnen, wie Licht von der Oberfl√§che reflektiert werden soll, und der Hauptzweck besteht darin, das Modell entsprechend seiner Kr√ºmmung zu schattieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Unterschied ist in den folgenden Bildern zu sehen. Oben sind die Normalen der D√ºnen v√∂llig zuf√§llig und es ist unm√∂glich zu verstehen, wo eine endet und eine andere beginnt. Von unten wird nur die Normale des Modells verwendet, wodurch wir eine zu glatte Oberfl√§che erhalten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/9cb/acb/6209cbacb616db15bee5f95e314779c8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/476/f0a/f25/476f0af2535dc2d552ce4b01a1d7751a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide L√∂sungen passen nicht zu uns. </font><font style="vertical-align: inherit;">Wir brauchen etwas dazwischen. </font><font style="vertical-align: inherit;">Eine zuf√§llige Richtung, die aus einer Textur abgetastet wurde, sollte verwendet werden, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um die</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normale um einen bestimmten Betrag </font><font style="vertical-align: inherit;">zu </font><em><font style="vertical-align: inherit;">neigen</font></em><font style="vertical-align: inherit;"> , wie unten gezeigt:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/929/dfb/7e6/929dfb7e6d4712b7c69a403d0733c25b.png" width="239" height="240"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die im Diagramm beschriebene Operation hei√üt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slerp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und steht f√ºr </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sph√§rische lineare Interpolation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (sph√§rische lineare Interpolation). </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slerp</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktioniert mit einer Ausnahme genauso wie lerp - es kann verwendet werden, um sicher zwischen Einheitsvektoren zu interpolieren, und das Ergebnis der Operation sind andere Einheitsvektoren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider ist die korrekte Implementierung von slerp ziemlich teuer. </font><font style="vertical-align: inherit;">Und f√ºr einen Effekt, der zumindest zuf√§llig ist, ist es unlogisch, ihn zu verwenden.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigen Sie mir die Slerp-Gleichung</font></font></b> <div class="spoiler_text">    , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-204"><span class="MJXp-msubsup" id="MJXp-Span-205"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-206" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-207" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-43">p_0</script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-208"><span class="MJXp-msubsup" id="MJXp-Span-209"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-210" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-211" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-44">p_1</script>   ,       .  Dann <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-212"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-213">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-214">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-215">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-216">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-217">p</span></span></span><script type="math/tex" id="MathJax-Element-45">slerp</script>    : <br><br>  (1) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-218"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-219">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-220">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-221">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-222">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-223">p</span><span class="MJXp-mrow" id="MJXp-Span-224"><span class="MJXp-mo" id="MJXp-Span-225" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-226"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-227" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-228" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-229" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-230"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-231" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-232" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-233" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-234">t</span><span class="MJXp-mo" id="MJXp-Span-235" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span><span class="MJXp-mo" id="MJXp-Span-236" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mfrac" id="MJXp-Span-237" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-238">sin</span><span class="MJXp-mo" id="MJXp-Span-239" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-240"><span class="MJXp-mo" id="MJXp-Span-241" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-242"><span class="MJXp-mo" id="MJXp-Span-243" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-244">1</span><span class="MJXp-mo" id="MJXp-Span-245" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-246">t</span><span class="MJXp-mo" id="MJXp-Span-247" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mi" id="MJXp-Span-248">Œ©</span><span class="MJXp-mo" id="MJXp-Span-249" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-250">sin</span><span class="MJXp-mo" id="MJXp-Span-251" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-252"><span class="MJXp-mo" id="MJXp-Span-253" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-254">Œ©</span><span class="MJXp-mo" id="MJXp-Span-255" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-256"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-257" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-258" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-259" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mfrac" id="MJXp-Span-260" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-261">sin</span><span class="MJXp-mo" id="MJXp-Span-262" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-263"><span class="MJXp-mo" id="MJXp-Span-264" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-265">t</span><span class="MJXp-mi" id="MJXp-Span-266">Œ©</span><span class="MJXp-mo" id="MJXp-Span-267" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-268">sin</span><span class="MJXp-mo" id="MJXp-Span-269" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-270"><span class="MJXp-mo" id="MJXp-Span-271" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-272">Œ©</span><span class="MJXp-mo" id="MJXp-Span-273" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-274"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-275" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-276" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-46">\begin{equation*} slerp\left(p_0, p_1, t\right) = \frac{\sin\left[\left(1-t\right)\Omega\right]}{\sin\left(\Omega\right)}p_0 + \frac{\sin\left(t\Omega\right)}{\sin\left(\Omega\right)} p_1 \end{equation*}</script> </math></p><br>  wo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-277"><span class="MJXp-mi" id="MJXp-Span-278">Œ©</span></span></span><script type="math/tex" id="MathJax-Element-47">\Omega</script> ‚Äî     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-279"><span class="MJXp-msubsup" id="MJXp-Span-280"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-281" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-282" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-48">p_0</script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-283"><span class="MJXp-msubsup" id="MJXp-Span-284"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-285" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-286" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-49">p_1</script> ,       : <br><br>  (2) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-287"><span class="MJXp-mi" id="MJXp-Span-288">Œ©</span><span class="MJXp-mo" id="MJXp-Span-289" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-290">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-291">o</span><span class="MJXp-msubsup" id="MJXp-Span-292"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-293" style="margin-right: 0.05em;">s</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-294" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-295">‚àí</span><span class="MJXp-mn" id="MJXp-Span-296">1</span></span></span><span class="MJXp-mrow" id="MJXp-Span-297"><span class="MJXp-mo" id="MJXp-Span-298" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-299"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-300" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-301" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-302" style="margin-left: 0.267em; margin-right: 0.267em;">‚ãÖ</span><span class="MJXp-msubsup" id="MJXp-Span-303"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-304" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-305" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-306" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-50">\begin{equation*} \Omega=cos^{-1} \left(p_0 \cdot p_1 \right) \end{equation*}</script> </math></p><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist wichtig zu beachten, dass bei Verwendung der traditionellen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linearen Interpolation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der resultierende Vektor sehr unterschiedlich aussieht:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/5e1/42f/eef5e142f1c8c05cac9b3d4f18d8e097.png" width="239" height="240"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Lerp-Operation zwischen zwei getrennten Einheitsvektoren erzeugt nicht immer andere Einheitsvektoren. </font><font style="vertical-align: inherit;">Tats√§chlich passiert dies nie, es sei denn, der Koeffizient ist</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-307"><span class="MJXp-mn" id="MJXp-Span-308"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-51-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-51">1</script>  oder <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-309"><span class="MJXp-mn" id="MJXp-Span-310"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-52-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-52">0</script>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trotzdem erhalten wir beim Normalisieren des Lerp-Ergebnisses tats√§chlich einen Einheitsvektor, der dem Ergebnis von slerp erstaunlich nahe kommt: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nlerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 n1, float3 n2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> normalize(lerp(n1, n2, t)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nlerp bezeichnete</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Technik </font><font style="vertical-align: inherit;">liefert eine enge Ann√§herung an slerp. </font><font style="vertical-align: inherit;">Seine Verwendung wurde von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casey Muratori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , einem der Entwickler von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Witness,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> popul√§r gemacht </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn Sie mehr √ºber dieses Thema </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfahren m√∂chten</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , empfehle ich, </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">Slerp-Artikel zu verstehen. </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">Dann </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">benutze ich es </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">nicht von </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonathan Blow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Math Magician - Lerp, Slerp und Nlerp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank nlerp k√∂nnen wir jetzt normale Vektoren effizient auf eine zuf√§llige Seite kippen, die abgetastet wird von </font></font><code>_SandTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _SandStrength; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); // Rotates N towards Ns based on _SandStrength float3 Ns = nlerp(N, S, _SandStrength); return Ns; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Ergebnis ist unten dargestellt: </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rddUAStRjZ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Was weiter </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im n√§chsten Teil betrachten wir die flackernden Reflexionen, dank denen die D√ºnen dem Ozean √§hneln. </font></font><br><br><h3>  Danksagung </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Videospiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Journey</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wurde </font><font style="vertical-align: inherit;">von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thatgamecompany entwickelt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sony Computer Entertainment ver√∂ffentlicht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es ist f√ºr PC ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Epic Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und PS4 ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">verf√ºgbar </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jiadi Deng werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3D-Modelle von </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">D√ºnenhintergr√ºnden</font></a><font style="vertical-align: inherit;"> und Beleuchtungsoptionen erstellt </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein 3D-Modell von Journeys Charakter wurde im (jetzt geschlossenen) FacePunch-Forum gefunden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einheitspaket </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diesen Effekt wiederherstellen m√∂chten, k√∂nnen Sie das vollst√§ndige Unity-Paket von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunterladen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es enth√§lt alles, was Sie brauchen, vom Shader bis zum 3D-Modell.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476448/">https://habr.com/ru/post/de476448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476434/index.html">Wir schreiben USB-Treiber f√ºr verlassene Ger√§te</a></li>
<li><a href="../de476436/index.html">Berichte vom ersten Treffen der Roboterentwickler in Russland √ºber das Roboterbetriebssystem</a></li>
<li><a href="../de476442/index.html">Geben Sie etwas Platz oder einen Mikrocontroller wie ein Frequenzmesser</a></li>
<li><a href="../de476444/index.html">Entmystifizierung der Prinzipien des Quantencomputers</a></li>
<li><a href="../de476446/index.html">Jira Plugins: Einige Beispiele f√ºr die erfolgreiche Erfindung des Fahrrads</a></li>
<li><a href="../de476450/index.html">√úberblick √ºber cPanel - eine webbasierte Konsole zum Verwalten von Websites und zum Hosten</a></li>
<li><a href="../de476452/index.html">Speichern von Schl√ºsselwerten oder wie unsere Anwendungen komfortabler geworden sind</a></li>
<li><a href="../de476454/index.html">5G kommt: Welche Unternehmen werden die Einf√ºhrung neuer Technologien im Jahr 2020 sicherstellen?</a></li>
<li><a href="../de476456/index.html">Das chinesische Sozialkredit-System ist in erster Linie kein B√ºrgerbewertungssystem, sondern ein massives API</a></li>
<li><a href="../de476460/index.html">Das erste Hit-Dateiformat im Internet war nicht MP3, sondern MIDI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>