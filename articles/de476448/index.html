<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🃏 🎯 👽 Erkundung des Sandshaders des Journey-Spiels 🌂 🚇 🗯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter den vielen Indie-Spielen, die in den letzten 10 Jahren veröffentlicht wurden, ist eines meiner Lieblingsspiele definitiv Journey . Dank seiner a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erkundung des Sandshaders des Journey-Spiels</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476448/">  Unter den vielen Indie-Spielen, die in den letzten 10 Jahren veröffentlicht wurden, ist eines meiner Lieblingsspiele definitiv <em>Journey</em> .  Dank seiner atemberaubenden Ästhetik und seines wunderschönen Soundtracks ist <em>Journey</em> in nahezu allen Aspekten der Entwicklung zu einem hervorragenden Beispiel geworden. <br><br>  Ich bin ein Spieleentwickler und technischer Künstler, daher war ich von der Art und Weise, wie der Sand gerendert wurde, am meisten fasziniert.  Es ist nicht nur schön, sondern steht auch in direktem Zusammenhang mit dem grundlegenden Gameplay und dem gesamten Gameplay.  <em>Journey</em> ist buchstäblich aus Sand gebaut, und ohne solch einen erstaunlichen Effekt könnte das Spiel selbst einfach nicht existieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/be0/2a8/63fbe02a87ccac8101001a43d953776f.jpg"></div><br>  In diesem Artikel, der in zwei Beiträge unterteilt ist, möchte ich dem <em>Journey-</em> Erbe meine Anerkennung zollen, indem ich Ihnen beibringe, wie Sie mit Shadern genau dasselbe Sand-Rendering erstellen.  Unabhängig davon, ob Sanddünen in Ihrem Spiel benötigt werden, können Sie in dieser Reihe von Tutorials lernen, wie Sie eine bestimmte Ästhetik in Ihrem eigenen Spiel wiederherstellen.  Wenn Sie den in <em>Journey</em> verwendeten schönen Sand-Shader neu erstellen möchten, müssen Sie zunächst verstehen, wie er erstellt wurde.  Und obwohl es äußerst komplex aussieht, besteht es tatsächlich aus mehreren relativ einfachen Effekten.  Dieser Ansatz, Shader zu schreiben, ist notwendig, um ein erfolgreicher technischer Künstler zu werden.  Daher hoffe ich, dass Sie diese <em>Reise</em> mit mir machen, auf der wir nicht nur die Erstellung von Shadern erforschen, sondern auch lernen, wie man Ästhetik und Gameplay kombiniert. <br><a name="habracut"></a><br><h1>  Sandanalyse in Journey </h1><br>  Dieser Artikel basiert, wie viele andere Versuche, das Sand-Rendering von <em>Journey</em> nachzubilden, auf einem Bericht der GDC, den der leitende Ingenieur des Unternehmens, John Edwards, mit dem Titel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Sand-Rendering in Journey</a> " verfasst hat.  In diesem Vortrag spricht John Edwards über alle Effektebenen, die <em>Journey zu</em> den Sanddünen hinzugefügt wurden, um den richtigen Look zu erzielen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wt2yYnBRD3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Der Bericht ist sehr nützlich, aber im Kontext dieses Tutorials sind viele der von John Edwards getroffenen Einschränkungen und Entscheidungen nicht wichtig.  Wir werden versuchen, die Sand-Shader, die an den <em>Journey-</em> Shader erinnern, hauptsächlich durch visuelle Referenzen nachzubilden. <br><br>  Beginnen wir mit einem einfachen 3D-Netz einer perfekt glatten Düne.  Die Glaubwürdigkeit der Sandverarbeitung hängt von zwei Aspekten ab: Beleuchtung und Körnung.  Eine interessante Möglichkeit, das Licht von Sand zu reflektieren, bietet ein modifiziertes <strong>Beleuchtungsmodell</strong> .  Im Kontext der Shader-Codierung bestimmt das Beleuchtungsmodell Schatten und Lichter basierend auf den Eigenschaften des Modells und den Beleuchtungsbedingungen der Szene. <br><br>  All dies reicht jedoch nicht aus, um die Illusion eines Realismus zu erzeugen.  Das Problem ist, dass Sand einfach nicht mit flachen Oberflächen modelliert werden kann.  Sandkorn sollte berücksichtigt werden.  Aus diesem Grund gibt es zwei separate Effekte, die direkt mit der <strong>Normalen auf der Oberfläche zusammenwirken</strong> und dazu verwendet werden können, kleine Sandpartikel auf der Oberfläche der Düne zu simulieren. <br><br>  Das folgende Diagramm zeigt alle Effekte, die wir in diesem Tutorial lernen werden.  Aus technischer Sicht werden normale Berechnungen durchgeführt, bevor die Beleuchtung verarbeitet wird.  Zur Erleichterung der Untersuchung werden die Wirkungen in einer anderen Reihenfolge beschrieben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/0b9/8a1/3730b98a1670ef00cf68efb0af0cc08b.png"></div><br><h6>  Diffuse Farbe </h6><br>  Der einfachste Sand Shader-Effekt ist seine <strong>diffuse Farbe</strong> , die grob die <em>matte</em> Komponente des Gesamterscheinungsbildes beschreibt.  Die diffuse Farbe wird basierend auf der <em>tatsächlichen</em> Farbe des Objekts und den Lichtbedingungen berechnet.  Eine weiße Kugel ist nicht überall perfekt weiß, da die diffuse Farbe vom einfallenden Licht abhängt.  Diffuse Farben werden mithilfe eines mathematischen Modells berechnet, das die Reflexion von Licht von einer Oberfläche approximiert.  Dank eines Berichts von John Edwards mit der GDC kennen wir genau die verwendete Gleichung, die er <strong>diffuses Kontrastreflexionsvermögen</strong> nennt;  es basiert auf dem bekannten <strong>Lambert-</strong> Modell der <strong>Reflexionen</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/509/4c1/65b/5094c165b5f2e1ba10696fec1641482c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br>  <i>Vor und nach der Anwendung der Gleichung</i> <br><br><h6>  Sand normal </h6><br>  Die ursprüngliche Geometrie ist völlig glatt.  Um dies zu kompensieren, wird die <strong>Oberflächennormale des</strong> Modells mit einer Technik namens <strong>Bump Mapping</strong> geändert.  Sie können eine Textur verwenden, um komplexere Geometrien zu simulieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><h6>  Kantenbeleuchtung </h6><br>  Jedes <em>Reise-</em> Level verwendet eine begrenzte Farbpalette.  Aus diesem Grund ist es ziemlich schwierig zu verstehen, wo eine Düne endet und eine andere beginnt.  Um die Lesbarkeit zu verbessern, wird die Technik der kleinen Hervorhebung des Sichtbaren nur entlang des Dünenrandes angewendet.  Es wird als <strong>Randbeleuchtung bezeichnet</strong> , und es gibt viele Möglichkeiten, dies umzusetzen.  Für dieses Tutorial habe ich eine <strong>auf Fresnel-</strong> Reflexionen basierende Methode gewählt, die Reflexionen auf polierten Oberflächen unter sogenannten <em>Einfallswinkeln</em> modelliert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><h6>  Spiegelbild des Ozeans </h6><br>  Einer der unterhaltsamsten Aspekte <em>im</em> Gameplay von <em>Journey</em> ist das „Surfen“ in den Sanddünen.  Dies ist wahrscheinlich der Grund, warum die Spielefirma wollte, dass sich der Sand eher wie eine Flüssigkeit als wie ein Feststoff anfühlt.  Hierfür wurde eine starke Reflexion verwendet, die häufig in Wasserschattierungen zu finden ist.  John Edwards nennt diesen Effekt <strong>Ocean Specular</strong> , und im Tutorial implementieren wir ihn mithilfe der <strong>Blinn-Fong-Reflexion</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><h6>  Blendung Reflexion </h6><br>  Indem Sie dem Sand Shader eine ozeanische Spiegelkomponente hinzufügen, wirkt er flüssiger.  Dennoch lässt sich einer der wichtigsten visuellen Aspekte des Sandes nicht vermitteln: zufällig auftretende Reflexionen.  In echten Dünen tritt dieser Effekt auf, weil jedes Sandkorn Licht in seine Richtung reflektiert und sehr oft einer dieser reflektierten Strahlen in unser Auge gelangt.  Eine solche <strong>Glitzerreflexion</strong> (Reflexion von Reflexionen) tritt auch an Orten auf, an denen direktes Sonnenlicht nicht einfällt;  es ergänzt das ozeanische Spiegelbild und stärkt das Gefühl der Glaubwürdigkeit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><h6>  Sandwellen </h6><br>  Durch Ändern der Normalen konnten wir den Effekt kleiner Sandkörner auf der Dünenoberfläche simulieren.  In den Dünen der realen Welt treten häufig vom Wind verursachte Wellen auf.  Ihre Form variiert je nach Neigung und Position der Dünen im Verhältnis zur Windrichtung.  Möglicherweise können solche Muster durch eine Höckertextur erzeugt werden, aber in diesem Fall ist es unmöglich, die Form der Dünen in Echtzeit zu ändern.  Die von John Edwards vorgeschlagene Lösung ähnelt einer Technik namens <strong>Triplanar Shading</strong> : Es werden vier verschiedene Texturen verwendet, die je nach Position und Neigung der Dünen gemischt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/828/9b4/997/8289b49971bbe0046845f71284790124.png"></div><br><h1>  Reise Sand Shader Anatomie </h1><br>  Unity bietet viele Shader-Vorlagen, mit denen Sie loslegen können.  Da wir an Materialien interessiert sind, die Licht empfangen und Schatten werfen können, müssen wir mit dem <strong>Surface Shader</strong> (Surface Shader) beginnen. <br><br>  Alle <strong>Surface Shader</strong> werden in zwei Schritten ausgeführt.  Zunächst wird <strong>eine Oberflächenfunktion</strong> aufgerufen, die die Eigenschaften der zu rendernden Oberfläche erfasst, z. B. <em>Albedo</em> , <em>Rauheit</em> , <em>Metalleigenschaften</em> , <em>Transparenz</em> und <em>Normalenrichtung</em> .  Dann werden alle diese Eigenschaften auf <strong>die Beleuchtungsfunktion übertragen</strong> , die den Einfluss externer Lichtquellen berücksichtigt und die Verschattung und Beleuchtung berechnet. <br><br><h2>  Oberflächenfunktion </h2><br>  Beginnen wir mit dem Kern unserer Oberflächenfunktion, der im folgenden <code>surf</code> wird.  Die einzigen Eigenschaften, die wir einstellen müssen, sind die <em>Farbe des Sandes</em> und die <strong>Normale zur Oberfläche</strong> .  Die Normale eines 3D-Modells ist ein Vektor, der die Position der Oberfläche angibt.  Normale Vektoren werden von der Beleuchtungsfunktion verwendet, um zu berechnen, wie Licht reflektiert wird.  Sie werden normalerweise beim Import des Netzes berechnet.  Sie können jedoch geändert werden, um eine komplexere Geometrie zu simulieren.  Hier verzerren die <strong>normalen Sand-</strong> und <strong>Sandwelleneffekte</strong> die Sandnorm, um ihre Rauheit zu simulieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); N = SandNormal (N); o.Normal = N; }</code> </pre> <br>  Wenn Sie Normalen nach <code>o.Normal</code> müssen sie im <strong>Tangentialraum</strong> ausgedrückt <strong>werden</strong> .  Dies bedeutet, dass der Vektor relativ zur Oberfläche des 3D-Modells ausgewählt wird.  <code>float3(0, 0, 1)</code> bedeutet also, dass das normale 3D-Modell tatsächlich nicht geändert wird. <br><br>  Beide Funktionen, <code>RipplesNormal</code> und <code>SandNormal</code> empfangen den normalen Vektor und modifizieren ihn.  Wie das geht, werden wir später sehen. <br><br><h2>  Beleuchtung funktion </h2><br>  In der Beleuchtungsfunktion werden alle anderen Effekte implementiert.  Der folgende Code zeigt, wie jede einzelne Komponente in separaten Funktionen berechnet wird (diffuse Farbe, Randbeleuchtung, Ozeanspiegelung und Glitzerreflexion).  Dann werden sie alle kombiniert. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Journey fullforwardshadows float4 LightingJourney (SurfaceOutput s, fixed3 viewDir, UnityGI gi) { float3 diffuseColor = DiffuseColor (); float3 rimColor = RimLighting (); float3 oceanColor = OceanSpecular (); float3 glitterColor = GlitterSpecular (); float3 specularColor = saturate(max(rimColor, oceanColor)); float3 color = diffuseColor + specularColor + glitterColor; return float4(color * s.Albedo, 1); }</span></span></code> </pre> <br>  Die Methode zum Kombinieren von Komponenten ist ziemlich willkürlich und ermöglicht es uns, sie zu ändern, um die künstlerischen Möglichkeiten zu untersuchen. <br><br>  Typischerweise stapeln sich Spiegelreflexionen über diffuse Farben.  Da wir hier nicht eine, sondern drei Spiegelreflexionen haben ( <em>Randlicht</em> , <em>Ozeanspiegel</em> und <em>Glitzerspiegel</em> ), müssen wir vorsichtiger sein, damit der Sand nicht <em>zu</em> flackert.  Da Rim Light und Ocean Specular Teil desselben Effekts sind, können wir nur den Maximalwert auswählen.  Glitzerspiegel werden separat hinzugefügt, da diese Komponente flackernden Sand erzeugt. <br><br><h2>  Teil 2. Diffuse Farbe </h2><br>  Im zweiten Teil des Beitrags konzentrieren wir uns auf das im Spiel verwendete Beleuchtungsmodell und darauf.  Wie erstelle ich es in Unity neu? <br><br>  Im vorigen Teil haben wir den Grundstein dafür gelegt, was sich allmählich in unsere Version des Sandshaders Journey verwandeln wird.  Wie bereits erwähnt, wird <strong>die Beleuchtungsfunktion</strong> in <strong>Oberflächen-Shadern verwendet</strong> , um den Effekt der Beleuchtung zu berechnen, sodass Schatten und Lichter auf der Oberfläche erscheinen.  Wir haben herausgefunden, dass Journey mehrere Effekte hat, die in diese Kategorie fallen.  Wir werden mit dem grundlegendsten (und einfachsten) Effekt beginnen, der im Kern dieses Shaders zu finden ist: seiner <strong>diffusen Beleuchtung</strong> (diffuse / diffuse Beleuchtung). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78f/166/71c/78f16671c754f05e619ce034fad81926.png"></div><br>  Im Moment lassen wir alle anderen Effekte und Komponenten aus und konzentrieren uns auf das <strong>Beleuchten des Sandes</strong> . <br><br>  Die Beleuchtungsfunktion, die wir im vorherigen Teil des Beitrags mit dem Namen <code>LightingJourney</code> , delegiert die Berechnung der diffusen Farbe von Sand einfach an eine Funktion mit dem Namen <code>DiffuseColor</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightingJourney</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SurfaceOutput s, fixed3 viewDir, UnityGI gi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Lighting properties float3 L = gi.light.dir; float3 N = s.Normal; // Lighting calculation float3 diffuseColor = DiffuseColor(N, L); // Final color return float4(diffuseColor, 1); }</span></span></code> </pre> <br>  Da jeder Effekt in sich geschlossen und in seiner eigenen Funktion gespeichert ist, ist unser Code modularer und übersichtlicher. <br><br><h2>  Lambert-Reflexion </h2><br>  Bevor Sie diffuses Licht „wie in Journey“ erstellen, sollten Sie sich ansehen, wie die „grundlegende“ Funktion für diffuses Licht aussieht.  Die einfachste Schattierungstechnik für matte Materialien heißt <strong>Lambertsches Reflexionsvermögen</strong> .  Dieses Modell entspricht in etwa dem Aussehen der meisten nicht glänzenden und nicht metallischen Oberflächen.  Es ist nach dem Schweizer Enzyklopädisten <strong>Johann Heinrich Lambert benannt</strong> , der sein Konzept 1760 vorschlug. <br><br>  Lamberts Reflexionskonzept basiert auf einer einfachen Idee: Die <em>Helligkeit einer Oberfläche hängt von der Menge des auf sie einfallenden Lichts ab</em> .  Geometrisch kann dies in der folgenden Abbildung gezeigt werden, in der die Kugel von einer entfernten Lichtquelle beleuchtet wird.  Obwohl die roten und grünen Bereiche der Kugel gleich stark beleuchtet werden, unterscheiden sich ihre Oberflächen erheblich.  Wenn das Licht im roten Bereich über eine größere Fläche verteilt ist, bedeutet dies, dass jede Einheit des roten Quadrats weniger Licht als grün empfängt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/d48/495/2cfd484953877a47fe5ba564b399ea35.png"></div><br>  Theoretisch hängt die Lambert-Reflexion vom relativen Winkel zwischen der <em>Oberfläche</em> und dem <em>einfallenden Licht ab</em> .  Aus mathematischer Sicht ist dies eine Funktion von der <strong>Normalen zur Oberfläche</strong> und der <strong>Beleuchtungsrichtung</strong> .  Diese Größen werden unter Verwendung von zwei Einheitslängenvektoren ( <strong>Einheitsvektoren genannt</strong> ) ausgedrückt. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> N </script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> L </script>  .  Einzelne Vektoren sind eine Standardmethode, um <em>Richtungen</em> im Kontext der Shader-Codierung anzugeben. <br><br><div class="spoiler">  <b class="spoiler_title">Der Wert von N und L</b> <div class="spoiler_text">  <strong>Normal</strong> zur Oberfläche <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.074ex" viewBox="0 -772.3 888.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> N </script>  Ist ein Einheitsvektor, der <em>von</em> der Oberfläche selbst <em>weg</em> gerichtet ist. <br><br>  Analog können wir davon ausgehen, dass die <strong>Richtung der Beleuchtung</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.074ex" viewBox="0 -772.3 681.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> L </script>  zeigt <em>von der</em> Lichtquelle und folgt in die Richtung, in die sich das Licht bewegt.  Dies ist jedoch nicht der Fall: Die Beleuchtungsrichtung ist ein einzelner Vektor, der <em>in die</em> Richtung zeigt, aus der das Licht kam. <br><br>  Dies kann verwirrend sein, insbesondere wenn Sie mit dem Erstellen von Shadern noch nicht vertraut sind.  Dank dieser Notation werden Gleichungen jedoch einfacher. </div></div><br><div class="spoiler">  <b class="spoiler_title">Lambert-Spiegelbild in der Einheit</b> <div class="spoiler_text">  Vor Unity 5 <strong>Standard Shader</strong> war die Lambert-Reflexion das Standardmodell für das Abschatten beleuchteter Oberflächen. <br><br>  Sie können weiterhin im Materialinspektor darauf zugreifen: Im <em>Legacy-Shader heißt</em> es <em>Diffuse</em> . <br><br>  Wenn Sie Ihren eigenen Oberflächen-Shader schreiben, steht die Lambert-Reflexion als Beleuchtungsfunktion mit dem Namen <code>Lambert</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Lambert fullforwardshadows</span></span></code> </pre> <br>  Ihre Implementierung finden Sie in der <code>LightingLambert</code> Funktion, die in der Datei <code>CGIncludes\Lighting.cginc</code> . </div></div><br><div class="spoiler">  <b class="spoiler_title">Lambert Reflexion und Klima</b> <div class="spoiler_text">  Lambert-Reflexion ist ein relativ altes Modell, bietet jedoch ein Verständnis für komplexe Konzepte wie Oberflächenschattierung.  Es kann auch verwendet werden, um viele andere Phänomene zu erklären.  Zum Beispiel erklärt dasselbe Diagramm, warum es an den Polen des Planeten kälter ist als am Äquator. </div></div><br>  Bei genauerer Betrachtung können wir feststellen, dass die Oberfläche die maximale Beleuchtungsstärke erhält, wenn ihre Normale parallel zur Beleuchtungsrichtung verläuft.  Und umgekehrt: Es gibt kein Licht, wenn zwei Einheitsvektoren senkrecht zueinander stehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e1/d06/6c6/0e1d066c6ff998abda8ca5c7607e4c4e.png"></div><br>  Offensichtlich ist der Winkel zwischen <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> N </script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> L </script>  kritisch für die Reflexion nach Lambert.  Darüber hinaus ist die Helligkeit maximal und gleich <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14">100</span><span class="MJXp-mi" id="MJXp-Span-15">%</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.423ex" height="2.298ex" viewBox="0 -832 2335 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-25" x="1501" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> 100 \% </script>  wenn der Winkel ist <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-16"><span class="MJXp-mn" id="MJXp-Span-17">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-30" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> 0 </script>  und minimal ( <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-18"><span class="MJXp-mn" id="MJXp-Span-19">0</span><span class="MJXp-mi" id="MJXp-Span-20">%</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.098ex" height="2.298ex" viewBox="0 -832 1334 989.6" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-30" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-25" x="500" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9"> 0 \% </script>  ), wenn der Winkel dazu neigt <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-msubsup" id="MJXp-Span-22"><span class="MJXp-mn" id="MJXp-Span-23" style="margin-right: 0.05em;">90</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-24" style="vertical-align: 0.5em;"><span class="MJXp-mtext" id="MJXp-Span-25">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">c</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.871ex" height="2.419ex" viewBox="0 -935.7 2527.6 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-39"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMAIN-30" x="500" y="0"></use><g transform="translate(1001,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-63" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-69" x="787" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-72" x="1132" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-63" x="1584" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-10"> 90 ^ {\ circ} </script>  .  Wenn Sie mit der <em>Vektoralgebra</em> vertraut sind, können Sie verstehen, dass eine Größe Lamberts Reflexion darstellt <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">I</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.172ex" height="2.057ex" viewBox="0 -780.1 504.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-49" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-11"> I </script>  ist gleich <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-32"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">N</span><span class="MJXp-mtext" id="MJXp-Span-34">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.417ex" height="2.057ex" viewBox="0 -780.1 3624 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-63" x="1138" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-64" x="1572" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-6F" x="2095" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-74" x="2581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhjOAGsAP4ZwVkt4t9IieEfPCBpWbg#MJMATHI-4C" x="2942" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-12"> N \ cdot L </script>  Wo ist der Betreiber? <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="MJXp-mtext" id="MJXp-Span-41">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> \ cdot </script>  <strong>Skalarprodukt genannt</strong> . <br><br>  (1) <p><math> </math> $$ display $$ \ begin {equation *} I = N \ cdot L \ end {equation *} $$ display $$ </p><br>  Das Skalarprodukt ist ein Maß für die "Übereinstimmung" zweier Vektoren relativ zueinander und variiert im Intervall von <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-52"><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-54">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> + 1 </script>  (für zwei identische Vektoren) bis <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-55"><span class="MJXp-mo" id="MJXp-Span-56" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mn" id="MJXp-Span-57">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> -1 </script>  (für zwei entgegengesetzte Vektoren).  Ein Skalarprodukt ist die Grundlage für die Schattierung, die ich im Tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Physikalisch basiertes Rendern und Beleuchtungsmodelle</a> ausführlich untersucht habe. <br><br><h3>  Implementierung </h3><br>  Und zu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-58"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> N </script>  und zu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> L </script>  Sie können leicht auf die Surface Shader-Beleuchtungsfunktionen über <code>s.Normal</code> und <code>gi.light.dirin</code> .  Der Einfachheit halber werden wir sie im Shader-Code in <code>N</code> und <code>L</code> umbenennen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate( dot(N, L) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  <code>saturate</code> begrenzt den Wert von <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mn" id="MJXp-Span-63">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> 0 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mn" id="MJXp-Span-65">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> 1 </script>  .  Da sich das Skalarprodukt jedoch im Bereich von <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mn" id="MJXp-Span-68">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> -1 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-69"><span class="MJXp-mo" id="MJXp-Span-70" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-71">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> + 1 </script>  Wir müssen nur mit den negativen Werten arbeiten.  Aus diesem Grund wird die Lambert-Reflexion häufig wie folgt implementiert: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, L) );</code> </pre> <br><h2>  Kontrastreflexion des Umgebungslichts </h2><br>  Obwohl Lamberts Reflexion die meisten Materialien gut abschattet, ist sie weder physikalisch genau noch fotorealistisch.  In älteren Spielen wurden Lambert-Shader häufig verwendet.  Spiele, die diese Technik verwenden, <em>scheinen</em> oft alt zu sein, weil sie versehentlich die Ästhetik alter Spiele reproduzieren können.  Wenn Sie dies nicht anstreben, sollten Sie Lambert-Reflexionen vermeiden und modernere Technologien verwenden. <br><br>  Ein solches Modell ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">das Oren-Nayyar-Reflexionsmodell</a> , das ursprünglich in dem 1994 von Michael Oren und Sri C. Nayyar veröffentlichten Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Generalization of Lambert's Reflectance Model beschrieben</a> wurde.  Das Oren-Nayyar-Modell ist eine Verallgemeinerung der Lambert-Reflexion und wurde speziell für raue Oberflächen entwickelt.  Anfänglich wollten die Entwickler von Journey die Oren-Nayyar-Reflexion als Grundlage für ihren Sandshader verwenden.  Diese Idee wurde jedoch aufgrund der hohen Rechenkosten aufgegeben. <br><br>  In seinem Bericht von 2013 erklärt der technische Künstler John Edwards, dass das für den Sand Journey erstellte Reflexionsmodell auf einer Reihe von Versuchen und Irrtümern basiert. Die Entwickler wollten nicht die fotorealistische Wiedergabe der Wüste nachbilden, sondern einer konkreten, sofort erkennbaren Ästhetik Leben einhauchen. <br><br>  Das resultierende Schattierungsmodell entspricht seiner Meinung nach dieser Gleichung: <br><br>  (2) <p><math> </math> $$ display $$ \ begin {equation *} I = 4 * \ left (\ left (N \ odot \ left [1, 0.3, 1 \ right] \ right) \ cdot L \ right) \ end {equation *} $$ display $$ </p><br>  wo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mtext" id="MJXp-Span-96">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> \ odot </script>  - <strong>Elementweises Produkt</strong> zweier Vektoren. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  Reflexionsmodell (2) Da John Edwards <strong>diffusen Kontrast</strong> nennt, werden wir diesen Namen im gesamten Lernprogramm verwenden. <br><br>  Die Animation unten zeigt den Unterschied zwischen Lambert-Schattierung (links) und diffusem Kontrast gegenüber Journey (rechts). <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q-hQiDA71Yg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">Was ist die Bedeutung von 4 und 0,3?</b> <div class="spoiler_text">  Obwohl der diffuse Kontrast nicht auf physikalische Genauigkeit ausgelegt ist, können wir dennoch versuchen zu verstehen, was er bewirkt. <br><br>  Im Kern wird immer noch Lambert-Reflexion verwendet.  Der erste offensichtliche Unterschied ist, dass das Gesamtergebnis mit multipliziert wird <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mn" id="MJXp-Span-102"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><script type="math/tex" id="MathJax-Element-25"> 4 </script>  .  Dies bedeutet, dass alle Pixel, die normalerweise empfangen wurden <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-103"><span class="MJXp-mn" id="MJXp-Span-104"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25 </font></font></span><span class="MJXp-mi" id="MJXp-Span-105"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></span></span></span><script type="math/tex" id="MathJax-Element-26"> 25 \% </script>  Die Beleuchtung leuchtet jetzt wie beim Empfang <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-106"><span class="MJXp-mn" id="MJXp-Span-107"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100 </font></font></span><span class="MJXp-mi" id="MJXp-Span-108"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></span></span></span><script type="math/tex" id="MathJax-Element-27"> 100 \% </script>  beleuchtung.  Indem man alles mit multipliziert <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-mn" id="MJXp-Span-110"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><script type="math/tex" id="MathJax-Element-28"> 4 </script>  Eine schwache Schattierung nach Lambert wird viel stärker und der Übergangsbereich zwischen Dunkelheit und Licht ist kleiner.  In diesem Fall wird der Schatten schärfer. <br><br>  Auswirkung der Multiplikation der <code>y</code> Komponente auf die Normalenrichtung <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-111"><span class="MJXp-mn" id="MJXp-Span-112"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,3</font></font></span></span></span><script type="math/tex" id="MathJax-Element-29"> 0.3 </script>  erklären ist viel schwieriger.  Wenn sich die Komponenten des Vektors ändern, ändert sich die allgemeine Richtung, in die er zeigt.  Reduzieren Sie den Wert der <code>y</code> Komponente auf alles <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-113"><span class="MJXp-mn" id="MJXp-Span-114"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30 </font></font></span><span class="MJXp-mi" id="MJXp-Span-115"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">%</font></font></span></span></span><script type="math/tex" id="MathJax-Element-30"> 30 \% </script>  Die Reflexion des diffusen Kontrasts bewirkt, dass die Schatten vom ursprünglichen Wert vertikaler werden. <br><br>  Hinweis: Ein Skalarprodukt misst den Winkel zwischen zwei Vektoren nur dann direkt, wenn beide eine Länge haben <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-116"><span class="MJXp-mn" id="MJXp-Span-117"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-31"> 1 </script>  .  Die vorgenommene Änderung verringert die normale Länge <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-118"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></span></span></span><script type="math/tex" id="MathJax-Element-32"> N </script>  Das ist kein Einheitsvektor mehr. </div></div><br><h2>  Von Grautönen zu Farbe </h2><br>  Alle oben gezeigten Animationen haben Graustufen, da sie die Werte ihres Reflexionsmodells anzeigen, die im Intervall von variieren <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-120"><span class="MJXp-mn" id="MJXp-Span-121">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> 0 </script>  vorher <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-122"><span class="MJXp-mn" id="MJXp-Span-123">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> 1 </script>  ". Wir können einfach Farben hinzufügen, indem <code>NdotL</code> als Interpolationskoeffizienten zwischen zwei Farben verwenden: eine für vollständig schattierten und eine für vollständig beleuchteten Sand. <br><br><pre> <code class="cpp hljs">float3 _TerrainColor; float3 _ShadowColor; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); float3 color = lerp(_ShadowColor, _TerrainColor, NdotL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; }</code> </pre> <br><h2>  Teil 3. Normaler Sand </h2><br>  Im dritten Teil werden wir uns auf die Erstellung normaler Karten konzentrieren, die glatte 3D-Modelle in Sanddünen verwandeln. <br><br>  Im vorherigen Teil des Tutorials haben wir die diffuse Beleuchtung von Journey Sand implementiert.  Wenn Sie nur diesen Effekt verwenden, wirken die Wüstendünen eher flach und langweilig. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cb/dd6/9a8/8cbdd69a8a92614469132400c0979c79.png"></div><br>  Einer der faszinierendsten Effekte von Journey ist die Körnigkeit des Sandes.  Wenn wir uns einen Screenshot ansehen, sehen wir, dass die Dünen nicht glatt und homogen sind, sondern aus Millionen mikroskopisch kleinen Sandkörnern bestehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e93/307/efc/e93307efce359d4830f5894dde30c9e6.jpg"></div><br>  Dieser Effekt kann mit einer Technik namens <strong>Bump Mapping</strong> erzielt werden, bei der Licht von einer ebenen Oberfläche reflektiert wird, als wäre es komplexer.  Sehen Sie, wie dieser Effekt das Erscheinungsbild des Renderings ändert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br>  Kleine Unterschiede zeigen sich mit zunehmender: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3d5/b3f/ea73d5b3fb56c941c9b61f022dcb8699.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f8/efa/5c4/2f8efa5c4926a0de947b8ff91e114498.png"></div><br><h2>  Wir beschäftigen uns mit normalen Karten </h2><br>  Sand besteht aus unzähligen Sandkörnern, von denen jedes seine eigene Form und Zusammensetzung hat (siehe unten).  Jedes einzelne Partikel reflektiert das Licht in eine möglicherweise zufällige Richtung.  Ein Weg, diesen Effekt zu realisieren, besteht darin, ein 3D-Modell zu erstellen, das all diese mikroskopischen Sandkörner enthält.  Aufgrund der unglaublichen Anzahl erforderlicher Polygone ist dieser Ansatz jedoch nicht durchführbar. <br><br>  Es gibt jedoch eine andere Lösung, mit der häufig eine komplexere Geometrie im Vergleich zu einem echten 3D-Modell simuliert wird.  Jeder Scheitelpunkt oder jede Fläche des 3D-Modells ist einem Parameter zugeordnet, der als <strong>Normalenrichtung bezeichnet wird</strong> .  Dies ist ein Längeneinheitsvektor, der zur Berechnung der Lichtreflexion auf der Oberfläche eines 3D-Modells verwendet wird.  Das heißt, um Sand zu simulieren, müssen Sie diese scheinbar zufällige Verteilung der Sandkörner simulieren und damit, wie sie die Oberflächennormalen beeinflussen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/bc4/cc3/413bc4cc3466b827a1a1d86559d54054.jpg"></div><br>  Dies kann auf unzählige Arten geschehen.  Am einfachsten ist es, eine Textur zu erstellen, die die Richtung der ursprünglichen Normalen des Dünenmodells ändert. <br><br>  <strong>Normal zur Oberfläche</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-124"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-125">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> N </script>  im allgemeinen Fall wird es anhand der Geometrie des 3D-Modells berechnet.  Sie können es jedoch mit der <strong>normalen Karte</strong> ändern.  Normale Karten sind Texturen, mit denen Sie komplexere Geometrien simulieren können, indem Sie die lokale Ausrichtung der Normalen zur Oberfläche ändern.  Diese Technik wird oft als <strong>Bump-Mapping bezeichnet</strong> . <br><br>  Das Ändern der Normalen ist eine relativ einfache Aufgabe, die in der <code>surf</code> Funktion des <strong>Surface Shader ausgeführt werden kann</strong> .  Diese Funktion <code>SurfaceOutput</code> zwei Parameter, von denen einer eine <code>struct</code> namens <code>SurfaceOutput</code> .  Es enthält alle Eigenschaften, die zum Rendern eines Teils eines 3D-Modells erforderlich sind, von der Farbe ( <code>o.Albedo</code> ) bis zur Transparenz ( <code>o.Alpha</code> ).  Ein weiterer Parameter, den es enthält, ist die Normalenrichtung ( <code>o.Normal</code> ), die umgeschrieben werden kann, um die Art und Weise zu ändern, in der Licht auf das Modell reflektiert wird. <br><br>  Gemäß der Unity-Dokumentation zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer">Surface Shadern</a> müssen alle Normalen, die in die <code>o.Normal</code> Struktur geschrieben werden, im <strong>Tangentialraum</strong> ausgedrückt <strong>werden</strong> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SurfaceOutput</span></span></span><span class="hljs-class"> {</span></span> fixed3 Albedo; <span class="hljs-comment"><span class="hljs-comment">// diffuse color fixed3 Normal; // tangent space normal, if written fixed3 Emission; half Specular; // specular power in 0..1 range fixed Gloss; // specular intensity fixed Alpha; // alpha for transparencies };</span></span></code> </pre> <br>  Somit können wir berichten, dass Einheitsvektoren im Koordinatensystem relativ zur Netznormalen ausgedrückt werden müssen.  Wenn Sie beispielsweise in <code>o.Normal</code> schreiben, <code>o.Normal</code> Werte von <code>float3(0, 0, 1)</code> normal unverändert. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br>  Dies liegt daran, dass der Vektor <code>float3(0, 0, 1)</code> tatsächlich ein normaler Vektor ist, der relativ zur Geometrie des 3D-Modells ausgedrückt wird. <br><br>  <code>o.Normal</code> die Normalen zur Oberfläche im <strong>Oberflächen-Shader</strong> zu ändern, müssen wir in <code>o.Normal</code> nur einen neuen Vektor in <strong>die Oberflächenfunktion</strong> <code>o.Normal</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = ... <span class="hljs-comment"><span class="hljs-comment">// change the normal here }</span></span></code> </pre> <br>  Im Rest des Beitrags werden wir die anfängliche Annäherung erstellen, die wir im sechsten Teil des Tutorials verkomplizieren werden. <br><br><h2>  Sand normal </h2><br>  Am problematischsten ist es zu verstehen, <em>wie sich die</em> Sandkörner normal zur Oberfläche verändern.  Obwohl jedes Sandkorn einzeln Licht in jede Richtung streuen kann, passiert im Großen und Ganzen etwas anderes.  Jeder physikalisch genaue Ansatz sollte die Verteilung normaler Vektoren auf der Sandoberfläche untersuchen und mathematisch modellieren.  Solche Modelle gibt es tatsächlich, aber die in unserem Tutorial vorgestellte Lösung ist viel einfacher und gleichzeitig sehr effektiv. <br><br>  An jedem Punkt im Modell wird ein <strong>zufälliger Einheitsvektor</strong> aus der Textur abgetastet.  Dann neigt sich die Normale zur Oberfläche um einen bestimmten Betrag in Richtung dieses Vektors.  Mit der richtigen Erzeugung einer zufälligen Textur und der Auswahl einer geeigneten Menge an Mischung können wir die Normale so zur Oberfläche verschieben, dass ein Gefühl der Körnigkeit entsteht, ohne die Gesamtkrümmung der Dünen zu verlieren. <br><br>  Zufällige Werte können mit einer Textur aus zufälligen Farben abgetastet werden.  Die Komponenten R, G und B jedes Pixels werden als Komponenten X, Y und Z des Normalenvektors verwendet.  Farbkomponenten sind im Sortiment <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-126"><span class="MJXp-mtext" id="MJXp-Span-127">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">t</span><span class="MJXp-mo" id="MJXp-Span-132" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mn" id="MJXp-Span-133">0</span><span class="MJXp-mo" id="MJXp-Span-134" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-135">1</span><span class="MJXp-mtext" id="MJXp-Span-136">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-137">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-138">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-139">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-140">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-141">t</span><span class="MJXp-mo" id="MJXp-Span-142" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> \ left [0, 1 \ right] </script>  Sie müssen also in ein Intervall konvertiert werden <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-143"><span class="MJXp-mtext" id="MJXp-Span-144">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-147">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148">t</span><span class="MJXp-mo" id="MJXp-Span-149" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mo" id="MJXp-Span-150" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-151">1</span><span class="MJXp-mo" id="MJXp-Span-152" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-153" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-154">1</span><span class="MJXp-mtext" id="MJXp-Span-155">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-156">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-157">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-158">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-159">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-160">t</span><span class="MJXp-mo" id="MJXp-Span-161" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> \ left [-1, + 1 \ right] </script>  .  Dann wird der resultierende Vektor normalisiert, so dass seine Länge gleich ist <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-162"><span class="MJXp-mn" id="MJXp-Span-163">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> 1 </script>  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d2/c95/03d/0d2c9503d98fd2463e7e3682743736bd.png"></div><br><div class="spoiler">  <b class="spoiler_title">Erstelle zufällige Texturen</b> <div class="spoiler_text">  Es gibt viele Möglichkeiten, zufällige Texturen zu erzeugen.  Um den gewünschten Effekt zu erzielen, ist die allgemeine Verteilung der Zufallsvektoren, die aus der Textur abgetastet werden können, das Wichtigste. <br><br>  Im obigen Bild ist jedes Pixel völlig zufällig.  Es gibt keine allgemeine Richtung (Farbe) in der Textur, da jeder Wert dieselbe Wahrscheinlichkeit hat wie alle anderen.  Diese Textur gibt uns eine Art Sand, der Licht in alle Richtungen streut. <br><br>  Während eines GDC-Vortrags machte John Edwards klar, dass die zufällige Textur, die für den Sand in Journey verwendet wurde, aus einer Gaußschen Verteilung generiert wurde.  Dies stellt sicher, dass die vorherrschende Richtung mit der Normalen auf der Oberfläche übereinstimmt. </div></div><br><div class="spoiler">  <b class="spoiler_title">Müssen zufällige Vektoren normalisiert werden?</b> <div class="spoiler_text">  Das Bild, mit dem ich Zufallsvektoren abgetastet habe, wurde nach einem völlig zufälligen Verfahren erzeugt.  Nicht nur jedes Pixel wird einzeln erzeugt: Die Komponenten R, G und B eines Pixels sind auch unabhängig voneinander.  Das heißt, im allgemeinen Fall wird für die aus dieser Textur abgetasteten Vektoren nicht garantiert, dass sie eine Länge von gleich haben <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-164"><span class="MJXp-mn" id="MJXp-Span-165"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-39"> 1 </script>  . <br><br>  Natürlich können Sie eine Textur erzeugen, bei der jedes Pixel beim Konvertieren aus <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-166"><span class="MJXp-mtext" id="MJXp-Span-167">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-168"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-169"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-171"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-172" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mn" id="MJXp-Span-173"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-174" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mn" id="MJXp-Span-175"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-178"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179"><font style="vertical-align: inherit;">g </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-180"><font style="vertical-align: inherit;">h </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-181"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mo" id="MJXp-Span-182" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;">]</font></span></font><span class="MJXp-mtext" id="MJXp-Span-176">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-177"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-178"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-180"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-181"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-182" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"></font></span></span></span><script type="math/tex" id="MathJax-Element-40"> \ left [0, 1 \ right] </script>  in <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-183"><span class="MJXp-mtext" id="MJXp-Span-184">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-185"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-186"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-188"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-189" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mo" id="MJXp-Span-190" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-191"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-192" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font></span><span class="MJXp-mo" id="MJXp-Span-193" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-194"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-196"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-197"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198"><font style="vertical-align: inherit;">g </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-199"><font style="vertical-align: inherit;">h </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-200"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mo" id="MJXp-Span-201" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;">]</font></span></font><span class="MJXp-mtext" id="MJXp-Span-195">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-196"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-197"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-199"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-200"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-201" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"></font></span></span></span><script type="math/tex" id="MathJax-Element-41"> \ left [-1, + 1 \ right] </script>  und in der Tat muss eine Länge haben <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-202"><span class="MJXp-mn" id="MJXp-Span-203"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><script type="math/tex" id="MathJax-Element-42"> 1 </script>  .  Hierbei treten jedoch zwei Probleme auf. <br><br> ,             . -,    <em> </em>   mip-,             . <br><br>   ,    . </div></div><br><h2>  Implementierung </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Teil des Tutorials haben wir das Konzept der „normalen Karten“ kennengelernt, als es in der allerersten Gliederung </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Oberflächenfunktion</font></font></strong> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auftauchte </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn Sie sich an das Diagramm am Anfang des Artikels erinnern, sehen Sie, dass zwei Effekte erforderlich sind, um das Rendern von Journey Sand wiederherzustellen. Die erste ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sandnormalen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die wir in diesem Teil des Artikels betrachten, und die zweite ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sandwellen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) werden wir im sechsten Teil untersuchen.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); <span class="hljs-comment"><span class="hljs-comment">// Covered in Journey Sand Shader #6 N = SandNormal (N); // Covered in this article o.Normal = N; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Abschnitt haben wir das Konzept des Bump-Mappings eingeführt, das uns gezeigt hat, dass für einen Teil des Effekts die Textur abgetastet werden muss (dies wird im Code aufgerufen </font></font><code>uv_SandTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem mit dem obigen Code ist, dass Sie für Berechnungen die wahre Position des Punktes kennen müssen, den wir zeichnen. Tatsächlich benötigen Sie eine </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV-Koordinate</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Textur abzutasten </font><font style="vertical-align: inherit;">, die bestimmt, von welchem ​​Pixel gelesen werden soll. Wenn das von uns verwendete 3D-Modell relativ flach ist und eine UV-Umwandlung aufweist, können wir seine UV-Strahlung verwenden, um eine zufällige Textur abzutasten.</font></font><br><br><pre> <code class="cpp hljs">N = WavesNormal(IN.uv_SandTex.xy, N); N = SandNormal (IN.uv_SandTex.xy, N);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternativ können Sie auch die Position </font></font><code>IN.worldPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des gerenderten Punkts </font><font style="vertical-align: inherit;">in der Welt ( </font><font style="vertical-align: inherit;">) verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt können wir uns endlich auf </font></font><code>SandNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Umsetzung konzentrieren. </font><font style="vertical-align: inherit;">Wie bereits erwähnt, besteht die Idee darin, ein Pixel aus einer zufälligen Textur abzutasten und es (nach der Konvertierung in einen Einheitsvektor) als neue Norm zu verwenden.</font></font><br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie zoome ich zufällige Textur?</font></font></b> <div class="spoiler_text">    UV- 3D-      ,   .      ,       . <br><br>   ,  Unity   .   ,        <code>_SandText_ST</code> . Unity       (  ) <code>_SandTex</code> . <br><br>  <code>_SandText_ST</code>    :     .        ,          <em>Tiling</em>  <em>Offset</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/a84/059/f29a84059ab970f412217f09c87fcf6f.png"></div><br>       ,     <code>TRANSFORM_TEX</code> : <br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; float4 _SandTex_ST; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, TRANSFORM_TEX(uv, _SandTex)).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kippen Sie die Normalen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das oben gezeigte Code-Snippet funktioniert, führt aber nicht zu sehr guten Ergebnissen. Der Grund dafür ist einfach: Wenn wir nur eine völlig zufällige Norm zurückgeben, aber im Wesentlichen das Gefühl der Krümmung verlieren. Tatsächlich wird die Richtung der Normalen verwendet, um zu berechnen, wie Licht von der Oberfläche reflektiert werden soll, und der Hauptzweck besteht darin, das Modell entsprechend seiner Krümmung zu schattieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Unterschied ist in den folgenden Bildern zu sehen. Oben sind die Normalen der Dünen völlig zufällig und es ist unmöglich zu verstehen, wo eine endet und eine andere beginnt. Von unten wird nur die Normale des Modells verwendet, wodurch wir eine zu glatte Oberfläche erhalten.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/9cb/acb/6209cbacb616db15bee5f95e314779c8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/476/f0a/f25/476f0af2535dc2d552ce4b01a1d7751a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Lösungen passen nicht zu uns. </font><font style="vertical-align: inherit;">Wir brauchen etwas dazwischen. </font><font style="vertical-align: inherit;">Eine zufällige Richtung, die aus einer Textur abgetastet wurde, sollte verwendet werden, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um die</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Normale um einen bestimmten Betrag </font><font style="vertical-align: inherit;">zu </font><em><font style="vertical-align: inherit;">neigen</font></em><font style="vertical-align: inherit;"> , wie unten gezeigt:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/929/dfb/7e6/929dfb7e6d4712b7c69a403d0733c25b.png" width="239" height="240"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die im Diagramm beschriebene Operation heißt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slerp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und steht für </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sphärische lineare Interpolation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (sphärische lineare Interpolation). </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slerp</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funktioniert mit einer Ausnahme genauso wie lerp - es kann verwendet werden, um sicher zwischen Einheitsvektoren zu interpolieren, und das Ergebnis der Operation sind andere Einheitsvektoren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leider ist die korrekte Implementierung von slerp ziemlich teuer. </font><font style="vertical-align: inherit;">Und für einen Effekt, der zumindest zufällig ist, ist es unlogisch, ihn zu verwenden.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeigen Sie mir die Slerp-Gleichung</font></font></b> <div class="spoiler_text">    , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-204"><span class="MJXp-msubsup" id="MJXp-Span-205"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-206" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-207" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-43">p_0</script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-208"><span class="MJXp-msubsup" id="MJXp-Span-209"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-210" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-211" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-44">p_1</script>   ,       .  Dann <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-212"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-213">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-214">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-215">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-216">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-217">p</span></span></span><script type="math/tex" id="MathJax-Element-45">slerp</script>    : <br><br>  (1) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-218"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-219">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-220">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-221">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-222">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-223">p</span><span class="MJXp-mrow" id="MJXp-Span-224"><span class="MJXp-mo" id="MJXp-Span-225" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-226"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-227" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-228" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-229" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-230"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-231" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-232" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-233" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-234">t</span><span class="MJXp-mo" id="MJXp-Span-235" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span><span class="MJXp-mo" id="MJXp-Span-236" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mfrac" id="MJXp-Span-237" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-238">sin</span><span class="MJXp-mo" id="MJXp-Span-239" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-240"><span class="MJXp-mo" id="MJXp-Span-241" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-242"><span class="MJXp-mo" id="MJXp-Span-243" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-244">1</span><span class="MJXp-mo" id="MJXp-Span-245" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-246">t</span><span class="MJXp-mo" id="MJXp-Span-247" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mi" id="MJXp-Span-248">Ω</span><span class="MJXp-mo" id="MJXp-Span-249" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-250">sin</span><span class="MJXp-mo" id="MJXp-Span-251" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-252"><span class="MJXp-mo" id="MJXp-Span-253" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-254">Ω</span><span class="MJXp-mo" id="MJXp-Span-255" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-256"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-257" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-258" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-259" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mfrac" id="MJXp-Span-260" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-261">sin</span><span class="MJXp-mo" id="MJXp-Span-262" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-263"><span class="MJXp-mo" id="MJXp-Span-264" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-265">t</span><span class="MJXp-mi" id="MJXp-Span-266">Ω</span><span class="MJXp-mo" id="MJXp-Span-267" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-268">sin</span><span class="MJXp-mo" id="MJXp-Span-269" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-270"><span class="MJXp-mo" id="MJXp-Span-271" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-272">Ω</span><span class="MJXp-mo" id="MJXp-Span-273" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-274"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-275" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-276" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-46">\begin{equation*} slerp\left(p_0, p_1, t\right) = \frac{\sin\left[\left(1-t\right)\Omega\right]}{\sin\left(\Omega\right)}p_0 + \frac{\sin\left(t\Omega\right)}{\sin\left(\Omega\right)} p_1 \end{equation*}</script> </math></p><br>  wo <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-277"><span class="MJXp-mi" id="MJXp-Span-278">Ω</span></span></span><script type="math/tex" id="MathJax-Element-47">\Omega</script> —     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-279"><span class="MJXp-msubsup" id="MJXp-Span-280"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-281" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-282" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-48">p_0</script>  und <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-283"><span class="MJXp-msubsup" id="MJXp-Span-284"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-285" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-286" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-49">p_1</script> ,       : <br><br>  (2) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-287"><span class="MJXp-mi" id="MJXp-Span-288">Ω</span><span class="MJXp-mo" id="MJXp-Span-289" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-290">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-291">o</span><span class="MJXp-msubsup" id="MJXp-Span-292"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-293" style="margin-right: 0.05em;">s</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-294" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-295">−</span><span class="MJXp-mn" id="MJXp-Span-296">1</span></span></span><span class="MJXp-mrow" id="MJXp-Span-297"><span class="MJXp-mo" id="MJXp-Span-298" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-299"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-300" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-301" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-302" style="margin-left: 0.267em; margin-right: 0.267em;">⋅</span><span class="MJXp-msubsup" id="MJXp-Span-303"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-304" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-305" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-306" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-50">\begin{equation*} \Omega=cos^{-1} \left(p_0 \cdot p_1 \right) \end{equation*}</script> </math></p><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist wichtig zu beachten, dass bei Verwendung der traditionellen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linearen Interpolation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der resultierende Vektor sehr unterschiedlich aussieht:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/5e1/42f/eef5e142f1c8c05cac9b3d4f18d8e097.png" width="239" height="240"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Lerp-Operation zwischen zwei getrennten Einheitsvektoren erzeugt nicht immer andere Einheitsvektoren. </font><font style="vertical-align: inherit;">Tatsächlich passiert dies nie, es sei denn, der Koeffizient ist</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-307"><span class="MJXp-mn" id="MJXp-Span-308"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-51-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-51">1</script>  oder <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-309"><span class="MJXp-mn" id="MJXp-Span-310"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-52-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-52">0</script>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trotzdem erhalten wir beim Normalisieren des Lerp-Ergebnisses tatsächlich einen Einheitsvektor, der dem Ergebnis von slerp erstaunlich nahe kommt: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nlerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 n1, float3 n2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> normalize(lerp(n1, n2, t)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese als </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nlerp bezeichnete</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Technik </font><font style="vertical-align: inherit;">liefert eine enge Annäherung an slerp. </font><font style="vertical-align: inherit;">Seine Verwendung wurde von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casey Muratori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , einem der Entwickler von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Witness,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> populär gemacht </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn Sie mehr über dieses Thema </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erfahren möchten</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , empfehle ich, </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">Slerp-Artikel zu verstehen. </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">Dann </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">benutze ich es </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">nicht von </font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonathan Blow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Math Magician - Lerp, Slerp und Nlerp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dank nlerp können wir jetzt normale Vektoren effizient auf eine zufällige Seite kippen, die abgetastet wird von </font></font><code>_SandTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _SandStrength; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); // Rotates N towards Ns based on _SandStrength float3 Ns = nlerp(N, S, _SandStrength); return Ns; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Ergebnis ist unten dargestellt: </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rddUAStRjZ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Was weiter </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im nächsten Teil betrachten wir die flackernden Reflexionen, dank denen die Dünen dem Ozean ähneln. </font></font><br><br><h3>  Danksagung </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Videospiel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Journey</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wurde </font><font style="vertical-align: inherit;">von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thatgamecompany entwickelt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sony Computer Entertainment veröffentlicht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es ist für PC ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Epic Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und PS4 ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">verfügbar </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jiadi Deng werden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3D-Modelle von </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">Dünenhintergründen</font></a><font style="vertical-align: inherit;"> und Beleuchtungsoptionen erstellt </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein 3D-Modell von Journeys Charakter wurde im (jetzt geschlossenen) FacePunch-Forum gefunden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einheitspaket </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diesen Effekt wiederherstellen möchten, können Sie das vollständige Unity-Paket von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunterladen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es enthält alles, was Sie brauchen, vom Shader bis zum 3D-Modell.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de476448/">https://habr.com/ru/post/de476448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de476434/index.html">Wir schreiben USB-Treiber für verlassene Geräte</a></li>
<li><a href="../de476436/index.html">Berichte vom ersten Treffen der Roboterentwickler in Russland über das Roboterbetriebssystem</a></li>
<li><a href="../de476442/index.html">Geben Sie etwas Platz oder einen Mikrocontroller wie ein Frequenzmesser</a></li>
<li><a href="../de476444/index.html">Entmystifizierung der Prinzipien des Quantencomputers</a></li>
<li><a href="../de476446/index.html">Jira Plugins: Einige Beispiele für die erfolgreiche Erfindung des Fahrrads</a></li>
<li><a href="../de476450/index.html">Überblick über cPanel - eine webbasierte Konsole zum Verwalten von Websites und zum Hosten</a></li>
<li><a href="../de476452/index.html">Speichern von Schlüsselwerten oder wie unsere Anwendungen komfortabler geworden sind</a></li>
<li><a href="../de476454/index.html">5G kommt: Welche Unternehmen werden die Einführung neuer Technologien im Jahr 2020 sicherstellen?</a></li>
<li><a href="../de476456/index.html">Das chinesische Sozialkredit-System ist in erster Linie kein Bürgerbewertungssystem, sondern ein massives API</a></li>
<li><a href="../de476460/index.html">Das erste Hit-Dateiformat im Internet war nicht MP3, sondern MIDI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>