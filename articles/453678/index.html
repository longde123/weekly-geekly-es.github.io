<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèáüèª üë®‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üëçüèª C√≥mo ver la reverberaci√≥n o la transmisi√≥n de video por sonido a trav√©s del agua - 2 üîí üëÜüèø ‚ùé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola querida 

 Hoy volveremos a transmitir la imagen con ultrasonido a trav√©s del agua: literalmente veremos reverberaci√≥n y eco, e incluso c√≥mo camb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo ver la reverberaci√≥n o la transmisi√≥n de video por sonido a trav√©s del agua - 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453678/"><h3>  Hola querida </h3><br><br>  Hoy volveremos a transmitir la imagen con ultrasonido a trav√©s del agua: literalmente veremos reverberaci√≥n y eco, e incluso c√≥mo cambian seg√∫n las condiciones.  Todo lo que le dir√© es simple, es interesante repetirlo yo mismo y casi cualquier persona puede hacerlo. <br><br>  Si algo est√° revoloteando en tu alma por estas palabras, ¬°bienvenido a Kat a las aguas oscuras de nuestro estanque! <br><br><img src="https://habrastorage.org/webt/e7/dd/ql/e7ddqlsffkcu34ex7scxfsvt4fs.png"><br><a name="habracut"></a><br><br><blockquote>  "El mejor descanso es interpretar verdades conocidas".  (C) ABS, mediod√≠a, siglo XXII </blockquote><br><br><h3>  Juegos previos </h3><br>  La regla b√°sica del club de testigos de hidroac√∫stica es que el video que usa hidroac√∫stica a una distancia m√°s o menos significativa (m√°s de unos pocos metros) en el cuerpo medio de agua no se puede transmitir, y siempre ser√° imposible. <br>  Existen serias razones para esto: un canal de comunicaci√≥n con un ancho de banda muy bajo, una velocidad de propagaci√≥n de se√±al baja (en agua de solo 1,500 m / s) y una alta probabilidad de error.  La banda de frecuencia disponible es solo unas pocas decenas de kilohercios. <br>  Pero esto no es todo: si, en t√©rminos relativos, una se√±al a frecuencias del orden de 10 kHz se propaga en el agua a una distancia de aproximadamente 8-10 km, entonces a una frecuencia de 20 kHz ya es de 3-5 km, y cuanto mayor sea la frecuencia, mayor ser√° la atenuaci√≥n .  Por ejemplo, nuestros m√≥dems <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uWAVE</a> m√°s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">peque√±os</a> del mundo operan en la banda de 20-30 kHz y transmiten datos a una velocidad de 78 bit / s por 1000 metros, y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RedLINE</a> con una banda de 5-15 a 8000 metros.  El r√©cord entre dispositivos comerciales pertenece a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">EvoLogics</a> : 68 kBits por 300 metros. <br>  La f√≠sica, por desgracia, no puede ser enga√±ada y es imposible estar de acuerdo con ella: puede transmitirse de forma muy lenta e inmune al ruido, o r√°pidamente, pero a distancias cortas. <br>  Sin embargo, en algunos casos es posible "cortar algunas esquinas", las cuales cortaremos esta vez son m√°s bajas. <br><br><h3>  ¬øQu√© haremos hoy y qu√© se necesita para esto? </h3><br>  En art√≠culos anteriores, ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transmitimos "video" con sonido a trav√©s del agua</a> , les recuerdo que all√≠ el cuadro fue "dibujado en el espectro", es decir, el espectro, o m√°s bien el espectrograma de la se√±al era una imagen. <br>  M√°s tarde fabricamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">antenas hidroac√∫sticas simples a partir de escombros</a> e hicimos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√≥dem hidroac√∫stico simple</a> .  All√≠ tambi√©n hicimos un preamplificador para la antena (el dise√±o de la PCB para la autoproducci√≥n por LUT-ohm todav√≠a se encuentra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ). <br><br>  Pensamos, ¬øde qu√© otra manera puedes tratar de transmitir la imagen para que incluso un estudiante de <s>jard√≠n de infantes</s> pueda resolverlo? Y, como nos parece a nosotros, se les ocurri√≥ una forma a√∫n m√°s simple que antes. <br><br>  Entonces, para resumir, elabore una lista de lo que necesitamos: <br><br>  - un par de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">antenas</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sonar de recolectores de pastel</a> <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">preamplificador</a> fabricado por LUT <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo fuente del</a> proyecto C # <br>  - un par de bater√≠as de plomo a 12 voltios <br>  - un amplificador en TDA, tom√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno</a> por solo 50 rublos en Ali <br><br><h3>  Poco de teor√≠a </h3><br>  Recuerde que nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√≥dem de sonda</a> se bas√≥ en un detector de tono simple, cuya frecuencia es 4 veces menor que la frecuencia de muestreo.  Recuerda brevemente c√≥mo funciona. <br><img src="https://habrastorage.org/webt/__/zm/oe/__zmoe1u0jzgjderykrsaogn0k8.png"><br><br>  La imagen muestra dos oscilaciones desplazadas entre s√≠ en Pi / 2, es decir, las fases seno y coseno.  Y si la frecuencia es exactamente cuatro veces menor que la frecuencia de muestreo, entonces solo 4 muestras caen en el per√≠odo. <br>  Un habuchitel atento ciertamente not√≥ que ambas se√±ales se desplazan a Pi / 4.  Con este cambio, la se√±al solo toma dos valores: ‚àö2 / 2 y -‚àö2 / 2. <br>  Y los valores espec√≠ficos ni siquiera son importantes, es importante que pueda usar solo los signos: "+" y "-". <br><br>  Ahora podemos representar la fase sinusoidal como una secuencia de signos "+" "+" "-" "-", y la fase cosenoidal como "+" "-" "-" "+". <br><br><div class="spoiler">  <b class="spoiler_title">Debajo del spoiler, repita el detector:</b> <div class="spoiler_text"> Deje que la se√±al de entrada est√© en el b√∫fer sn, tenemos dos b√∫feres de promedio de anillo para las fases seno y coseno - bs y bc de tama√±o N. Tienen punteros comunes de cabeza y cola - bH y bT.  En el momento inicial del tiempo, bH = N-1, bT = 0. Contador de ciclo promedio C = 0. <br>  Tomamos 4 muestras del b√∫fer de entrada y las agregamos de acuerdo con las secuencias de caracteres. <br><br> <code>a = sn(i) <br> bs(bH) = a <br> bc(bH) = a <br> s1 = s1 + a - bs(bT) <br> s2 = s2 + a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+1) <br> bs(bH) = a <br> bc(bH) = -a <br> s1 = s1 + a - bs(bT) <br> s2 = s2 - a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+2) <br> bs(bH) = -a <br> bc(bH) = -a <br> s1 = s1 - a - bs(bT) <br> s2 = s2 - a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br> <br> a = sn(i+3) <br> bs(bH) = -a <br> bc(bH) = a <br> s1 = s1 - a - bs(bT) <br> s2 = s2 + a - bc(bT) <br> bH = (bH + 1) % N <br> bT = (bT + 1) % N <br></code> <br><br>  Despu√©s de cada cuatro muestras procesadas, verificamos el contador de los ciclos de promedio y si ha excedido N, entonces calculamos la amplitud cA de la portadora: <br><br> <code>if ++cycle &gt;= N <br> cA = sqrt(s1 * s1 + s2 * s2) <br> cycle = 0 <br> end <br></code> <br></div></div><br><br>  Tomamos este m√©todo como base, ser√° responsable de la "sincronizaci√≥n". <br>  Ahora veamos c√≥mo se codifica la imagen.  Sugiero usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manipulaci√≥n de amplitud</a> .  La manipulaci√≥n es cuando una se√±al se divide en segmentos iguales llamados chips o s√≠mbolos, y alg√∫n par√°metro variable (en nuestro caso, la amplitud) se almacena a lo largo de la longitud del chip. <br>  Si, por ejemplo, podemos variar la amplitud en el rango de 0 a 32767 (muestras de 16 bits), y necesitamos transferir 255 valores del brillo de los p√≠xeles, entonces, por unidad de cambio en el brillo del p√≠xel, la amplitud del chip cambiar√° a 32768/255 = 128. <br>  Otro par√°metro importante es la longitud del chip, comenzamos con un per√≠odo de soporte, cuatro muestras en nuestro caso. <br>  Entonces, la imagen se transmitir√° p√≠xel por p√≠xel, cada p√≠xel dura 4 muestras, y la amplitud para este per√≠odo ser√° b [x, y] * 128, donde b [x, y] es el valor de brillo del p√≠xel con las coordenadas x e y en la imagen b. <br><br>  Vamos a estimar cu√°l ser√° la velocidad de transmisi√≥n. <br>  En el ejemplo, utilic√© un tama√±o de cuadro de 120x120 p√≠xeles.  Esto significa que para transferir un cuadro, necesitamos <br><br>  120x120x4 = 57600 muestras, <br><br>  Si la frecuencia de muestreo es de 96 kHz, la transmisi√≥n de un cuadro llevar√° tiempo: <br><br>  57600/96000 = 0.6 segundos <br><br>  Obviamente, necesitamos alg√∫n tipo de pausa, un cierto intervalo de guarda, para que el detector pueda determinar el comienzo del siguiente cuadro.  Por razones humanas, supongamos que 0.1 segundos son suficientes para nosotros, durante los cuales todos los ecos desaparecen (en realidad no).  Luego, al final, la tasa de transferencia resultar√°: <br><br>  1 / (0.6 + 0.1) = 1.428 cuadros por segundo. <br><br>  Aqu√≠ es muy f√°cil cometer un error e intentar calcular la velocidad en bits por segundo.  Vea lo incre√≠ble que es la velocidad de transmisi√≥n: <br><br>  120 * 120 * 8 / 1.428 = 80627 bps <br><br>  Pero, ¬øqu√© sucede si no tengo p√≠xeles de 8 bits, sino de 16 bits? <br><br>  120 * 120 * 16 / 1.428 = 161344 bps <br><br>  El problema aqu√≠ es que, nuevamente, este m√©todo de transmisi√≥n no puede llamarse digital, y el concepto de velocidad de bits no es completamente v√°lido para √©l. <br>  Intente calcular la velocidad de bits para una se√±al de televisi√≥n anal√≥gica.  ¬øY para el receptor detector?  :) <br><br>  Entonces, por ejemplo, se ver√° una parte de la se√±al, transmitiendo el brillo de 10 p√≠xeles, cuyos valores cambian alternativamente: 1 2 1 2 1 2 1 2 1 2 <br><img src="https://habrastorage.org/webt/ul/kz/st/ulkzsthqa8tt4ykb7stgu7hehqe.png"><br><br>  Ahora veamos c√≥mo funciona esto en el ejemplo.  Los m√©todos Encode y Decode viven en la clase <a href="">Encoder</a> y son responsables de modular y demodular la imagen: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Encode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Bitmap source, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> carrier, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interframePauseMs</span></span></span><span class="hljs-function">)</span></span> { Bitmap frame; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.PixelFormat != System.Drawing.Imaging.PixelFormat.Format8bppIndexed) frame = Grayscale.CommonAlgorithms.RMY.Apply(source); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> frame = source; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!frame.Size.Equals(frameSize)) frame = resizer.Apply(frame); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cols = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> row = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * carrier / sampleRate; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> phase = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxAmplitude = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * chipSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span>; List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; samples = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isFinished = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; pSize; i++) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= pLimit) { phase -= pLimit; } samples.Add(alpha * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isFinished) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= chipLimit) { phase -= chipLimit; pxAmplitude = (((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)frame.GetPixel(col, row).R) / <span class="hljs-number"><span class="hljs-number">255.0</span></span>) * <span class="hljs-keyword"><span class="hljs-keyword">short</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++col &gt;= cols) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++row &gt;= rows) isFinished = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } samples.Add(alpha * pxAmplitude); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interframePauseMs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { samples.AddRange(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((((<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)interframePauseMs) / <span class="hljs-number"><span class="hljs-number">1000.0</span></span>) * (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)sampleRate)]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> samples.ToArray(); }</code> </pre><br><br>  Se puede ver en el c√≥digo que antes de modular la imagen, se agrega un prefijo de sincronizaci√≥n que consiste en un tono puro (muestras pSize) a la se√±al de salida; esto es necesario para que en el lado receptor pueda ocurrir una sincronizaci√≥n antes de que la imagen misma <s>y en general pueda ocurrir</s> en condiciones adversas. <br>  El m√©todo de decodificaci√≥n es el siguiente: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Decode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] samples, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> carrier, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cols = frameSize.Width; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rows = frameSize.Height; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> col = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> row = <span class="hljs-number"><span class="hljs-number">0</span></span>; Bitmap result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(cols, rows); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> delta = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * carrier / sampleRate; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> phase = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipLimit = Math.PI * <span class="hljs-number"><span class="hljs-number">2</span></span> * chipSize; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> chipAmplitude = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> maxAmplitude = WaveUtils.GetMaxAmplitude(samples); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxMax = -maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> pxMin = maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> smp; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = pSize; (i &lt; samples.Length) &amp;&amp; (row &lt; rows); i++) { alpha = Math.Sin(phase); phase += delta; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (phase &gt;= chipLimit) { phase -= chipLimit; chipAmplitude = (Math.Max(Math.Abs(pxMax), Math.Abs(pxMin)) / maxAmplitude); pxMin = maxAmplitude; pxMax = -maxAmplitude; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gs = Convert.ToByte(chipAmplitude * <span class="hljs-number"><span class="hljs-number">255</span></span>); result.SetPixel(col, row, Color.FromArgb(<span class="hljs-number"><span class="hljs-number">255</span></span>, gs, gs, gs)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++col &gt;= cols) { col = <span class="hljs-number"><span class="hljs-number">0</span></span>; row++; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { smp = samples[i] * alpha; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smp &gt; pxMax) pxMax = smp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smp &lt; pxMin) pxMin = smp; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  Se puede ver que ambos m√©todos no est√°n vinculados a ninguna frecuencia en particular y se pueden usar con otro detector. <br><br>  La b√∫squeda de se√±al en s√≠ misma (detecci√≥n, sincronizaci√≥n) tambi√©n se produce como en nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√≥dem hidroac√∫stico m√°s simple</a> , con la √∫nica diferencia de que lo puse en una clase separada <a href="">FsBy4CarrierDetector</a> para un cambio. <br>  Toda la magia sin complicaciones ocurre en el m√©todo bool ProcessSample (breve a) <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessSample</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { ring1[ringHead] = a; ring2[ringHead] = a; s1 += a - ring1[ringTail]; s2 += a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">1</span></span>) { ring1[ringHead] = a; ring2[ringHead] = -a; s1 += a - ring1[ringTail]; s2 += - a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">2</span></span>) { ring1[ringHead] = -a; ring2[ringHead] = -a; s1 += -a - ring1[ringTail]; s2 += -a - ring2[ringTail]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (smpCount == <span class="hljs-number"><span class="hljs-number">3</span></span>) { ring1[ringHead] = -a; ring2[ringHead] = a; s1 += -a - ring1[ringTail]; s2 += a - ring2[ringTail]; } ringHead = (ringHead + <span class="hljs-number"><span class="hljs-number">1</span></span>) % ringSize; ringTail = (ringTail + <span class="hljs-number"><span class="hljs-number">1</span></span>) % ringSize; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++smpCount &gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>) { smpCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++cycle &gt;= ringSize) { s = Math.Sqrt(s1 * s1 + s2 * s2) / ringSize; cycle = <span class="hljs-number"><span class="hljs-number">0</span></span>; result = (s - sPrev) &gt;= Threshold; sPrev = s; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><br>  Se llama en cada muestra entrante y devuelve verdadero en caso de detecci√≥n de portadora. <br><br>  Como el detector est√° lejos de ser perfecto y se puede sincronizar f√°cilmente en el medio de la l√≠nea, agregu√© un control deslizante especial, movi√©ndolo para que pueda lograr una sincronizaci√≥n m√°s precisa. <br><br>  Ahora, despu√©s de haber examinado brevemente c√≥mo funciona todo esto, pasemos a la parte m√°s deliciosa: lo que se puede obtener de todo esto. <br><br><h3>  Un poco de practica </h3><br>  Primero, verifiquemos c√≥mo funciona todo sin un canal de sonda, simplemente conectando las antenas de recepci√≥n y transmisi√≥n entre s√≠. <br>  Primero, la imagen es m√°s grande (240x120) para que al menos se pueda ver algo: <br><img src="https://habrastorage.org/webt/ev/ys/1t/evys1t89oks6jpvgeyxtgafgbp4.gif"><br><br>  Y luego r√°pidamente, para que haya <s>m√°s vida</s> m√°s como un video: <br><img src="https://habrastorage.org/webt/2j/2t/y_/2j2ty_dym0iowoiq_xgtf_oqdrg.gif"><br><br>  Parece que no est√° mal?  Pero no se apresure a sacar conclusiones, y vaya a la piscina: <br><img src="https://habrastorage.org/webt/_8/0u/jz/_80ujzh-1afojo46fevq6egccvg.jpeg"><br><br>  Y aqu√≠, como promet√≠ en el t√≠tulo, veremos un eco con nuestros propios ojos: <br><img src="https://habrastorage.org/webt/lb/aq/xe/lbaqxezsgyzwjik0zxymshqjysi.gif"><br><br>  ¬ø <s>Qu√© te parece eso, Elon Musk?</s>  ¬øTe gusta la HD?  ¬øPor qu√© es esto as√≠? <br>  Y todo es muy simple: el eco, de hecho, son las copias retrasadas de la se√±al original, que interfieren con ella en el punto de recepci√≥n, se pliegan en una fase diferente y dan esa imagen.  Como transferimos la imagen, al final obtenemos muchas im√°genes superpuestas entre s√≠ con diferentes amplitudes.  Todo esto finalmente conduce a la falta de definici√≥n y reproducci√≥n. <br><br>  Mirando hacia atr√°s, verifiquemos todo en la imagen grande del modelo.  Tom√© una foto al azar: <br><img src="https://habrastorage.org/webt/oo/hd/jb/oohdjbgoj4pqq-k8f9st0b9rdre.jpeg"><br><br>  Lo modul√©, luego agregu√© un eco y un poco de ruido, luego lo decodifiqu√© y s√≠, el resultado se parece a lo que obtuvimos en el grupo: <br><img src="https://habrastorage.org/webt/bk/dp/y_/bkdpy_9ztpti3b91ulbakqzokes.png"><br><br>  En principio, es posible llevar a cabo la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desconvoluci√≥n</a> y restar reflexiones, pero <s>dejemos que las personas de fuera de nuestra √°rea</s> dejen este punto para un trabajo independiente. <br><br>  Por cierto, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√©todo anterior</a> en el grupo funciona un poco mejor, pero tambi√©n mal: en las se√±ales de banda ancha, la trayectoria m√∫ltiple y la reverberaci√≥n conducen a un desvanecimiento selectivo de frecuencia, que en la imagen (le√≠da en el espectro) se ve como rayas en blanco y negro, donde la se√±al est√° en antifase, y donde se desarroll√≥ en fase (de hecho, todav√≠a hay un mont√≥n de opciones intermedias): <br><img src="https://habrastorage.org/webt/zo/f-/pp/zof-ppqayi-rbz2h9yfgjlvc8da.gif"><br><br>  En abril, aprovechamos el momento y fuimos al estanque con una maqueta de pan y nos mimamos all√≠ tambi√©n: <br><img src="https://habrastorage.org/webt/mv/c-/v4/mvc-v4-m9tys6na8hip-8t8kzyc.jpeg"><br><br><img src="https://habrastorage.org/webt/pp/wc/8u/ppwc8uemc0xlmsmt_rz5h24s664.jpeg"><br><br>  El resultado no es muy diferente de los resultados obtenidos en el grupo: <br><img src="https://habrastorage.org/webt/1-/8j/et/1-8jetei8ly02aanoubjimfhlty.png"><br><br><img src="https://habrastorage.org/webt/_o/1q/ij/_o1qijulzi1p0pqxmch5dijhrcc.png"><br><br>  E inmediatamente para comparaci√≥n, el m√©todo anterior: <br><img src="https://habrastorage.org/webt/dh/8o/nk/dh8onkjtu5jly6kr7ios0k3td44.png"><br><br>  Y aqu√≠ est√°n las animaciones gif recopiladas de los cuadros guardados, m√©todo 1: <br><img src="https://habrastorage.org/webt/b7/bq/nz/b7bqnzrvtoa1jkbc0cj4h0okv-u.gif"><br><br>  Y el m√©todo 2, que discutimos en este art√≠culo: <br><img src="https://habrastorage.org/webt/of/vg/gb/ofvggbrbktqq30iy0ihoybpx6le.gif"><br><br><h3>  En conclusi√≥n </h3><br>  Como prometimos, mostramos c√≥mo el eco y la reverberaci√≥n se ven literalmente, pasamos tiempo con beneficio e hicimos algo con nuestras manos. <br><br>  En esta forma, por supuesto, el m√©todo no es aplicable en la pr√°ctica, pero trabajar con √©l ser√° muy √∫til para los principiantes. <br><br>  En general, verificamos en un estanque poco profundo, donde las condiciones son muy desfavorables, y ser√≠a genial si alguien repitiera nuestros experimentos en otros embalses y ciertamente informara sobre sus resultados. <br><br>  Si el lector solo quiere probar (incluso en el aire con un micr√≥fono y altavoces), aqu√≠ est√°n los enlaces a los lanzamientos: <br>  <a href="">M√©todo 1</a> <br>  <a href="">M√©todo 2 (de este art√≠culo)</a> <br><br><h3>  PS </h3>  Realmente esperamos comentarios de los lectores, ya que es muy importante entender que est√° haciendo algo en vano (o en vano, y luego esto debe detenerse de inmediato). <br><br><h3>  PS / 2 </h3>  Contestar√© una pregunta com√∫n de inmediato: para los peces y otras especies marinas en esas instalaciones infantiles, todo esto es imperceptible. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453678/">https://habr.com/ru/post/453678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453664/index.html">Spring Boot - OAuth2 y JWT</a></li>
<li><a href="../453666/index.html">C√≥mo mont√© un taxi no tripulado</a></li>
<li><a href="../453668/index.html">10 errores de un joven RO (parte I - tres errores)</a></li>
<li><a href="../453672/index.html">CardInfo: API para determinar el logotipo, los colores del banco y otras cosas por n√∫mero de tarjeta</a></li>
<li><a href="../453676/index.html">Conexi√≥n a Windows a trav√©s de SSH como en Linux</a></li>
<li><a href="../453682/index.html">Desarrollo del "firmware" m√°s simple para FPGAs instalados en Redd. Parte 2. C√≥digo del programa</a></li>
<li><a href="../453686/index.html">Semana de la seguridad 22: estad√≠sticas de amenazas, troyanos bancarios y haza√±as populares</a></li>
<li><a href="../453688/index.html">Java no solo es una empresa sangrienta, sino tambi√©n aplicaciones r√°pidas sensibles a la latencia</a></li>
<li><a href="../453692/index.html">Shaders 3D para principiantes: efectos</a></li>
<li><a href="../453694/index.html">Con√©ctese a Windows a trav√©s de SSH como en Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>