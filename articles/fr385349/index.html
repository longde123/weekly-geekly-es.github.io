<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>▪️ 🍭 🏂🏾 Arduino Mega Server et horloge en temps réel 🕺🏻 🥢 🎑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, vous apprendrez comment fonctionne Arduino Mega Server au fil du temps et comment créer des projets sur Arduino qui sont liés en tem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arduino Mega Server et horloge en temps réel</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/385349/"><img src="https://habrastorage.org/files/ce4/e16/81f/ce4e1681f98841af80ec3eeef2fce455.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet article, vous apprendrez comment fonctionne Arduino Mega Server au fil du temps et comment créer des projets sur Arduino qui sont liés en temps réel, qu'ils aient ou non un module RTC «iron» installé. </font><font style="vertical-align: inherit;">Toutes les questions de travail en temps réel sur Arduino seront discutées en détail et après avoir lu cet article, vous deviendrez un véritable "horloger".</font></font><br>
<a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essence de la question</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout projet plus ou moins sérieux sur Arduino devrait avoir une idée du temps réel actuel. Par exemple, les lectures des capteurs doivent être limitées dans le temps (sinon il serait impossible de générer des statistiques et même des graphiques élémentaires), le contrôleur doit effectuer certaines actions en fonction de l'heure actuelle de la journée, des week-ends, des vacances, etc. Si votre contrôleur n'a aucune idée en temps réel, il se transforme en une machine simple qui ne peut effectuer des actions de base que sur un programme défini de manière rigide. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depuis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arduino Mega Server</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c'est un système puissant et développé, alors cet état de fait (manque de travail en temps réel) ne pouvait pas me convenir, ainsi qu'à tous les autres utilisateurs du système. </font><font style="vertical-align: inherit;">Par conséquent, la question de l'intégration dans le système RTC était l'une des premières à l'ordre du jour.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horloge virtuelle en temps réel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout irait bien, mais ni moi, ni la plupart des utilisateurs d'AMS ne disposions du même module RTC «de fer», il a donc été décidé de faire une «balade à cheval» et, à titre temporaire, d'organiser des horloges en temps réel fonctionnant à l'intérieur du système, sans véritable module physique. </font><font style="vertical-align: inherit;">Qui a été mis en œuvre avec succès. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, comment organiser un RTC virtuel, sans véritable module. </font><font style="vertical-align: inherit;">Il y a une merveilleuse </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bibliothèque de temps</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui fait la part du lion du travail de nous fournir l'heure exacte. </font><font style="vertical-align: inherit;">Pour commencer à travailler avec lui, vous devez le télécharger, le décompresser et le placer sur l'emplacement standard de toutes les bibliothèques de l'environnement Arduino, à savoir dans le dossier:</font></font><br>
<br>
<pre><code class="java hljs">\rduino\libraries\
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après cela, toutes les possibilités de travailler avec le temps qu'il nous offre deviennent disponibles pour nous.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment ça fonctionne</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le principe est très simple. La bibliothèque «lance» l'horloge virtuelle «à l'intérieur» du contrôleur et offre la possibilité de les synchroniser de différentes manières, au choix. Vous pouvez choisir la méthode qui vous convient le mieux. Étant donné que l'Arduino Mega Server est un périphérique réseau, l'option de synchronisation de l'horloge via le réseau avec l'heure exacte des serveurs a été choisie. Il peut s'agir de serveurs sur Internet ou de serveurs sur le réseau local sur lequel le service correspondant s'exécute. Par exemple, dans la version de base d'AMS, l'horloge est synchronisée avec le serveur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MajorDoMo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et vous n'avez rien à configurer pour cela, tout fonctionne par </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">défaut</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, pour que cela fonctionne, vous devez connecter les bibliothèques appropriées au début de l'esquisse.</font></font><br>
<br>
<pre><code class="java hljs">#include &lt;SPI.h&gt;<font></font>
#include &lt;Ethernet.h&gt;<font></font>
#include &lt;EthernetUdp.h&gt;<font></font>
#include &lt;Time.h&gt; <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier Time.h est en fait une bibliothèque pour travailler avec le temps, et le reste des fichiers est nécessaire pour travailler avec le réseau et pour synchroniser l'heure en utilisant le protocole NTP (la bibliothèque Ethernet doit également être installée sur votre ordinateur). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, vous devez spécifier l'adresse IP du serveur avec lequel vous souhaitez synchroniser l'heure</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">IPAddress <span class="hljs-title">timeServer</span><span class="hljs-params">(<span class="hljs-number">192</span>, <span class="hljs-number">168</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>)</span></span>; <span class="hljs-comment">//   MajorDoMo  </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et port correspondant</font></font><br>
<br>
<pre><code class="java hljs">unsigned <span class="hljs-keyword">int</span> localPort = <span class="hljs-number">8888</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mais il y a un point: le port 8888 convient à la synchronisation sur un réseau local, et la plupart des serveurs sur Internet n'y répondent pas, donc si vous prévoyez de synchroniser l'heure avec des serveurs de temps exacts sur Internet, il est préférable de définir le port 123:</font></font><br>
<br>
<pre><code class="java hljs">unsigned <span class="hljs-keyword">int</span> localPort = <span class="hljs-number">123</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
il ne reste plus qu'à indiquer le fuseau horaire</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> timeZone = <span class="hljs-number">4</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et créer un objet EthernetUDP</font></font><br>
<br>
<pre><code class="java hljs">EthernetUDP Udp;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À ce sujet, les opérations préparatoires peuvent être considérées comme terminées et vous pouvez décrire les fonctionnalités dont vous avez besoin pour travailler avec le temps. </font><font style="vertical-align: inherit;">Fonction d'initialisation:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rtcInit</span><span class="hljs-params">()</span> </span>{<font></font>
  Udp.begin(localPort);<font></font>
  Serial.println(<span class="hljs-string">"Waiting for NTP sync..."</span>);<font></font>
  setSyncProvider(getNtpTime);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, vous devez faire attention à la fonction</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(getNtpTime);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fonction définit la source de synchronisation horaire (dans ce cas, la synchronisation NTP via le réseau). Mais il pourrait s'agir de n'importe quelle autre source, par exemple, le module RTC physique. La performance de cette fonction conduit à l'installation d'une source de synchronisation (pour l'avenir) et, en même temps, à la synchronisation de l'heure elle-même via cette source. C'est au moment de l'exécution de cette fonction que l'heure exacte «apparaît» dans votre système. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La bibliothèque elle-même a une autre fonctionnalité intéressante,</font></font><br>
<br>
<pre><code class="java hljs">setSyncInterval(interval);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ce qui vous permet de définir l'intervalle souhaité entre les synchronisations (défini en secondes, la synchronisation elle-même se produit automatiquement, sans aucune participation de votre part). </font></font><br>
<br>
<img src="https://habrastorage.org/files/994/655/c68/994655c686114b5c897a038f300e1e61.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez maintenant utiliser l'heure exacte à l'intérieur de l'esquisse d'Arduino, par exemple, afficher les événements sur le moniteur série n'est pas facile, mais lié à une heure exacte précise. </font><font style="vertical-align: inherit;">Cela se fait en utilisant la fonction timeStamp ():</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">timeStamp</span><span class="hljs-params">()</span> </span>{<font></font>
  serialRTC();<font></font>
  Serial.print(<span class="hljs-string">" "</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
qui est un wrapper pour la fonction serialRTC ():</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serialRTC</span><span class="hljs-params">()</span> </span>{<font></font>
  Serial.print(year()); <font></font>
  Serial.print(<span class="hljs-string">"-"</span>);<font></font>
  printDigits(month());<font></font>
  Serial.print(<span class="hljs-string">"-"</span>);<font></font>
  printDigits(day());<font></font>
  Serial.print(<span class="hljs-string">" "</span>);<font></font>
  printDigits(hour());<font></font>
  Serial.print(<span class="hljs-string">":"</span>);<font></font>
  printDigits(minute());<font></font>
  Serial.print(<span class="hljs-string">":"</span>);<font></font>
  printDigits(second());<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'analyse du mécanisme de transmission et d'affichage du temps dans l'interface Web AMS dépasse le cadre de cette histoire et mérite un article séparé et, s'il y a un intérêt, nous pouvons écrire une suite et expliquer en détail comment la «magie» du temps s'affiche dans l'interface Web Arduino Mega. Serveur </font></font><br>
<br>
<img src="https://habrastorage.org/files/ca9/d1c/bec/ca9d1cbec3084d169566dbaa1cf2cf99.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, c'est tout. </font><font style="vertical-align: inherit;">C'est ainsi que les horloges virtuelles en temps réel étaient organisées dans AMS jusqu'à la version 0.12 incluse, et vous pouvez également organiser le travail avec une heure précise dans vos projets, même si vous n'avez pas de module physique pour les horloges en temps réel. </font><font style="vertical-align: inherit;">Mais ce n'est pas la fin de l'histoire, mais plutôt le début.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code de module RTC complet d'Arduino Mega Server 0.12</font></font></b><div class="spoiler_text">/*<br>
 Modul Virtual RTC<br>
 part of Arduino Mega Server project<br>
*/<br>
<br>
// Virtual RTC<br>
<br>
IPAddress timeServer(192, 168, 2, 8);<br>
unsigned int localPort = 8888; // local port to listen for UDP packets<br>
EthernetUDP Udp;<br>
<br>
const int timeZone = 4;<br>
time_t prevDisplay = 0; // when the digital clock was displayed<br>
<br>
void rtcInit() {<br>
 Udp.begin(localPort);<br>
 Serialprint(«Waiting for NTP sync… \n»);<br>
 setSyncProvider(getNtpTime);<br>
 modulRtc = 1;<br>
}<br>
<br>
void rtcWorks() {<br>
 if (timeStatus() != timeNotSet) {<br>
 if (now() != prevDisplay) { // update the display only if time has changed<br>
 setLifer();<br>
 prevDisplay = now();<br>
 //digitalClockDisplay(); <br>
 }<br>
 }<br>
}<br>
<br>
void printDigits(int digits) {<br>
 if(digits &lt; 10) {<br>
 Serial.print('0');<br>
 }<br>
 Serial.print(digits);<br>
}<br>
<br>
void serialRTC() {<br>
 Serial.print(year()); <br>
 Serial.print("-");<br>
 printDigits(month());<br>
 Serial.print("-");<br>
 printDigits(day());<br>
 Serial.print(" ");<br>
 printDigits(hour());<br>
 Serial.print(":");<br>
 printDigits(minute());<br>
 Serial.print(":");<br>
 printDigits(second());<br>
}<br>
<br>
void timeStamp() {<br>
 serialRTC();<br>
 Serial.print(" ");<br>
}<br>
<br>
void printRTC(){<br>
 serialRTC();<br>
 Serial.println();<br>
}<br>
<br>
// NTP code<br>
<br>
const int NTP_PACKET_SIZE = 48; // NTP time is in the first 48 bytes of message<br>
byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming &amp; outgoing packets<br>
<br>
#ifdef RTC_FEATURE<br>
<br>
time_t getNtpTime() {<br>
 while (Udp.parsePacket() &gt; 0); // discard any previously received packets<br>
 Serialprint(«Transmit NTP request\n»);<br>
 sendNTPpacket(timeServer);<br>
 uint32_t beginWait = millis();<br>
 while (millis() — beginWait &lt; 1500) {<br>
 int size = Udp.parsePacket();<br>
 if (size &gt;= NTP_PACKET_SIZE) {<br>
 Serialprint(«Receive NTP response\n»);<br>
 Udp.read(packetBuffer, NTP_PACKET_SIZE); // read packet into the buffer<br>
 unsigned long secsSince1900;<br>
 // convert four bytes starting at location 40 to a long integer<br>
 secsSince1900 = (unsigned long)packetBuffer[40] &lt;&lt; 24;<br>
 secsSince1900 |= (unsigned long)packetBuffer[41] &lt;&lt; 16;<br>
 secsSince1900 |= (unsigned long)packetBuffer[42] &lt;&lt; 8;<br>
 secsSince1900 |= (unsigned long)packetBuffer[43];<br>
 return secsSince1900 — 2208988800UL + timeZone * SECS_PER_HOUR;<br>
 }<br>
 }<br>
 Serialprint(«No NTP response\n»);<br>
 return 0; // return 0 if unable to get the time<br>
}<br>
<br>
// send an NTP request to the time server at the given address<br>
void sendNTPpacket(IPAddress &amp;address) {<br>
 // set all bytes in the buffer to 0<br>
 memset(packetBuffer, 0, NTP_PACKET_SIZE);<br>
 // Initialize values needed to form NTP request<br>
 // (see URL above for details on the packets)<br>
 packetBuffer[0] = 0b11100011; // LI, Version, Mode<br>
 packetBuffer[1] = 0; // Stratum, or type of clock<br>
 packetBuffer[2] = 6; // Polling Interval<br>
 packetBuffer[3] = 0xEC; // Peer Clock Precision<br>
 // 8 bytes of zero for Root Delay &amp; Root Dispersion<br>
 packetBuffer[12] = 49;<br>
 packetBuffer[13] = 0x4E;<br>
 packetBuffer[14] = 49;<br>
 packetBuffer[15] = 52;<br>
 // all NTP fields have been given values, now<br>
 // you can send a packet requesting a timestamp: <br>
 Udp.beginPacket(address, 123); //NTP requests are to port 123<br>
 Udp.write(packetBuffer, NTP_PACKET_SIZE);<br>
 Udp.endPacket();<br>
}<br>
<br>
#endif<br>
<br>
// Duration<br>
<br>
void showDuration(time_t duration) {<br>
 // prints the duration in days, hours, minutes and seconds<br>
 Serialprint(" (duration ");<br>
 if(duration &gt;= SECS_PER_DAY){<br>
 Serial.print(duration / SECS_PER_DAY);<br>
 Serialprint(" day "); <br>
 duration = duration % SECS_PER_DAY; <br>
 }<br>
 if(duration &gt;= SECS_PER_HOUR){<br>
 Serial.print(duration / SECS_PER_HOUR);<br>
 Serialprint(" hour "); <br>
 duration = duration % SECS_PER_HOUR; <br>
 }<br>
 if(duration &gt;= SECS_PER_MIN){<br>
 Serial.print(duration / SECS_PER_MIN);<br>
 Serialprint(" min "); <br>
 duration = duration % SECS_PER_MIN; <br>
 }<br>
 Serial.print(duration);<br>
 Serialprint(" sec) \n"); <br>
}<br>
<br>
void checkEvent(time_t* prevEvent) {<br>
 time_t duration = 0;<br>
 time_t timeNow = now();<br>
 <br>
 if (*prevEvent &gt; 0) {<br>
 duration = timeNow — *prevEvent;<br>
 } <br>
 if (duration &gt; 0) {<br>
 showDuration(duration);<br>
 } <br>
 *prevEvent = timeNow;<br>
}<br>
<br>
</div></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une agréable surprise</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'aurais pas été occupé à intégrer des modules RTC dans le système depuis longtemps (il y a aussi suffisamment d'autres tâches urgentes), mais ici, dans le cadre de la coopération technologique avec notre projet, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CHIPSTER a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fourni des </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">équipements</font></a><font style="vertical-align: inherit;"> de test et d'intégration dans AMS, parmi lesquels il y avait des modules Ethernet basés sur la puce </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W5500</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et ... le module d'horloge en temps réel sur la puce </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DS3231</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui s'est avéré être le plus opportun et a servi d'impulsion pour l'intégration des modules RTC dans le système. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'est avéré que la société CHIPSTER vend non seulement des équipements électroniques, mais développe également ses propres produits pour Arduino et l'automatisation sous la marque </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geegrow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et a de grands projets pour l'avenir dans cette direction, en particulier, elle a un projet pour la sortie d'une version spécialisée de l'Arduino Mega 2560 avec des fonctionnalités avancées et "affûtées" spécifiquement pour l'Arduino Mega Server. </font><font style="vertical-align: inherit;">Et, si ce forum sort, ce sera un événement très intéressant. </font><font style="vertical-align: inherit;">Mais revenons à l'horloge en temps réel.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Horloge temps réel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que le module RTC était à portée de main, ce serait un péché de ne pas l'intégrer dans le système. Heureusement, cela s'est avéré assez simple grâce à la même Time Library. Mais tout d'abord. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ceux qui ne connaissent pas, il existe deux types de modules en temps réel - «ordinaire» (généralement sur une puce DS1307) et «avancé» (sur une puce DS3231, que j'ai). La différence entre les deux est que les premières ne sont pas très précises et peuvent «s'enfuir» très rapidement et très fortement, et la seconde est une montre de haute précision avec un soin normalisé de pas plus de deux minutes par an, c'est-à-dire, réellement applicable dans la pratique. Et la précision est obtenue grâce à une conception de circuit plus complexe et à une compensation thermique intégrée.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais par programme, les deux versions des modules sont compatibles et les deux fonctionneront avec la bibliothèque et le code. </font><font style="vertical-align: inherit;">La différence ne sera que dans la précision. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et bien sûr, l'une des principales propriétés d'une horloge en temps réel est la capacité de fonctionner lorsque l'alimentation est coupée, en raison de la batterie intégrée.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connexion physique</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant comment connecter physiquement le module RTC au Arduino Mega Server ou à votre projet Arduino. Je dois dire que c'est très simple et que vous n'aurez besoin que de deux résistances et de quelques fils. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La connexion est triviale: vous devez trouver quatre contacts sur votre module - GND (masse), VCC (tension d'alimentation), SCL (signal d'horloge), SDA (données). D'autres contacts sont utilisés dans des cas rares et spécifiques et vous pouvez les ignorer. </font></font><br>
<br>
<img src="https://habrastorage.org/files/7ec/49a/566/7ec49a56688f40f2a824adef2f625774.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, nous connectons la broche GND à la masse, la broche VCC à la tension d'alimentation du contrôleur. Ici, tout est simple et aucune question ne devrait se poser.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le reste des conclusions n'est pas beaucoup plus compliqué. </font><font style="vertical-align: inherit;">Le module RTC communique avec le contrôleur via l'interface I2C, qui n'a que deux fils: synchronisation et données, et les contrôleurs Arduino ont déjà des contacts pour connecter cette interface. </font><font style="vertical-align: inherit;">L'Arduino Uno est A4 (SDA) et A5 (SCL), tandis que l'arduino Mega est D20 (SDA) et D21 (SCL). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La seule subtilité est que les broches SCL et SDA doivent être «tirées» vers la source d'alimentation via des résistances de 4,7 kΩ. </font><font style="vertical-align: inherit;">Si vous n'avez pas exactement cette cote, vous pouvez utiliser des résistances de la gamme 2 KOhm - 10 KOhm.</font></font><br>
<br>
<img src="https://habrastorage.org/files/490/875/26d/49087526d1544d56947ee66ed7b19150.jpg" alt="image"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Support logiciel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il ne reste plus qu'à ajouter la prise en charge du module dans le code AMS ou votre projet. </font><font style="vertical-align: inherit;">Comme je l'ai dit, ce sera très simple car la même Time Library fonctionnera avec le module. </font><font style="vertical-align: inherit;">Certes, nous devrons ajouter une autre bibliothèque, à savoir la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bibliothèque DS1307RTC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nous le déballons également et le mettons dans le dossier de bibliothèque standard:</font></font><br>
<br>
<pre><code class="java hljs">\rduino\libraries\
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ajoutez les lignes suivantes à votre code d'esquisse</font></font><br>
<br>
<pre><code class="java hljs">#include &lt;Wire.h&gt;<font></font>
#include &lt;DS1307RTC.h&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous sommes entièrement équipés et nous pouvons commencer à écrire le code du croquis lui-même, en travaillant avec le module physique RTC. </font><font style="vertical-align: inherit;">En fonction</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rtcInit</span><span class="hljs-params">()</span> </span>{<font></font>
  Udp.begin(localPort);<font></font>
  Serial.println(<span class="hljs-string">"Waiting for NTP sync..."</span>);<font></font>
  setSyncProvider(getNtpTime);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
remplacer la chaîne</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(getNtpTime);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sur le</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(RTC.get);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et l'heure interne de l'Arduino Mega Server (ou de votre contrôleur) sera synchronisée avec le contrôleur RTC "iron", et non avec les serveurs sur Internet ou le réseau local. </font><font style="vertical-align: inherit;">Ainsi, en appelant les fonctions setSyncProvider (getNtpTime) et setSyncProvider (RTC.get), vous pouvez manipuler les sources de synchronisation de l'heure et synchroniser l'heure comme vous le souhaitez, en fonction de diverses conditions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre fonction que vous devez connaître est</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (timeStatus() != timeNotSet) {<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ce qui vous permet de savoir si l'heure est synchronisée et, selon cette condition, de prendre les mesures nécessaires.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moment subtil</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez distinguer deux choses: le temps qui passe dans le module RTC «iron» et le temps qui passe dans votre contrôleur. Ce n'est pas la même chose. La chose «principale» pour vous est le temps dans le contrôleur, et le temps dans le module n'est qu'une source de synchronisation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais! étant donné que le temps dans le RTC physique s'épuise également progressivement, il doit également être ajusté en se synchronisant avec des sources plus précises, par exemple, des serveurs sur Internet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par conséquent, l'algorithme optimal devrait être le suivant: si possible, synchronisez ensuite toutes les horloges avec les serveurs sur Internet, si le réseau n'est pas disponible, puis nous commençons à synchroniser l'heure dans le contrôleur avec le module RTC, dès que le réseau apparaît, revenez à la synchronisation via Internet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous êtes dans des conditions extrêmes, sans accès à aucune source de synchronisation, vous pouvez ajuster manuellement le cours de l'horloge de fer de temps en temps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérons par exemple la fonction de synchronisation de l'horloge interne du contrôleur et du module RTC via le réseau:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rtcSync</span><span class="hljs-params">()</span> </span>{<font></font>
  setSyncProvider(getNtpTime);<font></font>
  Serial.println(<span class="hljs-string">"...getNtpTime..."</span>);
  <span class="hljs-keyword">if</span> (timeStatus() != timeNotSet) {<font></font>
    Serial.println(<span class="hljs-string">"...set!..."</span>);<font></font>
    time_t t = getNtpTime();<font></font>
    RTC.set(t);<font></font>
    setSyncProvider(RTC.get);<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous obtenons d'abord l'heure exacte sur le réseau.</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(getNtpTime);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
puis, en cas de succès, installez-le dans le module RTC</font></font><br>
<br>
<pre><code class="java hljs">RTC.set(t);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
puis à partir de ce module, nous définissons le temps du contrôleur</font></font><br>
<br>
<pre><code class="java hljs">setSyncProvider(RTC.get);
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lancement initial</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais ce n'est pas tout. </font><font style="vertical-align: inherit;">Il y a aussi le problème du démarrage initial, lorsque le module RTC est uniquement connecté, mais que l'heure n'est pas définie et qu'il est donc impossible de se synchroniser avec lui. </font><font style="vertical-align: inherit;">Vous devez en quelque sorte régler le bon moment. </font><font style="vertical-align: inherit;">Il y a deux façons de résoudre ce problème dans l'Arduino Mega Server: vous pouvez synchroniser le RTC physique sur le réseau (si le serveur de temps est disponible) ou en utilisant l'utilitaire Arduino Serial Commander.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour régler l'heure dans le module RTC, il suffit de ... cliquer sur le bouton. </font><font style="vertical-align: inherit;">Tout le reste sera fait pour vous par deux jeunes hommes nommés Arduino Mega Server et Arduino Serial Commander. </font><font style="vertical-align: inherit;">Si vous n'utilisez pas AMS, mais développez votre propre projet, vous pouvez prendre le code du kit de distribution Arduino Mega Server (le code est disponible et entièrement gratuit) ou chercher une solution à ce problème sur Internet (il existe plusieurs solutions).</font></font><br>
<br>
<img src="https://habrastorage.org/files/df7/2b1/c4b/df72b1c4b4594bd082d9a0b8c7cdc6c6.png" alt="image"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Version avec véritable support RTC</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arduino Mega Server, à partir de la version 0.13, prend en charge le «fer» RTC. </font><font style="vertical-align: inherit;">Vous pouvez télécharger la dernière version actuelle sur le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">site officiel du projet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et </font><font style="vertical-align: inherit;">vous pouvez </font><font style="vertical-align: inherit;">poser des questions sur le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et, bien sûr, j'exprime ma gratitude à </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CHIPSTER</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour la coopération et l'équipement fourni pour les tests et l'intégration (je vais vous parler du module W5500 et de l'accélération du fonctionnement du réseau AMS dans l'un des articles suivants). </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addition</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Une chaîne Youtube est ouverte et voici une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vidéo promo du</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arduino Mega Server, qui montre comment travailler avec un vrai système.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr385349/">https://habr.com/ru/post/fr385349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr385339/index.html">Intel a présenté le SSD le plus rapide</a></li>
<li><a href="../fr385341/index.html">Cultivée artificiellement en laboratoire, la viande sera en vente au cours des 5 prochaines années</a></li>
<li><a href="../fr385343/index.html">Un peu de magie d'Apple - nouveaux Magic Keyboard, Trackpad, Mouse et iMac</a></li>
<li><a href="../fr385345/index.html">Le marteau de Thor dans la vraie vie: aimant et scanner d'empreintes digitales</a></li>
<li><a href="../fr385347/index.html">Bitcoin computer maker 21 Bitcoin lance des cours pour développeurs</a></li>
<li><a href="../fr385351/index.html">La NASA a rejeté le projet de livraison de fret orbital de Lockheed Martin comme trop compliqué et trop cher</a></li>
<li><a href="../fr385353/index.html">Un prototype fonctionnel d'un module accélérateur de microparticules d'une longueur de 1,5 cm a été créé</a></li>
<li><a href="../fr385355/index.html">Le piratage en ligne en Australie diminue grâce à Netflix</a></li>
<li><a href="../fr385361/index.html">Windows 10 Mobile — билд 10549 доступен инсайдерам</a></li>
<li><a href="../fr385363/index.html">Vidéo du pilote automatique Tesla sur le trafic urbain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>