<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Ä üë®‚Äçüöí üôèüèø NCBI Genome Workbench: Investigaci√≥n en peligro de extinci√≥n üéì ü§ñ üë®üèø‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tecnolog√≠as inform√°ticas modernas, soluciones t√©cnicas y de software: todo esto facilita y acelera enormemente la implementaci√≥n de diversas investiga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NCBI Genome Workbench: Investigaci√≥n en peligro de extinci√≥n</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/430476/"><img src="https://habrastorage.org/getpro/habr/post_images/9ce/9dc/792/9ce9dc792e9661eba72b3692521754be.png" align="left">  Tecnolog√≠as inform√°ticas modernas, soluciones t√©cnicas y de software: todo esto facilita y acelera enormemente la implementaci√≥n de diversas investigaciones cient√≠ficas.  A menudo, la simulaci√≥n por computadora es la √∫nica forma de probar muchas teor√≠as.  El software cient√≠fico tiene sus propias caracter√≠sticas.  Por ejemplo, dicho software a menudo se somete a pruebas muy exhaustivas, pero est√° poco documentado.  Sin embargo, el software est√° escrito por personas y las personas cometen errores.  Los errores en los programas cient√≠ficos pueden poner en duda toda la investigaci√≥n.  Este art√≠culo enumerar√° docenas de problemas encontrados en el c√≥digo del paquete de software NCBI Genome Workbench. <br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El NCBI Genome Workbench</a> ofrece a los investigadores una amplia gama de herramientas para estudiar y analizar datos gen√©ticos.  Los usuarios pueden investigar y comparar datos de varias fuentes, incluidas las bases de datos del NCBI (Centro Nacional de Informaci√≥n Biotecnol√≥gica) o sus propios datos personales. <br><br>  Como se mencion√≥ anteriormente, el software cient√≠fico generalmente est√° bien cubierto por las pruebas unitarias.  Al verificar este proyecto, 85 directorios con archivos de prueba fueron excluidos del an√°lisis.  Esto es alrededor de mil archivos.  Quiz√°s esto se deba a los requisitos para probar varios algoritmos complejos que se inventan para varios estudios.  Pero la calidad del resto del c√≥digo (no el de prueba) no est√° en un nivel tan alto como nos gustar√≠a.  Sin embargo, como en cualquier proyecto en el que a√∫n no se hayan ocupado de introducir herramientas de an√°lisis de c√≥digo est√°tico :). <br><br>  Los datos para la revisi√≥n (o incluso la investigaci√≥n) del c√≥digo fueron proporcionados por el analizador de c√≥digo est√°tico para C / C ++ / C # / Java - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PVS-Studio</a> . <br><br><h2>  Solo dos n√∫meros que arruinan tu proyecto </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dad/9f3/20b/dad9f320b84473428205cc1227a20fe6.png"></div><br><br>  Con base en nuestra base de datos de errores, que actualmente asciende a m√°s de 12 mil ejemplos seleccionados, notamos y describimos patrones espec√≠ficos para escribir c√≥digo que conducen a numerosos errores.  Por ejemplo, realizamos los siguientes estudios: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El efecto de la √∫ltima l√≠nea</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La funci√≥n m√°s peligrosa en el mundo de C / C ++</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Expresiones l√≥gicas en C / C ++.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Qu√© equivocados est√°n los profesionales</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El mal vive en funciones de comparaci√≥n</a> . </li></ol><br>  Este proyecto marc√≥ el comienzo de la descripci√≥n del nuevo patr√≥n.  Estamos hablando de los n√∫meros <b>1</b> y <b>2</b> en los nombres de variables, por ejemplo, <i>archivo1</i> y <i>archivo2</i> , etc.  Es muy f√°cil confundir dos de esas variables.  Este es un caso especial de errores tipogr√°ficos en el c√≥digo, pero uno de esos errores da como resultado el deseo de trabajar con variables del mismo nombre, que difieren solo por los n√∫meros 1 y 2 al final del nombre. <br><br>  Mirando hacia el futuro un poco, dir√© que todos los estudios enumerados anteriormente se confirmaron en el c√≥digo de este proyecto: D. <br><br>  Considere el primer ejemplo del proyecto Genome Workbench: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V501</a> Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subexpresiones</a> id√©nticas '(! Loc1.IsInt () &amp;&amp;! Loc1.IsWhole ())' a la izquierda y a la derecha de '||'  operador  nw_aligner.cpp 480 <br><br><pre><code class="cpp hljs">CRef&lt;CSeq_align&gt; CNWAligner::Run(CScope &amp;scope, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc &amp;loc1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc &amp;loc2, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> trim_end_gaps) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!loc1.IsInt() &amp;&amp; !loc1.IsWhole()) || (!loc1.IsInt() &amp;&amp; !loc1.IsWhole())) { NCBI_THROW(CException, eUnknown, <span class="hljs-string"><span class="hljs-string">"Only whole and interval locations supported"</span></span>); } .... }</code> </pre> <br>  Vemos dos variables llamadas <i>loc1</i> y <i>loc2</i> .  Y tambi√©n un error en el c√≥digo: la variable <i>loc2</i> no se usa, porque en su <i>lugar</i> se usa <i>loc1</i> una vez m√°s. <br><br>  Otro ejemplo: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V560</a> Una parte de la expresi√≥n condicional siempre es falsa: s1.IsSet ().  valid_biosource.cpp 3073 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_PCRPrimerSetLess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPCRPrimerSet&amp; s1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPCRPrimerSet&amp; s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s1.IsSet() &amp;&amp; s1.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.IsSet() &amp;&amp; !s2.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s1.IsSet() &amp;&amp; !s2.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Get().size() &lt; s2.Get().size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Get().size() &gt; s2.Get().size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ..... }</code> </pre> <br>  La primera l√≠nea de c√≥digo mezcl√≥ las variables <i>s1</i> y <i>s2</i> .  Seg√∫n el nombre, esta es una funci√≥n de comparaci√≥n.  Pero tal error puede estar en cualquier parte, porque al nombrar las variables <i>N√∫mero 1</i> y <i>N√∫mero 2</i> , el programador seguramente cometer√° un error en el futuro.  Y cuanto m√°s usos de tales nombres en una funci√≥n, mayor es la probabilidad de un error. <br><br><h2>  Otros errores tipogr√°ficos y copiar y pegar </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/d9f/f6b/6d5d9ff6bf8083922701b25273fa50b2.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V501</a> Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subexpresiones</a> id√©nticas a la izquierda y a la derecha del operador '! =': Bd.bit_.bits [i]! = Bd.bit_.bits [i] bm.h 296 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_state</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iterator_base&amp; ib)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;block_type_ == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.ptr != ib_db.bit_.ptr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.idx != ib_db.bit_.idx) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.cnt != ib_db.bit_.cnt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.pos != ib_db.bit_.pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bd.bit_.cnt; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.bits[i] != bd.bit_.bits[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } .... }</code> </pre> <br>  Creo que despu√©s de todas las comprobaciones, los tama√±os de las matrices de <i>bits</i> de los <i>objetos</i> <i>bd.bit_</i> e <i>ib_db.bit_</i> son iguales.  Por lo tanto, el autor del c√≥digo escribi√≥ un ciclo para la comparaci√≥n por <i>elementos de las</i> matrices de <i>bits</i> , pero hizo un error tipogr√°fico en el nombre de uno de los objetos comparados.  Como resultado, los objetos comparados pueden considerarse err√≥neamente iguales en algunas situaciones. <br><br>  Este ejemplo es digno del art√≠culo "El <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mal vive en funciones de comparaci√≥n</a> ". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V501</a> Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">subexpresiones</a> id√©nticas 'CFieldHandler :: QualifierNamesAreEquivalent (field, kFieldTypeSeqId)' a la izquierda y a la derecha de '||'  operador  field_handler.cpp 152 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CFieldHandlerFactory::s_IsSequenceIDField(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; field) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( CFieldHandler::QualifierNamesAreEquivalent(field, kFieldTypeSeqId) || CFieldHandler::QualifierNamesAreEquivalent(field, kFieldTypeSeqId)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Lo m√°s probable es que uno de los controles sea superfluo.  No encontr√© en el c√≥digo variables similares a <i>kFieldTypeSeqId</i> .  Sin embargo, es posible una llamada de funci√≥n adicional debido al operador "||", que degrada el rendimiento. <br><br>  Un par m√°s del mismo tipo de lugares con una advertencia del analizador, que requieren verificaci√≥n: <br><br><ul><li>  V501 Hay subexpresiones id√©nticas 'uf-&gt; GetData (). IsBool ()' a la izquierda y a la derecha del operador '&amp;&amp;'.  variaci√≥n_utils.cpp 1711 </li><li>  V501 Hay subexpresiones id√©nticas 'uf-&gt; GetData (). IsBool ()' a la izquierda y a la derecha del operador '&amp;&amp;'.  variaci√≥n_utils.cpp 1735 </li></ul><br>  V766 Ya se ha agregado un elemento con la misma clave 'kArgRemote'.  blast_args.cpp 3262 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBlastAppArgs::x_IssueWarningsForIgnoredOptions(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CArgs&amp; args) { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; can_override; .... can_override.insert(kArgOutputFormat); can_override.insert(kArgNumDescriptions); can_override.insert(kArgNumAlignments); can_override.insert(kArgMaxTargetSequences); can_override.insert(kArgRemote); <span class="hljs-comment"><span class="hljs-comment">// &lt;= can_override.insert(kArgNumThreads); can_override.insert(kArgInputSearchStrategy); can_override.insert(kArgRemote); // &lt;= can_override.insert("remote_verbose"); can_override.insert("verbose"); .... }</span></span></code> </pre> <br>  El analizador detect√≥ la adici√≥n de 2 valores id√©nticos al contenedor <i>establecido</i> .  Recuerde que este contenedor solo almacena valores √∫nicos, por lo que no se le agregan duplicados. <br><br>  El c√≥digo como el anterior a menudo se escribe utilizando el m√©todo de copiar y pegar.  Simplemente puede haber un valor adicional, o tal vez el autor olvid√≥ cambiar el nombre de una de las variables cuando copi√≥.  Cuando elimina una llamada adicional para <i>insertar, el</i> c√≥digo se optimiza ligeramente, lo que, sin embargo, no es significativo.  M√°s importante a√∫n, un error grave puede estar oculto aqu√≠ debido a un elemento faltante en el conjunto. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V523</a> La declaraci√≥n 'then' es equivalente al fragmento de c√≥digo posterior.  vcf_reader.cpp 1105 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CVcfReader::xAssignFeatureLocationSet(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.m_SetType == CVcfData::ST_ALL_DEL) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.m_strRef.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//deletion of a single base pFeat-&gt;SetLocation().SetPnt().SetPoint(data.m_iPos-1); pFeat-&gt;SetLocation().SetPnt().SetId(*pId); } else { pFeat-&gt;SetLocation().SetInt().SetFrom(data.m_iPos-1); //-1 for 0-based, //another -1 for inclusive end-point ( ie [], not [) ) pFeat-&gt;SetLocation().SetInt().SetTo( data.m_iPos -1 + data.m_strRef.length() - 1); pFeat-&gt;SetLocation().SetInt().SetId(*pId); } return true; } //default: For MNV's we will use the single starting point //NB: For references of size &gt;=2, this location will not //match the reference allele. Future Variation-ref //normalization code will address these issues, //and obviate the need for this code altogether. if (data.m_strRef.size() == 1) { //deletion of a single base pFeat-&gt;SetLocation().SetPnt().SetPoint(data.m_iPos-1); pFeat-&gt;SetLocation().SetPnt().SetId(*pId); } else { pFeat-&gt;SetLocation().SetInt().SetFrom(data.m_iPos-1); pFeat-&gt;SetLocation().SetInt().SetTo( data.m_iPos -1 + data.m_strRef.length() - 1); pFeat-&gt;SetLocation().SetInt().SetId(*pId); } return true; }</span></span></code> </pre> <br>  La funci√≥n contiene fragmentos de c√≥digo grandes y completamente id√©nticos.  Sin embargo, contienen varios comentarios acompa√±antes.  El c√≥digo no est√° escrito de manera √≥ptima, confusa, y posiblemente contiene un error. <br><br>  La lista completa de lugares sospechosos con la declaraci√≥n if-else se ve as√≠: <br><br><ul><li>  V523 La declaraci√≥n 'then' es equivalente a la declaraci√≥n 'else'.  blk.c 2142 </li><li>  V523 La declaraci√≥n 'then' es equivalente al fragmento de c√≥digo posterior.  odbc.c 379 </li><li>  V523 La declaraci√≥n 'then' es equivalente al fragmento de c√≥digo posterior.  odbc.c 1414 </li><li>  V523 La declaraci√≥n 'then' es equivalente a la declaraci√≥n 'else'.  seqdbvol.cpp 1922 </li><li>  V523 La declaraci√≥n 'then' es equivalente a la declaraci√≥n 'else'.  seqdb_demo.cpp 466 </li><li>  V523 La declaraci√≥n 'then' es equivalente al fragmento de c√≥digo posterior.  blast_engine.c 1917 </li><li>  V523 La declaraci√≥n 'then' es equivalente a la declaraci√≥n 'else'.  blast_filter.c 420 </li><li>  V523 La declaraci√≥n 'then' es equivalente a la declaraci√≥n 'else'.  blast_parameters.c 636 </li><li>  V523 La declaraci√≥n 'then' es equivalente a la declaraci√≥n 'else'.  unordered_spliter.cpp 684 </li><li>  V523 La declaraci√≥n 'then' es equivalente a la declaraci√≥n 'else'.  bme.cpp 333 </li><li>  V523 La declaraci√≥n 'then' es equivalente a la declaraci√≥n 'else'.  gme.cpp 484 </li></ul><br><h2>  / * con seguridad es mejor ser pedante * / </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/914/df5/670/914df5670813e7eb410e446f60a0ed5e.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V597</a> El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'passwd_buf'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 366 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Crypt a given password using schema required for NTLMv1 authentication * @param passwd clear text domain password * @param challenge challenge data given by server * @param flags NTLM flags from server side * @param answer buffer where to store crypted password */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds_answer_challenge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_PW_SZ 14 .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ntlm_v == 1) { .... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* with security is best be pedantic */</span></span></span><span class="hljs-meta"> memset(hash, 0, sizeof(hash)); memset(passwd_buf, 0, sizeof(passwd_buf)); memset(ntlm2_challenge, 0, sizeof(ntlm2_challenge)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { .... } }</span></span></code> </pre> <br>  Como probablemente ya adivin√≥, en el t√≠tulo de la secci√≥n se utiliz√≥ un comentario divertido sobre la seguridad del c√≥digo. <br><br>  En resumen, la funci√≥n <i>memset</i> ser√° eliminada por el compilador, porque los buffers <i>vaciados</i> ya no se utilizan.  Y datos como <i>hash</i> o <i>passwd_buf en</i> realidad no ser√°n ceros.  Para obtener m√°s informaci√≥n sobre este mecanismo de compilaci√≥n no obvio, consulte el art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Limpieza segura de datos privados</a> ". <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V597</a> El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el objeto 'responder'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 561 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TDSRET </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds7_send_auth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* for security reason clear structure */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;answer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(TDSANSWER)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tds_flush_packet(tds); }</code> </pre> <br>  Ese no fue el √∫nico ejemplo con comentarios sobre "seguridad".  A juzgar por los comentarios, se puede suponer que la seguridad es realmente importante para el proyecto.  Por lo tanto, adjunto toda la lista no peque√±a de problemas identificados: <br><br><ul><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el objeto 'mont√≥n'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  ncbi_heapmgr.c 1300 </li><li>  V597 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el objeto 'context'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 167 </li><li>  V597 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el objeto 'ks'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 339 </li><li>  V597 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el objeto 'md5_ctx'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 353 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'hash'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 365 </li><li>  V597 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el objeto 'ks'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 406 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el objeto 'ntlm_v2_response'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  login.c 795 </li><li>  V597 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el objeto 'responder'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  login.c 801 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'paquete'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  numeric.c 256 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'paquete'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  numeric.c 110 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'pwd'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  getpassarg.c 50 </li><li>  V597 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el objeto 'context'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  desaf√≠o.c 188 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'buf'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 243 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'ntlm_v2_hash'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 309 </li><li>  V597 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el objeto 'md5_ctx'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 354 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'passwd_buf'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 380 </li><li>  V597 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el objeto 'ks'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 393 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'hash'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 394 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el b√∫fer 'ntlm2_challenge'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 395 </li><li>  V597 El compilador podr√≠a eliminar la llamada a la funci√≥n 'memset', que se utiliza para vaciar el objeto 'ks'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 419 </li><li>  V597 El compilador podr√≠a eliminar la llamada de funci√≥n 'memset', que se utiliza para vaciar el objeto 'ntlm_v2_response'.  La funci√≥n memset_s () debe usarse para borrar los datos privados.  challenge.c 556 </li></ul><br><h2>  Ciclos sospechosos </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ac/c77/124/8acc77124e5a13a1d25926c95d9eb2cf.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V534</a> Es probable que se compare una variable incorrecta dentro del operador 'for'.  Considere revisar 'i'.  taxFormat.cpp 569 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CTaxFormat::x_LoadTaxTree(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; alignTaxids.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tax_id = alignTaxids[i]; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; taxInfo.seqInfoList.size(); j++) { SSeqInfo* seqInfo = taxInfo.seqInfoList[j]; seqInfo-&gt;taxid = newTaxid; } .... } .... }</code> </pre> <br>  Creo que, en la condici√≥n del bucle interno, la variable la obtuve al azar.  En cambio, se debe usar la variable <i>j</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V535</a> La variable 'i' se est√° utilizando para este bucle y para el bucle externo.  L√≠neas de verificaci√≥n: 302, 309. sls_alp.cpp 309 <br><br><pre> <code class="cpp hljs">alp::~alp() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(d_alp_states) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=d_nalp;i++) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if(i&lt;=d_alp_states-&gt;d_dim) { if(d_alp_states-&gt;d_elem[i]) { for(i=0;i&lt;=d_nalp;i++) // &lt;= { .... .... }</span></span></code> </pre> <br>  Dos ciclos id√©nticos anidados, en los que el contador global tambi√©n se restablece, parecen muy sospechosos.  Los desarrolladores deben verificar lo que sucede aqu√≠. <br><br><h2>  Indizaci√≥n de matriz anormal </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/136/5b2/4a81365b2534c606f6d12df389841299.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V520</a> El operador de coma ',' en la expresi√≥n de √≠ndice de matriz '[- i2, - k]'.  nw_spliced_aligner16.cpp 564 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CSplicedAligner16::x_DoBackTrace ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Uint2* backtrace_matrix, CNWAligner::SAlignInOut* data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_global_max, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j_global_max) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(intron_length &lt; m_IntronMinSize || (Key &amp; donor) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Key = backtrace_matrix[--i2, --k]; ++intron_length; data-&gt;m_transcript.push_back(eTS_Intron); } .... }</code> </pre> <br>  Debo decir de inmediato que parece no haber ning√∫n error (por ahora, jajaja).  Considere la siguiente l√≠nea: <br><br><pre> <code class="cpp hljs">Key = backtrace_matrix[--i2, --k];</code> </pre> <br>  La palabra 'matriz' y la doble indexaci√≥n pueden sugerir que la matriz es bidimensional, pero no lo es.  Este es un puntero regular a una matriz de enteros.  Pero el diagn√≥stico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V520</a> no solo apareci√≥.  Los programadores est√°n realmente confundidos acerca de c√≥mo indexar matrices bidimensionales. <br><br>  En este caso, el autor simplemente decidi√≥ guardar en una l√≠nea de c√≥digo, aunque podr√≠a escribir as√≠: <br><br><pre> <code class="cpp hljs">--i2; Key = backtrace_matrix[--k];</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V661</a> Una expresi√≥n sospechosa 'A [B == C]'.  Probablemente significaba 'A [B] == C'.  ncbi_service_connector.c 180 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EHTTP_HeaderParse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_ParseHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* header, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(header, <span class="hljs-string"><span class="hljs-string">"%u.%u.%u.%u%n"</span></span>, &amp;i1, &amp;i2, &amp;i3, &amp;i4, &amp;n) &lt; <span class="hljs-number"><span class="hljs-number">4</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(header + n, <span class="hljs-string"><span class="hljs-string">"%hu%x%n"</span></span>, &amp;uuu-&gt;port, &amp;tkt, &amp;m) &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> || (header[m += n] &amp;&amp; !(header[m] == <span class="hljs-string"><span class="hljs-string">'$'</span></span>) &amp;&amp; !<span class="hljs-built_in"><span class="hljs-built_in">isspace</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)((header + m) [header[m] == <span class="hljs-string"><span class="hljs-string">'$'</span></span>])))) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span><span class="hljs-comment"><span class="hljs-comment">/*failed - unreadable connection info*/</span></span>; } .... }</code> </pre> <br>  Otro ejemplo de c√≥digo en el que pas√© mucho tiempo tratando de entender lo que est√° sucediendo: D.  La funci√≥n <i>isspace ()</i> verifica el car√°cter con √≠ndice <i>m</i> , pero si este car√°cter es '$', entonces el car√°cter con √≠ndice <i>m + 1 se</i> pasa a la funci√≥n.  Adem√°s, la comparaci√≥n con '$' ya estaba por adelantado.  Quiz√°s no haya ning√∫n error aqu√≠, pero el c√≥digo definitivamente se puede reescribir m√°s claramente. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V557</a> Array overrun es posible.  El √≠ndice de 'fila' apunta m√°s all√° del l√≠mite de la matriz.  aln_reader.cpp 412 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CAlnReader::x_IsGap(TNumrow row, TSeqPos pos, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; residue) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_MiddleSections.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { x_CalculateMiddleSections(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row &gt; m_MiddleSections.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &lt; m_MiddleSections[row].first) { .... } .... }</code> </pre> <br>  Aqu√≠ hay un grave error.  La verificaci√≥n correcta del √≠ndice de <i>fila</i> deber√≠a ser as√≠: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row &gt;= m_MiddleSections.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  De lo contrario, es posible acceder a datos fuera del vector de <i>MiddleSections</i> . <br><br>  Muchos m√°s de esos lugares: <br><br><ul><li>  V557 Array overrun es posible.  El √≠ndice 'i' apunta m√°s all√° del l√≠mite de la matriz.  resource_pool.hpp 388 </li><li>  V557 Array overrun es posible.  El √≠ndice de 'fila' apunta m√°s all√° del l√≠mite de la matriz.  aln_reader.cpp 418 </li><li>  V557 Array overrun es posible.  El √≠ndice 'fmt_idx' apunta m√°s all√° del l√≠mite de la matriz.  seq_writer.cpp 384 </li><li>  V557 Array overrun es posible.  El √≠ndice 'fmt_idx' apunta m√°s all√° del l√≠mite de la matriz.  blastdb_formatter.cpp 183 </li><li>  V557 Array overrun es posible.  El √≠ndice 'num' apunta m√°s all√° del l√≠mite de la matriz.  newcleanupp.cpp 13035 </li></ul><br><h2>  C√≥mo ganarse la desconfianza de las funciones </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/147/029/c18/147029c18e4ccacc04f11f688084034f.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V570</a> La variable 'm_onClickFunction' se asigna a s√≠ misma.  alngraphic.hpp 103 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOnClickFunctionName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> onClickFunction)</span></span></span><span class="hljs-function"> </span></span>{ m_onClickFunction = m_onClickFunction; }</code> </pre> <br>  No hay nada que comentar.  Solo puede simpatizar con la persona que hizo clic en algo, hizo clic, pero nada cambi√≥. <br><br>  Dos casos m√°s de asignarme variables dar√°n como resultado una lista: <br><br><ul><li>  V570 La variable 'iter-&gt; level' se asigna a s√≠ misma.  align_format_util.cpp 189 </li><li>  V570 La variable 'd_elements_values ‚Äã‚Äã[ind]' se asigna a s√≠ misma.  sls_alp_data.cpp 1416 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V763 El</a> par√°metro 'w1' siempre se reescribe en el cuerpo de la funci√≥n antes de usarse.  bmfunc.h 5363 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Bit COUNT functor template&lt;typename W&gt; struct bit_COUNT { W operator()(W w1, W w2) { w1 = 0; BM_INCWORD_BITCOUNT(w1, w2); return w1; } };</span></span></code> </pre> <br>  Una funci√≥n en la que el argumento se deshilacha inmediatamente al ingresar a la funci√≥n puede ser enga√±oso para los desarrolladores que la usan.  El c√≥digo debe ser verificado dos veces. <br><br><h2>  Errores de dise√±o de clase </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/033/e75/06c/033e7506c36604696731f73024f57c78.png"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V688</a> El argumento de la funci√≥n 'm_qsrc' posee el mismo nombre que uno de los miembros de la clase, lo que puede generar confusi√≥n.  compart_matching.cpp 873 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CElementaryMatching</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CObject { .... ISequenceSource * m_qsrc; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_CreateIndex</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, EIndexMode index_more, ....)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_CreateRemapData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, EIndexMode mode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_LoadRemapData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; sdb)</span></span></span></span>; .... };</code> </pre> <br>  Inmediatamente 3 funciones de clase contienen argumentos cuyos nombres coinciden con el campo de clase.  Esto puede conducir a errores en los cuerpos de las funciones: el programador puede pensar que est√° trabajando con un miembro de la clase, cambiando realmente el valor de la variable local. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V614</a> Variable no inicializada 'm_BitSet' utilizada.  SnpBitAttributes.hpp 187 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// SNP bit attribute container. class CSnpBitAttributes { public: .... private: /// Internal storage for bits. Uint8 m_BitSet; }; inline CSnpBitAttributes::CSnpBitAttributes(Uint8 bits) : m_BitSet(bits) { } inline CSnpBitAttributes::CSnpBitAttributes(const vector&lt;char&gt;&amp; octet_string) { auto count = sizeof(m_BitSet); auto byte = octet_string.end(); do m_BitSet = (m_BitSet &lt;&lt; 8) | *--byte; while (--count &gt; 0); }</span></span></code> </pre> <br>  Uno de los constructores trabaja <i>descuidadamente</i> con la variable <i>m_BitSet</i> .  El hecho es que la variable no est√° inicializada.  Su valor de "basura" se utiliza en la primera iteraci√≥n del bucle, despu√©s de lo cual ocurre la inicializaci√≥n.  Este es un error muy grave, que conduce a un comportamiento indefinido del programa. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V603</a> El objeto fue creado pero no se est√° utilizando.  Si desea llamar al constructor, debe usar 'this-&gt; SIntervalComparisonResult :: SIntervalComparisonResult (....)'.  compare_feats.hpp 100 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//This struct keeps the result of comparison of two exons struct SIntervalComparisonResult : CObject { public: SIntervalComparisonResult(unsigned pos1, unsigned pos2, FCompareLocs result, int pos_comparison = 0) : m_exon_ordinal1(pos1), m_exon_ordinal2(pos2), m_result(result), m_position_comparison(pos_comparison) {} SIntervalComparisonResult() { SIntervalComparisonResult(0, 0, fCmp_Unknown, 0); } .... };</span></span></code> </pre> <br>  Hace mucho tiempo no encontr√© tales errores al verificar proyectos.  Pero el problema sigue siendo relevante.  El error es que llamar al constructor parametrizado de esta manera crea y elimina un objeto temporal.  Y los campos de clase permanecen sin inicializar.  Se debe llamar a otro constructor a trav√©s de la lista de inicializaci√≥n (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Delegar el constructor</a> ). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V591 La funci√≥n</a> no nula deber√≠a devolver un valor.  bio_tree.hpp 266 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Recursive assignment CBioNode&amp; operator=(const CBioNode&amp; tree) { TParent::operator=(tree); TBioTree* pt = (TBioTree*)tree.GetParentTree(); SetParentTree(pt); }</span></span></code> </pre> <br>  El analizador considera que falta la l√≠nea en la declaraci√≥n sobrecargada: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V670</a> El miembro de clase no inicializado 'm_OutBlobIdOrData' se usa para inicializar el miembro 'm_StdOut'.  Recuerde que los miembros se inicializan en el orden de sus declaraciones dentro de una clase.  remote_app.hpp 215 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NCBI_XCONNECT_EXPORT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CRemoteAppResult</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CRemoteAppResult(CNetCacheAPI::TInstance netcache_api, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_inline_size = kMaxBlobInlineSize) : m_NetCacheAPI(netcache_api), m_RetCode(<span class="hljs-number"><span class="hljs-number">-1</span></span>), m_StdOut(netcache_api, m_OutBlobIdOrData, m_OutBlobSize), m_OutBlobSize(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_StdErr(netcache_api, m_ErrBlobIdOrData, m_ErrBlobSize), m_ErrBlobSize(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_StorageType(eBlobStorage), m_MaxInlineSize(max_inline_size) { } .... };</code> </pre> <br>  Se emiten inmediatamente 3 advertencias del analizador a este fragmento de c√≥digo.  Los campos de clase se inicializan no en el orden en que aparecen en la lista de inicializaci√≥n, sino en la forma en que se declaran en la clase.  La causa cl√°sica del error es que no todos los programadores recuerdan o conocen esta regla.  Aqu√≠ y en la lista de inicializaci√≥n est√° el orden incorrecto.  Uno tiene la sensaci√≥n de que la lista de campos se ingres√≥ en orden aleatorio. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V746 Rebanado de</a> objetos.  Se debe detectar una excepci√≥n por referencia en lugar de por valor.  cobalt.cpp 247 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CMultiAligner::SetQueries(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; CRef&lt;objects::CBioseq&gt; &gt;&amp; queries) { .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { seq_loc-&gt;SetId(*it-&gt;GetSeqId()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (objects::CObjMgrException e) { NCBI_THROW(CMultiAlignerException, eInvalidInput, (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)<span class="hljs-string"><span class="hljs-string">"Missing seq-id in bioseq. "</span></span> + e.GetMsg()); } m_tQueries.push_back(seq_loc); .... }</code> </pre> <br>  Capturar excepciones por valor puede conducir a la p√©rdida de cierta informaci√≥n sobre la excepci√≥n debido a la creaci√≥n de un nuevo objeto.  Es mucho mejor y m√°s seguro detectar una excepci√≥n por referencia. <br><br>  Lugares similares: <br><br><ul><li>  V746 Rebanado de objetos.  Se debe detectar una excepci√≥n por referencia en lugar de por valor.  agp_validate_reader.cpp 562 </li><li>  V746 Rebanado de objetos.  Se debe detectar una excepci√≥n por referencia en lugar de por valor.  aln_build_app.cpp 320 </li><li>  V746 Rebanado de objetos.  Se debe detectar una excepci√≥n por referencia en lugar de por valor.  aln_test_app.cpp 458 </li><li>  V746 Rebanado de objetos.  Se debe detectar una excepci√≥n por referencia en lugar de por valor.  cobalt.cpp 691 </li><li>  V746 Rebanado de objetos.  Se debe detectar una excepci√≥n por referencia en lugar de por valor.  cobalt.cpp 719 </li><li>  V746 Rebanado de objetos.  Se debe detectar una excepci√≥n por referencia en lugar de por valor.  cobalt.cpp 728 </li><li>  V746 Rebanado de objetos.  Se debe detectar una excepci√≥n por referencia en lugar de por valor.  cobalt.cpp 732 </li></ul><br><h2>  Acerca del c√≥digo inalcanzable y otros problemas de ejecuci√≥n del c√≥digo </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/8f5/263/1d18f52633776adc7ca32f92446c4b9f.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V779</a> C√≥digo inalcanzable detectado.  Es posible que haya un error presente.  merge_tree_core.cpp 627 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CMergeTree::x_FindBefores_Up_Iter(....) { .... FirstFrame-&gt;Curr = StartCurr; FirstFrame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; FirstFrame-&gt;VisitCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; FrameStack.push_back(FirstFrame); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!FrameStack.empty()) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Rel == CEquivRange::eAfter) { Frame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; FrameStack.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Rel == CEquivRange::eBefore) { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Frame-&gt;VisitCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } Frame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= FrameStack.pop_back(); continue; } // end stack loop FirstFrame-&gt;ChildFrames.clear(); return FirstFrame-&gt;Returned; }</span></span></code> </pre> <br>  El c√≥digo de la declaraci√≥n condicional se escribe de modo que absolutamente todas las ramas del c√≥digo terminen con la declaraci√≥n de <i>continuaci√≥n</i> .  Esto condujo a varias l√≠neas de c√≥digo inalcanzable que se forman en el <i>ciclo while</i> .  Estas l√≠neas se ven muy sospechosas.  Lo m√°s probable es que este problema surgi√≥ despu√©s de refactorizar el c√≥digo, y ahora requiere una revisi√≥n cuidadosa del c√≥digo. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V519</a> La variable 'interval_width' tiene valores asignados dos veces sucesivamente.  Quiz√°s esto sea un error.  L√≠neas de verificaci√≥n: 454, 456. aln_writer.cpp 456 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CAlnWriter::AddGaps(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(exon_chunk-&gt;Which()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Match: interval_width = exon_chunk-&gt;GetMatch(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Mismatch: interval_width = exon_chunk-&gt;GetMismatch(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Diag: interval_width = exon_chunk-&gt;GetDiag(); genomic_string.append(....); product_string.append(....); genomic_pos += interval_width; product_pos += interval_width/res_width; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... } .... }</code> </pre> <br>  La variable <i>interval_width se</i> sobrescribe varias veces, porque  No hay declaraciones de <i>ruptura</i> en las ramas de <i>casos</i> .  Aunque es un cl√°sico, pero es un error muy malo. <br><br>  Algunos lugares m√°s sospechosos: <br><br><ul><li>  V779 C√≥digo inalcanzable detectado.  Es posible que haya un error presente.  dbapi_driver_utils.cpp 351 </li><li>  V779 C√≥digo inalcanzable detectado.  Es posible que haya un error presente.  net.c 780 </li><li>  V779 C√≥digo inalcanzable detectado.  Es posible que haya un error presente.  bcp.c 1495 </li><li>  V779 C√≥digo inalcanzable detectado.  Es posible que haya un error presente.  remote_blast.cpp 1470 </li><li>  V779 C√≥digo inalcanzable detectado.  Es posible que haya un error presente.  remote_blast.cpp 1522 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V571</a> Verificaci√≥n recurrente.  La condici√≥n 'if (m_QueryOpts-&gt; filtering_options)' ya se verific√≥ en la l√≠nea 703. blast_options_local_priv.hpp 713 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBlastOptionsLocal::SetFilterString(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* f) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_QueryOpts-&gt;filtering_options) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { SBlastFilterOptions* old_opts = m_QueryOpts-&gt;filtering_options; m_QueryOpts-&gt;filtering_options = NULL; SBlastFilterOptionsMerge(&amp;(m_QueryOpts-&gt;filtering_options), old_opts, new_opts); old_opts = SBlastFilterOptionsFree(old_opts); new_opts = SBlastFilterOptionsFree(new_opts); } else { if (m_QueryOpts-&gt;filtering_options) // &lt;= m_QueryOpts-&gt;filtering_options = SBlastFilterOptionsFree(m_QueryOpts-&gt;filtering_options); m_QueryOpts-&gt;filtering_options = new_opts; new_opts = NULL; } .... }</span></span></code> </pre> <br>  Obviamente, la rama <i>else</i> requiere reescritura.  Tengo algunas ideas que quer√≠a hacer con el puntero <i>m_QueryOpts-&gt; filtering_options</i> , pero el c√≥digo sigue siendo algo confuso.  Apelo a los autores del c√≥digo. <br><br>  Bueno, el problema no viene solo: <br><br><ul><li>  V571 Verificaci√≥n recurrente.  La condici√≥n 'if (sue√±o)' ya se verific√≥ en la l√≠nea 205. request_control.cpp 208 </li><li>  V571 Verificaci√≥n recurrente.  La condici√≥n 'if (asignarValor.empty ())' ya se verific√≥ en la l√≠nea 712. classstr.cpp 718 </li></ul><br><h2>  Errores de lectura de datos </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/761/548/f6b/761548f6b44470fe7b64db8ce0b0eb11.png"></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V739</a> EOF no debe compararse con un valor del tipo 'char'.  La 'cadena de l√≠nea [0]' debe ser del tipo 'int'.  alnread.c 3509 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EBool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_AfrpInitLineData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* linestring = readfunc (pfile); .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">while</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (linestring != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; linestring [</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">] != EOF) { s_TrimSpace (&amp;linestring); .... } .... }</span></span></span></span></code> </pre> <br>  Los caracteres que planea comparar con EOF no deben almacenarse en variables <i>char</i> .  De lo contrario, existe el riesgo de que un car√°cter con el valor 0xFF (255) se convierta en -1 y se interprete de la misma manera que el final de un archivo (EOF).  Adem√°s (por si acaso) vale la pena verificar la implementaci√≥n de la funci√≥n <i>readfunc</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V663</a> Infinite loop es posible.  La condici√≥n 'cin.eof ()' es insuficiente para romper el bucle.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere agregar la llamada a la funci√≥n 'cin.fail ()' a la expresi√≥n condicional. </font><font style="vertical-align: inherit;">ncbicgi.cpp 1564</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream CNcbiIstream; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CCgiRequest::Serialize(CNcbiOstream&amp; os) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... CNcbiIstream* istrm = GetInputStream(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (istrm) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!istrm-&gt;eof()) { istrm-&gt;read(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf)); os.write(buf, istrm-&gt;gcount()); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El analizador detect√≥ un error potencial debido al cual puede ocurrir un bucle infinito. </font><font style="vertical-align: inherit;">Si ocurre una falla mientras lee datos, llamar a la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eof ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> siempre devolver√° </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">falso</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Para completar el ciclo en este caso, es necesaria una verificaci√≥n adicional del valor devuelto por la funci√≥n </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fail ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Errores varios </font></font></h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/132/51d/701/13251d701a22cae67c852d1bed7d33a5.png"></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V502</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quiz√°s el operador '?:' Funciona de una manera diferente a la esperada. </font><font style="vertical-align: inherit;">El operador '?:' Tiene una prioridad menor que el operador '&amp;&amp;'. </font><font style="vertical-align: inherit;">ncbi_connutil.c 1135</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_ClientAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* client_host, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*bool*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> local_host)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((client_host == c &amp;&amp; x_IsSufficientAddress(client_host)) || !(ip = *c &amp;&amp; !local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(eDefault)) || SOCK_ntoa(ip, addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(addr)) != <span class="hljs-number"><span class="hljs-number">0</span></span> || !(s = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(client_host) + <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(addr) + <span class="hljs-number"><span class="hljs-number">3</span></span>))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> client_host<span class="hljs-comment"><span class="hljs-comment">/*least we can do :-/*/</span></span>; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Presta atenci√≥n a la expresi√≥n: </font></font><br><br><pre> <code class="cpp hljs">!local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(eDefault)</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No se calcula como esperaba el programador, porque la expresi√≥n completa se ve as√≠: </font></font><br><br><pre> <code class="cpp hljs">ip = *c &amp;&amp; !local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(...)</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La prioridad del operador </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es </font><font style="vertical-align: inherit;">mayor que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?:</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por esta raz√≥n, el c√≥digo no se ejecuta seg√∫n lo previsto. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V561</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Probablemente sea mejor asignar valor a la variable 'seq' que declararlo de nuevo. </font><font style="vertical-align: inherit;">Declaraci√≥n previa: validator.cpp, l√≠nea 490. validator.cpp 492</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CValidator::IsSeqLocCorrectlyOrdered(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc&amp; loc, CScope&amp; scope) { CBioseq_Handle seq; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { CBioseq_Handle seq = scope.GetBioseqHandle(loc); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CObjMgrException&amp; ) { <span class="hljs-comment"><span class="hljs-comment">// no way to tell return true; } catch (const exception&amp; ) { // no way to tell return true; } if (seq &amp;&amp; seq.GetInst_Topology() == CSeq_inst::eTopology_circular) { // no way to check if topology is circular return true; } return CheckConsecutiveIntervals(loc, scope, x_IsCorrectlyOrdered); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debido a que el programador declara una nueva variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dentro de la secci√≥n try / catch, otra variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permanece sin inicializar y se usa a continuaci√≥n en el c√≥digo. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V562</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es extra√±o comparar un valor de tipo bool con un valor de 0: (((estado) &amp; 0x7f) == 0)! = 0. ncbi_process.cpp 111</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CProcess::CExitInfo::IsExited(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { EXIT_INFO_CHECK; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != eExitInfo_Terminated) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(NCBI_OS_UNIX) return WIFEXITED(status) != 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(NCBI_OS_MSWIN) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// The process always terminates with exit code return true; #endif }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nada anunciaba mal, pero WIFEXITED result√≥ ser una apertura macro de esta manera: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((status) &amp; <span class="hljs-number"><span class="hljs-number">0x7f</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resulta que la funci√≥n devuelve el valor opuesto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el c√≥digo, hab√≠a otra funci√≥n, que emiti√≥ una advertencia:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V562 Es extra√±o comparar un valor de tipo bool con un valor de 0. ncbi_process.cpp 126 </font></font></li></ul><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V595</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El puntero 'dst_len' se utiliz√≥ antes de que se verificara contra nullptr. </font><font style="vertical-align: inherit;">L√≠neas de verificaci√≥n: 309, 315. zlib.cpp 309</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CZipCompression::CompressBuffer( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* src_buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> src_len, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* dst_buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> dst_size, <span class="hljs-comment"><span class="hljs-comment">/* out */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>* dst_len) { *dst_len = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Check parameters if (!src_len &amp;&amp; !F_ISSET(fAllowEmptyData)) { src_buf = NULL; } if (!src_buf || !dst_buf || !dst_len) { SetError(Z_STREAM_ERROR, "bad argument"); ERR_COMPRESS(48, FormatErrorMessage("CZipCompression::CompressBuffer")); return false; } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El puntero </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dst_len se</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desreferencia al comienzo de la funci√≥n, mientras que m√°s adelante se verifica que el c√≥digo sea igual a cero. </font><font style="vertical-align: inherit;">Se ha cometido un error en el c√≥digo que conduce a un comportamiento indefinido si el puntero </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dst_len</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V590</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Considere inspeccionar la </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">expresi√≥n</font></a><font style="vertical-align: inherit;"> 'ch! =' \ 0 '&amp;&amp; ch ==' ''. </font><font style="vertical-align: inherit;">La expresi√≥n es excesiva o contiene un error de imprenta. </font><font style="vertical-align: inherit;">cleanup_utils.cpp 580</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Asn2gnbkCompressSpaces</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; val)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ch != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; ch == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { ptr++; ch = *ptr; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La condici√≥n para detener el bucle depende solo de si el car√°cter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ch es un</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> espacio o no. </font><font style="vertical-align: inherit;">La expresi√≥n se puede simplificar a lo siguiente:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ch == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { .... }</code> </pre> <br><h2>  Conclusi√≥n </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El uso de programas de computadora en la investigaci√≥n cient√≠fica ayuda y ayudar√° a hacer descubrimientos. </font><font style="vertical-align: inherit;">Esperemos que no se pierdan los especialmente importantes debido a alg√∫n error tipogr√°fico. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Invito a los desarrolladores del proyecto NCBI Genome Workbench a contactarnos y les proporcionaremos un informe completo emitido por el analizador PVS-Studio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que esta peque√±a investigaci√≥n de c√≥digo ayude a corregir muchos errores y, en general, mejore la confiabilidad del proyecto. </font><font style="vertical-align: inherit;">Intente ejecutar PVS-Studio en el c√≥digo de sus proyectos, si a√∫n no lo ha hecho. </font><font style="vertical-align: inherit;">Te puede gustar :).</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si desea compartir este art√≠culo con una audiencia de habla inglesa, utilice el enlace a la traducci√≥n: Svyatoslav Razmyslov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NCBI Genome Workbench: Investigaci√≥n cient√≠fica bajo amenaza</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430476/">https://habr.com/ru/post/es430476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430466/index.html">Mini AI Cup # 3: Escribiendo un Top Bot</a></li>
<li><a href="../es430468/index.html">Sensibilizar a los ciudadanos.</a></li>
<li><a href="../es430470/index.html">¬øPor qu√© mantener el contexto en la cuenta del cliente? Honestamente y de manera rentable</a></li>
<li><a href="../es430472/index.html">Red DECT sin costura de bricolaje</a></li>
<li><a href="../es430474/index.html">CephFS vs GlusterFS</a></li>
<li><a href="../es430478/index.html">Comercio de bots para el mercado de criptomonedas. Por donde empezar</a></li>
<li><a href="../es430480/index.html">Mientras escrib√≠amos la aplicaci√≥n en el hackathon del Desaf√≠o de Aplicaciones Espaciales de la NASA</a></li>
<li><a href="../es430482/index.html">El tema de las placas de armadura en la cultura de Oriente y Occidente</a></li>
<li><a href="../es430484/index.html">Escenarios t√≠picos de implementaci√≥n de NGFW</a></li>
<li><a href="../es430486/index.html">C√≥mo viven los freelancers: de un desarrollador a un redactor t√©cnico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>