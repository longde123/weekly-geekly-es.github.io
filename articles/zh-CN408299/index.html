<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍝 👧🏾 🈸 使用pentamino示例使用SAT求解器解决平铺问题 🗄️ 👩🏽‍🚀 😅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当我遇到一个五角棋游戏时，有必要将13个数字乘以8乘8的正方形。在一段时间内我未能成功解决此问题后，我决定有必要编写一个程序来为我完成此任务。 为此，必须选择一种求解算法。 首先想到的是通常的分支和边界算法，当图形彼此相邻地堆叠时（带有跳舞链接的算法在这里不适用，因为图形不同）。 通常使用各种启发式...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用pentamino示例使用SAT求解器解决平铺问题</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/408299/">当我遇到一个五角棋游戏时，有必要将13个数字乘以8乘8的正方形。在一段时间内我未能成功解决此问题后，我决定有必要编写一个程序来为我完成此任务。 为此，必须选择一种求解算法。 首先想到的是通常的分支和边界算法，当图形彼此相邻地堆叠时（带有跳舞链接的算法在这里不适用，因为图形不同）。 通常使用各种启发式方法来加快此算法的速度，例如，最好使用最少数量的选项进行分支。 您可以在此算法中提出并实现其他启发式方法，但是后来我认为在SAT解算器中已经实现了许多加快解决此类问题的技巧。 因此，有必要将任务翻译成适当的数学语言并使用某种SAT求解器。 关于如何实现此方法以及在切割下可以读取什么结果。 <br><a name="habracut"></a><br> 一开始，我想提醒您什么游戏是pentamino。 这是一个8x8正方形的字段，需要平铺13个图形-12个花体，由5个正方形和一个2x2图形组成： <br><br><img src="https://ic.pics.livejournal.com/andyplekhanov/66030250/59907/59907_900.jp" alt="图片"><br><br> 在这里值得一说的是布尔可满足性问题或SAT问题。 一般而言，可以将其表述为对这样的布尔变量值的发现，其中给定表达式变为真。 一般来说，这是NP的完整任务，但是，有许多技巧可以有效地解决它。 为此，已经开发了许多称为SAT解算器的特殊应用。 我将使用一个名为minisat的SAT求解器。 为了解决该问题，有必要以合取范式重写输入表达式，即以变量逻辑和的乘积形式重写输入表达式。 每个合取范式中的每个括号都称为子句，它是某些文字的逻辑“或”，即布尔变量或它们的拒绝。 例如： <br><br>  （x1 V不是x3）（x2 V x4）（x2 V x3 V不是X4） <br><br> 我需要将平铺任务转换为SAT任务。 拍摄一些五角氨基的图形，并以各种可能的方式将其放置在运动场中，包括移动，转弯和反射。 对于图的每个这样的位置，我们关联一个布尔变量，并且我们假设，如果在最终解决方案中该图出现在该特定位置，则该变量将为true，否则为false。 我们针对所有数据执行此操作。 <br><br> 现在，让我们草拟一个描述我们问题的公式，也就是说，我们实际上将对变量施加限制。 首先要做的是确保我们比赛场地的所有单元都被至少一个数字覆盖。 为此，对于每个64个单元格，我们找到覆盖该单元格的所有图形和这些图形的位置，并根据分配给这些图形位置的变量组成一个子句。 第二件事是消除形状的交集。 这可以在一个双周期中完成，只需将所有图形的所有可能位置分类，然后确定该对是否具有公共单元即可。 如果存在，则它们相交，您需要添加以下形式的子句（不是x_i V而不是x_j），其中x_i是分配给第一个位置的变量，x_j是第二个位置。 当x_i和x_j同时不等于1时（即，排除交集），此子句为true。 最后，要考虑的第三件事是每个人物只能出现在运动场上一次。 为此，我们还要在一个双循环中遍历每个图形的所有位置，对于同一图形的每对位置，我们制作一个类似于前一个子句的子句，并由两个负数组成。 也就是说，当出现两个相同的数字（但位置不同）时，这些子句之一将给出错误，因此将排除这种解决方案。 <br><br> 这全都是理论，现在让我们继续练习。 每个图形都有一个从1到d的数字，以区别于其他图形并方便打印。 然后创建一个运动场矩阵，并将运动场的相应单元格编码为该图所占据/未占据： <br><br> <code>. . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . 1 1 . . . . . <br> 1 1 . . . . . . <br> . 1 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> 2 . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 3 . . . . . . . <br> 3 . . . . . . . <br> 3 . . . . . . . <br> 3 3 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 4 . . . . . . . <br> 4 . . . . . . . <br> 4 4 . . . . . . <br> . 4 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 5 5 . . . . . . <br> 5 5 . . . . . . <br> 5 . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 6 6 6 . . . . . <br> . 6 . . . . . . <br> . 6 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 7 . 7 . . . . . <br> 7 7 7 . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> 8 . . . . . . . <br> 8 . . . . . . . <br> 8 8 8 . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . 9 . . . . . <br> . 9 9 . . . . . <br> 9 9 . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . a . . . . . . <br> aaa . . . . . <br> . a . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> b . . . . . . . <br> bb . . . . . . <br> b . . . . . . . <br> b . . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . cc . . . . . <br> . c . . . . . . <br> cc . . . . . . <br> <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> . . . . . . . . <br> dd . . . . . . <br> dd . . . . . . <br></code> <br> 现在，对于每块棋子，都有必要通过移动，转弯和反射找到运动场上所有可能的位置。 让我们从转弯和反思开始。 总共有8种可能的转向和反射变换，其中包括一个使图形完整无缺的琐碎变换。 对于这些转换，我创建了8个对应的矩阵，如下所示。 旋转或反射后，人物可能会超出运动场，因此有必要将其返回到运动场。 还应考虑到某些数字可以在转换后转换为自身，并且这种情况应排除在外。 我向Orientation类添加了唯一的选项。 结果是以下代码： <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dimension_ = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_SIZE = dimension_ * dimension_; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MATRIX_SIZE; i++ ) { matrix[ i ] = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; dimension_; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix, matrix + MATRIX_SIZE, matrix1 ); matrix1[ i ] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = dimension_; j &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * dimension_; j++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !matrix1[ j - dimension_ ] ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix1, matrix1 + MATRIX_SIZE, matrix2 ); matrix2[ j ] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NUMBER = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; dimension_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>; l &lt; NUMBER; l++ ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * matrix3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[ MATRIX_SIZE ]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( matrix2, matrix2 + MATRIX_SIZE, matrix3 ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( l &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; l1 &lt; dimension_; l1++ ) { matrix3[ l1 ] = -matrix3[ l1 ]; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( l &amp; <span class="hljs-number"><span class="hljs-number">2</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l1 = dimension_; l1 &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * dimension_; l1++ ) { matrix3[ l1 ] = -matrix3[ l1 ]; } } Orientation * orientation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Orientation( figure ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Point *&gt;::const_iterator h = figure-&gt;points().begin(); h != figure-&gt;points().end(); ++h ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point * p = *h; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i1 &lt; dimension_; i1++ ) { x = x + p-&gt;coord( i1 ) * matrix3[ i1 ]; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i1 &lt; dimension_; i1++ ) { y = y + p-&gt;coord( i1 ) * matrix3[ dimension_ + i1 ]; } <span class="hljs-function"><span class="hljs-function">Point </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( x, y )</span></span></span></span>; orientation-&gt;createPoint( p1.coord( <span class="hljs-number"><span class="hljs-number">0</span></span> ), p1.coord( <span class="hljs-number"><span class="hljs-number">1</span></span> ) ); } orientation-&gt;moveToOrigin(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( isUnique( orientations, orientation ) ) { orientations.push_back( orientation ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> orientation; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix3; } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix2; } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> [] matrix1; }</code> </pre><br> 将此代码应用于每个图形，然后，将接收到的唯一方向沿x和y轴移动，从而创建每个图形的所有可能位置。 因此，每个图都有以下数量的不同位置： <br><br> <code>---------- Figure 1 <br> Count = 288 <br> ---------- Figure 2 <br> Count = 64 <br> ---------- Figure 3 <br> Count = 280 <br> ---------- Figure 4 <br> Count = 280 <br> ---------- Figure 5 <br> Count = 336 <br> ---------- Figure 6 <br> Count = 144 <br> ---------- Figure 7 <br> Count = 168 <br> ---------- Figure 8 <br> Count = 144 <br> ---------- Figure 9 <br> Count = 144 <br> ---------- Figure a <br> Count = 36 <br> ---------- Figure b <br> Count = 280 <br> ---------- Figure c <br> Count = 144 <br> ---------- Figure d <br> Count = 49 <br></code> <br> 然后，如上所述，我们将布尔变量分配给每个可能的位置并创建一个公式。 之后，我们直接从应用程序中调用minisat，这将返回一个解决方案-一组分配了值为true或false的变量。 知道这些变量分配到的位置后，我们打印解决方案： <br><br> <code>bbbb 3 3 3 3 <br> ddbc 8 8 8 3 <br> dd 1 ccc 8 2 <br> 5 5 1 1 1 c 8 2 <br> 5 5 5 1 4 4 4 2 <br> 7 7 a 4 4 9 6 2 <br> 7 aaa 9 9 6 2 <br> 7 7 a 9 9 6 6 6 <br></code> <br><img src="https://ic.pics.livejournal.com/andyplekhanov/66030250/60414/60414_900.jpg" alt="图片"><br><br><h2> 接下来是什么 </h2><br> 自然地，对此一无所知。 因此，对我提出的第一个问题是“存在多少种不同的解决方案，这些解决方案在琐碎的转弯和对运动场的反映方面没有差异？”。 为此，SAT解算器中提供了一种模式，该模式允许您添加子句而不丢失现有信息，与从头开始搜索解决方案相比，这可以大大加快过程。 通过添加一个子句，可以找到以下解决方案，该子句包含否定了先前解决方案中存在的所有变量。 在添加了此过程并将新解决方案与以前的解决方案进行比较之后，考虑到比赛场地的转弯和反射，我得到了1364个不同的选项。 <br><br> 我实现的另一个有趣的扩展是对各种其他形式的运动场和人物的研究。 最后，对三维运动场的研究非常有趣。 但这是另一篇文章的主题。 <br><br><h2> 更新资料 </h2><br><br> 添加一个附加条件后：对于一个子句的每个图形-该图形在运动场中至少应有一个位置，计算变得更快了。 此外，已修复一个错误，所有可能的唯一选项的数量为16146。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN408299/">https://habr.com/ru/post/zh-CN408299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN408285/index.html">用户调查极客时间</a></li>
<li><a href="../zh-CN408287/index.html">谁应为涉及自动驾驶汽车的事故负责？ 我们什么时候会在道路上看到自主的KAMAZ？</a></li>
<li><a href="../zh-CN408289/index.html">新型Tesla Model 3的未来派用户界面</a></li>
<li><a href="../zh-CN408291/index.html">在矮星谷神星上，过去可能存在海洋</a></li>
<li><a href="../zh-CN408297/index.html">配音演员的工作方式：第2部分</a></li>
<li><a href="../zh-CN408301/index.html">DJI向网络安全专家威胁法院，后者发现了在GitHub上访问公司帐户的密钥</a></li>
<li><a href="../zh-CN408303/index.html">电子纸简史：演变与前景</a></li>
<li><a href="../zh-CN408305/index.html">斯坦福神经网络比医生更好地诊断X射线肺炎</a></li>
<li><a href="../zh-CN408307/index.html">Raise3D：3D打印取代传统的制鞋业</a></li>
<li><a href="../zh-CN408311/index.html">质子和中子：物质内部拥挤</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>