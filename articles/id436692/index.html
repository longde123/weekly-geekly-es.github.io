<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ¾ ğŸ‘• ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿ (dalam) Perang Terbatas ğŸ‘¨â€âœˆï¸ ğŸ¢ ğŸ”‘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami punya masalah. Masalah dengan pengujian. Masalah dengan pengujian komponen Bereaksi, dan itu cukup mendasar. Ini tentang perbedaan antara unit te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>(dalam) Perang Terbatas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436692/"><p><img src="https://habrastorage.org/webt/4w/m4/cc/4wm4ccdyq2tqs2giqspeys3e9sa.jpeg" alt="perang infitite"></p><br><p> Kami punya masalah.  Masalah dengan pengujian.  Masalah dengan pengujian komponen Bereaksi, dan itu cukup mendasar.  Ini tentang perbedaan antara <code>unit testing</code> dan <code>integration testing</code> .  Ini tentang perbedaan antara apa yang kita sebut pengujian unit dan apa yang kita sebut pengujian integrasi, ukuran dan ruang lingkup. </p><br><p>  Ini bukan tentang pengujian itu sendiri, tetapi tentang Arsitektur Komponen.  Tentang perbedaan antara <strong>komponen</strong> pengujian, perpustakaan mandiri, dan <strong>aplikasi</strong> akhir. </p><br><p>  Semua orang tahu cara menguji komponen sederhana (mereka sederhana), mungkin tahu cara menguji Aplikasi (E2E).  Cara menguji hal-hal yang <em>Terbatas</em> dan <em>Tak Terbatas</em> ... </p><a name="habracut"></a><br><h2 id="define-the-problem">  Definisikan masalahnya m </h2><br><p>  Ada 2 cara berbeda untuk menguji React Component - <code>shallow</code> dan yang lainnya, termasuk <code>mount</code> , <code>react-testing-library</code> , <code>webdriver</code> dan sebagainya.  Hanya yang <code>shallow</code> yang istimewa - sisanya berperilaku dengan cara yang sama. </p><br><p>  Dan perbedaan ini adalah tentang <em>ukuran, dan ruang lingkup</em> - tentang APA yang akan diuji, dan hanya sebagian <em>caranya</em> . </p><br><p>  Singkatnya - <code>shallow</code> hanya akan merekam panggilan ke React.createElement, tetapi tidak menjalankan efek samping, termasuk merender elemen DOM - itu adalah efek samping (aljabar) dari React.createElement. </p><br><p>  Perintah lain akan menjalankan kode yang Anda berikan dengan masing-masing dan setiap efek samping juga dieksekusi.  Karena itu akan nyata, dan itulah tujuannya. </p><br><p>  Dan <strong>masalahnya</strong> adalah sebagai berikut: <code>you can NOT run each and every side effect</code> . </p><br><h3 id="why-not">  Kenapa tidak </h3><br><p>  Fungsi kemurnian?  Kemurnian dan Kekekalan - sapi suci hari ini.  Dan Anda membantai salah satu dari mereka.  Aksioma pengujian unit - tidak ada efek samping, isolasi, ejekan, semuanya terkendali. </p><br><ul><li><p>  Tapi itu <em>bukan masalah</em> bagi ... <code>dumb components</code> .  Mereka bodoh, hanya berisi lapisan presentasi, tetapi bukan "efek samping". </p><br></li><li><p>  Tapi itu <em>masalah</em> bagi <code>Containers</code> .  Selama mereka tidak bisu, mengandung apa pun yang mereka inginkan, dan sepenuhnya tentang efek samping.  Mereka masalahnya! </p><br></li></ul><br><p>  Mungkin, jika kita mendefinisikan aturan "The Right Component" kita dapat dengan mudah menguji - itu akan membimbing kita, dan membantu kita. </p><br><blockquote>  TRDL: Komponen Hingga </blockquote><br><h2 id="smart-and-dumb-components">  Komponen pintar dan bodoh </h2><br><p>  Menurut Komponen Penyajian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel Dan Abramov</a> adalah: </p><br><ul><li>  Khawatir dengan bagaimana hal-hal terlihat. </li><li>  Mungkin mengandung komponen presentasi dan wadah <code>**</code> di dalamnya, dan biasanya memiliki beberapa markup DOM dan gaya mereka sendiri. </li><li>  Seringkali mengizinkan penahanan melalui this.props.children. </li><li>  Tidak memiliki dependensi pada sisa aplikasi, seperti tindakan atau toko Flux. </li><li>  Jangan menentukan bagaimana data dimuat atau bermutasi. </li><li>  Terima data dan panggilan balik secara eksklusif melalui alat peraga. </li><li>  Jarang memiliki status mereka sendiri (ketika mereka melakukannya, ini adalah keadaan UI daripada data). </li><li>  Ditulis sebagai komponen fungsional kecuali memerlukan status, kait siklus hidup, atau optimalisasi kinerja. </li><li>  Contoh: Halaman, Bilah Samping, Cerita, UserInfo, Daftar. </li><li>  .... </li><li>  Dan Kontainer hanyalah penyedia data / properti untuk komponen-komponen ini. </li></ul><br><p>  Menurut asal: <strong>Dalam Aplikasi yang ideal ...</strong> <strong><br></strong>  <strong>Wadah adalah Pohonnya.</strong>  <strong>Komponennya adalah Tree Leafs.</strong> </p><br><h4 id="find-the-black-cat-in-the-dark-room">  Temukan kucing hitam di ruangan gelap </h4><br><p>  Saus rahasia di sini, satu perubahan yang harus kami ubah dalam definisi ini, disembunyikan di dalam <em>"Mungkin mengandung komponen presentasi dan wadah <code>**</code> "</em> , izinkan saya mengutip artikel asli: </p><br><blockquote>  Dalam versi yang lebih awal dari artikel ini saya mengklaim bahwa komponen presentasi hanya boleh mengandung komponen presentasi lainnya.  Saya tidak lagi berpikir ini adalah masalahnya.  Apakah komponen merupakan komponen presentasi atau wadah adalah detail implementasinya.  Anda harus dapat mengganti komponen presentasi dengan wadah tanpa mengubah salah satu situs panggilan.  Oleh karena itu, komponen penyajian dan wadah dapat berisi komponen penyajian atau wadah lainnya dengan baik. </blockquote><p>  Oke, tapi bagaimana dengan aturan, yang membuat unit komponen presentasi dapat diuji - <em>â€œTidak memiliki ketergantungan pada aplikasi lainnyaâ€</em> ? </p><br><p>  Sayangnya, dengan memasukkan kontainer ke dalam komponen presentasi, Anda membuat yang kedua <strong>tanpa batas</strong> , dan menyuntikkan ketergantungan ke seluruh aplikasi. </p><br><p>  Mungkin itu bukan sesuatu yang harus Anda lakukan.  Jadi, saya tidak punya pilihan lain, tetapi untuk membuat komponen bodoh hingga: </p><br><p>  <strong>KOMPONEN PRESENTASI HARUS MENGANDUNG KOMPONEN PRESENTASI LAINNYA</strong> </p><br><p>  Dan satu-satunya pertanyaan, Anda harus bertanya (melihat ke basis kode Anda saat ini): <em>Bagaimana?</em>  : tableflip:?! </p><br><p>  Komponen dan Kontainer Presentasi Hari Ini tidak hanya terjerat, tetapi kadang-kadang juga tidak diekstraksi sebagai entitas "murni" (halo GraphQL). </p><br><h4 id="solution-1---di">  Solusi 1 - DI </h4><br><p>  Solusi 1 sederhana - tidak mengandung wadah bersarang di komponen bodoh - mengandung <code>slots</code> .  Terima saja "konten" (anak-anak), sebagai alat peraga, dan itu akan menyelesaikan masalah: </p><br><ul><li>  Anda dapat menguji komponen bodoh tanpa "sisa aplikasi Anda" </li><li>  Anda dapat menguji integrasi dengan tes asap / integrasi / e2e, bukan tes. </li></ul><br><pre> <code class="plaintext hljs">// Test me with mount, with "slots emty". const PageChrome = ({children, aside}) =&gt; ( &lt;section&gt; &lt;aside&gt;{aside}&lt;/aside&gt; {children} &lt;/section&gt; ); // test me with shallow, or real integration test const PageChromeContainer = () =&gt; ( &lt;PageChrome aside={&lt;ASideContainer /&gt;}&gt; &lt;Page /&gt; &lt;/PageChrome&gt; );</code> </pre> <br><p>  Disetujui oleh Dan sendiri: <br>  {% twitter 1021850499618955272%} </p><br><p>  DI (baik Dependecy Injection maupun Dependency Inversion), mungkin, adalah teknik yang paling dapat digunakan kembali di sini, mampu membuat hidup Anda jauh, lebih mudah. </p><br><blockquote>  Poin di sini - Komponen bisu bodoh! </blockquote><br><h4 id="solution-2---boundaries">  Solusi 2 - Batas </h4><br><p>  Ini adalah solusi yang cukup deklaratif, dan dapat memperluas <code>Solution 1</code> - cukup nyatakan semua titik <em>ekstensi</em> .  Bungkus saja dengan ... <code>Boundary</code> </p><br><pre> <code class="plaintext hljs">const Boundary = ({children}) =&gt; ( process.env.NODE_ENV === 'test' ? null : children // or `jest.mock` ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Boundary&gt;&lt;ASideContainer /&gt;&lt;/Boundary&gt;&lt;/aside&gt; &lt;Boundary&gt;&lt;Page /&gt;&lt;/Boundary&gt; &lt;/section&gt; );</code> </pre> <br><p>  Lalu - Anda dapat menonaktifkan, hanya nol, <code>Boundary</code> untuk mengurangi cakupan Komponen, dan membuatnya <em>terbatas</em> . </p><br><blockquote>  Poin di sini - Batas ada pada level komponen Bodoh.  Komponen bodoh mengendalikan bagaimana bodohnya itu. </blockquote><br><h3 id="solution-3---tier">  Solusi 3 - Tingkat </h3><br><p>  Sama dengan Solution 2, tetapi dengan Boundary yang lebih pintar, mampu mengejek <em>layer</em> , atau <em>tier</em> , atau apa pun yang Anda katakan: </p><br><pre> <code class="plaintext hljs">const checkTier = tier =&gt; tier === currentTier; const withTier = tier =&gt; WrapperComponent =&gt; (props) =&gt; ( (process.env.NODE_ENV !== 'test' || checkTier(tier)) &amp;&amp; &lt;WrapperComponent{...props} /&gt; ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;ASideContainer /&gt;&lt;/aside&gt; &lt;Page /&gt; &lt;/section&gt; ); const ASideContainer = withTier('UI')(...) const Page = withTier('Page')(...) const PageChromeContainer = withTier('UI')(PageChrome);</code> </pre> <br><blockquote>  Bahkan jika ini hampir mirip dengan Boundary example - Komponen bisu adalah Bisu, dan Kontainer mengendalikan visibilitas Kontainer lain. </blockquote><br><h4 id="solution-4---separate-concerns">  Solusi 4 - Kekhawatiran Terpisah </h4><br><p>  Solusi lain hanya untuk Masalah Terpisah!  Maksud saya - Anda sudah melakukannya, dan mungkin sekarang saatnya untuk menggunakannya. </p><br><blockquote>  Dengan <code>connect</code> komponen ke Redux atau GQL Anda menghasilkan Kontainer <em>terkenal</em> .  Maksud saya - dengan nama-nama <em>terkenal</em> - <code>Container(WrapperComponent)</code> .  Anda dapat mengejek mereka dengan nama mereka </blockquote><br><pre> <code class="plaintext hljs">const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;ASideContainer /&gt;&lt;/aside&gt; &lt;Page /&gt; &lt;/section&gt; ); // remove all components matching react-redux pattern reactRemock.mock(/Connect\(\w\)/) // all any other container reactRemock.mock(/Container/)</code> </pre> <br><p>  Pendekatan ini agak kasar - itu akan menghapus <em>semuanya</em> , membuat lebih sulit untuk menguji Contaiers sendiri, dan Anda dapat menggunakan mengejek yang sedikit lebih rumit untuk mempertahankan "yang pertama": </p><br><pre> <code class="plaintext hljs">import {createElement, remock} from 'react-remock'; // initially "open" const ContainerCondition = React.createContext(true); reactRemock.mock(/Connect\(\w\)/, (type, props, children) =&gt; ( &lt;ContainerCondition.Consumer&gt; { opened =&gt; ( opened ? ( // "close" and render real component &lt;ContainerCondition.Provider value={false}&gt; {createElement(type, props, ...children)} &lt;ContainerCondition.Provider&gt; ) // it's "closed" : null )} &lt;/ContainerCondition.Consumer&gt; )</code> </pre> <br><blockquote>  Intinya di sini: tidak ada logika di dalam atau Presentasi, bukan Wadah - semua logika ada di luar. </blockquote><br><h4 id="bonus-solution---separate-concerns">  Solusi Bonus - Kekhawatiran Terpisah </h4><br><p>  Anda dapat tetap menggunakan <em>kopling ketat</em> menggunakan <code>defaultProps</code> , dan membatalkan <code>defaultProps</code> ini dalam pengujian ... </p><br><pre> <code class="plaintext hljs">const PageChrome = ({Content = Page, Aside = ASideContainer}) =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Aside/&gt;&lt;/aside&gt; &lt;Content/&gt; &lt;/section&gt; );</code> </pre> <br><h2 id="so">  Jadi? </h2><br><p>  Jadi saya baru saja memposting beberapa cara untuk mengurangi cakupan komponen apa pun, dan membuatnya lebih dapat diuji.  Cara sederhana untuk mengeluarkan satu <code>gear</code> dari <code>gearbox</code> .  Pola sederhana untuk membuat hidup Anda lebih mudah. </p><br><p>  Tes E2E bagus, tetapi sulit untuk mensimulasikan beberapa kondisi, yang dapat terjadi di dalam fitur yang sangat bersarang dan siap untuk mereka.  Anda harus memiliki unit test untuk dapat mensimulasikan berbagai skenario.  Anda harus memiliki tes integrasi untuk memastikan semuanya terhubung dengan benar. </p><br><p>  Anda tahu, seperti yang ditulis Dan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikelnya yang lain</a> : </p><br><blockquote>  Misalnya, jika sebuah tombol dapat berada di salah satu dari 5 keadaan yang berbeda (normal, aktif, melayang, bahaya, dinonaktifkan), kode yang memperbarui tombol harus benar untuk 5 Ã— 4 = 20 kemungkinan transisi - atau melarang beberapa di antaranya.  Bagaimana kita menjinakkan ledakan kombinatorial dari keadaan yang memungkinkan dan membuat keluaran visual dapat diprediksi? </blockquote><p>  Sementara solusi yang tepat di sini adalah mesin negara, dapat memilih satu atom atau molekul tunggal dan bermain dengannya - adalah persyaratan dasar. </p><br><h3 id="the-main-points-of-this-article">  Poin utama dari artikel ini </h3><br><ol><li>  Komponen presentasi hanya boleh mengandung komponen presentasi lainnya. </li><li>  Wadah adalah Pohonnya.  Komponennya adalah Tree Leafs. </li><li>  Anda tidak harus <em>selalu</em> TIDAK mengandung Kontainer di dalam Presentational, tetapi <em>tidak</em> hanya memuatnya dalam tes. </li></ol><br><blockquote>  Anda dapat menyelam lebih dalam ke masalah dengan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel menengah</a> , tetapi di sini mari kita lewati semua gula. </blockquote><p>  PS: Ini adalah terjemahan dari artikel <em>ru-</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr versi habr</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436692/">https://habr.com/ru/post/id436692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436682/index.html">Jangan membuat JL (DSL) Anda sendiri untuk memperluas fungsionalitas aplikasi</a></li>
<li><a href="../id436684/index.html">Hari Jadi Android 10 (Q). Apa yang diketahui sekarang?</a></li>
<li><a href="../id436686/index.html">JPEG dari dunia 3D. Apa itu glTF?</a></li>
<li><a href="../id436688/index.html">Raksasa IT meninggalkan pasar untuk chip untuk pusat data - beri tahu kami apa artinya bagi industri</a></li>
<li><a href="../id436690/index.html">[Tanya - jawab] tentang kekayaan intelektual dan perlindungan data</a></li>
<li><a href="../id436694/index.html">Kompilator Pascal saya dan Seni Kontemporer Polandia</a></li>
<li><a href="../id436696/index.html">Cara menghasilkan suara binaural pada trek audio mono-channel - video akan membantu</a></li>
<li><a href="../id436698/index.html">Berapa banyak cara yang bisa saya tulis faktorial untuk Skema?</a></li>
<li><a href="../id436700/index.html">Anti-spoofing: bagaimana sistem pengenalan wajah melawan scammers?</a></li>
<li><a href="../id436704/index.html">Kisah tentang bagaimana kami memilih skala untuk otomatisasi register kas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>