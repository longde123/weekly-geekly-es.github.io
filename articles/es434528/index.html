<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüîß ü•Ñ üóª Descifrado de trazado de rayos del tama√±o de una postal üÜò ü§∞üèª üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""¬°Lo hizo de nuevo!": Esto es lo que se me ocurri√≥ cuando mir√© la parte posterior del folleto de Pixar [1] , completamente lleno de c√≥digo. Un grupo d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Descifrado de trazado de rayos del tama√±o de una postal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434528/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cr/xz/vj/crxzvjqqbw5gl4mv3wxxx2zw6wa.png"></div><br>  "¬°Lo hizo de nuevo!": Esto es lo que se me ocurri√≥ cuando mir√© la parte posterior del folleto de Pixar <sup>[1]</sup> , completamente lleno de c√≥digo.  Un grupo de construcciones y expresiones fue firmado en la esquina inferior derecha por nada menos que Andrew Kensler.  Para aquellos que no lo conocen, dir√©: Andrew es un programador que invent√≥ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">rastreador de rayos del tama√±o de una tarjeta de negocios de</a> 1337 bytes en 2009. <br><br>  Esta vez, a Andrew se le ocurri√≥ algo m√°s voluminoso, pero con un resultado visual mucho m√°s interesante.  Desde que termin√© de escribir los Libros negros de Game Engine sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wolf3D</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DOOM</a> , tuve tiempo de aprender el interior de su c√≥digo cr√≠ptico.  Y casi de inmediato, me fascinaron literalmente las t√©cnicas descubiertas en √©l.  Eran muy diferentes del trabajo anterior de Andrew, basado en un trazador de rayos "est√°ndar".  Estaba interesado en aprender sobre la marcha de rayos, las caracter√≠sticas de la geometr√≠a volum√©trica constructiva, el trazado de trazado / trazado de Monte Carlo, as√≠ como muchos otros trucos que utiliz√≥ para comprimir el c√≥digo en un trozo de papel tan peque√±o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yc/z4/nt/ycz4ntg3qh91i6m2wymfccaekvk.png"></div><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lf/2o/qv/lf2oqvd5d39pyfwxyixvjnrmlqq.png"></div><br><h2>  C√≥digo fuente </h2><br><hr><br>  El frente del volante es un anuncio para el departamento de reclutamiento de Pixar.  En el reverso, se imprimen 2,037 bytes de c√≥digo C ++, ofuscados para ocupar la superficie m√°s peque√±a posible. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; // card &gt; pixar.ppm #include &lt;stdio.h&gt; #include &lt;math.h&gt; #define R return #define O operator typedef float F;typedef int I;struct V{F x,y,z;V(F v=0){x=y=z=v;}V(F a,F b,F c=0){x=a;y=b;z=c;}V O+(V r){RV(x+rx,y+ry,z+rz);}VO*(V r){RV(x*rx,y*r. y,z*rz);}FO%(V r){R x*r.x+y*r.y+z*rz;}VO!(){R*this*(1/sqrtf(*this%*this) );}};FL(F l,F r){R l&lt;r?l:r;}FU(){R(F)rand()/RAND_MAX;}FB(V p,V l,V h){l=p +l*-1;h=h+p*-1;RL(L(L(lx,hx),L(ly,hy)),L(lz,hz));}FS(V p,I&amp;m){F d=1\ e9;V f=p;fz=0;char l[]="5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_]OWW[WaOa_aW\ eWa_e_cWiO";for(I i=0;i&lt;60;i+=4){V b=V(l[i]-79,l[i+1]-79)*.5,e=V(l[i+2]-79,l [i+3]-79)*.5+b*-1,o=f+(b+e*L(-L((b+f*-1)%e/(e%e),0),1))*-1;d=L(d,o%o);}d=sq\ rtf(d);V a[]={V(-11,6),V(11,6)};for(I i=2;i--;){V o=f+a[i]*-1;d=L(d,ox&gt;0?f\ absf(sqrtf(o%o)-2):(o.y+=oy&gt;0?-2:2,sqrtf(o%o)));}d=powf(powf(d,8)+powf(pz, 8),.125)-.5;m=1;F r=L(-L(B(p,V(-30,-.5,-30),V(30,18,30)),B(p,V(-25,17,-25),V (25,20,25))),B(V(fmodf(fabsf(px),8),py,pz),V(1.5,18.5,-25),V(6.5,20,25))) ;if(r&lt;d)d=r,m=2;F s=19.9-py;if(s&lt;d)d=s,m=3;R d;}IM(V o,V d,V&amp;h,V&amp;n){I m,s= 0;F t=0,c;for(;t&lt;100;t+=c)if((c=S(h=o+d*t,m))&lt;.01||++s&gt;99)R n=!V(S(h+V(.01,0 ),s)-c,S(h+V(0,.01),s)-c,S(h+V(0,0,.01),s)-c),m;R 0;}VT(V o,V d){V h,n,r,t= 1,l(!V(.6,.6,1));for(I b=3;b--;){I m=M(o,d,h,n);if(!m)break;if(m==1){d=d+n*( n%d*-2);o=h+d*.1;t=t*.2;}if(m==2){F i=n%l,p=6.283185*U(),c=U(),s=sqrtf(1-c), g=nz&lt;0?-1:1,u=-1/(g+nz),v=nx*ny*u;d=V(v,g+ny*ny*u,-ny)*(cosf(p)*s)+V( 1+g*nx*nx*u,g*v,-g*nx)*(sinf(p)*s)+n*sqrtf(c);o=h+d*.1;t=t*.2;if(i&gt;0&amp;&amp;M(h +n*.1,l,h,n)==3)r=r+t*V(500,400,100)*i;}if(m==3){r=r+t*V(50,80,100);break;}} R r;}I main(){I w=960,h=540,s=16;V e(-22,5,25),g=!(V(-3,4,0)+e*-1),l=!V(gz, 0,-gx)*(1./w),u(gy*lz-gz*ly,gz*lx-gx*lz,gx*ly-gy*lx);printf("P\ 6 %d %d 255 ",w,h);for(I y=h;y--;)for(I x=w;x--;){V c;for(I p=s;p--;)c=c+T(e ,!(g+l*(xw/2+U())+u*(yh/2+U())));c=c*(1./s)+14./241;V o=c+1;c=V(cx/ox,c. y/oy,cz/oz)*255;printf("%c%c%c",(I)cx,(I)cy,(I)cz);}}// Andrew Kensler</span></span></span></span></code> </pre> <br><h2>  ¬ø√âl incluso trabaja? </h2><br><hr><br>  Con el c√≥digo hay una instrucci√≥n para su lanzamiento.  La idea es redirigir la salida est√°ndar a un archivo.  Por extensi√≥n, podemos suponer que el formato de salida es un formato de imagen de texto llamado NetPBM <sup>[2]</sup> . <br><br><pre>  $ clang -o card2 -O3 raytracer.cpp
 $ time ./card&gt; pixar.ppm<font></font>
<font></font>
 2m58.524s reales
 usuario 2m57.567s
 sys 0m0.415s </pre><br>  Despu√©s de dos minutos y cincuenta y ocho segundos <sup>[3]</sup> , se genera la siguiente imagen.  Es sorprendente la poca cantidad de c√≥digo que se requiere para ello. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cae/b34/b5c/caeb34b5c6c57c4598adc8f6b3f28f38.webp"></div><br>  Puedes extraer mucho de la imagen de arriba.  El grano es un signo obvio de un "trazador de ruta".  Este tipo de renderizador difiere del trazado de rayos en que los rayos no se remontan a las fuentes de luz.  En este m√©todo, se emiten miles de rayos por p√≠xel desde las fuentes y el programa los monitorea, esperando que encuentren la fuente de luz.  Esta es una t√©cnica interesante que, mucho mejor que el trazado de rayos, puede manejar la representaci√≥n de oclusi√≥n ambiental, sombras suaves, c√°usticos y radiosidad. <br><br><h2>  Romperemos el c√≥digo en partes </h2><br><hr><br>  Pasar la entrada a CLion formatea el c√≥digo (vea la salida <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ) y lo divide en partes / tareas m√°s peque√±as. <br><br><pre>  <font color="grey">#include &lt;stdlib.h&gt; // card&gt; pixar.ppm</font> <font color="grey">
</font>  <font color="grey">#include &lt;stdio.h&gt;</font> <font color="grey">
</font>  <font color="grey">#include &lt;math.h&gt;</font> </pre><br><pre>  <font color="fuchsia">#define R return</font> <font color="fuchsia">
</font>  <font color="fuchsia">#define el operador O</font> <font color="fuchsia">
</font>  <font color="fuchsia">typedef float F; typedef int I;</font> </pre><pre>  <font color="blue">struct V {F x, y, z; V (F v = 0) {x = y = z = v;} V (F a, F b, F</font> <font color="blue">
</font>  <font color="blue">c = 0) {x = a; y = b; z = c;} V O + (V r) {RV (x + rx, y + ry, z + rz);} VO * (V r) {RV ( x * rx, y * r.</font> <font color="blue">
</font>  <font color="blue">y, z * rz);} FO% (V r) {R x * r.x + y * r.y + z * rz;} VO! () {R * this * (1 / sqrtf (* this% * esto)</font> <font color="blue">
</font>  <font color="blue">);}};</font> </pre><pre>  <font color="orange">FL (F l, F r) {R l &lt;r? L: r;} FU () {R (F) rand () / RAND_MAX;} FB (V p, V l, V h) {l = p</font> <font color="orange">
</font>  <font color="orange">+ l * -1; h = h + p * -1; RL (L (L (L (lx, hx), L (ly, hy)), L (lz, hz));}</font> </pre><pre>  <font color="LimeGreen">FS (V p, I &amp; m) {F d = 1 \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">e9; V f = p; fz = 0; char l [] = "5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_] OWW [WaOa_aW \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">eWa_e_cWiO "; para (I i = 0; i &lt;60; i + = 4) {V b = V (l [i] -79, l [i + 1] -79) *. 5, e = V (l [ i + 2] -79, l</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">[i + 3] -79) *. 5 + b * -1, o = f + (b + e * L (-L ((b + f * -1)% e / (e% e), 0), 1)) * - 1; d = L (d, o% o);} d = sq \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">rtf (d); V a [] = {V (-11.6), V (11.6)}; para (I i = 2; i -;) {V o = f + a [i] * -1; d = L (d, ox&gt; 0? F \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">absf (sqrtf (o% o) -2) :( o.y + = oy&gt; 0? -2: 2, sqrtf (o% o)));} d = powf (powf (d, 8) + powf (pz ,</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">8) ,. 125) -. 5; m = 1; F r = L (-L (B (p (V, -30, -. 5, -30), V (30,18,30)), B (p, V (-25.17, -25), V</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">(25,20,25))), B (V (fmodf (fabsf (px), 8), py, pz), V (1.5,18.5, -25), V (6.5,20,25)))</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">; if (r &lt;d) d = r, m = 2; F s = 19.9-py; if (s &lt;d) d = s, m = 3; R d;}</font> </pre><pre>  <font color="black">IM (V o, V d, V &amp; h, V &amp; n) {I m, s =</font> <font color="black">
</font>  <font color="black">0; F t = 0, c; para (; t &lt;100; t + = c) if ((c = S (h = o + d * t, m)) &lt;. 01 || ++ s&gt; 99) R n =! V (S (h + V (.01,0</font> <font color="black">
</font>  <font color="black">), s) -c, S (h + V (0, .01), s) -c, S (h + V (0,0, .01), s) -c), m; R 0;}</font> </pre><pre>  <font color="SkyBlue">VT (V o, V d) {V h, n, r, t =</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1, l (! V (.6, .6,1)); para (I b = 3; b -;) {I m = M (o, d, h, n); si (! M) se rompe ; if (m == 1) {d = d + n * (</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">n% d * -2); o = h + d * .1; t = t * .2;} if (m == 2) {F i = n% l, p = 6.283185 * U (), c = U (), s = sqrtf (1-c),</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">g = nz &lt;0? -1: 1, u = -1 / (g + nz), v = nx * ny * u; d = V (v, g + ny * ny * u, -ny) * (cosf (p) * s) + V (</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1 + g * nx * nx * u, g * v, -g * nx) * (sinf (p) * s) + n * sqrtf (c); o = h + d * .1; t = t *. 2; if (i&gt; 0 &amp;&amp; M (h</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">+ n * .1, l, h, n) == 3) r = r + t * V (500,400,100) * i;} if (m == 3) {r = r + t * V (50,80,100) ; descanso;}}</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">R r;}</font> </pre><pre>  <font color="red">I main () {I w = 960, h = 540, s = 16; V e (-22,5,25), g =! (V (-3,4,0) + e * -1), l =! V (gz,</font> <font color="red">
</font>  <font color="red">0, -gx) * (1./w), u (gy * lz-gz * ly, gz * lx-gx * lz, gx * ly-gy * lx); printf ("P \</font> <font color="red">
</font>  <font color="red">6% d% d 255 ", w, h); para (I y = h; y -;) para (I x = w; x -;) {V c; para (I p = s; p- -;) c = c + T (e</font> <font color="red">
</font>  <font color="red">,! (g + l * (xw / 2 + U ()) + u * (yh / 2 + U ()))); c = c * (1./s) + 14. / 241; V o = c + 1; c = V (cx / ox, c.</font> <font color="red">
</font>  <font color="red">y / oy, cz / oz) * 255; printf ("% c% c% c", (I) cx, (I) cy, (I) cz);}}</font> </pre><pre>  <font color="LightGray">// Andrew Kensler</font> </pre><br>  Cada una de las secciones se describe en detalle en el resto del art√≠culo: <br>  <font color="fuchsia">‚ñ†</font> - trucos ordinarios, <font color="blue">‚ñ†</font> - clase de vector, <font color="orange">‚ñ†</font> - c√≥digo auxiliar, <font color="LimeGreen">‚ñ†</font> - base de datos, <font color="black">‚ñ†</font> - marcha de rayos, <font color="SkyBlue">‚ñ†</font> - muestreo, <font color="red">‚ñ†</font> - c√≥digo principal. <br><br><h2>  Trucos comunes con #define y typedef </h2><br><hr><br>  Los trucos comunes est√°n usando #define y typedef para reducir significativamente la cantidad de c√≥digo.  Aqu√≠ denotamos F = float, I = int, R = return y O = operator.  La ingenier√≠a inversa es trivial. <br><br><h2>  Clase v </h2><br><hr><br>  Luego viene la clase V, que renombr√© a Vec (aunque, como veremos a continuaci√≥n, tambi√©n se usa para almacenar canales RGB en formato flotante). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = y = z = v; } Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = a; y = b; z = c;} Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x + rx, y + ry, z + rz); } Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x * rx, y * ry, z * rz); } <span class="hljs-comment"><span class="hljs-comment">// dot product float operator%(Vec r) { return x * rx + y * ry + z * rz; } // inverse square root Vec operator!() {return *this * (1 / sqrtf(*this % *this) );} };</span></span></code> </pre> <br>  Tenga en cuenta que no hay operador de resta (-), por lo que en lugar de escribir "X = A - B", se utiliza "X = A + B * -1".  La ra√≠z cuadrada inversa es √∫til m√°s adelante para normalizar los vectores. <br><br><h2>  Funci√≥n principal </h2><br><hr><br>  main () es el √∫nico car√°cter que no puede ofuscarse porque es invocado por la funci√≥n _start de la biblioteca libc.  Por lo general, vale la pena comenzar con √©l, porque ser√° m√°s f√°cil trabajar de esta manera.  Me tom√≥ un tiempo entender el significado de las primeras letras, pero aun as√≠ logr√© crear algo legible. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = <span class="hljs-number"><span class="hljs-number">960</span></span>, h = <span class="hljs-number"><span class="hljs-number">540</span></span>, samplesCount = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">position</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-22</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Vec goal = !(Vec(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + position * <span class="hljs-number"><span class="hljs-number">-1</span></span>); Vec left = !Vec(goal.z, <span class="hljs-number"><span class="hljs-number">0</span></span>, -goal.x) * (<span class="hljs-number"><span class="hljs-number">1.</span></span> / w); <span class="hljs-comment"><span class="hljs-comment">// Cross-product to get the up vector Vec up(goal.y * left.z - goal.z * left.y, goal.z * left.x - goal.x * left.z, goal.x * left.y - goal.y * left.x); printf("P6 %d %d 255 ", w, h); for (int y = h; y--;) for (int x = w; x--;) { Vec color; for (int p = samplesCount; p--;) color = color + Trace(position, !(goal + left * (x - w / 2 + randomVal())+ up * (y - h / 2 + randomVal()))); // Reinhard tone mapping color = color * (1. / samplesCount) + 14. / 241; Vec o = color + 1; color = Vec(color.x / ox, color.y / oy, color.z / oz) * 255; printf("%c%c%c", (int) color.x, (int) color.y, (int) color.z); } }</span></span></code> </pre> <br>  Tenga en cuenta que los literales flotantes no contienen la letra "f", y la parte fraccionaria se descarta para ahorrar espacio.  El mismo truco se usa a continuaci√≥n, donde se cae la parte entera (flotante x = .5).  Tambi√©n es inusual la construcci√≥n "for" con una expresi√≥n de iteraci√≥n insertada dentro de la condici√≥n de interrupci√≥n. <br><br>  Esta es una funci√≥n principal bastante est√°ndar para un rayo / trazado de ruta.  Aqu√≠ se establecen vectores de c√°mara y se emiten rayos para cada p√≠xel.  La diferencia entre el trazador de rayos y el trazador de ruta es que se emiten varios rayos por p√≠xel en el TP, que se desplazan ligeramente al azar.  Luego, el color obtenido para cada rayo en un p√≠xel se acumula en tres canales flotantes R, B, G.  Al final, se realiza la correcci√≥n tonal del resultado del m√©todo Reinhardt. <br><br>  La parte m√°s importante es sampleCount, que te√≥ricamente se puede establecer en 1 para acelerar el renderizado y la iteraci√≥n.  Aqu√≠ hay representaciones de muestra con valores de muestra de 1 a 2048. <br><br><div class="spoiler">  <b class="spoiler_title">Encabezado de spoiler</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/550/e66/b2b/550e66b2b1347f8cafdf18c50d89e40d.png"><br><br>  1 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f49/724/1f0/f497241f0e3bb43fcc9913d8a2745419.png"><br><br>  2 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f71/3f3/35c/f713f335c2842b995936db1499e307e5.png"><br><br>  4 4 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/6d4/f56/b4f6d4f56198a64b8e569a62f7159e8a.png"><br><br>  8 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a70/200/3c6/a702003c61d4080c2f92fe84844238cd.png"><br><br>  16 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bcf/0d6/43c/bcf0d643c501839c2506c7c026bc445c.png"><br><br>  32 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f0/5cf/569/8f05cf5690fa3265a1a4fa6f60a35749.png"><br><br>  64 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebd/c87/660/ebdc87660263ff14eb6bf03a95865f34.png"><br><br>  128 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d17/0d3/1ae/d170d31aed20aeafc54d877ed447a1cc.png"><br><br>  256 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"><br><br>  512 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/460/50f/715/46050f71582834ddebbeb29dd86940fc.png"><br><br>  1024 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/947/ea8/88b/947ea888b63c32f0892cc1e25b187bf8.png"><br><br>  2048 </div></div><br><h2>  C√≥digo de ayuda </h2><br><hr><br>  Otra pieza simple de c√≥digo son las funciones auxiliares.  En este caso, tenemos una funci√≥n trivial min (), un generador de valores aleatorios en el intervalo [0,1] y una prueba mucho m√°s interesante boxTest (), que forma parte del sistema Constructive Solid Geometry (CSG) utilizado para cortar el mundo.  CSG se discute en la siguiente secci√≥n. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l &lt; r ? l : r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomVal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) rand() / RAND_MAX; } <span class="hljs-comment"><span class="hljs-comment">// Rectangle CSG equation. Returns minimum signed distance from // space carved by lowerLeft vertex and opposite rectangle // vertex upperRight. float BoxTest(Vec position, Vec lowerLeft, Vec upperRight) { lowerLeft = position + lowerLeft * -1; upperRight = upperRight + position * -1; return -min( min( min(lowerLeft.x, upperRight.x), min(lowerLeft.y, upperRight.y) ), min(lowerLeft.z, upperRight.z)); }</span></span></code> </pre> <br><h2>  Funciones de geometr√≠a volum√©trica constructiva. </h2><br><hr><br>  No hay v√©rtices en el c√≥digo.  Todo se hace usando las funciones CSG.  Si no est√° familiarizado con ellos, simplemente diga que se trata de funciones que describen si la coordenada est√° dentro o fuera del objeto.  Si la funci√≥n devuelve una distancia positiva, entonces el punto est√° dentro del objeto.  Una distancia negativa indica que el punto est√° fuera del objeto.  Hay muchas funciones para describir diferentes objetos, pero en aras de la simplificaci√≥n, tomemos por ejemplo una esfera y dos puntos, A y B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56f/424/13a/56f42413a77c51a3d06e12fd4b4b385e.svg" alt="imagen"></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to sphere(c,r) float testSphere(Vec p, Vec c, float r) { Vec delta = c - p; float distance = sqrtf(delta%delta); return radius - distance; } Vec A {4, 6}; Vec B {3, 2}; Vec C {4, 2}; float r = 2.; testSphere(A, C, r); // == -1 (outside) testSphere(B, C, r); // == 1 (inside)</span></span></code> </pre> <br>  La funci√≥n testSphere () devuelve -1 para el punto A (es decir, est√° afuera) y 1 para B (es decir, est√° adentro).  Las se√±ales a distancia son solo un truco, que le permite obtener dos piezas de informaci√≥n en lugar de una en el caso de un solo valor.  Tambi√©n se puede escribir un tipo de funci√≥n similar para describir un paralelogramo (esto es exactamente lo que se realiza en la funci√≥n BoxTest). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/1cd/25b/7571cd25baa7d2f9cfbd01f62e84aef1.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to Box(c1,c2) float testRectangle(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testRectangle(A, C1, C2); // 1.41 (inside) testRectangle(B, C1, C2); // -2.23 (outside)</span></span></code> </pre> <br>  Ahora veamos qu√© sucede si voltea el signo del valor de retorno. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/017/bd8/dcd017bd89a9e9d3955c94be3645aa20.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to carved box(c1,c2) float testCarveBox(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return -min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testCarveBox(A, C1, C2); // == -1.41 (outside) testCarveBox(B, C1, C2); // == 2.23 (inside)</span></span></code> </pre> <br>  Ahora no describimos un objeto s√≥lido, sino que declaramos que todo el mundo es s√≥lido y cortamos el espacio vac√≠o en √©l.  Las funciones se pueden usar como ladrillos de construcci√≥n, que cuando se combinan pueden describir formas m√°s complejas.  Usando el operador de suma l√≥gica (funci√≥n min) podemos cortar un par de rect√°ngulos uno encima del otro y el resultado se ver√° as√≠. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/f78/615/48bf786150f9d37af1f51fd12987162e.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point to room float testRoom(Vec p) { Vec C1 {2, 4}; Vec C2 {5, 2}; // Lower room Vec C3 {3, 5}; Vec C4 {4, 4}; // Upper room // min() is the union of the two carved volumes. return min(testCarvedBox(p, C1, C2), testCarvedBox(p, C3, C4)); } Vec A {3, 3}; Vec B {4, 6}; testRoom(A, C1, C2); // == -1.41 (outside) testRoom(B, C1, C2); // == 1.00 (inside)</span></span></code> </pre> <br>  Si lo piensas bien, se parece a la habitaci√≥n que estamos estudiando, porque la habitaci√≥n inferior se expresa exactamente de esta manera, con la ayuda de dos paralelogramos cortados. <br><br>  Ahora, habiendo dominado el poderoso conocimiento de CSG, podemos volver al c√≥digo y considerar la funci√≥n de la base de datos, que es la m√°s dif√≠cil de manejar. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_NONE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_LETTER 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_WALL 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_SUN 3 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Sample the world using Signed Distance Fields. float QueryDatabase(Vec position, int &amp;hitType) { float distance = 1e9; Vec f = position; // Flattened position (z=0) fz = 0; char letters[15*4+1] = // 15 two points lines "5O5_" "5W9W" "5_9_" // P (without curve) "AOEO" "COC_" "A_E_" // I "IOQ_" "I_QO" // X "UOY_" "Y_]O" "WW[W" // A "aOa_" "aWeW" "a_e_" "cWiO"; // R (without curve) for (int i = 0; i &lt; sizeof(letters); i += 4) { Vec begin = Vec(letters[i] - 79, letters[i + 1] - 79) * .5; Vec e = Vec(letters[i + 2] - 79, letters[i + 3] - 79) * .5 + begin * -1; Vec o = f + (begin + e * min(-min((begin + f * -1) % e / (e % e), 0), 1) ) * -1; distance = min(distance, o % o); // compare squared distance. } distance = sqrtf(distance); // Get real distance, not square distance. // Two curves (for P and R in PixaR) with hard-coded locations. Vec curves[] = {Vec(-11, 6), Vec(11, 6)}; for (int i = 2; i--;) { Vec o = f + curves[i] * -1; distance = min(distance, ox &gt; 0 ? fabsf(sqrtf(o % o) - 2) : (oy += oy &gt; 0 ? -2 : 2, sqrtf(o % o)) ); } distance = powf(powf(distance, 8) + powf(position.z, 8), .125) - .5; hitType = HIT_LETTER; float roomDist ; roomDist = min(// min(A,B) = Union with Constructive solid geometry //-min carves an empty space -min(// Lower room BoxTest(position, Vec(-30, -.5, -30), Vec(30, 18, 30)), // Upper room BoxTest(position, Vec(-25, 17, -25), Vec(25, 20, 25)) ), BoxTest( // Ceiling "planks" spaced 8 units apart. Vec(fmodf(fabsf(position.x), 8), position.y, position.z), Vec(1.5, 18.5, -25), Vec(6.5, 20, 25) ) ); if (roomDist &lt; distance) distance = roomDist, hitType = HIT_WALL; float sun = 19.9 - position.y ; // Everything above 19.9 is light source. if (sun &lt; distance)distance = sun, hitType = HIT_SUN; return distance; }</span></span></span></span></code> </pre> <br>  Puede ver aqu√≠ la funci√≥n de "cortar" el paralelogramo, en el que solo se utilizan dos rect√°ngulos para construir toda la habitaci√≥n (nuestro cerebro hace el resto, representa las paredes).  La escalera horizontal es una funci√≥n CSG un poco m√°s compleja que utiliza la divisi√≥n del resto.  Y finalmente, las letras de la palabra PIXAR est√°n formadas por 15 l√≠neas con un par ‚Äúorigen / delta‚Äù y dos casos especiales para curvas en las letras P y R. <br><br><h2>  Rayo marchando </h2><br><hr><br>  Con una base de datos de funciones CSG que describe el mundo, es suficiente para omitir todos los rayos emitidos en la funci√≥n main ().  La marcha de rayos usa la funci√≥n de distancia.  Esto significa que la posici√≥n de muestreo se desplaza una distancia hacia el obst√°culo m√°s cercano. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Perform signed sphere marching // Returns hitType 0, 1, 2, or 3 and update hit position/normal int RayMarching(Vec origin, Vec direction, Vec &amp;hitPos, Vec &amp;hitNorm) { int hitType = HIT_NONE; int noHitCount = 0; float d; // distance from closest object in world. // Signed distance marching for (float total_d=0; total_d &lt; 100; total_d += d) if ((d = QueryDatabase(hitPos = origin + direction * total_d, hitType)) &lt; .01 || ++noHitCount &gt; 99) return hitNorm = !Vec(QueryDatabase(hitPos + Vec(.01, 0), noHitCount) - d, QueryDatabase(hitPos + Vec(0, .01), noHitCount) - d, QueryDatabase(hitPos + Vec(0, 0, .01), noHitCount) - d) , hitType; // Weird return statement where a variable is also updated. return 0; }</span></span></code> </pre> <br>  La idea de la marcha de rayos basada en la distancia es avanzar una distancia hasta el objeto m√°s cercano.  Al final, el haz se acercar√° tanto a la superficie que puede considerarse un punto de incidencia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e99/774/398/e997743989aa1cb22fb65e6d5d8e93f2.svg"></div><br>  Tenga en cuenta que la marcha de rayos no devuelve una verdadera intersecci√≥n con la superficie, sino una aproximaci√≥n.  Es por eso que la marcha se detiene en el c√≥digo cuando d &lt;0.01f. <br><br><h2>  Poniendo todo junto: muestreo </h2><br><hr><br>  La investigaci√≥n del trazado de ruta est√° casi completa.  Nos falta un puente que conecte la funci√≥n main () con el rayo marcher.  Esta √∫ltima parte, a la que renombr√© "Trace", es el "cerebro" en el que los rayos rebotan o se detienen, dependiendo de lo que encuentren. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vec origin, Vec direction)</span></span></span><span class="hljs-function"> </span></span>{ Vec sampledPosition, normal, color, attenuation = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lightDirection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!Vec(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Directional light for (int bounceCount = 3; bounceCount--;) { int hitType = RayMarching(origin, direction, sampledPosition, normal); if (hitType == HIT_NONE) break; // No hit. This is over, return color. if (hitType == HIT_LETTER) { // Specular bounce on a letter. No color acc. direction = direction + normal * ( normal % direction * -2); origin = sampledPosition + direction * 0.1; attenuation = attenuation * 0.2; // Attenuation via distance traveled. } if (hitType == HIT_WALL) { // Wall hit uses color yellow? float incidence = normal % lightDirection; float p = 6.283185 * randomVal(); float c = randomVal(); float s = sqrtf(1 - c); float g = normal.z &lt; 0 ? -1 : 1; float u = -1 / (g + normal.z); float v = normal.x * normal.y * u; direction = Vec(v, g + normal.y * normal.y * u, -normal.y) * (cosf(p) * s) + Vec(1 + g * normal.x * normal.x * u, g * v, -g * normal.x) * (sinf(p) * s) + normal * sqrtf(c); origin = sampledPosition + direction * .1; attenuation = attenuation * 0.2; if (incidence &gt; 0 &amp;&amp; RayMarching(sampledPosition + normal * .1, lightDirection, sampledPosition, normal) == HIT_SUN) color = color + attenuation * Vec(500, 400, 100) * incidence; } if (hitType == HIT_SUN) { // color = color + attenuation * Vec(50, 80, 100); break; // Sun Color } } return color; }</span></span></code> </pre> <br>  Experiment√© un poco con esta funci√≥n para cambiar el n√∫mero m√°ximo de reflejos de haz permitidos.  El valor "2" le da a las letras un color Vantablack lacado sorprendentemente hermoso <sup>[4]</sup> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/940/a3e/d10940a3ed7efab3271097904ce50d77.png"></div><br>  <i>1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0c/8b2/c3b/e0c8b2c3b249057b1f5fd0d166e12014.png"></div><br>  <i>2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"></div><br>  <i>3</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/2f5/716/65c2f5716578caaa2fcc454a49376578.png"></div><br>  <i>4 4</i> <br><br><h2>  C√≥digo fuente completamente limpio </h2><br><hr><br>  Para poner todo junto, cre√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo fuente</a> completamente limpio. <br><br><h2>  Referencias </h2><br><hr><br>  [1] Fuente: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n de Twitter de lexfrench el 8 de octubre de 2018.</a> <br><br>  [2] Fuente: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia: formato de imagen NetPBM</a> <br><br>  [3] Fuente: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">visualizaci√≥n realizada en el MacBook Pro m√°s potente, 2017</a> <br><br>  [4] Fuente: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wikipedia: Vantablack</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es434528/">https://habr.com/ru/post/es434528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es434514/index.html">DPAPI o DPAPI "Secretos" para Pentesters</a></li>
<li><a href="../es434516/index.html">Una manera f√°cil de lidiar con sus aspiraciones profesionales.</a></li>
<li><a href="../es434518/index.html">Aplausos y v√≠tores: drama cuidadosamente controlado en las tiendas de Apple</a></li>
<li><a href="../es434522/index.html">Patrones de justificaci√≥n de tareas y antipatrones</a></li>
<li><a href="../es434524/index.html">Kubernetes Ingress a trav√©s de los ojos de un principiante</a></li>
<li><a href="../es434530/index.html">Calendario predeterminado, correcciones en LDAP y otras innovaciones en Zimbra 8.8.11</a></li>
<li><a href="../es434532/index.html">La historia de un proyecto: cuando un equipo no tiene un desarrollador senior</a></li>
<li><a href="../es434534/index.html">ONYX BOOX "Mi primer libro": lectura inofensiva para mam√° y beb√©</a></li>
<li><a href="../es434538/index.html">La lucha por el espacio: lo que est√° sucediendo en el mercado satelital de Internet</a></li>
<li><a href="../es434540/index.html">¬øQu√© hacer con las personas que ser√°n reemplazadas por robots?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>