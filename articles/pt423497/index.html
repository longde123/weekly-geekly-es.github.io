<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéñÔ∏è üåú ‚õπüèΩ Vamos tentar falar sobre m√°quinas de estado hier√°rquico em geral e seu suporte no SObjectizer-5 em particular ü§µüèª üë®üèΩ‚Äçüé§ ü§¶üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="M√°quinas de estados finitos s√£o talvez um dos conceitos mais fundamentais e amplamente utilizados em programa√ß√£o. M√°quinas de estado finito (KA) s√£o u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vamos tentar falar sobre m√°quinas de estado hier√°rquico em geral e seu suporte no SObjectizer-5 em particular</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423497/">  M√°quinas de estados finitos s√£o talvez um dos conceitos mais fundamentais e amplamente utilizados em programa√ß√£o.  M√°quinas de estado finito (KA) s√£o usadas ativamente em muitos nichos aplicados.  Em particular, em nichos como APCS e telecomunica√ß√µes, com os quais era poss√≠vel lidar, as naves espaciais s√£o encontradas com um pouco menos de frequ√™ncia do que em todas as etapas. <br><br>  Portanto, neste artigo, tentaremos falar sobre naves espaciais, principalmente sobre m√°quinas hier√°rquicas de estados finitos e seus recursos avan√ßados.  E conte um pouco sobre o suporte a naves espaciais no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SObjectizer-5</a> , a estrutura ‚Äúator‚Äù para C ++.  Um desses <s>dois</s> que s√£o abertos, gratuitos, multiplataforma e ainda est√£o vivos. <br><br>  Mesmo se voc√™ n√£o estiver interessado no SObjectizer, mas nunca ouviu falar de m√°quinas hier√°rquicas de estados finitos ou de qu√£o √∫teis s√£o os recursos avan√ßados de uma espa√ßonave, como manipuladores de entrada / sa√≠da para estados ou hist√≥rico de status, voc√™ pode estar interessado em olhar sob o gato e leia pelo menos a primeira parte do artigo. <br><a name="habracut"></a><br><h1>  Palavras gerais sobre m√°quinas de estados finitos </h1><br>  N√£o tentaremos realizar um programa educacional completo no artigo sobre o t√≥pico de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aut√¥matos</a> e uma variedade de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√°quinas de estados finitos</a> .  O leitor precisa ter pelo menos um entendimento b√°sico desses tipos de entidades. <br><br><h2>  M√°quinas avan√ßadas de estado finito e seus recursos </h2><br>  A nave espacial possui v√°rios recursos "avan√ßados" que aumentam bastante a usabilidade da nave espacial no programa.  Vamos dar uma olhada r√°pida nesses recursos "avan√ßados". <br><br>  Isen√ß√£o de responsabilidade: se o leitor estiver familiarizado com os diagramas de estado da UML, ele n√£o encontrar√° nada de novo aqui. <br><br><h3>  M√°quinas de estado hier√°rquico </h3><br>  Talvez a oportunidade mais importante e valiosa seja a organiza√ß√£o de uma hierarquia / agrupamento de estados.  Como √© precisamente a capacidade de colocar estados um no outro que elimina a ‚Äúexplos√£o‚Äù do n√∫mero de transi√ß√µes de estado para estado, √† medida que a complexidade da espa√ßonave aumenta. <br><br>  √â mais dif√≠cil explicar isso em palavras do que mostrar pelo exemplo.  Portanto, vamos imaginar que temos um infokiosk na tela em que uma mensagem de boas-vindas √© exibida pela primeira vez.  O usu√°rio pode selecionar o item "Servi√ßos" e ir para a se√ß√£o para selecionar os servi√ßos de que precisa.  Ou ele pode selecionar o item "Conta pessoal" e ir para a se√ß√£o sobre como trabalhar com seus dados e servi√ßos pessoais.  Ou ele pode selecionar a se√ß√£o Ajuda.  At√© agora, tudo parece ser simples e pode ser representado pelo seguinte diagrama de estado (o mais simplificado poss√≠vel): <br><br><img src="https://habrastorage.org/webt/6e/lv/bm/6elvbm4wcsbmfbjaasp8zynjmtw.png"><br><br>  Mas vamos tentar garantir que, clicando no bot√£o "Cancelar", o usu√°rio possa retornar de qualquer se√ß√£o para a p√°gina inicial com uma mensagem de boas-vindas: <br><br><img src="https://habrastorage.org/webt/ok/hn/u3/okhnu3xrsjiss8u1fl1gygirn9u.png"><br><br>  O esquema est√° ficando complicado, mas ainda est√° sob controle.  No entanto, lembremos que na se√ß√£o "Servi√ßos", podemos ter v√°rias outras subse√ß√µes, por exemplo, "Servi√ßos populares", "Novos servi√ßos" e "Lista completa".  E em cada uma dessas se√ß√µes, voc√™ tamb√©m precisa retornar √† p√°gina inicial.  Nossa espa√ßonave simples est√° se tornando cada vez mais dif√≠cil: <br><br><img src="https://habrastorage.org/webt/ic/zx/hu/iczxhus-j_5ohrzwdxpbdf5n2qi.png"><br><br>  Mas isso est√° longe de tudo.  Ainda n√£o levamos em conta o bot√£o "Voltar", pelo qual precisamos retornar √† se√ß√£o anterior.  Vamos adicionar uma rea√ß√£o ao bot√£o "Voltar" e ver o que temos: <br><br><img src="https://habrastorage.org/webt/mn/rq/t7/mnrqt7zjk8kyq6e3i1-jb9fgwya.png"><br><br>  Sim, agora vemos o caminho para a verdadeira divers√£o.  Mas nem sequer consideramos as subse√ß√µes nas se√ß√µes "Minha conta" e "Ajuda" ... Se come√ßarmos, ent√£o quase imediatamente nossa espa√ßonave simples, a princ√≠pio, se tornar√° algo inimagin√°vel. <br><br>  Aqui a aninhamento de estados vem em nosso aux√≠lio.  Vamos imaginar que temos apenas dois estados de n√≠vel superior: WelcomeScreen e UserSelection.  Todas as nossas se√ß√µes (por exemplo, "Servi√ßos", "Minha conta" e "Ajuda") ser√£o "aninhadas" no estado UserSelection.  Voc√™ pode dizer que os estados ServicesScreen, ProfileScreen e HelpScreen ser√£o filhos da UserSelection.  E, como s√£o filhos, herdar√£o a rea√ß√£o a alguns sinais do estado parental.  Portanto, podemos definir a resposta ao bot√£o Cancelar no UserSelection.  Mas n√£o precisamos determinar essa rea√ß√£o em todos os subestados subsidi√°rios.  O que torna nossa espa√ßonave mais concisa e compreens√≠vel: <br><br><img src="https://habrastorage.org/webt/lx/nb/qn/lxnbqn3kqv9rst-fbebmx1kxhi8.png"><br><br>  Aqui voc√™ pode observar que a rea√ß√£o para "Cancelar" e "Voltar" foi definida em UserSelection.  E essa rea√ß√£o ao bot√£o Cancelar funciona para todos, sem exce√ß√£o, sub-estados UserSelection (incluindo ainda outro sub-estado ServicesSelection composto).  Mas no subestado ServicesSelection, a rea√ß√£o ao bot√£o Voltar j√° √© diferente - o retorno n√£o est√° no WelcomScreen, mas no ServicesScreen. <br><br>  As CAs que usam uma hierarquia / aninhamento de estados s√£o chamadas de m√°quinas de estados finitos hier√°rquicos (ICA). <br><br><h3>  Rea√ß√£o √† entrada / sa√≠da de / para o estado </h3><br>  Um recurso muito √∫til √© a capacidade de atribuir uma resposta √† entrada de um estado espec√≠fico, bem como uma rea√ß√£o √† sa√≠da de um estado.  Portanto, no exemplo acima com um infokiosk, um manipulador pode ser desligado para inserir cada um dos estados, o que alterar√° o conte√∫do da tela do infokiosk. <br><br>  O exemplo anterior pode ser expandido um pouco.  Suponha que tenhamos dois subestados no WelcomScreen: BrightWelcomScreen, no qual a tela ser√° destacada normalmente, e DarkWelcomScreen, no qual o brilho da tela ser√° reduzido.  Podemos criar um manipulador de entrada DarkWelcomScreen que escurecer√° a tela.  E um manipulador de sa√≠da DarkWelcomScreen que restaurar√° o brilho normal. <br><br><img src="https://habrastorage.org/webt/qm/n0/2y/qmn02yrt9xxxmmawcpzufiexrpg.png"><br><br><h3>  Mudan√ßa autom√°tica de estado ap√≥s um tempo definido </h3><br>  √Äs vezes, pode ser necess√°rio limitar a perman√™ncia da espa√ßonave em um estado espec√≠fico.  Portanto, no exemplo acima, podemos limitar o tempo que nossa ICA permanece no estado BrightWelcomScreen a um minuto.  Assim que o minuto expira, o ICA muda automaticamente para o estado DarkWelcomScreen. <br><br><h3>  Hist√≥ria da nave espacial </h3><br>  Outra caracter√≠stica muito √∫til da ACI √© a hist√≥ria do estado da espa√ßonave. <br><br>  Vamos imaginar que temos algum tipo de ACI abstrata desse tipo: <br><br><img src="https://habrastorage.org/webt/6i/6n/bl/6i6nblfh7l89fzaulpzsa3mo4a4.png"><br><br>  Essa ACI pode ir de TopLevelState1 para TopLevelState2 e vice-versa.  Mas, dentro do TopLevelState1, existem v√°rios estados aninhados.  Se o ICA simplesmente passar de TopLevelState2 para TopLevelState1, dois estados ser√£o ativados imediatamente: TopLevelState1 e NestedState1.  NestedState1 √© ativado porque √© o subestado inicial do estado TopLevelState1. <br><br>  Agora imagine que nossa ICA alterou seu estado de NestedState1 para NestedState2.  Dentro do NestedState2, o SubState InternalState1 foi ativado (j√° que √© o subestado inicial do NestedState2).  E do InternalState1, fomos para o InternalState2.  Portanto, temos simultaneamente os seguintes estados ativos: TopLevelState1, NestedState2 e InternalState2.  E aqui vamos para TopLevelState2 (ou seja, geralmente deixamos TopLevelState1). <br><br>  Ativo se torna TopLevelState2.  Depois disso, queremos retornar ao TopLevelState1.  Est√° em TopLevelState1 e n√£o em nenhum subestado espec√≠fico em TopLevelState1. <br><br>  Ent√£o, a partir do TopLevelState2, vamos para o TopLevelState1 e de onde chegamos? <br><br>  Se TopLevelState1 n√£o tiver hist√≥rico, chegaremos a TopLevelState1 e NestedState1 (j√° que NestedState1 √© o subestado inicial de TopLevelState1).  I.e.  toda a hist√≥ria sobre as transi√ß√µes dentro do TopLevelState1, que ocorreu antes de deixar o TopLevelState2, foi completamente perdida. <br><br>  Se TopLevelState1 tiver o chamado  hist√≥rico superficial, ao retornar de TopLevelState2 para TopLevelState1, entramos em NestedState2 e InternalState1.  Entramos no NestedState2 porque ele √© registrado no hist√≥rico de status do TopLevelState1.  E chegamos ao InternalState1 porque √© o inicial do NestedState2.  Acontece que no hist√≥rico superficial do TopLevelState1, as informa√ß√µes s√£o armazenadas apenas sobre os subestados do primeiro n√≠vel.  A hist√≥ria dos estados incorporados nesses subestados n√£o √© preservada. <br><br>  Mas se TopLevelState1 tiver um hist√≥rico profundo, quando retornarmos de TopLevelState2 para TopLevelState1, entraremos em NestedState2 e InternalState2.  Como em um hist√≥rico profundo, informa√ß√µes completas sobre subestados ativos s√£o armazenadas, independentemente de sua profundidade. <br><br><h3>  Estados ortogonais </h3><br>  At√© agora, examinamos a ACI em que apenas um dos subestados poderia estar ativo dentro do estado.  Mas, √†s vezes, pode haver situa√ß√µes em que, em um estado espec√≠fico da ACI, haja v√°rios subestados ativos simultaneamente.  Tais subestados s√£o chamados estados ortogonais. <br><br>  Um exemplo cl√°ssico que demonstra estados ortogonais √© o familiar teclado do computador e seus modos NumLock, CapsLock e ScrollLock.  Podemos dizer que o trabalho com NumLock / CapsLock / ScrollLock √© descrito por subestados ortogonais dentro do estado Ativo: <br><br><img src="https://habrastorage.org/webt/hv/kf/8p/hvkf8p_gqijakghmndndhlileag.png"><br><br><h3>  Tudo o que voc√™ queria saber sobre m√°quinas de estados finitos, mas ... </h3><br>  Em geral, h√° um artigo fundamental sobre nota√ß√£o formal para diagramas de estado de David Harel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Statecharts: A Visual Formalism For Complex Systems (1987)</a> . <br><br>  L√°, v√°rias situa√ß√µes que podem ser encontradas ao trabalhar com m√°quinas de estados finitos s√£o examinadas usando o exemplo de controle de um rel√≥gio eletr√¥nico comum.  Se algu√©m n√£o leu, eu recomendo.  Basicamente, tudo o que Harel descreveu passou para a nota√ß√£o UML.  Mas quando voc√™ l√™ a descri√ß√£o dos diagramas de estado na UML, nem sempre entende o que, por que e quando precisa.  Mas no artigo de Harel, a apresenta√ß√£o vai de situa√ß√µes simples a situa√ß√µes mais complexas.  E voc√™ est√° mais consciente de todo o poder que as m√°quinas de estados finitos escondem em si mesmas. <br><br><h1>  M√°quinas de estado finito no SObjectizer </h1><br>  Al√©m disso, falaremos sobre o SObjectizer e suas especificidades.  Se voc√™ n√£o entender os exemplos abaixo, talvez fa√ßa sentido aprender mais sobre o SObjectizer.  Por exemplo, em nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo de revis√£o sobre o SObjecizer</a> e em v√°rios artigos subsequentes que apresentam leitores ao SObjectizer, passando de simples para complexos ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro</a> artigo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segundo</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">terceiro</a> ). <br><br><h2>  Os agentes no SObjectizer s√£o m√°quinas de estado </h2><br>  Os agentes no SObjectizer desde o in√≠cio eram m√°quinas de estados com estados expl√≠citos.  Mesmo que o desenvolvedor do agente n√£o tenha descrito nenhum de seus pr√≥prios estados em sua classe de agente, ele ainda possui um estado padr√£o, que √© usado por padr√£o.  Por exemplo, se um desenvolvedor fez um agente t√£o trivial: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;how_are_you&gt;([]{ std::cout &lt;&lt; "I'm fine!" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); } };</span></span></code> </pre> <br>  ent√£o ele pode nem suspeitar que, na realidade, todas as assinaturas que ele fez s√£o feitas para o estado padr√£o.  Mas se o desenvolvedor adicionar seus pr√≥prios estados ao agente, voc√™ j√° precisar√° pensar em assinar corretamente o agente no estado correto.  Aqui, digamos, uma modifica√ß√£o incorreta simples (e, como sempre) do agente mostrada acima: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,  ,   . state_t st_free{this}; // ,  ,   . state_t st_busy{this}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { so_subscribe_self() .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  Definimos dois manipuladores diferentes para o sinal how_are_you, cada um para seu pr√≥prio estado. <br><br>  E o erro nessa modifica√ß√£o do agente simple_demo √© que, estando em st_free ou st_busy, o agente n√£o responder√° ao sair, porque  deixamos a assinatura encerrada no estado padr√£o, mas n√£o fizemos as assinaturas correspondentes para st_free e st_busy.  Uma maneira simples e √≥bvia de corrigir esse problema √© adicionar as assinaturas apropriadas ao st_free e st_busy: <br><pre> <code class="cpp hljs"> simple_demo(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { <span class="hljs-comment"><span class="hljs-comment">//   how_are_you   ,    . st_free .event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); st_busy .event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }) .event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //     st_free. this &gt;&gt;= st_free; }</span></span></code> </pre> <br>  √â verdade que esse m√©todo parece copiar e colar, o que n√£o √© bom.  Voc√™ pode se livrar da copiar e colar inserindo um estado pai comum para st_free e st_busy: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">simple_demo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      . state_t st_basic{this}; // ,  ,   . //      st_basic. state_t st_free{initial_substate_of{st_basic}}; // ,  ,   . //     st_basic. state_t st_busy{substate_of{st_basic}}; public: //   ,       . struct how_are_you final : public so_5::signal_t {}; //   ,     . struct quit final : public so_5::signal_t {}; // ..   ,      . simple_demo(context_t ctx) : so_5::agent_t{std::move(ctx)} { //   quit   st_basic    //  ""  . st_basic.event&lt;quit&gt;([this]{ so_deregister_agent_coop_normally(); }); //   how_are_you   ,    . st_free.event([]{ std::cout &lt;&lt; "I'm free" &lt;&lt; std::endl; }); st_busy.event([]{ std::cout &lt;&lt; "I'm busy" &lt;&lt; std::endl; }); //     st_free. this &gt;&gt;= st_free; } };</span></span></code> </pre> <br>  Por uma quest√£o de justi√ßa, deve-se acrescentar que inicialmente os agentes SObjectizer podiam ser apenas m√°quinas de estado simples.  O suporte para naves espaciais hier√°rquicas apareceu relativamente recentemente, em janeiro de 2016. <br><br><h2>  Por que os agentes SObjectizer s√£o m√°quinas de estado finito? </h2><br>  Essa pergunta tem uma resposta muito simples: <s>aconteceu que as</s> ra√≠zes do SObjectizer crescem a partir do mundo dos sistemas de controle de processos, e as m√°quinas de estados finitos s√£o usadas com muita frequ√™ncia.  Portanto, consideramos necess√°rio que os agentes no SObjectizer tamb√©m sejam m√°quinas de estado.  Isso √© muito conveniente se no aplicativo para o qual SObjectizer eles est√£o tentando aplicar, a CA √© usada.  E o estado padr√£o, que todos os agentes t√™m, nos permite n√£o pensar em naves espaciais se o uso da espa√ßonave n√£o for necess√°rio. <br><br>  Em princ√≠pio, se voc√™ olhar o pr√≥prio modelo de atores e os princ√≠pios nos quais esse modelo √© constru√≠do: <br><br><ul><li>  um ator √© uma entidade com comportamento; </li><li>  atores respondem a mensagens recebidas; </li><li>  Ap√≥s receber a mensagem, o ator pode: <br><ul><li>  envie um certo n√∫mero de mensagens para outros atores; </li><li>  criar uma s√©rie de novos atores; </li><li>  Defina um novo comportamento para o processamento de mensagens subseq√ºentes. </li></ul></li></ul><br>  Pode-se encontrar uma forte semelhan√ßa entre espa√ßonaves simples e atores.  Voc√™ poderia at√© dizer que os atores s√£o simples m√°quinas de estados finitos. <br><br><h2>  Quais recursos de m√°quinas de estado avan√ßadas o SObjectizer suporta? </h2><br>  Dos recursos acima das m√°quinas avan√ßadas de estados finitos, o SObjectizer suporta tudo, exceto estados ortogonais.  Outros itens, como estados aninhados, manipuladores de entrada / sa√≠da, restri√ß√µes sobre o tempo gasto no estado, hist√≥rico para os estados, s√£o suportados. <br><br>  Com o apoio de estados ortogonais, a primeira vez n√£o cresceu junto.  Por um lado, a arquitetura interna do SObjectizer n√£o pretendia oferecer suporte a v√°rios estados independentes e simultaneamente ativos do agente.  Por outro lado, h√° quest√µes ideol√≥gicas sobre como um agente que possui estados ortogonais deve se comportar.  O emaranhado dessas perguntas acabou sendo muito complicado, e a exaust√£o √∫til era pequena demais para resolver esse problema.  Sim, e em nossa pr√°tica, ainda n√£o houve situa√ß√µes em que estados ortogonais seriam necess√°rios, mas seria imposs√≠vel, por exemplo, dividir o trabalho entre v√°rios agentes vinculados a um contexto de trabalho comum. <br><br>  No entanto, se algu√©m precisar de um recurso como estados ortogonais e voc√™ tiver exemplos do mundo real de tarefas onde isso √© necess√°rio, ent√£o vamos conversar.  Talvez, tendo exemplos concretos diante de nossos olhos, possamos adicionar esse recurso ao SObjectizer. <br><br><h2>  Como o suporte a recursos avan√ßados do ICA √© exibido no c√≥digo </h2><br>  Nesta parte da hist√≥ria, tentaremos revisar rapidamente a API do SObjectizer-5 para trabalhar com a ICA.  Sem se aprofundar nos detalhes, apenas para que o leitor tenha uma id√©ia do que √© e como fica.  Informa√ß√µes mais detalhadas, se voc√™ desejar, podem ser encontradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na documenta√ß√£o oficial</a> . <br><br><h3>  Estados aninhados </h3><br>  Para declarar um estado aninhado, voc√™ precisa passar a express√£o initial_substate_of ou substate_of para o construtor do objeto state_t correspondente: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_parent{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  . state_t st_first_child{initial_substate_of{st_parent}}; //   . //    . state_t st_second_child{substate_of{st_parent}}; //   . state_t st_third_child{substate_of{st_parent}}; //   . state_t st_first_grandchild{initial_substate_of{st_third_child}}; //    . state_t st_second_grandchild{substate_of{st_third_child]}; ... };</span></span></code> </pre> <br>  Se o estado S possui v√°rios subestados C1, C2, ..., Cn, um deles (e apenas um) deve ser marcado como inicial_substate_of.  A viola√ß√£o desta regra √© diagnosticada em tempo de execu√ß√£o. <br><br>  A profundidade m√°xima de aninhamento de estado no SObjectizer-5 √© limitada.  Nas vers√µes 5.5, esses s√£o 16 n√≠veis.  A viola√ß√£o desta regra √© diagnosticada em tempo de execu√ß√£o. <br><br>  O truque mais importante com estados aninhados √© que, quando um estado que possui estados aninhados √© ativado, v√°rios estados s√£o ativados ao mesmo tempo.  Suponha que exista um estado A que possua os subestados B e C e no subestado B existam os subestados D e E: <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  Quando o estado A √© ativado, na verdade, tr√™s estados s√£o ativados imediatamente: A, AB e ABD <br><br>  O fato de v√°rios estados poderem estar ativos ao mesmo tempo tem o efeito mais s√©rio em duas coisas de arquivo.  Primeiro, procure um manipulador para a pr√≥xima mensagem recebida.  Portanto, no exemplo mostrado, o manipulador de mensagens ser√° pesquisado primeiro no estado ABD. Se n√£o houver um manipulador adequado, a pesquisa continuar√° no estado pai, ou seja,  em AB E j√° machucou, se necess√°rio, a pesquisa continuar√° no estado A. <br><br>  Em segundo lugar, a presen√ßa de v√°rios estados ativos afeta a ordem de chamada de manipuladores de entrada / sa√≠da para estados.  Mas isso ser√° discutido abaixo. <br><br><h3>  Manipuladores de E / S do estado </h3><br>  Para um estado, os manipuladores de estado de entrada e sa√≠da de estado podem ser especificados.  Isso √© feito usando os m√©todos state_t :: on_enter e state_t :: on_exit.  Normalmente, esses m√©todos s√£o chamados no m√©todo so_define_agent () (ou diretamente no construtor do agente, se o agente for trivial e a heran√ßa dele n√£o for fornecida). <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_busy{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// :       , //     . st_free.on_enter([]{ ... }); st_busy.on_exit([]{ ...}); ... this &gt;&gt;= st_free; } ... };</span></span></code> </pre> <br>  Provavelmente, o momento mais dif√≠cil com os manipuladores on_enter / on_exit √© us√°-los para estados aninhados.  Vamos voltar ao exemplo com os estados A, B, C, D e E. <br><br><img src="https://habrastorage.org/webt/pf/1n/gb/pf1ngbtknzrf5qxlluht3yfiraq.png"><br><br>  Suponha que cada estado tenha um manipulador on_enter e on_exit. <br><br>  Deixe A. se tornar o estado atual do agente.  os estados A, AB e ABD s√£o ativados Durante a mudan√ßa de estado de um agente, A.on_enter, ABon_enter e ABDon_enter ser√£o chamados.  E nessa ordem. <br><br>  Suponha que exista uma transi√ß√£o para o ABE, ABDon_exit e ABEon_enter ser√£o chamados. <br><br>  Se ent√£o colocarmos o agente no estado AC, ABEon_exit, ABon_exit, ACon_enter ser√° chamado. <br><br>  Se o agente, estando no estado AC, for cancelado o registro, imediatamente ap√≥s a conclus√£o do m√©todo so_evt_finish (), os manipuladores ACon_exit e A.on_exit ser√£o chamados. <br><br><h3>  Prazos </h3><br>  O limite de tempo para o agente permanecer em um estado espec√≠fico √© definido usando o m√©todo state_t :: time_limit.  Assim como no on_enter / on_exit, os m√©todos time_limit geralmente s√£o chamados onde o agente est√° configurado para funcionar dentro do SObjectizer: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">led_indicator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> inactive{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> active{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        15s. //        inactive. active.time_limit(15s, inactive); ... } ... };</span></span></code> </pre> <br>  Se o limite de tempo para o estado estiver definido, assim que o agente entrar nesse estado, o SObjectizer come√ßar√° a contar o tempo gasto no estado.  Se o agente sair do estado e retornar a esse estado novamente, a contagem regressiva ser√° iniciada novamente. <br><br>  Se limites de tempo forem definidos para estados incorporados, voc√™ precisar√° ter cuidado, porque  truques curiosos s√£o poss√≠veis: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   . state_t A{this}, B{this}; //   first . state_t C{initial_substate_of{A}}, st_D{substate_of{A}}; ... void so_define_agent() override { A.time_limit(15s, B); C.time_limit(10s, D); D.time_limit(20s, C); ... } ... };</span></span></code> </pre> <br>  Suponha que um agente entre no estado A.  os estados A e C s√£o ativados para A e C.  Anteriormente, terminava no estado C e o agente passava para o estado D. Isso iniciar√° a contagem regressiva para permanecer no estado D. Mas a contagem regressiva continuar√° para permanecer no A!  Como durante a transi√ß√£o de C para D, o agente continuou no estado A. E cinco segundos ap√≥s a transi√ß√£o for√ßada de C para D, o agente passar√° para o estado B. <br><br><h3>  Hist√≥ria para fortuna </h3><br>  Por padr√£o, os estados do agente n√£o t√™m um hist√≥rico.  Para ativar o hist√≥rico de salvar um estado, passe a constante shallow_history (o estado ter√° um hist√≥rico raso) ou deep_history (o estado ter√° um hist√≥rico profundo) para o construtor state_t.  Por exemplo: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> A{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, shallow_history}; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> B{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, deep_history}; ... };</code> </pre> <br>  A hist√≥ria dos estados √© um t√≥pico dif√≠cil, especialmente quando √© usada uma profundidade decente de aninhamento de estados e os subestados t√™m sua pr√≥pria hist√≥ria.  Portanto, para obter informa√ß√µes mais completas sobre esse t√≥pico, √© melhor consultar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">a documenta√ß√£o</a> , experimentar.  Bem, para nos perguntar se voc√™ n√£o consegue descobrir;) <br><br><h3>  just_switch_to, transfer_to_state, suprimir </h3><br>  A classe state_t possui v√°rios dos m√©todos mais usados ‚Äã‚Äãj√° mostrados acima: event () para inscrever eventos em uma mensagem, on_enter () e on_exit () para definir manipuladores de entrada / sa√≠da, time_limit () para definir um limite para o tempo gasto em um estado. <br><br>  Junto com esses m√©todos, ao trabalhar com o ICA, os seguintes m√©todos da classe state_t s√£o muito √∫teis: <br><br>  O m√©todo just_switch_to (), desenvolvido para o caso em que a √∫nica rea√ß√£o a uma mensagem recebida √© transferir o agente para um novo estado.  Voc√™ pode escrever: <br><pre> <code class="cpp hljs">some_state.just_switch_to&lt;some_msg&gt;(another_state);</code> </pre> <br>  em vez de: <br><pre> <code class="cpp hljs">some_state.event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;some_msg&gt;) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= another_state; });</code> </pre> <br>  O m√©todo transfer_to_state () √© muito √∫til quando temos alguma mensagem M processada da mesma maneira em dois ou mais estados S1, S2, ..., Sn.  Mas, se estamos nos estados S2, ..., Sn, primeiro precisamos retornar a S1, e somente ent√£o o processamento M. <br><br>  Se isso parecer complicado, talvez em um exemplo de c√≥digo essa situa√ß√£o seja melhor compreendida: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); ... //      . Sn.event([this](mhood_t&lt;M&gt; cmd) { this &gt;&gt;= S1; actual_M_handler(cmd); }); } ... };</span></span></code> </pre> <br>  Mas, em vez de definir manipuladores de eventos muito semelhantes para S2, ..., Sn, use transfer_to_state: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> S1{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, S2{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}, ..., Sn{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actual_M_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; cmd)</span></span></span><span class="hljs-function"> </span></span>{...} ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ S1.event(&amp;demo::actual_M_handler); ... <span class="hljs-comment"><span class="hljs-comment">//           S1, //      M  . S2.transfer_to_state&lt;M&gt;(S1); ... //      . Sn.transfer_to_state&lt;M&gt;(Sn); } ... };</span></span></code> </pre> <br>  O m√©todo suppress () suprime uma pesquisa de manipulador de eventos para o subestado atual e todos os seus subestados pai.  Suponha que tenhamos um estado pai A no qual std :: abort () √© chamado na mensagem M.  E existe um estado filho de B no qual M pode ser ignorado com seguran√ßa.  Devemos determinar a rea√ß√£o a M no subestado B, porque, se n√£o o fizermos, o manipulador de B ser√° encontrado em A. Portanto, precisaremos escrever algo como: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) {}); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br>  O m√©todo suppress () permite que voc√™ escreva essa situa√ß√£o no c√≥digo de maneira mais expl√≠cita e gr√°fica: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ A.event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;M&gt;) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abort</span></span>(); }); ... B.suppress&lt;M&gt;(); <span class="hljs-comment"><span class="hljs-comment">//    ,      //   M   . ... }</span></span></code> </pre> <br><h2>  Exemplo muito simples </h2><br>  Os exemplos padr√£o do SObjectizer v.5.5 incluem um exemplo simples, <a href="">piscando_led</a> , que simula a opera√ß√£o de um indicador LED piscando.  O diagrama de estado do agente deste exemplo √© o seguinte: <br><br><img src="https://habrastorage.org/webt/9d/yt/ms/9dytmskalbsypsg9xjjzkwupl5k.png"><br><br>  E aqui est√° o c√≥digo completo do agente deste exemplo: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blinking_led</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> off{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }, blink_on{ initial_substate_of{ blinking } }, blink_off{ substate_of{ blinking } }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn_on_off</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; blinking_led( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ ctx } { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= off; off.just_switch_to&lt; turn_on_off &gt;( blinking ); blinking.just_switch_to&lt; turn_on_off &gt;( off ); blink_on .on_enter( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ON"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .on_exit( []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"off"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } ) .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">1250</span></span>}, blink_off ); blink_off .time_limit( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds{<span class="hljs-number"><span class="hljs-number">750</span></span>}, blink_on ); } };</code> </pre> <br>  Aqui, todo o trabalho real √© feito dentro dos manipuladores de E / S para o subestado blink_on.  Al√©m disso, limites para a dura√ß√£o da perman√™ncia no trabalho dos subestados blink_on e blink_off. <br><br><h2>  N√£o √© um exemplo muito simples </h2><br>  Os exemplos padr√£o do SObjectizer v.5.5 tamb√©m incluem um exemplo muito mais complexo, <a href="">intercom_statechart</a> , que imita o comportamento do painel do interfone.  E o diagrama de estado do agente principal neste exemplo √© mais ou menos assim: <br><br><img src="https://habrastorage.org/webt/o-/i6/7d/o-i67dswwms9rkutntnvd-hrx7e.jpeg"><br><br>  Tudo √© t√£o duro, porque essa imita√ß√£o suporta n√£o apenas ligar para um apartamento por n√∫mero, mas tamb√©m coisas como um c√≥digo secreto exclusivo para cada apartamento, bem como um c√≥digo de servi√ßo especial.  Esses c√≥digos permitem abrir a fechadura da porta sem discar para qualquer lugar. <br><br>  Ainda h√° coisas interessantes neste exemplo.  Mas √© muito grande para ser descrito em detalhes (mesmo um artigo separado pode n√£o ser suficiente para isso).  Portanto, se voc√™ estiver interessado em saber como as ICAs realmente complexas s√£o exibidas no SObjectizer, voc√™ pode ver neste exemplo.  E se algo n√£o estiver claro, voc√™ pode nos fazer uma pergunta.  Por exemplo, nos coment√°rios deste artigo. <br><br><h1>  √â poss√≠vel n√£o usar o suporte para naves espaciais integradas no SObjectizer-5? </h1><br>  Portanto, o SObjectizer-5 possui suporte interno para ICA com uma ampla gama de recursos suportados.  Esse suporte √© feito, √© claro, para us√°-lo.  Em particular, os mecanismos de depura√ß√£o do SObjectizer, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">rastreamento de entrega de mensagens</a> , est√£o cientes do estado do agente e exibem o estado atual em suas respectivas mensagens de depura√ß√£o. <br><br>  No entanto, se o desenvolvedor n√£o quiser, por algum motivo, usar as ferramentas internas do SObjectizer-5, ele poder√° n√£o fazer isso. <br><br>  Por exemplo, voc√™ pode se recusar a usar o SObjectizer state_t e outros similares porque state_t √© um objeto bastante pesado com std :: string interno, algumas fun√ß√µes std ::, v√°rios contadores como std :: size_t, cinco ponteiros para v√°rios objetos e alguma outra ninharia.  Juntos, isso no Linux de 64 bits e no GCC-5.5, por exemplo, fornece 160 bytes por state_t (al√©m do que pode ser alocado na mem√≥ria din√¢mica). <br><br>  Se voc√™ precisar, digamos, de um milh√£o de agentes no aplicativo, cada um com 10 estados, a sobrecarga do SObjectizer state_t pode n√£o ser aceit√°vel.  Nesse caso, voc√™ pode usar outro mecanismo para trabalhar com m√°quinas de estado, delegando manualmente o processamento de mensagens para esse mecanismo.  Algo como: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">external_fsm_demo</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { some_fsm_type my_fsm_; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ so_subscribe_self() .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_one&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_two&gt; cmd) { my_fsm_.handle(*cmd); }) .event([<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_three&gt; cmd) { my_fsm_.handle(*cmd); }); ... } ... };</code> </pre> <br>  Nesse caso, voc√™ est√° pagando pela efici√™ncia aumentando a quantidade de trabalho manual e a falta de ajuda dos mecanismos de depura√ß√£o do SObjectizer.  Mas aqui cabe ao desenvolvedor decidir. <br><br><h1>  Conclus√£o </h1><br>  O artigo acabou sendo volumoso, muito mais do que o planejado originalmente.  Obrigado a todos que leram para este lugar.  Se um dos leitores considerar poss√≠vel deixar seu feedback nos coment√°rios do artigo, ser√° √≥timo. <br><br>  Se algo permanecer incerto, fa√ßa perguntas, responderemos com prazer. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, aproveitando esta oportunidade, quero chamar a aten√ß√£o daqueles que est√£o interessados ‚Äã‚Äãno SObjectizer, que o trabalho come√ßou na pr√≥xima vers√£o do SObjectizer no quadro da ramifica√ß√£o 5.5. </font><font style="vertical-align: inherit;">Brevemente sobre o que √© considerado para implementa√ß√£o em 5.5.23, descrito </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mais detalhadamente, mas em ingl√™s, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Voc√™ pode deixar sua opini√£o sobre qualquer um dos recursos propostos para implementa√ß√£o ou oferecer outra coisa.</font></font> I.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existe uma oportunidade real de influenciar o desenvolvimento do SObjectizer. </font><font style="vertical-align: inherit;">Al√©m disso, ap√≥s o lan√ßamento da v.5.5.23, pode haver uma pausa no trabalho no SObjectizer e a pr√≥xima oportunidade de incluir algo √∫til no SObjectizer 2018 pode n√£o estar l√°.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt423497/">https://habr.com/ru/post/pt423497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt423487/index.html">Node.js sem node_modules</a></li>
<li><a href="../pt423489/index.html">Sou m√©dico de emerg√™ncia e quero falar sobre o novo eletrocardiograma do Apple Watch</a></li>
<li><a href="../pt423491/index.html">PHP Digest No. 139 (3 a 17 de setembro de 2018)</a></li>
<li><a href="../pt423493/index.html">O Android Go √© o futuro bilh√£o de dispositivos e um limite de 50 MB. Palestra Yandex</a></li>
<li><a href="../pt423495/index.html">O que h√° no XGBoost e o que o Go tem a ver com isso?</a></li>
<li><a href="../pt423499/index.html">DevBoy - como eu criei um projeto de dispositivo de c√≥digo aberto e lancei um projeto no Kickstarter</a></li>
<li><a href="../pt423501/index.html">Pesquisa e cria√ß√£o de estilo visual para um projeto de design</a></li>
<li><a href="../pt423503/index.html">Minha experi√™ncia de me mudar, morar e estudar na Alemanha</a></li>
<li><a href="../pt423505/index.html">Zuckerberg vende a√ß√µes do Facebook por US $ 13 bilh√µes, para que ‚Äúnossos filhos nunca precisem ficar doentes‚Äù</a></li>
<li><a href="../pt423507/index.html">Como economizar mem√≥ria nas guias do navegador, mas n√£o perder o conte√∫do. A experi√™ncia da equipe Yandex.Browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>