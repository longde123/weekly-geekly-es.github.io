<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµüèæ üöï üßôüèº Tras la reuni√≥n "Nuevas funciones de PostgreSQL 11" üëàüèæ üçÇ ü§ôüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy hablaremos sobre las caracter√≠sticas m√°s importantes de PostgreSQL 11. ¬øPor qu√© solo sobre ellas? Porque no todos necesitan algunas caracter√≠stica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tras la reuni√≥n "Nuevas funciones de PostgreSQL 11"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/414031/">  Hoy hablaremos sobre las caracter√≠sticas m√°s importantes de PostgreSQL 11. ¬øPor qu√© solo sobre ellas? Porque no todos necesitan algunas caracter√≠sticas, por lo que nos decidimos por las m√°s populares. <br><br><h3>  Contenido </h3><br><img src="https://habrastorage.org/webt/3l/ef/wk/3lefwko0funvsqwyvgcaqtf7ory.png" align="right" width="300"><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Compilaci√≥n jit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Particionamiento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√çndices</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√çndices de cobertura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SP GiST</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rendimiento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WAL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Copia de seguridad y replicaci√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Para dba</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejecuci√≥n paralela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Optimizadores</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Funciones de ventana</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cambios de b√∫squeda de texto completo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Json (b) y texto completo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Procedimientos PL / *</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pgbench</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mejoras de PSQL</a> </li></ul><a name="habracut"></a><br><a name="1"></a><h3>  Compilaci√≥n jit </h3><br>  PostgreSQL finalmente ha introducido la compilaci√≥n JIT, es decir, compilar consultas en c√≥digo binario.  Para hacer esto, compile PostgreSQL con soporte para compilaci√≥n JIT <code>(Compile time 1 (--with-llvm))</code> .  Al mismo tiempo, la m√°quina debe tener una versi√≥n LLVM no inferior a 3.9. <br><br>  ¬øQu√© puede acelerar JIT? <br><br><ul><li>  Consultas con la cl√°usula WHERE, es decir, todo lo que viene despu√©s de esta palabra clave.  Esto no siempre es necesario, pero la oportunidad es √∫til. </li><li>  C√°lculo de la lista de destino: en la terminolog√≠a de PostgreSQL, esto es todo lo que se encuentra entre select y from. </li><li>  Agregados </li><li>  Convierta registros de una vista a otra (Proyecci√≥n).  Por ejemplo, cuando aplica unir a dos tablas, el resultado es una nueva tupla que contiene campos de ambas tablas. </li><li>  Deformaci√≥n de tuplas.  Uno de los problemas de cualquier base de datos, al menos en min√∫sculas, relacional, es c√≥mo obtener un campo de un registro en el disco.  Despu√©s de todo, puede ser nulo, tienen registros diferentes y, en general, esta no es la operaci√≥n m√°s barata. </li></ul><br>  <code>Compile time 2</code> significa que JIT no se usa.  En PostgreSQL hay un momento de planificaci√≥n de consultas, cuando el sistema decide qu√© vale JIT y qu√© no.  En este punto, se JIT y luego el ejecutor se ejecuta tal como est√°. <br><br>  JIT se hace conectable.  Por defecto, funciona con LLVM, pero puede conectar cualquier otro JIT. <br><br><img src="https://habrastorage.org/webt/hm/pk/lk/hmpklkbpxsi1qzqyvyx3drcl6_y.png" width="600"><br><br>  Si compil√≥ PostgreSQL sin compatibilidad con JIT, entonces la primera configuraci√≥n no funciona.  Opciones implementadas para desarrolladores, hay configuraciones para funciones JIT individuales. <br><br>  El siguiente punto sutil est√° relacionado con jit_above_cost.  JIT en s√≠ no es gratis.  Por lo tanto, PostgreSQL usa de manera predeterminada la optimizaci√≥n JIT si el costo de una consulta excede los 100 mil loros condicionales, en los que se miden explicar, analizar, etc.  Este valor se elige al azar, as√≠ que preste atenci√≥n. <br><br>  Pero no siempre despu√©s de encender JIT todo funciona de inmediato.  Por lo general, todos comienzan a experimentar con JIT usando select * from table donde id = 600 query y fallan.  Probablemente, es necesario complicar de alguna manera la solicitud, y luego todos generan una base de datos gigante y componen la solicitud.  Como resultado, PostgreSQL se basa en las capacidades del disco; carece de la capacidad de buffers y cach√©s compartidos. <br><br>  Aqu√≠ hay un ejemplo completamente abstracto.  Hay 9 campos nulos con diferentes frecuencias, para que pueda notar el efecto de la deformaci√≥n de la tupla. <br><br> <code>select i as x1, <br> case when i % 2 = 0 then i else null end as x2, <br> case when i % 3 = 0 then i else null end as x3, <br> case when i % 4 = 0 then i else null end as x4, <br> case when i % 5 = 0 then i else null end as x5, <br> case when i % 6 = 0 then i else null end as x6, <br> case when i % 7 = 0 then i else null end as x7, <br> case when i % 8 = 0 then i else null end as x8, <br> case when i % 9 = 0 then i else null end as x9 <br> into t <br> from generate_series(0, 10000000) i; <br> <br> vacuum t; <br> analyze t;</code> <br> <br>  PostgreSQL tiene muchas posibilidades, y para ver las ventajas de JIT, desactive las dos primeras l√≠neas para no interferir y restablezca los umbrales. <br><br> <code>set max_parallel_workers=0; <br> set max_parallel_workers_per_gather=0; <br> set jit_above_cost=0; <br> set jit_inline_above_cost=0; <br> set jit_optimize_above_cost=0;</code> <br> <br>  Aqu√≠ est√° la solicitud en s√≠: <br><br> <code>set jit=off; <br> explain analyze <br> select count(*) from t where <br> sqrt(pow(x9, 2) + pow(x8,2)) &lt; 10000; <br> <br> set jit=on; <br> explain analyze <br> select count(*) from t where <br> sqrt(pow(x9, 2) + pow(x8,2)) &lt; 10000;</code> <br> <br>  Y aqu√≠ est√° el resultado: <br><br> <code>Planning Time: 0.71 ms <br> Execution Time: <b>1986.323</b> ms <br> <br> VS <br> <br> Planning Time: 0.060 ms <br> JIT: <br> Functions: 4 <br> Generation Time: 0.911 ms <br> Inlining: true <br> Inlining Time: 23.876 ms <br> Optimization: true <br> Optimization Time: 41.399 ms <br> Emission Time: 21.856 ms <br> Execution Time: <b>949.112</b> ms</code> <br> <br>  JIT ayud√≥ a acelerar la solicitud a la mitad.  El tiempo de planificaci√≥n es casi lo mismo, pero probablemente sea el resultado del almacenamiento en cach√© de PostgreSQL, as√≠ que ign√≥relo. <br><br>  Si se resume, la compilaci√≥n JIT tard√≥ unos 80 ms.  ¬øPor qu√© JIT no es gratis?  Antes de ejecutar la solicitud, debe compilarla, y esto tambi√©n lleva tiempo.  Y tres √≥rdenes de magnitud m√°s que la planificaci√≥n.  No es un placer costoso, pero vale la pena debido a la duraci√≥n de la ejecuci√≥n. <br><br>  De esta manera puede usar JIT, aunque no siempre es beneficioso. <br><br><a name="2"></a><h3>  Particionamiento </h3><br>  Si prest√≥ atenci√≥n a la partici√≥n en PostgreSQL, probablemente not√≥ que se hizo all√≠ para mostrar.  La situaci√≥n mejor√≥ ligeramente en la versi√≥n 10, cuando apareci√≥ una declaraci√≥n declarativa de particiones (secciones).  Por otro lado, todo permaneci√≥ igual por dentro y funcion√≥ aproximadamente igual que en versiones anteriores, es decir, malo. <br>  En muchos sentidos, este problema fue resuelto por el m√≥dulo pg_pathman, que permiti√≥ trabajar con secciones y cortarlas en el momento √≥ptimo. <br><br>  En la versi√≥n 11, la partici√≥n se mejora enormemente: <br><br><ul><li>  Primero, la tabla de partici√≥n puede tener una clave primaria, que debe incluir la clave de partici√≥n.  De hecho, esta es una clave semi-primaria o una clave primaria.  Desafortunadamente, no puede hacer una clave for√°nea en √©l.  Espero que esto se solucione en el futuro. </li><li>  Adem√°s, ahora es posible particionar no solo por rango, sino tambi√©n por lista y hash.  El hash es bastante primitivo, el resto de la expresi√≥n se toma por √©l. </li><li>  Al actualizar, la l√≠nea se mueve entre secciones.  Anteriormente, ten√≠a que escribir un activador, pero ahora se hace autom√°ticamente. </li></ul><br>  La gran pregunta es: ¬øcu√°ntas secciones puedo tener?  Honestamente, con una gran cantidad de secciones (miles y decenas de miles) la funci√≥n no funciona bien.  Pg_pathman lo hace mejor. <br><br>  Tambi√©n se hicieron secciones por defecto.  Una vez m√°s, en pg_pathman puede hacer la creaci√≥n autom√°tica de secciones, lo cual es m√°s conveniente.  Aqu√≠, todo lo que no pudo ser empujado a alg√∫n lado cae en la secci√≥n.  Si est√° en un sistema real para hacer esto de forma predeterminada, luego de un tiempo obtienes tal desorden, que luego atormentas para rastrillar. <br><br>  PostgreSQL 11 ahora puede optimizar la partici√≥n si dos tablas est√°n unidas por una clave de partici√≥n y los esquemas de partici√≥n coinciden.  Esto se controla mediante un par√°metro especial, que est√° desactivado de manera predeterminada. <br><br>  Puede calcular los agregados para cada secci√≥n por separado y luego sumarlos.  Finalmente, puede crear un √≠ndice en la tabla particionada principal, y luego se crear√°n √≠ndices locales en todas las tablas que est√°n conectadas. <br><br>  En la secci√≥n "Novedades", se menciona algo maravilloso: la capacidad de eliminar secciones al ejecutar una solicitud.  Veamos c√≥mo funciona.  El resultado es una tabla de este tipo: <br><br><img src="https://habrastorage.org/webt/pd/yq/og/pdyqogkeovn-af_egj5u8wlszne.png" width="500"><br><br>  Hacemos un tipo y una tabla de dos columnas con una clave primaria, con una gran columna de serie, inserte los datos.  Creamos la segunda tabla, que ser√° particionada y ser√° una copia de la primera.  Agregue la clave primaria a la tabla particionada. <br><br><img src="https://habrastorage.org/webt/in/5h/gr/in5hgrummalku8i2gfizbjbt3hm.png" width="500"><br><br>  La tabla constar√° de dos tipos de entradas: "ni√±eras" y "conductores masculinos".  Y habr√° una mujer conductora.  Hacemos dos secciones, dividimos por lista, agregamos la clave primaria e insertamos todos los datos de la tabla en la que se genera todo esto.  El resultado fue completamente poco interesante: <br><br><img src="https://habrastorage.org/webt/r5/st/ax/r5staxao_opewadzu9wavch_w6w.png"><br><br>  Presta atenci√≥n a la solicitud.  Seleccionamos todo de una tabla no particionada, nos conectamos a una tabla particionada.  Tomamos una pieza peque√±a y elegimos solo un tipo, pasan por uno.  Indicamos que la columna oss debe tener un valor.  Resulta una selecci√≥n de controladores s√≥lidos. <br><br>  En la ejecuci√≥n, deshabilitamos espec√≠ficamente la paralelizaci√≥n, porque PostgreSQL 11 por defecto paraleliza muy activamente las consultas m√°s o menos complejas.  Si miramos el plan de ejecuci√≥n (explique, analice), entonces se puede ver que el sistema agreg√≥ los datos en ambas secciones: en la ni√±era y en los controladores, aunque las ni√±eras no estaban all√≠.  No hubo llamadas al b√∫fer.  Tiempo empleado, condici√≥n utilizada, aunque PostgreSQL podr√≠a resolverlo todo.  Es decir, la declaraci√≥n de eliminaci√≥n de partici√≥n no funciona de inmediato.  Quiz√°s en las pr√≥ximas versiones esto se corrija.  En este caso, el m√≥dulo pg_pathman en este caso funciona sin problemas. <br><br><a name="3"></a><h3>  √çndices </h3><br><ul><li>  Optimizaci√≥n de ofertas de forma mon√≥tona, es decir, b-tree.  Todo el mundo sabe que cuando inserta datos de crecimiento mon√≥tono, resulta que no es muy r√°pido.  Ahora PostgreSQL puede almacenar en cach√© la p√°gina final de una manera especial y no ir desde la ra√≠z para insertar.  Esto acelera significativamente el trabajo. </li><li>  PostgreSQL 10 hizo posible usar un √≠ndice hash porque comenz√≥ a usar WAL (registro de escritura anticipada).  Anteriormente, obtuvimos el valor, desbloqueamos la p√°gina, devolvimos el valor.  Para el siguiente valor, ten√≠a que bloquear la p√°gina nuevamente, regresar, desbloquear, etc.  Ahora el hash se ha vuelto mucho m√°s r√°pido.  Le permite bloquear una p√°gina a la vez para recuperar un registro de un √≠ndice hash, devolver todos los valores desde all√≠ y desbloquearlo.  Ahora est√° implementado para HASH, GiST y GIN.  En el futuro, esto probablemente se implementar√° para SP-GiST.  Pero para BRIN con su l√≥gica min / max esto no se puede hacer en principio. </li><li>  Si sol√≠a crear √≠ndices funcionales, la actualizaci√≥n HOT (Heup Only Tuple) se deshabilit√≥ efectivamente.  Cuando se actualiza un registro en PostgreSQL, se crea una nueva copia, y esto requiere pegar en todos los √≠ndices que est√°n en la tabla para que el nuevo valor apunte a la nueva tupla.  Dicha optimizaci√≥n se ha implementado durante mucho tiempo: si la actualizaci√≥n no cambia los campos que no est√°n incluidos en los √≠ndices y hay espacio libre en la misma p√°gina, los √≠ndices no se actualizan y, en la versi√≥n anterior de tupla, se coloca un puntero a la nueva versi√≥n.  Esto le permite reducir un poco la gravedad del problema con las actualizaciones.  Sin embargo, dicha optimizaci√≥n no funcionar√≠a en absoluto si tuviera √≠ndices funcionales.  En PostgreSQL 11, comenz√≥ a funcionar.  Si cre√≥ un √≠ndice funcional y actualiza una tupla que no cambia de qu√© depende el √≠ndice funcional, la actualizaci√≥n HOT funcionar√°. </li></ul><br><a name="4"></a><h3>  √çndices de cobertura </h3><br>  Esta funcionalidad fue implementada por PostgresPro hace tres a√±os, y todo este tiempo PostgreSQL intent√≥ agregarla.  Los √≠ndices de cobertura significan que puede agregar columnas adicionales al √≠ndice √∫nico, directamente en la tupla de √≠ndice. <br><br>  Por qu√©  A todos les encanta el escaneo de solo √≠ndice por su trabajo r√°pido.  Para esto, se construyen √≠ndices de "cobertura" condicionalmente: <br><br><img src="https://habrastorage.org/webt/ep/s7/vf/eps7vfc5hddmnsu6occowc250kw.png" width="600"><br><br>  Pero al mismo tiempo, debe mantener la singularidad.  Por lo tanto, se est√°n construyendo dos √≠ndices, estrecho y ancho. <br>  La desventaja es que cuando aplica vac√≠o, inserta o actualiza a una tabla, debe actualizar ambos √≠ndices.  Por lo tanto, insertar en un √≠ndice es una operaci√≥n lenta.  Y el √≠ndice de cobertura permitir√° administrar solo un √≠ndice. <br><br>  Es cierto que tiene algunas limitaciones.  M√°s precisamente, los beneficios que pueden no entenderse de inmediato.  Las columnas cyd en el primer √≠ndice de creaci√≥n no tienen que ser tipos escalares para los que se define un √≠ndice b-tree.  Es decir, no necesariamente tienen una comparaci√≥n m√°s y menos.  Pueden ser puntos o pol√≠gonos.  Lo √∫nico es que la tupla debe ser inferior a 2,7 Kb, porque no hay tostado en el √≠ndice, pero puede encajar en lo que no se puede comparar. <br><br>  Sin embargo, dentro del √≠ndice con estas columnas cubiertas garantizadas, no se realizan c√°lculos al buscar.  Esto debe hacerse mediante un filtro que se encuentre por encima del √≠ndice.  Por un lado, ¬øpor qu√© no calcularlo dentro del √≠ndice? Por otro lado, esta es una llamada de funci√≥n adicional.  Pero no todo es tan aterrador como parece. <br><br>  Bueno, adem√°s, puede agregar estas columnas cubiertas a la clave primaria. <br><br><a name="5"></a><h3>  SP GiST </h3><br>  Pocas personas usan este √≠ndice porque es bastante espec√≠fico.  Sin embargo, se hizo posible almacenar en √©l no exactamente lo que se insert√≥.  Esto se refiere a p√©rdida - √≠ndice, compresi√≥n.  Toma los pol√≠gonos como ejemplo.  En cambio, se coloca un cuadro delimitador en el √≠ndice, es decir, el rect√°ngulo m√≠nimo que contiene el pol√≠gono deseado.  En este caso, representamos el rect√°ngulo como un punto en el espacio de cuatro dimensiones, y luego trabajamos con el quad3 cl√°sico, en el espacio de cuatro dimensiones. <br><br>  Tambi√©n para el SP-GiST introdujo la operaci√≥n "b√∫squeda de prefijos".  Devuelve verdadero si una l√≠nea es un prefijo de otra.  Lo presentaron no solo as√≠, sino en aras de tal solicitud con soporte para SP-GiST. <br><br> <code>SELECT * FROM table WHERE c ^@ ‚Äûabc‚Äú</code> <br> <br>  En b-tree hay un l√≠mite de 2.7 Kb por l√≠nea, pero SP-GiST no.  Es cierto que PostgreSQL tiene una limitaci√≥n: un solo valor no puede exceder 1 GB. <br><br><a name="6"></a><h3>  Rendimiento </h3><br><ul><li>  <b>El escaneo del √≠ndice de mapa de bits solo ha aparecido</b>  Funciona igual que el escaneo de √≠ndice cl√°sico solamente, excepto que no puede garantizar ning√∫n orden.  Por lo tanto, es aplicable solo para algunos agregados como count (*), porque el mapa de bits no puede transferir campos del √≠ndice al ejecutor.  Solo puede informar el hecho de un registro que satisfaga las condiciones. </li><li>  La siguiente innovaci√≥n es la <b>actualizaci√≥n del Free Space Map durante la aplicaci√≥n del vac√≠o</b> .  Desafortunadamente, ninguno de los desarrolladores de sistemas que trabajan con PostgreSQL cree que es necesario eliminar al final de la tabla; de lo contrario, aparecen agujeros, espacios no asignados.  Para rastrear esto, implementamos FSM, que nos permite no agrandar la tabla, sino insertar tuplas en huecos.  Anteriormente, esto se hac√≠a con vac√≠o, pero al final.  Y ahora el vac√≠o puede hacer esto en el proceso, y en sistemas con mucha carga ayuda a mantener el tama√±o de la mesa bajo control. </li><li>  <b>Posibilidad de omitir el escaneo de √≠ndice durante la ejecuci√≥n de vac√≠o</b> .  El hecho es que todos los √≠ndices PostgreSQL, seg√∫n la teor√≠a de la base de datos, se denominan secundarios.  Esto significa que los √≠ndices se almacenan lejos de la tabla; los punteros se los llevan.  La exploraci√≥n de solo √≠ndice le permite no hacer este salto en punteros, sino tomar directamente del √≠ndice.  Pero el vac√≠o, que elimina registros, no puede mirarlos en el √≠ndice y decidir si los elimina o no, simplemente porque no hay tales datos en el √≠ndice.  Por lo tanto, el vac√≠o siempre se realiza en dos pasadas.  Primero, revisa la tabla y descubre lo que necesita eliminar.  Luego va a los √≠ndices adjuntos a esta tabla, elimina los registros que hacen referencia a lo encontrado, vuelve a la tabla y elimina a lo que iba.  Y la etapa de ir a los √≠ndices no siempre es necesaria. <br><br>  Si desde el √∫ltimo vac√≠o no hubo eliminaci√≥n o actualizaci√≥n, entonces no tiene registros muertos, no necesita eliminarlos.  En este caso, no puede ir al √≠ndice.  Hay sutilezas adicionales, b-tree no elimina sus p√°ginas inmediatamente, sino en dos pasadas.  Por lo tanto, si elimin√≥ una gran cantidad de datos en la tabla, entonces debe hacer vac√≠o.  Pero si desea liberar espacio en los √≠ndices, aspire dos veces. <br><br>  Alguien se sorprender√°, ¬øcu√°l es esta tabla en la que no hubo eliminaci√≥n o actualizaci√≥n?  De hecho, muchos tratan con esto, simplemente no piensen.  Estas son solo tablas de agregar, donde, por ejemplo, se agregan registros.  En ellos, la eliminaci√≥n es extremadamente rara.  Y esto ahorra enormemente la duraci√≥n del vac√≠o / autovac√≠o, reduce la carga en el disco, el uso de cach√©s, etc. </li><li>  <b>Compromiso simult√°neo de transacciones competitivas</b> .  Esto no es una innovaci√≥n, sino una mejora.  Ahora PostgreSQL detecta que se comprometer√° ahora y retrasa la confirmaci√≥n de la transacci√≥n actual, esperando el resto de las confirmaciones.  Tenga en cuenta que esta caracter√≠stica tiene poco efecto si tiene un servidor peque√±o con 2‚Äì4 n√∫cleos. </li><li>  <b>postgres_fdw (Contenedores de datos extranjeros)</b> .  FDW es una forma de conectar una fuente de datos externa para que parezca un verdadero post-Congreso.  postgres_fdw le permite conectar una tabla de una instancia vecina a su instancia, y se ver√° casi como una real.  Ahora se ha eliminado una de las restricciones para actualizar y eliminar.  PostgreSQL a menudo puede adivinar que necesita enviar datos sin procesar.  La forma de ejecutar la solicitud de uni√≥n es bastante simple: la ejecutamos en nuestra m√°quina, extraemos la tabla de la instancia usando FDW, descubrimos la clave primaria de identificaci√≥n que necesitamos eliminar y luego aplicamos la actualizaci√≥n y / o eliminaci√≥n, es decir, los datos que vamos y venimos. .  Ahora es posible hacerlo.  Por supuesto, si las tablas est√°n en m√°quinas diferentes, esto no es tan f√°cil, pero FDW le permite hacer que la m√°quina remota realice operaciones, y solo esperamos. </li><li>  <b>toast_tuple_target</b> .  Hay situaciones en las que los datos van un poco m√°s all√° de los l√≠mites, despu√©s de los cuales es necesario brindar, pero al mismo tiempo brindar por tales valores no siempre es agradable.  Suponga que tiene un l√≠mite de 90 bytes, y necesita un ajuste de 100. Debe iniciar una tostada de 10 bytes, agregarlos por separado, luego, cuando seleccione este campo, deber√° ir al √≠ndice de tostadas, averiguar d√≥nde est√°n los datos necesarios, ir a la tabla de tostadas, coleccionar y dar. </li></ul><br>  Ahora, con la ayuda del ajuste fino, puede cambiar este comportamiento para toda la base de datos o una tabla separada para que las salidas tan peque√±as no requieran el uso de tostadas.  Pero debes entender lo que est√°s haciendo, sin esto, nada funcionar√°. <br><br><a name="7"></a><h3>  WAL </h3><br><ul><li>  WAL (registro de escritura anticipada) es un registro de escritura anticipada.  El tama√±o del segmento WAL ahora se establece en initdb.  Gracias a Dios, no cuando compilamos. </li><li>  La l√≥gica tambi√©n ha cambiado.  Anteriormente, el conjunto de segmentos WAL se guardaba desde el momento del pen√∫ltimo punto de control, y ahora desde el √∫ltimo.  Esto puede reducir significativamente la cantidad de datos almacenados.  Pero si tiene una base de datos de 1 TB y TPS = 1, es decir, una solicitud por segundo, entonces no ver√° la diferencia. </li></ul><br><a name="8"></a><h3>  Copia de seguridad y replicaci√≥n </h3><br><ul><li>  <b>Truncate apareci√≥ en la replicaci√≥n l√≥gica</b> .  Fue la √∫ltima de las operaciones DML que no se reflej√≥ en la replicaci√≥n l√≥gica.  Ahora reflejado. </li><li>  <b>Un mensaje sobre prepare apareci√≥ en la replicaci√≥n l√≥gica</b> .  Ahora puede capturar la transacci√≥n de preparaci√≥n, una confirmaci√≥n de dos fases en la replicaci√≥n l√≥gica.  Esto se implementa para la construcci√≥n de grupos: heterog√©neos, homog√©neos, fragmentados y no sombreados, multimaster, etc. </li><li>  <b>Excepci√≥n de las tablas temporales y no registradas de pg_basebackup</b> .  Muchos se han quejado de que pg_basebackup incluye las tablas enumeradas.  Y excluy√©ndolos, reducimos el tama√±o de la copia de seguridad.  Pero siempre que use tablas temporales y no registradas, de lo contrario esta opci√≥n ser√° in√∫til para usted. </li><li>  <b>Control de suma de comprobaci√≥n en la replicaci√≥n de transmisi√≥n (para tablas)</b> .  Esto le permite comprender qu√© sucedi√≥ con su r√©plica.  Hasta ahora, la funci√≥n se implementa solo para tablas. </li><li>  <b>Hubo una promoci√≥n de las posiciones de la ranura de replicaci√≥n</b> .  Como siempre, solo puede avanzar, retroceder solo si hay un WAL.  Adem√°s, debe comprender muy bien lo que est√° haciendo con √©l y por qu√©.  En mi opini√≥n, esta es m√°s una opci√≥n de desarrollo, pero aquellos que usan la replicaci√≥n l√≥gica para algunas aplicaciones ex√≥ticas pueden disfrutarla. </li></ul><br><a name="9"></a><h3>  Para dba </h3><br><ul><li>  <b>Alterar tabla, agregar columna, no X nulo predeterminado</b> , escribir toda la tabla.  Hay una peque√±a tarifa por esto: el valor predeterminado se almacena por separado.  Si recoge la tupla y requiere esta columna, PostgreSQL se ve obligado a seguir una ruta de codificaci√≥n adicional para extraer un valor temporal, sustituirlo en la tupla y d√°rselo.  Sin embargo, uno puede vivir con eso. </li><li>  <b>Aspirar / analizar</b> .  Anteriormente, solo pod√≠a aplicar vac√≠o o analizar a una base de datos completa o una sola tabla.  Ahora es posible hacer esto en varias tablas, con un solo comando. </li></ul><br><a name="10"></a><h3>  Ejecuci√≥n paralela </h3><br><ul><li>  <b>Construcci√≥n paralela de √≠ndices b-tree</b> .  En la versi√≥n 11, se hizo posible incrustar √≠ndices b-tree en varios trabajadores.  Si tiene una m√°quina realmente buena, muchos discos y muchos n√∫cleos, puede construir √≠ndices en paralelo, esto promete un aumento notable en el rendimiento. </li><li>  <b>Hash conexi√≥n paralela utilizando una tabla hash compartida para ejecutores</b> .    ,           -.   ,     .   - ,     .     . </li><li>  , <b>      union, create table as, select  create materialized view!</b> </li><li> - <b>   (limit)   </b> .    . </li></ul><br>    : <br><br> <code>alter table usr reset (parallel_workers) <br> create index on usr(lower((so).occ)) ‚Äî 2  <br> alter table usr set (parallel_workers=2) <br> create index on usr(upper((so).occ)) ‚Äî 1.8 </code> <br> <br>     parallel worker.        .     16    4  (    )      2 .,    ‚Äî 1,8 .     ,   ,     .  ,         . <br><br>     : <br><br> <code>explain analyze <br> select u1.* from usr u, usr1 u1 where <br> u.id=u1.id+0</code> <br> <br>     ,      . , user ‚Äî   ,    .     .    ,      ,   . <br><br>     ,   PostgreSQL 11           . <br><br><img src="https://habrastorage.org/webt/a4/si/tw/a4sitw7cyqsulcovvmv--yueczs.png"><br><br>    1425 ,  1,5 .    1,4 .  2  .  ,   9.6   : 1      ‚Äî  1 .,   2   1 .    ,    10    tuple.    11    .       :      user,   batch,    x-scan      append   . <br><br>    : <br><br><img src="https://habrastorage.org/webt/7f/rx/2h/7frx2hwdbaxaq4asujz7aembelq.png"><br><br>   .         211 ,   702 .   ,    510     1473.    ,      2  . <br><br>     parallel hash join.       .     ‚Äî 4.     ,     . <br><br>   parallel index scan    .     batch  .  ¬øQu√© significa esto?        hash join,         .  user    .        ,  parallel hash,   . <br><br>     1 .  ,       OLAP-,  OLTP  .    OLTP  ,      . <br><br><a name="11"></a><h3>  </h3><br>      . <br><br><ul><li>       .   ,            .      ,    ¬´¬ª   ¬´¬ª,     index scan,     .    (highly skewed data),         ,    .      .    ,    ,    . </li><li>       ¬´¬ª,   . </li></ul><br><a name="12"></a><h3> Window- </h3><br>     SQL:2011,      . <br><br><a name="13"></a><h3>     </h3><br>   ,      ,    . ,   ,    ,  ,    ,    . <br><br>   websearch,     .      ,     .        ,   . <br><br> <code># select websearch_to_tsquery('dog or cat'); <br> ---------------------- <br> 'dor' | 'cat' <br> # select websearch_to_tsquery('dog -cat'); <br> ---------------------- <br> 'dor' &amp; !'cat' <br> # select websearch_to_tsquery('or cat'); <br> ---------------------- <br> 'cat'</code> <br> <br>   ‚Äî dog or cat ‚Äî   . Websearch      .     |  ,       .    ‚Äúor cat‚Äù.   ,   .    websearch  ‚Äúor‚Äù  .  ,    -,    . <br><br> Websearch ‚Äî     .       :        ,   .     ,   . <br><br><a name="14"></a><h3> Json(b)   </h3><br>  10-     ,   11-     .    json  json(b),   tsvector.   ( json(b))  -  .      ,    ,   ,  bull, numeric, string, .     . <br><br> <code># select jsonb_to_tsvector <br> ('{"a":"texts", "b":12}', '"string"'); <br> ------------------- <br> 'text':1 <br> # select jsonb_to_tsvector <br> ('{"a":"texts", "b":12}', '["string", "numeric"]'); <br> ------------------- <br> '12':3 'text':1</code> <br> <br>     json(b),        .      ,   ,   ,   . <br><br><a name="15"></a><h3> PL/*  </h3><br>     . <br><br> <code>CREATE PROCEDURE transaction_test1() <br> LANGUAGE plpgsql <br> AS $$ <br> BEGIN <br> FOR i IN 0..9 LOOP <br> INSERT INTO test1 (a) VALUES (i); <br> IF i % 2 = 0 THEN <br> COMMIT; <br> ELSE <br> ROLLBACK; <br> END IF; <br> END LOOP; <br> END <br> $$; <br> CALL transaction_test1();</code> <br> <br>      call,       ,         .        .     .      select, insert   . <br><br>    ,    ,   PostgreSQL    .    Perl, Python, TL  PL/pgSQL.    Perl    sp begin,         . <br><br> PL/pgSQL    :    ,    . <br><br><a name="16"></a><h3> pgbench </h3><br>     pgbench  ICSB bench ‚Äî ,   ,       .    if,     ,     .  case,       - .   <code>--init-steps</code> ,    ,   . <br><br>         random-seed.   zipfian- .    / ‚Äî   ,      .   -    ,      ,  - ,  . <br><br> ,  ,    - . <br><br><a name="17"></a><h3>  PSQL </h3><br>  ,    PSQL,        .    exit  quit. <br><br><ul><li>   ‚Äî    copy,      2 <sup>32</sup> .  copy      :      2 <sup>32</sup> - . ,     2 <sup>31</sup>  2 <sup>32</sup> copy     .    64-  ,      2 <sup>64</sup> . </li><li>  POSIX  :   NaN <sup>0</sup> = 1  1 <sup>NaN</sup> = 1. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414031/">https://habr.com/ru/post/es414031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414019/index.html">Soluci√≥n universal para UITableViewRowAction y UIContextualAction</a></li>
<li><a href="../es414023/index.html">Preg√∫ntele a Ethan: ¬øQu√© tan r√°pido podr√≠a haber aparecido la vida en el universo?</a></li>
<li><a href="../es414025/index.html">Los empleadores rastrean computadoras, viajes al ba√±o y ahora tambi√©n emociones; ¬øTu jefe te sigue?</a></li>
<li><a href="../es414027/index.html">¬øPueden mis amigos ser considerados verdaderos amigos?</a></li>
<li><a href="../es414029/index.html">Luz misteriosa alrededor de una estrella reci√©n formada, y lo que los astr√≥nomos piensan al respecto</a></li>
<li><a href="../es414041/index.html">En invierno y verano en un color? Buscar la estacionalidad en los datos</a></li>
<li><a href="../es414043/index.html">An√°lisis de tablas de enrutamiento, o por qu√© un ingeniero de red de Python</a></li>
<li><a href="../es414047/index.html">C√≥mo hacer una poderosa escalera Jacob con un transformador de microondas con tus propias manos</a></li>
<li><a href="../es414049/index.html">Los principales juegos de E3 2018: Fallout 76, Metro Exodus, Doom Eternal y otros</a></li>
<li><a href="../es414053/index.html">5 conceptos err√≥neos sobre GDPR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>