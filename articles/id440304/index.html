<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏿 🧦 🥨 Mengganggu dari perangkat eksternal dalam sistem x86. Bagian 3. Mengkonfigurasi perutean interupsi dalam chipset menggunakan contoh coreboot 👔 👩🏻‍💻 👨🏾‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami terus mempertimbangkan untuk mengonfigurasi interupsi dari perangkat eksternal di sistem x86. 
 Pada bagian 1 ( Evolusi pengendali interupsi ), k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengganggu dari perangkat eksternal dalam sistem x86. Bagian 3. Mengkonfigurasi perutean interupsi dalam chipset menggunakan contoh coreboot</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440304/"> Kami terus mempertimbangkan untuk mengonfigurasi interupsi dari perangkat eksternal di sistem x86. <br>  Pada bagian 1 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Evolusi pengendali interupsi</a> ), kami menguji dasar-dasar teoritis pengendali interupsi dan istilah umum, di bagian 2 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">opsi boot kernel Linux</a> ), kami melihat bagaimana dalam praktiknya OS membuat pilihan antara pengontrol.  Pada bagian ini, kita akan melihat bagaimana BIOS mengkonfigurasi routing IRQ untuk pengontrol interupsi dalam chipset. <br><br>  Tidak ada perusahaan pengembangan BIOS modern (AwardBIOS / AMIBIOS / Insyde) yang mengungkapkan kode sumber program mereka.  Tetapi untungnya ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Coreboot</a> , sebuah proyek untuk menggantikan BIOS yang dipatenkan dengan perangkat lunak bebas.  Dalam kodenya, kita akan melihat bagaimana interrupt routing di chipset dikonfigurasi. <br><br><img src="https://habrastorage.org/webt/mx/vi/wu/mxviwuisp5rglec_kgsk872hmy8.png"><br><br><a name="habracut"></a><br><h2>  Teori </h2><br>  Pertama, menyegarkan dan melengkapi pengetahuan teoritis kami.  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1,</a> kami mengidentifikasi jalur interupsi umum untuk kasus PIC dan APIC. <br><br>  <b>Foto:</b> <br><br><img src="https://habrastorage.org/webt/u_/jr/u9/u_jru9pemdeda2xvvbqihvgtp3y.png"><br><br>  <b>APIC:</b> <br><br><img src="https://habrastorage.org/webt/mc/ra/hj/mcrahjn-owk9qrcmyiixcmhomcq.png"><br><br>  Dalam angka-angka ini, perangkat PCI → pemetaan PIR ditampilkan secara abstrak, bahkan agak rumit.  Pada kenyataannya, setiap perangkat PCI memiliki 4 jalur interupsi (INTA #, INTB #, INTC #, INTD #).  Setiap perangkat PCI dapat memiliki hingga 8 fungsi dan setiap fungsi sudah memiliki satu interupsi INTx #.  Baris INTx # mana yang masing-masing fungsi perangkat akan tarik, apakah diperbaiki dalam perangkat keras atau ditentukan oleh konfigurasi perangkat. <br><br><img src="https://habrastorage.org/webt/dk/ny/gh/dknyghwfo8gktn5l_lmmqb5awz0.png"><br><br>  Intinya, fungsi adalah blok logis yang terpisah.  Misalnya, dalam satu perangkat PCI mungkin ada fungsi pengontrol Smbus, fungsi pengontrol SATA, fungsi jembatan LPC.  Di sisi OS, setiap fungsi adalah perangkat terpisah dengan ruang konfigurasi PCI Config-nya sendiri. <br><br>  Dalam kasus paling sederhana (dan paling umum) dalam perangkat PCI, hanya ada satu fungsi, yaitu interupsi dari yang melalui baris INTA #.  Tetapi secara umum, perangkat ini bahkan mungkin memiliki lebih dari 4 fungsi (seperti yang kami katakan sebelumnya 8), maka beberapa dari mereka harus ditanam pada satu baris INTx # (interupsi PCI dapat berbagi garis).  Juga, untuk perangkat PCI yang termasuk dalam chipset dengan menulis ke register khusus, seringkali dimungkinkan untuk menunjukkan fungsi mana yang menggunakan baris INTx # mana (dan apakah mereka digunakan sama sekali). <br><br>  Dengan mensistematisasikan pengetahuan kami, kami menunjukkan jalur (perutean) interupsi dari fungsi PCI apa pun melalui INTx # → PIRQy → IRQz, di mana: <br><br><ul><li>  INTx # - line INT # (INTA #, INTB #, INTC #, INTD #) dari perangkat PCI yang akan digunakan fungsi tersebut </li><li>  PIRQy - garis PIRQ (PIRQA, PIRQB, ...) dari PIR yang terhubung dengan garis INTx # </li><li>  IRQz - IRQ line (0, 1, 2, ...) pada interrupt controller (APIC / PIC), yang terhubung ke jalur PIRQy </li></ul><br><h3>  Mengapa Anda tidak bisa menghubungkan di mana saja INTA # → PIRQA, INTB # → PIRQB, ...? </h3><br>  Mengapa repot-repot mengatur perutean sama sekali?  Misalkan kita memutuskan untuk tidak repot dan mendapatkan semua jalur interupsi dari semua perangkat PCI ke jalur PIRQ yang sama.  Katakan ini: <br><br><ul><li>  INTA # → PIRQA </li><li>  INTB # → PIRQB </li><li>  INTC # → PIRQC </li><li>  INTD # → PIRQD </li></ul><br>  Seperti yang kami katakan di atas, kasus yang paling umum adalah ketika perangkat PCI memiliki satu fungsi, dan gangguannya terhubung ke baris INTA # (karena mengapa pengembang perangkat harus memulainya secara berbeda?).  Jadi jika kita tiba-tiba memutuskan untuk memulai semua baris seperti yang kita tulis, maka hampir semua interupsi dari perangkat akan dibagi menjadi baris PIRQA.  Katakanlah dia berakhir di IRQ16.  Kemudian setiap kali prosesor diberitahu bahwa interupsi telah terjadi pada jalur IRQ16, ia harus menginterogasi driver semua perangkat yang terhubung ke jalur IRQ16 (PIRQA) jika mereka memiliki interupsi untuk itu.  Jika ada banyak perangkat seperti itu, ini secara alami tidak akan mempercepat respons sistem terhadap gangguan.  Dan baris PIRQB-PIRQD dalam hal ini sebagian besar akan menganggur.  Untuk kejelasan, gambar yang menggambarkan masalah: <br><br><img src="https://habrastorage.org/webt/cz/dv/bf/czdvbfsnymw5xyyqujavawdcv_m.png"><br><br>  Tapi semuanya bisa dilakukan seperti ini: <br><br><img src="https://habrastorage.org/webt/dk/3e/x6/dk3ex67xjmm_9h0q3miq2djqnti.png"><br><br>  Gambarnya agak membingungkan, tetapi intinya adalah kita cukup menghubungkan garis INTx # dengan PIRQy ke round-robin (PIRQA, PIRQB, PIRQC, PIRQD, PIRQA, PIRQB, PIRQC, PIRQD, PIRQA, PIRQB, PIRQC, PIRQD,. ..) <br><br>  Perlu dicatat bahwa di sini perlu untuk memperhitungkan tidak hanya bahwa jumlah fungsi PCI yang sama dimuat pada setiap baris PIRQ.  Bagaimanapun, beberapa fungsi dapat membuat interupsi sangat jarang, dan beberapa secara permanen (misalnya Ethernet controller).  Dalam hal ini, bahkan alokasi jalur PIRQ terpisah untuk gangguan dengan fungsi seperti itu dapat dibenarkan. <br><br>  Berdasarkan hal tersebut di atas, pengembang BIOS, antara lain, memiliki tugas untuk memastikan bahwa jalur PIRQ dimuat secara seragam dengan interupsi. <br><br><h3>  Apa yang harus dilakukan BIOS? </h3><br>  Kami mensistematisasikan pada gambar: <br><br><img src="https://habrastorage.org/webt/pm/rq/xg/pmrqxgkdu0nkjz6yb44vdn79a8q.png"><br><br><ul><li>  <b>1) Tunjukkan baris INTx # yang masing-masing menarik fungsi perangkat PCI</b> <br>  Untuk perangkat PCI eksternal, item ini tidak dilakukan, tetapi untuk fungsi perangkat PCI yang termasuk dalam chipset, itu mungkin saja. </li><li>  <b>2) Konfigurasikan INTx # → pemetaan PIRQy untuk setiap perangkat PCI</b> <br>  Perlu dicatat bahwa mungkin ada lebih dari empat sinyal PIRQy standar (PIRQA, PIRQB, PIRQC, PIRQD).  Misalnya 8: PIRQA-PIRQH. </li></ul><br>  Sinyal PIRQy digunakan pada jalur IRQz dari pengontrol interupsi yang dipilih (APIC / PIC).  Karena kami ingin mendukung semua metode pemuatan yang mungkin (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 2</a> ), kami perlu mengisi kedua pemetaan: <br><br><ul><li>  <b>3a) Isi pemetaan PIRQy → IRQz1 untuk komunikasi PIR → I / O APIC</b> <br>  Tapi biasanya ini tidak perlu, karena jalur PIRQy ditetapkan pada jalur APIC.  Solusi umum adalah PIRQA → IRQ16, PIRQB → IRQ17, ... Solusi paling sederhana, karena  Dengan menempatkan garis PIRQy pada garis pengontrol ≥16, Anda tidak perlu khawatir tentang konflik dengan interupsi yang tidak terpisahkan dari perangkat ISA. </li><li>  <b>3b) Isi pemetaan PIRQy → IRQz2 untuk komunikasi PIR → PIC</b> <br>  Ini harus disediakan jika kita menggunakan perutean melalui pengontrol PIC.  Tidak ada solusi yang ambigu seperti dalam kasus APIC, karena dalam kasus PIC, orang harus menyadari kemungkinan konflik dengan interupsi yang tidak terpisahkan dari perangkat ISA. </li></ul><br>  Item keempat terakhir diperlukan untuk membantu OS dalam menentukan rute interupsi.  Perangkat itu sendiri biasanya tidak menggunakan register ini. <br><br><ul><li>  <b>4) Isi register Interrupt Line / Interrupt Pin untuk setiap fungsi PCI</b> <br>  Secara umum, register Interrupt Pin secara otomatis terisi dan biasanya Read-Only, jadi mengisi kemungkinan besar hanya akan memerlukan mengisi daftar Interrupt Line.  Ini harus disediakan jika kita menggunakan perutean melalui pengontrol PIC tanpa memberi OS tabel apa pun tentang perutean perutean (lihat lagi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 2</a> ).  Jika tabel disediakan dan pemetaan ini konsisten dengan tabel perutean ($ PIR / ACPI), maka OS sering meninggalkannya. </li></ul><br>  Perlu dicatat bahwa kita belum menyentuh tabel $ PIR / MPtable / ACPI dan mempertimbangkan cara mengkonfigurasi register chipset dalam hal perutean interupsi sebelum mentransfer kontrol ke loader sistem.  Tabel interupsi adalah topik untuk artikel terpisah (mungkin yang akan datang). <br><br>  Jadi, dasar-dasar teoretis dipelajari, akhirnya kita mulai berlatih! <br><br><h2>  Berlatih </h2><br>  Sebagai contoh untuk artikel dalam seri ini, saya menggunakan papan kustom dengan prosesor Intel Haswell i7 dan chipset LynxPoint-LP.  Di forum ini, saya meluncurkan coreboot bersama dengan SeaBIOS.  Coreboot menyediakan inisialisasi khusus perangkat keras, dan muatan SeaBIOS menyediakan antarmuka BIOS untuk sistem operasi.  Pada artikel ini, saya tidak akan menjelaskan proses mengkonfigurasi coreboot, tetapi coba tunjukkan dengan contoh pengaturan BIOS seperti apa yang harus dibuat dalam chipset untuk routing interupsi IRQ dari perangkat eksternal. <br><br>  Karena proyek coreboot sedang aktif dikembangkan sehingga artikel selalu up to date, kami akan mempertimbangkan kode menggunakan contoh versi tetap terbaru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.9</a> (rilis 2018-12-20). <br><br>  Motherboard terdekat dengan saya adalah Google Beltino dengan variasi Panther.  Folder utama untuk motherboard ini adalah folder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"src \ mainboard \ google \ beltino"</a> .  Semua pengaturan terkonsentrasi di sini dan kode khusus untuk board ini. <br><br>  Jadi, mari kita mulai memilah mana item-item di atas dikonfigurasi: <br><br><h4>  1) Tunjukkan baris INTx # yang masing-masing menarik fungsi perangkat PCI </h4><br>  Informasi ini didefinisikan dalam file <a href="">“src / mainboard / google / beltino / romstage.c”</a> di struktur rcba_config melalui register DxxIP (Device xx Interrupt Pin Register (IP)).  Register ini menunjukkan pin INTx # (A / B / C / D) mana yang masing-masing fungsi perangkat menghasilkan interupsi. <br><br>  Opsi yang memungkinkan (lihat file <a href="">"src / southbridge / intel / lynxpoint / pch.h"</a> ): <br><br><pre><code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>h = No interrupt <span class="hljs-number"><span class="hljs-number">1</span></span>h = INTA# <span class="hljs-number"><span class="hljs-number">2</span></span>h = INTB# <span class="hljs-number"><span class="hljs-number">3</span></span>h = INTC# <span class="hljs-number"><span class="hljs-number">4</span></span>h = INTD#</code> </pre> <br>  Diasumsikan bahwa beberapa fungsi menggunakan pin yang sama. <br><br>  Diasumsikan bahwa fungsi tidak boleh menggunakan pin untuk interupsi (Tanpa interupsi). <br>  Semuanya seperti yang kita lihat pada gambar di awal artikel. <br><br>  Kode lengkap bertanggung jawab atas barang yang ditunjuk oleh kami: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt pin register (board specific) */</span></span> RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)), RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)), RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTB &lt;&lt; D28IP_P4IP)), RCBA_SET_REG_32(D27IP, (INTA &lt;&lt; D27IP_ZIP)), RCBA_SET_REG_32(D26IP, (INTA &lt;&lt; D26IP_E2P)), RCBA_SET_REG_32(D22IP, (NOINT &lt;&lt; D22IP_MEI1IP)), RCBA_SET_REG_32(D20IP, (INTA &lt;&lt; D20IP_XHCI)),</code> </pre> <br>  Untuk pemahaman yang lebih baik, pertimbangkan beberapa contoh: <br><br>  <b>Contoh 1:</b> <br><br>  Perangkat 0x1d (29 dalam desimal) memiliki satu fungsi (pengontrol EHCI). <br><br>  Dalam hal ini, tetapkan interupsi ke INTA #. <br><br>  00: 1d.0 - INTA # <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IP, (INTA &lt;&lt; D29IP_E1P)),</code> </pre> <br>  <b>Contoh 2:</b> <br>  Perangkat 0x1f (31 dalam desimal) memiliki fungsi Pengontrol Sensor Termal (00: 1f.6), pengontrol SATA 2 (00: 1f.2), pengontrol SMBus (00: 1f.3), pengontrol SATA 1 (00: 1f .2).  Kami hanya ingin menggunakan pengontrol SMBus, pengontrol SATA 1 dan pengontrol Sensor Termal. <br><br>  00: 1f.2 - INTA # (pengontrol SATA 1) <br>  00: 1f.3 - INTB # (pengontrol SMBus) <br>  00: 1f.2 - Tidak ada interupsi (pengontrol SATA 2 tidak digunakan) <br>  00: 1f.6 - INTC # (Pengontrol Sensor Termal) <br><br>  Untuk konfigurasi ini, Anda harus menulis: <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D31IP, (INTC &lt;&lt; D31IP_TTIP) | (NOINT &lt;&lt; D31IP_SIP2) | (INTB &lt;&lt; D31IP_SMIP) | (INTA &lt;&lt; D31IP_SIP)),</code> </pre> <br>  <b>Contoh 3:</b> <br><br>  Dalam satu Perangkat, jumlah fungsi yang kami butuhkan lebih dari 4. Di perangkat 0x1c, setiap fungsi bertanggung jawab untuk port PCI Express.  Agar port 0-5 berfungsi, dan menyela agar didistribusikan secara merata, Anda dapat mengonfigurasi ini: <br><br>  00: 1c.0 - INTA # (PCI Express Port 0) <br>  00.1c.1 - INTB # (PCI Express Port 1) <br>  00.1c.2 - INTC # (PCI Express Port 2) <br>  00.1c.3 - INTD # (PCI Express Port 3) <br>  00.1c.4 - INTA # (PCI Express Port 4) <br>  00.1c.5 - INTB # (PCI Express Port 5) <br>  00.1c.6 - Tidak ada interupsi (port tidak digunakan) <br>  00.1c.7 - Tidak ada interupsi (port tidak digunakan) <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IP, (INTA &lt;&lt; D28IP_P1IP) | (INTB &lt;&lt; D28IP_P2IP) | (INTC &lt;&lt; D28IP_P3IP) | (INTD &lt;&lt; D28IP_P4IP) | (INTA &lt;&lt; D28IP_P5IP) | (INTB &lt;&lt; D28IP_P6IP) | (NOINT &lt;&lt; D28IP_P7IP) | (NOINT &lt;&lt; D28IP_P8IP)),</code> </pre> <br><h4>  2) Konfigurasikan INTx # → pemetaan PIRQy untuk setiap perangkat PCI </h4><br>  Informasi ini juga didefinisikan dalam file <a href="">"src \ mainboard \ google \ beltino \ romstage.c"</a> <br>  dalam struktur rcba_config, tetapi sudah melalui register DxxIR (Device xx Interrupt Route Register). <br><br>  Informasi dalam register ini menunjukkan baris PIRQx mana (A / B / C / D / E / F / G / H) setiap baris interupsi INTx # yang terhubung. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Device interrupt route registers */</span></span> RCBA_SET_REG_32(D31IR, DIR_ROUTE(PIRQG, PIRQC, PIRQB, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* LPC */</span></span> RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* EHCI */</span></span> RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD)),<span class="hljs-comment"><span class="hljs-comment">/* PCIE */</span></span> RCBA_SET_REG_32(D27IR, DIR_ROUTE(PIRQG, PIRQG, PIRQG, PIRQG)),<span class="hljs-comment"><span class="hljs-comment">/* HDA */</span></span> RCBA_SET_REG_32(D22IR, DIR_ROUTE(PIRQA, PIRQA, PIRQA, PIRQA)),<span class="hljs-comment"><span class="hljs-comment">/* ME */</span></span> RCBA_SET_REG_32(D21IR, DIR_ROUTE(PIRQE, PIRQF, PIRQF, PIRQF)),<span class="hljs-comment"><span class="hljs-comment">/* SIO */</span></span> RCBA_SET_REG_32(D20IR, DIR_ROUTE(PIRQC, PIRQC, PIRQC, PIRQC)),<span class="hljs-comment"><span class="hljs-comment">/* XHCI */</span></span> RCBA_SET_REG_32(D23IR, DIR_ROUTE(PIRQH, PIRQH, PIRQH, PIRQH)),<span class="hljs-comment"><span class="hljs-comment">/* SDIO */</span></span></code> </pre> <br>  <b>Contoh 1:</b> <br><br>  Perangkat 0x1c (28 dalam sistem desimal) adalah port PCIe seperti yang sudah kita ketahui. <br><br>  Kami membuat koneksi "langsung": <br><br><ul><li>  INTA # → PIRQA </li><li>  INTB # → PIRQB </li><li>  INTC # → PIRQC </li><li>  INTD # → PIRQD </li></ul><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D28IR, DIR_ROUTE(PIRQA, PIRQB, PIRQC, PIRQD))</code> </pre> <br>  <b>Contoh 2:</b> <br><br>  Perangkat 0x1d (29 dalam desimal) - satu fungsi (pengontrol EHCI) pada INTA #, baris lain tidak digunakan. <br><br>  Hubungkan baris INTA # ke PIRQD: <br><br><pre> <code class="cpp hljs">RCBA_SET_REG_32(D29IR, DIR_ROUTE(PIRQD, PIRQD, PIRQD, PIRQD))</code> </pre> <br>  Dalam hal ini, hanya catatan PIRQD pertama (untuk INTA #) yang masuk akal, sisanya tidak masuk akal. <br><br><h4>  3a) Isi pemetaan PIRQy → IRQz1 (PIR → APIC) </h4><br>  Seperti yang telah kami katakan, pemetaan sering diperbaiki di sini, dan kasus ini tidak terkecuali. <br><br><ul><li>  PIRQA → IRQ16 </li><li>  PIRQB → IRQ17 </li><li>  ... </li><li>  PIRQH → IRQ23 </li></ul><br><h4>  3b) Isi pemetaan PIRQy → IRQz2 (PIR → PIC) </h4><br>  Dalam coreboot, isi untuk mengisi register ini didefinisikan dalam file <a href="">devicetree.cb</a> di folder motherboard "src \ mainboard \ google \ beltino \". <br><br>  devicetree.cb (nama devicetree untuk komunikasi dengan konsep serupa di kernel Linux, dan "cb" adalah kependekan dari coreboot) adalah file khusus yang mencerminkan konfigurasi motherboard ini: prosesor, chipset yang digunakan, perangkat mana yang disertakan pada mereka, yang off dll  Selain itu, informasi khusus untuk konfigurasi chipset dapat ditentukan dalam file ini.  Ini hanya kasus yang kita butuhkan: <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x8b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span></code> </pre> <br>  Baris-baris ini menentukan pemetaan PIRQy → IRQz2.  Dalam kode, setelah mengurai file devicetree.cb, mereka ditransformasikan menjadi variabel "config-&gt; pirqX_routing". <br><br>  Variabel "config-&gt; pirqa_routing = 0x8b" akan berarti bahwa PIRQA terhubung ke jalur interupsi IRIC11 (0x0b = 11) dari pengontrol PIC, namun, bit yang lebih tinggi (yaitu 0x80) berarti bahwa interrupt routing tidak dilakukan.  Jujur, dalam pengalaman saya ini adalah kesalahan, secara default layak menyalakan PIC routing, sistem operasi itu sendiri akan dapat beralih ke I / O APIC dengan mengatur bit ini ke 1 jika perlu. <br><br>  Artinya, dalam hal ini akan lebih tepat untuk menulis: <br><br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x80"</span></span> <span class="hljs-comment"><span class="hljs-comment"># not used register "pirqf_routing" = "0x80" # not used register "pirqg_routing" = "0x80" # not used register "pirqh_routing" = "0x80" # not used</span></span></code> </pre><br>  Kami tidak mengaktifkan 4 interupsi terakhir, karena  Interupsi IRQ0 selalu digunakan di bawah pengatur waktu sistem dan jelas tidak tersedia (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Informasi Interupsi Kompatibel IBM-PC Umum</a> ). <br><br>  Tetapi jika kita melihat lebih dekat pada poin 2), kita akan melihat bahwa beberapa perangkat PCI menggunakan jalur PIRQE-PIRQH, jadi membiarkannya tidak terhubung adalah cara yang tepat untuk perangkat yang rusak. <br><br>  Jadi lebih baik menulis sesuatu seperti ini: <br><pre> <code class="python hljs">register <span class="hljs-string"><span class="hljs-string">"pirqa_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x03"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqb_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x04"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqc_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x05"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqd_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x06"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqe_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0a"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqf_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0b"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqg_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0e"</span></span> register <span class="hljs-string"><span class="hljs-string">"pirqh_routing"</span></span> = <span class="hljs-string"><span class="hljs-string">"0x0f"</span></span></code> </pre> <br><br>  Pengisian aktual dari register yang sesuai terjadi di file <a href="">src \ southbridge \ intel \ lynxpoint \ lpc.c</a> pada fungsi pch_pirq_init. <br><br>  Cuplikan kode yang bertanggung jawab untuk mengisi register: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Get the chip configuration */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">config_t</span></span> *config = dev-&gt;chip_info; pci_write_config8(dev, PIRQA_ROUT, config-&gt;pirqa_routing); pci_write_config8(dev, PIRQB_ROUT, config-&gt;pirqb_routing); pci_write_config8(dev, PIRQC_ROUT, config-&gt;pirqc_routing); pci_write_config8(dev, PIRQD_ROUT, config-&gt;pirqd_routing); pci_write_config8(dev, PIRQE_ROUT, config-&gt;pirqe_routing); pci_write_config8(dev, PIRQF_ROUT, config-&gt;pirqf_routing); pci_write_config8(dev, PIRQG_ROUT, config-&gt;pirqg_routing); pci_write_config8(dev, PIRQH_ROUT, config-&gt;pirqh_routing);</code> </pre> <br>  Konstanta alamat register dijelaskan dalam file <a href="">pch.h yang</a> sama <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQA_ROUT 0x60 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQB_ROUT 0x61 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQC_ROUT 0x62 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQD_ROUT 0x63 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQE_ROUT 0x68 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQF_ROUT 0x69 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQG_ROUT 0x6A #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PIRQH_ROUT 0x6B</span></span></code> </pre> <br>  Memetakan PIRQy → IRQz2 untuk chipset ini ditulis ke perangkat LPC PCI (alamat 00: 1f.0) di register PIRQy_ROUT.  Perlu dicatat bahwa sering kali tidak semua 15 IRQz2 baris per PIC diizinkan untuk digunakan, tetapi hanya sebagian (misalnya, 3,4,5,6,7,9,10,11,12,14,15).  Deskripsi register ini harus berisi informasi tentang IRQ mana yang tersedia untuk menetapkan interupsi dari jalur PIRQ kepada mereka.  Jadi, pemetaan yang diusulkan oleh kami di atas hanya mungkin jika penugasan PIRQ pada jalur IRQ3, IRQ4, IRQ5, IRQ6, IRQ10, IRQ11, IRQ14, IRQ14, IRQ15 tersedia.  Tetapi jika kita hati-hati melihat komentar sebelum fungsi pch_pirq_init, kita akan melihat bahwa itu adalah: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* PIRQ[n]_ROUT[3:0] - PIRQ Routing Control * 0x00 - 0000 = Reserved * 0x01 - 0001 = Reserved * 0x02 - 0010 = Reserved * 0x03 - 0011 = IRQ3 * 0x04 - 0100 = IRQ4 * 0x05 - 0101 = IRQ5 * 0x06 - 0110 = IRQ6 * 0x07 - 0111 = IRQ7 * 0x08 - 1000 = Reserved * 0x09 - 1001 = IRQ9 * 0x0A - 1010 = IRQ10 * 0x0B - 1011 = IRQ11 * 0x0C - 1100 = IRQ12 * 0x0D - 1101 = Reserved * 0x0E - 1110 = IRQ14 * 0x0F - 1111 = IRQ15 * PIRQ[n]_ROUT[7] - PIRQ Routing Control * 0x80 - The PIRQ is not routed. */</span></span></code> </pre> <br><h4>  4) Isi register Interrupt Line / Interrupt Pin untuk setiap fungsi PCI </h4><br>  Dalam ruang konfigurasi PCI (setiap PCI memiliki fungsi sesuai standar) ada 2 register yang menarik bagi kami: <br><br><ul><li>  3Ch: Interrupt Line - di sini Anda perlu menulis nomor IRQz2 (angka dari 0 hingga 15), angka interupsi yang akhirnya menarik fungsi ketika menggunakan pengontrol PIC </li><li>  3Dh: Interrupt Pin - menunjukkan baris INTx # (A / B / C / D) mana yang digunakan fungsi </li></ul><br>  Mari kita mulai dengan yang terakhir.  Register Interrupt Pin akan diisi secara otomatis berdasarkan pengaturan chipset (register DxxIP) yang dibuat oleh kami dalam paragraf 1 dan akan menjadi Read-Only. <br><br>  Jadi yang tersisa hanyalah mengisi register Interrupt Line dengan interupsi IRQz2 untuk setiap fungsi PCI. <br><br>  Mengetahui pemetaan PIRQy → IRQz2 (item 3b), dan pemetaan INTx # → PIRQy (item 2), Anda dapat dengan mudah mengisi register Interrupt Line untuk setiap fungsi, mengetahui INTx # interrupt yang digunakannya (item 1). <br><br>  Di coreboot, register Interrupt Line juga terisi dalam file <a href="">src \ southbridge \ intel \ lynxpoint \ lpc.c</a> dalam fungsi pch_pirq_init: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Eric Biederman once said we should let the OS do this. * I am not so sure anymore he was right. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (irq_dev = all_devices; irq_dev; irq_dev = irq_dev-&gt;next) { u8 int_pin=<span class="hljs-number"><span class="hljs-number">0</span></span>, int_line=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!irq_dev-&gt;enabled || irq_dev-&gt;path.type != DEVICE_PATH_PCI) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; int_pin = pci_read_config8(irq_dev, PCI_INTERRUPT_PIN); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (int_pin) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTA# */</span></span> int_line = config-&gt;pirqa_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTB# */</span></span> int_line = config-&gt;pirqb_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTC# */</span></span> int_line = config-&gt;pirqc_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-comment"><span class="hljs-comment">/* INTD# */</span></span> int_line = config-&gt;pirqd_routing; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!int_line) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; pci_write_config8(irq_dev, PCI_INTERRUPT_LINE, int_line); }</code> </pre> <br>  Untuk beberapa alasan, kode ini menyiratkan bahwa pemetaan dalam hal apapun INTA # → PIRQA, INTB # → PIRQB, INTC # → PIRQC, INTD # → PIRQD.  Meskipun dalam praktiknya kami melihat bahwa itu mungkin berbeda (lihat paragraf 2). <br><br>  Umumnya "Eric Biederman pernah berkata", dan kami menyalinnya di mana saja: <br><br><pre> <code class="bash hljs">$ grep <span class="hljs-string"><span class="hljs-string">"Eric Biederman once said"</span></span> -r src/ src/southbridge/intel/fsp_bd82x6x/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801gx/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/i82801ix/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/lynxpoint/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this. src/southbridge/intel/sch/lpc.c: /* Eric Biederman once said we should <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> the OS <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> this.</code> </pre> <br>  Secara umum, coreboot tidak terlalu peduli dengan dukungan interrupt legacy.  Sangat terkejut dengan kesalahan ini tidak layak.  Saat memuat OS modern, ini tidak akan mengganggu Anda, tetapi jika Anda tiba-tiba perlu memuat Linux dengan opsi "acpi = off nolapic", maka ini hampir tidak mungkin dilakukan. <br><br><h2>  Kesimpulan </h2><br>  Sebagai kesimpulan, kami akan mengulangi informasi khas yang perlu dikonfigurasi dalam chipset untuk routing interupsi PCI: <br><br><ol><li>  Tunjukkan baris INTx # mana yang setiap fungsi PCI tarik </li><li>  Konfigurasikan INTx # → pemetaan PIRQy untuk setiap perangkat PCI </li><li>  Isi pemetaan PIRQy → IRQz1 (PIR → APIC) dan pemetaan PIRQy → IRQz2 (PIR → PIC) </li><li>  Isi register Interrupt Line / Interrupt Pin dari ruang konfigurasi PCI untuk setiap fungsi PCI. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440304/">https://habr.com/ru/post/id440304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440294/index.html">MIDI-router di Raspberry Pi</a></li>
<li><a href="../id440296/index.html">6 Aplikasi untuk IoT Industri</a></li>
<li><a href="../id440298/index.html">Aplikasi Hari Valentine di Libgdx</a></li>
<li><a href="../id440300/index.html">10 perintah konsol untuk membantu memperdebatkan kode JavaScript seperti PRO</a></li>
<li><a href="../id440302/index.html">CRM - biaya kesuksesan, biaya kesalahan, biaya kepemilikan</a></li>
<li><a href="../id440306/index.html">Penskalaan basis data dalam sistem yang sangat dimuat</a></li>
<li><a href="../id440308/index.html">Bagilah dan taklukkan, atau tulis dengan lambat - baca dengan cepat</a></li>
<li><a href="../id440310/index.html">Cara mengajar mesin untuk memahami faktur dan mengekstrak data dari mereka</a></li>
<li><a href="../id440312/index.html">Hackquest 2018. Hasil & Tulisan. Hari 4-7</a></li>
<li><a href="../id440314/index.html">Kandidat Rilis JDK 12: Shenandoah, G1, JMH, Arm64. Bug di Swing menyerang balik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>