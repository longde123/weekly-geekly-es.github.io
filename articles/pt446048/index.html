<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò® üö° üëÉüèΩ A uni√£o do Arduino e o processador cl√°ssico üèØ üè¨ ü§ò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Retrocomputadores v√™m em v√°rios graus de mima√ß√£o. Alguns est√£o contentes com emula√ß√£o. Outros preferem FPGAs, porque ent√£o n√£o acontece emula√ß√£o, mas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>A uni√£o do Arduino e o processador cl√°ssico</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446048/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/8r/yr/ol8ryrltwjene6e2frje_pacnti.jpeg"></div><br>  Retrocomputadores v√™m em v√°rios graus de mima√ß√£o.  Alguns est√£o contentes com emula√ß√£o.  Outros preferem FPGAs, porque ent√£o n√£o acontece emula√ß√£o, mas recrea√ß√£o.  Por fim, sirva o terceiro processador. <br><br>  Mas o processador precisa de muito trabalho!  Novamente, o dilema: pegar chips reais dos mesmos anos ou colocar tudo no FPGA, deixando o processador de fora?  No entanto, por que o FPGA √© necess√°rio?  Viva a uni√£o do Arduino e do processador cl√°ssico! <a name="habracut"></a><br><br>  D√™ ao seu Arduino um "segundo c√©rebro" e torne-o mais inteligente. <br><br>  Um verdadeiro microprocessador de oito bits executa programas, enquanto um Arduino emula ROM, RAM e perif√©ricos simples. <br><br>  Projete perif√©ricos virtuais no Arduino IDE e execute o c√≥digo do assembler no microprocessador.  N√£o h√° necessidade de montar circuitos complexos e ROMs paralelas em flash. <br><br>  Microprocessadores suportados: 6502, 6809 e Z80 (18581), outros est√£o a caminho. <br><br>  Uma blindagem com um microprocessador n√£o interfere na conex√£o de outras blindagens: com LCDs, cart√µes de mem√≥ria etc. <br><br>  Al√©m da linguagem de auto-montagem, voc√™ pode tentar executar algum c√≥digo cl√°ssico no microprocessador. <br><br>  √â verdade que o microprocessador funcionar√° a uma frequ√™ncia muito baixa - cerca de 95 kHz, seu valor exato depende da otimiza√ß√£o do c√≥digo de emula√ß√£o perif√©rica. <br><br>  A distribui√ß√£o do espa√ßo de endere√ßo √© definida programaticamente em um esbo√ßo.  O microprocessador pode ser alocado de 4 a 6 kB de 8 kB de RAM dispon√≠vel no Arduino Mega.  A ROM pode alocar mais de 200 kB dos 256 dispon√≠veis. <br><br>  A porta serial Arduino Mega pode emular o UART. <br><br>  Circuitos, desenhos de placas e arquivos Gerber est√£o dispon√≠veis no CC-BY-SA 4.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Ao mesmo tempo, h√° um requisito para anexar o arquivo README.md, pois cont√©m o seguinte aviso: <br><blockquote>  N√£o conecte a blindagem at√© que o esbo√ßo da emula√ß√£o perif√©rica seja carregado!  Caso contr√°rio, √© poss√≠vel um curto-circuito nas linhas de sa√≠da do microprocessador. </blockquote>  Sim, e no pr√≥prio esbo√ßo, algo precisa ser refeito com cuidado pelo mesmo motivo. <br><br>  O esquema do dispositivo em 6502: <br><br><img src="https://habrastorage.org/webt/e0/n8/6k/e0n86kpozlcttklifjihnl51quo.png"><br><br>  O esquema do dispositivo em 6809: <br><br><img src="https://habrastorage.org/webt/qf/yi/kx/qfyikx1tktdjuad0hocivlpsolw.png"><br><br>  Esquema do dispositivo no Z80: <br><br><img src="https://habrastorage.org/webt/ct/uh/qs/ctuhqskjmmp1rvxrhs8abcoqvne.png"><br><br>  Voc√™ j√° pode executar: <br><br>  Em um dispositivo com 6502 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apple I, Woz Monitor + ROM com BASIC</a> <br><br>  Em um dispositivo com 6809 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um an√°logo de um computador caseiro Simon6809 do mesmo desenvolvedor, um monitor de treinamento com montador e desmontador</a> <br><br>  Em um dispositivo com Z80 - at√© agora, apenas um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teste de eco da porta serial</a> , permitindo verificar o desempenho do 8251 virtual (KR580VV51A). <br><br>  Firmware para emular perif√©ricos - sob a licen√ßa MIT. <br><br>  Breves descri√ß√µes do princ√≠pio de a√ß√£o: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para o dispositivo 6502</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para o dispositivo em 6809</a> <br><br>  Para o dispositivo no Z80 - em prepara√ß√£o. <br><br>  O desenvolvedor est√° tentando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vender</a> dispositivos, mas com entrega apenas nos Estados Unidos.  N√£o h√° nenhuma raz√£o espec√≠fica para comprar, porque o esquema √© muito simples, voc√™ pode repeti-lo em um peda√ßo da t√°bua de p√£o em uma hora. <br><br>  Est√° planejado o desenvolvimento de placas semelhantes nos modelos RCA1802, 68008, 8085 (182185), 8088 (181088).  Sobre o K1801BM1 n√£o √© mencionado, mas voc√™ pode lan√ßar essa id√©ia ao autor. <br><br>  Arquivos: <br><br>  Para o dispositivo 6502: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instru√ß√µes de montagem</a> , <a href="">serigrafia</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diagrama</a> <br><br>  Para dispositivo no 6809: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instru√ß√µes de montagem</a> , <a href="">serigrafia</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diagrama</a> <br><br>  Para o dispositivo no Z80: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instru√ß√µes de montagem</a> , <a href="">serigrafia</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diagrama</a> <br><br>  Considere a intera√ß√£o de um Arduino e um dispositivo 6502. O Arduino altera periodicamente o n√≠vel na entrada de um microprocessador projetado para fornecer pulsos de clock de zero a um e vice-versa.  A cada ciclo, ele verifica o que est√° acontecendo nas linhas de controle e no barramento de endere√ßos e, dependendo da situa√ß√£o, l√™ as informa√ß√µes do barramento de dados ou as envia para l√°.  O Arduino tamb√©m pode controlar as linhas de IRQ e NMI, causando interrup√ß√µes.  A figura mostra os tipos de dados e as dire√ß√µes de sua transmiss√£o: <br><br><img src="https://habrastorage.org/webt/tr/in/je/trinjeibi9cwwrngfq628lm4yns.png"><br><br>  A correspond√™ncia das portas do Arduino e das sa√≠das do microprocessador √© configurada no esbo√ßo: <br><br><pre><code class="plaintext hljs">/* Digital Pin Assignments */ #define DATA_OUT PORTL #define DATA_IN PINL #define ADDR_H PINC #define ADDR_L PINA #define ADDR ((unsigned int) (ADDR_H &lt;&lt; 8 | ADDR_L)) #define uP_RESET_N 38 #define uP_RW_N 40 #define uP_RDY 39 #define uP_SO_N 41 #define uP_IRQ_N 50 #define uP_NMI_N 51 #define uP_E 52 #define uP_GPIO 53</code> </pre> <br>  Dividiremos cada medida nos seguintes eventos: <br><br>  CLK altera o estado de um para zero (decl√≠nio) <br>  CLK est√° em um estado zero <br>  CLK muda de estado de um para zero (aumento) <br>  CLK est√° no estado da unidade <br>  O CLK novamente altera o estado de um para zero ... <br><br>  O que acontece durante momentos de transi√ß√£o de estado? <br><br>  6502 recebe pulsos de clock na entrada CLK0, os armazena em buffer e os envia para duas sa√≠das: CLK1 e CLK2.  Embora todos os eventos no microprocessador estejam vinculados ao CLK1, supomos que o atraso n√£o seja grande e eles est√£o vinculados ao CLK0 - a linha na qual o microprocessador recebe pulsos de clock do Arduino.  E chame o sinal apenas CLK. <br><br><img src="https://habrastorage.org/webt/9i/kq/hc/9ikqhcytwd4sjg6rwjnvmohgkvi.png"><br><br>  1. CLK muda de estado de um para zero. <br><br>  2. O microprocessador envia um novo endere√ßo para o barramento de endere√ßos e um sinal de comuta√ß√£o entre leitura e grava√ß√£o na sa√≠da R / W.  Mas ele ainda n√£o est√° pronto para a troca de dados. <br><br>  3. O CLK entra no estado da unidade e isso significa que a troca de dados come√ßou.  Se for uma opera√ß√£o de leitura, o microprocessador transfere as sa√≠das do barramento de dados para o estado de entrada e recebe dados e, se a opera√ß√£o de grava√ß√£o, transfere-as para o estado de sa√≠da e envia os dados.  E o sinal R / W muda o dispositivo externo para o modo de grava√ß√£o ou leitura, o oposto do estado correspondente do microprocessador. <br><br>  4. CLK vai para zero.  Agora, nem o microprocessador nem os dispositivos de entrada e sa√≠da produzem nada para o barramento de dados.  O microprocessador pode definir a linha do barramento de dados e o pino R / W para um novo estado. <br><br>  Uma explica√ß√£o simples, compreens√≠vel para a crian√ßa.  Quem nunca pensa nessas "intrigas nos bastidores", se ele apenas programa microcontroladores.  Mesmo em montador. <br><br>  Se voc√™ precisar conectar seu dispositivo perif√©rico, ele dever√° ter tempo para preparar os dados antes que a unidade (tempo de prepara√ß√£o) apare√ßa na linha CLK e, enquanto a unidade estiver l√°, n√£o a altere.  Se o dispositivo perif√©rico n√£o tiver tempo para preparar os dados enquanto o CLK estiver zero, ou os alterar quando a unidade estiver l√°, voc√™ se perguntar√° por um longo tempo por que seu c√≥digo n√£o funciona.  Como a frequ√™ncia de clock do microprocessador √© dez a quinze vezes menor que a frequ√™ncia nominal, √© f√°cil atender a esse requisito.  Mas √© necess√°rio. <br><br>  Portanto, precisamos ‚Äúensinar‚Äù o Arduino a gerar pulsos de clock, verificando continuamente o que acontece no barramento de endere√ßos e na linha R / W e interagindo com o barramento de dados de acordo.  Para fazer isso, o esbo√ßo usa a interrup√ß√£o do timer1, que gera pulsos com uma frequ√™ncia de 95 kHz.  O Arduino trabalha muito mais r√°pido que o microprocessador e, portanto, entre seus rel√≥gios, consegue ler e preparar tudo.  √â importante garantir que, ap√≥s modificar o esbo√ßo, essa condi√ß√£o continue a ser atendida. <br><br>  Aqui est√° um trecho do esbo√ßo, que mostra como o CLK vai de zero a um e o que acontece a seguir: <br><br><pre> <code class="plaintext hljs">//////////////////////////////////////////////////////////////////// // Processor Control Loop //////////////////////////////////////////////////////////////////// // This is where the action is. // it reads processor control signals and acts accordingly. // ISR(TIMER1_COMPA_vect) { // Drive CLK high CLK_E_HIGH; // Let's capture the ADDR bus uP_ADDR = ADDR; if (STATE_RW_N) ////////////////////////////////////////////////////////////////// // HIGH = READ transaction { // uP wants to read so Arduino to drive databus to uP: DATA_DIR = DIR_OUT; // Check what device uP_ADDR corresponds to: // ROM? if ( (ROM_START &lt;= uP_ADDR) &amp;&amp; (uP_ADDR &lt;= ROM_END) ) DATA_OUT = pgm_read_byte_near(rom_bin + (uP_ADDR - ROM_START)); else if ( (BASIC_START &lt;= uP_ADDR) &amp;&amp; (uP_ADDR &lt;= BASIC_END) ) DATA_OUT = pgm_read_byte_near(basic_bin + (uP_ADDR - BASIC_START)); else // RAM? if ( (uP_ADDR &lt;= RAM_END) &amp;&amp; (RAM_START &lt;= uP_ADDR) ) DATA_OUT = RAM[uP_ADDR - RAM_START]; else // 6821? if ( KBD &lt;=uP_ADDR &amp;&amp; uP_ADDR &lt;= DSPCR ) { // KBD? if (uP_ADDR == KBD) { ... // handle KBD register } else // KBDCR? if (uP_ADDR == KBDCR) { ... // handle KBDCR register } else // DSP? if (uP_ADDR == DSP) { ... // handle DSP register } else // DSPCR? if (uP_ADDR == DSPCR) { ... // handle DSPCR register } } } else ////////////////////////////////////////////////////////////////// // R/W = LOW = WRITE { // RAM? if ( (uP_ADDR &lt;= RAM_END) &amp;&amp; (RAM_START &lt;= uP_ADDR) ) RAM[uP_ADDR - RAM_START] = DATA_IN; else // 6821? if ( KBD &lt;=uP_ADDR &amp;&amp; uP_ADDR &lt;= DSPCR ) { // KBD? if (uP_ADDR == KBD) { ... // handle KBD register } else // KBDCR? if (uP_ADDR == KBDCR) { ... // handle KBDCR register } else // DSP? if (uP_ADDR == DSP) { ... // handle DSP register } else // DSPCR? if (uP_ADDR == DSPCR) { ... // handle DSPCR register } } } //////////////////////////////////////////////////////////////// // We are done with this cycle. // one full cycle complete clock_cycle_count ++; // start next cycle CLK_E_LOW; // If Arduino was driving the bus, no need anymore. // natural delay for DATA Hold time after CLK goes low (t_HR) DATA_DIR = DIR_IN; }</code> </pre> <br>  A aloca√ß√£o do espa√ßo de endere√ßo pode ser feita de qualquer maneira; em um esbo√ßo n√£o modificado, √© o mesmo da Apple 1 com 256 bytes de ROM, 8 kilobytes de ROM para BASIC, 4 kilobytes de RAM e dispositivo de entrada e sa√≠da 6821. <br><br><pre> <code class="plaintext hljs">// MEMORY LAYOUT // 4K MEMORY #define RAM_START 0x0000 #define RAM_END 0x0FFF byte RAM[RAM_END-RAM_START+1]; // ROMs (Monitor + Basic) #define ROM_START 0xFF00 #define ROM_END 0xFFFF #define BASIC_START 0xE000 #define BASIC_END 0xEFFF //////////////////////////////////////////////////////////////////// // Woz Monitor Code //////////////////////////////////////////////////////////////////// // PROGMEM const unsigned char rom_bin[] = { 0xd8, 0x58, 0xa0, 0x7f, 0x8c, 0x12, 0xd0, 0xa9, 0xa7, 0x8d, 0x11, 0xd0, ... 0x00, 0xff, 0x00, 0x00 }; // BASIC ROM starts at E000 PROGMEM const unsigned char basic_bin[] = { 0x4C, 0xB0, 0xE2, 0xAD, 0x11, 0xD0, 0x10, 0xFB, ... 0xE0, 0x80, 0xD0, 0x01, 0x88, 0x4C, 0x0C, 0xE0 };</code> </pre> <br>  A RAM √© emulada pelo conjunto de bytes da RAM [RAM_END-RAM_START + 1].  S√£o necess√°rias duas palavras-chave PROGMEM para que o conte√∫do das ROMs emuladas seja armazenado na mem√≥ria flash do microcontrolador. <br><br>  O 6821 √© emulado o suficiente para que o teclado virtual e o monitor funcionem atrav√©s do "terminal".  Woz Monitor e BASIC trabalham, que √© o que o autor procurou. <br><br>  Para emular qualquer dispositivo perif√©rico, voc√™ precisa ler atentamente sua folha de dados e descobrir quais registros ela possui e para que servem.  A conveni√™ncia da emula√ß√£o reside na flexibilidade com a qual voc√™ pode fazer an√°logos de software da periferia. <br><br>  Os dispositivos de E / S est√£o localizados no espa√ßo de endere√ßo do microprocessador e s√£o acessados ‚Äã‚Äãda mesma maneira que as c√©lulas de mem√≥ria.  Para usar os perif√©ricos "de ferro", como uma tela LCD, um cart√£o de mem√≥ria e uma sa√≠da de som, √© necess√°rio alocar um local no espa√ßo de endere√ßo. <br><br>  Refer√™ncias: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.6502.org</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.callapple.org/soft/ap1/emul.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">skilldrick.github.io/easy6502</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">searle.hostei.com/grant/6502/Simple6502.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wilsonminesco.com/6502primer</a> <br>  SB-Assembler: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.sbprojects.net/sbasm</a> <br><br>  V√° para 6809, ele cont√©m: <br><br>  Duas baterias de oito bits A e B, que podem ser combinadas em uma bateria de seis bits <br>  Dois √≠ndices de pilha de 16 bits <br>  Endere√ßamento relativo ao contador de instru√ß√µes <br>  Adicionar ou subtrair automaticamente 1 ou 2 <br>  Multiplica√ß√£o de dois n√∫meros n√£o assinados de oito d√≠gitos <br>  Aritm√©tica de 16 bits <br>  Transfer√™ncia e troca de dados entre todos os registros <br>  Escrever e ler todos os registros e qualquer combina√ß√£o deles <br><br>  O microprocessador 6809E (externo) precisa de um rel√≥gio externo, enquanto o 6809 possui um rel√≥gio interno.  Para a Hitachi, eles s√£o chamados, respectivamente, 6309E e 6309, diferem dos habituais porque operam na forma de 32 bits dentro da opera√ß√£o, mas √© poss√≠vel alternar para o modo de compatibilidade com a vers√£o cl√°ssica. <br><br>  Na verdade, todo o projeto RetroShield come√ßou porque o autor queria atualizar seu computador caseiro Simon6809 e nomear o resultado Simon6809 Turbo.  Mas os chips l√≥gicos padr√£o para tudo o que ele queria implementar l√° exigiriam muito.  Portanto, o autor formulou a id√©ia do RetroShield pela primeira vez em rela√ß√£o ao 6809, e s√≥ ent√£o pensou: ‚Äúe se o mesmo com outros processadores fizer o mesmo?‚Äù. <br><br>  O dispositivo, √© claro, usa o 6809E, que requer um rel√≥gio externo, para que ele possa sincronizar seu trabalho de fora.  As linhas E e Q para ambos os processadores t√™m o mesmo nome, apenas 6809 t√™m sa√≠das e 6809E t√™m entradas. <br><br>  O Arduino interage com o 6809 da mesma maneira que com o 6502, mas possui duas entradas de rel√≥gio: E e Q e tr√™s entradas de interrup√ß√£o: IRQ, FIRQ e NMI. <br><br><img src="https://habrastorage.org/webt/0i/uk/dn/0iukdn25vkrhbsvd8spjlhr-s3q.png"><br><br>  Desta vez, a correspond√™ncia entre as portas do Arduino e os pinos do microprocessador √© configurada da seguinte maneira: <br><br><pre> <code class="plaintext hljs">/* Digital Pin Assignments */ #define DATA_OUT PORTL #define DATA_IN PINL #define ADDR_H PINC #define ADDR_L PINA #define ADDR ((unsigned int) (ADDR_H &lt;&lt; 8 | ADDR_L)) #define uP_RESET_N 38 #define uP_E 52 #define uP_Q 53 #define uP_RW_N 40 #define uP_FIRQ_N 41 #define uP_IRQ_N 50 #define uP_NMI_N 51 #define uP_GPIO 39</code> </pre> <br>  Como pode ser visto nos gr√°ficos, o sinal Q √© deslocado em rela√ß√£o a E em um quarto do per√≠odo: <br><br>  Dificilmente prestaremos aten√ß√£o em Q, pois todos os eventos est√£o vinculados a E. E tudo acontece assim: <br><br><img src="https://habrastorage.org/webt/ao/hj/qv/aohjqvkk89mbouy7_njtjqbz3ku.png"><br><br><ol><li>  E muda para zero.  O processador define um novo endere√ßo no barramento de endere√ßos e altera o estado da linha R / W. </li><li>  E muda para um, o processador fica pronto para a troca de dados. </li><li>  N√£o importa o que acontece com o barramento de dados, desde que E seja um, o principal √© que os dados necess√°rios estejam presentes l√° no momento em que E voltar a zero. </li><li>  Ao ler dados, o dispositivo de E / S deve fornecer os dados necess√°rios ao barramento de dados antes que a linha E passe de um para zero (o atraso m√≠nimo √© mostrado pelo n√∫mero 17 no c√≠rculo). </li><li>  Ao gravar, o dispositivo de E / S deve corrigir os dados em algum registro da forma em que estava no momento E passou de um para zero.  O processador fornecer√° esses dados no barramento ainda mais cedo - no momento da transi√ß√£o de Q para um (o n√∫mero 20 no c√≠rculo). </li><li>  Ap√≥s a transi√ß√£o de E para zero, tudo se repete. </li></ol><br>  Tudo o que foi dito acima, sobre 6502, sobre a necessidade de um dispositivo perif√©rico (incluindo um virtual) para desenvolver todos os sinais no prazo, diz respeito ao 6809. <br><br>  Gera√ß√£o dos sinais E e Q, como no caso do 6502, com a √∫nica diferen√ßa de que existem dois sinais, e eles devem ser trocados de acordo com os gr√°ficos.  E assim, uma sub-rotina chamada interrup√ß√£o realiza entrada ou sa√≠da de dados nos momentos necess√°rios. <br><br>  O espa√ßo de endere√ßo no esbo√ßo n√£o modificado √© distribu√≠do da mesma maneira que no computador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">caseiro Simon6809</a> : <br><br><pre> <code class="plaintext hljs">// MEMORY #define RAM_START 0x0000 #define RAM_END 0x0FFF #define ROM_START 0xE000 #define ROM_END 0xFFFF byte RAM[RAM_END-RAM_START+1]; //////////////////////////////////////////////////////////////////// // Monitor Code //////////////////////////////////////////////////////////////////// // static const unsigned char PROGMEM const unsigned char simon09_bin[] = { 0x1a, 0xff, 0x4f, 0x1f, 0x8b, 0x0f, 0x36, 0x7f, 0x01, 0xa5, 0x10, 0xce, ... 0x00, 0x09, 0x00, 0x0c, 0x00, 0x0f, 0xe0, 0x00 };</code> </pre> <br>  A RAM e a ROM s√£o armazenadas em matrizes da mesma maneira que na variante 6502, com a √∫nica diferen√ßa sendo que existe apenas uma matriz com dados da ROM. <br><br>  Os dispositivos de E / S tamb√©m s√£o partes alocadas do espa√ßo de endere√ßo e podem ser virtuais ou reais.  Como o Simon6809 √© uma m√°quina moderna baseada em uma base elementar vintage, ele troca dados via FTDI do PC no qual o "terminal" est√° sendo executado.  Aqui √© emulado. <br><br>  Refer√™ncias: <br><br>  Muita informa√ß√£o sobre 6809 na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°gina Arto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo da Wikipedia sobre 6809</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sistemas SWTPc 6809</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo da Wikipedia sobre o sistema operacional FLEX</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt446048/">https://habr.com/ru/post/pt446048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt446036/index.html">Oracle Application Express. Aplicativos e p√°ginas</a></li>
<li><a href="../pt446038/index.html">Um pequeno guia sobre a cria√ß√£o de or√°culos, deuses dos carros e erros de segunda ordem</a></li>
<li><a href="../pt446040/index.html">Confiss√£o Full Stack: Profiss√£o, Religi√£o, Sonhos</a></li>
<li><a href="../pt446042/index.html">DJI Mavic 2 Pro ap√≥s seis meses de uso</a></li>
<li><a href="../pt446046/index.html">A expans√£o do universo √© a maior fal√°cia da hist√≥ria da ci√™ncia</a></li>
<li><a href="../pt446050/index.html">Flutter. Chaves! Para que eles servem?</a></li>
<li><a href="../pt446052/index.html">Criando a voz e o tom do seu produto</a></li>
<li><a href="../pt446054/index.html">Backup pronto: destruindo mitos do feriado</a></li>
<li><a href="../pt446056/index.html">Uma maneira simples de conversar com seu site</a></li>
<li><a href="../pt446058/index.html">Como criar SDN - Oito ferramentas de c√≥digo aberto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>