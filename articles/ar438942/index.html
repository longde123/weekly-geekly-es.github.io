<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏮️ 🤛🏻 🤵🏻 الظلال الثنائية الأبعاد على حقول المسافات الموقعة 🔏 👎 💠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="الآن وبعد أن عرفنا أساسيات الجمع بين وظائف المسافة الموقعة ، يمكنك استخدامها لإنشاء أشياء رائعة. في هذا البرنامج التعليمي ، سوف نستخدمها لتقديم ظلال ن...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>الظلال الثنائية الأبعاد على حقول المسافات الموقعة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438942/" style=";text-align:right;direction:rtl"> الآن وبعد أن عرفنا أساسيات الجمع بين وظائف المسافة الموقعة ، يمكنك استخدامها لإنشاء أشياء رائعة.  في هذا البرنامج التعليمي ، سوف نستخدمها لتقديم ظلال ناعمة ثنائية الأبعاد.  إذا لم تكن قد قمت بقراءة البرامج التعليمية السابقة الخاصة بي على حقول المسافات الموقعة (SDF) ، فإنني أوصي بشدة بدراستها ، بدءًا من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">البرنامج التعليمي حول إنشاء أشكال بسيطة</a> . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/yl/el/eh/ylelehlfeymk9yzxs5eezpyzyfq.gif"></div><br>  [GIF ولدت القطع الأثرية الإضافية أثناء إعادة الضغط.] <br><a name="habracut"></a><br><h2 style=";text-align:right;direction:rtl">  التكوين الأساسي </h2><br>  قمت بإنشاء تكوين بسيط مع غرفة ، ويستخدم التقنيات الموضحة في البرامج التعليمية السابقة.  في وقت سابق ، لم أذكر أنني استخدمت وظيفة <code>abs</code> للمتجه 2 لتعكس الموضع بالنسبة لمحور x و y ، وأيضًا قمت بقلب مسافة الشكل من أجل تبديل الأجزاء الداخلية والخارجية. <br><br>  سنقوم بنسخ الملف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">2D_SDF.cginc</a> من البرنامج التعليمي السابق إلى مجلد واحد باستخدام التظليل ، والذي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">سنكتبه</a> في هذا البرنامج التعليمي. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/037_2D_SDF_Shadows"</span></span>{ Properties{ } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float bounds = -rectangle(position, 2); float2 quarterPos = abs(position); float corner = rectangle(translate(quarterPos, 1), 0.5); corner = subtract(corner, rectangle(position, 1.2)); float diamond = rectangle(rotate(position, 0.125), .5); float world = merge(bounds, corner); world = merge(world, diamond); return world; } fixed4 frag(v2f i) : SV_TARGET{ float dist = scene(i.worldPos.xz); return dist; } ENDCG } } FallBack "Standard" //fallback adds a shadow pass so we get shadows on other objects }</span></span></code> </pre> <br>  إذا كنا لا نزال نستخدم تقنية التصور من البرنامج التعليمي السابق ، فسيبدو الشكل كما يلي: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/5ff/2cc/aee/5ff2ccaee5f12c0f87a1b7ae455bc044.png"></div><br><h2 style=";text-align:right;direction:rtl">  ظلال بسيطة </h2><br>  لإنشاء ظلال حادة ، نذهب حول الفضاء من موضع العينة إلى موضع مصدر الضوء.  إذا وجدنا كائنًا في الطريق ، فقد قررنا أن البكسل يجب أن يكون مظللاً ، وإذا وصلنا إلى المصدر دون عائق ، نقول إنه غير مظلل. <br><br>  نبدأ من خلال حساب المعلمات الأساسية للحزم.  لدينا بالفعل نقطة بداية (موضع البكسل الذي نقدمه) ونقطة مستهدفة (موضع مصدر الضوء) للحزمة.  نحن بحاجة إلى طول واتجاه طبيعي.  يمكن الحصول على الاتجاه من خلال طرح البداية من النهاية وتطبيع النتيجة.  يمكن الحصول على الطول بطرح المواضع وتمرير القيمة إلى طريقة <code>length</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traceShadow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position, float2 lightPosition)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> direction = normalise(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = length(lightPosition - position); }</code> </pre> <br>  ثم نلتف حول الأشعة في الحلقة.  سنقوم بتعيين تكرارات الحلقة في تعريف التعريف ، وسيتيح لنا ذلك تكوين الحد الأقصى لعدد التكرارات لاحقًا ، كما سنسمح للمترجم بتحسين التظليل قليلاً عن طريق توسيع الحلقة. <br><br>  في الحلقة ، نحتاج إلى الموضع الذي نحن فيه الآن ، لذلك نعلن أنه خارج الحلقة مع القيمة الأولية 0. في الحلقة ، يمكننا حساب موضع العينة عن طريق إضافة تقدم الحزمة مضروبًا في اتجاه الحزمة مع الموضع الأساسي.  ثم نقوم بتجربة وظيفة المسافة الموقعة في الموضع المحسوب للتو. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// outside of function #define SAMPLES 32 // in shadow function float rayDistance = 0; for(int i=0 ;i&lt;SAMPLES; i++){ float sceneDist = scene(pos + direction * rayDistance); //do other stuff and move the ray further }</span></span></code> </pre> <br>  ثم نتحقق لمعرفة ما إذا كنا بالفعل في النقطة التي يمكننا من خلالها إيقاف الدورة.  إذا كانت مسافة مشهد وظيفة المسافة مع الإشارة قريبة من 1 ، فبإمكاننا افتراض أن الشعاع مسدود برقم ويعود إلى 0. إذا انتشرت الحزمة على مسافة أبعد من المسافة إلى مصدر الضوء ، يمكننا افتراض أننا وصلنا إلى المصدر دون حدوث تصادمات ونعيد القيمة 1. <br><br>  إذا لم يكن العائد ناجحًا ، فأنت بحاجة إلى حساب الموضع التالي للعينة.  يتم ذلك عن طريق إضافة المسافة في مشهد تقدم الحزمة.  والسبب في ذلك هو أن المسافة في المشهد تعطينا المسافة إلى أقرب رقم ، لذلك إذا أضفنا هذه القيمة إلى الحزمة ، فربما لن نتمكن من إرسال الحزمة إلى أبعد من أقرب رقم ، أو حتى بعده ، مما سيؤدي إلى تدفق الظلال. <br><br>  في حال لم نواجه أي شيء ولم نصل إلى مصدر الضوء بحلول وقت اكتمال مخزون العينة (انتهت الدورة) ، نحتاج أيضًا إلى إرجاع القيمة.  نظرًا لأن هذا يحدث بشكل أساسي بجوار الأشكال ، قبل فترة وجيزة من اعتبار البيكسل مظللة ، نستخدم هنا القيمة المرجعة 0. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAMPLES 32 float traceShadows(float2 position, float2 lightPosition){ float2 direction = normalize(lightPosition - position); float lightDistance = length(lightPosition - position); float rayProgress = 0; for(int i=0 ;i</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SAMPLES; i++){ float sceneDist = scene(position + direction * rayProgress); if(sceneDist &lt;= 0){ return 0; } if(rayProgress &gt; lightDistance){ return 1; } rayProgress = rayProgress + sceneDist; } return 0; }</span></span></span></span></code> </pre> <br>  لاستخدام هذه الوظيفة ، نسميها في وظيفة شظية مع موضع البيكسل وموضع مصدر الضوء.  ثم نقوم بضرب النتيجة بأي لون لخلطها مع لون مصادر الضوء. <br><br>  كما أنني استخدمت التقنية الموضحة في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">البرنامج التعليمي الأول حول حقول المسافات مع علامة</a> لتصور الهندسة.  ثم أضفت فقط مطوية والهندسة.  هنا يمكننا فقط استخدام عملية الإضافة ، وعدم تنفيذ الاستيفاء الخطي أو الإجراءات المماثلة ، لأن الشكل أسود في كل مكان حيث لا يكون الشكل ، والظل أسود في كل مكان حيث يكون الشكل. <br><br> <code>fixed4 frag(v2f i) : SV_TARGET{ float2 position = i.worldPos.xz;</code> <br> <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">float2 lightPos; sincos(_Time.y, lightPos.x <span class="hljs-comment"><span class="hljs-comment">/*sine of time*/</span></span>, lightPos.y <span class="hljs-comment"><span class="hljs-comment">/*cosine of time*/</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadows = traceShadows(position, lightPos); float3 light = shadows * float3(<span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = scene(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(sceneDistance) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> binaryScene = smoothstep(distanceChange, -distanceChange, sceneDistance); float3 geometry = binaryScene * float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>); float3 col = geometry + light; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(col, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/29f/0cc/3e529f0cc0c90767d42bf4c14916f377.gif"></div><br><h2 style=";text-align:right;direction:rtl">  الظلال الناعمة </h2><br>  الانتقال من هذه الظلال القاسية إلى ليونة وأكثر واقعية أمر سهل بما فيه الكفاية.  في الوقت نفسه ، لا يصبح التظليل أكثر تكلفة حسابيًا. <br><br>  أولاً ، نحصل ببساطة على المسافة إلى أقرب كائن مشهد لكل عينة نتجاوزها ، ونختار الأقرب منها.  بعد ذلك ، حيث اعتدنا أن نرجع 1 ، سيكون من الممكن إعادة المسافة إلى أقرب رقم.  حتى لا يكون سطوع الظل مرتفعًا جدًا ولا يؤدي إلى إنشاء ألوان غريبة ، فسوف نمررها عبر الطريقة <code>saturate</code> ، التي تقصرها على الفاصل الزمني من 0 إلى 1. نحصل على الحد الأدنى بين أقرب رقم حالي والشكل التالي بعد التحقق مما إذا كانت حزمة مصدر الضوء قد وصلت بالفعل إلى التوزيع خلاف ذلك ، يمكننا أخذ عينات تتجاوز مصدر الضوء والحصول على قطع أثرية غريبة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traceShadows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position, float2 lightPosition)</span></span></span></span>{ float2 direction = normalize(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightDistance = length(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rayProgress = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nearest = <span class="hljs-number"><span class="hljs-number">9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span> ;i&lt;SAMPLES; i++){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDist = scene(position + direction * rayProgress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sceneDist &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rayProgress &gt; lightDistance){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(nearest); } nearest = min(nearest, sceneDist); rayProgress = rayProgress + sceneDist; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/6af/953/680/6af9536801d8eba4596b10e55aba7c3b.png"></div><br>  أول شيء نلاحظه بعد ذلك هو "الأسنان" الغريبة في الظل.  إنها تنشأ لأن المسافة من المشهد إلى مصدر الضوء أقل من 1. حاولت مواجهة هذا بطرق مختلفة ، لكن لم أتمكن من إيجاد حل.  بدلا من ذلك ، يمكننا تنفيذ الحدة من الظل.  ستكون الحدة معلمة أخرى في وظيفة الظل.  في الحلقة ، نقوم بضرب المسافة في المشهد بالحدة ، ومن ثم ، مع الحدة 2 ، يصبح الجزء الناعم والرمادي من الظل نصف هذا العدد.  عند استخدام الحدة ، يمكن أن يكون مصدر الضوء من الشكل على مسافة لا تقل عن 1 مقسومًا على الحدة ، وإلا ستظهر الآثار.  لذلك ، إذا استخدمت حدة 20 ، يجب أن تكون المسافة 0.05 وحدة على الأقل. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traceShadows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position, float2 lightPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hardness)</span></span></span></span>{ float2 direction = normalize(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightDistance = length(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rayProgress = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nearest = <span class="hljs-number"><span class="hljs-number">9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span> ;i&lt;SAMPLES; i++){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDist = scene(position + direction * rayProgress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sceneDist &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rayProgress &gt; lightDistance){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(nearest); } nearest = min(nearest, hardness * sceneDist); rayProgress = rayProgress + sceneDist; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//in fragment function float shadows = traceShadows(position, lightPos, 20);</span></span></code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/610/70b/5a4/61070b5a42c96ac0d121b8aa7f2130ae.png"></div><br>  من خلال تقليل هذه المشكلة ، نلاحظ ما يلي: حتى في المناطق التي يجب عدم تظليلها ، لا يزال الضعف مرئيًا بالقرب من الجدران.  بالإضافة إلى ذلك ، يبدو أن ليونة الظل هي نفسها بالنسبة للظل بالكامل ، وليست حادة بجوار الشكل والنعومة عند الابتعاد عن الكائن الذي ينبعث الظل. <br><br>  سنقوم بإصلاح ذلك عن طريق تقسيم المسافة في المشهد على انتشار الحزمة.  بفضل هذا ، سنقسم المسافة إلى أرقام صغيرة جدًا في بداية الحزمة ، أي أننا سنظل نحصل على قيم عالية وظلال واضحة جميلة.  عندما نعثر على النقطة الأقرب إلى الشعاع في النقاط اللاحقة في الشعاع ، يتم تقسيم أقرب نقطة على عدد أكبر ، مما يجعل الظل أكثر ليونة.  نظرًا لأن هذا لا يرتبط تمامًا بأقصر مسافة ، فسنقوم بإعادة تسمية المتغير إلى <code>shadow</code> . <br><br>  سنجري أيضًا تغييرًا بسيطًا واحدًا: نظرًا لأننا نقسم على rayProgress ، يجب ألا تبدأ بالرقم 0 (القسمة على الصفر هي دائمًا فكرة سيئة).  كبداية ، يمكنك اختيار أي عدد صغير جدًا. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traceShadows</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 position, float2 lightPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hardness)</span></span></span></span>{ float2 direction = normalize(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lightDistance = length(lightPosition - position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rayProgress = <span class="hljs-number"><span class="hljs-number">0.0001</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadow = <span class="hljs-number"><span class="hljs-number">9999</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span> ;i&lt;SAMPLES; i++){ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDist = scene(position + direction * rayProgress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sceneDist &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(rayProgress &gt; lightDistance){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saturate(shadow); } shadow = min(shadow, hardness * sceneDist / rayProgress); rayProgress = rayProgress + sceneDist; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/e46/715/305/e46715305ef51c3016c4d56b34f47a8d.png"></div><br><h2 style=";text-align:right;direction:rtl">  مصادر الإضاءة المتعددة </h2><br>  في هذا التطبيق البسيط أحادي النواة ، تتمثل أسهل طريقة للحصول على مصادر إضاءة متعددة في حسابها بشكل فردي وإضافة النتائج. <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">fixed4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v2f i)</span></span></span><span class="hljs-function"> : SV_TARGET</span></span>{ float2 position = i.worldPos.xz; float2 lightPos1 = float2(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y), <span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadows1 = traceShadows(position, lightPos1, <span class="hljs-number"><span class="hljs-number">20</span></span>); float3 light1 = shadows1 * float3(<span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); float2 lightPos2 = float2(-<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(_Time.y) * <span class="hljs-number"><span class="hljs-number">1.75</span></span>, <span class="hljs-number"><span class="hljs-number">1.75</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadows2 = traceShadows(position, lightPos2, <span class="hljs-number"><span class="hljs-number">10</span></span>); float3 light2 = shadows2 * float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">.6</span></span>, <span class="hljs-number"><span class="hljs-number">.6</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sceneDistance = scene(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distanceChange = fwidth(sceneDistance) * <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> binaryScene = smoothstep(distanceChange, -distanceChange, sceneDistance); float3 geometry = binaryScene * float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>); float3 col = geometry + light1 + light2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(col, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/a3b/b70/6ce/a3bb706cec13c16a54d8d740b0d91589.gif"></div><br><h2 style=";text-align:right;direction:rtl">  شفرة المصدر </h2><br><h3 style=";text-align:right;direction:rtl">  مكتبة SDF ثنائية الأبعاد (لم تتغير ، ولكنها تستخدم هنا) </h3><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/037_SDF_2D_Shadows/2D_SDF.cginc</a> </li></ul><br><h3 style=";text-align:right;direction:rtl">  ظلال ناعمة ثنائية الأبعاد </h3><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/037_SDF_2D_Shadows/2D_SDF_Shadows.shader</a> </li></ul><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Tutorial/037_2D_SDF_Shadows"</span></span>{ Properties{ } SubShader{ <span class="hljs-comment"><span class="hljs-comment">//the material is completely non-transparent and is rendered at the same time as the other opaque geometry Tags{ "RenderType"="Opaque" "Queue"="Geometry"} Pass{ CGPROGRAM #include "UnityCG.cginc" #include "2D_SDF.cginc" #pragma vertex vert #pragma fragment frag struct appdata{ float4 vertex : POSITION; }; struct v2f{ float4 position : SV_POSITION; float4 worldPos : TEXCOORD0; }; v2f vert(appdata v){ v2f o; //calculate the position in clip space to render the object o.position = UnityObjectToClipPos(v.vertex); //calculate world position of vertex o.worldPos = mul(unity_ObjectToWorld, v.vertex); return o; } float scene(float2 position) { float bounds = -rectangle(position, 2); float2 quarterPos = abs(position); float corner = rectangle(translate(quarterPos, 1), 0.5); corner = subtract(corner, rectangle(position, 1.2)); float diamond = rectangle(rotate(position, 0.125), .5); float world = merge(bounds, corner); world = merge(world, diamond); return world; } #define STARTDISTANCE 0.00001 #define MINSTEPDIST 0.02 #define SAMPLES 32 float traceShadows(float2 position, float2 lightPosition, float hardness){ float2 direction = normalize(lightPosition - position); float lightDistance = length(lightPosition - position); float lightSceneDistance = scene(lightPosition) * 0.8; float rayProgress = 0.0001; float shadow = 9999; for(int i=0 ;i&lt;SAMPLES; i++){ float sceneDist = scene(position + direction * rayProgress); if(sceneDist &lt;= 0){ return 0; } if(rayProgress &gt; lightDistance){ return saturate(shadow); } shadow = min(shadow, hardness * sceneDist / rayProgress); rayProgress = rayProgress + max(sceneDist, 0.02); } return 0; } fixed4 frag(v2f i) : SV_TARGET{ float2 position = i.worldPos.xz; float2 lightPos1 = float2(sin(_Time.y), -1); float shadows1 = traceShadows(position, lightPos1, 20); float3 light1 = shadows1 * float3(.6, .6, 1); float2 lightPos2 = float2(-sin(_Time.y) * 1.75, 1.75); float shadows2 = traceShadows(position, lightPos2, 10); float3 light2 = shadows2 * float3(1, .6, .6); float sceneDistance = scene(position); float distanceChange = fwidth(sceneDistance) * 0.5; float binaryScene = smoothstep(distanceChange, -distanceChange, sceneDistance); float3 geometry = binaryScene * float3(0, 0.3, 0.1); float3 col = geometry + light1 + light2; return float4(col, 1); } ENDCG } } FallBack "Standard" }</span></span></code> </pre> <br>  هذا مجرد مثال على العديد من الأمثلة لاستخدام حقول المسافات الموقعة.  حتى الآن تكون مرهقة إلى حد ما ، لأنه يجب تسجيل جميع الأشكال في التظليل أو تمريرها عبر خصائص التظليل ، لكن لدي بعض الأفكار حول كيفية جعلها أكثر ملاءمة للدروس التعليمية المستقبلية. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar438942/">https://habr.com/ru/post/ar438942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar438930/index.html">تغيّر السلطات بشكل أساسي استراتيجية التحكم في الإنترنت</a></li>
<li><a href="../ar438932/index.html">التعرف على الأنماط في الذكاء الاصطناعي الإيقاعي</a></li>
<li><a href="../ar438934/index.html">إنشاء وتكوين البنية المحمولة من Jupyter Notebook و Lab على Windows. الجزء 1</a></li>
<li><a href="../ar438936/index.html">علم بوتمان</a></li>
<li><a href="../ar438940/index.html">دورة مفتوحة "التعلم العميق على الأصابع"</a></li>
<li><a href="../ar438946/index.html">DateTimeOffset (صارم)</a></li>
<li><a href="../ar438948/index.html">لماذا نحتاج إلى تحسين المستوى المنخفض على Elbrus أو كيفية تسريع نظام التعرف مرة واحدة ونصف</a></li>
<li><a href="../ar438950/index.html">أطلق البنك المركزي روبوتًا للبحث عن برامج الكسب على الإنترنت</a></li>
<li><a href="../ar438952/index.html">ما يمكنك تعلمه عند تطوير مشغل صوت لمتصفحات مختلفة</a></li>
<li><a href="../ar438954/index.html">الجمع بين الحقول مسافة موقعة في 2D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>