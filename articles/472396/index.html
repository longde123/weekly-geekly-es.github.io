<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüíª üê• üèä La vuelta al mundo en 4 segundos en Columnstore (Parte 1) üë©üèΩ‚Äçüîß ü§∞üèæ üë®üèª‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, voy a considerar aumentar la velocidad de los informes. Por informe, me refiero a cualquier consulta a una base de datos que utiliza...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La vuelta al mundo en 4 segundos en Columnstore (Parte 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472396/">  En este art√≠culo, voy a considerar aumentar la velocidad de los informes.  Por informe, me refiero a cualquier consulta a una base de datos que utiliza funciones agregadas.  Adem√°s, voy a tocar temas relacionados con los recursos gastados en la producci√≥n y el soporte de informes, tanto humanos como mec√°nicos. <br><br>  En los ejemplos, usar√© un conjunto de datos que contiene 52,608,000 registros. <br><br>  Utilizando el ejemplo de reservas anal√≠ticas no dif√≠ciles, demostrar√© que incluso una computadora d√©bil puede convertirse en una buena herramienta para analizar una cantidad de datos ‚Äúdecente‚Äù sin mucho esfuerzo. <br><br>  Despu√©s de configurar experimentos no complicados, veremos que una tabla regular no es una fuente adecuada para consultas anal√≠ticas. <br><br>  Si el lector puede descifrar f√°cilmente las abreviaturas OLTP y OLAP, puede tener sentido ir directamente a la secci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Columnstore</a> <br><br><h4>  Dos enfoques para trabajar con datos </h4> <br>  Aqu√≠ voy a ser breve, porque  Hay m√°s que suficiente informaci√≥n sobre este tema en Internet. <br><br>  Entonces, en el nivel m√°s alto, solo hay dos enfoques para trabajar con datos: OLTP y OLAP. <br><br>  OLTP: se puede traducir como procesamiento de transacciones instant√°neas.  De hecho, estamos hablando del procesamiento en l√≠nea de transacciones cortas que funcionan con una peque√±a cantidad de datos.  Por ejemplo, grabar, actualizar o eliminar un pedido.  En la gran mayor√≠a de los casos, un pedido es una cantidad extremadamente peque√±a de datos, durante el procesamiento del cual no puede temer los largos bloqueos impuestos por el RDBMS moderno. <br><br>  OLAP: se puede traducir como procesamiento anal√≠tico de una gran cantidad de transacciones a la vez.  Cualquier informe utiliza este enfoque particular, porque en la gran mayor√≠a de los casos, el informe produce cifras resumidas y agregadas para ciertas secciones. <br><a name="habracut"></a><br>  Cada enfoque tiene su propia tecnolog√≠a.  Por ejemplo, para OLTP es PostgreSQL, y para OLAP es Microsoft SQL Server Analysis Services.  Si bien PostgresSQL utiliza un formato conocido para almacenar datos en tablas, se inventaron varios formatos diferentes para OLAP.  Estas son tablas multidimensionales, cubos llenos de pares clave-valor y mi almac√©n de columnas favorito.  Sobre este √∫ltimo con m√°s detalle a continuaci√≥n. <br><br><h4>  ¬øPor qu√© se necesitan dos enfoques? </h4><br>  Se observ√≥ que cualquier almac√©n de datos tarde o temprano enfrenta dos tipos de carga: lectura frecuente (escritura y actualizaci√≥n, por supuesto, tambi√©n) de cantidades extremadamente peque√±as de datos y lectura rara, pero cantidades muy grandes de datos.  De hecho, esta es una actividad, por ejemplo, de la taquilla y el jefe.  La caja, que funciona todo el d√≠a, llena el almacenamiento con peque√±os fragmentos de datos, mientras que al final del d√≠a el volumen acumulado, si el negocio va bien, alcanza un tama√±o impresionante.  A su vez, el gerente al final del d√≠a quiere saber cu√°nto dinero gana la taquilla por d√≠a. <br><br>  Entonces, en OLTP tenemos tablas e √≠ndices.  Estas dos herramientas son excelentes para registrar la actividad de taquilla con todos los detalles.  Los √≠ndices proporcionan una b√∫squeda r√°pida de un pedido previamente registrado, por lo que cambiar un pedido es f√°cil.  Pero para satisfacer las necesidades del l√≠der, debemos considerar la cantidad total de datos acumulados por d√≠a.  Adem√°s, como regla general, el gerente no necesita todos los detalles de todos los pedidos.  Lo que realmente necesita saber es cu√°nto dinero gan√≥ la taquilla en general.  No importa d√≥nde estaba la taquilla, cu√°ndo hab√≠a un descanso para almorzar, qui√©n trabajaba para ello, etc.  OLAP existe entonces, de modo que en un corto per√≠odo de tiempo el sistema puede responder la pregunta: cu√°nto ha ganado la compa√±√≠a en su conjunto sin una lectura secuencial de cada pedido y todos sus detalles.  ¬øPuede OLAP usar las mismas tablas e √≠ndices que OLTP?  La respuesta es no, al menos no deber√≠a.  En primer lugar, porque OLAP simplemente no necesita todos los detalles registrados en las tablas.  Este problema se resuelve almacenando datos en otros formatos que no sean tablas bidimensionales.  En segundo lugar, la informaci√≥n analizada a menudo se encuentra dispersa en diferentes tablas, lo que implica sus m√∫ltiples asociaciones, incluidas las asociaciones del tipo autouni√≥n.  Para resolver este problema, como regla general, desarrollan un esquema de base de datos especial.  Este esquema est√° optimizado para la carga OLAP, as√≠ como el esquema normalizado normal para la carga OLTP. <br><br><h4>  ¬øQu√© sucede cuando OLAP usa un esquema OLTP? </h4><br>  De hecho, present√© esta secci√≥n para que este art√≠culo cumpla claramente mis propios requisitos para el formato de dicho material, es decir.  problema, soluci√≥n, conclusi√≥n. <br><br>  Enumeramos una serie de desventajas del uso de esquemas OLTP para el an√°lisis de datos. <br><br><ul><li>  Demasiados √≠ndices <br><br>  <i>A menudo, debe crear √≠ndices especiales para admitir informes.</i>  <i>Estos √≠ndices implementan un esquema de almacenamiento de datos OLAP.</i>  <i>No son utilizados por la parte OLTP de la aplicaci√≥n, mientras ejercen una carga sobre ella, lo que requiere soporte constante y ocupa espacio en disco.</i> </li><li>  La cantidad de datos le√≠dos excede la requerida. </li><li>  Falta de un esquema de datos claro. <br><br>  <i>El hecho es que a menudo la informaci√≥n presentada por los informes en un solo formulario se distribuye en diferentes tablas.</i>  <i>Dicha informaci√≥n requiere una transformaci√≥n constante sobre la marcha.</i>  <i>El ejemplo m√°s simple es la cantidad de ingresos, que consiste en dinero en efectivo y no en efectivo.</i>  <i>Otro ejemplo sorprendente son las jerarqu√≠as de datos.</i>  <i>Porque</i>  <i>El desarrollo de aplicaciones es progresivo y no siempre se sabe lo que se necesitar√° en el futuro, la misma jerarqu√≠a de significado se puede almacenar en diferentes tablas.</i>  <i>Y aunque la adquisici√≥n sobre la marcha se usa activamente en OLAP, estas son cosas ligeramente diferentes.</i> </li><li>  Excesiva complejidad de consultas. <br><br>  <i>Porque</i>  <i>Un esquema OLTP difiere de un OLAP. Se necesita una capa de software fuertemente relacionada que lleve el esquema de datos OLTP a la forma correcta.</i> </li><li>  Complejidad de soporte, depuraci√≥n y desarrollo. <br><br>  <i>En general, podemos decir que cuanto m√°s complejo es el c√≥digo base, m√°s dif√≠cil es mantenerlo en buen estado.</i>  <i>Este es un axioma.</i> </li><li>  La complejidad de la cobertura de prueba. <br><br>  <i>Muchas copias se rompen debido a discusiones sobre c√≥mo obtener una base de datos llena de todos los scripts de prueba, pero es mejor decir que tener un esquema de datos m√°s simple la tarea de cubrir con pruebas se simplifica muchas veces.</i> </li><li>  Depuraci√≥n de rendimiento sin fin. <br><br>  <i>Existe una alta probabilidad de que el usuario solicite un informe que sea "pesado" para el servidor de la base de datos.</i>  <i>Esta probabilidad aumenta con el tiempo.</i>  <i>Cabe se√±alar que OLAP tambi√©n es propenso a este problema, pero a diferencia de OLTP, el recurso OLAP en este asunto es mucho mayor.</i> </li></ul><br> <b><a name="cs"></a></b>  <b>Almac√©n de columnas</b> <br><br>  Este art√≠culo se centrar√° en el formato de almacenamiento del almac√©n de columnas, pero sin detalles de bajo nivel.  Otros formatos mencionados anteriormente tambi√©n merecen atenci√≥n, pero este es un tema para otro art√≠culo. <br><br>  En realidad, el formato del almac√©n de columnas se conoce desde hace 30 a√±os, pero no se implement√≥ en el RDBMS hasta hace poco.  La esencia del almac√©n de columnas es que los datos se almacenan no en filas, sino en columnas.  Es decir  en una p√°gina (todos conocidos de 8 Kb) el servidor registra datos de un solo campo.  Y as√≠ con cada campo en la tabla a su vez.  Esto es necesario para que no tenga que leer informaci√≥n adicional.  Imaginemos una tabla con 10 campos y una consulta que solo tiene un campo especificado en la instrucci√≥n SELECT.  Si se tratara de una tabla normal guardada en un formato basado en filas, el servidor se ver√≠a obligado a leer los 10 campos, pero al mismo tiempo devolver√≠a solo uno.  Result√≥ que el servidor ley√≥ 9 veces m√°s informaci√≥n de la necesaria.  Columnstore resuelve completamente este problema, porque  El formato de almacenamiento le permite leer solo un campo ordenado.  Todo esto sucede porque la unidad de almacenamiento en un RDBMS es una p√°gina.  Es decir  el servidor siempre escribe y lee al menos una p√°gina.  La √∫nica pregunta es cu√°ntos campos est√°n presentes en √©l. <br><br><h4>  C√≥mo Columnstore realmente puede ayudar </h4><br>  Para responder a esto uno debe tener n√∫meros exactos.  Vamos por ellos.  Pero, ¬øqu√© n√∫meros pueden dar una imagen precisa? <br><br><ol><li>  La cantidad de espacio en disco. </li><li>  Consulta de rendimiento. </li><li>  Tolerancia a fallas. </li><li>  Facilidad de implementaci√≥n. </li><li>  ¬øQu√© nuevas habilidades debe tener un desarrollador para trabajar con nuevas estructuras? </li></ol><br><h4>  Espacio en disco </h4><br>  Creemos una tabla simple, compl√©tela con datos y verifiquemos cu√°nto espacio ocupa. <br><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> cstore_table ( trd <span class="hljs-type"><span class="hljs-type">date</span></span>, org <span class="hljs-type"><span class="hljs-type">int</span></span>, op <span class="hljs-type"><span class="hljs-type">int</span></span>, it <span class="hljs-type"><span class="hljs-type">int</span></span>, wh <span class="hljs-type"><span class="hljs-type">int</span></span>, m1 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m2 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m3 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m4 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m5 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> cstore_server <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>(compression <span class="hljs-string"><span class="hljs-string">'pglz'</span></span>);</code> </pre> <br>  Como notaron, cre√© una tabla externa.  El hecho es que PostgreSQL no tiene soporte de almac√©n de columnas incorporado.  Pero PostgreSQL tiene un poderoso sistema para extensiones.  Uno de ellos hace posible crear tablas de almac√©n de columnas.  Enlaces al final del art√≠culo. <br><br><ul><li>  pglz: le dice a la extensi√≥n que los datos deben comprimirse utilizando el algoritmo incorporado en PostgreSQL; </li><li>  trd - tiempo de transacci√≥n; </li><li>  op, it, wh - secciones anal√≠ticas o medidas; </li><li>  m1, m2, m3, m4, m5 - indicadores num√©ricos o medidas; </li></ul><br>  Insertemos una cantidad "decente" de datos y veamos cu√°nto espacio ocupa en el disco.  Al mismo tiempo, verificamos el rendimiento del inserto.  Porque  Puse mis experimentos en una computadora port√°til hogare√±a, soy un poco org√°nico en la cantidad de datos.  Adem√°s, lo cual es incluso bueno, usar√© el HDD con el sistema operativo invitado Fedora 30. Host del sistema operativo - Windows 10 Home Edition.  Procesador Intel Core 7. El sistema operativo invitado recibi√≥ 4 GB de RAM.  Versi√≥n PostgreSQL: PostgreSQL 10.10 en x86_64-pc-linux-gnu, compilado por gcc (GCC) 9.1.1 20190503 (Red Hat 9.1.1-1), 64 bits.  Experimentar√© con un conjunto de datos con el n√∫mero de registros 52 608 000. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> cstore_table <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span> + make_interval(days =&gt; d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> trd , op , org , wh , it , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m1 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m2 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m3 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m4 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> org <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wh <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1095</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d;</code> </pre> <br>  El plan de implementaci√≥n ser√° el siguiente <br><blockquote>  Insertar en cstore_table (costo = 0.01..24902714242540.01 filas = 1000000000000000 ancho = 150) (tiempo real = 119560.456..119560.456 filas = 0 bucles = 1) <br>  ----&gt; Bucle anidado (costo = 0.01..24902714242540.01 filas = 1000000000000000 ancho = 150) (tiempo real = 1.823..22339.976 filas = 52608000 bucles = 1) <br>  ----------&gt; Funci√≥n de escaneo en generate_series d (costo = 0.00..10.00 filas = 1000 ancho = 4) (tiempo real = 0.151..2.198 filas = 1096 bucles = 1) <br>  ----------&gt; Materializar (costo = 0.01..27284555030.01 filas = 1000000000000 ancho = 16) (tiempo real = 0.002..3.196 filas = 48000 bucles = 1096) <br>  ----------------&gt; Bucle anidado (costo = 0.01..17401742530.01 filas = 1000000000000 ancho = 16) (tiempo real = 1.461..15.072 filas = 48000 bucles = 1) <br>  ----------------------&gt; Funci√≥n Escanear en generate_series it (costo = 0.00..10.00 filas = 1000 ancho = 4) (tiempo real = 1.159..2.007 filas = 4000 bucles = 1) <br>  ----------------------&gt; Materializar (costo = 0.01..26312333.01 filas = 1,000,000,000 ancho = 12) (tiempo real = 0.000..0.001 filas = 12 bucles = 4000) <br>  ----------------------------&gt; Bucle anidado (costo = 0.01..16429520.01 filas = 1,000,000,000 ancho = 12) (tiempo real = 0.257 ..0.485 filas = 12 bucles = 1) <br>  ----------------------------------&gt; Funci√≥n de escaneo en generate_series wh (costo = 0.00..10.00 filas = 1000 ancho = 4) (tiempo real = 0.046..0.049 filas = 3 bucles = 1) <br>  ----------------------------------&gt; Materializar (costo = 0.01..28917.01 filas = 1,000,000 de ancho = 8) (tiempo real = 0.070..0.139 filas = 4 bucles = 3) <br>  ---------------------------------------&gt; Bucle anidado (costo = 0.01..20010.01 filas = 1000000 ancho = 8) (tiempo real = 0.173..0.366 filas = 4 bucles = 1) <br>  -------------------------------------------&gt; Funci√≥n de escaneo en generate_series op ( costo = 0.00..10.00 filas = 1000 ancho = 4) (tiempo real = 0.076..0.079 filas = 2 bucles = 1) <br>  ---------------------------------------------&gt; Exploraci√≥n de funciones en generate_series org (costo = 0.00..10.00 filas = 1000 ancho = 4) (tiempo real = 0.043..0.047 filas = 2 bucles = 2) <br>  Tiempo de planificaci√≥n: 0.439 ms <br>  Tiempo de ejecuci√≥n: 119692.051 ms </blockquote>  Tiempo de entrega total: 1.994867517 minutos <br><br>  Tiempo de creaci√≥n del conjunto de datos: 22.339976 segundos <br><br>  Tiempo de inserci√≥n - 1.620341333 minutos <br><br>  No logr√© evaluar el espacio en disco ocupado usando las funciones de PostgreSQL.  No estoy seguro de por qu√©, pero muestra 0. Quiz√°s este sea el comportamiento est√°ndar para tablas externas.  Utilizado para este administrador de archivos.  Entonces, el volumen de espacio en disco ocupado es 226.2 Mb.  Para evaluar mucho o poco, compar√©moslo con una tabla normal. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> rbstore_table <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span> + make_interval(days =&gt; d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> trd , op , org , wh , it , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m1 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m2 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m3 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m4 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> org <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wh <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1095</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d;</code> </pre> <br>  El plan de implementaci√≥n ser√° el siguiente <br><blockquote>  Bucle anidado (costo = 0.01..22402714242540.01 filas = 1000000000000000 ancho = 44) (tiempo real = 0.585..23781.942 filas = 52608000 bucles = 1) <br>  ---&gt; An√°lisis de funci√≥n en generate_series d (costo = 0.00..10.00 filas = 1000 ancho = 4) (tiempo real = 0.091..2.130 filas = 1096 bucles = 1) <br>  ---&gt; Materializar (costo = 0.01..27284555030.01 filas = 1000000000000 ancho = 16) (tiempo real = 0.001..3.574 filas = 48000 bucles = 1096) <br>  ----------&gt; Bucle anidado (costo = 0.01..17401742530.01 filas = 1000000000000 ancho = 16) (tiempo real = 0.489..14.044 filas = 48000 bucles = 1) <br>  ----------------&gt; Funci√≥n Escanear en generate_series it (costo = 0.00..10.00 filas = 1000 ancho = 4) (tiempo real = 0.477..1.352 filas = 4000 bucles = 1 ) <br>  ----------------&gt; Materializar (costo = 0.01..26312333.01 filas = 1000000000 ancho = 12) (tiempo real = 0.000..0.001 filas = 12 bucles = 4000) <br>  ----------------------&gt; Bucle anidado (costo = 0.01..16429520.01 filas = 1,000,000,000 ancho = 12) (tiempo real = 0.010..0.019 filas = 12 bucles = 1) <br>  ----------------------------&gt; Funci√≥n de escaneo en generate_series wh (costo = 0.00..10.00 filas = 1000 ancho = 4) (real tiempo = 0.003..0.003 filas = 3 bucles = 1) <br>  ----------------------------&gt; Materializar (costo = 0.01..28917.01 filas = 1,000,000 de ancho = 8) (tiempo real = 0.002. .0.004 filas = 4 bucles = 3) <br>  ----------------------------------&gt; Bucle anidado (costo = 0.01..20010.01 filas = 1,000,000 de ancho = 8 ) (tiempo real = 0.006..0.009 filas = 4 bucles = 1) <br>  ----------------------------------------&gt; An√°lisis de funciones en generate_series op (costo = 0.00 ..10.00 filas = 1000 ancho = 4) (tiempo real = 0.002..0.002 filas = 2 bucles = 1) <br>  ----------------------------------------&gt; An√°lisis de funciones en la organizaci√≥n generate_series (costo = 0.00 ..10.00 filas = 1000 ancho = 4) (tiempo real = 0.001..0.001 filas = 2 bucles = 2) <br>  Tiempo de planificaci√≥n: 0.569 ms <br>  Tiempo de ejecuci√≥n: 378883.989 ms </blockquote>  El tiempo dedicado a la implementaci√≥n de este plan no nos interesa, porque  en la vida real, no se supone que tales inserciones.  Nos interesa cu√°nto espacio en disco ocupa esta tabla.  Una vez cumplida la solicitud de funciones del sistema, recib√≠ 3.75 GB. <br><br>  Entonces, cstore_table - 226 MB, rbstore_table - 3.75 GB.  La diferencia de 16,99 veces es sorprendente, pero es poco probable que se pueda obtener la misma diferencia en la producci√≥n, principalmente debido a la distribuci√≥n de datos.  Como regla general, esta diferencia ser√° menor y ser√° aproximadamente 5 veces. <br><br>  Pero espere, nadie usa datos sin procesar en un formato basado en filas para fines de an√°lisis.  Por ejemplo, intentan usar datos indexados para generar informes.  Y porque  Los datos "sin procesar" siempre ser√°n, debe comparar los tama√±os con los tama√±os de los √≠ndices.  Creemos al menos un √≠ndice.  Sea un √≠ndice en el campo de fecha y tipo de operaci√≥n: trd + op. <br><br>  Entonces, index√© solo dos campos, y el √≠ndice tom√≥ 1583 MB, que es mucho m√°s que cstore_table.  Pero, como regla, se requiere m√°s de un √≠ndice para la carga OLAP.  Ser√° apropiado se√±alar aqu√≠ que cstore_table no necesita indexaci√≥n adicional.  Esta tabla act√∫a como un √≠ndice que cubre cualquier consulta. <br><br>  De todo lo anterior, se puede llegar a una conclusi√≥n simple: al usar tablas de almac√©n de columnas, puede reducir la cantidad de espacio en disco utilizado. <br><br><h4>  Query Performance </h4><br>  Para evaluar el rendimiento, ejecutemos una consulta que devuelva datos de resumen de un mes espec√≠fico para un tipo espec√≠fico de operaci√≥n. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cstore_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd = <span class="hljs-string"><span class="hljs-string">'2011-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  El plan de implementaci√≥n ser√° el siguiente <br><blockquote>  Agregado (costo = 793602.69..793602.70 filas = 1 ancho = 32) (tiempo real = 79.708..79.708 filas = 1 bucles = 1) <br>  --Buffers: golpe compartido = 44226 <br>  ---&gt; An√°lisis externo en cstore_table (costo = 0.00..793544.70 filas = 23197 ancho = 5) (tiempo real = 23.209..76.628 filas = 24000 bucles = 1) <br>  -------- Filtro: ((trd = '2011-01-01' :: fecha) Y (op = 1)) <br>  -------- Filas eliminadas por filtro: 26000 <br>  -------- CStore File: / var / lib / pgsql / 10 / data / cstore_fdw / 14028/16417 <br>  -------- Tama√±o del archivo CStore: 120818897 <br>  -------- Buffers: hit compartido = 44226 <br>  Tiempo de planificaci√≥n: 0.165 ms <br>  Tiempo de ejecuci√≥n: 79.887 ms </blockquote>  Y <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rbstore_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd = <span class="hljs-string"><span class="hljs-string">'2011-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  El plan de implementaci√≥n ser√° el siguiente <br><blockquote>  Agregado (costo = 40053.80..40053.81 filas = 1 ancho = 8) (tiempo real = 389.183..389.183 filas = 1 bucles = 1) <br>  --Buffers: lectura compartida = 545 <br>  ---&gt; Index Scan usando trd_op_ix en rbstore_table (costo = 0.56..39996.70 filas = 22841 ancho = 4) (tiempo real = 55.955..385.283 filas = 24000 bucles = 1) <br>  -------- √çndice Cond: ((trd = '2011-01-01 00:00:00' :: marca de tiempo sin zona horaria) Y (op = 1)) <br>  -------- Buffers: lectura compartida = 545 <br>  Tiempo de planificaci√≥n: 112.175 ms <br>  Tiempo de ejecuci√≥n: 389.219 ms </blockquote>  389.219 ms frente a 79.887 ms.  Aqu√≠ vemos que incluso en una cantidad relativamente peque√±a de datos del almac√©n de columnas, una tabla es significativamente m√°s r√°pida que un √≠ndice en una tabla basada en filas. <br><br>  Cambiemos la solicitud e intentemos obtener la unidad para todo 2011. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cstore_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-string"><span class="hljs-string">'2011-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'2011-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  El plan de implementaci√≥n ser√° el siguiente <br><blockquote>  Agregado (costo = 946625.58..946625.59 filas = 1 ancho = 32) (tiempo real = 3123.604..3123.604 filas = 1 bucles = 1) <br>  --Buffers: golpe compartido = 44226 <br>  ---&gt; An√°lisis externo en cstore_table (costo = 0.00..925064.70 filas = 8624349 ancho = 5) (tiempo real = 21.728..2100.665 filas = 8760000 bucles = 1) <br>  -------- Filtro: ((trd&gt; = '2011-01-01' :: fecha) AND (trd &lt;= '2011-12-31' :: fecha) AND (op = 1)) <br>  -------- Filas eliminadas por filtro: 8760000 <br>  -------- CStore File: / var / lib / pgsql / 10 / data / cstore_fdw / 14028/16411 <br>  -------- Tama√±o del archivo CStore: 120818897 <br>  -------- Buffers: hit compartido = 44226 <br>  Tiempo de planificaci√≥n: 0.212 ms <br>  Tiempo de ejecuci√≥n: 3123.960 ms </blockquote>  Y <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rbstore_table <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-string"><span class="hljs-string">'2011-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'2011-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  El plan de implementaci√≥n ser√° el siguiente <br><blockquote>  Finalizar agregado (costo = 885214.33..885214.34 filas = 1 ancho = 8) (tiempo real = 98512.560..98512.560 filas = 1 bucles = 1) <br>  --Buffers: hit compartido = 2565 read = 489099 <br>  ---&gt; Reunir (costo = 885214.12..885214.33 filas = 2 ancho = 8) (tiempo real = 98427.034..98523.194 filas = 3 bucles = 1) <br>  -------- Trabajadores previstos: 2 <br>  -------- Trabajadores lanzados: 2 <br>  -------- Buffers: hit compartido = 2565 read = 489099 <br>  ---------&gt; Agregado parcial (costo = 884214.12..884214.13 filas = 1 ancho = 8) (tiempo real = 97907.608..97907.608 filas = 1 bucles = 3) <br>  -------------- Buffers: hit compartido = 2565 read = 489099 <br>  ---------------&gt; An√°lisis paralelo paralelo en rbstore_table (costo = 0.00..875264.00 filas = 3580047 ancho = 4) (tiempo real = 40820.004..97405.250 filas = 2920000 bucles = 3) <br>  --------------------- Filtro: ((trd&gt; = '2011-01-01 00:00:00' :: marca de tiempo sin zona horaria) AND (trd &lt;= '2011-12-31 00:00:00' :: marca de tiempo sin zona horaria) Y (op = 1)) <br>  -------------------- Filas eliminadas por filtro: 14616000 <br>  -------------------- Buffers: hit compartido = 2565 read = 489099 <br>  Tiempo de planificaci√≥n: 7.899 ms <br>  Tiempo de ejecuci√≥n: 98523.278 ms </blockquote>  98523,278 ms frente a 3123,960 ms.  Quiz√°s un √≠ndice parcial nos ayudar√≠a, pero es mejor no arriesgarlo y crear una estructura adecuada basada en filas en la que se almacenen los valores listos para usar. <br><br><h4>  Agregados manuales </h4><br>  Una estructura adecuada para los agregados manuales podr√≠a ser una tabla regular basada en filas que contenga valores calculados previamente.  Por ejemplo, puede contener un registro relacionado con 2011 con el tipo de operaci√≥n igual a 1, mientras que en los campos m1, m2, m3, m4 y m5 el valor agregado se almacenar√° precisamente para estas secciones anal√≠ticas.  Por lo tanto, al tener un conjunto suficiente de agregados e √≠ndices, las consultas anal√≠ticas adquieren un rendimiento sin precedentes.  Curiosamente, Microsoft SQL Server Analysis Services tiene un asistente especial que le permite configurar el n√∫mero y la profundidad de los valores calculados previamente. <br><br>  Esta soluci√≥n tiene las siguientes ventajas: <br><br><ul><li>  An√°lisis en tiempo real. <br><br>  <i>No confunda el t√©rmino "an√°lisis en tiempo real".</i>  <i>Aqu√≠ estamos hablando del hecho de que el incremento de la unidad ocurre durante un per√≠odo de tiempo aceptable en la gran mayor√≠a de los casos.</i> <i><br><br></i>  <i>De hecho, esta ventaja es controvertida, pero no hablemos de eso.</i>  <i>El hecho permanece.</i>  <i>La arquitectura de la soluci√≥n es tal que las unidades permanecen "frescas" casi siempre.</i> </li><li>  Completa independencia del volumen de datos. <br><br>  <i>Esta es una ventaja muy seria.</i>  <i>No importa cu√°ntos datos se procesen, tarde o temprano se procesar√°n y se recibir√°n los agregados.</i> </li><li>  Complejidad relativa. <br><br>  <i>Para obtener un an√°lisis en tiempo real y la independencia del volumen de datos, la soluci√≥n debe utilizar tecnolog√≠as avanzadas como la gesti√≥n de subprocesos m√∫ltiples y manual en el nivel DBMS.</i> </li><li>  Prueba de dificultad. <br><br>  <i>Aqu√≠ estamos hablando de pruebas unitarias y pruebas manuales.</i>  <i>Creo que el lector no deber√≠a explicar que identificar errores de subprocesos m√∫ltiples no es una tarea f√°cil.</i> </li><li>  Mayores requisitos de espacio en disco. <br><br></li></ul><br><h4>  El uso real del almac√©n de columnas </h4><br>  Aqu√≠ debemos sumergirnos nuevamente en la teor√≠a y analizar la cuesti√≥n de qu√© son los datos anal√≠ticos con m√°s detalle. <br><br>  Tome el jefe promedio de la empresa.  Como regla, le preocupan dos preguntas globales: "¬øC√≥mo van las cosas en este momento?"  y "¬øQu√© ha cambiado √∫ltimamente?". <br><br>  Para responder la pregunta ‚Äú¬øC√≥mo van las cosas en este momento?‚Äù, Absolutamente no necesitamos datos hist√≥ricos.  Es decir  no importa c√≥mo fueron las cosas hace un mes. <br><br>  Para mantenerse al tanto del pulso, a menudo se hace la pregunta.  Este tipo de an√°lisis de datos se llama operativo. <br><br>  Para responder la pregunta "¬øQu√© ha cambiado √∫ltimamente?", Necesitamos datos hist√≥ricos precisos.  Adem√°s, como regla, el an√°lisis se realiza en los mismos intervalos de tiempo.  Por ejemplo, un mes se compara con un mes, a√±o tras a√±o, etc.  Por supuesto, el sistema no debe limitar al usuario la capacidad de comparar per√≠odos arbitrarios, pero dicho caso debe reconocerse como raro, porque  comparar un a√±o cerrado con un medio no cerrado tiene poco sentido.  Una caracter√≠stica distintiva del an√°lisis comparativo es que no se requiere con tanta frecuencia como operativo.  Llamaremos a este tipo de an√°lisis hist√≥rico. <br><br>  Obviamente, el an√°lisis operativo debe ocurrir r√°pidamente.  En consecuencia, impone altas exigencias al rendimiento.  Mientras que para el an√°lisis hist√≥rico, tales requisitos no pueden presentarse.  Aunque el desempe√±o del an√°lisis hist√≥rico debe permanecer en un nivel muy alto.  Al menos para que el sistema de an√°lisis en s√≠ siga siendo competitivo. <br><br>  Entonces, de acuerdo con dos tipos de an√°lisis, podemos distinguir dos tipos de datos anal√≠ticos: datos operativos e hist√≥ricos.  Desde el lado del usuario, no debe notarse con qu√© datos particulares est√° trabajando en este momento. <br><br>  Es a partir de estas consideraciones que en los servidores de bases de datos ha surgido la posibilidad de dividir las tablas en secciones separadas. <br><br>  Con respecto al almac√©n de columnas, es posible mezclar secciones en formatos basados ‚Äã‚Äãen filas y en columnas.  Se sabe que los datos del an√°lisis operativo est√°n sujetos a cambios frecuentes, lo que impide su almacenamiento en formato de almac√©n de columnas.  Y dado el hecho de que los datos operativos no suceden demasiado, se pueden almacenar en formato basado en filas. <br><br>  Los datos hist√≥ricos no cambian.  Hay muchos de estos datos y, por lo tanto, el formato de almac√©n de columnas les queda mejor.  Recuerde que el rendimiento de las consultas en negrita en una fuente de almac√©n de columnas es mayor que en una fuente basada en filas. <br><br>  Veamos un ejemplo de todo lo anterior. <br><br>  A continuaci√≥n, creo la tabla principal del almac√©n y le adjunto las secciones de an√°lisis operativo e hist√≥rico. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> warehouse ( trd <span class="hljs-type"><span class="hljs-type">date</span></span>, org <span class="hljs-type"><span class="hljs-type">int</span></span>, op <span class="hljs-type"><span class="hljs-type">int</span></span>, it <span class="hljs-type"><span class="hljs-type">int</span></span>, wh <span class="hljs-type"><span class="hljs-type">int</span></span>, m1 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m2 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m3 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m4 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m5 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">partition by range</span></span>(trd); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">foreign</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> historycal_data ( trd <span class="hljs-type"><span class="hljs-type">date</span></span>, org <span class="hljs-type"><span class="hljs-type">int</span></span>, op <span class="hljs-type"><span class="hljs-type">int</span></span>, it <span class="hljs-type"><span class="hljs-type">int</span></span>, wh <span class="hljs-type"><span class="hljs-type">int</span></span>, m1 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m2 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m3 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m4 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), m5 <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> cstore_server <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>(compression <span class="hljs-string"><span class="hljs-string">'pglz'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> historycal_data <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span> + make_interval(days =&gt; d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> trd , op , org , wh , it , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m1 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m2 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m3 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m4 , <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> org <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wh <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-number"><span class="hljs-number">1095</span></span> - <span class="hljs-number"><span class="hljs-number">31</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> historycal_data; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> operational_data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> (<span class="hljs-string"><span class="hljs-string">'2012-12-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span> + make_interval(days =&gt; d))::<span class="hljs-type"><span class="hljs-type">date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> trd , op , org , wh , it , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m1 , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m2 , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m3 , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m4 , <span class="hljs-number"><span class="hljs-number">100</span></span>::<span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> m5 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> org <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wh <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> trd_op_ix <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> operational_data (trd, op); <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> operational_data; <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> warehouse <span class="hljs-keyword"><span class="hljs-keyword">attach partition</span></span> operational_data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-string"><span class="hljs-string">'2012-12-01'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> (<span class="hljs-string"><span class="hljs-string">'2112-01-01'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> warehouse <span class="hljs-keyword"><span class="hljs-keyword">attach partition</span></span> historycal_data <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-string"><span class="hljs-string">'2010-01-01'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> (<span class="hljs-string"><span class="hljs-string">'2012-12-01'</span></span>);</code> </pre> <br>  Todo esta listo.  Intentemos ordenar un par de informes.  Comencemos ordenando datos para un d√≠a del mes actual. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> warehouse <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd = <span class="hljs-string"><span class="hljs-string">'2012-12-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><blockquote>  Agregado (costo = 15203.37..15203.38 filas = 1 ancho = 32) (tiempo real = 17.320..17.320 filas = 1 bucles = 1) <br>  --Buffers: golpe compartido = 3 lecturas = 515 <br>  ---&gt; Agregar (costo = 532.59..15140.89 filas = 24991 ancho = 5) (tiempo real = 1.924..13.838 filas = 24000 bucles = 1) <br>  ------- Buffers: hit compartido = 3 lecturas = 515 <br>  ---------&gt; Bitmap Heap Scan en datos_operativos (costo = 532.59..15140.89 filas = 24991 ancho = 5) (tiempo real = 1.924..11.992 filas = 24000 bucles = 1) <br>  --------------- Vuelva a verificar Cond: ((trd = '2012-12-01' :: date) AND (op = 1)) <br>  --------------- Bloques de mont√≥n: exactos = 449 <br>  --------------- Buffers: hit compartido = 3 lecturas = 515 <br>  ----------------&gt; Escaneo de √≠ndice de mapa de bits en trd_op_ix (costo = 0.00..526.34 filas = 24991 ancho = 0) (tiempo real = 1.877..1.877 filas = 24000 bucles = 1 ) <br>  --------------------- √çndice Cond: ((trd = '2012-12-01' :: fecha) Y (op = 1)) <br>  --------------------- Buffers: hit compartido = 2 lecturas = 67 <br>  Tiempo de planificaci√≥n: 0.388 ms <br>  Tiempo de ejecuci√≥n: 100.941 ms </blockquote>  Ahora ordenaremos datos para todo el 2012, en el que el n√∫mero de transacciones es de 8,784,000. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> warehouse <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> trd <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-string"><span class="hljs-string">'2012-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'2012-12-31'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> op = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><blockquote>  Agregado (costo = 960685.82..960685.83 filas = 1 ancho = 32) (tiempo real = 4124.681..4124.681 filas = 1 bucles = 1) <br>  --Buffers: hit compartido = 45591 read = 11282 <br>  ---&gt; Agregar (costo = 0.00..938846.60 filas = 8735687 ancho = 5) (tiempo real = 66.581..3036.394 filas = 8784000 bucles = 1) <br>  --------- Buffers: hit compartido = 45591 read = 11282 <br>  ----------&gt; An√°lisis externo en historycal_data (costo = 0.00..898899.60 filas = 7994117 ancho = 5) (tiempo real = 66.579..2193.801 filas = 8040000 bucles = 1) <br>  --------------- Filtro: ((trd&gt; = '2012-01-01' :: fecha) Y (trd &lt;= '2012-12-31' :: fecha) Y (op = 1)) <br>  --------------- Filas eliminadas por filtro: 8040000 <br>  --------------- Archivo CStore: / var / lib / pgsql / 10 / data / cstore_fdw / 14028/16448 <br>  --------------- Tama√±o del archivo CStore: 117401470 <br>  --------------- Buffers: hit compartido = 42966 <br>  ----------&gt; Seq Scan en datos_operativos (costo = 0.00..39947.00 filas = 741570 ancho = 5) (tiempo real = 0.019..284.824 filas = 744000 bucles = 1) <br>  --------------- Filtro: ((trd&gt; = '2012-01-01' :: fecha) Y (trd &lt;= '2012-12-31' :: fecha) Y (op = 1)) <br>  --------------- Filas eliminadas por filtro: 744000 <br>  --------------- Buffers: hit compartido = 2625 read = 11282 <br>  Tiempo de planificaci√≥n: 0.256 ms <br>  Tiempo de ejecuci√≥n: 4125.239 ms </blockquote>  Al final, veamos qu√© sucede si el usuario quiere, por ejemplo, sin intenci√≥n maliciosa, ordenar un informe sobre todas las transacciones en el sistema, de las cuales hay 52 608 000. <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">buffers</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sum(m1) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> warehouse</code> </pre> <br><blockquote>  Agregado (costo = 672940.20..672940.21 filas = 1 ancho = 32) (tiempo real = 15907.886..15907.886 filas = 1 bucles = 1) <br>  --Buffers: hit compartido = 17075 read = 11154 <br>  ---&gt; Agregar (costo = 0.00..541420.20 filas = 52608000 ancho = 5) (tiempo real = 0.192..9115.144 filas = 52608000 bucles = 1) <br>  --------- Buffers: hit compartido = 17075 read = 11154 <br>  ----------&gt; An√°lisis externo en historycal_data (costo = 0.00..512633.20 filas = 51120000 ancho = 5) (tiempo real = 0.191..5376.449 filas = 51120000 bucles = 1) <br>  --------------- Archivo CStore: / var / lib / pgsql / 10 / data / cstore_fdw / 14028/16448 <br>  --------------- Tama√±o del archivo CStore: 117401470 <br>  --------------- Buffers: hit compartido = 14322 <br>  ----------&gt; Seq Scan en datos_operativos (costo = 0.00..28787.00 filas = 1488000 ancho = 5) (tiempo real = 0.032..246.978 filas = 1488000 bucles = 1) <br>  --------------- Buffers: hit compartido = 2753 read = 11154 <br>  Tiempo de planificaci√≥n: 0.157 ms <br>  Tiempo de ejecuci√≥n: 15908.096 ms </blockquote>  Tenga en cuenta que todav√≠a estoy escribiendo mi art√≠culo, como si nada hubiera pasado.  Ni siquiera tuve que reiniciar mi port√°til no tan potente con HDD y 4 GB de RAM.  Aunque el tema del consumo de recursos requiere un estudio m√°s cuidadoso. <br><br><h4>  Tolerancia a fallos </h4><br>  En parte, la tolerancia a fallas se prob√≥ justo en el momento de escribir este art√≠culo.  Mi computadora port√°til est√° viva y, en general, no not√© ninguna desaceleraci√≥n en su trabajo, adem√°s de las habituales. <br><br>  Deje que el lector me perdone por el hecho de que no tuve tiempo para resolver el problema de la tolerancia a fallas en detalle, pero puedo decir que la extensi√≥n en cuesti√≥n tiene tolerancia a fallas: es posible realizar una copia de seguridad. <br><br><h4>  Facilidad de implementaci√≥n </h4><br>  Como resultado, al crear una tabla que almacena datos en un formato de almac√©n de columnas, no hay m√°s opciones que un algoritmo de compresi√≥n.  La compresi√≥n en s√≠ misma es absolutamente necesaria. <br><br>  El formato en s√≠ tiene una cierta estructura.  Al establecer los par√°metros apropiados, puede lograr una cierta aceleraci√≥n de las consultas anal√≠ticas o ajustar el grado de compresi√≥n de la informaci√≥n. <br><br>  Como se demostr√≥ anteriormente, crear una tabla de almac√©n de columnas no es una molestia en absoluto.  La extensi√≥n puede funcionar con 40 tipos de datos PostgreSQL.  Los seminarios web hablaron sobre todos los tipos compatibles con PostgreSQL. <br><br><h4>  ¬øQu√© nuevas habilidades debe tener un desarrollador para trabajar con nuevas estructuras? </h4><br>  El desarrollador de SQL no necesita ninguna habilidad especial para escribir consultas en las tablas del almac√©n de columnas.  Dicha tabla es visible en todas las consultas, como una tabla regular basada en filas.  Aunque esto no excluye la necesidad de optimizaci√≥n de consultas. <br><br><h4>  Conclusi√≥n </h4><br>  En este art√≠culo, mostr√© c√≥mo una tabla con un formato de almacenamiento de almac√©n de columnas puede ser √∫til.  Esto ahorra espacio en disco y consultas anal√≠ticas de alto rendimiento.  La facilidad de trabajar con la tabla reduce autom√°ticamente el costo de crear un almac√©n de datos anal√≠ticos completo, porque  Su uso no requiere el desarrollo de algoritmos complejos y dif√≠ciles de depurar.  La prueba se simplifica. <br><br>  A pesar del hecho de que los experimentos planteados anteriormente inspiran optimismo, muchos problemas no se han resuelto.  Por ejemplo, qu√© plan de consulta se generar√° cuando la tabla de almac√©n de columnas se una a otras tablas.  Espero continuar este trabajo en la pr√≥xima parte.  La cantidad de partes depender√° de c√≥mo se comporta cstore_fdw en datos m√°s o menos reales. <br><br><h4>  Enlaces a materiales adicionales </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Breve rese√±a cstore_fdw</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cstore_fdw en github</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hoja de ruta cstore_fdw</a> <br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472396/">https://habr.com/ru/post/472396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472384/index.html">Una mirada a las actualizaciones de Android desde la perspectiva de un desarrollador</a></li>
<li><a href="../472386/index.html">ZIO y Efecto Gatos: una alianza exitosa</a></li>
<li><a href="../472388/index.html">Walmart declara guerra de precios en Amazon</a></li>
<li><a href="../472392/index.html">El aumento, la ca√≠da y el posible regreso de los casetes de audio: tratamos los mitos y damos una visi√≥n general de la situaci√≥n</a></li>
<li><a href="../472394/index.html">Evaluar el impacto de la inteligencia artificial en el petr√≥leo y el gas en alta mar</a></li>
<li><a href="../472402/index.html">Transmisi√≥n de videollamadas RTMP</a></li>
<li><a href="../472404/index.html">C√°lculo de colisi√≥n 2D: Algoritmo de Gilbert-Johnson-Kirti</a></li>
<li><a href="../472406/index.html">Ampliar el centro de datos durante la entrega de pizza</a></li>
<li><a href="../472410/index.html">Dise√±o de sistemas de color disponibles</a></li>
<li><a href="../472412/index.html">Analista de sistemas y m√©tricas de productos: ¬øagitar pero no mezclar?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>