<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéØ ü•ù üë©üèæ‚Äçüíª MVCC in PostgreSQL-8. Einfrieren üëÜ üëì ‚ùÑÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir begannen mit Problemen im Zusammenhang mit der Isolation , machten einen Exkurs √ºber das Organisieren von Daten auf niedriger Ebene und sprachen a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC in PostgreSQL-8. Einfrieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/455590/">  Wir begannen mit Problemen im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation</a> , machten einen Exkurs √ºber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Organisieren von Daten auf niedriger Ebene</a> und sprachen ausf√ºhrlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber Zeilenversionen</a> und wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Snapshots</a> aus Versionen erhalten werden. <br><br>  Dann untersuchten wir verschiedene Arten der Reinigung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intra-Page</a> (zusammen mit HOT-Updates), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">regelm√§√üig</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">automatisch</a> . <br><br>  Und bin zum letzten Thema dieses Zyklus gekommen.  Heute werden wir √ºber das Problem des Umlaufens und Einfrierens von Transaktions-IDs sprechen. <br><a name="habracut"></a><br><h1>  Transaktionsz√§hler√ºberlauf </h1><br>  PostgreSQL verf√ºgt √ºber 32 Bits f√ºr die Transaktionsnummer.  Dies ist eine ziemlich gro√üe Zahl (ungef√§hr 4 Milliarden), aber mit dem aktiven Betrieb des Servers kann es durchaus ersch√∂pft sein.  Bei einer Last von 1000 Transaktionen pro Sekunde geschieht dies beispielsweise nach nur anderthalb Monaten Dauerbetrieb. <br><br>  Wir haben jedoch dar√ºber gesprochen, dass der Multi-Versionierungsmechanismus auf der Reihenfolge der Nummerierung beruht. Von zwei Transaktionen kann eine Transaktion mit einer niedrigeren Nummer als fr√ºher gestartet betrachtet werden.  Daher ist es klar, dass Sie den Z√§hler nicht einfach zur√ºcksetzen und die Nummerierung erneut fortsetzen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/cn/om/rg/cnomrgflv1bnkqme9k68bit4ad0.png"><br><br>  Warum werden der Transaktionsnummer keine 64 Bit zugewiesen, da dies das Problem vollst√§ndig beseitigen w√ºrde?  Tatsache ist, dass (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits erw√§hnt</a> ) im Header jeder Version der Zeile zwei Transaktionsnummern gespeichert sind - xmin und xmax.  Der Header ist bereits ziemlich gro√ü, mindestens 23 Bytes, und eine Erh√∂hung der Bittiefe w√ºrde zu einer Erh√∂hung um weitere 8 Bytes f√ºhren.  Das ist absolut unm√∂glich. <br><br><blockquote>  64-Bit-Transaktionsnummern sind im Produkt unseres Unternehmens Postgres Pro Enterprise implementiert, aber auch dort sind sie nicht ganz ehrlich: xmin und xmax bleiben 32-Bit, und die √úberschrift der Seite enth√§lt einen allgemeinen "Beginn einer √Ñra" auf der gesamten Seite. <br></blockquote><br>  Was tun?  Anstelle eines linearen Diagramms werden alle Transaktionsnummern wiederholt.  Bei jeder Transaktion wird davon ausgegangen, dass die H√§lfte der Zahlen ‚Äûgegen den Uhrzeigersinn‚Äú zur Vergangenheit und die H√§lfte ‚Äûim Uhrzeigersinn‚Äú zur Zukunft geh√∂rt. <br><br>  Das Alter einer Transaktion ist die Anzahl der Transaktionen, die seit ihrem Erscheinen im System bestanden wurden (unabh√§ngig davon, ob der Z√§hler Null durchlaufen hat oder nicht).  Wenn wir verstehen wollen, ob eine Transaktion √§lter als eine andere ist oder nicht, vergleichen wir ihr Alter und nicht ihre Zahlen.  (Daher sind die Operationen "gr√∂√üer" und "kleiner" √ºbrigens nicht f√ºr den Datentyp xid definiert.) <br><br><img src="https://habrastorage.org/webt/8f/rk/ft/8frkftw38-c0-yfbjaz7m-au3va.png"><br><br>  In einer solchen Schleifenschaltung entsteht jedoch eine unangenehme Situation.  Eine Transaktion, die in der fernen Vergangenheit war (Transaktion 1 in der Abbildung), befindet sich nach einer Weile in der H√§lfte des Kreises, der sich auf die Zukunft bezieht.  Dies verst√∂√üt nat√ºrlich gegen die Sichtbarkeitsregeln und w√ºrde zu Problemen f√ºhren - die durch Transaktion 1 vorgenommenen √Ñnderungen w√ºrden einfach aus dem Blickfeld verschwinden. <br><br><img src="https://habrastorage.org/webt/qp/vy/ag/qpvyagxruu4gik-rof6eqoxk1e4.png"><br><br><h1>  Versionsfrieren und Sichtbarkeitsregeln </h1><br>  Um solche ‚ÄûReisen‚Äú von der Vergangenheit in die Zukunft zu verhindern, f√ºhrt der Reinigungsprozess (zus√§tzlich zur Freigabe von Speicherplatz auf den Seiten) eine weitere Aufgabe aus.  Er findet ziemlich alte und "kalte" Versionen der Linien (die auf allen Bildern sichtbar sind und deren √Ñnderung bereits unwahrscheinlich ist) und markiert sie auf besondere Weise - "friert" sie ein.  Die eingefrorene Version der Zeile gilt als √§lter als alle regul√§ren Daten und ist in allen Datenschnappsch√ºssen immer sichtbar.  Dar√ºber hinaus muss die Transaktionsnummer xmin nicht mehr angezeigt werden, und diese Nummer kann sicher wiederverwendet werden.  So bleiben eingefrorene Versionen von Strings immer in der Vergangenheit. <br><br><img src="https://habrastorage.org/webt/2c/vn/yp/2cvnypkp70pikgco9rzjjiccob0.png"><br><br>  Um die Transaktionsnummer xmin als eingefroren zu markieren, werden beide Hinweisbits gleichzeitig gesetzt - das Festschreibungsbit und das Abbruchbit. <br><br>  Beachten Sie, dass die xmax-Transaktion nicht eingefroren werden muss.  Aufgrund seiner Anwesenheit ist diese Version der Zeichenfolge nicht mehr relevant.  Nachdem es in Datenschnappsch√ºssen nicht mehr sichtbar ist, wird diese Version der Zeile gel√∂scht. <br><br>  Erstellen Sie f√ºr Experimente eine Tabelle.  Wir stellen den minimalen F√ºllfaktor so ein, dass nur zwei Zeilen auf jede Seite passen. So k√∂nnen wir bequemer beobachten, was passiert.  Schalten Sie die Automatisierung aus, um die Reinigungszeit selbst zu steuern. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tfreeze( id <span class="hljs-type"><span class="hljs-type">integer</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">300</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">10</span></span>, autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre> <br>  Wir haben bereits mehrere Varianten der Funktion erstellt, die mithilfe der Erweiterung pageinspect die Version der Zeilen auf der Seite anzeigen.  Jetzt erstellen wir eine weitere Variante derselben Funktion: Jetzt werden mehrere Seiten gleichzeitig angezeigt und das Alter der xmin-Transaktion angezeigt (hierf√ºr wird das Alter der Systemfunktion verwendet): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno_from <span class="hljs-type"><span class="hljs-type">integer</span></span>, pageno_to <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin_age <span class="hljs-type"><span class="hljs-type">integer</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">+</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) = </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">+</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (f)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, age(t_xmin) xmin_age, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> generate_series(pageno_from, pageno_to) p(pageno), heap_page_items(get_raw_page(relname, pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> pageno, lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Bitte beachten Sie, dass das Zeichen des Einfrierens (das wir mit dem Buchstaben f in Klammern anzeigen) durch die gleichzeitige Installation festgeschriebener und abgebrochener Eingabeaufforderungen bestimmt wird.  Viele Quellen (einschlie√ülich Dokumentation) erw√§hnen die spezielle Nummer FrozenTransactionId = 2, die eingefrorene Transaktionen kennzeichnet.  Ein solches System funktionierte bis Version 9.4, wurde jedoch jetzt durch Tooltip-Bits ersetzt. Auf diese Weise k√∂nnen Sie die urspr√ºngliche Transaktionsnummer in der Zeilenversion speichern, was f√ºr Support- und Debugging-Zwecke praktisch ist.  Transaktionen mit der Nummer 2 k√∂nnen jedoch weiterhin in √§lteren Systemen erfolgen, selbst wenn sie auf die neuesten Versionen aktualisiert wurden. <br><br>  Wir ben√∂tigen auch die Erweiterung pg_visibility, mit der Sie in die Sichtbarkeitskarte schauen k√∂nnen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_visibility;</code> </pre><br>  Vor PostgreSQL 9.6 enthielt die Sichtbarkeitskarte ein Bit pro Seite.  Es wurden Seiten markiert, die nur ‚Äûziemlich alte‚Äú Versionen von Zeichenfolgen enthalten, die garantiert bereits in allen Bildern sichtbar sind.  Die Idee hier ist, dass, wenn die Seite in der Sichtbarkeitskarte markiert ist, Sie f√ºr ihre Version der Linien die Sichtbarkeitsregeln nicht √ºberpr√ºfen m√ºssen. <br><br>  Ab Version 9.6 wurde derselben Ebene eine Freeze-Map hinzugef√ºgt - ein weiteres Bit pro Seite.  Die Freeze Map markiert die Seiten, auf denen alle Versionen der Zeilen eingefroren sind. <br><br>  Wir f√ºgen mehrere Zeilen in die Tabelle ein und f√ºhren sofort die Reinigung durch, um eine Sichtbarkeitskarte zu erstellen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tfreeze(id, s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id, <span class="hljs-string"><span class="hljs-string">'FOO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>) g(id); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze;</code> </pre><br>  Und wir sehen, dass beide Seiten jetzt in der Sichtbarkeitskarte markiert sind (all_visible), aber noch nicht eingefroren sind (all_frozen): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | f (2 rows)</code> </pre><br>  Das Alter der Transaktion, die die Zeilen erstellt hat (xmin_age), ist 1 - dies ist die letzte Transaktion, die auf dem System ausgef√ºhrt wurde: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+--------+---------+----------+-------+-------- (0,1) | normal | 697 (c) | 1 | 0 (a) | (0,1) (0,2) | normal | 697 (c) | 1 | 0 (a) | (0,2) (1,1) | normal | 697 (c) | 1 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 1 | 0 (a) | (1,2) (4 rows)</code> </pre><br><h1>  Mindestalter zum Einfrieren </h1><br>  Drei Hauptparameter steuern das Einfrieren, und wir werden sie der Reihe nach betrachten. <br><br>  Beginnen wir mit <em>vakuum_freeze_min_age</em> , das das minimale Transaktionsalter xmin definiert, bei dem die Zeichenfolgenversion eingefroren werden kann.  Je niedriger dieser Wert ist, desto unn√∂tiger k√∂nnen sich die Gemeinkosten herausstellen: Wenn es sich um ‚Äûhei√üe‚Äú, sich aktiv √§ndernde Daten handelt, ist das Einfrieren von immer mehr neuen Versionen nutzlos.  In diesem Fall ist es besser zu warten. <br><br>  Der Standardwert f√ºr diesen Parameter legt fest, dass Transaktionen einfrieren, nachdem 50 Millionen andere Transaktionen seit ihrem Erscheinen vergangen sind: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> vacuum_freeze_min_age;</code> </pre><pre> <code class="plaintext hljs"> vacuum_freeze_min_age ----------------------- 50000000 (1 row)</code> </pre><br>  Um zu sehen, wie es zum Einfrieren kommt, reduzieren wir den Wert dieses Parameters auf Eins. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> vacuum_freeze_min_age = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Und wir aktualisieren eine Zeile auf der Nullseite.  Die neue Version wird aufgrund des kleinen F√ºllfaktorwerts auf dieselbe Seite gelangen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Folgendes sehen wir jetzt auf den Datenseiten: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+--------+---------+----------+-------+-------- (0,1) | normal | 697 (c) | 2 | 698 | (0,3) (0,2) | normal | 697 (c) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (c) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Jetzt sollen Zeilen, die √§lter als <em>vakuum_freeze_min_age</em> = 1 sind, eingefroren werden.  Beachten Sie jedoch, dass die Nulllinie in der Sichtbarkeitskarte nicht markiert ist (das Bit wurde durch den Befehl UPDATE zur√ºckgesetzt, der die Seite ge√§ndert hat), und die erste bleibt aktiviert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | f | f 1 | t | f (2 rows)</code> </pre><br>  Wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben bereits gesagt,</a> dass beim Reinigen nur Seiten gescannt werden, die nicht in der Sichtbarkeitskarte markiert sind.  Und so stellt sich heraus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+---------------+---------+----------+-------+-------- (0,1) | redirect to 3 | | | | (0,2) | normal | 697 (f) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 (c) | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (c) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Auf der Nullseite ist eine Version eingefroren, auf der ersten Seite wurde jedoch √ºberhaupt keine Reinigung in Betracht gezogen.  Wenn also nur aktuelle Versionen auf der Seite verbleiben, wird die Bereinigung einer solchen Seite nicht durchgef√ºhrt und sie werden nicht eingefroren. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | f (2 rows)</code> </pre><br><h1>  Alter, um den gesamten Tisch einzufrieren </h1><br>  Um die Version der Zeilen auf den Seiten, die bei der Bereinigung noch nicht <em>angezeigt werden,</em> weiterhin einzufrieren, wird ein zweiter Parameter bereitgestellt: <em>vakuum_freeze_table_age</em> .  Es bestimmt das Alter der Transaktion, bei dem die Bereinigung die Sichtbarkeitskarte ignoriert und alle Seiten der Tabelle durchl√§uft, um einzufrieren. <br><br>  In jeder Tabelle ist eine Transaktionsnummer gespeichert, f√ºr die bekannt ist, dass alle √§lteren Transaktionen garantiert eingefroren sind (pg_class.relfrozenxid).  Mit dem Alter dieser <em>gespeicherten</em> Transaktion wird der Wert des Parameters <em>vaca_freeze_table_age verglichen</em> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 694 | 5 (1 row)</code> </pre><br>  Vor PostgreSQL 9.6 f√ºhrte die Bereinigung einen vollst√§ndigen Tabellenscan durch, um sicherzustellen, dass alle Seiten gecrawlt wurden.  Bei gro√üen Tischen war diese Operation lang und traurig.  Die Angelegenheit wurde durch die Tatsache versch√§rft, dass, wenn die Reinigung nicht das Ende erreichte (zum Beispiel ein ungeduldiger Administrator die Ausf√ºhrung eines Befehls unterbrach), es notwendig war, von vorne zu beginnen. <br><br>  Ab Version 9.6 umgeht das L√∂schen dank der Freeze-Map (die wir in der Spalte all_frozen in der Ausgabe von pg_visibility_map sehen) nur die Seiten, die noch nicht in der Map markiert sind.  Dies ist nicht nur ein viel geringerer Arbeitsaufwand, sondern auch ein Widerstand gegen Unterbrechungen: Wenn der Reinigungsprozess gestoppt und neu gestartet wird, muss er nicht erneut auf die Seiten schauen, die er bereits beim letzten Mal in der Gefrierkarte markiert hat. <br><br>  Auf die eine oder andere Weise werden alle Seiten in der Tabelle einmalig in Transaktionen ( <em>vakuum_freeze_table_age</em> - <em>vakuum_freeze_min_age</em> ) eingefroren.  Bei Standardwerten geschieht dies einmal pro Million Transaktionen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> vacuum_freeze_table_age;</code> </pre><pre> <code class="plaintext hljs"> vacuum_freeze_table_age ------------------------- 150000000 (1 row)</code> </pre><br>  Somit ist es klar, dass nicht zu viel <em>Vakuum-Frost-Min_age gesetzt werden</em> sollte, da dies den Overhead erh√∂ht, anstatt ihn zu reduzieren. <br><br>  Lassen Sie uns sehen, wie die gesamte Tabelle eingefroren wird, und reduzieren Sie dazu <em>vakuum_freeze_table_age</em> auf 5, damit die Bedingung f√ºr das Einfrieren erf√ºllt ist. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> vacuum_freeze_table_age = <span class="hljs-number"><span class="hljs-number">5</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Lassen Sie uns reinigen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze;</code> </pre><br>  Da nun garantiert wurde, dass die gesamte Tabelle √ºberpr√ºft wird, kann die Anzahl der eingefrorenen Transaktionen erh√∂ht werden. Wir sind sicher, dass die Seiten keine √§ltere, nicht eingefrorene Transaktion enthalten. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 698 | 1 (1 row)</code> </pre><br>  Jetzt sind alle Versionen der Zeilen auf der ersten Seite eingefroren: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+---------------+---------+----------+-------+-------- (0,1) | redirect to 3 | | | | (0,2) | normal | 697 (f) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 (c) | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (f) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (f) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Au√üerdem ist die erste Seite in der Freeze Map markiert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | t (2 rows)</code> </pre><br><h1>  Alter f√ºr "aggressive" Reaktion </h1><br>  Es ist wichtig, dass Zeilenversionen rechtzeitig einfrieren.  Wenn eine Situation auftritt, in der eine noch nicht eingefrorene Transaktion in die Zukunft eintreten k√∂nnte, st√ºrzt PostgreSQL ab, um potenzielle Probleme zu vermeiden. <br><br>  Was k√∂nnte der Grund daf√ºr sein?  Es gibt verschiedene Gr√ºnde. <br><br><ul><li>  Die automatische Reinigung kann deaktiviert werden, und die regelm√§√üige Reinigung wird ebenfalls nicht gestartet.  Wir haben bereits gesagt, dass dies nicht notwendig ist, aber technisch ist es m√∂glich. </li><li>  Selbst die enthaltene automatische Bereinigung kommt nicht zu Datenbanken, die nicht verwendet werden (denken Sie an den Parameter <em>track_counts</em> und die Datenbank template0). </li><li>  Wie wir beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Mal gesehen haben</a> , √ºberspringt die Reinigung Tabellen, in denen Daten nur hinzugef√ºgt, aber nicht gel√∂scht oder ge√§ndert werden. </li></ul><br>  In solchen F√§llen wird ein "aggressiver" <em>automatischer Reinigungsvorgang</em> bereitgestellt, der durch den Parameter <em>autovacuum_freeze_max_age</em> geregelt wird.  Wenn in einer Tabelle einer Datenbank eine nicht eingefrorene Transaktion vorhanden ist, die √§lter als das im Parameter angegebene Alter ist, wird die automatische Bereinigung zwangsweise gestartet (auch wenn sie deaktiviert ist) und erreicht fr√ºher oder sp√§ter die Problemtabelle (trotz der √ºblichen Kriterien). <br><br>  Der Standardwert ist ziemlich konservativ: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> autovacuum_freeze_max_age;</code> </pre><pre> <code class="plaintext hljs"> autovacuum_freeze_max_age --------------------------- 200000000 (1 row)</code> </pre><br>  Das Limit f√ºr <em>autovacuum_freeze_max_age</em> betr√§gt 2 Milliarden Transaktionen, und es wird ein zehnmal kleinerer Wert verwendet.  Dies ist sinnvoll: Wenn Sie den Wert erh√∂hen, erh√∂hen Sie das Risiko, dass die automatische Reinigung f√ºr die verbleibende Zeit keine Zeit hat, alle erforderlichen Versionen der Leitungen einzufrieren. <br><br>  Dar√ºber hinaus bestimmt der Wert dieses Parameters die Gr√∂√üe der XACT-Struktur: Da das System keine √§lteren Transaktionen enthalten sollte, f√ºr die Sie m√∂glicherweise den Status ermitteln m√ºssen, werden durch die automatische Bereinigung unn√∂tige XACT-Segmentdateien entfernt, wodurch Speicherplatz frei wird. <br><br>  Lassen Sie uns am Beispiel von tfreeze sehen, wie die Reinigung Tabellen zum Anh√§ngen handhabt.  F√ºr diese Tabelle ist die automatische Reinigung im Allgemeinen deaktiviert, dies ist jedoch kein Hindernis. <br><br>  Das √Ñndern des Parameters <em>autovacuum_freeze_max_age</em> erfordert einen Neustart des Servers.  Alle oben diskutierten Parameter k√∂nnen aber auch auf der Ebene einzelner Tabellen mithilfe von Speicherparametern festgelegt werden.  In der Regel ist dies nur in besonderen F√§llen sinnvoll, wenn der Tisch wirklich besondere Pflege erfordert. <br><br>  Also setzen wir <em>autovacuum_freeze_max_age</em> auf Tabellenebene (und geben gleichzeitig auch den normalen F√ºllfaktor zur√ºck).  Leider ist der minimal m√∂gliche Wert 100.000: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_freeze_max_age = <span class="hljs-number"><span class="hljs-number">100000</span></span>, fillfactor = <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre><br>  Leider, weil wir 100.000 Transaktionen abschlie√üen m√ºssen, um die Situation zu reproduzieren, die uns interessiert.  Aber aus praktischen Gr√ºnden ist dies nat√ºrlich ein sehr, sehr niedriger Wert. <br><br>  Da wir Daten hinzuf√ºgen werden, werden wir 100.000 Zeilen in die Tabelle einf√ºgen - jede in unserer Transaktion.  Und wieder muss ich reservieren, dass dies in der Praxis nicht gemacht werden sollte.  Aber jetzt erforschen wir nur, wir k√∂nnen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> foo(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INSERT</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> tfreeze </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">VALUES</span></span></span><span class="pgsql"> (id, </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'FOO'</span></span></span><span class="pgsql">); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">COMMIT</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FOR</span></span></span><span class="pgsql"> i </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">IN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">101</span></span></span><span class="pgsql"> .. </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">100100</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CALL</span></span></span><span class="pgsql"> foo(i); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span>;</code> </pre><br>  Wie wir sehen k√∂nnen, hat das Alter der letzten eingefrorenen Transaktion in der Tabelle den Schwellenwert √ºberschritten: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+-------- 698 | 100006 (1 row)</code> </pre><br>  Wenn Sie jetzt etwas warten, wird im Nachrichtenprotokoll des Servers ein Eintrag √ºber das automatische aggressive Vakuum der Tabelle "test.public.tfreeze" angezeigt. Die Nummer der eingefrorenen Transaktion √§ndert sich und ihr Alter kehrt zum Anstand zur√ºck: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 100703 | 3 (1 row)</code> </pre><br><blockquote>  Es gibt auch so etwas wie das Einfrieren von Multi-Transaktionen, aber wir werden noch nicht dar√ºber sprechen - wir werden es verschieben, bis wir √ºber Sperren sprechen, um nicht vor uns selbst zu kommen. <br></blockquote><br><h1>  Manuelles Einfrieren </h1><br>  Manchmal ist es bequem, das Einfrieren manuell zu steuern, anstatt auf die automatische Reinigung zu warten. <br><br>  Sie k√∂nnen einen Befehl manuell mit dem Befehl VACUUM FREEZE einfrieren. Alle Zeilenversionen werden eingefroren, unabh√§ngig vom Alter der Transaktionen (als ob der Parameter <em>autovacuum_freeze_min_age</em> = 0 w√§re).  Wenn eine Tabelle mit den Befehlen VACUUM FULL oder CLUSTER neu erstellt wird, werden auch alle Zeilen eingefroren. <br><br>  Um alle Datenbanken einzufrieren, k√∂nnen Sie das Dienstprogramm verwenden: <br><br><pre> <code class="plaintext hljs">vacuumdb --all --freeze</code> </pre><br>  Daten k√∂nnen auch w√§hrend des ersten Ladens mit dem Befehl COPY eingefroren werden, indem der Parameter FREEZE angegeben wird.  Dazu muss die Tabelle in derselben erstellt (oder mit dem Befehl TRUNCATE geleert) werden <br>  Transaktionen als KOPIE. <br><br>  Da es separate Sichtbarkeitsregeln f√ºr eingefrorene Zeilen gibt, werden diese Zeilen in Snapshots von Daten aus anderen Transaktionen angezeigt, die gegen die √ºblichen Isolationsregeln versto√üen (dies gilt f√ºr Transaktionen mit der Stufe "Wiederholbares Lesen" oder "Serialisierbar"). <br><br>  Um dies zu √ºberpr√ºfen, starten Sie in einer anderen Sitzung eine Transaktion mit der Isolationsstufe Wiederholbares Lesen: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><br>  Beachten Sie, dass diese Transaktion einen Snapshot der Daten erstellt hat, jedoch nicht auf die tfreeze-Tabelle zugegriffen hat.  Jetzt leeren wir die tfreeze-Tabelle und laden in einer Transaktion neue Zeilen hinein.  Wenn eine parallele Transaktion den Inhalt von tfreeze liest, wird der Befehl TRUNCATE bis zum Ende der Transaktion gesperrt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> tfreeze; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">FROM stdin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FREEZE</span></span>;</code> </pre><pre> <code class="plaintext hljs">1 FOO 2 BAR 3 BAZ \.</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Jetzt sieht eine parallele Transaktion neue Daten, obwohl dies die Isolation unterbricht: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tfreeze;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Da es jedoch unwahrscheinlich ist, dass solche Daten regelm√§√üig geladen werden, ist dies normalerweise kein Problem. <br><br>  Bezeichnenderweise funktioniert COPY WITH FREEZE nicht mit der Sichtbarkeitskarte. Geladene Seiten enthalten nicht nur Versionen der Linien, die f√ºr alle sichtbar sind.  Wenn Sie zum ersten Mal auf die Tabelle zugreifen, muss die Bereinigung daher alles erneut verarbeiten und eine Sichtbarkeitskarte erstellen.  Um die Sache noch schlimmer zu machen, haben Datenseiten ein Zeichen der vollst√§ndigen Sichtbarkeit in ihrem eigenen Header, sodass beim Bereinigen nicht nur die gesamte Tabelle gelesen, sondern auch vollst√§ndig neu geschrieben wird, wobei das gew√ºnschte Bit abgelegt wird.  Leider muss die L√∂sung f√ºr dieses Problem nicht fr√ºher als Version 13 warten ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diskussion</a> ). <br><br><h1>  Fazit </h1><br>  Damit ist meine Artikelserie √ºber PostgreSQL-Isolation und Multiversion abgeschlossen.  Vielen Dank f√ºr Ihre Aufmerksamkeit und insbesondere f√ºr die Kommentare - sie verbessern das Material und weisen oft auf Bereiche hin, die meinerseits mehr Aufmerksamkeit erfordern. <br><br>  Bleib bei uns, um fortzufahren! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455590/">https://habr.com/ru/post/de455590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455580/index.html">Animationen f√ºr mobile Anwendungen sind ein Muss</a></li>
<li><a href="../de455582/index.html">Navigation im Laden: durch Augmented Reality zum gew√ºnschten Regal</a></li>
<li><a href="../de455584/index.html">Kundenspezifische Interviews mit den internen Kr√§ften des Unternehmens: durch Fehler zu Entdeckungen</a></li>
<li><a href="../de455586/index.html">Vorlesungsreihe √ºber Robotik von Professor Gregor Sch√∂ner, Direktor des Instituts f√ºr Neuroinformatik (INI) Bochum</a></li>
<li><a href="../de455588/index.html">Wie Sie Ihre Gemeinde erziehen, um nicht mit einem Tamburin zu tanzen</a></li>
<li><a href="../de455592/index.html">Viren, die Industrieunternehmen als Bedrohung f√ºr die physische Sicherheit angreifen</a></li>
<li><a href="../de455594/index.html">Microsoft Edge von CVE zu RCE unter Windows 10</a></li>
<li><a href="../de455596/index.html">DevConfX :: Management - Berichte von Managern in einfachen Worten</a></li>
<li><a href="../de455598/index.html">Aktualisieren Sie Exim dringend auf 4.92 - es liegt eine aktive Infektion vor</a></li>
<li><a href="../de455600/index.html">Die 3DEXPERIENCE-Plattform hilft bei der Schaffung √∂ffentlicher Verkehrsmittel der Zukunft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>