<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎯 🥝 👩🏾‍💻 MVCC in PostgreSQL-8. Einfrieren 👆 👓 ❄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wir begannen mit Problemen im Zusammenhang mit der Isolation , machten einen Exkurs über das Organisieren von Daten auf niedriger Ebene und sprachen a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC in PostgreSQL-8. Einfrieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/455590/">  Wir begannen mit Problemen im Zusammenhang mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Isolation</a> , machten einen Exkurs über das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Organisieren von Daten auf niedriger Ebene</a> und sprachen ausführlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">über Zeilenversionen</a> und wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Snapshots</a> aus Versionen erhalten werden. <br><br>  Dann untersuchten wir verschiedene Arten der Reinigung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intra-Page</a> (zusammen mit HOT-Updates), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">regelmäßig</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">automatisch</a> . <br><br>  Und bin zum letzten Thema dieses Zyklus gekommen.  Heute werden wir über das Problem des Umlaufens und Einfrierens von Transaktions-IDs sprechen. <br><a name="habracut"></a><br><h1>  Transaktionszählerüberlauf </h1><br>  PostgreSQL verfügt über 32 Bits für die Transaktionsnummer.  Dies ist eine ziemlich große Zahl (ungefähr 4 Milliarden), aber mit dem aktiven Betrieb des Servers kann es durchaus erschöpft sein.  Bei einer Last von 1000 Transaktionen pro Sekunde geschieht dies beispielsweise nach nur anderthalb Monaten Dauerbetrieb. <br><br>  Wir haben jedoch darüber gesprochen, dass der Multi-Versionierungsmechanismus auf der Reihenfolge der Nummerierung beruht. Von zwei Transaktionen kann eine Transaktion mit einer niedrigeren Nummer als früher gestartet betrachtet werden.  Daher ist es klar, dass Sie den Zähler nicht einfach zurücksetzen und die Nummerierung erneut fortsetzen können. <br><br><img src="https://habrastorage.org/webt/cn/om/rg/cnomrgflv1bnkqme9k68bit4ad0.png"><br><br>  Warum werden der Transaktionsnummer keine 64 Bit zugewiesen, da dies das Problem vollständig beseitigen würde?  Tatsache ist, dass (wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits erwähnt</a> ) im Header jeder Version der Zeile zwei Transaktionsnummern gespeichert sind - xmin und xmax.  Der Header ist bereits ziemlich groß, mindestens 23 Bytes, und eine Erhöhung der Bittiefe würde zu einer Erhöhung um weitere 8 Bytes führen.  Das ist absolut unmöglich. <br><br><blockquote>  64-Bit-Transaktionsnummern sind im Produkt unseres Unternehmens Postgres Pro Enterprise implementiert, aber auch dort sind sie nicht ganz ehrlich: xmin und xmax bleiben 32-Bit, und die Überschrift der Seite enthält einen allgemeinen "Beginn einer Ära" auf der gesamten Seite. <br></blockquote><br>  Was tun?  Anstelle eines linearen Diagramms werden alle Transaktionsnummern wiederholt.  Bei jeder Transaktion wird davon ausgegangen, dass die Hälfte der Zahlen „gegen den Uhrzeigersinn“ zur Vergangenheit und die Hälfte „im Uhrzeigersinn“ zur Zukunft gehört. <br><br>  Das Alter einer Transaktion ist die Anzahl der Transaktionen, die seit ihrem Erscheinen im System bestanden wurden (unabhängig davon, ob der Zähler Null durchlaufen hat oder nicht).  Wenn wir verstehen wollen, ob eine Transaktion älter als eine andere ist oder nicht, vergleichen wir ihr Alter und nicht ihre Zahlen.  (Daher sind die Operationen "größer" und "kleiner" übrigens nicht für den Datentyp xid definiert.) <br><br><img src="https://habrastorage.org/webt/8f/rk/ft/8frkftw38-c0-yfbjaz7m-au3va.png"><br><br>  In einer solchen Schleifenschaltung entsteht jedoch eine unangenehme Situation.  Eine Transaktion, die in der fernen Vergangenheit war (Transaktion 1 in der Abbildung), befindet sich nach einer Weile in der Hälfte des Kreises, der sich auf die Zukunft bezieht.  Dies verstößt natürlich gegen die Sichtbarkeitsregeln und würde zu Problemen führen - die durch Transaktion 1 vorgenommenen Änderungen würden einfach aus dem Blickfeld verschwinden. <br><br><img src="https://habrastorage.org/webt/qp/vy/ag/qpvyagxruu4gik-rof6eqoxk1e4.png"><br><br><h1>  Versionsfrieren und Sichtbarkeitsregeln </h1><br>  Um solche „Reisen“ von der Vergangenheit in die Zukunft zu verhindern, führt der Reinigungsprozess (zusätzlich zur Freigabe von Speicherplatz auf den Seiten) eine weitere Aufgabe aus.  Er findet ziemlich alte und "kalte" Versionen der Linien (die auf allen Bildern sichtbar sind und deren Änderung bereits unwahrscheinlich ist) und markiert sie auf besondere Weise - "friert" sie ein.  Die eingefrorene Version der Zeile gilt als älter als alle regulären Daten und ist in allen Datenschnappschüssen immer sichtbar.  Darüber hinaus muss die Transaktionsnummer xmin nicht mehr angezeigt werden, und diese Nummer kann sicher wiederverwendet werden.  So bleiben eingefrorene Versionen von Strings immer in der Vergangenheit. <br><br><img src="https://habrastorage.org/webt/2c/vn/yp/2cvnypkp70pikgco9rzjjiccob0.png"><br><br>  Um die Transaktionsnummer xmin als eingefroren zu markieren, werden beide Hinweisbits gleichzeitig gesetzt - das Festschreibungsbit und das Abbruchbit. <br><br>  Beachten Sie, dass die xmax-Transaktion nicht eingefroren werden muss.  Aufgrund seiner Anwesenheit ist diese Version der Zeichenfolge nicht mehr relevant.  Nachdem es in Datenschnappschüssen nicht mehr sichtbar ist, wird diese Version der Zeile gelöscht. <br><br>  Erstellen Sie für Experimente eine Tabelle.  Wir stellen den minimalen Füllfaktor so ein, dass nur zwei Zeilen auf jede Seite passen. So können wir bequemer beobachten, was passiert.  Schalten Sie die Automatisierung aus, um die Reinigungszeit selbst zu steuern. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tfreeze( id <span class="hljs-type"><span class="hljs-type">integer</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">300</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor = <span class="hljs-number"><span class="hljs-number">10</span></span>, autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>);</code> </pre> <br>  Wir haben bereits mehrere Varianten der Funktion erstellt, die mithilfe der Erweiterung pageinspect die Version der Zeilen auf der Seite anzeigen.  Jetzt erstellen wir eine weitere Variante derselben Funktion: Jetzt werden mehrere Seiten gleichzeitig angezeigt und das Alter der xmin-Transaktion angezeigt (hierfür wird das Alter der Systemfunktion verwendet): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno_from <span class="hljs-type"><span class="hljs-type">integer</span></span>, pageno_to <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin_age <span class="hljs-type"><span class="hljs-type">integer</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">+</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) = </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">+</span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (f)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, age(t_xmin) xmin_age, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> generate_series(pageno_from, pageno_to) p(pageno), heap_page_items(get_raw_page(relname, pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> pageno, lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Bitte beachten Sie, dass das Zeichen des Einfrierens (das wir mit dem Buchstaben f in Klammern anzeigen) durch die gleichzeitige Installation festgeschriebener und abgebrochener Eingabeaufforderungen bestimmt wird.  Viele Quellen (einschließlich Dokumentation) erwähnen die spezielle Nummer FrozenTransactionId = 2, die eingefrorene Transaktionen kennzeichnet.  Ein solches System funktionierte bis Version 9.4, wurde jedoch jetzt durch Tooltip-Bits ersetzt. Auf diese Weise können Sie die ursprüngliche Transaktionsnummer in der Zeilenversion speichern, was für Support- und Debugging-Zwecke praktisch ist.  Transaktionen mit der Nummer 2 können jedoch weiterhin in älteren Systemen erfolgen, selbst wenn sie auf die neuesten Versionen aktualisiert wurden. <br><br>  Wir benötigen auch die Erweiterung pg_visibility, mit der Sie in die Sichtbarkeitskarte schauen können: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_visibility;</code> </pre><br>  Vor PostgreSQL 9.6 enthielt die Sichtbarkeitskarte ein Bit pro Seite.  Es wurden Seiten markiert, die nur „ziemlich alte“ Versionen von Zeichenfolgen enthalten, die garantiert bereits in allen Bildern sichtbar sind.  Die Idee hier ist, dass, wenn die Seite in der Sichtbarkeitskarte markiert ist, Sie für ihre Version der Linien die Sichtbarkeitsregeln nicht überprüfen müssen. <br><br>  Ab Version 9.6 wurde derselben Ebene eine Freeze-Map hinzugefügt - ein weiteres Bit pro Seite.  Die Freeze Map markiert die Seiten, auf denen alle Versionen der Zeilen eingefroren sind. <br><br>  Wir fügen mehrere Zeilen in die Tabelle ein und führen sofort die Reinigung durch, um eine Sichtbarkeitskarte zu erstellen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tfreeze(id, s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> g.id, <span class="hljs-string"><span class="hljs-string">'FOO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>) g(id); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze;</code> </pre><br>  Und wir sehen, dass beide Seiten jetzt in der Sichtbarkeitskarte markiert sind (all_visible), aber noch nicht eingefroren sind (all_frozen): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | f (2 rows)</code> </pre><br>  Das Alter der Transaktion, die die Zeilen erstellt hat (xmin_age), ist 1 - dies ist die letzte Transaktion, die auf dem System ausgeführt wurde: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+--------+---------+----------+-------+-------- (0,1) | normal | 697 (c) | 1 | 0 (a) | (0,1) (0,2) | normal | 697 (c) | 1 | 0 (a) | (0,2) (1,1) | normal | 697 (c) | 1 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 1 | 0 (a) | (1,2) (4 rows)</code> </pre><br><h1>  Mindestalter zum Einfrieren </h1><br>  Drei Hauptparameter steuern das Einfrieren, und wir werden sie der Reihe nach betrachten. <br><br>  Beginnen wir mit <em>vakuum_freeze_min_age</em> , das das minimale Transaktionsalter xmin definiert, bei dem die Zeichenfolgenversion eingefroren werden kann.  Je niedriger dieser Wert ist, desto unnötiger können sich die Gemeinkosten herausstellen: Wenn es sich um „heiße“, sich aktiv ändernde Daten handelt, ist das Einfrieren von immer mehr neuen Versionen nutzlos.  In diesem Fall ist es besser zu warten. <br><br>  Der Standardwert für diesen Parameter legt fest, dass Transaktionen einfrieren, nachdem 50 Millionen andere Transaktionen seit ihrem Erscheinen vergangen sind: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> vacuum_freeze_min_age;</code> </pre><pre> <code class="plaintext hljs"> vacuum_freeze_min_age ----------------------- 50000000 (1 row)</code> </pre><br>  Um zu sehen, wie es zum Einfrieren kommt, reduzieren wir den Wert dieses Parameters auf Eins. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> vacuum_freeze_min_age = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Und wir aktualisieren eine Zeile auf der Nullseite.  Die neue Version wird aufgrund des kleinen Füllfaktorwerts auf dieselbe Seite gelangen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Folgendes sehen wir jetzt auf den Datenseiten: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+--------+---------+----------+-------+-------- (0,1) | normal | 697 (c) | 2 | 698 | (0,3) (0,2) | normal | 697 (c) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (c) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Jetzt sollen Zeilen, die älter als <em>vakuum_freeze_min_age</em> = 1 sind, eingefroren werden.  Beachten Sie jedoch, dass die Nulllinie in der Sichtbarkeitskarte nicht markiert ist (das Bit wurde durch den Befehl UPDATE zurückgesetzt, der die Seite geändert hat), und die erste bleibt aktiviert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | f | f 1 | t | f (2 rows)</code> </pre><br>  Wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">haben bereits gesagt,</a> dass beim Reinigen nur Seiten gescannt werden, die nicht in der Sichtbarkeitskarte markiert sind.  Und so stellt sich heraus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+---------------+---------+----------+-------+-------- (0,1) | redirect to 3 | | | | (0,2) | normal | 697 (f) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 (c) | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (c) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (c) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Auf der Nullseite ist eine Version eingefroren, auf der ersten Seite wurde jedoch überhaupt keine Reinigung in Betracht gezogen.  Wenn also nur aktuelle Versionen auf der Seite verbleiben, wird die Bereinigung einer solchen Seite nicht durchgeführt und sie werden nicht eingefroren. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | f (2 rows)</code> </pre><br><h1>  Alter, um den gesamten Tisch einzufrieren </h1><br>  Um die Version der Zeilen auf den Seiten, die bei der Bereinigung noch nicht <em>angezeigt werden,</em> weiterhin einzufrieren, wird ein zweiter Parameter bereitgestellt: <em>vakuum_freeze_table_age</em> .  Es bestimmt das Alter der Transaktion, bei dem die Bereinigung die Sichtbarkeitskarte ignoriert und alle Seiten der Tabelle durchläuft, um einzufrieren. <br><br>  In jeder Tabelle ist eine Transaktionsnummer gespeichert, für die bekannt ist, dass alle älteren Transaktionen garantiert eingefroren sind (pg_class.relfrozenxid).  Mit dem Alter dieser <em>gespeicherten</em> Transaktion wird der Wert des Parameters <em>vaca_freeze_table_age verglichen</em> . <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 694 | 5 (1 row)</code> </pre><br>  Vor PostgreSQL 9.6 führte die Bereinigung einen vollständigen Tabellenscan durch, um sicherzustellen, dass alle Seiten gecrawlt wurden.  Bei großen Tischen war diese Operation lang und traurig.  Die Angelegenheit wurde durch die Tatsache verschärft, dass, wenn die Reinigung nicht das Ende erreichte (zum Beispiel ein ungeduldiger Administrator die Ausführung eines Befehls unterbrach), es notwendig war, von vorne zu beginnen. <br><br>  Ab Version 9.6 umgeht das Löschen dank der Freeze-Map (die wir in der Spalte all_frozen in der Ausgabe von pg_visibility_map sehen) nur die Seiten, die noch nicht in der Map markiert sind.  Dies ist nicht nur ein viel geringerer Arbeitsaufwand, sondern auch ein Widerstand gegen Unterbrechungen: Wenn der Reinigungsprozess gestoppt und neu gestartet wird, muss er nicht erneut auf die Seiten schauen, die er bereits beim letzten Mal in der Gefrierkarte markiert hat. <br><br>  Auf die eine oder andere Weise werden alle Seiten in der Tabelle einmalig in Transaktionen ( <em>vakuum_freeze_table_age</em> - <em>vakuum_freeze_min_age</em> ) eingefroren.  Bei Standardwerten geschieht dies einmal pro Million Transaktionen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> vacuum_freeze_table_age;</code> </pre><pre> <code class="plaintext hljs"> vacuum_freeze_table_age ------------------------- 150000000 (1 row)</code> </pre><br>  Somit ist es klar, dass nicht zu viel <em>Vakuum-Frost-Min_age gesetzt werden</em> sollte, da dies den Overhead erhöht, anstatt ihn zu reduzieren. <br><br>  Lassen Sie uns sehen, wie die gesamte Tabelle eingefroren wird, und reduzieren Sie dazu <em>vakuum_freeze_table_age</em> auf 5, damit die Bedingung für das Einfrieren erfüllt ist. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> vacuum_freeze_table_age = <span class="hljs-number"><span class="hljs-number">5</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_reload_conf();</code> </pre><br>  Lassen Sie uns reinigen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> tfreeze;</code> </pre><br>  Da nun garantiert wurde, dass die gesamte Tabelle überprüft wird, kann die Anzahl der eingefrorenen Transaktionen erhöht werden. Wir sind sicher, dass die Seiten keine ältere, nicht eingefrorene Transaktion enthalten. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 698 | 1 (1 row)</code> </pre><br>  Jetzt sind alle Versionen der Zeilen auf der ersten Seite eingefroren: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmin_age | xmax | t_ctid -------+---------------+---------+----------+-------+-------- (0,1) | redirect to 3 | | | | (0,2) | normal | 697 (f) | 2 | 0 (a) | (0,2) (0,3) | normal | 698 (c) | 1 | 0 (a) | (0,3) (1,1) | normal | 697 (f) | 2 | 0 (a) | (1,1) (1,2) | normal | 697 (f) | 2 | 0 (a) | (1,2) (5 rows)</code> </pre><br>  Außerdem ist die erste Seite in der Freeze Map markiert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) g(blkno), pg_visibility_map(<span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>,g.blkno) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> g.blkno;</code> </pre><pre> <code class="plaintext hljs"> blkno | all_visible | all_frozen -------+-------------+------------ 0 | t | f 1 | t | t (2 rows)</code> </pre><br><h1>  Alter für "aggressive" Reaktion </h1><br>  Es ist wichtig, dass Zeilenversionen rechtzeitig einfrieren.  Wenn eine Situation auftritt, in der eine noch nicht eingefrorene Transaktion in die Zukunft eintreten könnte, stürzt PostgreSQL ab, um potenzielle Probleme zu vermeiden. <br><br>  Was könnte der Grund dafür sein?  Es gibt verschiedene Gründe. <br><br><ul><li>  Die automatische Reinigung kann deaktiviert werden, und die regelmäßige Reinigung wird ebenfalls nicht gestartet.  Wir haben bereits gesagt, dass dies nicht notwendig ist, aber technisch ist es möglich. </li><li>  Selbst die enthaltene automatische Bereinigung kommt nicht zu Datenbanken, die nicht verwendet werden (denken Sie an den Parameter <em>track_counts</em> und die Datenbank template0). </li><li>  Wie wir beim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Mal gesehen haben</a> , überspringt die Reinigung Tabellen, in denen Daten nur hinzugefügt, aber nicht gelöscht oder geändert werden. </li></ul><br>  In solchen Fällen wird ein "aggressiver" <em>automatischer Reinigungsvorgang</em> bereitgestellt, der durch den Parameter <em>autovacuum_freeze_max_age</em> geregelt wird.  Wenn in einer Tabelle einer Datenbank eine nicht eingefrorene Transaktion vorhanden ist, die älter als das im Parameter angegebene Alter ist, wird die automatische Bereinigung zwangsweise gestartet (auch wenn sie deaktiviert ist) und erreicht früher oder später die Problemtabelle (trotz der üblichen Kriterien). <br><br>  Der Standardwert ist ziemlich konservativ: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> autovacuum_freeze_max_age;</code> </pre><pre> <code class="plaintext hljs"> autovacuum_freeze_max_age --------------------------- 200000000 (1 row)</code> </pre><br>  Das Limit für <em>autovacuum_freeze_max_age</em> beträgt 2 Milliarden Transaktionen, und es wird ein zehnmal kleinerer Wert verwendet.  Dies ist sinnvoll: Wenn Sie den Wert erhöhen, erhöhen Sie das Risiko, dass die automatische Reinigung für die verbleibende Zeit keine Zeit hat, alle erforderlichen Versionen der Leitungen einzufrieren. <br><br>  Darüber hinaus bestimmt der Wert dieses Parameters die Größe der XACT-Struktur: Da das System keine älteren Transaktionen enthalten sollte, für die Sie möglicherweise den Status ermitteln müssen, werden durch die automatische Bereinigung unnötige XACT-Segmentdateien entfernt, wodurch Speicherplatz frei wird. <br><br>  Lassen Sie uns am Beispiel von tfreeze sehen, wie die Reinigung Tabellen zum Anhängen handhabt.  Für diese Tabelle ist die automatische Reinigung im Allgemeinen deaktiviert, dies ist jedoch kein Hindernis. <br><br>  Das Ändern des Parameters <em>autovacuum_freeze_max_age</em> erfordert einen Neustart des Servers.  Alle oben diskutierten Parameter können aber auch auf der Ebene einzelner Tabellen mithilfe von Speicherparametern festgelegt werden.  In der Regel ist dies nur in besonderen Fällen sinnvoll, wenn der Tisch wirklich besondere Pflege erfordert. <br><br>  Also setzen wir <em>autovacuum_freeze_max_age</em> auf Tabellenebene (und geben gleichzeitig auch den normalen Füllfaktor zurück).  Leider ist der minimal mögliche Wert 100.000: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> (autovacuum_freeze_max_age = <span class="hljs-number"><span class="hljs-number">100000</span></span>, fillfactor = <span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre><br>  Leider, weil wir 100.000 Transaktionen abschließen müssen, um die Situation zu reproduzieren, die uns interessiert.  Aber aus praktischen Gründen ist dies natürlich ein sehr, sehr niedriger Wert. <br><br>  Da wir Daten hinzufügen werden, werden wir 100.000 Zeilen in die Tabelle einfügen - jede in unserer Transaktion.  Und wieder muss ich reservieren, dass dies in der Praxis nicht gemacht werden sollte.  Aber jetzt erforschen wir nur, wir können. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> foo(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INSERT</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> tfreeze </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">VALUES</span></span></span><span class="pgsql"> (id, </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'FOO'</span></span></span><span class="pgsql">); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">COMMIT</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FOR</span></span></span><span class="pgsql"> i </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">IN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">101</span></span></span><span class="pgsql"> .. </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">100100</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CALL</span></span></span><span class="pgsql"> foo(i); </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span>;</code> </pre><br>  Wie wir sehen können, hat das Alter der letzten eingefrorenen Transaktion in der Tabelle den Schwellenwert überschritten: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+-------- 698 | 100006 (1 row)</code> </pre><br>  Wenn Sie jetzt etwas warten, wird im Nachrichtenprotokoll des Servers ein Eintrag über das automatische aggressive Vakuum der Tabelle "test.public.tfreeze" angezeigt. Die Nummer der eingefrorenen Transaktion ändert sich und ihr Alter kehrt zum Anstand zurück: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfrozenxid, age(relfrozenxid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'tfreeze'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfrozenxid | age --------------+----- 100703 | 3 (1 row)</code> </pre><br><blockquote>  Es gibt auch so etwas wie das Einfrieren von Multi-Transaktionen, aber wir werden noch nicht darüber sprechen - wir werden es verschieben, bis wir über Sperren sprechen, um nicht vor uns selbst zu kommen. <br></blockquote><br><h1>  Manuelles Einfrieren </h1><br>  Manchmal ist es bequem, das Einfrieren manuell zu steuern, anstatt auf die automatische Reinigung zu warten. <br><br>  Sie können einen Befehl manuell mit dem Befehl VACUUM FREEZE einfrieren. Alle Zeilenversionen werden eingefroren, unabhängig vom Alter der Transaktionen (als ob der Parameter <em>autovacuum_freeze_min_age</em> = 0 wäre).  Wenn eine Tabelle mit den Befehlen VACUUM FULL oder CLUSTER neu erstellt wird, werden auch alle Zeilen eingefroren. <br><br>  Um alle Datenbanken einzufrieren, können Sie das Dienstprogramm verwenden: <br><br><pre> <code class="plaintext hljs">vacuumdb --all --freeze</code> </pre><br>  Daten können auch während des ersten Ladens mit dem Befehl COPY eingefroren werden, indem der Parameter FREEZE angegeben wird.  Dazu muss die Tabelle in derselben erstellt (oder mit dem Befehl TRUNCATE geleert) werden <br>  Transaktionen als KOPIE. <br><br>  Da es separate Sichtbarkeitsregeln für eingefrorene Zeilen gibt, werden diese Zeilen in Snapshots von Daten aus anderen Transaktionen angezeigt, die gegen die üblichen Isolationsregeln verstoßen (dies gilt für Transaktionen mit der Stufe "Wiederholbares Lesen" oder "Serialisierbar"). <br><br>  Um dies zu überprüfen, starten Sie in einer anderen Sitzung eine Transaktion mit der Isolationsstufe Wiederholbares Lesen: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><br>  Beachten Sie, dass diese Transaktion einen Snapshot der Daten erstellt hat, jedoch nicht auf die tfreeze-Tabelle zugegriffen hat.  Jetzt leeren wir die tfreeze-Tabelle und laden in einer Transaktion neue Zeilen hinein.  Wenn eine parallele Transaktion den Inhalt von tfreeze liest, wird der Befehl TRUNCATE bis zum Ende der Transaktion gesperrt. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> tfreeze; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> tfreeze <span class="hljs-keyword"><span class="hljs-keyword">FROM stdin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FREEZE</span></span>;</code> </pre><pre> <code class="plaintext hljs">1 FOO 2 BAR 3 BAZ \.</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Jetzt sieht eine parallele Transaktion neue Daten, obwohl dies die Isolation unterbricht: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tfreeze;</code> </pre><pre> <code class="plaintext hljs">| count | ------- | 3 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Da es jedoch unwahrscheinlich ist, dass solche Daten regelmäßig geladen werden, ist dies normalerweise kein Problem. <br><br>  Bezeichnenderweise funktioniert COPY WITH FREEZE nicht mit der Sichtbarkeitskarte. Geladene Seiten enthalten nicht nur Versionen der Linien, die für alle sichtbar sind.  Wenn Sie zum ersten Mal auf die Tabelle zugreifen, muss die Bereinigung daher alles erneut verarbeiten und eine Sichtbarkeitskarte erstellen.  Um die Sache noch schlimmer zu machen, haben Datenseiten ein Zeichen der vollständigen Sichtbarkeit in ihrem eigenen Header, sodass beim Bereinigen nicht nur die gesamte Tabelle gelesen, sondern auch vollständig neu geschrieben wird, wobei das gewünschte Bit abgelegt wird.  Leider muss die Lösung für dieses Problem nicht früher als Version 13 warten ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diskussion</a> ). <br><br><h1>  Fazit </h1><br>  Damit ist meine Artikelserie über PostgreSQL-Isolation und Multiversion abgeschlossen.  Vielen Dank für Ihre Aufmerksamkeit und insbesondere für die Kommentare - sie verbessern das Material und weisen oft auf Bereiche hin, die meinerseits mehr Aufmerksamkeit erfordern. <br><br>  Bleib bei uns, um fortzufahren! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455590/">https://habr.com/ru/post/de455590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455580/index.html">Animationen für mobile Anwendungen sind ein Muss</a></li>
<li><a href="../de455582/index.html">Navigation im Laden: durch Augmented Reality zum gewünschten Regal</a></li>
<li><a href="../de455584/index.html">Kundenspezifische Interviews mit den internen Kräften des Unternehmens: durch Fehler zu Entdeckungen</a></li>
<li><a href="../de455586/index.html">Vorlesungsreihe über Robotik von Professor Gregor Schöner, Direktor des Instituts für Neuroinformatik (INI) Bochum</a></li>
<li><a href="../de455588/index.html">Wie Sie Ihre Gemeinde erziehen, um nicht mit einem Tamburin zu tanzen</a></li>
<li><a href="../de455592/index.html">Viren, die Industrieunternehmen als Bedrohung für die physische Sicherheit angreifen</a></li>
<li><a href="../de455594/index.html">Microsoft Edge von CVE zu RCE unter Windows 10</a></li>
<li><a href="../de455596/index.html">DevConfX :: Management - Berichte von Managern in einfachen Worten</a></li>
<li><a href="../de455598/index.html">Aktualisieren Sie Exim dringend auf 4.92 - es liegt eine aktive Infektion vor</a></li>
<li><a href="../de455600/index.html">Die 3DEXPERIENCE-Plattform hilft bei der Schaffung öffentlicher Verkehrsmittel der Zukunft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>