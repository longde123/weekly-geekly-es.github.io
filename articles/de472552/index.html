<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëì üíô üíä 63 Kerne durch sieben Anweisungen gesperrt üëÅÔ∏è üë®üèº‚Äçüî¨ ‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe anscheinend die Angewohnheit, √ºber leistungsstarke Maschinen zu schreiben, bei denen viele Kerne aufgrund falscher Sperren im Leerlauf sind. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>63 Kerne durch sieben Anweisungen gesperrt</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472552/"> Ich habe anscheinend die Angewohnheit, √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">leistungsstarke Maschinen zu</a> schreiben, bei denen viele Kerne aufgrund falscher Sperren im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Leerlauf</a> sind.  Also ... ja.  Nochmals dazu. <br><br>  Diese Geschichte ist besonders beeindruckend.  Wie oft dreht sich ein Thread einige Sekunden lang in einem Zyklus von sieben Befehlen und h√§lt eine Sperre, die die Arbeit von 63 anderen Prozessoren stoppt?  Es ist einfach unglaublich, in einem schrecklichen Sinne. <br><br>  Entgegen der landl√§ufigen Meinung habe ich tats√§chlich keine Maschine mit 64 logischen Prozessoren, und ich habe dieses spezielle Problem nie gesehen.  Aber mein Freund ist <s><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">darauf gesto√üen</a></s> , <s><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Nerd hat mich s√ºchtig gemacht,</a></s> er hat um Hilfe gebeten, und ich habe festgestellt, dass das Problem ziemlich interessant ist.  Er schickte eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ETW-Spur</a> mit gen√ºgend Informationen, damit der kollektive Verstand auf Twitter das Problem schnell l√∂ste. <br><a name="habracut"></a><br>  Die Beschwerde des Freundes war recht einfach: Er sammelte den Build mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ninja</a> .  In der Regel erh√∂ht Ninja die Last hervorragend und unterst√ºtzt st√§ndig n + 2 Prozesse, um Ausfallzeiten zu vermeiden.  Aber hier sah die CPU-Auslastung in den ersten 17 Sekunden der Assembly folgenderma√üen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/708/9d6/808/7089d68083b016688e6ec980981f52a4.png"><br><br>  Wenn Sie genauer hinschauen (ein Witz), sehen Sie eine d√ºnne Linie, in der die gesamte CPU-Auslastung innerhalb weniger Sekunden von 100% auf 0% sinkt.  In nur einer halben Sekunde reduziert sich die Last von 64 auf zwei oder drei F√§den.  Hier ist ein vergr√∂√üertes Fragment eines dieser St√ºrze - Sekunden sind entlang der horizontalen Achse markiert: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/14a/f7a/6c3/14af7a6c3dbdb7563fa6e316ad7a21e2.png"><br><br>  Der erste Gedanke war, dass Ninja nicht schnell Prozesse erstellen kann.  Ich habe dies oft gesehen, normalerweise aufgrund des Eingreifens von Antivirensoftware.  Aber als ich die Diagramme nach der Endzeit sortierte, stellte ich fest, dass w√§hrend solcher Abst√ºrze keine Prozesse abgeschlossen wurden, so dass Ninja nicht schuld ist. <br><br>  Die Tabelle zur <i>CPU-Auslastung (pr√§zise)</i> ist ideal, um die Ursache f√ºr Ausfallzeiten zu ermitteln.  Dort werden die Protokolle aller Kontextwechsel gespeichert, einschlie√ülich genauer Aufzeichnungen √ºber jeden Start des Streams, einschlie√ülich Ort und Zeit√ºberschreitung. <br><br>  Der Trick ist, dass Ausfallzeiten nichts auszusetzen haben.  Das Problem tritt auf, wenn wir wirklich wollen, dass der Thread die Arbeit erledigt, aber stattdessen ist er inaktiv.  Daher m√ºssen Sie bestimmte Ausfallzeiten ausw√§hlen. <br><br>  Bei der Analyse ist es wichtig zu verstehen, dass die Kontextumschaltung erfolgt, wenn ein Thread den Betrieb wieder aufnimmt.  Wenn wir uns diese Stellen ansehen, an denen die Prozessorlast zu sinken beginnt, werden wir nichts finden.  Konzentrieren Sie sich stattdessen darauf, wann das System wieder funktioniert.  Diese Spurenphase ist noch dramatischer.  W√§hrend der CPU-Lastabfall eine halbe Sekunde dauert, dauert der umgekehrte Vorgang von einem verwendeten Thread zu einer vollen Last nur zw√∂lf Millisekunden!  Die folgende Grafik ist ziemlich stark vergr√∂√üert, und dennoch ist der √úbergang vom Leerlauf zur Last fast eine vertikale Linie: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7f/cd4/cc6/d7fcd4cc68e55c5d6c7ff16cc8a5b32d.png"><br><br>  Ich habe auf zw√∂lf Millisekunden gezoomt und 500 Kontextwechsel gefunden. Hier ist eine sorgf√§ltige Analyse erforderlich. <br><br>  Die Kontextwechsel-Tabelle enth√§lt viele Spalten, die ich hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dokumentiert habe</a> .  Wenn ein Prozess einfriert, um den Grund zu finden, gruppiere ich nach neuen Prozessen, neuen Threads, neuen Thread-Stapeln usw. ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier beschrieben</a> ), aber dies funktioniert nicht bei Hunderten von gestoppten Prozessen.  Wenn ich einen falschen Prozess untersucht habe, ist es klar, dass er durch den vorherigen Prozess vorbereitet wurde, der durch den vorherigen vorbereitet wurde, und ich w√ºrde eine lange Kette scannen, um das erste Glied zu finden, das (vermutlich) lange Zeit ein wichtiges Schloss enth√§lt. <br><br>  Also habe ich ein anderes Spaltenlayout im Programm ausprobiert: <br><br><ul><li>  <i>Einschaltzeit</i> (bei Kontextumschaltung) <br></li><li>  <i>Vorbereitungsprozess</i> (der die Sperre nach dem Warten freigegeben hat) <br></li><li>  <i>Neuer Prozess</i> (wer hat angefangen zu arbeiten) <br></li><li>  <i>Zeit seit dem letzten</i> (wie lange hat der neue Prozess gewartet) </li></ul><br>  Dies gibt eine zeitlich geordnete Liste von Kontextwechseln mit einer Notiz dar√ºber, wer wen vorbereitet hat und wie lange die Prozesse betriebsbereit waren. <br><br>  Es stellte sich heraus, dass dies genug ist.  Die folgende Tabelle spricht f√ºr sich, wenn Sie wissen, wie man sie liest.  Die ersten paar Kontextwechsel sind nicht von Interesse, da die Wartezeit f√ºr einen neuen Prozess (Time Since Last) recht gering ist, aber in der hervorgehobenen Zeile (# 4) beginnt eine interessante Sache: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d7/106/72f/0d710672f2cafc1bd7a2953a42ea55dd.png"><br><br>  Diese Zeile besagt, dass <i>System (4)</i> <i>Cl. Exe (3032)</i> vorbereitet hat, das 3,368 Sekunden gewartet hat.  Die n√§chste Zeile besagt, dass <i>Cl</i> <i>. Exe (3032)</i> in weniger als 0,1 ms <i>cl.exe (16232)</i> vorbereitet <i>hat</i> , das 3,367 Sekunden gewartet hat.  Usw. <br><br>  Einige Kontextwechsel, wie in Zeile 7, sind nicht in der Wartekette enthalten, sondern spiegeln einfach andere Arbeiten im System wider, aber im Allgemeinen ist die Kette auf viele zehn Elemente ausgedehnt. <br><br>  Dies bedeutet, dass alle diese Prozesse auf die Freigabe derselben Sperre warten.  Wenn der <i>System (4)</i> -Prozess die Sperre aufhebt (nach 3.368 Sekunden Halten!), Erfassen die wartenden Prozesse diese wiederum, erledigen ihre kleine Arbeit und geben die Sperre weiter.  Die Warteschlange hat ungef√§hr hundert Prozesse, was den Grad des Einflusses einer einzelnen Sperre anzeigt. <br><br>  Eine kleine Studie mit <i>Ready Thread Stacks hat</i> gezeigt, dass die meisten Erwartungen von <i>KernelBase.dllWriteFile stammen</i> .  Ich habe WPA gebeten, die Aufrufer dieser Funktion mit Gruppierung anzuzeigen.  Dort k√∂nnen Sie sehen, dass in 12 Millisekunden dieser Katharsis 174 Threads aus dem <i>WriteFile-</i> Warten <i>verschwinden</i> und durchschnittlich 1.184 Sekunden gewartet haben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c63/a77/73d/c63a7773d08b42f2def485247d57e916.png"><br>  <i><font color="gray">174 Threads warten auf WriteFile, durchschnittliche Wartezeit 1.184 Sekunden</font></i> <br><br>  Dies ist eine erstaunliche Verz√∂gerung und in der Tat nicht einmal das gesamte Ausma√ü des Problems, da viele Threads von anderen Funktionen, wie z. B. <i>KernelBase.dll! GetQueuedCompletionStatus,</i> die Freigabe derselben Sperre erwarten. <br><br><h2>  Was macht das System? (4) </h2><br>  Zu diesem Zeitpunkt wusste ich, dass der Build-Fortschritt gestoppt wurde, da alle Compiler-Prozesse und andere <i>WriteFile</i> erwarteten, da <i>System (4)</i> die Sperre hielt.  Eine weitere Spalte mit der <i>Ready-Thread-ID</i> zeigte, dass der Thread 3276 die Sperre im Systemprozess aufgehoben hat. <br><br>  W√§hrend aller "H√§nge" der Baugruppe war der Thread 3276 zu 100% geladen, sodass klar ist, dass er beim Halten der Sperre einige Arbeiten an der CPU ausgef√ºhrt hat.  Um herauszufinden, wo die Prozessorzeit verbracht wird, schauen wir uns das <i>Diagramm</i> zur CPU-Auslastung <i>(abgetastet)</i> f√ºr Stream 3276 an. Die Daten zur CPU-Auslastung erwiesen sich als √ºberraschend klar.  Fast die ganze Zeit dauert die Arbeit einer Funktion <i>ntoskrnl.exe! RtlFindNextForwardRunClear</i> (die Anzahl der Proben ist in der Spalte mit den Zahlen angegeben): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0fc/0ce/2fc/0fc0ce2fc4485818ba45f9504f4c8181.png"><br>  <i><font color="gray">Der Aufrufstapel f√ºhrt zu ntoskrnl.exe! RtlFindNextForwardRunClear</font></i> <br><br>  Anzeigen des Thread-Stapels Das <i>Bereitstellen der Thread-ID</i> best√§tigte, dass <i>NtfsCheckpointVolume</i> die Sperre nach 3.368 s <i>aufgehoben</i> hat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a43/225/a97/a43225a974de7651a6b51dc04b339364.png"><br>  <i><font color="gray">Rufen Sie Stack von NtfsCheckpointVolume zu ExReleaseResourceLite auf</font></i> <br><br>  In diesem Moment schien es mir an der Zeit, das reiche Wissen meiner Follower auf Twitter zu nutzen, also stellte ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Frage</a> und zeigte einen vollst√§ndigen Anrufstapel.  Tweets mit solchen Fragen k√∂nnen sehr effektiv sein, wenn Sie gen√ºgend Informationen bereitstellen. <br><br>  In diesem Fall kam die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">richtige Antwort</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Caitlin Gadd</a> sehr schnell, zusammen mit vielen anderen gro√üartigen Vorschl√§gen.  Sie schaltete die Systemwiederherstellungsfunktion aus - und pl√∂tzlich ging der Build zwei- bis dreimal schneller! <br><br><h2>  Aber warte, weiter ist noch besser </h2><br>  Das Blockieren der Ausf√ºhrung im gesamten System f√ºr mehr als 3 Sekunden ist beeindruckend. Die Situation ist jedoch noch beeindruckender, wenn Sie die Spalte <i>Adresse</i> zur Tabelle <i>CPU-Auslastung (Stichproben)</i> hinzuf√ºgen und danach sortieren.  Es zeigt, wo genau in <i>RtlFindNextForwardRunClear-</i> Samples - und 99% davon fallen auf eine Anweisung! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aec/1e3/9b6/aec1e39b65cddb3473242514e7cea1a9.png"><br><br>  Ich nahm die <i>Dateien</i> <i>ntoskrnl.exe</i> und <i>ntkrnlmp.pdb</i> (dieselbe Version wie mein Freund) und f√ºhrte <code>dumpbin /disasm</code> , um die Funktion <code>dumpbin /disasm</code> , die f√ºr Assembler von Interesse ist.  Die ersten Ziffern der Adressen sind unterschiedlich, da sich der Code beim Booten bewegt, die letzten vier Hex-Werte jedoch gleich sind (sie √§ndern sich nach ASLR nicht): <br><br><pre>  RtlFindNextForwardRunClear:
 ...
 14006464F: 4C 3B C3 cmp r8, rbx
 140064652: 73 0F jae 0000000140064663
 140064654: 41 39 28 cmp dword ptr [r8], ebp
 140064657: 75 0A jne 0000000140064663
 140064659: 49 83 C0 04 r8.4 hinzuf√ºgen
 14006465D: 41 83 C1 20 addiere r9d, 20h
 140064661: EB EC jmp 000000014006464F
 ... </pre><br>  Wir sehen, dass die Anweisung zu ... 4657 in einem Zyklus von sieben Anweisungen enthalten ist, die in anderen Beispielen enthalten sind.  Die Anzahl solcher Proben ist rechts angegeben: <br><br><pre>  RtlFindNextForwardRunClear:
 ...
 14006464F: 4C 3B C3 cmp r8, rbx 4
 140064652: 73 0F jae 0000000140064663 41
 140064654: 41 39 28 cmp dword ptr [r8], ebp     
 140064657: 75 0A jne 0000000140064663 7498
 140064659: 49 83 C0 04 addiere r8.4 2
 14006465D: 41 83 C1 20 addiere r9d, 20h 1
 140064661: EB EC jmp 000000014006464F 1
 ... </pre><br>  Lassen Sie uns als √úbung f√ºr den Leser die Interpretation der Anzahl der Samples auf einem superskalaren Prozessor mit au√üergew√∂hnlicher Ausf√ºhrung von Anweisungen belassen, obwohl einige gute Ideen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel zu finden sind</a> .  In diesem Fall haben wir einen 32-Kern AMD Ryzen Threadripper 2990WX.  Offensichtlich erm√∂glicht die Prozessorfunktion von Micro-Up Fusion mit der Ausf√ºhrung von f√ºnf Befehlen gleichzeitig tats√§chlich, dass jeder Zyklus auf jne abgeschlossen wird, da der Befehl nach dem teuersten Befehl in die Mehrzahl der Unterbrechungen in der Auswahl f√§llt. <br><br>  Es stellt sich also heraus, dass ein Computer mit 64 logischen Prozessoren in einem Zyklus von sieben Befehlen im Systemprozess stoppt, w√§hrend eine wichtige NTFS-Sperre beibehalten wird, die durch Deaktivieren der Systemwiederherstellung behoben wird. <br><br><h2>  Coda </h2><br>  Es ist nicht klar, warum sich dieser Code auf diesem bestimmten Computer schlecht verhalten hat.  Ich nehme an, das h√§ngt irgendwie mit der Verteilung von Daten auf einer fast leeren 2-TB-Festplatte zusammen.  Wenn die Systemwiederherstellung wieder aktiviert wurde, trat das Problem ebenfalls auf, jedoch nicht so schwerwiegend.  Vielleicht gibt es eine Art Pathologie f√ºr Festplatten mit riesigen Fragmenten des leeren Raums? <br><br>  Ein anderer Follower auf Twitter erw√§hnte den Volume Shadow Copy-Fehler von Windows 7, der die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausf√ºhrung w√§hrend O (n ^ 2) erm√∂glicht</a> .  Dieser Fehler wurde angeblich in Windows 8 behoben, wurde aber m√∂glicherweise in irgendeiner Form beibehalten.  Meine Stack-Traces zeigen deutlich, dass <i>VspUpperFindNextForwardRunClearLimited</i> (Suchen eines verwendeten Bits in diesem 16-Megabyte-Bereich) <i>VspUpperFindNextForwardRunClear aufruft</i> (nach dem n√§chsten verwendeten Bit sucht, es jedoch nicht <i>zur√ºckgibt</i> , wenn es au√üerhalb des angegebenen Bereichs liegt).  Dies verursacht nat√ºrlich ein gewisses Gef√ºhl von Deja Vu.  Wie ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√ºrzlich sagte</a> , ist O (n ^ 2) eine Schwachstelle schlecht skalierbarer Algorithmen.  Zwei Faktoren stimmen hier √ºberein: Ein solcher Code ist schnell genug, um in die Produktion zu gelangen, aber langsam genug, um diese Produktion einzustellen. <br><br>  Es gab Berichte, dass ein √§hnliches Problem bei einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">massiven L√∂schen von Dateien</a> auftritt, aber unsere Ablaufverfolgung zeigt nicht viele L√∂schungen an, so dass das Problem anscheinend nicht das ist. <br><br>  Abschlie√üend werde ich den systemweiten CPU-Ladeplan ab dem Anfang des Artikels duplizieren, diesmal jedoch die CPU-Auslastung durch den <i>Systemproblemprozess</i> angeben (unten in gr√ºn).  In einem solchen Bild ist das Problem v√∂llig offensichtlich.  Der Systemprozess ist im oberen Diagramm technisch sichtbar, in dieser Gr√∂√üenordnung jedoch leicht zu √ºbersehen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4fb/ca1/9ff/4fbca19ffabb57dd7f17d40417eee0ca.png"><br><br>  Obwohl das Problem in der Grafik deutlich sichtbar ist, beweist es tats√§chlich nichts.  Korrelation ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie sie sagen</a> , kein Kausalzusammenhang.  Nur eine Analyse von Kontextwechselereignissen zeigt, dass es dieser Stream ist, der die kritische Sperre h√§lt - und dann k√∂nnen Sie sicher sein, dass wir die tats√§chliche Ursache gefunden haben und nicht nur eine zuf√§llige Korrelation. <br><br><h2>  Anfragen </h2><br>  Wie √ºblich schlie√üe ich diese Untersuchung mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufruf ab, die Threads besser zu benennen</a> .  Der Systemprozess hat Dutzende von Threads, von denen viele einen speziellen Zweck haben und keiner einen Namen hat.  Der am st√§rksten frequentierte Systemthread in diesem Trace war <i>MiZeroPageThread</i> .  Ich st√ºrzte mich wiederholt in seinen Stapel und jedes Mal erinnerte ich mich, dass es nicht von Interesse war.  Der VC ++ - Compiler benennt auch seine Threads nicht.  Das Umbenennen der Streams nimmt nicht viel Zeit in Anspruch und ist sehr n√ºtzlich.  Gib einfach den Namen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es ist einfach</a> .  Chromium enth√§lt sogar ein Tool zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auflisten von Streamnamen in einem Prozess</a> . <br><br>  Wenn jemand aus dem NTFS-Team von Microsoft √ºber dieses Thema sprechen m√∂chte, lassen Sie es mich wissen, und ich kann Sie mit dem Autor des Originalberichts verbinden und eine ETW-Ablaufverfolgung bereitstellen. <br><br><h2>  Referenzen </h2><br><ul><li>  Urspr√ºnglicher <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter-Thread</a> <br></li><li>  Ank√ºndigung eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Twitter-</a> Posts <br></li><li>  Diskussion bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hacker News</a> <br></li><li>  Diskussion √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reddit</a> <br></li><li>  M√∂glicherweise relevante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Windows / NTFS-</a> Tirade </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472552/">https://habr.com/ru/post/de472552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472536/index.html">Smart IdReader SDK - Einbettungserkennung in Projekte in Python und PHP einbetten</a></li>
<li><a href="../de472540/index.html">Sie wachen auf! (n.-f. Geschichte, Teil 2 und die letzte)</a></li>
<li><a href="../de472544/index.html">Pornhub Marketing Tricks: Was die ber√ºhrendste Website von heute erz√§hlt</a></li>
<li><a href="../de472548/index.html">Wie wir auf den Markt gekommen sind (und nichts Besonderes erreicht haben)</a></li>
<li><a href="../de472550/index.html">Start eines IT-Gesch√§fts: Top 4 Tech Franchises von 2019</a></li>
<li><a href="../de472556/index.html">Das Geheimnis des Mitarbeitergl√ºcks ist die Natur im B√ºro?</a></li>
<li><a href="../de472560/index.html">Gestalttest: Ein neuer Ansatz zur Optimierung von Mailinglisten basierend auf der Bayes'schen Theorie und dem maschinellen Lernen</a></li>
<li><a href="../de472562/index.html">Finanztrends: Gro√üe Unternehmen brauchen immer mehr IT-Experten</a></li>
<li><a href="../de472566/index.html">Die pers√∂nliche H√∂lle des Schriftstellers Fraerman oder die Geschichte der ersten Liebe</a></li>
<li><a href="../de472568/index.html">Apache Ignite Zero Deployment: genau Null?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>