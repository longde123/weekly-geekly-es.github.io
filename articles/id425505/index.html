<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏻 🙉 👩🏾‍🏭 Analisis proses boot kernel Linux 🎅🏻 🖐🏾 👨🏿‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! 

 Sementara Leonid sedang mempersiapkan pelajaran terbuka pertamanya di kursus Administrator Linux kami, kami terus berbicara tentang ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Analisis proses boot kernel Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/425505/">  Halo semuanya! <br><br>  Sementara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Leonid</a> sedang mempersiapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelajaran terbuka</a> pertamanya di kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Administrator Linux</a> kami, kami terus berbicara tentang memuat kernel Linux. <br><br>  Ayo pergi! <br><br>  Memahami cara kerja sistem tanpa kegagalan - Bersiap untuk memperbaiki kerusakan yang tidak terhindarkan <br><br>  Lelucon tertua di bidang open source adalah pernyataan bahwa "kode itu mendokumentasikannya sendiri."  Pengalaman menunjukkan bahwa membaca kode sumber seperti mendengarkan ramalan cuaca: orang cerdas masih akan pergi ke luar dan melihat ke langit.  Di bawah ini adalah tip untuk memeriksa dan memeriksa boot sistem Linux menggunakan alat debugging yang sudah dikenal.  Analisis proses boot sistem yang berfungsi dengan baik mempersiapkan pengguna dan pengembang untuk menyelesaikan crash yang tidak terhindarkan. <br><br>  Di satu sisi, proses pengunduhan ternyata sangat sederhana.  Kernel dari sistem operasi (kernel) berjalan satu-threaded dan serentak pada satu inti (core), yang mungkin tampak dimengerti bahkan untuk pikiran manusia yang menyedihkan.  Tetapi bagaimana kernel OS dimulai?  Apa fungsi initrd ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disk RAM untuk inisialisasi awal</a> ) dan yang dilakukan bootloader?  Dan tunggu, mengapa LED pada port Ethernet selalu menyala? <br><br><img src="https://habrastorage.org/webt/dl/v5/cc/dlv5cchbiput5mmnbjyzz1nloho.png"><a name="habracut"></a><br><br>  Baca terus untuk mendapatkan jawaban untuk ini dan beberapa pertanyaan lainnya;  Kode untuk demo dan latihan yang dijelaskan juga tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br>  <b>Mulai boot: status OFF</b> <br><br>  <i><b>Wake-on-LAN</b></i> <br><br>  Status MATI berarti sistem tidak memiliki daya, bukan?  Kesederhanaan yang tampak menipu.  Misalnya, LED Ethernet menyala bahkan dalam kondisi ini, karena wake-on-LAN (WOL, wake-up [signal from] jaringan lokal) dihidupkan di sistem Anda.  Pastikan dengan menulis: <br><br><pre><code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool &lt;interface name&gt;</code> </pre> <br>  Di mana sebaliknya bisa, misalnya, eth0 (ethtool dalam paket Linux dengan nama yang sama).  Jika "Wake-on" pada output menunjukkan g, host jarak jauh dapat mem-boot sistem dengan mengirimkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MagicPacket</a> .  Jika Anda tidak ingin mengaktifkan sendiri sistem Anda dari jarak jauh dan memberikan kesempatan ini kepada orang lain, nonaktifkan WOL di menu BIOS sistem, atau menggunakan: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> sudo ethtool -s &lt;interface name&gt; wol d</code> </pre> <br>  Prosesor yang merespons MagicPacket dapat berupa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baseboard Management Controller</a> (BMC) atau bagian dari antarmuka jaringan. <br><br>  <i><b>Mesin Manajemen Intel, Platform Controller Hub, dan Minix</b></i> <br><br>  BMC bukan satu-satunya mikrokontroler (MCU) yang dapat "mendengarkan" sistem yang dimatikan secara nominal.  Sistem X86_64 memiliki paket perangkat lunak Intel Management Engine (IME) untuk manajemen sistem jarak jauh.  Berbagai perangkat, mulai dari server hingga laptop, memiliki teknologi yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memiliki fitur</a> seperti KVM Remote Control atau Layanan Kemampuan Intel.  Menurut alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Inte</a> l <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sendiri</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IME memiliki kerentanan yang belum ditambal.</a>  Berita buruknya adalah menonaktifkan IME itu sulit.  Trammell Hudson menciptakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek me_cleaner, yang menghapus</a> beberapa komponen IME yang paling mengerikan, seperti server web tertanam, tetapi pada saat yang sama ada kemungkinan bahwa menggunakan proyek tersebut akan mengubah sistem yang menjalankannya menjadi batu bata. <br><br>  Firmware IME dan program Mode Manajemen Sistem (SMM) yang mengikutinya saat boot didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem operasi Minix</a> dan berjalan pada prosesor Platform Controller Hub yang terpisah, bukan CPU utama dari sistem.  Kemudian SMM meluncurkan program Universal Extensible Firmware Interface (UEFI) pada prosesor utama, yang telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditulis lebih dari satu kali</a> .  Grup Coreboot meluncurkan proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Non-Extensible Reduced Firmware (NERF) yang</a> ambisius dan ambisius di Google, yang bertujuan untuk menggantikan tidak hanya UEFI, tetapi juga komponen awal ruang pengguna Linux, seperti systemd.  Sementara itu, kami menunggu hasilnya, pengguna Linux dapat membeli laptop dari Purism, System76 atau Dell, di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IME dinonaktifkan</a> , ditambah, kami dapat berharap untuk laptop dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prosesor ARM 64-bit</a> . <br><br>  <i><b>Loader</b></i> <i><b><br></b></i> <br>  Apa yang dilakukan firmware yang dapat di-boot selain meluncurkan spyware yang dicurigai?  Tugas bootloader adalah menyediakan prosesor yang baru saja dinyalakan dengan sumber daya yang diperlukan untuk menjalankan sistem operasi serba guna seperti Linux.  Selama power-up, tidak hanya memori virtual, tetapi juga DRAM sampai saat menaikkan pengontrolnya.  Bootloader kemudian menyalakan catu daya dan memindai bus dan antarmuka untuk menemukan gambar kernel dan sistem file root.  Bootloader populer, seperti U-Boot dan GRUB, mendukung kedua antarmuka umum seperti USB, PCI dan NFS, serta perangkat tertanam lainnya yang lebih khusus, seperti NOR- dan NAND-flash.  Loader juga berinteraksi dengan perangkat perangkat keras keamanan, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Trusted Platform Module (TPM)</a> , untuk membangun rantai kepercayaan sejak awal pengunduhan. <br><br><img src="https://habrastorage.org/webt/ur/fy/-n/urfy-neq9uuqezexjmitgdyg4aa.png"><br>  <i>Menjalankan U-boot loader di kotak pasir di server build.</i> <br><br>  Bootloader <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">U-Boot</a> open source yang populer didukung oleh sistem dari Raspberry Pi hingga perangkat Nintendo, papan mobil, dan Chromebook.  Tidak ada log sistem, dan jika terjadi kesalahan, bahkan mungkin tidak ada output konsol.  Untuk memudahkan debugging, tim U-Boot menyediakan kotak pasir untuk menguji tambalan pada build host atau bahkan dalam sistem Integrasi Berkelanjutan.  Pada sistem dengan alat pengembangan umum seperti Git dan GNU Compiler Collection (GCC) yang diinstal, memahami kotak pasir U-Boot itu mudah. <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://git.denx.de/u-boot; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> u-boot <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make ARCH=sandbox defconfig <span class="hljs-variable"><span class="hljs-variable">$#</span></span> make; ./u-boot =&gt; printenv =&gt; <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  Itu saja: Anda meluncurkan U-Boot pada x86_64 dan Anda dapat menguji fitur-fitur rumit, misalnya, partisi ulang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perangkat penyimpanan fiktif</a> , manipulasi kunci rahasia berbasis TPM, dan hotplug perangkat USB.  Kotak pasir U-Boot bisa satu tahap di dalam debugger GDB.  Pengembangan menggunakan kotak pasir adalah 10 kali lebih cepat daripada pengujian dengan menimpa bootloader di papan, ditambah, kotak pasir "bata" dapat dipulihkan dengan menekan Ctrl + C. <br><br>  <b>Peluncuran kernel</b> <br><br>  <i><b>Booting Pasokan Kernel</b></i> <br><br>  Setelah menyelesaikan tugasnya, bootloader akan beralih ke kode kernel yang dimuat ke dalam memori utama dan mulai menjalankannya, melewati semua parameter baris perintah yang ditentukan pengguna.  Program apa itu kernel?  file / boot / vmlinuz menunjukkan bahwa ini adalah bzImage.  Linux source tree memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat ekstrak-vmlinux</a> yang dapat Anda gunakan untuk mengekstrak file: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> scripts/extract-vmlinux /boot/vmlinuz-$(uname -r) &gt; vmlinux <span class="hljs-variable"><span class="hljs-variable">$#</span></span> file vmlinux vmlinux: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, stripped</code> </pre><br>  Kernel adalah file biner yang dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dieksekusi dan menautkan Format (ELF)</a> , seperti program ruang pengguna Linux.  Ini berarti bahwa kita dapat menggunakan perintah binutils seperti readelf untuk mempelajarinya.  Bandingkan, misalnya, kesimpulan berikut: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S /bin/date <span class="hljs-variable"><span class="hljs-variable">$#</span></span> readelf -S vmlinux</code> </pre><br>  Daftar partisi dalam file biner sebagian besar mirip. <br><br>  Jadi, kernel harus meluncurkan binari ELF Linux lainnya ... Tapi bagaimana program ruang pengguna dijalankan?  Dalam fungsi <code>main()</code> , kan?  Tidak juga. <br><br>  Sebelum menjalankan fungsi <code>main()</code> , program memerlukan konteks eksekusi, termasuk memori heap- (heap) dan stack- (stack), ditambah deskriptor file untuk <code>stdio</code> , <code>stdout</code> dan <code>stderr</code> .  Program ruang pengguna mendapatkan sumber daya ini dari perpustakaan standar ( <code>glibc</code> untuk sebagian besar sistem Linux).  Pertimbangkan yang berikut ini: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$#</span></span> file /bin/date /bin/date: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> GNU/Linux 2.6.32, BuildID[sha1]=14e8563676febeb06d701dbee35d225c5a8e565a, stripped</code> </pre> <br>  Binari ELF memiliki juru bahasa, seperti halnya skrip Bash dan Python.  Tapi itu tidak perlu ditentukan melalui <code>#!</code>  seperti pada skrip, karena ELF adalah format Linux asli.  Penerjemah ELF memasok file biner dengan semua sumber daya yang diperlukan dengan memanggil <code>_start()</code> , suatu fungsi yang tersedia dalam paket sumber <code>glibc</code> , yang dapat dipelajari melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GDB</a> .  Kernel, jelasnya, tidak memiliki juru bahasa, dan harus menyediakan sendiri secara independen, tetapi bagaimana caranya? <br><br>  Studi memulai kernel dengan GDB memberikan jawaban untuk pertanyaan ini.  Untuk memulai, instal paket debugging kernel, yang berisi versi <code>vmlinux</code> belum dipotong, misalnya, <code>apt-get install linux-image-amd64-dbg</code> .  Atau kompilasi dan instal kernel Anda sendiri dari beberapa sumber, misalnya, mengikuti instruksi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Handbook Debian Kernel yang</a> sangat baik.  <code>gdb vmlinux</code> diikuti oleh <code>info files</code> menunjukkan bagian ELF <code>init.text</code> .  Tunjukkan dimulainya eksekusi program di <code>init.text</code> dengan <code>l *(address)</code> , di mana alamat adalah awal <code>init.text</code> heksadesimal.  GDB akan menunjukkan bahwa kernel x86_64 diluncurkan dalam <code><a href="">arch/x86/kernel/head_64.S</a></code> , di mana kami menemukan fungsi build <code>start_cpu0()</code> dan kode yang secara eksplisit membuat stack dan mendekompresi zImage sebelum memanggil <code>x86_64 start_kernel()</code> .  Core ARM 32-bit memiliki <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code>  <code><a href="">arch/arm/kernel/head.S. start_kernel()</a></code> adalah arsitektur independen, sehingga fungsinya terletak di kernel <code>init/main.c</code>  Kita dapat mengatakan bahwa <code>start_kernel()</code> adalah fungsi Linux <code>main()</code> nyata. <br><br>  <b>Dari start_kernel () ke PID 1</b> <br>  <i><b>Manifestasi Perangkat Keras Kernel: ACPI Tabel dan Pohon Perangkat</b></i> <br><br>  Saat boot, kernel membutuhkan informasi tentang perangkat keras di samping jenis prosesor yang dikompilasi.  Instruksi dalam kode dilengkapi dengan data konfigurasi, yang disimpan secara terpisah.  Ada dua metode utama untuk menyimpan data: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pohon</a> perangkat dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel ACPI</a> .  Dari file-file ini, kernel menemukan peralatan apa yang perlu dijalankan pada setiap boot. <br><br>  Untuk perangkat tertanam, bagan perangkat (DU) adalah manifes dari peralatan yang dipasang.  DU adalah file yang mengkompilasi pada saat yang sama dengan sumber kernel dan biasanya terletak di / boot bersama dengan <code>vmlinux</code> .  Untuk melihat apa yang ada di pohon perangkat biner pada perangkat ARM, cukup gunakan perintah <code>strings</code> dari paket binutils dalam file yang namanya sesuai dengan <code>/boot/*.dtb</code> , karena <code>dtb</code> berarti file biner dari pohon perangkat (Device-Tree Binary).  Anda dapat mengubah remote control dengan mengedit file seperti JSON yang terdiri dari dan me-restart kompiler dtc khusus yang disediakan dengan sumber kernel.  DU adalah file statis yang jalurnya biasanya dilewatkan ke kernel oleh bootloader pada baris perintah, tetapi dalam beberapa tahun terakhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">overlay hierarki perangkat</a> telah ditambahkan di mana kernel dapat secara dinamis memuat fragmen tambahan sebagai tanggapan terhadap kejadian hotplug setelah memuat. <br><br>  Keluarga x86 dan banyak perangkat tingkat bisnis ARM64 menggunakan mekanisme Advanced Configuration and Power Interface ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ACPI)</a> alternatif.  Berbeda dengan remote control, informasi ACPI disimpan dalam sistem file virtual <code>/sys/firmware/acpi/tables</code> , yang dibuat oleh kernel saat startup dengan mengakses ROM internal.  Untuk membaca tabel ACPI, gunakan perintah <code>acpidump</code> dari paket <code>acpica-tools</code> .  Berikut ini sebuah contoh: <br><br><img src="https://habrastorage.org/webt/gq/gw/mj/gqgwmjbpkadcvz6fbzyp7uc8gvg.png"><br>  <i>Tabel ACPI pada laptop Lenovo siap untuk Windows 2001.</i> <br><br>  Ya, sistem Linux Anda siap untuk Windows 2001 jika Anda ingin menginstalnya.  ACPI memiliki kedua metode dan data, berbeda dengan remote control, yang lebih mirip bahasa deskripsi perangkat keras.  Metode ACPI terus aktif setelah boot.  Misalnya, jika Anda menjalankan perintah acpi_listen (dari paket apcid), lalu tutup dan buka tutup laptop, Anda akan melihat bahwa fungsi ACPI terus berfungsi selama ini.  Menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ulang</a> sementara dan dinamis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari tabel ACPI</a> dimungkinkan, tetapi perubahan permanen akan membutuhkan interaksi dengan menu BIOS saat boot atau flashing ROM.  Alih-alih kompleksitas seperti itu, mungkin Anda harus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menginstal coreboot</a> , pengganti firmware sumber terbuka. <br><br>  Dari start_kernel () ke ruang pengguna <br><br>  Kode di <code><a href="">init/main.c</a></code> secara mengejutkan mudah dibaca dan, anehnya, masih menggunakan hak cipta asli Linus Torvalds dari tahun 1991-1992.  Baris ditemukan di <code>dmesg | head</code>  <code>dmesg | head</code> sistem yang berjalan pada dasarnya berasal dari file sumber ini.  CPU pertama didaftarkan oleh sistem, struktur data global diinisialisasi, satu demi satu penjadwal, interrupt handler (IRQs), timer dan konsol dinaikkan.  Semua cap waktu sebelum menjalankan <code>timekeeping_init()</code> adalah nol.  Bagian inisialisasi kernel ini bersifat sinkron, artinya eksekusi hanya dilakukan dalam satu utas.  Fungsi tidak dieksekusi sampai yang terakhir selesai dan dikembalikan.  Akibatnya, output <code>dmesg</code> akan sepenuhnya dapat direproduksi bahkan di antara kedua sistem, selama mereka memiliki remote control atau tabel ACPI yang sama.  Linux juga berperilaku seperti sistem operasi waktu nyata (RTOS) yang berjalan pada MCU, seperti QNX atau VxWorks.  Situasi ini disimpan dalam fungsi <code>rest_init()</code> , yang dipanggil oleh <code>start_kernel()</code> pada saat penyelesaiannya. <br><br><img src="https://habrastorage.org/webt/dt/ge/49/dtge49gofpzdjlzk__surv1x9-o.png"><br>  <i>Deskripsi singkat tentang proses boot kernel awal</i> <i><br></i> <br>  <code>rest_init()</code> dengan nama sederhana <code>rest_init()</code> membuat utas baru yang menjalankan <code>kernel_init()</code> , yang kemudian memanggil <code>do_initcalls()</code> .  Pengguna dapat memantau operasi <code>initcalls</code> dengan menambahkan <code>initcalls_debug</code> ke baris perintah kernel.  Akibatnya, Anda akan mendapatkan entitas <code>dmesg</code> setiap kali Anda menjalankan fungsi <code>initcall</code> .  <code>initcalls</code> melewati tujuh level berturut-turut: awal, inti, postcore, lengkung, subsys, fs, perangkat dan belakangan.  Bagian yang paling nyata dari <code>initcalls</code> untuk pengguna adalah identifikasi dan pemasangan perangkat periferal prosesor: bus, jaringan, penyimpanan, tampilan, dan sebagainya, disertai dengan pemuatan modul kernel mereka.  <code>rest_init()</code> juga membuat utas kedua dalam prosesor boot, yang dimulai dengan menjalankan <code>cpu_idle()</code> sementara scheduler mendistribusikan pekerjaannya. <br><br>  <code>kernel_init()</code> juga mengatur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">symmetric multiprocessing</a> (SMP).  Di kernel modern, Anda dapat menemukan momen ini di output dmesg dengan baris "Membesarkan CPU sekunder ...".  SMP kemudian membuat hot-plug CPU, yang berarti bahwa ia mengelola siklus hidupnya menggunakan mesin negara yang secara kondisional mirip dengan yang digunakan dalam perangkat seperti USB memory-sensing sensing sticks.  Sistem manajemen daya kernel sering mematikan masing-masing core (core) dan membangunkannya sesuai kebutuhan sehingga kode CPU hotplug yang sama dipanggil berulang kali pada mesin yang tidak dihuni.  Lihatlah bagaimana sistem manajemen daya memanggil hotplug CPU menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat BCC yang</a> disebut <code>offcputime.py</code> . <br><br>  Perhatikan bahwa kode di <code>init/main.c</code> hampir selesai dieksekusi ketika <code>smp_init()</code> dijalankan.  Prosesor boot menyelesaikan sebagian besar inisialisasi satu kali, yang tidak perlu diulang oleh kernel lain.  Namun, utas harus dibuat untuk setiap inti agar dapat mengontrol interupsi (IRQ), workqueue, timer, dan peristiwa daya pada masing-masing.  Sebagai contoh, lihat thread prosesor yang melayani softirqs dan workqueues dengan perintah <code>ps -o psr.</code> <br><br><pre> <code class="bash hljs">$\<span class="hljs-comment"><span class="hljs-comment"># ps -o pid,psr,comm $(pgrep ksoftirqd) PID PSR COMMAND 7 0 ksoftirqd/0 16 1 ksoftirqd/1 22 2 ksoftirqd/2 28 3 ksoftirqd/3 $\# ps -o pid,psr,comm $(pgrep kworker) PID PSR COMMAND 4 0 kworker/0:0H 18 1 kworker/1:0H 24 2 kworker/2:0H 30 3 kworker/3:0H [ . . . ]</span></span></code> </pre> <br>  di mana bidang PSR berarti "prosesor".  Setiap inti harus memiliki pengatur waktu sendiri dan penangan hotplug cpuhp. <br><br>  Dan akhirnya, bagaimana ruang pengguna diluncurkan?  Menjelang akhir, <code>kernel_init()</code> mencari <code>initrd</code> yang dapat memulai proses <code>init</code> atas namanya.  Jika tidak, kernel mengeksekusi <code>init</code> sendiri.  Mengapa <code>initrd</code> mungkin dibutuhkan? <br><br>  <i><b>Ruang pengguna awal: siapa yang memesan initrd?</b></i> <br><br>  Selain bagan perangkat, jalur init lain ke file, secara opsional disediakan oleh kernel saat boot, milik <code>initrd</code> .  <code>initrd</code> sering terletak di / boot bersama dengan file bzImage vmlinuz pada x86, atau dengan uImage dan pohon perangkat serupa untuk ARM.  Daftar isi <code>intrd</code> dapat dilihat menggunakan alat <code>lsinitramfs</code> , yang merupakan bagian dari paket <code>initramfs-tools-core</code> .  Gambar distribusi initrd berisi direktori minimum <code>/bin</code> , <code>/sbin</code> dan <code>/etc</code> , serta modul kernel dan file dalam <code>/scripts</code> .  Semuanya harus tampak kurang asing, karena <code>initrd</code> sebagian besar mirip dengan sistem file root Linux yang disederhanakan.  Kesamaan ini agak menyesatkan, karena hampir semua file yang dapat dieksekusi di <code>/bin</code> dan <code>/sbin</code> di dalam ramdisk adalah symlink ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">biner BusyBox</a> , yang membuat direktori / bin dan / sbin 10 kali lebih kecil daripada di <code>glibc</code> . <br><br>  Mengapa mencoba membuat <code>initrd</code> jika satu-satunya yang dilakukannya adalah memuat beberapa modul dan menjalankan <code>init</code> pada sistem file root biasa?  Pertimbangkan sistem file root terenkripsi.  Dekripsi mungkin tergantung pada pemuatan modul kernel yang disimpan di <code>/lib/modules</code> sistem file root ... dan, seperti yang diharapkan, di <code>initrd</code> .  Modul crypto dapat dikompilasi secara statis ke dalam kernel, dan tidak dimuat dari file, tetapi ada beberapa alasan untuk menolaknya.  Sebagai contoh, kompilasi statis kernel dengan modul mungkin membuatnya terlalu besar untuk muat dalam penyimpanan yang tersedia, atau kompilasi statis dapat melanggar persyaratan lisensi perangkat lunak.  Tidak mengherankan, driver penyimpanan, jaringan, dan HID (perangkat input manusia) juga dapat diwakili dalam <code>initrd</code> - pada dasarnya setiap kode yang bukan merupakan bagian dari kernel yang diperlukan untuk me-mount sistem file root.  Juga di initrd, pengguna dapat menyimpan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode ACPI mereka sendiri untuk tabel</a> . <br><br><img src="https://habrastorage.org/webt/gx/nj/lj/gxnjljvh-gs47qpacftktsubl2e.png"><br>  <i>Bersenang-senang dengan shell penyelamatan dan initrd khusus.</i> <br><br>  <code>initrd</code> juga bagus untuk menguji sistem file dan perangkat penyimpanan.  Letakkan alat pengujian di <code>initrd</code> dan jalankan tes dari memori, bukan dari objek tes. <br><br>  Akhirnya, ketika <code>init</code> berjalan, sistem sedang berjalan!  Karena prosesor sekunder sudah berjalan, mesin tersebut telah menjadi makhluk yang tidak sinkron, berurutan, tidak dapat diprediksi, dan berkinerja tinggi yang kita semua kenal dan cintai.  Memang, <code>ps -o pid,psr,comm -p</code> menunjukkan bahwa proses <code>init</code> ruang pengguna tidak lagi berjalan pada prosesor boot. <br><br>  <b>Ringkasan</b> <br><br>  Proses boot Linux terdengar terlarang, mengingat jumlah perangkat lunak yang terpengaruh, bahkan pada perangkat embedded sederhana.  Di sisi lain, proses booting cukup sederhana, karena tidak ada kompleksitas berlebihan yang disebabkan oleh crowding out multitasking, RCU dan kondisi balapan.  Hanya memperhatikan kernel dan PID 1, orang dapat mengabaikan pekerjaan hebat yang dilakukan oleh boot loader dan prosesor tambahan untuk mempersiapkan platform untuk peluncuran kernel.  Kernel tentu berbeda dari program Linux lainnya, tetapi menggunakan alat untuk bekerja dengan binari ELF lainnya akan membantu untuk lebih memahami strukturnya.  Mempelajari proses boot yang bisa diterapkan akan mempersiapkan crash di masa depan. <br><br>  AKHIR <br><br>  Kami menunggu komentar dan pertanyaan Anda, seperti biasa, baik di sini atau di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelajaran terbuka</a> kami di mana Leonid akan terpesona. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425505/">https://habr.com/ru/post/id425505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425493/index.html">Mengkonfigurasi MikroTik hAP mini untuk IPTV Beeline</a></li>
<li><a href="../id425497/index.html">Tutu PHP Meetup # 2: Siaran Acara Langsung</a></li>
<li><a href="../id425499/index.html">HyperX Impact DDR4 - SO-DIMM yang bisa! Atau mengapa di laptop memori 64 GB dengan frekuensi 3200 MHz?</a></li>
<li><a href="../id425501/index.html">Tes A / B di Android dari A hingga Z</a></li>
<li><a href="../id425503/index.html">Cassandra Sink untuk Streaming Terstruktur Spark</a></li>
<li><a href="../id425507/index.html">Parsim Wikipedia untuk tugas NLP dalam 4 tim</a></li>
<li><a href="../id425511/index.html">Fitur-fitur aplikasi Rotativa yang tidak jelas untuk menghasilkan PDF dalam aplikasi ASP.NET MVC</a></li>
<li><a href="../id425515/index.html">Apple memblokir perbaikan independen model MacBook baru</a></li>
<li><a href="../id425517/index.html">Bagaimana Yandex membuat perkiraan curah hujan global menggunakan radar dan satelit</a></li>
<li><a href="../id425521/index.html">Metode yang Dilindungi dalam JavaScript ES5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>