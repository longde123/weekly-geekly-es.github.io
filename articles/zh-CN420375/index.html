<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📰 🈲 🙍🏾 学习OpenGL。 5.8课-布卢姆 🗡️ 🖐🏿 ✉️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="布卢姆 
 由于常规监视器可用的亮度范围有限，因此很难说服令人信服地显示明亮的光源和明亮的表面。 在监视器上突出显示明亮区域的常用方法之一是一种在明亮物体周围增加光晕的技术，使光在光源外部“散布”。 结果，观察者给人这种照明区域或光源高亮度的印象。 

 所描述的光晕和光从光源射出的效果是通过称为B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>学习OpenGL。 5.8课-布卢姆</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420375/"><img align="left" src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="OGL3" width="300"><h2> 布卢姆 </h2><br> 由于常规监视器可用的亮度范围有限，因此很难说服令人信服地显示明亮的光源和明亮的表面。 在监视器上突出显示明亮区域的常用方法之一是一种在明亮物体周围增加光晕的技术，使光在光源外部“散布”。 结果，观察者给人这种照明区域或光源高亮度的印象。 <br><br> 所描述的光晕和光从光源射出的效果是通过称为<i>Bloom</i>的后处理技术实现的。 应用效果会在显示的场景的所有明亮区域中添加特有的发光光晕，可以在以下示例中看到： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oi/qw/mj/oiqwmjiua0ogznqfllr0q9v53fc.png"></div><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">目录内容</b> <div class="spoiler_text"> 第1部分。入门 <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">窗口创建</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">你好窗口</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">你好三角形</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">着色器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">贴图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">转变</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">坐标系</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摄影机</a> </li></ol><br> 第2部分。基本照明 <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">色彩</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">照明基础</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">用料</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">纹理贴图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">光源</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">多种光源</a> </li></ol><br> 第3部分。下载3D模型 <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">阿辛普图书馆</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网格多边形类</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3D模型类</a> </li></ol><br> 第4部分。高级OpenGL功能 <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">深度测试</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">模板测试</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">混色</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">裁剪面</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">帧缓冲</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">立方卡</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先进的数据处理</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高级GLSL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">几何着色器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实例化</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">平滑处理</a> </li></ol><br> 第5部分。高级照明 <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">先进的照明。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Blinn-Fong模型。</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">伽玛校正</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">影子卡</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">全向阴影贴图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">法线贴图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视差映射</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">高动态范围</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">布卢姆</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">延迟渲染</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SSAO</a> </li></ol><br> 第6部分。PBR <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">理论</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分析光源</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">国际劳工联盟</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">漫反射。</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">国际劳工联盟</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">镜面曝光。</a> </li></ol><br></div></div><br>  Bloom会从图像上为图像增添独特的视觉线索，即光晕所覆盖物体的显着亮度。 通过选择性地并精确地应用（很多游戏，可惜无法应付），该效果可以显着改善场景中使用的照明的视觉表现力，并在某些情况下增加戏剧性。 <br><br> 这项技术与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HDR</a>渲染结合使用几乎是不言而喻的。 显然，因此，许多人错误地将这两个术语混为一谈，以实现完全互换性。 但是，这些技术是完全独立的，可用于不同的目的。 可以使用默认的具有8位色深的帧缓冲区来实现Bloom，就像应用HDR渲染而无需诉诸Bloom一样。 唯一的事情是HDR渲染使您能够以更有效的方式实现效果（我们将在后面看到）。 <br><br> 为了实现绽放，首先以常规方式渲染照明场景。 接下来，提取HDR颜色缓冲器和仅包含场景的明亮部分的颜色缓冲器。 然后，将提取的亮部分图像模糊并覆盖在场景的原始HDR图像上。 <br><br> 为了更加清楚，我们将逐步分析过程。 渲染包含4个明亮的光源的场景，显示为彩色立方体。 它们的亮度值都在1.5到15.0的范围内。 如果将颜色缓冲区输出到HDR，则结果如下： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_2/_h/wn/_2_hwnque0owtvpdcyh_vo_p9pg.png"></div><br> 从此HDR颜色缓冲区中，我们提取亮度超过预定限制的所有片段。 结果是只包含明亮区域的图像： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/q7/jb/uz/q7jbuz_9apwuc9cb2jzpe4a-4si.png"></div><br> 此外，明亮区域的图像模糊。 效果的严重程度基本上取决于所应用的模糊滤镜的强度和半径： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5u/cv/b7/5ucvb73pzpcbvbrn2pcp5khu1_i.png"></div><br> 明亮区域产生的模糊图像是明亮物体周围光环最终效果的基础。 该纹理仅与场景的原始HDR图像混合。 由于明亮的区域模糊，因此它们的大小增加了，最终提供了超出光源范围的光度视觉效果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wq/pt/lx/wqptlxwywvag8dzh0dck64yzrbg.png"></div><br> 如您所见，bloom不是最复杂的技术，但是实现其高视觉质量和可靠性并不总是那么容易。 在大多数情况下，效果取决于所应用的模糊滤镜的质量和类型。 即使过滤器参数发生很小的变化，也会极大地改变设备的最终质量。 <br><br> 因此，以上动作为我们提供了针对光晕效果的后处理效果的分步算法。 下图总结了所需的操作： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t7/kt/pz/t7ktpzzm8bo_ccpmh70uu5x0rye.png"></div><br> 首先，我们需要基于给定的阈值获取有关场景明亮部分的信息。 这就是我们要做的。 <br><br><h2> 提取亮点 </h2><br> 因此，对于初学者来说，我们需要根据场景获取两个图像。 渲染两次会很幼稚，但是使用更高级的“ <i>多重渲染目标”</i> （ <i>MRT</i> ）方法：我们在最终的片段着色器中指定了多个输出，因此，一次可以提取两个图像！ 若要指定将在哪个颜色缓冲区中输出着色器，请使用<i>布局</i>说明符： <br><br><pre><code class="cpp hljs">layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) out vec4 FragColor; layout (location = <span class="hljs-number"><span class="hljs-number">1</span></span>) out vec4 BrightColor;</code> </pre> <br> 当然，该方法仅在我们准备好几个写入缓冲区的情况下才有效。 换句话说，要实现片段着色器的多个输出，此刻使用的帧缓冲区应包含足够数量的已连接颜色缓冲区。 如果我们转向有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">帧缓冲区</a>的课程，那么可以回想一下，将纹理绑定为颜色缓冲区时，我们可以指示<i>颜色附加编号</i> 。 到目前为止，我们不需要使用<i>GL_COLOR_ATTACHMENT0</i>以外的附件，但是这次<i>GL_COLOR_ATTACHMENT1将派</i>上用场，因为我们需要一次记录两个目标： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       unsigned int hdrFBO; glGenFramebuffers(1, &amp;hdrFBO); glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO); unsigned int colorBuffers[2]; glGenTextures(2, colorBuffers); for (unsigned int i = 0; i &lt; 2; i++) { glBindTexture(GL_TEXTURE_2D, colorBuffers[i]); glTexImage2D( GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); //     glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, colorBuffers[i], 0 ); }</span></span></code> </pre> <br> 另外，通过调用<i>glDrawBuffers</i> ，您将需要明确告诉OpenGL我们将输出到多个缓冲区。 否则，该库仍将仅输出到第一个附件，而忽略对其他附件的写入操作。 作为该函数的参数，传递了来自相应枚举的已使用附件的标识符的数组： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 }; glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments);</code> </pre> <br> 对于此帧缓冲区，任何为其输出指定<i>位置</i>说明符的片段着色器都将写入相应的颜色缓冲区。 这是个好消息，因为这样就避免了不必要的渲染过程来提取有关场景明亮部分的数据-您可以在一个着色器中一次完成所有操作： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) out vec4 FragColor; layout (location = 1) out vec4 BrightColor; [...] void main() { [...] </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      FragColor = vec4(lighting, 1.0); //         //   -    ,    float brightness = dot(FragColor.rgb, vec3(0.2126, 0.7152, 0.0722)); if(brightness &gt; 1.0) BrightColor = vec4(FragColor.rgb, 1.0); else BrightColor = vec4(0.0, 0.0, 0.0, 1.0); }</span></span></span></span></code> </pre> <br> 在此片段中，省略了包含用于计算照明的典型代码的部分。 其结果将写入着色器的第一个输出<i>-FragColor</i>变量。 接下来，片段的所得颜色用于计算亮度值。 为此，进行了灰度级的加权平移（通过标量乘法，我们将向量的相应分量相乘并将它们相加在一起，从而得到单个值）。 然后，当超过某个阈值的片段的亮度超过时，我们将其颜色记录在着色器的第二个输出中。 对于替换光源的立方体，还将执行此着色器。 <br><br> 弄清楚了算法之后，我们可以理解为什么这种技术在HDR渲染中如此有效。 使用HDR格式进行渲染时，颜色分量可以超过1.0的上限，这使您可以在标准间隔[0.，1.]之外更灵活地调整亮度阈值，从而可以微调场景中被认为是明亮的部分。 如果不使用HDR，您将必须满足[0.，1.]区间的亮度阈值，这是可以接受的，但是会导致亮度的“锐利”截止，这通常会使绽放的效果过于刺眼和浮华（想象自己在高山雪场上） 。 <br><br> 在执行着色器后，两个目标缓冲区将包含场景的普通图像以及仅包含明亮区域的图像。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hp/rf/pr/hprfprhsu9v4q6_gvhhg43leup4.png"></div><br> 现在应该使用模糊处理明亮区域的图像。 您可以使用一个简单的矩形（ <i>框形</i> ）过滤器来完成此操作，该过滤器在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">帧缓冲区</a>课程的后处理部分中使用过。 但是通过<i>高斯滤波</i>可以获得更好的结果。 <br><br><h2> 高斯模糊 </h2><br> 后处理课程为我们提供了使用相邻图像片段的简单颜色平均进行模糊处理的想法。 这种模糊方法很简单，但是生成的图像可能看起来更具吸引力。 高斯模糊基于同名的钟形分布曲线：函数的较高值位于曲线的中心附近，并且落在曲线的两侧。 在数学上，高斯曲线可以用不同的参数表示，但是曲线的一般形式仍然如下： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0o/xq/eq/0oxqeqhhsip9d0iai3eit6cpooo.png"></div><br> 基于高斯曲线值的权重模糊看起来比矩形滤镜好得多：由于该曲线在其中心附近具有较大的面积，这对应于滤芯中心附近的片段的权重较大。 以32x32内核为例，我们将使用权重因子越小，则片段离中央片段越远。 正是这种滤波器特性在视觉上提供了令人满意的高斯模糊效果。 <br><br> 滤波器的实现将需要一个加权系数的二维数组，该数组可以基于描述高斯曲线的二维表达式进行填充。 但是，我们将立即遇到性能问题：即使32x32片段中的模糊核心相对较小，处理后的图像的每个片段也需要1024个纹理样本！ <br><br> 对我们来说幸运的是，高斯曲线的表达式具有非常方便的数学特性-可分离性，这将使从一个描述水平分量和垂直分量的二维表达式中生成两个一维表达式成为可能。 这将允许依次采用两种方法进行模糊处理：水平，然后垂直使用对应于每个方向的权重集进行模糊。 生成的图像与处理二维算法时的图像相同，但是所需的视频处理器处理能力要低得多：我们不需要纹理中的1024个样本，而只需32 + 32 = 64！ 这是两遍高斯滤波的本质。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/my/aq/3gmyaqmqfsy1rk3hegbx_4s5rpc.png"></div><br> 对我们来说，所有这些都意味着一件事：一张图像的模糊将必须进行两次，并且在这里使用帧缓冲对象将非常方便。 我们应用所谓的乒乓技术：有几个帧缓冲区对象，并且通过一些处理将一个帧缓冲区的颜色缓冲区的内容渲染到当前帧缓冲区的颜色缓冲区中，然后将源帧缓冲区和帧缓冲区接收器互换，并重复此过程给定次数。 实际上，仅切换了用于显示图像的当前帧缓冲区，并由此切换了从中执行采样以进行渲染的当前纹理。 该方法允许您通过将原始图像放在第一个帧缓冲区中来对其进行模糊处理，然后对第一个帧缓冲区的内容进行模糊处理，然后将其放在第二个中，然后对第二个图像进行模糊处理，然后将其放在第一个中，依此类推。 <br><br> 在转到帧缓冲区调整代码之前，让我们看一下高斯模糊着色器代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D image; uniform bool horizontal; uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216); void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     vec2 tex_offset = 1.0 / textureSize(image, 0); //    vec3 result = texture(image, TexCoords).rgb * weight[0]; if(horizontal) { for(int i = 1; i &lt; 5; ++i) { result += texture(image, TexCoords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; result += texture(image, TexCoords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; } } else { for(int i = 1; i &lt; 5; ++i) { result += texture(image, TexCoords + vec2(0.0, tex_offset.y * i)).rgb * weight[i]; result += texture(image, TexCoords - vec2(0.0, tex_offset.y * i)).rgb * weight[i]; } } FragColor = vec4(result, 1.0); }</span></span></span></span></code> </pre> <br> 如您所见，我们使用了一个很小的高斯曲线系数样本，用作相对于当前片段水平或垂直采样的权重。 该代码有两个主要分支，它们根据<i>水平</i>均匀值将算法分为垂直和水平通过。 每个样本的偏移设置为等于纹理像素大小，该纹理大小定义为纹理大小的倒数（由<i>textureSize</i> （）函数返回的<i>vec2</i>类型的值）。 <br><br> 创建两个基于纹理的帧缓冲区，其中包含一个颜色缓冲区： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pingpongFBO[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pingpongBuffer[<span class="hljs-number"><span class="hljs-number">2</span></span>]; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, pingpongFBO); glGenTextures(<span class="hljs-number"><span class="hljs-number">2</span></span>, pingpongBuffer); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[i]); glBindTexture(GL_TEXTURE_2D, pingpongBuffer[i]); glTexImage2D( GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_RGB, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, pingpongBuffer[i], <span class="hljs-number"><span class="hljs-number">0</span></span> ); }</code> </pre> <br> 在获得场景的HDR纹理并提取明亮区域的纹理之后，我们用亮度纹理填充一对准备好的帧缓冲区之一的颜色缓冲区，并开始乒乓处理十次（垂直五次，水平五次）： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> horizontal = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, first_iteration = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = <span class="hljs-number"><span class="hljs-number">10</span></span>; shaderBlur.use(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; amount; i++) { glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[horizontal]); shaderBlur.setInt(<span class="hljs-string"><span class="hljs-string">"horizontal"</span></span>, horizontal); glBindTexture( GL_TEXTURE_2D, first_iteration ? colorBuffers[<span class="hljs-number"><span class="hljs-number">1</span></span>] : pingpongBuffers[!horizontal] ); RenderQuad(); horizontal = !horizontal; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (first_iteration) first_iteration = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br> 在每次迭代时，我们基于此迭代是水平还是垂直模糊来选择和锚定一个帧缓冲区，然后将另一个帧缓冲区的颜色缓冲区用作模糊着色器的输入纹理。 在第一次迭代中，我们必须显式地使用包含明亮区域的图像（ <i>BrightnessTexture</i> ）-否则两个乒乓帧缓冲区都将保持空白。 经过十次传递后，原始图像采用了由完整的高斯滤镜模糊处理五次的形式。 使用的方法使我们可以轻松地更改模糊程度：乒乓迭代次数越多，模糊程度就越强。 <br><br> 在我们的例子中，模糊结果看起来像这样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2j/du/ga/2jdugaud8hudvnsz8pkdjgaqvus.png"></div><br> 为了完成效果，仅需将模糊图像与场景的原始HDR图像结合在一起。 <br><br><h2> 纹理融合 </h2><br> 拥有渲染场景的HDR纹理和过度曝光区域的模糊纹理之后，您要实现著名的光晕效果或光晕，只需要将这两个图像组合即可。 最终的片段着色器（与本课程中有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HDR</a>格式的着色器非常相似）就是这样做的-它可将两种纹理加在一起： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D scene; uniform sampler2D bloomBlur; uniform float exposure; void main() { const float gamma = 2.2; vec3 hdrColor = texture(scene, TexCoords).rgb; vec3 bloomColor = texture(bloomBlur, TexCoords).rgb; hdrColor += bloomColor; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// additive blending //   vec3 result = vec3(1.0) - exp(-hdrColor * exposure); //     - result = pow(result, vec3(1.0 / gamma)); FragColor = vec4(result, 1.0); }</span></span></span></span></code> </pre> <br> 查找内容：混合是在应用<i>色调映射</i>之前完成的。 这将正确地将效果中的额外亮度转换为LDR（ <i>低动态范围</i> ）范围，同时保持场景中的相对亮度分布。 <br><br> 处理的结果-所有亮区均收到明显的发光效果： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ye/ga/s7/yegas7stvrwhww7-a_rzdu3g_lk.png"></div><br> 现在，替换光源的多维数据集看起来更亮，可以更好地传达光源的印象。 这个场景是很原始的，因为不会引起特殊热情的影响，但是在复杂的场景中，如果考虑周到的灯光，定性实现的绽放可能是增加戏剧性的关键视觉元素。 <br><br> 示例的源代码在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a> 。 <br><br> 我注意到，该课程使用了一个非常简单的过滤器，每个方向上只有五个样本。 通过在更大的半径中制作更多的样本或对滤镜进行几次迭代，可以从视觉上改善效果。 同样，值得一提的是，视觉上整个效果的质量直接取决于所使用的模糊算法的质量。 通过改进过滤器，可以实现显着的改进和整体效果。 例如，将几个具有不同磁芯尺寸或不同高斯曲线的滤波器组合在一起，将显示出更令人印象深刻的结果。 以下是Kalogirou和EpicGames的其他资源，这些资源介绍了如何通过修改高斯模糊来改善光晕质量。 <br><br><h2> 其他资源 </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">带有线性采样的高效高斯模糊</a> ：对高斯滤波器操作的定性描述，以及通过使用纹理样本OpenGL的双线性滤波来提高方法性能的研究。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Bloom Post Process Effect</a> ：EpicGames的一篇文章，通过合并多个高斯曲线来提高效果的质量。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何为HDR渲染实现良好</a>的光晕<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">效果</a> ：Kalogirou的一篇文章描述了通过修改原始的高斯滤波器算法来改善光晕效果。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420375/">https://habr.com/ru/post/zh-CN420375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420363/index.html">8月至10月的HPE网络研讨会：新主题（+ SHD，AI实践，交钥匙PB存储）</a></li>
<li><a href="../zh-CN420367/index.html">空调启示：智能电网停电情况</a></li>
<li><a href="../zh-CN420369/index.html">极端扩展边缘或IEEE 802.1BR交换</a></li>
<li><a href="../zh-CN420371/index.html">关于电子邮件存储领域中的自行车建设问题</a></li>
<li><a href="../zh-CN420373/index.html">几乎OCR即可获得VPNBook密码。 PHP + Mikrotik</a></li>
<li><a href="../zh-CN420377/index.html">我们如何开始视频通话</a></li>
<li><a href="../zh-CN420381/index.html">为什么将神经网络视为黑匣子就足够了？</a></li>
<li><a href="../zh-CN420383/index.html">“ Yandex.Money对您输入应用程序不感兴趣。”</a></li>
<li><a href="../zh-CN420385/index.html">基于容器的集成测试</a></li>
<li><a href="../zh-CN420387/index.html">三种智能魔方：小米，Roobo和GoCube</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>