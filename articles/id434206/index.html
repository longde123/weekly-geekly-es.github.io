<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎓 📙 🌦️ Distributor jet ok.ru/music 🈶 🧗🏾 👰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya bekerja di tim platform Odnoklassniki dan hari ini saya akan berbicara tentang arsitektur, desain, dan detail implementasi layanan distribusi mus...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Distributor jet ok.ru/music</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/434206/"><img src="https://habrastorage.org/webt/m8/yb/sn/m8ybsnu0c1bqakexungs-hkisui.png"><br><br>  Saya bekerja di tim platform Odnoklassniki dan hari ini saya akan berbicara tentang arsitektur, desain, dan detail implementasi layanan distribusi musik. <br><a name="habracut"></a><br><blockquote>  Artikel ini adalah transkrip dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Joker 2018</a> . </blockquote><br><h1>  Beberapa statistik </h1><br>  Pertama, beberapa kata tentang OK.  Ini adalah layanan raksasa yang digunakan oleh lebih dari 70 juta pengguna.  Mereka dilayani oleh 7 ribu mobil di 4 pusat data.  Baru-baru ini, kami telah menembus tanda lalu lintas pada 2 Tb / s tanpa memperhitungkan banyak situs CDN.  Kami memeras maksimal dari perangkat keras kami, layanan paling banyak melayani hingga 100.000 permintaan per detik dari simpul quad-core.  Apalagi hampir semua layanan ditulis di Jawa. <br><br>  Ada banyak bagian di OK, salah satu yang paling populer adalah "Musik".  Di dalamnya, pengguna dapat mengunggah trek mereka, membeli dan mengunduh musik dengan kualitas yang berbeda.  Bagian ini memiliki katalog yang luar biasa, sistem rekomendasi, radio dan banyak lagi.  Tetapi tujuan utama dari layanan ini, tentu saja, adalah memainkan musik. <br><br>  Distributor musik bertanggung jawab untuk mentransfer data ke pemutar pengguna dan aplikasi seluler.  Anda dapat menangkapnya di inspektur web jika Anda melihat permintaan ke domain musicd.mycdn.me.  API distributor sangat sederhana.  Ini menanggapi <code>GET</code> permintaan HTTP dan mengeluarkan rentang trek yang diminta. <br><br><img src="https://habrastorage.org/webt/j9/va/ze/j9vazesvr2fuqtpvhec0uj7gbmq.png"><br><br>  Pada puncaknya, beban mencapai 100 Gb / s hingga setengah juta koneksi.  Faktanya, distributor musik adalah tampilan cache di depan repositori trek internal kami, yang didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">One Blob Storage</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">One Cold Storage</a> dan berisi petabytes data. <br><br>  Karena saya sudah bicara tentang caching, mari kita lihat statistik pemutaran.  Kami melihat TOP yang diucapkan. <br><br><img src="https://habrastorage.org/webt/q6/jv/pc/q6jvpcopw2t0xt29sl84lwp1gkg.png"><br><br>  Sekitar 140 lagu mencakup 10% dari semua permainan per hari.  Jika kita ingin server caching kita memiliki cache hit setidaknya 90%, maka kita perlu memasukkan setengah juta track.  95% - hampir satu juta lagu. <br><br><h1>  Persyaratan Distributor </h1><br>  Tujuan apa yang kami tetapkan saat mengembangkan versi distributor selanjutnya? <br><br>  Kami ingin satu simpul untuk dapat menampung 100 ribu koneksi.  Dan ini adalah koneksi klien yang lambat: sekelompok browser dan aplikasi seluler melalui jaringan dengan kecepatan yang bervariasi.  Pada saat yang sama, layanan, seperti semua sistem kami, harus dapat diukur dan toleran terhadap kesalahan. <br><br>  Pertama-tama, kita perlu skala bandwidth cluster untuk mengimbangi semakin populernya layanan dan dapat memberikan lebih banyak dan lebih banyak lalu lintas.  Hal ini juga diperlukan untuk dapat mengukur kapasitas total cache cluster, karena cache hit dan persentase permintaan yang akan jatuh ke dalam penyimpanan trek secara langsung bergantung padanya. <br><br>  Saat ini perlu untuk dapat skala sistem terdistribusi secara horizontal, yaitu, menambahkan mesin dan pusat data.  Tetapi kami juga ingin menerapkan penskalaan vertikal.  Server modern khas kami berisi 56 core, 0,5-1 TB RAM, antarmuka jaringan 10 atau 40 Gb dan selusin disk SSD. <br><br>  Berbicara tentang skalabilitas horizontal, efek yang menarik muncul: ketika Anda memiliki ribuan server dan puluhan ribu disk, sesuatu yang terus-menerus rusak.  Kegagalan disk adalah rutin, kami mengubahnya dengan 20-30 lembar per minggu.  Dan kegagalan server tidak mengejutkan siapa pun; 2-3 mobil sehari diganti.  Saya juga harus berurusan dengan kegagalan pusat data, misalnya, pada 2018 ada tiga kegagalan seperti itu, dan ini mungkin bukan yang terakhir. <br><br>  Kenapa aku semua ini?  Ketika kita merancang sistem apa pun, kita tahu bahwa mereka akan rusak cepat atau lambat.  Oleh karena itu, kami selalu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mempelajari dengan cermat</a> skenario kegagalan semua komponen sistem.  Cara utama untuk mengatasi kegagalan adalah melalui replikasi data: beberapa salinan data disimpan pada node yang berbeda. <br><br>  Kami juga memesan bandwidth jaringan.  Ini penting karena jika komponen sistem gagal, itu tidak dapat diizinkan untuk memuat pada komponen yang tersisa untuk runtuh. <br><br><h1>  Menyeimbangkan </h1><br>  Pertama, Anda perlu mempelajari cara menyeimbangkan kueri pengguna antara pusat data, dan melakukannya secara otomatis.  Ini kalau-kalau Anda perlu melakukan pekerjaan jaringan, atau jika pusat data telah gagal.  Tetapi keseimbangan juga dibutuhkan di dalam pusat data.  Dan kami ingin mendistribusikan permintaan antar node tidak secara acak, tetapi dengan bobot.  Misalnya, ketika kami mengunggah versi baru dari suatu layanan dan ingin dengan lancar memasukkan simpul baru ke dalam rotasi.  Bobot juga banyak membantu selama pengujian stres: kami menambah berat badan dan meletakkan beban yang jauh lebih berat pada simpul untuk memahami batas kemampuannya.  Dan ketika sebuah simpul gagal di bawah beban, kami dengan cepat menurunkan berat dan menghapusnya dari rotasi menggunakan mekanisme penyeimbang. <br><br>  Seperti apa tampilan jalur permintaan dari pengguna ke simpul, yang akan mengembalikan data dengan mempertimbangkan penyeimbangan akun? <br><br><img src="https://habrastorage.org/webt/uu/tz/uf/uutzuf3bnfpetnns91ca-rcf5mc.png"><br><br>  Pengguna masuk melalui situs web atau aplikasi seluler dan menerima URL trek: <br><br> <code>musicd.mycdn.me/v0/stream?id=...</code> <br> <br>  Untuk mendapatkan alamat IP dari nama host di URL, klien menghubungi DNS GSLB kami, yang mengetahui semua pusat data dan situs CDN kami.  DNS GSLB memberikan klien alamat IP penyeimbang dari salah satu pusat data, dan klien membuat koneksi dengannya.  Penyeimbang tahu tentang semua node di dalam pusat data dan beratnya.  Itu, atas nama pengguna, membuat koneksi dengan salah satu node.  Kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan penyeimbang L4 berbasis N4Ware</a> .  Noda memberikan data pengguna secara langsung, melewati penyeimbang.  Dalam layanan seperti distributor, lalu lintas keluar secara signifikan lebih tinggi dari yang masuk. <br><br>  Jika pusat data macet, GSLB DNS mendeteksi ini dan dengan cepat menghapusnya dari rotasi: berhenti memberikan pengguna alamat IP penyeimbang pusat data ini.  Jika sebuah simpul di pusat data gagal, maka bobotnya diatur ulang, dan penyeimbang di dalam pusat data berhenti mengirim permintaan ke sana. <br><br>  Sekarang pertimbangkan untuk menyeimbangkan trek dengan node di dalam pusat data.  Kami akan mempertimbangkan pusat data sebagai unit otonom independen, masing-masing akan hidup dan bekerja, bahkan jika semua yang lain mati.  Track harus diseimbangkan di seluruh mesin secara merata sehingga tidak ada distorsi beban, dan mereplikasi mereka ke node yang berbeda.  Jika satu simpul gagal, beban harus didistribusikan secara merata di antara yang tersisa. <br><br>  Masalah ini dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diselesaikan dengan berbagai cara</a> .  Kami sepakat pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hashing yang konsisten</a> .  Kami membungkus seluruh rentang hash pengidentifikasi trek yang mungkin dalam sebuah cincin, dan kemudian setiap trek ditampilkan pada suatu titik pada cincin ini.  Kemudian kami kurang lebih mendistribusikan rentang cincin secara merata di antara node-node dalam cluster.  Node yang akan menyimpan trek dipilih dengan hashing trek ke titik di atas ring dan bergerak searah jarum jam. <br><br><img src="https://habrastorage.org/webt/qr/ty/xf/qrtyxfbchjhlp5taqfs0fbicnk0.jpeg"><br><br>  Tetapi skema semacam itu memiliki kelemahan: jika terjadi kegagalan simpul N2, misalnya, seluruh bebannya akan jatuh pada replika berikutnya di cincin - N3.  Dan jika tidak memiliki margin ganda dalam kinerja - dan ini tidak dibenarkan secara ekonomi - maka, kemungkinan besar, simpul kedua juga akan memiliki waktu yang buruk.  N3 dengan tingkat probabilitas tinggi akan berkembang, beban akan menuju N4, dan seterusnya - akan ada kegagalan kaskade di sepanjang keseluruhan cincin. <br><br>  Masalah ini dapat diatasi dengan meningkatkan jumlah replika, tetapi kemudian total kapasitas yang berguna dari cluster di cincin berkurang.  Karena itu, kami melakukan sebaliknya.  Dengan jumlah node yang sama, cincin dibagi menjadi sejumlah besar rentang yang secara acak tersebar di sekitar cincin.  Replika untuk trek dipilih sesuai dengan algoritma di atas. <br><br><img src="https://habrastorage.org/webt/kc/uf/5-/kcuf5-1mmekp60d5emkp5ckkgps.png"><br><br>  Dalam contoh di atas, setiap node bertanggung jawab untuk dua rentang.  Jika salah satu node gagal, seluruh bebannya tidak akan terletak pada node berikutnya di ring, tetapi akan didistribusikan di antara dua node lainnya dari cluster. <br><br>  Cincin dihitung berdasarkan sekelompok kecil parameter secara algoritmik dan ditentukan pada setiap node.  Artinya, kita tidak menyimpannya dalam semacam konfigurasi.  Kami memiliki lebih dari seratus ribu rentang produksi ini, dan jika terjadi kegagalan pada salah satu simpul, beban didistribusikan secara merata antara semua simpul hidup lainnya. <br><br>  Seperti apa jalur balik ke pengguna dalam sistem dengan hashing yang konsisten? <br><br>  Pengguna melalui L4-balancer mendapatkan simpul acak.  Pemilihan simpul adalah acak, karena penyeimbang tidak tahu apa-apa tentang topologi.  Tapi kemudian setiap replika di cluster tahu tentang itu.  Node yang menerima permintaan menentukan apakah itu merupakan replika dari trek yang diminta.  Jika tidak, ia beralih ke mode proxy dengan salah satu replika, membuat koneksi dengannya, dan mencari data di penyimpanan lokalnya.  Jika trek tidak ada, replika menariknya dari track store, menyimpannya ke toko lokal dan memberikan proxy, yang mengarahkan ulang data ke pengguna. <br><br><img src="https://habrastorage.org/webt/c5/pu/wl/c5puwlig-lfxy20leny4y4utqig.png"><br><br>  Jika drive dalam replika gagal, data dari penyimpanan akan ditransfer langsung ke pengguna.  Dan jika replika gagal, maka proxy tahu tentang semua replika lain untuk trek ini, itu akan membuat koneksi dengan replika langsung lain dan menerima data dari itu.  Jadi, kami menjamin bahwa jika pengguna meminta trek dan setidaknya satu replika masih hidup, ia akan menerima respons. <br><br><h1>  Bagaimana cara kerja simpul? </h1><br><img src="https://habrastorage.org/webt/2m/up/ob/2mupob-rqyqsbic50lc-qn2xwqe.png"><br><br>  Node adalah pipa dari serangkaian tahapan yang dilewati permintaan pengguna.  Pertama, permintaan masuk ke API eksternal (kami mengirim semuanya melalui HTTPS).  Kemudian permintaan divalidasi - tanda tangan diverifikasi.  Kemudian tag IDv3 dibangun jika perlu, misalnya, saat membeli trek.  Permintaan menuju ke tahap routing, di mana berdasarkan topologi cluster ditentukan bagaimana data akan dikembalikan: apakah node saat ini adalah replika untuk lagu ini, atau kami akan proksi dari node lain.  Dalam kasus kedua, simpul melalui klien proksi membuat koneksi ke replika melalui API HTTP internal tanpa verifikasi tanda tangan.  Replika mencari data di penyimpanan lokal, jika menemukan trek, lalu memberikannya dari disknya;  dan jika tidak, ia menarik trek dari penyimpanan, menyimpan dan memberi. <br><br><h1>  Beban simpul </h1><br>  Mari kita perkirakan beban yang harus dimiliki oleh satu simpul dalam konfigurasi ini.  Mari kita memiliki tiga pusat data dengan masing-masing empat node. <br><br><img src="https://habrastorage.org/webt/in/-z/nz/in-znz1gekgg217y9oxdlm5pv-g.png"><br><br>  Seluruh layanan harus melayani 120 Gbit / s, yaitu, 40 Gbit / s per pusat data.  Misalkan networkers membuat manuver atau kecelakaan terjadi, dan ada dua pusat data DC1 dan DC3 yang tersisa.  Sekarang masing-masing dari mereka harus memberikan 60 Gbit / s.  Tapi di sini terserah kepada pengembang untuk meluncurkan beberapa pembaruan, di setiap pusat data ada 3 node yang tersisa dan masing-masing dari mereka harus memberikan 20 Gbit / s. <br><br><img src="https://habrastorage.org/webt/6q/tc/sz/6qtcszoeoi4w1zjxvh_o1u35vni.png"><br><br>  Namun pada awalnya di setiap pusat data ada 4 node.  Dan jika kita menyimpan dua replika di pusat data, maka dengan probabilitas 50%, simpul yang menerima permintaan tidak akan menjadi replika trek yang diminta dan akan mem-proxy data.  Yaitu, setengah dari lalu lintas di dalam pusat data diproksikan. <br><br><img src="https://habrastorage.org/webt/yi/aj/tc/yiajtck3angspynaidxuar_t5gm.png"><br><br>  Jadi, satu node harus memberi pengguna 20 Gb / s.  Dari jumlah tersebut, 10 Gb / s itu menarik dari tetangganya di pusat data.  Tetapi skemanya simetris: node memberikan 10 Gb / s yang sama ke tetangga di pusat data.  Ternyata 30 Gbit / s keluar dari node, yang 20 Gbit / s harus diservis dengan sendirinya, karena ini adalah replika dari data yang diminta.  Selain itu, data akan berasal dari disk atau dari RAM, yang menampung sekitar 50 ribu trek "panas".  Berdasarkan statistik pemutaran kami, ini memungkinkan Anda untuk menghapus 60-70% dari beban dari disk, dan akan tetap sekitar 8 Gb / s.  Utas ini cukup mampu menghadirkan selusin SSD. <br><br><h1>  Penyimpanan data pada suatu node </h1><br>  Jika Anda menempatkan setiap lagu dalam file yang terpisah, maka biaya pengelolaan file-file ini akan sangat besar.  Bahkan merestart node dan memindai data pada disk akan memakan waktu beberapa menit, jika tidak puluhan menit. <br><br>  Ada batasan yang kurang jelas untuk skema ini.  Misalnya, Anda dapat memuat trek hanya dari awal.  Dan jika pengguna meminta pemutaran dari tengah dan cache tidak terjawab, maka kami tidak akan dapat mengirim satu byte sampai kami memuat data ke lokasi yang diinginkan dari repositori trek.  Selain itu, kita dapat menyimpan trek hanya secara keseluruhan, bahkan jika itu adalah buku audio raksasa yang mereka berhenti mendengarkan pada menit ketiga.  Ini akan terus membebani hard disk, membuang ruang yang mahal dan mengurangi hit cache dari node ini. <br><br>  Oleh karena itu, kami melakukannya dengan cara yang sama sekali berbeda: kami membagi trek menjadi 256 KB blok, karena ini berkorelasi dengan ukuran blok di SSD, dan kami sudah beroperasi dengan blok-blok ini.  Disk 1 TB berisi 4 juta blok.  Setiap disk dalam sebuah node adalah penyimpanan independen, dan semua blok dari setiap track didistribusikan di semua disk. <br><br>  Kami tidak segera sampai pada skema seperti itu, pada awalnya semua blok dari satu track terletak pada satu disk.  Tapi ini menyebabkan distorsi yang kuat dari beban antara disk, karena jika lagu populer menabrak salah satu disk, semua permintaan untuk datanya akan pergi ke satu disk.  Untuk mencegah hal ini, kami mendistribusikan blok setiap trek di semua disk, menyeimbangkan beban. <br><br>  Selain itu, kami tidak lupa bahwa kami memiliki banyak RAM, tetapi kami memutuskan untuk tidak melakukan cache semantik, karena kami memiliki cache halaman yang luar biasa di Linux. <br><br>  Bagaimana cara menyimpan blok pada disk? <br><br>  Pertama kami memutuskan untuk mendapatkan satu file XFS raksasa seukuran disk dan meletakkan semua blok di dalamnya.  Kemudian muncul ide untuk bekerja dengan perangkat blok secara langsung.  Kami menerapkan kedua opsi, membandingkannya dan ternyata ketika bekerja secara langsung dengan perangkat blok, perekaman 1,5 kali lebih cepat, waktu respons 2-3 kali lebih rendah, total beban sistem 2 kali lebih rendah. <br><br><h1>  Indeks </h1><br>  Tetapi itu tidak cukup untuk dapat menyimpan blok, Anda perlu mempertahankan indeks dari blok trek musik ke blok pada disk. <br><br><img src="https://habrastorage.org/webt/me/4y/0b/me4y0bk_xbwco9r_5y6smyhmxmc.png"><br><br>  Ternyata cukup kompak, satu entri indeks hanya membutuhkan 29 byte.  Untuk penyimpanan 10 TB, indeksnya sedikit di atas 1 GB. <br><br>  Ada satu hal yang menarik di sini.  Dalam setiap catatan seperti itu, Anda harus menyimpan ukuran total seluruh trek.  Ini adalah contoh klasik denasionalisasi.  Alasannya adalah bahwa, sesuai dengan spesifikasi dalam respons rentang HTTP, kami harus mengembalikan ukuran total sumber daya, serta membentuk header Panjang Konten.  Jika bukan ini, maka semuanya akan menjadi lebih kompak. <br><br>  Kami merumuskan sejumlah persyaratan untuk indeks: untuk bekerja dengan cepat (lebih disukai, disimpan dalam RAM), agar ringkas dan tidak memakan ruang pada cache halaman.  Indeks lain harus persisten.  Jika kita kehilangan itu, kita akan kehilangan informasi tentang di mana pada disk lagu mana yang disimpan, dan ini sama saja dengan membersihkan disk.  Dan secara umum, saya ingin blok-blok lama, yang sudah lama tidak diakses, untuk digantikan, membuat ruang untuk trek yang lebih populer.  Kami telah memilih kebijakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">crowding-out LRU</a> : blok-blok ramai keluar satu menit sekali, 1% blok tetap bebas.  Tentu saja, struktur indeks harus aman dari thread, karena kami memiliki 100 ribu koneksi per node.  Semua kondisi ini secara ideal dipenuhi oleh <code>SharedMemoryFixedMap</code> dari pustaka sumber terbuka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu-nio</a> kami. <br><br>  Kami menempatkan indeks pada <code>tmpfs</code> , ia bekerja dengan cepat, tetapi ada nuansa.  Ketika mesin restart, semua yang ada di <code>tmpfs</code> , termasuk indeks, hilang.  Selain itu, jika karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code> sun.misc.Unsafe</code></a> proses kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code> sun.misc.Unsafe</code></a> tidak jelas dalam keadaan apa indeks tetap.  Karena itu, kami membuat kesan sekali dalam satu jam.  Tetapi ini tidak cukup: karena kami menggunakan ekstrusi blok, kami harus mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WAL</a> , di mana kami menulis informasi tentang blok yang diekstrusi.  Entri tentang blok dalam gips dan WAL perlu diurutkan entah bagaimana selama pemulihan.  Untuk melakukan ini, kami menggunakan blok generasi.  Ia memainkan peran sebagai penghitung transaksi global dan bertambah setiap kali indeks berubah.  Mari kita lihat contoh cara kerjanya. <br><br>  Ambil indeks dengan tiga entri: dua blok trek No. 1 dan satu blok trek No. 2. <br><br><img src="https://habrastorage.org/webt/l6/ux/51/l6ux512_lbpedki0bb3g0ouggau.png"><br><br>  Aliran pembuatan gips terbangun dan diiterasi oleh indeks ini: tupel pertama dan kedua jatuh ke gips.  Kemudian aliran crowding beralih ke indeks, menyadari bahwa blok ketujuh belum diakses untuk waktu yang lama, dan memutuskan untuk menggunakannya untuk hal lain.  Proses memaksa blok keluar dan menulis catatan ke WAL.  Dia dapat memblokir 9, melihat bahwa dia belum dihubungi untuk waktu yang lama, dan juga menandainya sebagai ramai keluar.  Di sini pengguna mengakses sistem dan terjadi cache miss - trek diminta yang tidak kami miliki.  Kami menyimpan blok lagu ini di repositori kami, menimpa blok 9.  Dalam hal ini, generasi bertambah dan menjadi sama dengan 22. Selanjutnya, proses membuat cetakan diaktifkan, yang belum menyelesaikan pekerjaannya, mencapai catatan terakhir dan menulisnya ke cetakan.  Akibatnya, kami memiliki dua rekaman langsung dalam indeks, pemeran dan WAL. <br><br><img src="https://habrastorage.org/webt/sy/vj/0_/syvj0_-kknmn4i5pulf_p8bclc4.png"><br><br>  Ketika node saat ini jatuh, itu akan mengembalikan keadaan awal indeks sebagai berikut.  Pertama, pindai WAL dan buat peta blok kotor.  Kartu menyimpan pemetaan dari nomor blok ke generasi ketika blok ini digantikan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9p/g5/gn/9pg5gn-8atbixm4swmytkscxwpm.png" width="300"></div><br><br>  Setelah itu, kita mulai beralih ke cetakan menggunakan peta sebagai filter.  Kami melihat catatan pertama para pemeran, yang berkaitan dengan memblokir nomor 3.  Dia tidak disebutkan di antara yang kotor, yang berarti dia masih hidup dan masuk ke dalam indeks.  Kita dapat memblokir nomor 7 dengan generasi kedelapan belas, tetapi peta blok yang kotor memberi tahu kita bahwa hanya pada generasi ke-18 blok itu dihadang.  Karena itu, tidak masuk dalam indeks.  Kita sampai pada catatan terakhir, yang menggambarkan isi blok 9 dengan 22 generasi.  Blok ini disebutkan dalam peta blok kotor, tetapi digantikan sebelumnya.  Jadi, ini digunakan kembali untuk data baru dan masuk ke dalam indeks.  Tujuan tercapai. <br><br><h1>  Optimalisasi </h1><br>  Tapi bukan itu saja, kita turun lebih dalam. <br><br>  Mari kita mulai dengan cache halaman.  Kami mengandalkannya pada awalnya, tetapi ketika kami mulai melakukan pengujian memuat versi pertama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ternyata</a> tingkat hit cache halaman tidak mencapai 20%.  Mereka menyarankan bahwa masalahnya dibaca di depan: kami tidak menyimpan file, tetapi memblokir, sambil melayani banyak koneksi, dan dalam konfigurasi ini, bekerja dengan disk secara efisien efisien.  Kami hampir tidak pernah membaca apa pun secara berurutan.  Untungnya, di Linux ada panggilan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>posix_fadvise</code></a> yang memungkinkan Anda untuk memberi tahu kernel bagaimana kita akan bekerja dengan deskriptor file - khususnya, kita dapat mengatakan bahwa kita tidak perlu membaca ke depan dengan melewati flag <code>POSIX_FADV_RANDOM</code> .  Panggilan sistem ini tersedia melalui <a href="">one-nio</a> .  Dalam operasi, hit cache kami adalah 70-80%.  Jumlah pembacaan fisik dari disk menurun lebih dari 2 kali, keterlambatan respons HTTP menurun 20%. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita melangkah lebih jauh. </font><font style="vertical-align: inherit;">Layanan ini memiliki ukuran tumpukan yang agak besar. </font><font style="vertical-align: inherit;">Untuk membuat hidup lebih mudah untuk cache TLB prosesor, kami memutuskan untuk memasukkan Huge Pages untuk proses Java kami. </font><font style="vertical-align: inherit;">Akibatnya, kami mendapat keuntungan nyata untuk waktu pengumpulan sampah (Waktu GC / Total Waktu Safepoint adalah 20-30% lebih rendah), pemuatan kernel menjadi lebih seragam, tetapi tidak melihat adanya pengaruh pada grafik latensi HTTP.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Insiden </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segera setelah layanan dimulai, satu-satunya (sejauh) insiden terjadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suatu malam setelah akhir hari kerja, keluhan tentang bermain musik dituangkan dalam dukungan. Pengguna menulis bahwa mereka memasukkan lagu favorit mereka, tetapi setiap beberapa detik mereka mendengar musik aneh dari waktu dan orang lain, dan pemain mengatakan kepada mereka bahwa itu memainkan lagu favorit mereka. Cukup cepat mempersempit lingkaran pencarian ke satu mobil, yang memberi sesuatu yang aneh. Kami menemukan dari log bahwa itu baru saja dimulai kembali. Untuk mempermudah, kami memiliki dua disk dan indeks yang menggambarkan isi blok. Satu indeks mengatakan bahwa blok keempat dari trek Daft Punk terletak di blok nomor 2 dari disk sdc, dan blok nol dari trek Stas Mikhailov terletak di blok nol dari disk sdd.</font></font><br><br><img src="https://habrastorage.org/webt/9q/pu/9g/9qpu9gxbc-uph2jp7tsjkup4b5a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ternyata setelah me-reboot mesin, nama drive berubah tempat dengan semua konsekuensi berikutnya. </font><font style="vertical-align: inherit;">Masalah ini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terkenal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di Linux </font><font style="vertical-align: inherit;">: jika ada beberapa pengontrol disk di server, maka urutan penamaan disk tidak dijamin. </font></font><br><br><img src="https://habrastorage.org/webt/3s/y-/vm/3sy-vmtyncu3miiwjhzyu0j9xi4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbaiki ternyata sederhana. </font><font style="vertical-align: inherit;">Ada beberapa jenis ID persisten untuk disk. </font><font style="vertical-align: inherit;">Kami menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WWN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berdasarkan nomor seri disk dan menggunakannya untuk mengidentifikasi indeks, snapshot, dan WAL. </font><font style="vertical-align: inherit;">Ini tidak mengecualikan pengocokan disk itu sendiri, tetapi tidak peduli bagaimana mereka mengocok, pemetaan indeks pada disk tidak akan dilanggar dan kami akan selalu memberikan data yang benar.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Analisis insiden </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis masalah dalam sistem terdistribusi seperti itu sulit karena permintaan pengguna melewati banyak tahap dan melintasi batas-batas node. Dalam hal CDN, semuanya menjadi lebih rumit, karena untuk CDN, hulu adalah pusat data rumah. Mungkin ada banyak harapan seperti itu. Selain itu, sistem melayani ratusan ribu koneksi pengguna. Cukup sulit untuk memahami pada tahap apa ada masalah dengan pemrosesan permintaan dari pengguna tertentu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menyederhanakan hidup kami seperti ini. Saat masuk, kami menandai semua permintaan dengan tag yang mirip dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open Tracing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zipkin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tag ini mencakup pengidentifikasi pengguna, permintaan, dan trek yang diminta. </font><font style="vertical-align: inherit;">Tag ini di dalam pipeline ditransmisikan dengan semua data dan permintaan yang terkait dengan koneksi saat ini, dan antar node ditransmisikan sebagai header HTTP dan dipulihkan oleh sisi penerima. </font><font style="vertical-align: inherit;">Saat kami perlu mengatasi masalah, kami mengaktifkan debugging, mencatat tag, menemukan semua catatan yang terkait dengan pengguna tertentu atau melacak, mengagregasi dan mencari tahu bagaimana permintaan diproses sepanjang jalan melalui cluster.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengirim data </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertimbangkan skema khas untuk mengirim data dari disk ke soket. </font><font style="vertical-align: inherit;">Sepertinya tidak ada yang rumit: pilih buffer, baca dari disk ke buffer, kirim buffer ke soket.</font></font><br><br><pre> <code class="java hljs">ByteBuffer buffer = ByteBuffer.allocate(size); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = fileChannel.read(buffer, position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ... } buffer.flip(); socketChannel.write(buffer);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Salah satu masalah dengan pendekatan ini adalah bahwa dua salinan data tersembunyi disembunyikan di sini: </font></font><br><br><ul><li>       <code>FileChannel.read()</code>    kernel space  user space; </li><li>            <code>SocketChannel.write()</code> ,    user space  kernel space. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untungnya, ada panggilan di Linux </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>sendfile()</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang memungkinkan Anda untuk meminta kernel untuk mengirim data dari file ke soket dari offset tertentu secara langsung, melewati penyalinan ke ruang pengguna. Dan tentu saja, panggilan ini tersedia melalui </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one-nio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pada tes beban, kami memulai lalu lintas pengguna pada satu node dan memaksa proxy dari node tetangga, yang mengirim data hanya melalui </font></font><code>sendfile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- beban prosesor pada 10 Gb / s </font></font><code>sendfile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mendekati 0 </font><font style="vertical-align: inherit;">saat digunakan </font><font style="vertical-align: inherit;">, </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tetapi dalam kasus soket SSL ruang-pengguna, kami tidak bisa manfaatkan </font></font><code>sendfile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan kami tidak punya pilihan selain mengirim data dari file melalui buffer. Dan di sini kita punya kejutan lain. Jika Anda mempelajari sumber </font></font><code>SocketChannel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>FileChannel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, atau menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async Profiler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan sistem poprofilirovat dalam proses data kembali dengan cara ini, cepat atau lambat Anda mendapatkan ke kelas </font></font><code>sun.nio.ch.IOUtil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mendidih turun semua panggilan </font></font><code>read()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan </font></font><code>write()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada saluran ini. Kode semacam itu disembunyikan di sana.</font></font><br><br><pre> <code class="java hljs">ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = readIntoNativeBuffer(fd, bb, position, nd); bb.flip(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) dst.put(bb); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Util.offerFirstTemporaryDirectBuffer(bb); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah kumpulan buffer asli. </font><font style="vertical-align: inherit;">Saat Anda membaca dari file di tumpukan </font></font><code>ByteBuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pertama perpustakaan standar mengambil buffer dari kumpulan ini, membaca data ke dalamnya, lalu menyalinnya ke tumpukan Anda </font></font><code>ByteBuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan mengembalikan buffer asli kembali ke kumpulan. </font><font style="vertical-align: inherit;">Saat menulis ke soket, hal yang sama terjadi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skema kontroversial. </font><font style="vertical-align: inherit;">Di sini </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one-nio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> datang untuk menyelamatkan lagi </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami membuat pengalokasi </font></font><code>MallocMT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- sebenarnya, ini adalah kumpulan memori. </font><font style="vertical-align: inherit;">Jika kami memiliki SSL dan kami terpaksa mengirim data melalui buffer, lalu pilih buffer di luar Java heap, bungkus </font></font><code>ByteBuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, baca tanpa menyalin tambahan dari </font></font><code>FileChannel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buffer ini dan menulis ke soket. </font><font style="vertical-align: inherit;">Dan kemudian kita mengembalikan buffer ke pengalokasi.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Allocator allocator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MallocMT(size, concurrency); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Socket socket)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (socket.getSslContext() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> address = allocator.malloc(size); ByteBuffer buf = DirectMemory.wrap(address, size); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> available = channel.read(buf, offset); socket.writeRaw(address, available, flags);</code> </pre><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 100.000 koneksi per node </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi keberhasilan sistem tidak dijamin dengan implementasi yang masuk akal di tingkat bawah. Ada masalah lain di sini. Konveyor pada setiap node melayani hingga 100 ribu koneksi simultan. Bagaimana mengatur perhitungan dalam sistem seperti itu? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal pertama yang terlintas dalam pikiran adalah untuk membuat utas eksekusi untuk setiap klien atau koneksi, dan di dalamnya kami melakukan tahapan pipa satu demi satu. Jika perlu, blokir, lalu pindah. Tetapi dengan skema seperti itu, biaya konteks beralih dan tumpukan arus akan berlebihan, karena kita berbicara tentang distributor dan ada banyak aliran. Karena itu, kami pergi ke arah lain.</font></font><br><br><img src="https://habrastorage.org/webt/mt/vg/eo/mtvgeoszcpcv6zpc-qi_rbqeyhy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pipa logis dibuat untuk setiap koneksi, yang terdiri dari tahapan-tahapan yang saling berinteraksi secara asinkron. Setiap tahap memiliki giliran yang menyimpan permintaan yang masuk. Untuk pelaksanaan tahapan, kolam thread umum kecil digunakan. Jika Anda perlu memproses pesan dari antrian permintaan, kami mengambil aliran dari kumpulan, memproses pesan dan mengembalikan aliran ke kumpulan. Dengan skema ini, data didorong dari penyimpanan ke klien.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi skema semacam itu bukan tanpa cacat. Backends jauh lebih cepat daripada koneksi pengguna. Ketika data melewati pipa, itu terakumulasi dalam tahap paling lambat, yaitu pada tahap penulisan blok ke soket koneksi klien. Cepat atau lambat, ini akan menyebabkan runtuhnya sistem. Jika Anda mencoba membatasi antrian pada tahap-tahap ini, maka semuanya akan langsung terhenti, karena jaringan pipa dalam rantai ke soket pengguna akan diblokir. Dan karena mereka menggunakan kumpulan utas bersama, mereka akan memblokir semua utas di dalamnya. Perlu tekanan balik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melakukan ini, kami menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aliran jet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Inti dari pendekatan ini adalah bahwa pelanggan mengontrol kecepatan data yang berasal dari penerbit menggunakan permintaan. Permintaan berarti berapa banyak lagi data yang siap diproses pelanggan bersama dengan permintaan sebelumnya yang telah diisyaratkannya. Penerbit memiliki hak untuk mengirim data, tetapi tidak melebihi total akumulasi permintaan saat ini, minus data yang sudah dikirim.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan demikian, sistem secara dinamis beralih antara mode push dan pull. </font><font style="vertical-align: inherit;">Dalam mode push, pelanggan lebih cepat dari penerbit, artinya penerbit selalu memiliki permintaan yang tidak memuaskan dari pelanggan, tetapi tidak ada data. </font><font style="vertical-align: inherit;">Segera setelah data muncul, ia segera mengirimkannya ke pelanggan. </font><font style="vertical-align: inherit;">Mode tarikan terjadi ketika penerbit lebih cepat dari pelanggan. </font><font style="vertical-align: inherit;">Artinya, penerbit akan senang mengirim data, hanya permintaan nol. </font><font style="vertical-align: inherit;">Segera setelah pelanggan mengatakan siap memproses sedikit lagi, penerbit segera mengirimkannya sepotong data sebagai bagian dari permintaan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konveyor kami berubah menjadi aliran jet. </font><font style="vertical-align: inherit;">Setiap tahap berubah menjadi penerbit untuk tahap sebelumnya dan pelanggan untuk tahap berikutnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka stream jet terlihat sangat sederhana. </font></font><code>Publisher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mari masuk</font></font><code>Subscriber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan ia seharusnya hanya menerapkan empat penangan: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br> <code>Subscription</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memungkinkan Anda memberi sinyal permintaan dan berhenti berlangganan. </font></font> Tidak ada tempat yang lebih mudah. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai elemen data, kami tidak melewatkan array byte, tetapi abstraksi seperti chunk. </font><font style="vertical-align: inherit;">Kami melakukan ini agar tidak menyeret keluar data di heap, jika memungkinkan. </font><font style="vertical-align: inherit;">Chunk adalah tautan data dengan antarmuka yang sangat terbatas yang memungkinkan Anda hanya membaca data </font></font><code>ByteBuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menulis ke soket, atau ke file.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chunk</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteBuffer dst)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Socket socket)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FileChannel channel, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ada banyak implementasi chunks: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang paling populer, yang digunakan dalam kasus cache hit dan ketika mengirim data dari disk, adalah implementasi di atas </font></font><code>RandomAccessFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Potongan hanya berisi tautan ke file, offset dalam file ini dan ukuran data. </font><font style="vertical-align: inherit;">Ia melewati seluruh pipa, mencapai soket koneksi pengguna, dan di sana berubah menjadi panggilan </font></font><code>sendfile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Artinya, memori tidak dikonsumsi sama sekali.</font></font></li><li>   cache miss   :             .     , —  ,     , —      . </li><li> ,    -      heap.        <code>ByteBuffer</code> . </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terlepas dari kesederhanaan API ini, harus aman menurut spesifikasi, dan sebagian besar metode harus non-pemblokiran. </font><font style="vertical-align: inherit;">Kami memilih jalur dalam semangat Model Aktor yang Diketik, terinspirasi oleh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contoh-contoh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repositori </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aliran jet </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">resmi</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Untuk membuat pemanggilan metode non-pemblokiran, saat kita memanggil metode, kita mengambil semua parameter, membungkusnya dalam pesan, memasukkannya ke dalam antrian untuk dieksekusi, dan mengembalikan kontrol. </font><font style="vertical-align: inherit;">Pesan dari antrian diproses secara ketat secara berurutan.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanpa sinkronisasi, kodenya sederhana dan mudah.</font></font></b> <div class="spoiler_text">     .   publisher  subscriber   ,    ,   executor,       . <code>AtomicBoolean</code>  happens before   . <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Incoming messages final Queue&lt;M&gt; mailbox; // Message processing works here final Executor executor; // To ensure HB relationship between runs final AtomicBoolean on = new AtomicBoolean();</span></span></code> </pre> <br>    : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ enqueue(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(n)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enqueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> M message)</span></span></span><span class="hljs-function"> </span></span>{ mailbox.offer(message); tryScheduleToExecute(); }</code> </pre> <br>  <code>tryScheduleToExecute()</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (on.compareAndSet(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { executor.execute(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { ... } }</code> </pre> <br>  <code>run()</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (on.get()) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dequeueAndProcess(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { on.set(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!messages.isEmpty()) { tryScheduleToExecute(); } } }</code> </pre> <br>  <code>dequeueAndProcess()</code> : <br><br><pre> <code class="java hljs">M message; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((message = mailbox.poll()) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Pattern match if (message instanceof Request) { doRequest(((Request) message).n); } else { … } }</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mendapat implementasi yang sepenuhnya non-pemblokiran. </font><font style="vertical-align: inherit;">Kode sederhana dan konsisten, tanpa </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Atomic*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pertengkaran, dan lain-lain. </font><font style="vertical-align: inherit;">Di seluruh sistem kami, ada total 200 utas untuk melayani 100.000 koneksi.</font></font><br><br><h1>  Pada akhirnya </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam produksi, kami memiliki 12 mesin, sementara ada lebih dari margin ganda dalam bandwidth. Setiap mesin dalam mode normal memberikan hingga 10 Gbit / s melalui ratusan ribu koneksi. Kami telah menyediakan skalabilitas dan ketahanan. Semuanya ditulis dalam Java dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one-nio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/oa/pz/cq/oapzcqjf6y9ccxrnk1wzrpaigdy.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah grafik hingga byte pertama yang diberikan kepada pengguna dari sisi server. 99 persentil kurang dari 20 ms. Grafik biru adalah kembalinya data HTTPS ke pengguna. Grafik merah adalah kembalinya data dari replika ke proxy melalui </font></font><code>sendfile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebenarnya, cache hit dalam produksi adalah 97%, sehingga grafik menggambarkan latensi repositori trek kami, dari mana kami menarik data jika ada cache yang hilang, yang juga tidak buruk, mengingat petabyte data.</font></font><br><br><img src="https://habrastorage.org/webt/xp/fd/eq/xpfdequddx6cnglrzrgdxtbspuc.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda melihat persentil ke-75 ketika kembali dari disk, maka byte pertama terbang ke pengguna setelah 1 ms. </font><font style="vertical-align: inherit;">Replika di dalam cluster berkomunikasi dengan kecepatan yang lebih besar - mereka bertanggung jawab atas 300 μs.</font></font> Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,7 ms adalah biaya proksi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam artikel ini, kami ingin menunjukkan bagaimana kami membangun sistem yang terukur dan sarat muatan yang memiliki kecepatan tinggi dan toleransi kesalahan yang sangat baik. </font><font style="vertical-align: inherit;">Kami berharap kami berhasil.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434206/">https://habr.com/ru/post/id434206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434194/index.html">Pengembangan keterampilan untuk Alice. Pengalaman dengan antarmuka suara, kiat untuk pemula</a></li>
<li><a href="../id434196/index.html">3CX v16 Alpha 2 dan rencana untuk tahun baru</a></li>
<li><a href="../id434198/index.html">Memilih mode operasi server web berdasarkan pengalaman pribadi</a></li>
<li><a href="../id434200/index.html">Apakah Rust begitu mengerikan seperti yang dilukis</a></li>
<li><a href="../id434202/index.html">4 rahasia tentang bagaimana tidak kehilangan pekerjaan Anda dalam ilmu data</a></li>
<li><a href="../id434208/index.html">Bagaimana Cara Menyelamatkan Black Friday Kami</a></li>
<li><a href="../id434210/index.html">Analisis kontes kuis Android dari stand HeadHunter di Mobius 2018 Moscow</a></li>
<li><a href="../id434212/index.html">Menara Tesla. Apa yang terjadi di dalam dan di dekat gedung pencakar langit ketika terjadi sambaran petir?</a></li>
<li><a href="../id434214/index.html">Java dynamic proxy: apa itu dan bagaimana menggunakannya?</a></li>
<li><a href="../id434216/index.html">Serangan brutal menggunakan Kali Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>