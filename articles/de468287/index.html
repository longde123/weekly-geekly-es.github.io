<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÆ üßùüèª üë©üèø‚ÄçüöÄ C # -Attribute: √úber alle Aspekte üò¥ üö£üèΩ üë®‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Leser. Dieser Artikel beschreibt Attribute von allen Seiten - angefangen bei der Spezifikation, Bedeutung und Definition von Attributen √ºber das...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # -Attribute: √úber alle Aspekte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468287/">  Hallo Leser.  Dieser Artikel beschreibt Attribute von allen Seiten - angefangen bei der Spezifikation, Bedeutung und Definition von Attributen √ºber das Erstellen eigener Attribute und deren Arbeit bis hin zum Hinzuf√ºgen von Attributen zur Laufzeit und den n√ºtzlichsten und interessantesten vorhandenen Attributen.  Wenn Sie sich f√ºr das Thema Attribute in C # interessieren, sind Sie bei cat willkommen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u4/uk/ee/u4ukeefozvzkxjtgw9i8zbap6ly.jpeg"></div><a name="habracut"></a><br><h2>  Inhalt </h2><br><ol><li>  Einf√ºhrung  Attribute definieren und zuweisen </li><li>  Interessante Attribute mit Laufzeitunterst√ºtzung.  Hier werden kurze Informationen zu verschiedenen Attributen gegeben, deren Existenz nur wenige Menschen kennen und noch weniger diejenigen, die sie verwenden.  Da dies absolut unpraktische Informationen sind, wird es nicht viel Schimpfen geben (entgegen meiner Leidenschaft f√ºr nicht anwendbares Wissen) </li><li> Einige der wenig bekannten Attribute, die n√ºtzlich sind, um sie zu kennen. </li><li>  Definieren Sie Ihr Attribut und verarbeiten Sie es.  Hinzuf√ºgen von Attributen zur Laufzeit </li></ol><br><h2>  Einf√ºhrung </h2><br>  Beginnen Sie wie immer mit Definitionen und Spezifikationen.  Dies wird dazu beitragen, die Attribute auf allen Ebenen zu verstehen und zu realisieren, was wiederum sehr n√ºtzlich ist, um die richtigen Anwendungen f√ºr sie zu finden. <br><br>  Definieren Sie zun√§chst Metadaten.  <b>Metadaten</b> sind Daten, die von <abbr title="Common Type System">CTS</abbr> definierte Typen beschreiben und auf diese verweisen.  Metadaten werden unabh√§ngig von einer bestimmten Programmiersprache gespeichert.  Daher bieten Metadaten einen allgemeinen Mechanismus f√ºr den Austausch von Informationen √ºber ein Programm zur Verwendung zwischen Tools, die dies erfordern (Compiler und Debugger sowie das Programm selbst) sowie zwischen <abbr title="Virtuelles Ausf√ºhrungssystem">VES</abbr> .  Metadaten sind im Assemblymanifest enthalten.  Sie k√∂nnen in einer <abbr title="Tragbare ausf√ºhrbare Datei">PE-</abbr> Datei zusammen mit <abbr title="Zwischensprache">IL-</abbr> Code oder in einer separaten PE-Datei gespeichert werden, in der nur ein Assembly-Manifest vorhanden ist. <br>  <b>Ein Attribut</b> ist ein Merkmal eines Typs oder seiner Mitglieder (oder anderer Sprachkonstrukte), das beschreibende Informationen enth√§lt.  Obwohl die h√§ufigsten Attribute vordefiniert sind und ein bestimmtes Format in den Metadaten haben, k√∂nnen den Metadaten auch benutzerdefinierte Attribute hinzugef√ºgt werden.  Attribute sind kommutativ, d.h.  Die Reihenfolge ihrer Deklaration √ºber das Element ist unwichtig <br><br>  <b>Aus syntaktischer Sicht (in Metadaten) gibt es die folgenden Attribute</b> <br><br><ol><li>  Verwendung einer speziellen Syntax in IL.  Schl√ºsselw√∂rter sind beispielsweise Attribute.  Und f√ºr sie gibt es eine spezielle Syntax in IL.  Es gibt ziemlich viele von ihnen, alles aufzulisten macht keinen Sinn </li><li>  Verwendung der verallgemeinerten Syntax.  Dazu geh√∂ren Benutzer- und Bibliotheksattribute. </li><li>  Sicherheitsattribute.  Dazu geh√∂ren Attribute, die (direkt oder indirekt) von SecurityAttribute erben.  Sie werden auf besondere Weise verarbeitet.  In IL gibt es eine spezielle Syntax f√ºr sie, mit der Sie XML erstellen k√∂nnen, das diese Attribute direkt beschreibt </li></ol><br><h4>  Beispiel </h4><br><div class="spoiler">  <b class="spoiler_title">C # -Code, der alle oben genannten Attributtypen enth√§lt</b> <div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] [Serializable] [Obsolete] [SecurityPermission(SecurityAction.Assert)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sample</span></span> { }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Resultierende IL</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.class public EXPLICIT ansi SERIALIZABLE beforefieldinit AttributeSamples.Sample extends [System.Runtime]System.Object { .custom instance void [System.Runtime]System.ObsoleteAttribute::.ctor() = (01 00 00 00 ) .permissionset assert = { class 'System.Security.Permissions.SecurityPermissionAttribute, System.Runtime.Extensions, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' = {}} .method public hidebysig specialname rtspecialname instance void .ctor() cil managed {/*constructor body*/} }</code> </pre><br></div></div><br>  Wie Sie sehen k√∂nnen, hat StructLayoutAttribute eine spezielle Syntax, da es in IL als "explizit" dargestellt wird.  ObsoleteAttribute verwendet eine gemeinsame Syntax - in IL beginnt mit ".custom".  SecurityPermissionAttribute als Sicherheitsattribut wurde zu einem ".permissionset assert". <br><br>  Benutzerattribute f√ºgen Metadaten Benutzerinformationen hinzu.  Dieser Mechanismus kann verwendet werden, um anwendungsspezifische Informationen zur Kompilierungszeit zu speichern und zur Laufzeit darauf zuzugreifen oder um sie von einem anderen Tool zu lesen und zu analysieren.  Obwohl jeder benutzerdefinierte Typ als Attribut verwendet werden kann, erfordert die <abbr title="Gemeinsame Sprachspezifikation">CLS-</abbr> Konformit√§t, dass die Attribute von System.Attribute erben.  <abbr title="Gemeinsame Sprachinfrastruktur">Die CLI</abbr> definiert einige Attribute vor und verwendet sie zur Steuerung des Laufzeitverhaltens.  Einige Sprachen definieren Attribute zur Darstellung von Sprachfunktionen, die nicht direkt in CTS dargestellt werden. <br><br>  Wie bereits erw√§hnt, werden Attribute in Metadaten gespeichert, die wiederum in der Kompilierungsphase generiert werden, d. H.  in die PE-Datei eingegeben (normalerweise * .dll).  Daher k√∂nnen Sie ein Attribut zur Laufzeit nur hinzuf√ºgen, indem Sie die ausf√ºhrbare Datei zur Laufzeit √§ndern (aber die Zeiten sich selbst √§ndernder Programme sind l√§ngst vorbei).  Daraus folgt, dass sie in der Ausf√ºhrungsphase nicht hinzugef√ºgt werden k√∂nnen, dies ist jedoch nicht ganz korrekt.  Wenn wir unsere Assembly bilden, Typen darin definieren, k√∂nnen wir in der Ausf√ºhrungsphase einen neuen Typ erstellen und Attribute daran h√§ngen.  Formal k√∂nnen wir also zur Laufzeit noch Attribute hinzuf√ºgen (das Beispiel befindet sich ganz unten). <br><br><h4>  Nun ein wenig zu den Einschr√§nkungen </h4><br>  Wenn sich aus irgendeinem Grund zwei Attribute in derselben Assembly mit den Namen Name und NameAtribute befinden, ist es unm√∂glich, das erste davon zu setzen.  Bei Verwendung von [Name] (dh ohne Suffix) sieht der Compiler Unsicherheit.  Wenn Sie [NameAttribute] verwenden, setzen wir NameAttribute, was logisch ist.  Es gibt eine spezielle Syntax f√ºr solch eine mystische Situation mit mangelnder Vorstellungskraft beim Benennen.  Um die erste Version ohne Suffix zu platzieren, k√∂nnen Sie das Vorzeichen des Hundes (dh [Name] ist ein Witz, es ist nicht erforderlich) vor dem Attributnamen [@Name] angeben. <br><br>  Benutzerdefinierte Attribute k√∂nnen zu allen anderen als benutzerdefinierten Attributen hinzugef√ºgt werden.  Dies bezieht sich auf Metadaten, d.h.  Wenn wir ein Attribut in C # √ºber der Attributklasse platzieren, verweist es in Metadaten auf die Klasse.  Sie k√∂nnen "public" jedoch kein Attribut hinzuf√ºgen.  Sie k√∂nnen jedoch mit Assemblys, Modulen, Klassen, Werttypen, Aufz√§hlungen, Konstruktoren, Methoden, Eigenschaften, Feldern, Ereignissen, Schnittstellen, Parametern, Delegaten, R√ºckgabewerten oder verallgemeinerten Parametern arbeiten.  Das folgende Beispiel zeigt offensichtliche und nicht sehr gute Beispiele daf√ºr, wie Sie einer bestimmten Konstruktion ein Attribut zuweisen k√∂nnen. <br><br><div class="spoiler">  <b class="spoiler_title">Syntax der Attributdeklaration</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Security.Permissions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> AttributeSamples; [assembly:All] [module:All] <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">AttributeSamples</span></span> { [AttributeUsage(AttributeTargets.All)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AllAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { } [All] <span class="hljs-comment"><span class="hljs-comment">//   public class Usage { [All] //   [return:All] //     public int GiveMeInt&lt;[All]T&gt;([All]int param) { return 5 + param; } [All] //   [field:All] //        public event Action Event; [All] //   [field: All] //       public int Action { get; set; } } }</span></span></code> </pre><br></div></div><br>  Attribute haben zwei Arten von Parametern - benannt und positionell.  Positionsparameter umfassen Konstruktorparameter.  Zu benannten √∂ffentlichen Eigenschaften mit einem zug√§nglichen Setter.  Dar√ºber hinaus sind dies nicht nur formale Namen, sondern alle Parameter k√∂nnen angegeben werden, wenn ein Attribut in Klammern nach seinem Namen deklariert wird.  Benannte sind optional. <br><br><div class="spoiler">  <b class="spoiler_title">Arten von Parametern</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AttrParamsAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AttrParamsAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> positional</span></span></span><span class="hljs-function">) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//  { } public int Named { get; set; } //  } [AttrParams(1)] [AttrParams(1, Named = 2)] public class AttrParams { }</span></span></span></span></code> </pre><br></div></div><br>  G√ºltige Parameter (beider Typen) f√ºr das Attribut m√ºssen einer der folgenden Typen sein: <br><br><ol><li>  bool, byte, char, double, float, int, long, short, string und weiter primitiv, au√üer dezimal </li><li>  Objekt </li><li>  System.Type </li><li>  Aufz√§hlung </li><li>  Ein eindimensionales Array eines der oben genannten Typen </li></ol><br>  Dies liegt haupts√§chlich an der Tatsache, dass es sich um eine Konstante zur Kompilierungszeit handeln sollte, und die oben genannten Typen k√∂nnen diese Konstante akzeptieren (indem wir ein Objekt akzeptieren, das wir int √ºbergeben k√∂nnen).  Aus irgendeinem Grund kann das Argument jedoch nicht vom Typ ValueType sein, obwohl dies aus logischer Sicht m√∂glich ist. <br><br>  Es gibt zwei Arten von Benutzerattributen: echte benutzerdefinierte Attribute und <b>Pseudo-benutzerdefinierte</b> . <br>  Im Code sehen sie gleich aus (sie sind in eckigen Klammern √ºber der Sprachstruktur angegeben), werden jedoch unterschiedlich verarbeitet: <br><br><ol><li>  Das urspr√ºngliche Benutzerattribut wird direkt in den Metadaten gespeichert.  Attributparameter werden unver√§ndert gespeichert.  Sie sind zur Laufzeit verf√ºgbar und werden als Satz von Bytes gespeichert (ich m√∂chte Sie schnell daran erinnern, dass sie zur Kompilierungszeit bekannt sind). </li><li>  Ein Pseudo-Benutzerattribut wird erkannt, weil sein Name zu einer speziellen Liste geh√∂rt.  Anstatt seine Daten direkt in den Metadaten zu speichern, werden sie analysiert und zum Setzen von Bits oder Feldern in den Metadatentabellen verwendet. Die Daten werden dann verworfen und k√∂nnen nicht weiter empfangen werden.  Metadatentabellen werden zur Laufzeit schneller √ºberpr√ºft als echte Benutzerattribute, und zum Speichern von Informationen ist weniger Speicher erforderlich. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Pseudo-Benutzerattribute sind keine sichtbare Reflexion</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomPseudoCustom</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onlyCustom = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CustomPseudoCustom).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// SerializableAttribute } }</span></span></code> </pre><br></div></div><br>  Die meisten Benutzerattribute werden auf Sprachebene eingef√ºhrt.  Sie werden von der Laufzeit gespeichert und zur√ºckgegeben, w√§hrend die Laufzeit nichts √ºber die Bedeutung dieser Attribute wei√ü.  Alle Pseudo-Benutzerattribute sowie einige Benutzerattribute sind jedoch f√ºr Compiler und die CLI von besonderem Interesse.  Also fahren wir mit dem n√§chsten Abschnitt fort. <br><br><h2>  Laufzeitf√§hige Attribute </h2><br>  Dieser Abschnitt ist rein informativ. Wenn kein Interesse an der Verwendung der Laufzeit besteht, k√∂nnen Sie zum n√§chsten Abschnitt bl√§ttern. <br><br>  In der folgenden Tabelle sind Pseudo-Benutzerattribute und spezielle Benutzerattribute aufgef√ºhrt (CLIs oder Compiler behandeln sie auf besondere Weise). <br><br>  Pseudo-Benutzerattribute (sie k√∂nnen nicht durch Reflexion erhalten werden). <br>  CLI-Attribute: <br><div class="scrollable-table"><table><tbody><tr><th>  Attribut </th><th>  Beschreibung </th></tr><tr><td>  AssemblyAlgorithmIDAttribute </td><td>  Schreibt die Kennung des verwendeten Hash-Algorithmus.  Legt das Feld Assembly.HashAlgId fest </td></tr><tr><td>  AssemblyFlagsAttribute </td><td>  Schreibt Flags f√ºr die entsprechende Assembly.  Legt das Feld Assembly.Flags fest </td></tr><tr><td>  DllImportAttribute </td><td>  Bietet Informationen zu Code, der in einer nicht verwalteten Bibliothek implementiert ist.  Setzt das Method.Flags.PinvokeImpl-Bit der entsprechenden Methode.  f√ºgt ImplMap einen neuen Eintrag hinzu (indem die Werte von MappingFlags, MemberForwarded, ImportName und ImportScope festgelegt werden) </td></tr><tr><td>  StructLayoutAttribute </td><td>  Erm√∂glicht das explizite Festlegen der Methode zum Platzieren von Referenzfeldern oder signifikanten Typen.  Legt das Feld TypeDef.Flags.LayoutMask f√ºr den Typ fest.  Es k√∂nnen auch die Felder TypeDef.Flags.StringFormatMask, ClassLayout.PackingSize und ClassLayout.ClassSize festgelegt werden </td></tr><tr><td>  FieldOffsetAttribute </td><td>  Definiert den Byte-Offset von Feldern in einer Referenz oder einem signifikanten Typ.  Legt den Wert von FieldLayout.OffSet f√ºr die entsprechende Methode fest. </td></tr><tr><td>  Inattribute </td><td>  Gibt an, dass der Parameter als [in] -Argument √ºbergeben wird.  Setzt das Param.Flags.In-Bit f√ºr den entsprechenden Parameter. </td></tr><tr><td>  Outattribute </td><td>  Gibt an, dass der Parameter als [out] -Argument √ºbergeben wird.  Setzt das Param.Flags.Out-Bit f√ºr den entsprechenden Parameter. </td></tr><tr><td>  Marschallattribut </td><td>  Definiert, wie Daten zwischen verwaltetem und nicht verwaltetem Code gemarshallt werden.  Setzt das Field.Flags.HasFieldMarshal-Bit f√ºr das Feld (oder das Param.Flags.HasFieldMarshal-Bit f√ºr den Parameter).  F√ºgt der FieldMarshal-Tabelle einen Eintrag hinzu (indem Sie die Werte von Parent und NativeType festlegen). </td></tr><tr><td>  MethodImplAttribute </td><td>  Definiert Implementierungsdetails f√ºr eine Methode.  Legt den Wert von Method.ImplFlags f√ºr die entsprechende Methode fest </td></tr></tbody></table></div><br><br>  CLS-Attribute - Sprachen m√ºssen sie unterst√ºtzen: <br><div class="scrollable-table"><table><tbody><tr><th>  Attribut </th><th>  Beschreibung </th></tr><tr><td>  AttributeUsageAttribute </td><td>  Wird verwendet, um anzugeben, wie ein Attribut verwendet werden kann. </td></tr><tr><td>  Veraltetes Attribut </td><td>  Gibt an, dass das Element nicht verwendet werden soll. </td></tr><tr><td>  CLSCompliantAttribute </td><td>  Gibt an, ob ein Element als CLS-kompatibel deklariert ist. </td></tr></tbody></table></div><br>  Verschiedenes interessant <br><div class="scrollable-table"><table><tbody><tr><th>  Attribut </th><th>  Beschreibung </th></tr><tr><td>  ThreadStaticAttribute </td><td>  Stellt Stream-bezogene Typfelder bereit </td></tr><tr><td>  ConditionalAttribute </td><td>  Markiert die Methode basierend auf einer Kompilierungsbedingung (angegeben in / define) als aufgerufen.  Wenn die Bedingung nicht erf√ºllt ist, wird die Methode nicht aufgerufen (und nicht in IL kompiliert).  Nur die void-Methode kann markiert werden.  Andernfalls tritt ein Kompilierungsfehler auf. </td></tr><tr><td>  DecimalConstantAttribute </td><td>  Speichert den dezimalen Konstantenwert in Metadaten </td></tr><tr><td>  DefaultMemberAttribute </td><td>  Definiert das Mitglied der Klasse, das standardm√§√üig mit der InvokeMember-Methode verwendet werden soll. </td></tr><tr><td>  CompilationRelaxationsAttribute </td><td>  Gibt an, ob Ausnahmen von Anweisungspr√ºfungen streng oder gelockert sind.  Derzeit k√∂nnen Sie nur den Parameter NoStringInterning √ºbergeben, der die Assembly als nicht interning f√ºr Zeichenfolgenliterale kennzeichnend markiert.  Dieser Mechanismus kann jedoch weiterhin verwendet werden. </td></tr><tr><td>  FlagsAttribute </td><td>  Attribut, das angibt, ob Enum als Bit-Flags behandelt werden soll </td></tr><tr><td>  IndexerNameAttribute </td><td>  Gibt den Namen an, unter dem der Indexer in Programmiersprachen bekannt ist, die diese Funktion nicht direkt unterst√ºtzen. </td></tr><tr><td>  ParamArrayAttribute </td><td>  Gibt an, dass die Methode eine variable Anzahl von Parametern akzeptiert. </td></tr></tbody></table></div><br><h2>  N√ºtzliche Attribute </h2><br>  Ein wesentlicher Bestandteil der Softwareproduktentwicklung ist das Debuggen.  In einem gro√üen und komplexen System dauert es oft Dutzende und Hunderte Male, dieselbe Methode auszuf√ºhren und den Status von Objekten zu √ºberwachen.  Gleichzeitig beginnt es bereits zu einem Zeitpunkt von 20, die Notwendigkeit, ein Objekt 400-mal tief zu erweitern, um den Wert einer Variablen zu sehen und die Methode erneut zu starten, besonders zu ver√§rgern. <br>  F√ºr ein leiseres und schnelleres Debuggen k√∂nnen Sie Attribute verwenden, die das Verhalten des Debuggers √§ndern. <br><br>  <b>DebuggerDisplayAttribute</b> gibt an, wie der Typ oder sein Mitglied im Fenster der Debugger-Variablen angezeigt wird (und nicht nur). <br><br>  Das einzige Argument f√ºr den Konstruktor ist eine Zeichenfolge mit einem Anzeigeformat.  Was zwischen den Klammern sein wird, wird berechnet.  Das Format ist wie eine interpolierte Zeichenfolge, nur ohne Dollar.  Sie k√∂nnen keine Zeiger in einem berechneten Wert verwenden.  √úbrigens, wenn Sie einen √ºberschriebenen ToString haben, wird sein Wert so angezeigt, als ob er in diesem Attribut w√§re.  Wenn sowohl ein ToString als auch ein Attribut vorhanden sind, wird der Wert dem Attribut entnommen. <br><img src="https://habrastorage.org/webt/eg/l9/mp/egl9mpyoppftcevpckbs4qznh-c.png"><br><br>  <b>DebuggerBrowsableAttribute</b> definiert, wie ein Feld oder eine Eigenschaft im Fenster mit den Debugger-Variablen angezeigt wird.  Akzeptiert einen DebuggerBrowsableState mit drei Optionen: <br><br><ul><li>  Nie - das Feld wird beim Debuggen √ºberhaupt nicht angezeigt.  Beim Erweitern der Objekthierarchie wird dieses Feld nicht angezeigt </li><li>  Reduziert - Das Feld ist ungel√∂st, kann aber erweitert werden.  Dies ist das Standardverhalten. </li><li>  RootHidden - Das Feld selbst wird nicht angezeigt, aber die Objekte, aus denen es besteht, werden angezeigt (f√ºr Arrays und Sammlungen). </li></ul><br><img src="https://habrastorage.org/webt/6m/a5/gf/6ma5gf06sqj0eryekzparfrzq0i.png"><br><br>  <b>DebuggerTypeProxy</b> - Wenn ein Objekt hunderte Male am Tag im Debugger angezeigt wird, k√∂nnen Sie verwirrt sein und 3 Minuten damit verbringen, ein Proxy-Objekt zu erstellen, das das Quellobjekt so anzeigt, wie es sollte.  In der Regel ist das anzuzeigende Proxy-Objekt die innere Klasse.  Tats√§chlich wird es anstelle des Zielobjekts angezeigt. <br><br><img src="https://habrastorage.org/webt/np/bg/zd/npbgzdwf_ontlgkwcr3adapeink.png"><br><br>  Andere n√ºtzliche Attribute <br><br>  <b>ThreadStatic</b> - Ein Attribut, mit dem Sie eine statische Variable f√ºr jeden Thread zu einer eigenen machen k√∂nnen.  Setzen Sie dazu das Attribut √ºber das statische Feld.  Es lohnt sich, sich an eine wichtige Nuance zu erinnern: Die Initialisierung durch einen statischen Konstruktor wird nur einmal durchgef√ºhrt, und die Variable √§ndert sich in dem Thread, den der statische Konstruktor ausf√ºhrt.  Im √ºbrigen bleibt es voreingestellt.  (PS. Wenn Sie dieses Verhalten ben√∂tigen, empfehle ich Ihnen, sich der ThreadLocal-Klasse zuzuwenden.) <br><br>  Ein wenig √ºber die Nuancen des Motorraums.  Sowohl unter Linux als auch unter Windows gibt es einen lokalen Speicherbereich f√ºr den Stream ( <abbr title="Thread lokalen Speicher">TLS</abbr> bzw. <abbr title="Thread-spezifische Daten">TSD</abbr> ).  Diese Bereiche selbst sind jedoch sehr klein.  Daher wird eine ThreadLocalInfo-Struktur erstellt, auf die in TLS ein Zeiger gesetzt wird.  Dementsprechend wird nur ein Steckplatz verwendet.  Die Struktur selbst enth√§lt 3 Felder - Thread, AppDomain, ClrTlsInfo.  Wir interessieren uns f√ºr die erste.  Es ist es, das die Speicherung der Flussstatik im Speicher mithilfe von ThreadLocalBlock und ThreadLocalModule organisiert. <br><br>  Auf diese Weise: <br><br><ul><li>  Referenztypen - ThreadStaticHandleTable befindet sich auf dem Heap und wird von der ThreadLocalBlock-Klasse unterst√ºtzt. </li><li>  Strukturen - In einem verwalteten Heap gepackt und gespeichert sowie Referenztypen </li><li>  Primitive signifikante Typen werden in Bereichen des nicht verwalteten Speichers gespeichert, die Teil von ThreadLocalModule sind </li></ul><br>  Nun, da wir dar√ºber sprechen, ist es erw√§hnenswert, √ºber asynchrone Methoden zu sprechen.  Wie ein aufmerksamer Leser vielleicht bemerkt, wird bei Verwendung der Asynchronit√§t die Fortsetzung nicht unbedingt im selben Thread ausgef√ºhrt (wir k√∂nnen den Ausf√ºhrungskontext beeinflussen, jedoch nicht den Thread).  Dementsprechend bekommen wir einen Mist, wenn wir ThreadLocal verwenden.  In diesem Fall wird empfohlen, AsyncLocal zu verwenden.  Aber der Artikel handelt nicht davon, also gingen wir weiter. <br><br>  <b>InternalsVisibleTo</b> - Mit dieser Option k√∂nnen Sie die Baugruppe angeben, die f√ºr als <i>intern</i> gekennzeichnete Elemente sichtbar ist.  Es scheint, dass Sie, wenn eine Versammlung bestimmte Typen und deren Mitglieder ben√∂tigt, diese einfach als <i>√∂ffentlich</i> und nicht als Dampf markieren k√∂nnen.  Eine gute Architektur setzt jedoch voraus, dass Implementierungsdetails ausgeblendet werden.  Trotzdem k√∂nnen sie f√ºr einige Infrastrukturzwecke ben√∂tigt werden, beispielsweise f√ºr Testprojekte.  Mit diesem Attribut k√∂nnen Sie sowohl die Kapselung als auch den erforderlichen Prozentsatz der Testabdeckung unterst√ºtzen. <br><br>  <b>HandleProcessCorruptedStateExceptions</b> - Erm√∂glicht es Ihnen, sch√ºchterne Programmierer zu erschrecken und Ausnahmen eines besch√§digten Zustands <b>abzufangen</b> .  F√ºr solche Ausnahmen wird die CLR standardm√§√üig nicht abgefangen.  Im Allgemeinen w√§re die beste L√∂sung, die Anwendung abst√ºrzen zu lassen.  Dies sind gef√§hrliche Ausnahmen, die darauf hinweisen, dass der Prozessspeicher besch√§digt ist. Daher ist die Verwendung dieses Attributs eine sehr schlechte Idee.  In einigen F√§llen ist es jedoch m√∂glich, dass f√ºr die lokale Entwicklung dieses Attribut f√ºr eine Weile festgelegt wird.  Um die Ausnahme eines besch√§digten Zustands abzufangen, setzen Sie dieses Attribut einfach √ºber die Methode.  Und wenn dieses Attribut bereits verwendet wird, wird (wie immer) empfohlen, eine bestimmte Ausnahme abzufangen. <br><br>  <b>DisablePrivateReflection</b> - macht alle privaten Mitglieder der Assembly f√ºr die Reflexion unerreichbar.  Das Attribut wird in die Assembly eingef√ºgt. <br><br><h2>  Definieren Sie Ihr Attribut </h2><br>  Nicht nur, weil dieser Abschnitt der letzte ist.  Der beste Weg, um zu verstehen, in welchen F√§llen die Verwendung des Attributs von Vorteil ist, besteht darin, sich bereits verwendete Attribute anzusehen.  Es ist schwierig, eine formalisierte Regel zu formulieren, wenn Sie √ºber Ihr eigenes Attribut nachdenken sollten.  Oft werden sie als zus√§tzliche Informationen √ºber einen Typ / sein Mitglied oder ein anderes Sprachkonstrukt verwendet, das v√∂llig anderen Entit√§ten gemeinsam ist.  Als Beispiel alle Attribute, die f√ºr Serialisierung / ORM / Formatierung usw. verwendet werden.  Aufgrund der umfassenden Anwendung dieser Mechanismen auf v√∂llig unterschiedliche Typen, die den Entwicklern des entsprechenden Mechanismus h√§ufig nicht bekannt sind, ist die Verwendung von Attributen eine hervorragende M√∂glichkeit, dem Benutzer die Bereitstellung deklarativer Informationen f√ºr diesen Mechanismus zu erm√∂glichen. <br><br>  Die Verwendung Ihrer Attribute kann in zwei Teile unterteilt werden: <br><br><ol><li>  Ein Attribut erstellen und verwenden </li><li>  Ein Attribut abrufen und verarbeiten </li></ol><br><h4>  Ein Attribut erstellen und verwenden </h4><br>  Um Ihr Attribut zu erstellen, reicht es aus, von <i>System.Attribute</i> zu erben.  In diesem Fall ist es ratsam, den genannten Namensstil einzuhalten - den Klassennamen auf Attribut zu beenden.  Es wird jedoch kein Fehler angezeigt, wenn Sie dieses Suffix weglassen.  Wie bereits erw√§hnt, k√∂nnen Attribute zwei Arten von Parametern haben - positionell und benannt.  Die Logik ihrer Anwendung ist dieselbe wie bei den Eigenschaften und Parametern des Konstruktors f√ºr die Klasse - die Werte, die zum Erstellen des Objekts erforderlich sind, f√ºr das es keinen vern√ºnftigen "Standard" gibt, werden in Position (dh Konstruktor) gestellt.  Was vern√ºnftigerweise voreingestellt werden kann, was h√§ufig verwendet wird, wird besser in eine benannte (d. H. Eine Eigenschaft) unterschieden. <br><br>  Von nicht geringer Bedeutung f√ºr die Erstellung eines Attributs ist die Begrenzung seiner Anwendungsorte.  Hierf√ºr wird AttributeUsageAttribute verwendet.  Der erforderliche Parameter (Position) ist das AttributeTarget, das bestimmt, wo das Attribut verwendet wird (Methode, Assembly usw.).  Optionale (benannte) Parameter sind: <br><br><ol><li>  AllowMultiple - Gibt an, ob es m√∂glich ist, mehr als ein Attribut √ºber dem Ort seiner Anwendung zu platzieren oder nicht.  Standardm√§√üig falsch </li><li>  Geerbt - Bestimmt, ob dieses Attribut zu Klassenvererbern (bei Platzierung √ºber der Basisklasse) und √ºberschriebenen Methoden (bei Platzierung √ºber der Methode) geh√∂rt.  Der Standardwert ist true. </li></ol><br>  Danach k√∂nnen Sie die Attribute mit einer Nutzlast laden.  Ein Attribut ist eine deklarative Information, dh alles, was darin definiert ist, sollte die Konstruktion beschreiben, auf die es sich bezieht.  Das Attribut sollte keine tiefe Logik enthalten.  F√ºr die Verarbeitung der von Ihnen definierten Attribute sollten spezielle Services verantwortlich sein, die sie nur verarbeiten.  Die Tatsache, dass das Attribut keine Logik haben sollte, bedeutet jedoch nicht, dass es keine Methoden haben sollte. <br><br>  Eine Methode (Funktion) ist auch Information und kann auch ein Design beschreiben.  Mithilfe von Polymorphismus in Attributen k√∂nnen Sie ein sehr leistungsf√§higes und praktisches Tool bereitstellen, mit dem der Benutzer sowohl die von Ihrem Tool verwendeten Informationen als auch bestimmte Ausf√ºhrungs- und Verarbeitungsstufen beeinflussen kann.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall muss er keine Klassen erstellen, Abh√§ngigkeiten, Kostenfabriken und deren Schnittstellen einf√ºgen, die diese Klassen erstellen. </font><font style="vertical-align: inherit;">Es reicht aus, eine einzelne Erbenklasse zu erstellen, die die Details der Arbeit mit dem Element enth√§lt, auf das sie sich bezieht. </font><font style="vertical-align: inherit;">In der Regel reicht jedoch das √ºbliche ROSO-Attribut mit einigen Eigenschaften aus.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abrufen und Verarbeiten eines Attributs </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verarbeitung der empfangenen Attribute h√§ngt vom jeweiligen Fall ab und kann auf v√∂llig unterschiedliche Weise erfolgen. Es ist schwierig, hierf√ºr n√ºtzliche Funktionen und Tricks anzugeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attribute werden zur Laufzeit durch Reflektion erhalten. Es gibt verschiedene M√∂glichkeiten, ein Attribut von einem bestimmten Element abzurufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber alles stammt von der </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICustomAttributeProvider-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oberfl√§che </font><font style="vertical-align: inherit;">. Es wird von Typen wie Assembly, MemberInfo, Module, ParameterInfo implementiert. Die Nachfolger von MemberInfo sind wiederum Type, EventInfo, FieldInfo, MethodBase, PropertyInfo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schnittstelle hat nur 3 Funktionen und sie sind nicht sehr praktisch. Sie arbeiten mit Arrays (auch wenn wir wissen, dass es nur ein Attribut geben kann) und sind nicht nach Typ parametrisiert (sie verwenden Objekt). Daher m√ºssen Sie selten direkt auf die Funktionen dieser Schnittstelle zugreifen (ich habe es nie gesagt, weil ich nicht kategorisch sein m√∂chte). Zur Vereinfachung der Verwendung gibt es eine </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomAttributeExtensions-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">, in der es viele Erweiterungsmethoden f√ºr alle Arten von Typen gibt, die einfache Operationen zum Umwandeln, Ausw√§hlen eines einzelnen Werts usw. ausf√ºhren, wodurch der Entwickler von dieser Notwendigkeit befreit wird. Diese Methoden sind auch als statisch in der Attributklasse verf√ºgbar, mit der n√ºtzlichsten Funktion, den geerbten Parameter zu ignorieren (f√ºr Nonkonformisten).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die wichtigsten verwendeten Funktionen sind unten aufgef√ºhrt. </font><font style="vertical-align: inherit;">Der erste Parameter, der angibt, welcher Typ die Methode erweitert, habe ich weggelassen. </font><font style="vertical-align: inherit;">√úberall dort, wo der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool-Vererbungsparameter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angegeben ist </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> kommt es ohne ihn zu einer √úberladung (mit dem Standardwert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Dieser Parameter gibt an, ob die Attribute der √ºbergeordneten Klasse oder der Basismethode bei der Ausf√ºhrung der Methode ber√ºcksichtigt werden sollen (falls sie f√ºr eine √ºberschriebene Methode verwendet werden). </font><font style="vertical-align: inherit;">Wenn im Attribut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erben = flase angegeben ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><i><font style="vertical-align: inherit;">hilft</font></i><font style="vertical-align: inherit;"> es nicht, die Attribute der Basisklasse zu ber√ºcksichtigen, wenn Sie es auf true setzen</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methodenname </font></font></th><th>  Beschreibung </th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributes &lt;LogAttribute&gt; (Bool-Erbe) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruft eine Aufz√§hlung von Attributen des angegebenen Typs ab. </font><font style="vertical-align: inherit;">Wenn das Attribut eins ist, wird eine Aufz√§hlung von 1 Element zur√ºckgegeben</font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttribute &lt;LogAttribute&gt; (Bool-Erbe) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt ein einzelnes Attribut des angegebenen Typs zur√ºck. </font><font style="vertical-align: inherit;">Wenn mehrere vorhanden sind, </font><i><font style="vertical-align: inherit;">l√∂sen Sie</font></i><font style="vertical-align: inherit;"> eine </font><i><font style="vertical-align: inherit;">System.Reflection.AmbiguousMatchException aus: Mehrere benutzerdefinierte Attribute desselben Typs haben eine</font></i><font style="vertical-align: inherit;"> Ausnahme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gefunden</font></font></i> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributes () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gibt eine Aufz√§hlung von Attributen aller Typen zur√ºck </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributesData () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gibt eine Aufz√§hlung CustomAttributeData zur√ºck, in der es Eigenschaften gibt, mit denen Sie einen Konstruktor, Parameter (benannt und positionell) und Konstruktorargumente abrufen k√∂nnen </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IsDefined (Typ attrType, bool erben) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gibt true zur√ºck, wenn das Attribut √ºber dem Element deklariert ist, andernfalls false </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus Gr√ºnden der Klarheit schlage ich vor, eine kleine Demo der Arbeit aller genannten Funktionen anzusehen. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckgabewert der oben genannten Methoden</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LogAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LogName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [AttributeUsage(AttributeTargets.All, AllowMultiple = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, Inherited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerializeAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SerializeName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityDerived</span></span> : <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type derivedType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(RandomDomainEntityDerived); MemberInfo overrideMethod = derivedType.GetMethod(<span class="hljs-string"><span class="hljs-string">"VirtualMethod"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// overrideMethod.GetCustomAttribute(typeof(LogAttribute)); //System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // overrideMethod.GetCustomAttribute&lt;LogAttribute&gt;(false); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // Attribute.GetCustomAttribute(derivedType, typeof(SerializeAttribute)); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. IEnumerable&lt;Attribute&gt; allCustom = overrideMethod.GetCustomAttributes(); //LogOverride1 LogOverride2 SerializeOverride1 SerializeOverride2 LogMethod1 LogMethod2 IList&lt;CustomAttributeData&gt; allCustomInfo = overrideMethod.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:false); //LogOverride1 LogOverride2 IEnumerable&lt;LogAttribute&gt; typedInheritedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:true); //LogOverride1 LogOverride2 LogMethod1 LogMethod2 IEnumerable&lt;SerializeAttribute&gt; typedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:false); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:true); //SerializeOverride1 SerializeOverride2 Attribute[] customFromStaticClass = Attribute.GetCustomAttributes(overrideMethod, typeof(SerializeAttribute), inherit:true); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;Attribute&gt; classCustom = derivedType.GetCustomAttributes(); //LogDerived1 LogDerived2 SerializeDerived1 SerializeDerived2 LogBase1 LogBase2 IList&lt;CustomAttributeData&gt; classCustomInfo = derivedType.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(false); //LogDerived1 LogDerived2 IEnumerable&lt;LogAttribute&gt; typedInheritedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(true); //LogDerived1 LogDerived2 LogBase1 LogBase2 IEnumerable&lt;SerializeAttribute&gt; typedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(false); //SerializeDerived1 SerializeDerived2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(true); //SerializeDerived1 SerializeDerived2 } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus akademischen Gr√ºnden gebe ich ein Beispiel f√ºr die Definition von Attributen zur Laufzeit. </font><font style="vertical-align: inherit;">Dieser Code erhebt nicht den Anspruch, der sch√∂nste und am meisten unterst√ºtzte zu sein.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TypeCreator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TypeSignature = <span class="hljs-string"><span class="hljs-string">"DynamicType"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ModuleName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AssemblyName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TypeBuilder _typeBuilder = GetTypeBuilder(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTypeInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _typeBuilder.DefineNestedType(<span class="hljs-string"><span class="hljs-string">"ClassName"</span></span>); CreatePropertyWithAttribute&lt;SerializeAttribute&gt;(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Type newType = _typeBuilder.CreateType(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Activator.CreateInstance(newType); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreatePropertyWithAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName, Type propertyType, Type[] ctorTypes, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] ctorArgs) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Attribute { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attributeCtor = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).GetConstructor(ctorTypes); CustomAttributeBuilder caBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomAttributeBuilder(attributeCtor, ctorArgs); PropertyBuilder newProperty = CreateProperty(propertyName, propertyType); newProperty.SetCustomAttribute(caBuilder); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PropertyBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName, Type propertyType</span></span></span><span class="hljs-function">)</span></span> { FieldBuilder fieldBuilder = _typeBuilder.DefineField(propertyName, propertyType, FieldAttributes.Private); PropertyBuilder propertyBuilder = _typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, propertyType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig; MethodBuilder getter = GenerateGetter(); MethodBuilder setter = GenerateSetter(); propertyBuilder.SetGetMethod(getter); propertyBuilder.SetSetMethod(setter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> propertyBuilder; <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder getMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"get_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, propertyType, Type.EmptyTypes); ILGenerator getterIl = getMethodBuilder.GetILGenerator(); getterIl.Emit(OpCodes.Ldarg_0); getterIl.Emit(OpCodes.Ldfld, fieldBuilder); getterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMethodBuilder; } <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateSetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder setMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"set_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, <span class="hljs-literal"><span class="hljs-literal">null</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { propertyType }); ILGenerator setterIl = setMethodBuilder.GetILGenerator(); setterIl.Emit(OpCodes.Ldarg_0); setterIl.Emit(OpCodes.Ldarg_1); setterIl.Emit(OpCodes.Stfld, fieldBuilder); setterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> setMethodBuilder; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTypeBuilder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AssemblyName(AssemblyName), AssemblyBuilderAccess.Run); ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(ModuleName); TypeBuilder typeBuilder = moduleBuilder.DefineType(TypeSignature, TypeAttributes.Public | TypeAttributes.Class | TypeAttributes.AutoClass | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit | TypeAttributes.AutoLayout,<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typeBuilder; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeCreator().CreateTypeInstance(); IEnumerable&lt;Attribute&gt; attrs = instance.GetType().GetProperty(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// Serializable } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468287/">https://habr.com/ru/post/de468287/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468265/index.html">Aus Vim S√º√üigkeiten machen</a></li>
<li><a href="../de468267/index.html">St√§rkung der UseCase-Methodik im Buch Alistair Coburn</a></li>
<li><a href="../de468271/index.html">Tests vs. Typen - Rostversion</a></li>
<li><a href="../de468277/index.html">Ist die Arbeit des Programmierers schwierig - eine Sicht aus Sicht der Psychophysiologie</a></li>
<li><a href="../de468285/index.html">Top-Softwareentwicklungsunternehmen f√ºr Unternehmen und Startups</a></li>
<li><a href="../de468289/index.html">AM</a></li>
<li><a href="../de468291/index.html">Synopse aus Mark Gaulstons Buch "Ich kann dich durchh√∂ren"</a></li>
<li><a href="../de468293/index.html">Vive Cosmos - Test des neuen VR-Sets von HTC</a></li>
<li><a href="../de468295/index.html">50 Matplotlib-Schattierungen - The Master Plots (mit vollst√§ndigem Python-Code)</a></li>
<li><a href="../de468299/index.html">Was soll Oracle f√ºr einen Entwickler im Jahr 2019 (und danach) entwickeln?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>