<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎮 🧝🏻 👩🏿‍🚀 C # -Attribute: Über alle Aspekte 😴 🚣🏽 👨‍👦‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Leser. Dieser Artikel beschreibt Attribute von allen Seiten - angefangen bei der Spezifikation, Bedeutung und Definition von Attributen über das...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # -Attribute: Über alle Aspekte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468287/">  Hallo Leser.  Dieser Artikel beschreibt Attribute von allen Seiten - angefangen bei der Spezifikation, Bedeutung und Definition von Attributen über das Erstellen eigener Attribute und deren Arbeit bis hin zum Hinzufügen von Attributen zur Laufzeit und den nützlichsten und interessantesten vorhandenen Attributen.  Wenn Sie sich für das Thema Attribute in C # interessieren, sind Sie bei cat willkommen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u4/uk/ee/u4ukeefozvzkxjtgw9i8zbap6ly.jpeg"></div><a name="habracut"></a><br><h2>  Inhalt </h2><br><ol><li>  Einführung  Attribute definieren und zuweisen </li><li>  Interessante Attribute mit Laufzeitunterstützung.  Hier werden kurze Informationen zu verschiedenen Attributen gegeben, deren Existenz nur wenige Menschen kennen und noch weniger diejenigen, die sie verwenden.  Da dies absolut unpraktische Informationen sind, wird es nicht viel Schimpfen geben (entgegen meiner Leidenschaft für nicht anwendbares Wissen) </li><li> Einige der wenig bekannten Attribute, die nützlich sind, um sie zu kennen. </li><li>  Definieren Sie Ihr Attribut und verarbeiten Sie es.  Hinzufügen von Attributen zur Laufzeit </li></ol><br><h2>  Einführung </h2><br>  Beginnen Sie wie immer mit Definitionen und Spezifikationen.  Dies wird dazu beitragen, die Attribute auf allen Ebenen zu verstehen und zu realisieren, was wiederum sehr nützlich ist, um die richtigen Anwendungen für sie zu finden. <br><br>  Definieren Sie zunächst Metadaten.  <b>Metadaten</b> sind Daten, die von <abbr title="Common Type System">CTS</abbr> definierte Typen beschreiben und auf diese verweisen.  Metadaten werden unabhängig von einer bestimmten Programmiersprache gespeichert.  Daher bieten Metadaten einen allgemeinen Mechanismus für den Austausch von Informationen über ein Programm zur Verwendung zwischen Tools, die dies erfordern (Compiler und Debugger sowie das Programm selbst) sowie zwischen <abbr title="Virtuelles Ausführungssystem">VES</abbr> .  Metadaten sind im Assemblymanifest enthalten.  Sie können in einer <abbr title="Tragbare ausführbare Datei">PE-</abbr> Datei zusammen mit <abbr title="Zwischensprache">IL-</abbr> Code oder in einer separaten PE-Datei gespeichert werden, in der nur ein Assembly-Manifest vorhanden ist. <br>  <b>Ein Attribut</b> ist ein Merkmal eines Typs oder seiner Mitglieder (oder anderer Sprachkonstrukte), das beschreibende Informationen enthält.  Obwohl die häufigsten Attribute vordefiniert sind und ein bestimmtes Format in den Metadaten haben, können den Metadaten auch benutzerdefinierte Attribute hinzugefügt werden.  Attribute sind kommutativ, d.h.  Die Reihenfolge ihrer Deklaration über das Element ist unwichtig <br><br>  <b>Aus syntaktischer Sicht (in Metadaten) gibt es die folgenden Attribute</b> <br><br><ol><li>  Verwendung einer speziellen Syntax in IL.  Schlüsselwörter sind beispielsweise Attribute.  Und für sie gibt es eine spezielle Syntax in IL.  Es gibt ziemlich viele von ihnen, alles aufzulisten macht keinen Sinn </li><li>  Verwendung der verallgemeinerten Syntax.  Dazu gehören Benutzer- und Bibliotheksattribute. </li><li>  Sicherheitsattribute.  Dazu gehören Attribute, die (direkt oder indirekt) von SecurityAttribute erben.  Sie werden auf besondere Weise verarbeitet.  In IL gibt es eine spezielle Syntax für sie, mit der Sie XML erstellen können, das diese Attribute direkt beschreibt </li></ol><br><h4>  Beispiel </h4><br><div class="spoiler">  <b class="spoiler_title">C # -Code, der alle oben genannten Attributtypen enthält</b> <div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] [Serializable] [Obsolete] [SecurityPermission(SecurityAction.Assert)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sample</span></span> { }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Resultierende IL</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">.class public EXPLICIT ansi SERIALIZABLE beforefieldinit AttributeSamples.Sample extends [System.Runtime]System.Object { .custom instance void [System.Runtime]System.ObsoleteAttribute::.ctor() = (01 00 00 00 ) .permissionset assert = { class 'System.Security.Permissions.SecurityPermissionAttribute, System.Runtime.Extensions, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' = {}} .method public hidebysig specialname rtspecialname instance void .ctor() cil managed {/*constructor body*/} }</code> </pre><br></div></div><br>  Wie Sie sehen können, hat StructLayoutAttribute eine spezielle Syntax, da es in IL als "explizit" dargestellt wird.  ObsoleteAttribute verwendet eine gemeinsame Syntax - in IL beginnt mit ".custom".  SecurityPermissionAttribute als Sicherheitsattribut wurde zu einem ".permissionset assert". <br><br>  Benutzerattribute fügen Metadaten Benutzerinformationen hinzu.  Dieser Mechanismus kann verwendet werden, um anwendungsspezifische Informationen zur Kompilierungszeit zu speichern und zur Laufzeit darauf zuzugreifen oder um sie von einem anderen Tool zu lesen und zu analysieren.  Obwohl jeder benutzerdefinierte Typ als Attribut verwendet werden kann, erfordert die <abbr title="Gemeinsame Sprachspezifikation">CLS-</abbr> Konformität, dass die Attribute von System.Attribute erben.  <abbr title="Gemeinsame Sprachinfrastruktur">Die CLI</abbr> definiert einige Attribute vor und verwendet sie zur Steuerung des Laufzeitverhaltens.  Einige Sprachen definieren Attribute zur Darstellung von Sprachfunktionen, die nicht direkt in CTS dargestellt werden. <br><br>  Wie bereits erwähnt, werden Attribute in Metadaten gespeichert, die wiederum in der Kompilierungsphase generiert werden, d. H.  in die PE-Datei eingegeben (normalerweise * .dll).  Daher können Sie ein Attribut zur Laufzeit nur hinzufügen, indem Sie die ausführbare Datei zur Laufzeit ändern (aber die Zeiten sich selbst ändernder Programme sind längst vorbei).  Daraus folgt, dass sie in der Ausführungsphase nicht hinzugefügt werden können, dies ist jedoch nicht ganz korrekt.  Wenn wir unsere Assembly bilden, Typen darin definieren, können wir in der Ausführungsphase einen neuen Typ erstellen und Attribute daran hängen.  Formal können wir also zur Laufzeit noch Attribute hinzufügen (das Beispiel befindet sich ganz unten). <br><br><h4>  Nun ein wenig zu den Einschränkungen </h4><br>  Wenn sich aus irgendeinem Grund zwei Attribute in derselben Assembly mit den Namen Name und NameAtribute befinden, ist es unmöglich, das erste davon zu setzen.  Bei Verwendung von [Name] (dh ohne Suffix) sieht der Compiler Unsicherheit.  Wenn Sie [NameAttribute] verwenden, setzen wir NameAttribute, was logisch ist.  Es gibt eine spezielle Syntax für solch eine mystische Situation mit mangelnder Vorstellungskraft beim Benennen.  Um die erste Version ohne Suffix zu platzieren, können Sie das Vorzeichen des Hundes (dh [Name] ist ein Witz, es ist nicht erforderlich) vor dem Attributnamen [@Name] angeben. <br><br>  Benutzerdefinierte Attribute können zu allen anderen als benutzerdefinierten Attributen hinzugefügt werden.  Dies bezieht sich auf Metadaten, d.h.  Wenn wir ein Attribut in C # über der Attributklasse platzieren, verweist es in Metadaten auf die Klasse.  Sie können "public" jedoch kein Attribut hinzufügen.  Sie können jedoch mit Assemblys, Modulen, Klassen, Werttypen, Aufzählungen, Konstruktoren, Methoden, Eigenschaften, Feldern, Ereignissen, Schnittstellen, Parametern, Delegaten, Rückgabewerten oder verallgemeinerten Parametern arbeiten.  Das folgende Beispiel zeigt offensichtliche und nicht sehr gute Beispiele dafür, wie Sie einer bestimmten Konstruktion ein Attribut zuweisen können. <br><br><div class="spoiler">  <b class="spoiler_title">Syntax der Attributdeklaration</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Security.Permissions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> AttributeSamples; [assembly:All] [module:All] <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">AttributeSamples</span></span> { [AttributeUsage(AttributeTargets.All)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AllAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { } [All] <span class="hljs-comment"><span class="hljs-comment">//   public class Usage { [All] //   [return:All] //     public int GiveMeInt&lt;[All]T&gt;([All]int param) { return 5 + param; } [All] //   [field:All] //        public event Action Event; [All] //   [field: All] //       public int Action { get; set; } } }</span></span></code> </pre><br></div></div><br>  Attribute haben zwei Arten von Parametern - benannt und positionell.  Positionsparameter umfassen Konstruktorparameter.  Zu benannten öffentlichen Eigenschaften mit einem zugänglichen Setter.  Darüber hinaus sind dies nicht nur formale Namen, sondern alle Parameter können angegeben werden, wenn ein Attribut in Klammern nach seinem Namen deklariert wird.  Benannte sind optional. <br><br><div class="spoiler">  <b class="spoiler_title">Arten von Parametern</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AttrParamsAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AttrParamsAttribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> positional</span></span></span><span class="hljs-function">) </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//  { } public int Named { get; set; } //  } [AttrParams(1)] [AttrParams(1, Named = 2)] public class AttrParams { }</span></span></span></span></code> </pre><br></div></div><br>  Gültige Parameter (beider Typen) für das Attribut müssen einer der folgenden Typen sein: <br><br><ol><li>  bool, byte, char, double, float, int, long, short, string und weiter primitiv, außer dezimal </li><li>  Objekt </li><li>  System.Type </li><li>  Aufzählung </li><li>  Ein eindimensionales Array eines der oben genannten Typen </li></ol><br>  Dies liegt hauptsächlich an der Tatsache, dass es sich um eine Konstante zur Kompilierungszeit handeln sollte, und die oben genannten Typen können diese Konstante akzeptieren (indem wir ein Objekt akzeptieren, das wir int übergeben können).  Aus irgendeinem Grund kann das Argument jedoch nicht vom Typ ValueType sein, obwohl dies aus logischer Sicht möglich ist. <br><br>  Es gibt zwei Arten von Benutzerattributen: echte benutzerdefinierte Attribute und <b>Pseudo-benutzerdefinierte</b> . <br>  Im Code sehen sie gleich aus (sie sind in eckigen Klammern über der Sprachstruktur angegeben), werden jedoch unterschiedlich verarbeitet: <br><br><ol><li>  Das ursprüngliche Benutzerattribut wird direkt in den Metadaten gespeichert.  Attributparameter werden unverändert gespeichert.  Sie sind zur Laufzeit verfügbar und werden als Satz von Bytes gespeichert (ich möchte Sie schnell daran erinnern, dass sie zur Kompilierungszeit bekannt sind). </li><li>  Ein Pseudo-Benutzerattribut wird erkannt, weil sein Name zu einer speziellen Liste gehört.  Anstatt seine Daten direkt in den Metadaten zu speichern, werden sie analysiert und zum Setzen von Bits oder Feldern in den Metadatentabellen verwendet. Die Daten werden dann verworfen und können nicht weiter empfangen werden.  Metadatentabellen werden zur Laufzeit schneller überprüft als echte Benutzerattribute, und zum Speichern von Informationen ist weniger Speicher erforderlich. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Pseudo-Benutzerattribute sind keine sichtbare Reflexion</b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable</span></span>] [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CustomPseudoCustom</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onlyCustom = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CustomPseudoCustom).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// SerializableAttribute } }</span></span></code> </pre><br></div></div><br>  Die meisten Benutzerattribute werden auf Sprachebene eingeführt.  Sie werden von der Laufzeit gespeichert und zurückgegeben, während die Laufzeit nichts über die Bedeutung dieser Attribute weiß.  Alle Pseudo-Benutzerattribute sowie einige Benutzerattribute sind jedoch für Compiler und die CLI von besonderem Interesse.  Also fahren wir mit dem nächsten Abschnitt fort. <br><br><h2>  Laufzeitfähige Attribute </h2><br>  Dieser Abschnitt ist rein informativ. Wenn kein Interesse an der Verwendung der Laufzeit besteht, können Sie zum nächsten Abschnitt blättern. <br><br>  In der folgenden Tabelle sind Pseudo-Benutzerattribute und spezielle Benutzerattribute aufgeführt (CLIs oder Compiler behandeln sie auf besondere Weise). <br><br>  Pseudo-Benutzerattribute (sie können nicht durch Reflexion erhalten werden). <br>  CLI-Attribute: <br><div class="scrollable-table"><table><tbody><tr><th>  Attribut </th><th>  Beschreibung </th></tr><tr><td>  AssemblyAlgorithmIDAttribute </td><td>  Schreibt die Kennung des verwendeten Hash-Algorithmus.  Legt das Feld Assembly.HashAlgId fest </td></tr><tr><td>  AssemblyFlagsAttribute </td><td>  Schreibt Flags für die entsprechende Assembly.  Legt das Feld Assembly.Flags fest </td></tr><tr><td>  DllImportAttribute </td><td>  Bietet Informationen zu Code, der in einer nicht verwalteten Bibliothek implementiert ist.  Setzt das Method.Flags.PinvokeImpl-Bit der entsprechenden Methode.  fügt ImplMap einen neuen Eintrag hinzu (indem die Werte von MappingFlags, MemberForwarded, ImportName und ImportScope festgelegt werden) </td></tr><tr><td>  StructLayoutAttribute </td><td>  Ermöglicht das explizite Festlegen der Methode zum Platzieren von Referenzfeldern oder signifikanten Typen.  Legt das Feld TypeDef.Flags.LayoutMask für den Typ fest.  Es können auch die Felder TypeDef.Flags.StringFormatMask, ClassLayout.PackingSize und ClassLayout.ClassSize festgelegt werden </td></tr><tr><td>  FieldOffsetAttribute </td><td>  Definiert den Byte-Offset von Feldern in einer Referenz oder einem signifikanten Typ.  Legt den Wert von FieldLayout.OffSet für die entsprechende Methode fest. </td></tr><tr><td>  Inattribute </td><td>  Gibt an, dass der Parameter als [in] -Argument übergeben wird.  Setzt das Param.Flags.In-Bit für den entsprechenden Parameter. </td></tr><tr><td>  Outattribute </td><td>  Gibt an, dass der Parameter als [out] -Argument übergeben wird.  Setzt das Param.Flags.Out-Bit für den entsprechenden Parameter. </td></tr><tr><td>  Marschallattribut </td><td>  Definiert, wie Daten zwischen verwaltetem und nicht verwaltetem Code gemarshallt werden.  Setzt das Field.Flags.HasFieldMarshal-Bit für das Feld (oder das Param.Flags.HasFieldMarshal-Bit für den Parameter).  Fügt der FieldMarshal-Tabelle einen Eintrag hinzu (indem Sie die Werte von Parent und NativeType festlegen). </td></tr><tr><td>  MethodImplAttribute </td><td>  Definiert Implementierungsdetails für eine Methode.  Legt den Wert von Method.ImplFlags für die entsprechende Methode fest </td></tr></tbody></table></div><br><br>  CLS-Attribute - Sprachen müssen sie unterstützen: <br><div class="scrollable-table"><table><tbody><tr><th>  Attribut </th><th>  Beschreibung </th></tr><tr><td>  AttributeUsageAttribute </td><td>  Wird verwendet, um anzugeben, wie ein Attribut verwendet werden kann. </td></tr><tr><td>  Veraltetes Attribut </td><td>  Gibt an, dass das Element nicht verwendet werden soll. </td></tr><tr><td>  CLSCompliantAttribute </td><td>  Gibt an, ob ein Element als CLS-kompatibel deklariert ist. </td></tr></tbody></table></div><br>  Verschiedenes interessant <br><div class="scrollable-table"><table><tbody><tr><th>  Attribut </th><th>  Beschreibung </th></tr><tr><td>  ThreadStaticAttribute </td><td>  Stellt Stream-bezogene Typfelder bereit </td></tr><tr><td>  ConditionalAttribute </td><td>  Markiert die Methode basierend auf einer Kompilierungsbedingung (angegeben in / define) als aufgerufen.  Wenn die Bedingung nicht erfüllt ist, wird die Methode nicht aufgerufen (und nicht in IL kompiliert).  Nur die void-Methode kann markiert werden.  Andernfalls tritt ein Kompilierungsfehler auf. </td></tr><tr><td>  DecimalConstantAttribute </td><td>  Speichert den dezimalen Konstantenwert in Metadaten </td></tr><tr><td>  DefaultMemberAttribute </td><td>  Definiert das Mitglied der Klasse, das standardmäßig mit der InvokeMember-Methode verwendet werden soll. </td></tr><tr><td>  CompilationRelaxationsAttribute </td><td>  Gibt an, ob Ausnahmen von Anweisungsprüfungen streng oder gelockert sind.  Derzeit können Sie nur den Parameter NoStringInterning übergeben, der die Assembly als nicht interning für Zeichenfolgenliterale kennzeichnend markiert.  Dieser Mechanismus kann jedoch weiterhin verwendet werden. </td></tr><tr><td>  FlagsAttribute </td><td>  Attribut, das angibt, ob Enum als Bit-Flags behandelt werden soll </td></tr><tr><td>  IndexerNameAttribute </td><td>  Gibt den Namen an, unter dem der Indexer in Programmiersprachen bekannt ist, die diese Funktion nicht direkt unterstützen. </td></tr><tr><td>  ParamArrayAttribute </td><td>  Gibt an, dass die Methode eine variable Anzahl von Parametern akzeptiert. </td></tr></tbody></table></div><br><h2>  Nützliche Attribute </h2><br>  Ein wesentlicher Bestandteil der Softwareproduktentwicklung ist das Debuggen.  In einem großen und komplexen System dauert es oft Dutzende und Hunderte Male, dieselbe Methode auszuführen und den Status von Objekten zu überwachen.  Gleichzeitig beginnt es bereits zu einem Zeitpunkt von 20, die Notwendigkeit, ein Objekt 400-mal tief zu erweitern, um den Wert einer Variablen zu sehen und die Methode erneut zu starten, besonders zu verärgern. <br>  Für ein leiseres und schnelleres Debuggen können Sie Attribute verwenden, die das Verhalten des Debuggers ändern. <br><br>  <b>DebuggerDisplayAttribute</b> gibt an, wie der Typ oder sein Mitglied im Fenster der Debugger-Variablen angezeigt wird (und nicht nur). <br><br>  Das einzige Argument für den Konstruktor ist eine Zeichenfolge mit einem Anzeigeformat.  Was zwischen den Klammern sein wird, wird berechnet.  Das Format ist wie eine interpolierte Zeichenfolge, nur ohne Dollar.  Sie können keine Zeiger in einem berechneten Wert verwenden.  Übrigens, wenn Sie einen überschriebenen ToString haben, wird sein Wert so angezeigt, als ob er in diesem Attribut wäre.  Wenn sowohl ein ToString als auch ein Attribut vorhanden sind, wird der Wert dem Attribut entnommen. <br><img src="https://habrastorage.org/webt/eg/l9/mp/egl9mpyoppftcevpckbs4qznh-c.png"><br><br>  <b>DebuggerBrowsableAttribute</b> definiert, wie ein Feld oder eine Eigenschaft im Fenster mit den Debugger-Variablen angezeigt wird.  Akzeptiert einen DebuggerBrowsableState mit drei Optionen: <br><br><ul><li>  Nie - das Feld wird beim Debuggen überhaupt nicht angezeigt.  Beim Erweitern der Objekthierarchie wird dieses Feld nicht angezeigt </li><li>  Reduziert - Das Feld ist ungelöst, kann aber erweitert werden.  Dies ist das Standardverhalten. </li><li>  RootHidden - Das Feld selbst wird nicht angezeigt, aber die Objekte, aus denen es besteht, werden angezeigt (für Arrays und Sammlungen). </li></ul><br><img src="https://habrastorage.org/webt/6m/a5/gf/6ma5gf06sqj0eryekzparfrzq0i.png"><br><br>  <b>DebuggerTypeProxy</b> - Wenn ein Objekt hunderte Male am Tag im Debugger angezeigt wird, können Sie verwirrt sein und 3 Minuten damit verbringen, ein Proxy-Objekt zu erstellen, das das Quellobjekt so anzeigt, wie es sollte.  In der Regel ist das anzuzeigende Proxy-Objekt die innere Klasse.  Tatsächlich wird es anstelle des Zielobjekts angezeigt. <br><br><img src="https://habrastorage.org/webt/np/bg/zd/npbgzdwf_ontlgkwcr3adapeink.png"><br><br>  Andere nützliche Attribute <br><br>  <b>ThreadStatic</b> - Ein Attribut, mit dem Sie eine statische Variable für jeden Thread zu einer eigenen machen können.  Setzen Sie dazu das Attribut über das statische Feld.  Es lohnt sich, sich an eine wichtige Nuance zu erinnern: Die Initialisierung durch einen statischen Konstruktor wird nur einmal durchgeführt, und die Variable ändert sich in dem Thread, den der statische Konstruktor ausführt.  Im übrigen bleibt es voreingestellt.  (PS. Wenn Sie dieses Verhalten benötigen, empfehle ich Ihnen, sich der ThreadLocal-Klasse zuzuwenden.) <br><br>  Ein wenig über die Nuancen des Motorraums.  Sowohl unter Linux als auch unter Windows gibt es einen lokalen Speicherbereich für den Stream ( <abbr title="Thread lokalen Speicher">TLS</abbr> bzw. <abbr title="Thread-spezifische Daten">TSD</abbr> ).  Diese Bereiche selbst sind jedoch sehr klein.  Daher wird eine ThreadLocalInfo-Struktur erstellt, auf die in TLS ein Zeiger gesetzt wird.  Dementsprechend wird nur ein Steckplatz verwendet.  Die Struktur selbst enthält 3 Felder - Thread, AppDomain, ClrTlsInfo.  Wir interessieren uns für die erste.  Es ist es, das die Speicherung der Flussstatik im Speicher mithilfe von ThreadLocalBlock und ThreadLocalModule organisiert. <br><br>  Auf diese Weise: <br><br><ul><li>  Referenztypen - ThreadStaticHandleTable befindet sich auf dem Heap und wird von der ThreadLocalBlock-Klasse unterstützt. </li><li>  Strukturen - In einem verwalteten Heap gepackt und gespeichert sowie Referenztypen </li><li>  Primitive signifikante Typen werden in Bereichen des nicht verwalteten Speichers gespeichert, die Teil von ThreadLocalModule sind </li></ul><br>  Nun, da wir darüber sprechen, ist es erwähnenswert, über asynchrone Methoden zu sprechen.  Wie ein aufmerksamer Leser vielleicht bemerkt, wird bei Verwendung der Asynchronität die Fortsetzung nicht unbedingt im selben Thread ausgeführt (wir können den Ausführungskontext beeinflussen, jedoch nicht den Thread).  Dementsprechend bekommen wir einen Mist, wenn wir ThreadLocal verwenden.  In diesem Fall wird empfohlen, AsyncLocal zu verwenden.  Aber der Artikel handelt nicht davon, also gingen wir weiter. <br><br>  <b>InternalsVisibleTo</b> - Mit dieser Option können Sie die Baugruppe angeben, die für als <i>intern</i> gekennzeichnete Elemente sichtbar ist.  Es scheint, dass Sie, wenn eine Versammlung bestimmte Typen und deren Mitglieder benötigt, diese einfach als <i>öffentlich</i> und nicht als Dampf markieren können.  Eine gute Architektur setzt jedoch voraus, dass Implementierungsdetails ausgeblendet werden.  Trotzdem können sie für einige Infrastrukturzwecke benötigt werden, beispielsweise für Testprojekte.  Mit diesem Attribut können Sie sowohl die Kapselung als auch den erforderlichen Prozentsatz der Testabdeckung unterstützen. <br><br>  <b>HandleProcessCorruptedStateExceptions</b> - Ermöglicht es Ihnen, schüchterne Programmierer zu erschrecken und Ausnahmen eines beschädigten Zustands <b>abzufangen</b> .  Für solche Ausnahmen wird die CLR standardmäßig nicht abgefangen.  Im Allgemeinen wäre die beste Lösung, die Anwendung abstürzen zu lassen.  Dies sind gefährliche Ausnahmen, die darauf hinweisen, dass der Prozessspeicher beschädigt ist. Daher ist die Verwendung dieses Attributs eine sehr schlechte Idee.  In einigen Fällen ist es jedoch möglich, dass für die lokale Entwicklung dieses Attribut für eine Weile festgelegt wird.  Um die Ausnahme eines beschädigten Zustands abzufangen, setzen Sie dieses Attribut einfach über die Methode.  Und wenn dieses Attribut bereits verwendet wird, wird (wie immer) empfohlen, eine bestimmte Ausnahme abzufangen. <br><br>  <b>DisablePrivateReflection</b> - macht alle privaten Mitglieder der Assembly für die Reflexion unerreichbar.  Das Attribut wird in die Assembly eingefügt. <br><br><h2>  Definieren Sie Ihr Attribut </h2><br>  Nicht nur, weil dieser Abschnitt der letzte ist.  Der beste Weg, um zu verstehen, in welchen Fällen die Verwendung des Attributs von Vorteil ist, besteht darin, sich bereits verwendete Attribute anzusehen.  Es ist schwierig, eine formalisierte Regel zu formulieren, wenn Sie über Ihr eigenes Attribut nachdenken sollten.  Oft werden sie als zusätzliche Informationen über einen Typ / sein Mitglied oder ein anderes Sprachkonstrukt verwendet, das völlig anderen Entitäten gemeinsam ist.  Als Beispiel alle Attribute, die für Serialisierung / ORM / Formatierung usw. verwendet werden.  Aufgrund der umfassenden Anwendung dieser Mechanismen auf völlig unterschiedliche Typen, die den Entwicklern des entsprechenden Mechanismus häufig nicht bekannt sind, ist die Verwendung von Attributen eine hervorragende Möglichkeit, dem Benutzer die Bereitstellung deklarativer Informationen für diesen Mechanismus zu ermöglichen. <br><br>  Die Verwendung Ihrer Attribute kann in zwei Teile unterteilt werden: <br><br><ol><li>  Ein Attribut erstellen und verwenden </li><li>  Ein Attribut abrufen und verarbeiten </li></ol><br><h4>  Ein Attribut erstellen und verwenden </h4><br>  Um Ihr Attribut zu erstellen, reicht es aus, von <i>System.Attribute</i> zu erben.  In diesem Fall ist es ratsam, den genannten Namensstil einzuhalten - den Klassennamen auf Attribut zu beenden.  Es wird jedoch kein Fehler angezeigt, wenn Sie dieses Suffix weglassen.  Wie bereits erwähnt, können Attribute zwei Arten von Parametern haben - positionell und benannt.  Die Logik ihrer Anwendung ist dieselbe wie bei den Eigenschaften und Parametern des Konstruktors für die Klasse - die Werte, die zum Erstellen des Objekts erforderlich sind, für das es keinen vernünftigen "Standard" gibt, werden in Position (dh Konstruktor) gestellt.  Was vernünftigerweise voreingestellt werden kann, was häufig verwendet wird, wird besser in eine benannte (d. H. Eine Eigenschaft) unterschieden. <br><br>  Von nicht geringer Bedeutung für die Erstellung eines Attributs ist die Begrenzung seiner Anwendungsorte.  Hierfür wird AttributeUsageAttribute verwendet.  Der erforderliche Parameter (Position) ist das AttributeTarget, das bestimmt, wo das Attribut verwendet wird (Methode, Assembly usw.).  Optionale (benannte) Parameter sind: <br><br><ol><li>  AllowMultiple - Gibt an, ob es möglich ist, mehr als ein Attribut über dem Ort seiner Anwendung zu platzieren oder nicht.  Standardmäßig falsch </li><li>  Geerbt - Bestimmt, ob dieses Attribut zu Klassenvererbern (bei Platzierung über der Basisklasse) und überschriebenen Methoden (bei Platzierung über der Methode) gehört.  Der Standardwert ist true. </li></ol><br>  Danach können Sie die Attribute mit einer Nutzlast laden.  Ein Attribut ist eine deklarative Information, dh alles, was darin definiert ist, sollte die Konstruktion beschreiben, auf die es sich bezieht.  Das Attribut sollte keine tiefe Logik enthalten.  Für die Verarbeitung der von Ihnen definierten Attribute sollten spezielle Services verantwortlich sein, die sie nur verarbeiten.  Die Tatsache, dass das Attribut keine Logik haben sollte, bedeutet jedoch nicht, dass es keine Methoden haben sollte. <br><br>  Eine Methode (Funktion) ist auch Information und kann auch ein Design beschreiben.  Mithilfe von Polymorphismus in Attributen können Sie ein sehr leistungsfähiges und praktisches Tool bereitstellen, mit dem der Benutzer sowohl die von Ihrem Tool verwendeten Informationen als auch bestimmte Ausführungs- und Verarbeitungsstufen beeinflussen kann.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Fall muss er keine Klassen erstellen, Abhängigkeiten, Kostenfabriken und deren Schnittstellen einfügen, die diese Klassen erstellen. </font><font style="vertical-align: inherit;">Es reicht aus, eine einzelne Erbenklasse zu erstellen, die die Details der Arbeit mit dem Element enthält, auf das sie sich bezieht. </font><font style="vertical-align: inherit;">In der Regel reicht jedoch das übliche ROSO-Attribut mit einigen Eigenschaften aus.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abrufen und Verarbeiten eines Attributs </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verarbeitung der empfangenen Attribute hängt vom jeweiligen Fall ab und kann auf völlig unterschiedliche Weise erfolgen. Es ist schwierig, hierfür nützliche Funktionen und Tricks anzugeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attribute werden zur Laufzeit durch Reflektion erhalten. Es gibt verschiedene Möglichkeiten, ein Attribut von einem bestimmten Element abzurufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber alles stammt von der </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICustomAttributeProvider-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oberfläche </font><font style="vertical-align: inherit;">. Es wird von Typen wie Assembly, MemberInfo, Module, ParameterInfo implementiert. Die Nachfolger von MemberInfo sind wiederum Type, EventInfo, FieldInfo, MethodBase, PropertyInfo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schnittstelle hat nur 3 Funktionen und sie sind nicht sehr praktisch. Sie arbeiten mit Arrays (auch wenn wir wissen, dass es nur ein Attribut geben kann) und sind nicht nach Typ parametrisiert (sie verwenden Objekt). Daher müssen Sie selten direkt auf die Funktionen dieser Schnittstelle zugreifen (ich habe es nie gesagt, weil ich nicht kategorisch sein möchte). Zur Vereinfachung der Verwendung gibt es eine </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomAttributeExtensions-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klasse </font><font style="vertical-align: inherit;">, in der es viele Erweiterungsmethoden für alle Arten von Typen gibt, die einfache Operationen zum Umwandeln, Auswählen eines einzelnen Werts usw. ausführen, wodurch der Entwickler von dieser Notwendigkeit befreit wird. Diese Methoden sind auch als statisch in der Attributklasse verfügbar, mit der nützlichsten Funktion, den geerbten Parameter zu ignorieren (für Nonkonformisten).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die wichtigsten verwendeten Funktionen sind unten aufgeführt. </font><font style="vertical-align: inherit;">Der erste Parameter, der angibt, welcher Typ die Methode erweitert, habe ich weggelassen. </font><font style="vertical-align: inherit;">Überall dort, wo der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bool-Vererbungsparameter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> angegeben ist </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> kommt es ohne ihn zu einer Überladung (mit dem Standardwert </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Dieser Parameter gibt an, ob die Attribute der übergeordneten Klasse oder der Basismethode bei der Ausführung der Methode berücksichtigt werden sollen (falls sie für eine überschriebene Methode verwendet werden). </font><font style="vertical-align: inherit;">Wenn im Attribut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erben = flase angegeben ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><i><font style="vertical-align: inherit;">hilft</font></i><font style="vertical-align: inherit;"> es nicht, die Attribute der Basisklasse zu berücksichtigen, wenn Sie es auf true setzen</font></font><br><div class="scrollable-table"><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methodenname </font></font></th><th>  Beschreibung </th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributes &lt;LogAttribute&gt; (Bool-Erbe) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruft eine Aufzählung von Attributen des angegebenen Typs ab. </font><font style="vertical-align: inherit;">Wenn das Attribut eins ist, wird eine Aufzählung von 1 Element zurückgegeben</font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttribute &lt;LogAttribute&gt; (Bool-Erbe) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gibt ein einzelnes Attribut des angegebenen Typs zurück. </font><font style="vertical-align: inherit;">Wenn mehrere vorhanden sind, </font><i><font style="vertical-align: inherit;">lösen Sie</font></i><font style="vertical-align: inherit;"> eine </font><i><font style="vertical-align: inherit;">System.Reflection.AmbiguousMatchException aus: Mehrere benutzerdefinierte Attribute desselben Typs haben eine</font></i><font style="vertical-align: inherit;"> Ausnahme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gefunden</font></font></i> </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributes () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gibt eine Aufzählung von Attributen aller Typen zurück </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GetCustomAttributesData () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gibt eine Aufzählung CustomAttributeData zurück, in der es Eigenschaften gibt, mit denen Sie einen Konstruktor, Parameter (benannt und positionell) und Konstruktorargumente abrufen können </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IsDefined (Typ attrType, bool erben) </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gibt true zurück, wenn das Attribut über dem Element deklariert ist, andernfalls false </font></font></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aus Gründen der Klarheit schlage ich vor, eine kleine Demo der Arbeit aller genannten Funktionen anzusehen. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückgabewert der oben genannten Methoden</font></font></b> <div class="spoiler_text"><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.All, AllowMultiple = true)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LogAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LogName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [AttributeUsage(AttributeTargets.All, AllowMultiple = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, Inherited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SerializeAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SerializeName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogBase2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeBase2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogMethod2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeMethod2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogDerived2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeDerived2"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RandomDomainEntityDerived</span></span> : <span class="hljs-title"><span class="hljs-title">RandomDomainEntityBase</span></span> { [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride1"</span></span>)] [Log(LogName = <span class="hljs-string"><span class="hljs-string">"LogOverride2"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride1"</span></span>)] [Serialize(SerializeName = <span class="hljs-string"><span class="hljs-string">"SerializeOverride2"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VirtualMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotImplementedException(); } } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Type derivedType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(RandomDomainEntityDerived); MemberInfo overrideMethod = derivedType.GetMethod(<span class="hljs-string"><span class="hljs-string">"VirtualMethod"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// overrideMethod.GetCustomAttribute(typeof(LogAttribute)); //System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // overrideMethod.GetCustomAttribute&lt;LogAttribute&gt;(false); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. // Attribute.GetCustomAttribute(derivedType, typeof(SerializeAttribute)); // System.Reflection.AmbiguousMatchException: Multiple custom attributes of the same type found. IEnumerable&lt;Attribute&gt; allCustom = overrideMethod.GetCustomAttributes(); //LogOverride1 LogOverride2 SerializeOverride1 SerializeOverride2 LogMethod1 LogMethod2 IList&lt;CustomAttributeData&gt; allCustomInfo = overrideMethod.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:false); //LogOverride1 LogOverride2 IEnumerable&lt;LogAttribute&gt; typedInheritedCustom1 = overrideMethod.GetCustomAttributes&lt;LogAttribute&gt;(inherit:true); //LogOverride1 LogOverride2 LogMethod1 LogMethod2 IEnumerable&lt;SerializeAttribute&gt; typedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:false); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedCustom2 = overrideMethod.GetCustomAttributes&lt;SerializeAttribute&gt;(inherit:true); //SerializeOverride1 SerializeOverride2 Attribute[] customFromStaticClass = Attribute.GetCustomAttributes(overrideMethod, typeof(SerializeAttribute), inherit:true); //SerializeOverride1 SerializeOverride2 IEnumerable&lt;Attribute&gt; classCustom = derivedType.GetCustomAttributes(); //LogDerived1 LogDerived2 SerializeDerived1 SerializeDerived2 LogBase1 LogBase2 IList&lt;CustomAttributeData&gt; classCustomInfo = derivedType.GetCustomAttributesData(); //  ,     IEnumerable&lt;LogAttribute&gt; typedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(false); //LogDerived1 LogDerived2 IEnumerable&lt;LogAttribute&gt; typedInheritedClassCustom1 = derivedType.GetCustomAttributes&lt;LogAttribute&gt;(true); //LogDerived1 LogDerived2 LogBase1 LogBase2 IEnumerable&lt;SerializeAttribute&gt; typedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(false); //SerializeDerived1 SerializeDerived2 IEnumerable&lt;SerializeAttribute&gt; typedInheritedClassCustom2 = derivedType.GetCustomAttributes&lt;SerializeAttribute&gt;(true); //SerializeDerived1 SerializeDerived2 } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aus akademischen Gründen gebe ich ein Beispiel für die Definition von Attributen zur Laufzeit. </font><font style="vertical-align: inherit;">Dieser Code erhebt nicht den Anspruch, der schönste und am meisten unterstützte zu sein.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TypeCreator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> TypeSignature = <span class="hljs-string"><span class="hljs-string">"DynamicType"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ModuleName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> AssemblyName = <span class="hljs-string"><span class="hljs-string">"DynamicModule"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> TypeBuilder _typeBuilder = GetTypeBuilder(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTypeInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _typeBuilder.DefineNestedType(<span class="hljs-string"><span class="hljs-string">"ClassName"</span></span>); CreatePropertyWithAttribute&lt;SerializeAttribute&gt;(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Type newType = _typeBuilder.CreateType(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Activator.CreateInstance(newType); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CreatePropertyWithAttribute&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName, Type propertyType, Type[] ctorTypes, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] ctorArgs) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Attribute { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attributeCtor = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).GetConstructor(ctorTypes); CustomAttributeBuilder caBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CustomAttributeBuilder(attributeCtor, ctorArgs); PropertyBuilder newProperty = CreateProperty(propertyName, propertyType); newProperty.SetCustomAttribute(caBuilder); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PropertyBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName, Type propertyType</span></span></span><span class="hljs-function">)</span></span> { FieldBuilder fieldBuilder = _typeBuilder.DefineField(propertyName, propertyType, FieldAttributes.Private); PropertyBuilder propertyBuilder = _typeBuilder.DefineProperty(propertyName, PropertyAttributes.HasDefault, propertyType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); MethodAttributes getSetAttr = MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig; MethodBuilder getter = GenerateGetter(); MethodBuilder setter = GenerateSetter(); propertyBuilder.SetGetMethod(getter); propertyBuilder.SetSetMethod(setter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> propertyBuilder; <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateGetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder getMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"get_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, propertyType, Type.EmptyTypes); ILGenerator getterIl = getMethodBuilder.GetILGenerator(); getterIl.Emit(OpCodes.Ldarg_0); getterIl.Emit(OpCodes.Ldfld, fieldBuilder); getterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMethodBuilder; } <span class="hljs-function"><span class="hljs-function">MethodBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateSetter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { MethodBuilder setMethodBuilder = _typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">$"set_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{propertyName}</span></span></span><span class="hljs-string">"</span></span>, getSetAttr, <span class="hljs-literal"><span class="hljs-literal">null</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { propertyType }); ILGenerator setterIl = setMethodBuilder.GetILGenerator(); setterIl.Emit(OpCodes.Ldarg_0); setterIl.Emit(OpCodes.Ldarg_1); setterIl.Emit(OpCodes.Stfld, fieldBuilder); setterIl.Emit(OpCodes.Ret); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> setMethodBuilder; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TypeBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTypeBuilder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AssemblyName(AssemblyName), AssemblyBuilderAccess.Run); ModuleBuilder moduleBuilder = assemblyBuilder.DefineDynamicModule(ModuleName); TypeBuilder typeBuilder = moduleBuilder.DefineType(TypeSignature, TypeAttributes.Public | TypeAttributes.Class | TypeAttributes.AutoClass | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit | TypeAttributes.AutoLayout,<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typeBuilder; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TypeCreator().CreateTypeInstance(); IEnumerable&lt;Attribute&gt; attrs = instance.GetType().GetProperty(<span class="hljs-string"><span class="hljs-string">"PropWithAttr"</span></span>).GetCustomAttributes(); <span class="hljs-comment"><span class="hljs-comment">// Serializable } }</span></span></code> </pre><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468287/">https://habr.com/ru/post/de468287/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468265/index.html">Aus Vim Süßigkeiten machen</a></li>
<li><a href="../de468267/index.html">Stärkung der UseCase-Methodik im Buch Alistair Coburn</a></li>
<li><a href="../de468271/index.html">Tests vs. Typen - Rostversion</a></li>
<li><a href="../de468277/index.html">Ist die Arbeit des Programmierers schwierig - eine Sicht aus Sicht der Psychophysiologie</a></li>
<li><a href="../de468285/index.html">Top-Softwareentwicklungsunternehmen für Unternehmen und Startups</a></li>
<li><a href="../de468289/index.html">AM</a></li>
<li><a href="../de468291/index.html">Synopse aus Mark Gaulstons Buch "Ich kann dich durchhören"</a></li>
<li><a href="../de468293/index.html">Vive Cosmos - Test des neuen VR-Sets von HTC</a></li>
<li><a href="../de468295/index.html">50 Matplotlib-Schattierungen - The Master Plots (mit vollständigem Python-Code)</a></li>
<li><a href="../de468299/index.html">Was soll Oracle für einen Entwickler im Jahr 2019 (und danach) entwickeln?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>