<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🚀 💆 💧 Anotación incremental en proceso para acelerar las construcciones de gradle 💭 🚂 ⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A partir de las versiones Gradle 4.7 y Kotlin 1.3.30, fue posible obtener un ensamblaje incremental acelerado de proyectos debido a la operación corre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anotación incremental en proceso para acelerar las construcciones de gradle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/484918/"><p><img src="https://habrastorage.org/webt/ne/dq/wg/nedqwgztbpmabplkbivfwi8gx9s.jpeg" alt="imagen"></p><br><p>  A partir de las versiones Gradle 4.7 y Kotlin 1.3.30, fue posible obtener un ensamblaje incremental acelerado de proyectos debido a la operación correcta del procesamiento incremental de anotaciones.  En este artículo, entendemos cómo funciona la teoría de la compilación incremental en Gradle, qué se debe hacer para liberar todo su potencial (sin perder la generación de código al mismo tiempo) y qué tipo de aumento en la velocidad de los ensamblajes incrementales se puede lograr mediante la activación del procesamiento incremental de anotaciones en la práctica. </p><a name="habracut"></a><br><h2 id="kak-rabotaet-inkrementalnaya-kompilyaciya">  Cómo funciona la compilación incremental </h2><br><p>  Las construcciones incrementales en Gradle se implementan en dos niveles.  El primer nivel es cancelar el inicio de los módulos de recompilación utilizando <a href="https://docs.gradle.org/current/userguide/java_plugin.html">evitación de compilación</a> .  El segundo es la compilación incremental directa, iniciando el compilador dentro del marco de un módulo solo en aquellos archivos que han cambiado, o dependen directamente de los archivos cambiados. </p><br><p>  Consideremos evitar la compilación en un ejemplo (tomado de un <a href="https://blog.gradle.org/incremental-compiler-avoidance">artículo</a> de Gradle) de un proyecto de tres módulos: <strong>aplicación</strong> , <strong>núcleo</strong> y <strong>utilidades</strong> . </p><br><p>  La clase principal del módulo de la <strong>aplicación</strong> (depende del <strong>núcleo</strong> ): </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ WordCount wc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordCount(); wc.collect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); System.out.println(<span class="hljs-string"><span class="hljs-string">"Word count: "</span></span> + wc.wordCount()); } }</code> </pre> <br><p>  En el módulo <strong>central</strong> (depende de las <strong>utilidades</strong> ): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordCount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... void collect(File source) { IOUtils.eachLine(source, WordCount::collectLine); } }</span></span></code> </pre> <br><p>  En el módulo de <strong>utilidades</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eachLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Callable&lt;String&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (BufferedReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileReader(file))) { <span class="hljs-comment"><span class="hljs-comment">// ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  El orden de la primera compilación de los módulos es el siguiente (de acuerdo con el orden de las dependencias): </p><br><p>  1) <strong>utils</strong> <br>  2) <strong>núcleo</strong> <br>  3) <strong>aplicación</strong> </p><br><p>  Ahora considere lo que sucede cuando cambia la implementación interna de la clase IOUtils: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// IOUtils lives in project `utils` void eachLine(File file, Callable&lt;String&gt; action) { try { try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "utf-8") )) { // ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  Este cambio no afecta al módulo ABI.  ABI (Application Binary Interface) es una representación binaria de la interfaz pública del módulo ensamblado.  En el caso en que el cambio se relacione solo con la implementación interna del módulo y no afecte su interfaz pública de ninguna manera, Gradle utilizará la evitación de compilación e iniciará la recompilación solo del módulo <strong>utils</strong> .  Si la ABI del módulo de <strong>utilidades</strong> se ve afectada (por ejemplo, aparece un método público adicional o cambia la firma del existente), entonces la compilación del módulo <strong>principal</strong> comenzará adicionalmente, pero el módulo de la <strong>aplicación</strong> dependiente del <strong>núcleo</strong> no se volverá a compilar transitivamente si la dependencia en él está conectada a través de la <a href="https://medium.com/mindorks/implementation-vs-api-in-gradle-3-0-494c817a6fa">implementación</a> . </p><br><p><img src="https://habrastorage.org/webt/io/pv/b-/iopvb-pf4b-fzrwksogs3ydsuzk.png"><br>  <em>Ilustración de la evitación de compilación a nivel del módulo del proyecto</em> </p><br><p>  El segundo nivel de incremento es el incremento en el nivel de inicio del compilador para archivos modificados directamente dentro de módulos individuales. </p><br><p>  Por ejemplo, agregue una nueva clase al módulo <strong>principal</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NGrams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NGrams lives in project `core` // ... void collect(String source, int ngramLength) { collectInternal(StringUtils.sanitize(source), ngramLength); } // ... }</span></span></code> </pre> <br><p>  Y en <strong>utilidades</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanitize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String dirtyString)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  En este caso, en ambos módulos, solo se deben volver a compilar dos archivos nuevos (sin afectar a WordCount y IOUtils existentes y no modificados), ya que no hay dependencias entre las clases nuevas y antiguas. </p><br><p>  Por lo tanto, el compilador incremental analiza las dependencias entre clases y solo vuelve a compilar: </p><br><ul><li>  clases que contienen cambios </li><li><p>  clases que dependen directamente de las clases cambiantes </p><br><h2 id="inkrementalnyy-annotation-processing">  Procesamiento de anotación incremental </h2><br><p><img src="https://habrastorage.org/webt/qd/qy/c1/qdqyc14pw7rak4d89dgft7oylus.png" alt="ingrese la descripción de la imagen aquí"></p><br></li></ul><br><p>  Generar código usando APT y KAPT reduce el tiempo que lleva escribir y depurar código repetitivo, pero el procesamiento de anotaciones puede aumentar significativamente el tiempo de construcción.  Para empeorar las cosas, durante mucho tiempo, el procesamiento de anotaciones rompió fundamentalmente las posibilidades de compilación incremental en Gradle. </p><br><p>  Cada procesador de anotaciones en un proyecto le dice al compilador información sobre la lista de anotaciones que procesa.  Pero desde el punto de vista del ensamblaje, el procesamiento de anotaciones es un cuadro negro: Gradle no sabe qué hará el procesador, en particular, qué archivos generará y dónde.  Hasta Gradle 4.7, la compilación incremental se deshabilitaba automáticamente en aquellos conjuntos de origen donde se usaban procesadores de anotación. </p><br><p>  Con el <a href="https://docs.gradle.org/4.7/userguide/java_plugin.html">lanzamiento de</a> Gradle 4.7, la compilación incremental ahora admite el procesamiento de anotaciones, pero solo para APT.  En KAPT, el soporte para la anotación incremental se ha <a href="https://blog.jetbrains.com/kotlin/2019/04/kotlin-1-3-30-released/">introducido</a> con Kotlin 1.3.30.  También requiere <a href="https://docs.gradle.org/current/userguide/java_plugin.html">soporte</a> de bibliotecas que proporcionan procesadores de anotaciones.  Los desarrolladores de procesadores de anotaciones tienen la oportunidad de establecer explícitamente la categoría del procesador, informando a Gradle de la información necesaria para que funcione la compilación incremental. </p><br><h2 id="kategorii-processorov-annotaciy">  Categorías del procesador de anotaciones </h2><br><p>  Gradle admite dos categorías de procesadores: </p><br><p>  <strong>Aislamiento</strong> : dichos procesadores deben tomar todas las decisiones para la generación de código basándose únicamente en la información de <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">AST</a> que está asociada con un elemento de una anotación particular.  Esta es la categoría más rápida de procesadores de anotaciones, ya que Gradle puede no reiniciar el procesador y usar los archivos que generó previamente si no hubiera cambios en el archivo fuente. </p><br><p>  <strong>Agregación</strong> : se utiliza para procesadores que toman decisiones basadas en varias entradas (por ejemplo, análisis de anotaciones en varios archivos a la vez o en el estudio de AST, al que se puede acceder de forma transitiva desde un elemento anotado).  Cada vez, Gradle iniciará el procesador para archivos que usan anotaciones del procesador de agregación, pero no volverá a compilar los archivos que genera si no hay cambios en ellos. </p><br><p>  Para muchas bibliotecas populares basadas en la generación de código, el soporte de compilación incremental ya está implementado en las últimas versiones.  Vea la lista de bibliotecas que lo admiten <a href="https://docs.gradle.org/current/userguide/java_plugin.html">aquí</a> . </p><br><h2 id="nash-opyt-vnedreniya-incremental-annotation-processing">  Nuestra experiencia implementando procesamiento de anotaciones incrementales </h2><br><p>  Ahora, para los proyectos que comienzan desde cero y usan las últimas versiones de bibliotecas y complementos de Gradle, es probable que las compilaciones incrementales estén activas de manera predeterminada.  Pero la mayor parte del aumento en la productividad del ensamblaje se puede lograr mediante la incrementalidad del procesamiento de anotaciones en proyectos grandes y de larga duración.  En este caso, puede ser necesaria una actualización masiva de la versión.  ¿Vale la pena en la práctica?  A ver! </p><br><p>  Entonces, para que el procesamiento incremental de anotaciones funcione, necesitamos: </p><br><ul><li>  Gradle 4.7+ </li><li>  Kotlin 1.3.30+ </li><li>  Todos los procesadores de anotaciones en nuestro proyecto deben tener su apoyo.  Esto es muy importante, porque si en un solo módulo al menos un procesador no admite incrementalidad, Gradle lo deshabilitará para todo el módulo.  ¡Todos los archivos en el módulo serán compilados nuevamente cada vez!  Una de las opciones alternativas para obtener soporte para la compilación incremental sin actualizar las versiones es la eliminación de todo el código utilizando procesadores de anotaciones en un módulo separado.  En los módulos que no tienen procesadores de anotaciones, la compilación incremental funcionará bien </li></ul><br><p>  Para detectar procesadores que no satisfacen la última condición, puede ejecutar el ensamblaje con el indicador <em>-Pkapt.verbose = true</em> .  Si Gradle se vio obligado a deshabilitar el procesamiento de anotaciones incrementales para un solo módulo, en el registro de compilación veremos un mensaje sobre qué procesadores y en qué módulos está sucediendo esto (vea el nombre de la tarea): </p><br><pre> <code class="plaintext hljs">&gt; Task :common:kaptDebugKotlin w: [kapt] Incremental annotation processing requested, but support is disabled because the following processors are not incremental: toothpick.compiler.factory.FactoryProcessor (NON_INCREMENTAL), toothpick.compiler.memberinjector.MemberInjectorProcessor (NON_INCREMENTAL).</code> </pre> <br><p>  En nuestro proyecto de biblioteca con procesadores de anotaciones no incrementales, había 3: </p><br><ul><li>  Palillo de dientes </li><li>  Habitacion </li><li>  PermisosDispatcher </li></ul><br><p>  Afortunadamente, estas bibliotecas son compatibles activamente, y sus últimas versiones ya tienen soporte incremental.  Además, todos los procesadores de anotaciones en las últimas versiones de estas bibliotecas tienen una categoría óptima: aislar.  En el proceso de subir las versiones, tuve que lidiar con la refactorización debido a cambios en la API de la biblioteca Toothpick, que afectó a casi todos los módulos nuestros.  Pero en este caso, tuvimos suerte, y resultó ser una refactorización completamente automática utilizando los nombres de reemplazo automático de los métodos de biblioteca pública utilizados. </p><br><p>  Tenga en cuenta que si usa la biblioteca de <em>salas</em> , deberá pasar explícitamente la <em>marca room.incremental: true</em> al procesador de anotaciones.  <a href="https://developer.android.com/jetpack/androidx/releases/room">Un ejemplo</a>  En el futuro, los desarrolladores de Room <a href="https://developer.android.com/jetpack/androidx/releases/room">planean</a> habilitar esta bandera por defecto. </p><br><p>  Para las versiones de Kotlin 1.3.30-1.3.50, debe habilitar el soporte para el procesamiento incremental de anotaciones <strong>explícitamente a</strong> través de <em>kapt.incremental.apt = true</em> en el archivo gradle.properties del proyecto.  A partir de la versión 1.3.50, esta opción se establece en true de forma predeterminada. </p><br><h2 id="profayling-inkrementalnyh-sborok">  Perfiles incrementales de ensamblaje </h2><br><p>  Después de que se hayan generado las versiones de todas las dependencias necesarias, es hora de probar la velocidad de las compilaciones incrementales.  Para hacer esto, utilizamos el siguiente conjunto de herramientas y técnicas: </p><br><ul><li>  <a href="https://guides.gradle.org/creating-build-scans/">Escaneo de construcción Gradle</a> </li><li>  <a href="https://github.com/gradle/gradle-profiler">gradle-profiler</a> </li><li>  Para ejecutar scripts con procesamiento de anotación incremental habilitado y deshabilitado, se usó la propiedad <em>gradle kapt.incremental.apt = [true | false]</em> </li><li>  Para obtener resultados consistentes e informativos, las asambleas se generaron en un entorno de CI separado.  La incrementalidad de construcción se reprodujo utilizando gradle-profiler </li></ul><br><p>  gradle-profiler permite preparar <a href="https://github.com/gradle/gradle-profiler">scripts</a> declarativamente para puntos de referencia de compilación incremental.  Se compilaron 4 escenarios basados ​​en las siguientes condiciones: </p><br><ul><li>  La modificación de un archivo afecta / no afecta su ABI </li><li>  Soporte para el procesamiento de anotación incremental activado / desactivado </li></ul><br><p>  La ejecución de cada uno de los escenarios es una secuencia de: </p><br><ul><li>  Reiniciar el demonio gradle </li><li>  Lanzar compilaciones de calentamiento </li><li>  Ejecute 10 ensamblajes incrementales, antes de cada uno de los cuales se cambia un archivo agregando un nuevo método (privado para cambios no ABI y público para cambios ABI) </li></ul><br><p>  Todas las compilaciones se realizaron con Gradle 5.4.1.  El archivo involucrado en los cambios se refiere a uno de los módulos principales del proyecto (común), del cual dependen directamente 40 módulos (incluidos el núcleo y la función).  Este archivo usa la anotación para aislar el procesador. </p><br><p>  También vale la pena señalar que la ejecución de referencia se realizó en dos tareas <em>básicas</em> : <em>ompileDebugSources</em> y <em>assembleDebug</em> .  El primero solo inicia la compilación de archivos con código fuente, sin hacer ningún trabajo con recursos y agrupando la aplicación en un archivo .apk.  Basado en el hecho de que la compilación incremental afecta solo a los archivos .kt y .java, se <em>eligió la</em> tarea <em>compileDedugSource</em> para una evaluación comparativa más aislada y más rápida.  En condiciones de desarrollo reales, cuando reinicia la aplicación, Android Studio utiliza la tarea <em>assembleDebug</em> , que incluye la generación completa de la versión de depuración de la aplicación. </p><br><h2 id="rezultaty-benchmarkov">  Resultados de referencia </h2><br><p>  En todos los gráficos generados por gradle-profiler, el eje vertical muestra el tiempo de ensamblaje incremental en milisegundos, y el eje horizontal muestra el número de inicio del ensamblaje. </p><br><h3 id="compiledebugsource-do-obnovleniya-processorov-annotaciy">  : compileDebugSource antes de actualizar los procesadores de anotaciones </h3><br><p><img src="https://habrastorage.org/webt/mn/cd/jj/mncdjjla37vj8ogbycy0szzpj-e.png" alt="ingrese la descripción de la imagen aquí"><br>  El tiempo de ejecución promedio para cada escenario fue de 38 segundos antes de actualizar los procesadores de anotaciones a versiones que admitan incrementalidad.  En este caso, Gradle desactiva el soporte para la compilación incremental, por lo que no hay una diferencia significativa entre los scripts. </p><br><h3 id="compiledebugsource-posle-obnovleniya-processorov-annotaciy">  : compileDebugSource después de actualizar los procesadores de anotaciones </h3><br><p><img src="https://habrastorage.org/webt/wk/fk/h1/wkfkh1e37r3jpagocxqbdi4twqk.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Escenario </th><th>  Cambio incremental de ABI </th><th>  Cambio de ABI no incremental </th><th>  Cambio incremental no ABI </th><th>  Cambio no incremental no abi </th></tr></thead><tbody><tr><td>  <strong>malvado</strong> </td><td>  23978 </td><td>  35370 </td><td>  23514 </td><td>  34602 </td></tr><tr><td>  <strong>mediana</strong> </td><td>  23879 </td><td>  35019 </td><td>  23424 </td><td>  34749 </td></tr><tr><td>  <strong>min</strong> </td><td>  22618 </td><td>  33969 </td><td>  22343 </td><td>  33292 </td></tr><tr><td>  <strong>max</strong> </td><td>  26820 </td><td>  38097 </td><td>  25651 </td><td>  35843 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  1193,29 </td><td>  1240.81 </td><td>  888,24 </td><td>  815,91 </td></tr></tbody></table></div><br><p>  La reducción media en el tiempo de montaje debido a la incrementalidad fue del 31% para los cambios ABI y del 32,5% para los cambios no ABI.  En valor absoluto, unos 10 segundos. </p><br><h3 id="assembledebug-posle-obnovleniya-processorov-annotaciy">  : assembleDebug después de actualizar los procesadores de anotaciones </h3><br><p><img src="https://habrastorage.org/webt/fa/5h/qx/fa5hqxvowacrovlvmc12xard7_i.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Escenario </th><th>  Cambio incremental de ABI </th><th>  Cambio de ABI no incremental </th><th>  Cambio incremental no ABI </th><th>  Cambio no incremental no abi </th></tr></thead><tbody><tr><td>  <strong>malvado</strong> </td><td>  39902 </td><td>  49850 </td><td>  39005 </td><td>  52123 </td></tr><tr><td>  <strong>mediana</strong> </td><td>  38974 </td><td>  49691 </td><td>  38713 </td><td>  50336 </td></tr><tr><td>  <strong>min</strong> </td><td>  38563 </td><td>  48782 </td><td>  38233 </td><td>  48944 </td></tr><tr><td>  <strong>max</strong> </td><td>  48255 </td><td>  52364 </td><td>  41732 </td><td>  65941 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  2953,28 </td><td>  1011.20 </td><td>  1015,37 </td><td>  5039.11 </td></tr></tbody></table></div><br><p>  Para compilar la versión de depuración completa de la aplicación en nuestro proyecto, la disminución media en el tiempo de compilación debido al incremento fue del 21.5% para cambios ABI y del 23% para cambios no ABI.  En términos absolutos, aproximadamente los mismos 10 segundos, ya que el incremento de la compilación del código fuente no afecta la velocidad de ensamblaje de los recursos. </p><br><h2 id="anatomiya-sborki-v-gradle-build-scan">  Build Scan Anatomy en Gradle Build Scan </h2><br><p>  Para una comprensión más profunda de cómo se logró el incremento durante la compilación incremental, comparamos escaneos de ensamblajes incrementales y no incrementales. </p><br><p>  En el caso de un incremento KAPT deshabilitado, la parte principal del tiempo de compilación es la compilación del módulo de la aplicación, que no se puede paralelizar con otras tareas.  La línea de tiempo para KAPT no incremental es la siguiente: </p><br><p><img src="https://habrastorage.org/webt/r0/cw/_n/r0cw_n4xvp7olnharknhce--9fe.png" alt="ingrese la descripción de la imagen aquí"></p><br><p>  Ejecución de la tarea: kaptDebugKotlin de nuestro módulo de aplicación tarda unos 8 segundos en este caso. </p><br><p>  Línea de tiempo para el caso con el incremento KAPT habilitado: </p><br><p><img src="https://habrastorage.org/webt/_u/xt/se/_uxtsee_4jt_g7oems5ggxbm3rg.png" alt="ingrese la descripción de la imagen aquí"></p><br><p>  Ahora el módulo de la aplicación se ha vuelto a compilar en menos de un segundo.  Vale la pena prestar atención a la desproporción visual de las escalas de los dos escaneos en la imagen de arriba.  Las tareas que parecen más cortas en la primera imagen no son necesariamente más largas en la segunda, donde parecen más largas.  Pero es muy notable cuánto ha disminuido la proporción de recompilación del módulo de la aplicación cuando activa KAPT incremental.  En nuestro caso, ganamos unos 8 segundos en este módulo y unos 2 segundos adicionales en módulos más pequeños que se compilan en paralelo. </p><br><p>  Al mismo tiempo, el tiempo total de ejecución de todas las tareas * kapt para la incrementalidad deshabilitada de las anotaciones de procesamiento es de 1 minuto y 36 segundos contra 55 segundos cuando está activado.  Es decir, sin tener en cuenta el ensamblaje paralelo de los módulos, la ganancia es más sustancial. </p><br><p>  También vale la pena señalar que los resultados de referencia anteriores se prepararon en un entorno CI con la capacidad de ejecutar 24 subprocesos paralelos para el ensamblaje.  En un entorno de 8 subprocesos, la ganancia de habilitar el procesamiento de anotación incremental es de aproximadamente 20-30 segundos en nuestro proyecto. </p><br><h2 id="incremental-vs--parallel">  Incremental vs (?) Paralelo </h2><br><p>  Otra forma de acelerar significativamente el ensamblaje (tanto incremental como limpio) es realizar tareas de gradle en paralelo al dividir el proyecto en una gran cantidad de módulos sueltos.  De una forma u otra, la modularización representa un potencial mucho mayor para acelerar los ensamblajes que el uso de KAPT incremental.  Pero cuanto más monolítico sea el proyecto, y cuanto más generación de código se use en él, mayor será el procesamiento incremental de las anotaciones.  Es más fácil obtener el efecto de la incrementalidad completa de los ensamblajes que dividir una aplicación en módulos.  Sin embargo, ambos enfoques no se contradicen y se complementan perfectamente entre sí. </p><br><h2 id="itog">  Resumen </h2><br><ul><li>  La inclusión del procesamiento incremental de anotaciones en nuestro proyecto nos permitió lograr un aumento del 20% en la velocidad de la reconstrucción local. </li><li>  Para habilitar el procesamiento de anotación incremental, será útil estudiar el registro completo de los ensamblados actuales y buscar mensajes de advertencia con el texto "Procesamiento de anotación incremental solicitado, pero el soporte está deshabilitado porque los siguientes procesadores no son incrementales ...".  Es necesario actualizar las versiones de las bibliotecas a versiones con soporte para el procesamiento incremental de anotaciones y tener versiones Gradle 4.7+, Kotlin 1.3.30+ </li></ul><br><h3 id="materialy-i-chto-pochitat-po-teme">  Materiales y qué leer sobre el tema. </h3><br><ul><li>  <a href="https://docs.gradle.org/6.0.1/userguide/java_plugin.html">Acerca de la compatibilidad con el procesamiento de anotaciones iniciales en el nivel del complemento Gradle Java</a> </li><li>  <a href="https://medium.com/andrews-tech-blog/the-gradle-profiler-part-1-introduction-bdcbe70efe08">Artículo sobre gradle-profiler</a> </li><li>  <a href="https://kotlinlang.org/docs/reference/kapt.html">Más sobre las características de KAPT</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DsQC9-Rj2yLI">Informe sobre Google I / O 2019 con trucos de aceleración de compilación actuales</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3D7ll-rkLCtyk">Otro informe sobre Gradle Optimization en Google I / O 2017, incluye material de construcción incremental y evitación de compilación</a> </li></ul></div></div><p>Source: <a href="https://habr.com/ru/post/484918/">https://habr.com/ru/post/484918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484902/index.html">En ecuaciones de grados superiores</a></li>
<li><a href="../484904/index.html">Un año sin Splunk: cómo una empresa estadounidense cambió el mercado de análisis de datos de máquinas en Rusia y a quién dejó atrás</a></li>
<li><a href="../484906/index.html">Equipo distribuido y líder de equipo en remoto</a></li>
<li><a href="../484908/index.html">HighLoad ++, Eugene Kuzovlev (EcommPay IT): qué hacer cuando un minuto de tiempo de inactividad cuesta $ 100,000</a></li>
<li><a href="../484910/index.html">Paul Graham: enemigos</a></li>
<li><a href="../484920/index.html">¿Cómo entender que usted es un operador de fresadoras?</a></li>
<li><a href="../484930/index.html">Codifiquemos rápidamente como profesionales</a></li>
<li><a href="../484932/index.html">La naturaleza dual de los requisitos de software.</a></li>
<li><a href="../484934/index.html">Desde el desarrollo personal hasta Agile en una escala XXXL en dos días en TeamLead Conf</a></li>
<li><a href="../484936/index.html">Conocimientos y competencias en el equipo: encontrar, ver, bombear</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>