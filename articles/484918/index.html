<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>锯   Anotaci贸n incremental en proceso para acelerar las construcciones de gradle   锔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A partir de las versiones Gradle 4.7 y Kotlin 1.3.30, fue posible obtener un ensamblaje incremental acelerado de proyectos debido a la operaci贸n corre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anotaci贸n incremental en proceso para acelerar las construcciones de gradle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/484918/"><p><img src="https://habrastorage.org/webt/ne/dq/wg/nedqwgztbpmabplkbivfwi8gx9s.jpeg" alt="imagen"></p><br><p>  A partir de las versiones Gradle 4.7 y Kotlin 1.3.30, fue posible obtener un ensamblaje incremental acelerado de proyectos debido a la operaci贸n correcta del procesamiento incremental de anotaciones.  En este art铆culo, entendemos c贸mo funciona la teor铆a de la compilaci贸n incremental en Gradle, qu茅 se debe hacer para liberar todo su potencial (sin perder la generaci贸n de c贸digo al mismo tiempo) y qu茅 tipo de aumento en la velocidad de los ensamblajes incrementales se puede lograr mediante la activaci贸n del procesamiento incremental de anotaciones en la pr谩ctica. </p><a name="habracut"></a><br><h2 id="kak-rabotaet-inkrementalnaya-kompilyaciya">  C贸mo funciona la compilaci贸n incremental </h2><br><p>  Las construcciones incrementales en Gradle se implementan en dos niveles.  El primer nivel es cancelar el inicio de los m贸dulos de recompilaci贸n utilizando <a href="https://docs.gradle.org/current/userguide/java_plugin.html">evitaci贸n de compilaci贸n</a> .  El segundo es la compilaci贸n incremental directa, iniciando el compilador dentro del marco de un m贸dulo solo en aquellos archivos que han cambiado, o dependen directamente de los archivos cambiados. </p><br><p>  Consideremos evitar la compilaci贸n en un ejemplo (tomado de un <a href="https://blog.gradle.org/incremental-compiler-avoidance">art铆culo</a> de Gradle) de un proyecto de tres m贸dulos: <strong>aplicaci贸n</strong> , <strong>n煤cleo</strong> y <strong>utilidades</strong> . </p><br><p>  La clase principal del m贸dulo de la <strong>aplicaci贸n</strong> (depende del <strong>n煤cleo</strong> ): </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... args)</span></span></span><span class="hljs-function"> </span></span>{ WordCount wc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WordCount(); wc.collect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); System.out.println(<span class="hljs-string"><span class="hljs-string">"Word count: "</span></span> + wc.wordCount()); } }</code> </pre> <br><p>  En el m贸dulo <strong>central</strong> (depende de las <strong>utilidades</strong> ): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordCount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... void collect(File source) { IOUtils.eachLine(source, WordCount::collectLine); } }</span></span></code> </pre> <br><p>  En el m贸dulo de <strong>utilidades</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eachLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, Callable&lt;String&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (BufferedReader reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileReader(file))) { <span class="hljs-comment"><span class="hljs-comment">// ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  El orden de la primera compilaci贸n de los m贸dulos es el siguiente (de acuerdo con el orden de las dependencias): </p><br><p>  1) <strong>utils</strong> <br>  2) <strong>n煤cleo</strong> <br>  3) <strong>aplicaci贸n</strong> </p><br><p>  Ahora considere lo que sucede cuando cambia la implementaci贸n interna de la clase IOUtils: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IOUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// IOUtils lives in project `utils` void eachLine(File file, Callable&lt;String&gt; action) { try { try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "utf-8") )) { // ... } } catch (IOException e) { // ... } } }</span></span></code> </pre> <br><p>  Este cambio no afecta al m贸dulo ABI.  ABI (Application Binary Interface) es una representaci贸n binaria de la interfaz p煤blica del m贸dulo ensamblado.  En el caso en que el cambio se relacione solo con la implementaci贸n interna del m贸dulo y no afecte su interfaz p煤blica de ninguna manera, Gradle utilizar谩 la evitaci贸n de compilaci贸n e iniciar谩 la recompilaci贸n solo del m贸dulo <strong>utils</strong> .  Si la ABI del m贸dulo de <strong>utilidades</strong> se ve afectada (por ejemplo, aparece un m茅todo p煤blico adicional o cambia la firma del existente), entonces la compilaci贸n del m贸dulo <strong>principal</strong> comenzar谩 adicionalmente, pero el m贸dulo de la <strong>aplicaci贸n</strong> dependiente del <strong>n煤cleo</strong> no se volver谩 a compilar transitivamente si la dependencia en 茅l est谩 conectada a trav茅s de la <a href="https://medium.com/mindorks/implementation-vs-api-in-gradle-3-0-494c817a6fa">implementaci贸n</a> . </p><br><p><img src="https://habrastorage.org/webt/io/pv/b-/iopvb-pf4b-fzrwksogs3ydsuzk.png"><br>  <em>Ilustraci贸n de la evitaci贸n de compilaci贸n a nivel del m贸dulo del proyecto</em> </p><br><p>  El segundo nivel de incremento es el incremento en el nivel de inicio del compilador para archivos modificados directamente dentro de m贸dulos individuales. </p><br><p>  Por ejemplo, agregue una nueva clase al m贸dulo <strong>principal</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NGrams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NGrams lives in project `core` // ... void collect(String source, int ngramLength) { collectInternal(StringUtils.sanitize(source), ngramLength); } // ... }</span></span></code> </pre> <br><p>  Y en <strong>utilidades</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringUtils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanitize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String dirtyString)</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  En este caso, en ambos m贸dulos, solo se deben volver a compilar dos archivos nuevos (sin afectar a WordCount y IOUtils existentes y no modificados), ya que no hay dependencias entre las clases nuevas y antiguas. </p><br><p>  Por lo tanto, el compilador incremental analiza las dependencias entre clases y solo vuelve a compilar: </p><br><ul><li>  clases que contienen cambios </li><li><p>  clases que dependen directamente de las clases cambiantes </p><br><h2 id="inkrementalnyy-annotation-processing">  Procesamiento de anotaci贸n incremental </h2><br><p><img src="https://habrastorage.org/webt/qd/qy/c1/qdqyc14pw7rak4d89dgft7oylus.png" alt="ingrese la descripci贸n de la imagen aqu铆"></p><br></li></ul><br><p>  Generar c贸digo usando APT y KAPT reduce el tiempo que lleva escribir y depurar c贸digo repetitivo, pero el procesamiento de anotaciones puede aumentar significativamente el tiempo de construcci贸n.  Para empeorar las cosas, durante mucho tiempo, el procesamiento de anotaciones rompi贸 fundamentalmente las posibilidades de compilaci贸n incremental en Gradle. </p><br><p>  Cada procesador de anotaciones en un proyecto le dice al compilador informaci贸n sobre la lista de anotaciones que procesa.  Pero desde el punto de vista del ensamblaje, el procesamiento de anotaciones es un cuadro negro: Gradle no sabe qu茅 har谩 el procesador, en particular, qu茅 archivos generar谩 y d贸nde.  Hasta Gradle 4.7, la compilaci贸n incremental se deshabilitaba autom谩ticamente en aquellos conjuntos de origen donde se usaban procesadores de anotaci贸n. </p><br><p>  Con el <a href="https://docs.gradle.org/4.7/userguide/java_plugin.html">lanzamiento de</a> Gradle 4.7, la compilaci贸n incremental ahora admite el procesamiento de anotaciones, pero solo para APT.  En KAPT, el soporte para la anotaci贸n incremental se ha <a href="https://blog.jetbrains.com/kotlin/2019/04/kotlin-1-3-30-released/">introducido</a> con Kotlin 1.3.30.  Tambi茅n requiere <a href="https://docs.gradle.org/current/userguide/java_plugin.html">soporte</a> de bibliotecas que proporcionan procesadores de anotaciones.  Los desarrolladores de procesadores de anotaciones tienen la oportunidad de establecer expl铆citamente la categor铆a del procesador, informando a Gradle de la informaci贸n necesaria para que funcione la compilaci贸n incremental. </p><br><h2 id="kategorii-processorov-annotaciy">  Categor铆as del procesador de anotaciones </h2><br><p>  Gradle admite dos categor铆as de procesadores: </p><br><p>  <strong>Aislamiento</strong> : dichos procesadores deben tomar todas las decisiones para la generaci贸n de c贸digo bas谩ndose 煤nicamente en la informaci贸n de <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">AST</a> que est谩 asociada con un elemento de una anotaci贸n particular.  Esta es la categor铆a m谩s r谩pida de procesadores de anotaciones, ya que Gradle puede no reiniciar el procesador y usar los archivos que gener贸 previamente si no hubiera cambios en el archivo fuente. </p><br><p>  <strong>Agregaci贸n</strong> : se utiliza para procesadores que toman decisiones basadas en varias entradas (por ejemplo, an谩lisis de anotaciones en varios archivos a la vez o en el estudio de AST, al que se puede acceder de forma transitiva desde un elemento anotado).  Cada vez, Gradle iniciar谩 el procesador para archivos que usan anotaciones del procesador de agregaci贸n, pero no volver谩 a compilar los archivos que genera si no hay cambios en ellos. </p><br><p>  Para muchas bibliotecas populares basadas en la generaci贸n de c贸digo, el soporte de compilaci贸n incremental ya est谩 implementado en las 煤ltimas versiones.  Vea la lista de bibliotecas que lo admiten <a href="https://docs.gradle.org/current/userguide/java_plugin.html">aqu铆</a> . </p><br><h2 id="nash-opyt-vnedreniya-incremental-annotation-processing">  Nuestra experiencia implementando procesamiento de anotaciones incrementales </h2><br><p>  Ahora, para los proyectos que comienzan desde cero y usan las 煤ltimas versiones de bibliotecas y complementos de Gradle, es probable que las compilaciones incrementales est茅n activas de manera predeterminada.  Pero la mayor parte del aumento en la productividad del ensamblaje se puede lograr mediante la incrementalidad del procesamiento de anotaciones en proyectos grandes y de larga duraci贸n.  En este caso, puede ser necesaria una actualizaci贸n masiva de la versi贸n.  驴Vale la pena en la pr谩ctica?  A ver! </p><br><p>  Entonces, para que el procesamiento incremental de anotaciones funcione, necesitamos: </p><br><ul><li>  Gradle 4.7+ </li><li>  Kotlin 1.3.30+ </li><li>  Todos los procesadores de anotaciones en nuestro proyecto deben tener su apoyo.  Esto es muy importante, porque si en un solo m贸dulo al menos un procesador no admite incrementalidad, Gradle lo deshabilitar谩 para todo el m贸dulo.  隆Todos los archivos en el m贸dulo ser谩n compilados nuevamente cada vez!  Una de las opciones alternativas para obtener soporte para la compilaci贸n incremental sin actualizar las versiones es la eliminaci贸n de todo el c贸digo utilizando procesadores de anotaciones en un m贸dulo separado.  En los m贸dulos que no tienen procesadores de anotaciones, la compilaci贸n incremental funcionar谩 bien </li></ul><br><p>  Para detectar procesadores que no satisfacen la 煤ltima condici贸n, puede ejecutar el ensamblaje con el indicador <em>-Pkapt.verbose = true</em> .  Si Gradle se vio obligado a deshabilitar el procesamiento de anotaciones incrementales para un solo m贸dulo, en el registro de compilaci贸n veremos un mensaje sobre qu茅 procesadores y en qu茅 m贸dulos est谩 sucediendo esto (vea el nombre de la tarea): </p><br><pre> <code class="plaintext hljs">&gt; Task :common:kaptDebugKotlin w: [kapt] Incremental annotation processing requested, but support is disabled because the following processors are not incremental: toothpick.compiler.factory.FactoryProcessor (NON_INCREMENTAL), toothpick.compiler.memberinjector.MemberInjectorProcessor (NON_INCREMENTAL).</code> </pre> <br><p>  En nuestro proyecto de biblioteca con procesadores de anotaciones no incrementales, hab铆a 3: </p><br><ul><li>  Palillo de dientes </li><li>  Habitacion </li><li>  PermisosDispatcher </li></ul><br><p>  Afortunadamente, estas bibliotecas son compatibles activamente, y sus 煤ltimas versiones ya tienen soporte incremental.  Adem谩s, todos los procesadores de anotaciones en las 煤ltimas versiones de estas bibliotecas tienen una categor铆a 贸ptima: aislar.  En el proceso de subir las versiones, tuve que lidiar con la refactorizaci贸n debido a cambios en la API de la biblioteca Toothpick, que afect贸 a casi todos los m贸dulos nuestros.  Pero en este caso, tuvimos suerte, y result贸 ser una refactorizaci贸n completamente autom谩tica utilizando los nombres de reemplazo autom谩tico de los m茅todos de biblioteca p煤blica utilizados. </p><br><p>  Tenga en cuenta que si usa la biblioteca de <em>salas</em> , deber谩 pasar expl铆citamente la <em>marca room.incremental: true</em> al procesador de anotaciones.  <a href="https://developer.android.com/jetpack/androidx/releases/room">Un ejemplo</a>  En el futuro, los desarrolladores de Room <a href="https://developer.android.com/jetpack/androidx/releases/room">planean</a> habilitar esta bandera por defecto. </p><br><p>  Para las versiones de Kotlin 1.3.30-1.3.50, debe habilitar el soporte para el procesamiento incremental de anotaciones <strong>expl铆citamente a</strong> trav茅s de <em>kapt.incremental.apt = true</em> en el archivo gradle.properties del proyecto.  A partir de la versi贸n 1.3.50, esta opci贸n se establece en true de forma predeterminada. </p><br><h2 id="profayling-inkrementalnyh-sborok">  Perfiles incrementales de ensamblaje </h2><br><p>  Despu茅s de que se hayan generado las versiones de todas las dependencias necesarias, es hora de probar la velocidad de las compilaciones incrementales.  Para hacer esto, utilizamos el siguiente conjunto de herramientas y t茅cnicas: </p><br><ul><li>  <a href="https://guides.gradle.org/creating-build-scans/">Escaneo de construcci贸n Gradle</a> </li><li>  <a href="https://github.com/gradle/gradle-profiler">gradle-profiler</a> </li><li>  Para ejecutar scripts con procesamiento de anotaci贸n incremental habilitado y deshabilitado, se us贸 la propiedad <em>gradle kapt.incremental.apt = [true | false]</em> </li><li>  Para obtener resultados consistentes e informativos, las asambleas se generaron en un entorno de CI separado.  La incrementalidad de construcci贸n se reprodujo utilizando gradle-profiler </li></ul><br><p>  gradle-profiler permite preparar <a href="https://github.com/gradle/gradle-profiler">scripts</a> declarativamente para puntos de referencia de compilaci贸n incremental.  Se compilaron 4 escenarios basados en las siguientes condiciones: </p><br><ul><li>  La modificaci贸n de un archivo afecta / no afecta su ABI </li><li>  Soporte para el procesamiento de anotaci贸n incremental activado / desactivado </li></ul><br><p>  La ejecuci贸n de cada uno de los escenarios es una secuencia de: </p><br><ul><li>  Reiniciar el demonio gradle </li><li>  Lanzar compilaciones de calentamiento </li><li>  Ejecute 10 ensamblajes incrementales, antes de cada uno de los cuales se cambia un archivo agregando un nuevo m茅todo (privado para cambios no ABI y p煤blico para cambios ABI) </li></ul><br><p>  Todas las compilaciones se realizaron con Gradle 5.4.1.  El archivo involucrado en los cambios se refiere a uno de los m贸dulos principales del proyecto (com煤n), del cual dependen directamente 40 m贸dulos (incluidos el n煤cleo y la funci贸n).  Este archivo usa la anotaci贸n para aislar el procesador. </p><br><p>  Tambi茅n vale la pena se帽alar que la ejecuci贸n de referencia se realiz贸 en dos tareas <em>b谩sicas</em> : <em>ompileDebugSources</em> y <em>assembleDebug</em> .  El primero solo inicia la compilaci贸n de archivos con c贸digo fuente, sin hacer ning煤n trabajo con recursos y agrupando la aplicaci贸n en un archivo .apk.  Basado en el hecho de que la compilaci贸n incremental afecta solo a los archivos .kt y .java, se <em>eligi贸 la</em> tarea <em>compileDedugSource</em> para una evaluaci贸n comparativa m谩s aislada y m谩s r谩pida.  En condiciones de desarrollo reales, cuando reinicia la aplicaci贸n, Android Studio utiliza la tarea <em>assembleDebug</em> , que incluye la generaci贸n completa de la versi贸n de depuraci贸n de la aplicaci贸n. </p><br><h2 id="rezultaty-benchmarkov">  Resultados de referencia </h2><br><p>  En todos los gr谩ficos generados por gradle-profiler, el eje vertical muestra el tiempo de ensamblaje incremental en milisegundos, y el eje horizontal muestra el n煤mero de inicio del ensamblaje. </p><br><h3 id="compiledebugsource-do-obnovleniya-processorov-annotaciy">  : compileDebugSource antes de actualizar los procesadores de anotaciones </h3><br><p><img src="https://habrastorage.org/webt/mn/cd/jj/mncdjjla37vj8ogbycy0szzpj-e.png" alt="ingrese la descripci贸n de la imagen aqu铆"><br>  El tiempo de ejecuci贸n promedio para cada escenario fue de 38 segundos antes de actualizar los procesadores de anotaciones a versiones que admitan incrementalidad.  En este caso, Gradle desactiva el soporte para la compilaci贸n incremental, por lo que no hay una diferencia significativa entre los scripts. </p><br><h3 id="compiledebugsource-posle-obnovleniya-processorov-annotaciy">  : compileDebugSource despu茅s de actualizar los procesadores de anotaciones </h3><br><p><img src="https://habrastorage.org/webt/wk/fk/h1/wkfkh1e37r3jpagocxqbdi4twqk.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Escenario </th><th>  Cambio incremental de ABI </th><th>  Cambio de ABI no incremental </th><th>  Cambio incremental no ABI </th><th>  Cambio no incremental no abi </th></tr></thead><tbody><tr><td>  <strong>malvado</strong> </td><td>  23978 </td><td>  35370 </td><td>  23514 </td><td>  34602 </td></tr><tr><td>  <strong>mediana</strong> </td><td>  23879 </td><td>  35019 </td><td>  23424 </td><td>  34749 </td></tr><tr><td>  <strong>min</strong> </td><td>  22618 </td><td>  33969 </td><td>  22343 </td><td>  33292 </td></tr><tr><td>  <strong>max</strong> </td><td>  26820 </td><td>  38097 </td><td>  25651 </td><td>  35843 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  1193,29 </td><td>  1240.81 </td><td>  888,24 </td><td>  815,91 </td></tr></tbody></table></div><br><p>  La reducci贸n media en el tiempo de montaje debido a la incrementalidad fue del 31% para los cambios ABI y del 32,5% para los cambios no ABI.  En valor absoluto, unos 10 segundos. </p><br><h3 id="assembledebug-posle-obnovleniya-processorov-annotaciy">  : assembleDebug despu茅s de actualizar los procesadores de anotaciones </h3><br><p><img src="https://habrastorage.org/webt/fa/5h/qx/fa5hqxvowacrovlvmc12xard7_i.png"></p><br><div class="scrollable-table"><table><thead><tr><th>  Escenario </th><th>  Cambio incremental de ABI </th><th>  Cambio de ABI no incremental </th><th>  Cambio incremental no ABI </th><th>  Cambio no incremental no abi </th></tr></thead><tbody><tr><td>  <strong>malvado</strong> </td><td>  39902 </td><td>  49850 </td><td>  39005 </td><td>  52123 </td></tr><tr><td>  <strong>mediana</strong> </td><td>  38974 </td><td>  49691 </td><td>  38713 </td><td>  50336 </td></tr><tr><td>  <strong>min</strong> </td><td>  38563 </td><td>  48782 </td><td>  38233 </td><td>  48944 </td></tr><tr><td>  <strong>max</strong> </td><td>  48255 </td><td>  52364 </td><td>  41732 </td><td>  65941 </td></tr><tr><td>  <strong>stddev</strong> </td><td>  2953,28 </td><td>  1011.20 </td><td>  1015,37 </td><td>  5039.11 </td></tr></tbody></table></div><br><p>  Para compilar la versi贸n de depuraci贸n completa de la aplicaci贸n en nuestro proyecto, la disminuci贸n media en el tiempo de compilaci贸n debido al incremento fue del 21.5% para cambios ABI y del 23% para cambios no ABI.  En t茅rminos absolutos, aproximadamente los mismos 10 segundos, ya que el incremento de la compilaci贸n del c贸digo fuente no afecta la velocidad de ensamblaje de los recursos. </p><br><h2 id="anatomiya-sborki-v-gradle-build-scan">  Build Scan Anatomy en Gradle Build Scan </h2><br><p>  Para una comprensi贸n m谩s profunda de c贸mo se logr贸 el incremento durante la compilaci贸n incremental, comparamos escaneos de ensamblajes incrementales y no incrementales. </p><br><p>  En el caso de un incremento KAPT deshabilitado, la parte principal del tiempo de compilaci贸n es la compilaci贸n del m贸dulo de la aplicaci贸n, que no se puede paralelizar con otras tareas.  La l铆nea de tiempo para KAPT no incremental es la siguiente: </p><br><p><img src="https://habrastorage.org/webt/r0/cw/_n/r0cw_n4xvp7olnharknhce--9fe.png" alt="ingrese la descripci贸n de la imagen aqu铆"></p><br><p>  Ejecuci贸n de la tarea: kaptDebugKotlin de nuestro m贸dulo de aplicaci贸n tarda unos 8 segundos en este caso. </p><br><p>  L铆nea de tiempo para el caso con el incremento KAPT habilitado: </p><br><p><img src="https://habrastorage.org/webt/_u/xt/se/_uxtsee_4jt_g7oems5ggxbm3rg.png" alt="ingrese la descripci贸n de la imagen aqu铆"></p><br><p>  Ahora el m贸dulo de la aplicaci贸n se ha vuelto a compilar en menos de un segundo.  Vale la pena prestar atenci贸n a la desproporci贸n visual de las escalas de los dos escaneos en la imagen de arriba.  Las tareas que parecen m谩s cortas en la primera imagen no son necesariamente m谩s largas en la segunda, donde parecen m谩s largas.  Pero es muy notable cu谩nto ha disminuido la proporci贸n de recompilaci贸n del m贸dulo de la aplicaci贸n cuando activa KAPT incremental.  En nuestro caso, ganamos unos 8 segundos en este m贸dulo y unos 2 segundos adicionales en m贸dulos m谩s peque帽os que se compilan en paralelo. </p><br><p>  Al mismo tiempo, el tiempo total de ejecuci贸n de todas las tareas * kapt para la incrementalidad deshabilitada de las anotaciones de procesamiento es de 1 minuto y 36 segundos contra 55 segundos cuando est谩 activado.  Es decir, sin tener en cuenta el ensamblaje paralelo de los m贸dulos, la ganancia es m谩s sustancial. </p><br><p>  Tambi茅n vale la pena se帽alar que los resultados de referencia anteriores se prepararon en un entorno CI con la capacidad de ejecutar 24 subprocesos paralelos para el ensamblaje.  En un entorno de 8 subprocesos, la ganancia de habilitar el procesamiento de anotaci贸n incremental es de aproximadamente 20-30 segundos en nuestro proyecto. </p><br><h2 id="incremental-vs--parallel">  Incremental vs (?) Paralelo </h2><br><p>  Otra forma de acelerar significativamente el ensamblaje (tanto incremental como limpio) es realizar tareas de gradle en paralelo al dividir el proyecto en una gran cantidad de m贸dulos sueltos.  De una forma u otra, la modularizaci贸n representa un potencial mucho mayor para acelerar los ensamblajes que el uso de KAPT incremental.  Pero cuanto m谩s monol铆tico sea el proyecto, y cuanto m谩s generaci贸n de c贸digo se use en 茅l, mayor ser谩 el procesamiento incremental de las anotaciones.  Es m谩s f谩cil obtener el efecto de la incrementalidad completa de los ensamblajes que dividir una aplicaci贸n en m贸dulos.  Sin embargo, ambos enfoques no se contradicen y se complementan perfectamente entre s铆. </p><br><h2 id="itog">  Resumen </h2><br><ul><li>  La inclusi贸n del procesamiento incremental de anotaciones en nuestro proyecto nos permiti贸 lograr un aumento del 20% en la velocidad de la reconstrucci贸n local. </li><li>  Para habilitar el procesamiento de anotaci贸n incremental, ser谩 煤til estudiar el registro completo de los ensamblados actuales y buscar mensajes de advertencia con el texto "Procesamiento de anotaci贸n incremental solicitado, pero el soporte est谩 deshabilitado porque los siguientes procesadores no son incrementales ...".  Es necesario actualizar las versiones de las bibliotecas a versiones con soporte para el procesamiento incremental de anotaciones y tener versiones Gradle 4.7+, Kotlin 1.3.30+ </li></ul><br><h3 id="materialy-i-chto-pochitat-po-teme">  Materiales y qu茅 leer sobre el tema. </h3><br><ul><li>  <a href="https://docs.gradle.org/6.0.1/userguide/java_plugin.html">Acerca de la compatibilidad con el procesamiento de anotaciones iniciales en el nivel del complemento Gradle Java</a> </li><li>  <a href="https://medium.com/andrews-tech-blog/the-gradle-profiler-part-1-introduction-bdcbe70efe08">Art铆culo sobre gradle-profiler</a> </li><li>  <a href="https://kotlinlang.org/docs/reference/kapt.html">M谩s sobre las caracter铆sticas de KAPT</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3DsQC9-Rj2yLI">Informe sobre Google I / O 2019 con trucos de aceleraci贸n de compilaci贸n actuales</a> </li><li>  <a href="https://www.youtube.com/watch%3Fv%3D7ll-rkLCtyk">Otro informe sobre Gradle Optimization en Google I / O 2017, incluye material de construcci贸n incremental y evitaci贸n de compilaci贸n</a> </li></ul></div></div><p>Source: <a href="https://habr.com/ru/post/484918/">https://habr.com/ru/post/484918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484902/index.html">En ecuaciones de grados superiores</a></li>
<li><a href="../484904/index.html">Un a帽o sin Splunk: c贸mo una empresa estadounidense cambi贸 el mercado de an谩lisis de datos de m谩quinas en Rusia y a qui茅n dej贸 atr谩s</a></li>
<li><a href="../484906/index.html">Equipo distribuido y l铆der de equipo en remoto</a></li>
<li><a href="../484908/index.html">HighLoad ++, Eugene Kuzovlev (EcommPay IT): qu茅 hacer cuando un minuto de tiempo de inactividad cuesta $ 100,000</a></li>
<li><a href="../484910/index.html">Paul Graham: enemigos</a></li>
<li><a href="../484920/index.html">驴C贸mo entender que usted es un operador de fresadoras?</a></li>
<li><a href="../484930/index.html">Codifiquemos r谩pidamente como profesionales</a></li>
<li><a href="../484932/index.html">La naturaleza dual de los requisitos de software.</a></li>
<li><a href="../484934/index.html">Desde el desarrollo personal hasta Agile en una escala XXXL en dos d铆as en TeamLead Conf</a></li>
<li><a href="../484936/index.html">Conocimientos y competencias en el equipo: encontrar, ver, bombear</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>