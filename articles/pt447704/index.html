<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äç‚öïÔ∏è üë®üèΩ‚Äçüé® üï¢ Escalada Elbrus - Reconhecimento em batalha. Parte t√©cnica 1. Registros, pilhas e outros detalhes t√©cnicos üé≠ üññüèø üë®üèæ‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Conforme prometido , continuamos a falar sobre o desenvolvimento dos processadores Elbrus . Este artigo √© t√©cnico. As informa√ß√µes fornecidas no artigo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escalada Elbrus - Reconhecimento em batalha. Parte t√©cnica 1. Registros, pilhas e outros detalhes t√©cnicos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/447704/"><img src="https://habrastorage.org/webt/ic/4z/5o/ic4z5olelesc04boln85goculk4.png" align="right" width="320">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conforme prometido</a> , continuamos a falar sobre o desenvolvimento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dos processadores Elbrus</a> .  Este artigo √© t√©cnico.  As informa√ß√µes fornecidas no artigo n√£o s√£o documenta√ß√£o oficial, porque foram obtidas durante o estudo de Elbrus como uma caixa preta.  Mas certamente ser√° interessante para uma melhor compreens√£o da arquitetura Elbrus, porque, embora tiv√©ssemos documenta√ß√£o oficial, muitos detalhes ficaram claros somente ap√≥s longas experi√™ncias, quando a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Embox</a> funcionou. <br><br>  Lembre-se de que no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> falamos sobre a inicializa√ß√£o b√°sica do sistema e o driver da porta serial.  A Embox come√ßou, mas para mais avan√ßos precis√°vamos de interrup√ß√µes, um cron√¥metro do sistema e, √© claro, eu gostaria de incluir algum conjunto de testes de unidade, e para isso precisamos do setjmp.  Este artigo se concentrar√° em registros, pilhas e outros detalhes t√©cnicos necess√°rios para implementar todas essas coisas. <br><a name="habracut"></a><br>  Vamos come√ßar com uma breve introdu√ß√£o √† arquitetura, que √© a informa√ß√£o m√≠nima necess√°ria para entender o que ser√° discutido mais adiante.  No futuro, vamos nos referir √†s informa√ß√µes desta se√ß√£o. <br><br><h3>  Breve introdu√ß√£o: pilhas </h3><br>  Existem tr√™s pilhas em Elbrus: <br><br><ul><li> Pilha de procedimentos (PS) </li><li>  Pilha de cadeia de procedimentos (PCS) </li><li>  Pilha de usu√°rios (EUA) </li></ul><br>  Vamos analis√°-los com mais detalhes.  Os endere√ßos na figura s√£o condicionais, mostram em que dire√ß√£o os movimentos s√£o direcionados - de um endere√ßo maior para um menor ou vice-versa. <br><br><img src="https://habrastorage.org/webt/le/bc/ac/lebcace6fqkdk5vvhwke6kajyuu.png"><br><br>  A pilha de procedimentos (PS) destina-se a dados alocados a registros "operacionais". <br><br>  Por exemplo, podem ser argumentos de fun√ß√£o; em arquiteturas "comuns", esse conceito √© o mais pr√≥ximo dos registros de uso geral.  Diferentemente das arquiteturas de processador "regulares", no E2K, os registros usados ‚Äã‚Äãnas fun√ß√µes s√£o empilhados em uma pilha separada. <br><br>  A pilha de informa√ß√µes de encaderna√ß√£o (PCS) foi projetada para colocar informa√ß√µes sobre o procedimento anterior (de chamada) e usada ao retornar.  Os dados no endere√ßo de retorno, assim como no caso dos registros, s√£o colocados em um local separado.  Portanto, a promo√ß√£o de pilha (por exemplo, para sair por exce√ß√£o em C ++) √© um processo mais demorado do que nas arquiteturas "comuns".  Por outro lado, isso elimina problemas de estouro de pilha. <br><br>  Ambas as pilhas (PS e PCS) s√£o caracterizadas por um endere√ßo base, tamanho e deslocamento de corrente.  Esses par√¢metros s√£o definidos nos registros PSP e PCSP, s√£o de 128 bits e no assembler voc√™ precisa se referir a campos espec√≠ficos (por exemplo, alto ou baixo).  Al√©m disso, o funcionamento das pilhas est√° intimamente relacionado ao conceito de um arquivo de registro, mais sobre isso abaixo.  A intera√ß√£o com o arquivo ocorre atrav√©s do mecanismo de registros de bombeamento / troca.  Um papel ativo nesse mecanismo √© desempenhado pelo chamado "ponteiro de hardware para o topo da pilha" das informa√ß√µes processuais ou da pilha de informa√ß√µes de liga√ß√£o, respectivamente.  Sobre isso tamb√©m abaixo.  √â importante que, a cada momento, os dados dessas pilhas estejam na RAM ou em um arquivo de registro. <br><br>  Tamb√©m √© importante notar que essas pilhas (a pilha processual e a pilha de informa√ß√µes vinculativas) crescem.  Nos deparamos com isso quando implementamos context_switch. <br><br>  A pilha do usu√°rio tamb√©m recebe o endere√ßo e o tamanho base.  O ponteiro atual est√° no registro USD.lo.  Na sua ess√™ncia, √© uma pilha cl√°ssica que cresce.  Somente, diferentemente das arquiteturas "comuns", as informa√ß√µes de outras pilhas (registros e endere√ßos de retorno) n√£o se encaixam l√°. <br><br>  Um requisito n√£o padr√£o, na minha opini√£o, para os limites e tamanhos das pilhas √© o alinhamento de 4Kb, e o endere√ßo base da pilha e seu tamanho devem estar alinhados com 4Kb.  Em outras arquiteturas, n√£o atendi a essa restri√ß√£o.  Encontramos esse detalhe novamente quando implementamos context_switch. <br><br><h3>  Breve introdu√ß√£o: Registros.  Registre arquivos.  Janelas de registro </h3><br>  Agora que descobrimos um pouco as pilhas, precisamos entender como as informa√ß√µes s√£o apresentadas nelas.  Para fazer isso, precisamos introduzir mais alguns conceitos. <br><br>  Um arquivo de registro (RF) √© um conjunto de todos os registros.  Existem dois arquivos de registro que precisamos: um arquivo de informa√ß√µes de conex√£o (arquivo de cadeia - CF), o outro √© chamado de arquivo de registro (RF); ele armazena registros ‚Äúoperacionais‚Äù, que s√£o armazenados na pilha de procedimentos. <br><br>  A janela Registro √© a √°rea (conjunto de registros) do arquivo de registro atualmente dispon√≠vel. <br><br>  Vou explicar com mais detalhes.  O que √© um conjunto de registros, eu acho, ningu√©m precisa explicar. <br><br>  √â sabido que um dos gargalos da arquitetura x86 √© precisamente um pequeno n√∫mero de registros.  Nas arquiteturas RISC com registros, √© mais simples, geralmente em torno de 16 registros, dos quais v√°rios (2-3) s√£o ocupados por necessidades oficiais.  Por que n√£o fazer apenas 128 registros, porque parece que isso aumentar√° o desempenho do sistema?  A resposta √© bastante simples: uma instru√ß√£o de processador precisa de um local para armazenar o endere√ßo de registro e, se houver muitas delas, tamb√©m ser√£o necess√°rios muitos bits para isso.  Portanto, eles fazem todo tipo de truque, fazem registros de sombra, registram bancos, janelas e assim por diante.  Por registradores-sombra, quero dizer o princ√≠pio da organiza√ß√£o de registros no ARM.  Se ocorrer uma interrup√ß√£o ou outra situa√ß√£o, um conjunto diferente de registros com os mesmos nomes (n√∫meros) estar√° dispon√≠vel, enquanto as informa√ß√µes armazenadas no conjunto original permanecem l√°.  Os bancos de registradores, de fato, s√£o muito semelhantes aos registradores-sombra, simplesmente n√£o h√° troca de hardware dos conjuntos de registradores, e o programador escolhe qual banco (conjunto de registradores) deve entrar em contato agora. <br><br>  As janelas de registro foram projetadas para otimizar o trabalho com a pilha.  Como voc√™ provavelmente entende, em uma arquitetura ‚Äúnormal‚Äù, voc√™ insere um procedimento, salva os registros na pilha (ou o procedimento de chamada salva, depende do contrato) e pode usar os registros, porque as informa√ß√µes j√° est√£o armazenadas na pilha.  Mas o acesso √† mem√≥ria √© lento e, portanto, deve ser evitado.  Ao entrar no procedimento, vamos disponibilizar um novo conjunto de registros, os dados do antigo ser√£o salvos, o que significa que voc√™ n√£o precisa despej√°-los na mem√≥ria.  Al√©m disso, quando voc√™ retornar ao procedimento de chamada, a janela de registro anterior tamb√©m retornar√°, portanto, todos os dados nos registros ser√£o relevantes.  Este √© o conceito de uma janela de registro. <br><br><img src="https://habrastorage.org/webt/lg/5e/6u/lg5e6u_pfus75yedi6hefckkqkk.png"><br><br>  √â claro que voc√™ ainda precisa salvar os registros na pilha (na mem√≥ria), mas isso pode ser feito quando as janelas de registro gratuito terminarem. <br><br>  E o que fazer com os registros de entrada e sa√≠da (argumentos ao inserir a fun√ß√£o e o resultado retornado)?  Deixe a janela conter parte dos registros vis√≠veis na janela anterior, mais precisamente, parte dos registros estar√° dispon√≠vel para ambas as janelas.  Ent√£o, em geral, ao chamar uma fun√ß√£o, voc√™ n√£o precisa acessar a mem√≥ria.  Suponha que nossos registros sejam assim <br><br><img src="https://habrastorage.org/webt/n9/ki/zw/n9kizwn2qkag4rew2jspyassaco.png"><br><br>  Ou seja, r0 na primeira janela ser√° o mesmo registro que r2 em zero e r1 da primeira janela no mesmo registro que r3.  Ou seja, escrevendo em r2 antes de chamar o procedimento (alterando o n√∫mero da janela) obtemos o valor em r0 no procedimento chamado.  Este princ√≠pio √© chamado de mecanismo de rota√ß√£o das janelas. <br><br>  Vamos otimizar um pouco mais, porque os criadores da Elbrus fizeram exatamente isso.  Deixe que as janelas que temos n√£o sejam de tamanho fixo, mas vari√°veis, o tamanho da janela pode ser definido no momento da entrada no procedimento.  Faremos o mesmo com o n√∫mero de registros rotacionados.  √â claro que isso nos levar√° a alguns problemas, porque, nas janelas rotativas cl√°ssicas, existe um √≠ndice de janelas atrav√©s do qual √© determinado que voc√™ precisa salvar os dados do arquivo de registro na pilha ou carreg√°-los.  Mas se voc√™ n√£o inserir o √≠ndice da janela, mas o √≠ndice do registro a partir do qual nossa janela atual √© iniciada, esse problema n√£o surgir√°.  No Elbrus, esses √≠ndices est√£o contidos nos registros PSHTP (para a pilha de procedimentos PS) e PCSHTP (para a pilha de informa√ß√µes processuais do PCS).  A documenta√ß√£o refere-se a "ponteiros de hardware para o topo da pilha".  Agora voc√™ pode tentar novamente ler sobre as pilhas, acho que ficar√° mais claro. <br><br>  Como voc√™ entende, esse mecanismo implica que voc√™ tem a capacidade de controlar o que est√° na mem√≥ria.  Ou seja, sincronize o arquivo de registro e a pilha.  Quero dizer um programador de sistemas.  Se voc√™ √© um programador de aplicativos, o equipamento fornecer√° entrada e sa√≠da transparentes do procedimento.  Ou seja, se n√£o houver registros suficientes ao tentar selecionar uma nova janela, a janela de registro ser√° "bombeada" automaticamente.  Nesse caso, todos os dados do arquivo de registro ser√£o salvos na pilha apropriada (na mem√≥ria) e o "ponteiro para o topo da pilha" (√≠ndice de deslocamento) ser√° zerado.  Da mesma forma, a troca de um arquivo de registro da pilha ocorre automaticamente.  Mas se voc√™ estiver desenvolvendo, por exemplo, a altern√¢ncia de contexto, que √© exatamente o que fizemos, precisar√° de um mecanismo para trabalhar com a parte oculta do arquivo de registro.  No Elbrus, os comandos FLUSHR e FLUSHC s√£o usados ‚Äã‚Äãpara isso.  FLUSHR - limpando o arquivo de registro, todas as janelas, exceto a atual, s√£o liberadas para a pilha de procedimentos, o √≠ndice PSHTP √© redefinido para zero.  FLUSHC - limpa o arquivo de informa√ß√µes de liga√ß√£o, tudo, exceto a janela atual, √© despejado na pilha de informa√ß√µes de liga√ß√£o, o √≠ndice PCSHTP tamb√©m √© redefinido para zero. <br><br><h3>  Breve introdu√ß√£o: Implementa√ß√£o em Elbrus </h3><br>  Agora que discutimos o trabalho n√£o √≥bvio com registros e pilhas, falaremos mais especificamente sobre v√°rias situa√ß√µes no Elbrus. <br><br>  Quando entramos na pr√≥xima fun√ß√£o, o processador cria duas janelas: uma janela na pilha PS e uma janela na pilha PCS. <br><br>  Uma janela na pilha PCS cont√©m as informa√ß√µes necess√°rias para retornar de uma fun√ß√£o: por exemplo, IP (Ponteiro de Instru√ß√£o) da instru√ß√£o na qual voc√™ precisar√° retornar da fun√ß√£o.  Com isso, tudo fica mais ou menos claro. <br><br>  A janela na pilha PS √© um pouco mais complicada.  O conceito de registros da janela atual √© introduzido.  Nesta janela, voc√™ tem acesso aos registros da janela atual -% dr0,% dr1, ...,% dr15, ... Ou seja, para n√≥s, como usu√°rio, eles sempre s√£o numerados de 0, mas isso √© numerado em rela√ß√£o ao endere√ßo base da janela atual.  Por meio desses registradores, os argumentos s√£o passados ‚Äã‚Äãquando a fun√ß√£o √© chamada e o valor √© retornado, e a fun√ß√£o √© usada como registrador de uso geral dentro da fun√ß√£o.  Na verdade, isso foi explicado ao considerar o mecanismo de rota√ß√£o das janelas de registro. <br><br>  O tamanho da janela de registro no Elbrus pode ser controlado.  Isso, como eu disse, √© necess√°rio para otimiza√ß√£o.  Por exemplo, em uma fun√ß√£o, precisamos de apenas 4 registros para passar argumentos e alguns c√°lculos; nesse caso, o programador (ou compilador) decide quantos registros ser√£o alocados para a fun√ß√£o e, com base nisso, define o tamanho da janela.  O tamanho da janela √© definido pela opera√ß√£o setwd: <br><br><pre><code class="cpp hljs">setwd wsz=<span class="hljs-number"><span class="hljs-number">0x10</span></span></code> </pre> <br>  Especifica o tamanho da janela em termos de registradores qu√°druplos (registradores de 128 bits). <br><br><img src="https://habrastorage.org/webt/tf/ov/px/tfovpxrj1wkos3e29zsl0fj_8p8.png"><br><br>  Agora, digamos que voc√™ queira chamar uma fun√ß√£o a partir de uma fun√ß√£o.  Para isso, o conceito j√° descrito de uma janela de registro girado √© aplicado.  A figura acima mostra um fragmento de um arquivo de registro em que uma fun√ß√£o com a janela 1 (verde) chama uma fun√ß√£o com a janela 2 (laranja).  Em cada uma dessas duas fun√ß√µes, voc√™ ter√° acesso aos seus% dr0,% dr1, ... Mas os argumentos ser√£o passados ‚Äã‚Äãpelos chamados registros rotativos.  Em outras palavras, parte dos registros da janela 1 se tornar√£o os registros da janela 2 (observe que essas duas janelas se cruzam).  Esses registros tamb√©m s√£o definidos pela janela (veja os registros do Rotary na figura) e t√™m o endere√ßo% db [0],% db [1], ... Portanto, o registro% dr0 na janela 2 nada mais √© do que o registro% db [0] em janela 1. <br><br>  A janela de registro de rota√ß√£o √© definida pela opera√ß√£o setbn: <br><br><pre> <code class="cpp hljs"> setbn rbs = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rsz = <span class="hljs-number"><span class="hljs-number">0x8</span></span></code> </pre> <br>  rbs define o tamanho da janela girada e rsz define o endere√ßo base, mas em rela√ß√£o √† janela de registro atual.  I.e.  Aqui, alocamos tr√™s registros, come√ßando no dia 8. <br><br>  Com base no exposto, mostramos como √© a chamada de fun√ß√£o.  Para simplificar, supomos que a fun√ß√£o use um argumento: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Ent√£o, para chamar essa fun√ß√£o, voc√™ precisa preparar uma janela de registros rotativos (j√° fizemos isso via setbn).  Em seguida, no registro% db0, colocamos o valor que ser√° passado para my_func.  Depois disso, voc√™ precisa chamar a instru√ß√£o CALL e n√£o se esque√ßa de dizer a ela onde a janela dos registros girados come√ßa.  Ignoramos a prepara√ß√£o para a chamada (o comando disp) agora, porque n√£o diferencia mai√∫sculas de min√∫sculas.  Como resultado, no assembler, uma chamada para esta fun√ß√£o deve ser assim: <br><br><pre> <code class="cpp hljs"> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, my_func call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x8</span></span></code> </pre> <br>  Ent√£o, com registros um pouco descobri.  Agora vamos ver a pilha de informa√ß√µes vinculativas.  Ele armazena os chamados registros CR.  De fato, dois - CR0, CR1.  E eles j√° cont√™m as informa√ß√µes necess√°rias para retornar da fun√ß√£o. <br><br><img src="https://habrastorage.org/webt/rc/8q/kl/rc8qklg-pb3tgwv3jjz_8pc6l3g.png"><br><br>  Os registradores CR0 e CR1 da janela da fun√ß√£o que chamou a fun√ß√£o com os registradores marcados em laranja s√£o verdes.  Os registradores CR0 cont√™m o ponteiro de instru√ß√µes da fun√ß√£o de chamada e um determinado arquivo predicado (PF-Predicate File), uma hist√≥ria sobre isso definitivamente est√° al√©m do escopo deste artigo. <br><br>  Os registros CR1 cont√™m dados como PSR (status do processador de texto), n√∫mero da janela, tamanho da janela e assim por diante.  No Elbrus, tudo √© t√£o flex√≠vel que todo procedimento armazena informa√ß√µes no CR1, inclusive sobre se a opera√ß√£o de ponto flutuante est√° inclu√≠da no procedimento e um registro contendo informa√ß√µes sobre exce√ß√µes de software, mas √© claro que voc√™ precisa pagar para salvar informa√ß√µes adicionais. <br><br>  √â muito importante n√£o esquecer que o arquivo de registro e o arquivo de informa√ß√µes de liga√ß√£o podem ser extra√≠dos e trocados da mem√≥ria principal e vice-versa (das pilhas PS e PCS descritas acima).  Este ponto √© importante ao implementar o setjmp descrito posteriormente. <br><br><h3>  SETJMP / LONGJMP </h3><br>  E, finalmente, pelo menos de alguma maneira, entendendo como as pilhas e os registros s√£o organizados no Elbrus, voc√™ pode come√ßar a fazer algo √∫til, ou seja, adicionar novas funcionalidades ao Embox. <br><br>  Na Embox, o sistema de teste de unidade requer setjmp / longjmp, portanto tivemos que implementar essas fun√ß√µes. <br><br>  Para a implementa√ß√£o, √© necess√°rio salvar / restaurar os registros: CR0, CR1, PSP, PCSP, USD, - j√° familiares para n√≥s a partir de uma breve introdu√ß√£o.  De fato, salvar / restaurar √© implementado em nossa testa, mas h√° uma nuance significativa que muitas vezes foi sugerida na descri√ß√£o de pilhas e registros, a saber: pilhas devem ser sincronizadas, porque est√£o localizadas n√£o apenas na mem√≥ria, mas tamb√©m no arquivo de registro.  Essa nuance significa que voc√™ precisa cuidar de v√°rios recursos, sem os quais nada funcionar√°. <br><br>  O primeiro recurso √© desativar as interrup√ß√µes durante o salvamento e a restaura√ß√£o.  Ao restaurar uma interrup√ß√£o, √© obrigat√≥rio proibir, caso contr√°rio, pode surgir uma situa√ß√£o em que entramos no manipulador de interrup√ß√µes com pilhas com meia comuta√ß√£o (referindo-se ao bombeamento da troca de arquivos de registro descrita na ‚Äúdescri√ß√£o resumida‚Äù).  E ao salvar, o problema √© que, ap√≥s entrar e sair da interrup√ß√£o, o processador pode novamente trocar parte do arquivo de registro da RAM (e isso arruinar√° as condi√ß√µes invariantes PSHTP = 0 e PSCHTP = 0, um pouco mais sobre elas).  √â por isso que, tanto no setjmp quanto no longjmp, as interrup√ß√µes devem ser desativadas.  Tamb√©m deve ser observado aqui que especialistas do MCST nos aconselharam a usar colchetes at√¥micos em vez de desativar interrup√ß√µes, mas, por enquanto, usamos a implementa√ß√£o mais simples (compreens√≠vel para n√≥s). <br><br>  O segundo recurso est√° relacionado ao bombeamento / extra√ß√£o de um arquivo de registro da mem√≥ria.  √â o seguinte.  O arquivo de registro tem um tamanho limitado e, portanto, √© frequentemente bombeado para a mem√≥ria e vice-versa.  Portanto, se simplesmente salvarmos os valores dos registros PSP e PSHTP, fixaremos o valor do ponteiro atual na mem√≥ria e no arquivo de registro.  Por√©m, como o arquivo de registro est√° mudando, no momento da restaura√ß√£o do contexto, ele indica dados j√° incorretos (n√£o aqueles que ‚Äúsalvamos‚Äù).  Para evitar isso, voc√™ precisa liberar todo o arquivo de registro na mem√≥ria.  Assim, ao salvar em setjmp, temos os registros PSP.ind na mem√≥ria e registros PSHTP.ind na janela de registro.  Acontece que voc√™ precisa salvar todos os registros PCSP.ind + PCSHTP.ind.  A seguir est√° a fun√ß√£o que executa esta opera√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* First arg is PCSP, 2nd arg is PCSHTP * Returns new PCSP value with updated PCSP.ind */</span></span> .type update_pcsp_ind,@function $update_pcsp_ind: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Here and below, 10 is size of PCSHTP.ind. Here we * extend the sign of PCSHTP.ind */</span></span> shld %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span>), %dr1 shrd %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span>), %dr1 <span class="hljs-comment"><span class="hljs-comment">/* Finally, PCSP.ind += PCSHTP.ind */</span></span> addd %dr1, %dr0, %dr0 E2K_ASM_RETURN</code> </pre> <br>  Tamb√©m √© necess√°rio esclarecer um pequeno ponto neste c√≥digo descrito no coment√°rio, ou seja, √© necess√°rio expandir programaticamente o caractere no √≠ndice PCSHTP.ind, porque o √≠ndice pode ser negativo e armazenado em c√≥digo adicional.  Para fazer isso, primeiro mudamos para (64-10) para a esquerda (registro de 64 bits), para um campo de 10 bits e depois voltamos. <br><br>  O mesmo vale para o PSP (pilha de procedimentos) <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* First arg is PSP, 2nd arg is PSHTP * Returns new PSP value with updated PSP.ind */</span></span> .type update_psp_ind,@function $update_psp_ind: setwd wsz = <span class="hljs-number"><span class="hljs-number">0x4</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Here and below, 12 is size of PSHTP.ind. Here we * extend the sign of PSHTP.ind as stated in documentation */</span></span> shld %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">12</span></span>), %dr1 shrd %dr1, (<span class="hljs-number"><span class="hljs-number">64</span></span> - <span class="hljs-number"><span class="hljs-number">12</span></span>), %dr1 muld %dr1, <span class="hljs-number"><span class="hljs-number">2</span></span>, %dr1 <span class="hljs-comment"><span class="hljs-comment">/* Finally, PSP.ind += PSHTP.ind */</span></span> addd %dr1, %dr0, %dr0 E2K_ASM_RETURN</code> </pre> <br>  Com uma pequena diferen√ßa (o campo √© de 12 bits e os registradores s√£o contados em termos de 128 bits, ou seja, o valor deve ser multiplicado por 2). <br><br>  C√≥digo Setjmp em si <br><br><pre> <code class="cpp hljs">C_ENTRY(setjmp): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x14</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* It's for db[N] registers */</span></span> setbn rsz = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, rcur = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* We must disable interrupts here */</span></span> disp %ctpr1, ipl_save ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Store current IPL to dr9 */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr9 <span class="hljs-comment"><span class="hljs-comment">/* Store some registers to jmp_buf */</span></span> rrd %cr0.hi, %dr1 rrd %cr1.lo, %dr2 rrd %cr1.hi, %dr3 rrd %usd.lo, %dr4 rrd %usd.hi, %dr5 <span class="hljs-comment"><span class="hljs-comment">/* Prepare RF stack to flush in longjmp */</span></span> rrd %psp.hi, %dr6 rrd %pshtp, %dr7 addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr6, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr7, %db[<span class="hljs-number"><span class="hljs-number">1</span></span>] disp %ctpr1, update_psp_ind ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr6 <span class="hljs-comment"><span class="hljs-comment">/* Prepare CF stack to flush in longjmp */</span></span> rrd %pcsp.hi, %dr7 rrd %pcshtp, %dr8 addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr7, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr8, %db[<span class="hljs-number"><span class="hljs-number">1</span></span>] disp %ctpr1, update_pcsp_ind ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr7 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr1, [%dr0 + E2K_JMBBUFF_CR0_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_JMBBUFF_CR1_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_JMBBUFF_CR1_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_JMBBUFF_USD_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_JMBBUFF_USD_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr6, [%dr0 + E2K_JMBBUFF_PSP_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr7, [%dr0 + E2K_JMBBUFF_PCSP_HI] <span class="hljs-comment"><span class="hljs-comment">/* Enable interrupts */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, ipl_restore ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* return 0 */</span></span> adds <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, %r0 E2K_ASM_RETURN</code> </pre> <br>  Ao implementar o longjmp, √© importante n√£o esquecer a sincroniza√ß√£o dos dois arquivos de registro; portanto, √© necess√°rio liberar n√£o apenas a janela de registro (flushr), mas tamb√©m o arquivo do fich√°rio (flushc).  Vamos descrever a macro: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_ASM_FLUSH_CPU \ flushr; \ nop 2; \ flushc; \ nop 3;</span></span></code> </pre> <br>  Agora que todas as informa√ß√µes est√£o na mem√≥ria, podemos registrar com seguran√ßa a recupera√ß√£o no longjmp. <br><br><pre> <code class="cpp hljs">C_ENTRY(longjmp): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x14</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> setbn rsz = <span class="hljs-number"><span class="hljs-number">0x3</span></span>, rbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, rcur = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* We must disable interrupts here */</span></span> disp %ctpr1, ipl_save ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Store current IPL to dr9 */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>], %dr9 <span class="hljs-comment"><span class="hljs-comment">/* We have to flush both RF and CF to memory because saved values * of P[C]SHTP can be not valid here. */</span></span> E2K_ASM_FLUSH_CPU <span class="hljs-comment"><span class="hljs-comment">/* Load registers previously saved in setjmp. */</span></span> ldd [%dr0 + E2K_JMBBUFF_CR0_HI], %dr2 ldd [%dr0 + E2K_JMBBUFF_CR1_LO], %dr3 ldd [%dr0 + E2K_JMBBUFF_CR1_HI], %dr4 ldd [%dr0 + E2K_JMBBUFF_USD_LO], %dr5 ldd [%dr0 + E2K_JMBBUFF_USD_HI], %dr6 ldd [%dr0 + E2K_JMBBUFF_PSP_HI], %dr7 ldd [%dr0 + E2K_JMBBUFF_PCSP_HI], %dr8 rwd %dr2, %cr0.hi rwd %dr3, %cr1.lo rwd %dr4, %cr1.hi rwd %dr5, %usd.lo rwd %dr6, %usd.hi rwd %dr7, %psp.hi rwd %dr8, %pcsp.hi <span class="hljs-comment"><span class="hljs-comment">/* Enable interrupts */</span></span> addd <span class="hljs-number"><span class="hljs-number">0</span></span>, %dr9, %db[<span class="hljs-number"><span class="hljs-number">0</span></span>] disp %ctpr1, ipl_restore ipd <span class="hljs-number"><span class="hljs-number">3</span></span> call %ctpr1, wbs = <span class="hljs-number"><span class="hljs-number">0x10</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Actually, we return to setjmp caller with second * argument of longjmp stored on r1 register. */</span></span> adds <span class="hljs-number"><span class="hljs-number">0</span></span>, %r1, %r0 E2K_ASM_RETURN</code> </pre> <br><h3>  Mudan√ßa de contexto </h3><br>  Depois que descobrimos o setjmp / longjmp, a implementa√ß√£o b√°sica do context_switch parecia clara o suficiente para n√≥s.  De fato, como no primeiro caso, precisamos salvar / restaurar os registros de informa√ß√µes e pilhas de conex√£o, al√©m de restaurar corretamente o registro de status do processador (UPSR). <br><br>  Eu vou explicar  Como no caso de setjmp, ao salvar registros, voc√™ deve primeiro redefinir o arquivo de registro e o arquivo de informa√ß√µes de liga√ß√£o para a mem√≥ria (flushr + flushc).  Depois disso, precisamos salvar os valores atuais dos registradores CR0 e CR1 para que, quando retornarmos, pule exatamente para onde o fluxo atual foi alternado.  Em seguida, salvamos os descritores das pilhas PS, PCS e US.  E, finalmente, voc√™ precisa cuidar da restaura√ß√£o correta do modo de interrup√ß√£o - para esses fins, tamb√©m salvamos o registro UPSR. <br><br>  C√≥digo do assembler context_switch: <br><br><pre> <code class="cpp hljs">C_ENTRY(context_switch): setwd wsz = <span class="hljs-number"><span class="hljs-number">0x10</span></span>, nfx = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Save prev UPSR */</span></span> rrd %upsr, %dr2 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_CTX_UPSR] <span class="hljs-comment"><span class="hljs-comment">/* Disable interrupts before saving/restoring context */</span></span> rrd %upsr, %dr2 andnd %dr2, (UPSR_IE | UPSR_NMIE), %dr2 rwd %dr2, %upsr E2K_ASM_FLUSH_CPU <span class="hljs-comment"><span class="hljs-comment">/* Save prev CRs */</span></span> rrd %cr0.lo, %dr2 rrd %cr0.hi, %dr3 rrd %cr1.lo, %dr4 rrd %cr1.hi, %dr5 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr2, [%dr0 + E2K_CTX_CR0_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_CTX_CR0_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_CTX_CR1_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_CTX_CR1_HI] <span class="hljs-comment"><span class="hljs-comment">/* Save prev stacks */</span></span> rrd %usd.lo, %dr3 rrd %usd.hi, %dr4 rrd %psp.lo, %dr5 rrd %psp.hi, %dr6 rrd %pcsp.lo, %dr7 rrd %pcsp.hi, %dr8 <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr3, [%dr0 + E2K_CTX_USD_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr4, [%dr0 + E2K_CTX_USD_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr5, [%dr0 + E2K_CTX_PSP_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr6, [%dr0 + E2K_CTX_PSP_HI] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr7, [%dr0 + E2K_CTX_PCSP_LO] <span class="hljs-built_in"><span class="hljs-built_in">std</span></span> %dr8, [%dr0 + E2K_CTX_PCSP_HI] <span class="hljs-comment"><span class="hljs-comment">/* Load next CRs */</span></span> ldd [%dr1 + E2K_CTX_CR0_LO], %dr2 ldd [%dr1 + E2K_CTX_CR0_HI], %dr3 ldd [%dr1 + E2K_CTX_CR1_LO], %dr4 ldd [%dr1 + E2K_CTX_CR1_HI], %dr5 rwd %dr2, %cr0.lo rwd %dr3, %cr0.hi rwd %dr4, %cr1.lo rwd %dr5, %cr1.hi <span class="hljs-comment"><span class="hljs-comment">/* Load next stacks */</span></span> ldd [%dr1 + E2K_CTX_USD_LO], %dr3 ldd [%dr1 + E2K_CTX_USD_HI], %dr4 ldd [%dr1 + E2K_CTX_PSP_LO], %dr5 ldd [%dr1 + E2K_CTX_PSP_HI], %dr6 ldd [%dr1 + E2K_CTX_PCSP_LO], %dr7 ldd [%dr1 + E2K_CTX_PCSP_HI], %dr8 rwd %dr3, %usd.lo rwd %dr4, %usd.hi rwd %dr5, %psp.lo rwd %dr6, %psp.hi rwd %dr7, %pcsp.lo rwd %dr8, %pcsp.hi <span class="hljs-comment"><span class="hljs-comment">/* Restore next UPSR */</span></span> ldd [%dr1 + E2K_CTX_UPSR], %dr2 rwd %dr2, %upsr E2K_ASM_RETURN</code> </pre> <br>  Outro ponto importante √© a inicializa√ß√£o do encadeamento do SO.  Na Embox, cada thread possui um determinado procedimento prim√°rio <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _<span class="hljs-function"><span class="hljs-function">NORETURN </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread_trampoline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br>  em que todo o trabalho adicional do fluxo ser√° executado.  Portanto, precisamos de alguma forma preparar as pilhas para chamar essa fun√ß√£o, √© aqui que nos deparamos com o fato de que existem tr√™s pilhas e elas n√£o crescem na mesma dire√ß√£o.  Por arquitetura, criamos um fluxo com uma √∫nica pilha, ou melhor, ele tem um √∫nico lugar abaixo da pilha, no topo temos uma estrutura que descreve o pr√≥prio fluxo e assim por diante, aqui tivemos que cuidar de pilhas diferentes, para n√£o esquecer que elas deveriam estar alinhadas 4 kB, n√£o esque√ßa todos os tipos de direitos de acesso e assim por diante. <br><br>  Como resultado, no momento decidimos dividir o espa√ßo sob a pilha em tr√™s partes, um quarto sob a pilha de informa√ß√µes de liga√ß√£o, um quarto sob a pilha processual e metade sob a pilha do usu√°rio. <br><br><div class="spoiler">  <b class="spoiler_title">Trago o c√≥digo para que voc√™ possa avaliar o tamanho, √© necess√°rio considerar que isso √© uma inicializa√ß√£o m√≠nima.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* This value is used for both stack base and size align. */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> E2K_STACK_ALIGN (1UL </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 12) #define round_down(x, bound) ((x) &amp; ~((bound) - 1)) /* Reserve 1/4 for PSP stack, 1/4 for PCSP stack, and 1/2 for USD stack */ #define PSP_CALC_STACK_BASE(sp, size) binalign_bound(sp - size, E2K_STACK_ALIGN) #define PSP_CALC_STACK_SIZE(sp, size) binalign_bound((size) / 4, E2K_STACK_ALIGN) #define PCSP_CALC_STACK_BASE(sp, size) \ (PSP_CALC_STACK_BASE(sp, size) + PSP_CALC_STACK_SIZE(sp, size)) #define PCSP_CALC_STACK_SIZE(sp, size) binalign_bound((size) / 4, E2K_STACK_ALIGN) #define USD_CALC_STACK_BASE(sp, size) round_down(sp, E2K_STACK_ALIGN) #define USD_CALC_STACK_SIZE(sp, size) \ round_down(USD_CALC_STACK_BASE(sp, size) - PCSP_CALC_STACK_BASE(sp, size),\ E2K_STACK_ALIGN) static void e2k_calculate_stacks(struct context *ctx, uint64_t sp, uint64_t size) { uint64_t psp_size, pcsp_size, usd_size; log_debug("Stacks:\n"); ctx-&gt;psp_lo |= PSP_CALC_STACK_BASE(sp, size) &lt;&lt; PSP_BASE; ctx-&gt;psp_lo |= E2_RWAR_RW_ENABLE &lt;&lt; PSP_RW; psp_size = PSP_CALC_STACK_SIZE(sp, size); assert(psp_size); ctx-&gt;psp_hi |= psp_size &lt;&lt; PSP_SIZE; log_debug(" PSP.base=0x%lx, PSP.size=0x%lx\n", PSP_CALC_STACK_BASE(sp, size), psp_size); ctx-&gt;pcsp_lo |= PCSP_CALC_STACK_BASE(sp, size) &lt;&lt; PCSP_BASE; ctx-&gt;pcsp_lo |= E2_RWAR_RW_ENABLE &lt;&lt; PCSP_RW; pcsp_size = PCSP_CALC_STACK_SIZE(sp, size); assert(pcsp_size); ctx-&gt;pcsp_hi |= pcsp_size &lt;&lt; PCSP_SIZE; log_debug(" PCSP.base=0x%lx, PCSP.size=0x%lx\n", PCSP_CALC_STACK_BASE(sp, size), pcsp_size); ctx-&gt;usd_lo |= USD_CALC_STACK_BASE(sp, size) &lt;&lt; USD_BASE; usd_size = USD_CALC_STACK_SIZE(sp, size); assert(usd_size); ctx-&gt;usd_hi |= usd_size &lt;&lt; USD_SIZE; log_debug(" USD.base=0x%lx, USD.size=0x%lx\n", USD_CALC_STACK_BASE(sp, size), usd_size); } static void e2k_calculate_crs(struct context *ctx, uint64_t routine_addr) { uint64_t usd_size = (ctx-&gt;usd_hi &gt;&gt; USD_SIZE) &amp; USD_SIZE_MASK; /* Reserve space in hardware stacks for @routine_addr */ /* Remark: We do not update psp.hi to reserve space for arguments, * since routine do not accepts any arguments. */ ctx-&gt;pcsp_hi |= SZ_OF_CR0_CR1 &lt;&lt; PCSP_IND; ctx-&gt;cr0_hi |= (routine_addr &gt;&gt; CR0_IP) &lt;&lt; CR0_IP; ctx-&gt;cr1_lo |= PSR_ALL_IRQ_ENABLED &lt;&lt; CR1_PSR; /* Divide on 16 because it field contains size in terms * of 128 bit values. */ ctx-&gt;cr1_hi |= (usd_size &gt;&gt; 4) &lt;&lt; CR1_USSZ; } void context_init(struct context *ctx, unsigned int flags, void (*routine_fn)(void), void *sp, unsigned int stack_size) { memset(ctx, 0, sizeof(*ctx)); e2k_calculate_stacks(ctx, sp, stack_size); e2k_calculate_crs(ctx, (uint64_t) routine_fn); if (!(flags &amp; CONTEXT_IRQDISABLE)) { ctx-&gt;upsr |= (UPSR_IE | UPSR_NMIE); } }</span></span></span></span></code> </pre> <br></div></div><br>  O artigo tamb√©m continha trabalhos com interrup√ß√µes, exce√ß√µes e temporizadores, mas, como ficou t√£o grande, decidimos falar sobre isso na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pr√≥xima parte</a> . <br><br>  Por precau√ß√£o, repito, este material n√£o √© uma documenta√ß√£o oficial!  Para suporte oficial, documenta√ß√£o e o restante, voc√™ precisa entrar em contato diretamente com o ICST.  O c√≥digo na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Embox</a> , √© claro, est√° aberto, mas para compil√°-lo, voc√™ precisar√° de um compilador cruzado, que, novamente, pode ser obtido no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MCST</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt447704/">https://habr.com/ru/post/pt447704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt447694/index.html">Configura√ß√£o do sistema distribu√≠do compilado</a></li>
<li><a href="../pt447696/index.html">Por que as cidades se op√µem ao Amazon Go, as primeiras lojas que n√£o s√£o de caixa</a></li>
<li><a href="../pt447698/index.html">Red Hogwarts: acad√™mico sem diploma</a></li>
<li><a href="../pt447700/index.html">A flexibilidade emocional √© a chave para o crescimento pessoal.</a></li>
<li><a href="../pt447702/index.html">O c√≠rculo matem√°tico ideal n√£o existe</a></li>
<li><a href="../pt447706/index.html">Nem um √∫nico ORM</a></li>
<li><a href="../pt447708/index.html">Yandex presenteou jovens cientistas e l√≠deres cient√≠ficos com os primeiros pr√™mios Ilya Segalovich</a></li>
<li><a href="../pt447712/index.html">Ol√° SaaS | SaaS russo 2018 - resultados</a></li>
<li><a href="../pt447714/index.html">Sobre a aplica√ß√£o da teoria dos processos ARMA na pr√°tica de engenharia</a></li>
<li><a href="../pt447716/index.html">Unidade: desenhe muitas barras de sa√∫de em uma chamada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>