<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëë üëåüèª üë®üèæ‚ÄçüöÄ ROS LKW Wagen. Teil 6. Kilometerz√§hler mit Radgebern, Raumkarte, Lidar ‚ôäÔ∏è üí¥ üë©üèº‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beitr√§ge in der Reihe: 
 8. Wir steuern von der Telefon-ROS-Steuerung, GPS-Knoten 
 7. Roboterlokalisierung: Gmapping, AMCL, Referenzpunkte auf der Ra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ROS LKW Wagen. Teil 6. Kilometerz√§hler mit Radgebern, Raumkarte, Lidar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471028/"> Beitr√§ge in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">8. Wir steuern von der Telefon-ROS-Steuerung, GPS-Knoten</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">7. Roboterlokalisierung: Gmapping, AMCL, Referenzpunkte auf der Raumkarte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">6. Kilometerz√§hler mit Radgebern, Raumkarte, Lidar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">5. Wir arbeiten in Rviz und Pavillon: Xacro, neue Sensoren.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4. Erstellen Sie eine Robotersimulation mit den Editoren rviz und pavillon.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3. Beschleunigen, Kamera wechseln, Gang fixieren</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2. Software</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1. Eisen</a> <br><br>  Letztes Mal haben wir das Projekt in Form von separaten XACRO-Modulen entworfen, eine virtuelle Videokamera und ein IMU (Gyroskop) hinzugef√ºgt. <br><br>  In diesem Beitrag werden wir mit Kilometerz√§hlern von optischen Encodern arbeiten, die auf Radwellen montiert sind, eine Raumkarte laden und sie auf einem echten Roboterwagen fahren. <br><a name="habracut"></a><br><h3>  Kilometerz√§hler und tf </h3><br>  Was Odometrie und tf ist und wie sie normalerweise in ROS implementiert werden, ist in der Ressource bereits gut beschrieben, daher verweisen wir hier beispielsweise auf die relevanten Artikel in der Theorie. <br>  Ausgehend von der theoretischen Basis werden wir mit der Praxis arbeiten. <br><br>  Beginnen wir mit der Arbeit an einem Wagenroboter, indem wir ihn √ºber VNC verbinden. <br><br>  Wechseln Sie in den Ordner rosbots_driver und erstellen Sie einen Dateiknoten.  Diese Datei generiert eine Kilometerz√§hler und empf√§ngt sie von optischen Encodern, die sie wiederum an arduino uno und dann an raspberry pi senden. <br><br><pre><code class="plaintext hljs">cd /home/pi/rosbots_catkin_ws/src/rosbots_driver/scripts/rosbots_driver touch diff-tf.py</code> </pre> <br>  Wir haben den Code in die Datei eingef√ºgt: <br><br><div class="spoiler">  <b class="spoiler_title">diff_tf.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python """ diff_tf.py - follows the output of a wheel encoder and creates tf and odometry messages. some code borrowed from the arbotix diff_controller script A good reference: http://rossum.sourceforge.net/papers/DiffSteer/ Copyright (C) 2012 Jon Stephan. """ import rospy #import roslib #roslib.load_manifest('differential_drive') from math import sin, cos, pi from geometry_msgs.msg import Quaternion from geometry_msgs.msg import Twist from geometry_msgs.msg import Vector3 from nav_msgs.msg import Odometry import tf from tf.broadcaster import TransformBroadcaster from std_msgs.msg import Int16, Int32, Int64, UInt32 ############################################################################# class DiffTf: ############################################################################# ############################################################################# def __init__(self): ############################################################################# rospy.init_node("diff_tf") self.nodename = rospy.get_name() rospy.loginfo("-I- %s started" % self.nodename) #### parameters ####### #Wheel radius : 0.0325 # wheel circum = 2* 3.14 * 0.0325 = 0.2041 # One rotation encoder ticks : 8 ticks # For 1 meter: 8 * ( 1 / 0.2041) = 39 ticks self.rate = rospy.get_param('~rate',10.0) # the rate at which to publish the transform self.ticks_meter = float(rospy.get_param('ticks_meter', 190)) # The number of wheel encoder ticks per meter of travel self.base_width = float(rospy.get_param('~base_width', 0.11)) # The wheel base width in meters self.base_frame_id = rospy.get_param('~base_frame_id','base_link') # basefootprint /the name of the base frame of the robot self.odom_frame_id = rospy.get_param('~odom_frame_id', 'odom') # the name of the odometry reference frame self.encoder_min = rospy.get_param('encoder_min', -2147483648) self.encoder_max = rospy.get_param('encoder_max', 2147483648) self.encoder_low_wrap = rospy.get_param('wheel_low_wrap', (self.encoder_max - self.encoder_min) * 0.3 + self.encoder_min ) self.encoder_high_wrap = rospy.get_param('wheel_high_wrap', (self.encoder_max - self.encoder_min) * 0.7 + self.encoder_min ) self.t_delta = rospy.Duration(1.0/self.rate) self.t_next = rospy.Time.now() + self.t_delta # internal data self.enc_left = None # wheel encoder readings self.enc_right = None self.left = 0 # actual values coming back from robot self.right = 0 self.lmult = 0 self.rmult = 0 self.prev_lencoder = 0 self.prev_rencoder = 0 self.x = 0 # position in xy plane self.y = 0 self.th = 0 self.dx = 0 # speeds in x/rotation self.dr = 0 self.yaw = 0.01 self.pitch = 0.01 self.roll = 0.01 self.then = rospy.Time.now() self.quaternion_1 = Quaternion() # subscriptions rospy.Subscriber("wheel_ticks_left", UInt32, self.lwheelCallback) rospy.Subscriber("wheel_ticks_right", UInt32, self.rwheelCallback) #rospy.Subscriber("imu_data", Vector3, self.imu_value_update) self.odomPub = rospy.Publisher("odom", Odometry,queue_size=10) self.odomBroadcaster = TransformBroadcaster() ############################################################################# def spin(self): ############################################################################# r = rospy.Rate(self.rate) while not rospy.is_shutdown(): self.update() r.sleep() ############################################################################# def update(self): ############################################################################# now = rospy.Time.now() if now &gt; self.t_next: elapsed = now - self.then self.then = now elapsed = elapsed.to_sec() # calculate odometry if self.enc_left == None: d_left = 0 d_right = 0 else: d_left = (self.left - self.enc_left) / self.ticks_meter d_right = (self.right - self.enc_right) / self.ticks_meter self.enc_left = self.left self.enc_right = self.right # distance traveled is the average of the two wheels d = ( d_left + d_right ) / 2 # this approximation works (in radians) for small angles th = ( d_right - d_left ) / self.base_width # calculate velocities self.dx = d / elapsed self.dr = th / elapsed if (d != 0): # calculate distance traveled in x and y x = cos( th ) * d y = -sin( th ) * d # calculate the final position of the robot self.x = self.x + ( cos( self.th ) * x - sin( self.th ) * y ) self.y = self.y + ( sin( self.th ) * x + cos( self.th ) * y ) if( th != 0): self.th = self.th + th # publish the odom information quaternion = Quaternion() quaternion.x = 0.0 quaternion.y = 0.0 quaternion.z = sin( self.th / 2 ) quaternion.w = cos( self.th / 2 ) ''' try: quaternion.z = self.quaternion_1[2] quaternion.w = self.quaternion_1[3] except: quaternion.z = sin( self.th / 2 ) quaternion.w = cos( self.th / 2 ) pass ''' self.odomBroadcaster.sendTransform( (self.x, self.y, 0), (quaternion.x, quaternion.y, quaternion.z, quaternion.w), rospy.Time.now(), self.base_frame_id, self.odom_frame_id ) odom = Odometry() odom.header.stamp = now odom.header.frame_id = self.odom_frame_id odom.pose.pose.position.x = self.x odom.pose.pose.position.y = self.y odom.pose.pose.position.z = 0 odom.pose.pose.orientation = quaternion odom.child_frame_id = self.base_frame_id odom.twist.twist.linear.x = self.dx odom.twist.twist.linear.y = 0 odom.twist.twist.angular.z = self.dr self.odomPub.publish(odom) def imu_value_update(self, imu_data): orient = Vector3() orient = imu_data self.yaw = orient.x self.pitch = orient.y self.roll = orient.z try: self.quaternion_1 = tf.transformations.quaternion_from_euler(self.yaw, self.pitch, self.roll) #print self.quaternion_1[0] #print self.quaternion_1[1] #print self.quaternion_1[2] #print self.quaternion_1[3] except: rospy.logwarn("Unable to get quaternion values") pass ############################################################################# def lwheelCallback(self, msg): ############################################################################# enc = msg.data if (enc &lt; self.encoder_low_wrap and self.prev_lencoder &gt; self.encoder_high_wrap): self.lmult = self.lmult + 1 if (enc &gt; self.encoder_high_wrap and self.prev_lencoder &lt; self.encoder_low_wrap): self.lmult = self.lmult - 1 self.left = 1.0 * (enc + self.lmult * (self.encoder_max - self.encoder_min)) self.prev_lencoder = enc ############################################################################# def rwheelCallback(self, msg): ############################################################################# enc = msg.data if(enc &lt; self.encoder_low_wrap and self.prev_rencoder &gt; self.encoder_high_wrap): self.rmult = self.rmult + 1 if(enc &gt; self.encoder_high_wrap and self.prev_rencoder &lt; self.encoder_low_wrap): self.rmult = self.rmult - 1 self.right = 1.0 * (enc + self.rmult * (self.encoder_max - self.encoder_min)) self.prev_rencoder = enc ############################################################################# ############################################################################# if __name__ == '__main__': """ main """ diffTf = DiffTf() diffTf.spin()</span></span></code> </pre><br></div></div><br>  Speichern Sie die Datei und machen Sie sie ausf√ºhrbar: <br> <code>CTRL+X <br> chmod +x diff-tf.py</code> <br> <br>  F√ºhren Sie nun auf dem Roboter die zweiten Knoten aus - Treiber und diff-tf: <br>  1. Terminal: <br><br><pre> <code class="plaintext hljs">python diff_tf.py</code> </pre> <br>  2. Platz: <br><br><pre> <code class="plaintext hljs">rosrun rosbots_driver part2_cmr.py</code> </pre> <br>  Im 3. Terminal werden wir √ºberpr√ºfen, ob es neue Themen zu odom und tf gibt: <br><br><img src="https://habrastorage.org/webt/zy/tc/rw/zytcrwcee_4-ygvgiwipil9jyxm.png"><br><br>  Lassen Sie uns mit dem Befehl rostopic echo odom sehen, was im Thema ver√∂ffentlicht wird (und ob es √ºberhaupt ver√∂ffentlicht wird). <br>  Die Ausgabe erfolgt ungef√§hr wie folgt: <br><br><img src="https://habrastorage.org/webt/c2/f0/-o/c2f0-onzf3-8gdjtvegw7axrgtw.png"><br><br>  Ohne die laufenden Knoten auf dem Roboter zu schlie√üen, starten wir jetzt den Steuercomputer mit den grafischen Umgebungen rviz und pavillon. <br><br>  * Ein Image (virtuelle VMWare-Maschine mit Ubuntu 16.04 + ROS Kinetic), das zuvor zum Download angeboten wurde, enth√§lt alles, was Sie ben√∂tigen. <br><br>  F√ºhren Sie das Modell auf dem Steuercomputer (im Folgenden als ‚ÄûComputer‚Äú bezeichnet) in rviz aus: <br><br><pre> <code class="plaintext hljs">roslaunch rosbots_description rviz.launch</code> </pre> <br>  Das geladene Robotermodell, mit dem in fr√ºheren Beitr√§gen gearbeitet wurde, wird geladen: <br><br><img src="https://habrastorage.org/webt/e2/xf/kb/e2xfkbeuzqsl8g9vcl_ffiz2caa.png"><br><br>  F√ºgen Sie rviz zwei Anzeigen hinzu, indem Sie auf Hinzuf√ºgen klicken.  Die Anzeige mit Kilometerz√§hler und die Anzeige mit tf aktivieren die Kontrollk√§stchen, um sie zu visualisieren. <br><br>  In dem Fenster, in dem das Robotermodell dargestellt ist, werden charakteristische Grafiken angezeigt: <br><br><img src="https://habrastorage.org/webt/i_/p3/r1/i_p3r1fflodksrj2vowmldcmxl0.png"><br>  * Um es besser sichtbar zu machen, k√∂nnen Sie die Robotmodel-Anzeige ausschalten. <br><br>  Wir steuern den Roboter √ºber die Tastatur des Computers und sehen, wie sich die Visualisierung von tf und Kilometerz√§hler √§ndert. <br><br>  Ohne rviz im 2. Terminal zu schlie√üen, starten wir die Steuerung √ºber die Tastatur: <br><br><pre> <code class="plaintext hljs">rosrun teleop_twist_keyboard teleop_twist_keyboard.py /cmd_vel:=/part2_cmr/cmd_vel</code> </pre> <br>  Bei der Steuerung des Roboters werden im Fenster mit der Visualisierung angezeigt: roter Pfeil (Visualisierung des Odom-Themas), Vektorlinien (tf-Thema). <br><br>  Wenn der rote Pfeil des Odom-Themas die Bewegungsrichtung des Roboters anzeigt, zeigen die Vektorlinien tf, wie sich die einzelnen Elemente des Roboters im Raum befinden: <br><br><div class="spoiler">  <b class="spoiler_title">das Video</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/CC6CO5VIDUA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  Um fortzufahren, m√ºssen Sie die Kilometerz√§hler ‚Äûeinstellen‚Äú. <br>  Schlie√üen Sie dazu den rviz-Editor und starten Sie ihn erneut, ohne das Modell mit dem folgenden Befehl zu visualisieren: <br><br><pre> <code class="plaintext hljs">rosrun rviz rviz</code> </pre> <br>  Dies ist notwendig, damit nur base_link und odom von den Vektoren des tf-Themas √ºbrig bleiben: <br><br><img src="https://habrastorage.org/webt/x6/qn/fn/x6qnfnbvkzstivryymtyovdnmuw.gif"><br><br>  In rviz ist eine Zelle 1 Meter.  In der Realit√§t muss der Roboter daher auch 1 Meter passieren, damit die Daten vergleichbar sind. <br><br>  Wir passieren 1 Meter am Roboter und steuern ihn √ºber die Tastatur.  In rviz muss der Roboter auch 1 Meter fahren - eine Zelle. <br><br>  Wenn der Roboter l√§nger f√§hrt als in rviz oder umgekehrt, eine k√ºrzere Strecke als in der Realit√§t, m√ºssen Sie die zuvor erstellte Datei diff_tf.py bearbeiten, n√§mlich diesen Block: <br><br><div class="spoiler">  <b class="spoiler_title">diff_tf.py</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> #### parameters ####### #Wheel radius : 0.0325 # wheel circum = 2* 3.14 * 0.0325 = 0.2041 # One rotation encoder ticks : 8 ticks # For 1 meter: 8 * ( 1 / 0.2041) = 39 ticks self.rate = rospy.get_param('~rate',10.0) # the rate at which to publish the transform self.ticks_meter = float(rospy.get_param('ticks_meter', 190)) # The number of wheel encoder ticks per meter of travel self.base_width = float(rospy.get_param('~base_width', 0.11)) # The wheel base width in meters</code> </pre> <br></div></div><br><h3>  Karte </h3><br>  Um irgendwohin zu gelangen, ben√∂tigen Sie eine Karte.  F√ºr die Zwecke unseres Roboters ben√∂tigen wir eine Raumkarte. <br>  Lass uns mit ihr arbeiten. <br><br>  Um eine Karte auf rviz hochzuladen, m√ºssen Sie im Projekt (rosbots_description) auf dem Computer (nicht auf dem Roboter) einen Kartenordner erstellen und zwei Dateien darin ablegen, aus denen die Karte besteht: map.pgm und map.yaml. <br>  * In einem Ordner k√∂nnen sich mehrere Kartendateien befinden, Sie k√∂nnen jedoch nur eine in den Assistenten hochladen. <br><br>  Eine Karte in ROS besteht aus zwei Dateien, von denen eine ein PGM-Bild ist, wobei jedes Pixel entweder: <br><br><ul><li>  Leerraum ist frei; </li><li>  Schwarzraum wird von einem Hindernis besetzt; </li><li>  Grauraum wurde noch nicht erforscht. </li></ul><br>  Die zweite .yaml-Datei ist eine Datei mit den Einstellungen der Karte, in der die Abmessungen, die Pixelbelegung mit verschiedenen Typen (oben aufgef√ºhrt) und andere Parameter angegeben sind. <br><br>  F√ºhren Sie den Knoten auf dem Computer aus, auf dem die Karte ver√∂ffentlicht wird: <br><br><pre> <code class="plaintext hljs">rosrun map_server map_server /home/pi/catkin_ws/src/rosbots_description/maps/rail_lab.pgm 0.05</code> </pre> <br>  F√ºhren Sie im benachbarten Terminal das Modell in rviz aus: <br><br><pre> <code class="plaintext hljs">roslaunch rosbots_description rviz.launch</code> </pre> <br>  F√ºgen Sie in rviz eine Kartenanzeige hinzu. <br><br>  In rviz stellte sich heraus, dass der Roboter unverh√§ltnism√§√üig gro√ü war und sich au√üerhalb der Karte befand: <br><br><img src="https://habrastorage.org/webt/h6/ob/8g/h6ob8gyq_u11omb3bzneqczgkra.gif"><br><br>  Um dies zu beheben, m√ºssen Sie eine Karte ausf√ºhren, bei der die Zellengr√∂√üe 1 Meter betr√§gt.  Starten Sie die Karte mit Parameter 1 am Ende neu: <br><br><pre> <code class="plaintext hljs">rosrun map_server map_server /home/pi/catkin_ws/src/rosbots_description/maps/rail_lab.pgm 1</code> </pre> <br>  Jetzt k√∂nnen Sie die Karte in rviz fahren und den Roboter √ºber die Tastatur steuern: <br><br><div class="spoiler">  <b class="spoiler_title">das Video</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/bbsn97FUNnI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br>  <b>Also, was wurde erreicht</b> : <br><br><ul><li>  Empfangen von Kilometerz√§hlerdaten von optischen Radcodierern des Roboters und Senden an Themen zur Anzeige in rviz; </li><li>  Konfigurieren Sie die Roboter-Kilometerz√§hler so, dass sie der zur√ºckgelegten Strecke live und virtuell entsprechen. </li><li>  Laden Sie eine Raumkarte und zeigen Sie sie an. </li></ul><br>  Trotz der Tatsache, dass die Karte angezeigt wird und der Roboter mit einer ‚Äûabgestimmten‚Äú Kilometerz√§hler darauf fahren kann, ist der Roboter in Wirklichkeit blind.  Er sieht keine Hindernisse und wird √ºber sie stolpern.  Das zweite Minus ist die in rviz geladene virtuelle Raumkarte, mit der Sie alleine in alle Richtungen fahren k√∂nnen, auch dort, wo die Hindernisse deutlich sichtbar sind. <br><br>  Wie kann der Roboter Hindernisse in der Realit√§t und virtuell "sehen"? <br><br>  Mit einer virtuellen Umgebung ist einfacher.  Alles hier basiert auf dem Pavillon-Emulator-Editor.  Und in fr√ºheren Beitr√§gen wurde dies erw√§hnt. <br><br>  Es ist komplizierter mit der Realit√§t.  Wir ben√∂tigen ein Element (Sensor), das Hindernisse anzeigt und dies dem System meldet. <br><br>  Eine M√∂glichkeit besteht darin, Lidar auf den Roboter zu setzen. <br><br><h3>  Lidar RPlidar A1 </h3><br>  Wir werden die kosteng√ºnstige Budgetl√∂sung verwenden und den Lidar auf den Roboter setzen.  M√∂glicherweise ist diese L√∂sung teurer als die Verwendung des gleichen Kinect, aber wie die Praxis gezeigt hat, ist sie hinsichtlich Geschwindigkeit, Genauigkeit und einfacher Installation effektiver (weniger umst√§ndlich).  Au√üerdem ist es einfacher, mit Lidar zu arbeiten  Es sind keine √úberlegungen erforderlich, wie das Ger√§t mit Strom versorgt und mit dem Projekt verbunden werden kann (https://habr.com/en/company/tod/blog/210252/). <br><br>  Wir ben√∂tigen das ros-Paket, um mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lidar</a> arbeiten zu k√∂nnen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wiki.ros.org/rplidar</a> . <br>  Mit Hilfe des Lidars erstellen wir eine Karte des Raumes und verwenden sie auch f√ºr die Navigation. <br><br>  Wie man rplidar in ROS installiert, enth√§lt viele Artikel, zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Wir werden das Wissen grauhaariger alter M√§nner nutzen und Pakete mit Lidar im System <u>des Roboters</u> installieren: <br><br><pre> <code class="plaintext hljs">cd /home/pi/rosbots_catkin_ws/src git clone https://github.com/robopeak/rplidar_ros.git cd .. catkin_make</code> </pre> <br>  Installieren Sie auf dem <u>Computer</u> das Paket f√ºr die Arbeit mit der Karte: <br><br><pre> <code class="plaintext hljs">cd /home/pi/rosbots_catkin_ws/src git clone https://github.com/tu-darmstadt-ros-pkg/hector_slam &lt;/code&gt; cd .. catkin_make</code> </pre> <br>  F√ºhren Sie das Paket auf dem Roboter aus und pr√ºfen Sie, ob das Lidar funktioniert: <br><br><pre> <code class="plaintext hljs">sudo chmod a+rw /dev/ttyUSB0 roslaunch rplidar_ros rplidar.launch</code> </pre> <br>  * Der erste Befehl erm√∂glicht den Zugriff auf den USB-Port, an dem das Lidar angeschlossen ist. <br><br>  Wenn alles reibungslos gelaufen ist, werden Zeilen an die Konsole ausgegeben: <br><br><pre> <code class="plaintext hljs">[ INFO] [1570900184.874891236]: RPLIDAR running on ROS package rplidar_ros. SDK Version:1.9.0 RPLIDAR S/N: ---------------- [ INFO] [1570900187.397858270]: Firmware Ver: 1.24 [ INFO] [1570900187.398081809]: Hardware Rev: 5 [ INFO] [1570900187.401749476]: RPLidar health status : 0 [ INFO] [1570900188.014285166]: current scan mode: Express, max_distance: 12.0 m, Point number: 4.0K , angle_compensate: 1</code> </pre> <br>  Hier konfigurieren wir sofort ein kleines Lidar, weil  Die offizielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Website</a> sagt, dass es (Lidar) besser funktionieren kann. <br><br>  Wir m√ºssen die Ausgabe erreichen, wenn das Scannen nicht 4,0 KB Punkte betr√§gt, die standardm√§√üig ausgegeben werden, sondern 8,0 KB.  Diese Option verbessert die Scanqualit√§t geringf√ºgig. <br><br>  Dazu setzen wir im rplidar-Paket einen weiteren Parameter - den Scan-Modus: <br><br><pre> <code class="plaintext hljs">cd /rosbots_catkin_ws/src/rplidar_ros/launch nano nano rplidar.launch</code> </pre> <br>  Und danach <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"angle_compensate"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"bool"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre>  F√ºgen Sie die Zeile hinzu: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"scan_mode"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"string"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Boost"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  Die zweite Zeile, die hier behoben werden muss: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"frame_id"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"string"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"laser"</span></span></span><span class="hljs-tag">/&gt;</span></span></code> </pre> <br>  Ersetzen Sie den Laserwert durch base_link. <br><br>  * Wenn Sie nun den Knoten mit dem Befehl roslaunch rplidar_ros rplidar.launch neu starten, ist die Ausgabe anders: <br><br><pre> <code class="plaintext hljs">[ INFO] [1570900188.014285166]: current scan mode: Boost, max_distance: 12.0 m, Point number: 8.0K , angle_compensate: 1</code> </pre> <br>  Schau mal rein.  welches Lidar in Rviz anzeigt. <br><br>  F√ºhren Sie dazu den Roboter aus: <br><br><pre> <code class="plaintext hljs">roslaunch rplidar_ros rplidar.launch</code> </pre> <br>  Auf einem Computer: <br><br><pre> <code class="plaintext hljs">roslaunch rosbots_description rviz.launch</code> </pre> <br>  F√ºgen Sie in rviz die LaserScan-Anzeige hinzu und w√§hlen Sie das Scan-Thema aus.  Weiterhin wird ersichtlich, dass Nachrichten in das Thema fallen: <br><br><img src="https://habrastorage.org/webt/mg/mo/6p/mgmo6p_pyjzofzrfyxwj5ollnrw.gif"><br><br>  Im Fenster mit der Visualisierung des Roboters stellte sich heraus, dass der Roboter ein Riese war.  Mit seiner Gr√∂√üe werden wir es sp√§ter herausfinden.  Nun erstellen wir eine Raumkarte. <br><br>  Erstellen Sie dazu ein Paket mit einem Knoten: <br><br><pre> <code class="plaintext hljs">catkin_create_pkg my_hector_mapping rospy cd my_hector_mapping mkdir launch cd launch nano hector.launch</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">hector.launch</b> <div class="spoiler_text"><pre> <code class="python hljs">&lt;?xml version=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span>?&gt; &lt;launch&gt; &lt;node pkg=<span class="hljs-string"><span class="hljs-string">"tf"</span></span> type=<span class="hljs-string"><span class="hljs-string">"static_transform_publisher"</span></span> name=<span class="hljs-string"><span class="hljs-string">"laser_link"</span></span> args=<span class="hljs-string"><span class="hljs-string">"0.0 0.0 0.0 0.0 0.0 0.0 /base_link /laser 50"</span></span> /&gt; &lt;node pkg=<span class="hljs-string"><span class="hljs-string">"hector_mapping"</span></span> type=<span class="hljs-string"><span class="hljs-string">"hector_mapping"</span></span> name=<span class="hljs-string"><span class="hljs-string">"hector_mapping"</span></span> output=<span class="hljs-string"><span class="hljs-string">"screen"</span></span>&gt; &lt;!-- Frame names --&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_frame"</span></span> value=<span class="hljs-string"><span class="hljs-string">"map"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"odom_frame"</span></span> value=<span class="hljs-string"><span class="hljs-string">"base_link"</span></span> /&gt; &lt;!-- Map size / start point --&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_resolution"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.050"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_size"</span></span> value=<span class="hljs-string"><span class="hljs-string">"1024"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_start_x"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.5"</span></span>/&gt; //  &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_start_y"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.5"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_multi_res_levels"</span></span> value=<span class="hljs-string"><span class="hljs-string">"2"</span></span> /&gt; &lt;!-- Map update parameters --&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"update_factor_free"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.4"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"update_factor_occupied"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.9"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_update_distance_thresh"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.4"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"map_update_angle_thresh"</span></span> value=<span class="hljs-string"><span class="hljs-string">"0.06"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"laser_z_min_value"</span></span> value=<span class="hljs-string"><span class="hljs-string">"-1.0"</span></span> /&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"laser_z_max_value"</span></span> value=<span class="hljs-string"><span class="hljs-string">"1.0"</span></span> /&gt; &lt;!-- Advertising config --&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"advertise_map_service"</span></span> value=<span class="hljs-string"><span class="hljs-string">"true"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"scan_subscriber_queue_size"</span></span> value=<span class="hljs-string"><span class="hljs-string">"5"</span></span>/&gt; &lt;param name=<span class="hljs-string"><span class="hljs-string">"scan_topic"</span></span> value=<span class="hljs-string"><span class="hljs-string">"scan"</span></span>/&gt; &lt;/node&gt; &lt;/launch&gt;</code> </pre><br></div></div><br><pre> <code class="plaintext hljs">cd ~/rosbots_catkin_ws catkin_make</code> </pre> <br>  Lass es uns laufen. <br><br>  Auf dem Roboter: <br><br>  1. Terminal: <code>roslaunch rplidar_ros rplidar.launch</code> <br>  2. <code>rosrun rosbots_driver part2_cmr.py</code> <br><br>  Auf einem Computer: <br><br>  1. Terminal: <code>roslaunch my_hector_mapping hector.launch</code> <br>  2. <code>roslaunch rosbots_description rviz.launch</code> <br>  3. <code>rosrun teleop_twist_keyboard teleop_twist_keyboard.py /cmd_vel:=/part2_cmr/cmd_vel</code> <br><br>  In den Anzeigen m√ºssen Sie eine Karte hinzuf√ºgen und als fester Rahmen base_link ausw√§hlen.  Dann k√∂nnen Sie in Echtzeit beobachten, wie der Lidar den Raum um ihn herum "beleuchtet": <br><br><img src="https://habrastorage.org/webt/-6/gv/gq/-6gvgqgtmggjf7ffvnwlr1w6gwa.jpeg"><br><br>  Im aktuellen Schritt m√ºssen Sie zum Erstellen einer Karte durch den Raum fahren und in verschiedenen Winkeln ‚Äûanhalten‚Äú, damit das Lidar sie auf der Karte markiert. <br><br>  Also Lehrb√ºcher empfehlen.  Wir empfehlen jedoch, den Roboter aufzunehmen, mit ihm zu gehen und ihn vor sich zu halten.  Die Geschwindigkeit beim Erstellen einer Karte ist also in dem Sinne h√∂her, dass Sie nicht abgelenkt werden m√ºssen und schauen m√ºssen, wo der Roboter ohne Sichtkontakt im n√§chsten Raum gefahren ist. <br><br>  Wenn der Roboter w√§hrend einer Fahrt um seine Achse gedreht wird, hinterl√§sst der Lidar au√üerdem charakteristische schwarze Artefakte an den Stellen, an denen es tats√§chlich keine Hindernisse gibt: <br><br><img src="https://habrastorage.org/webt/wf/tn/0y/wftn0yxvutj6keza4jhqngsasai.jpeg"><br><br>  Speichern Sie die Karte nach dem Erstellen mit dem folgenden Befehl: <br><br><pre> <code class="plaintext hljs">rosrun map_server map_saver -f map-1</code> </pre> <br>  Das Erstellen der perfekten Karte mit einem Budget-Lidar ist ein Mythos.  Daher werden wir dem Lidar in Photoshop helfen.  Wir werden die schwarzen Artefakte von der Karte entfernen, wo es wirklich keine Hindernisse gibt, und die W√§nde an schwarzen Linien ausrichten: <br><br><img src="https://habrastorage.org/webt/-k/xv/fo/-kxvfoxyjflij37fvy_ntw2d-ic.jpeg"><br><br>  Vergessen Sie nicht, die Karte im PNG-Format zu speichern. <br><br>  Jetzt wiederholen wir auf dem Computer die Befehle, die am Anfang des Beitrags standen, aber mit einer neuen Karte: <br>  1. Terminal: <code>rosrun map_server maserver /home/pi/catkin_ws/src/rosbots_description/maps/map-1.pgm 0.05</code> <br>  2. <code>roslaunch rosbots_description rviz.launch</code> <br><br>  Ergebnis in rviz: <br><br><img src="https://habrastorage.org/webt/g1/g9/mj/g1g9mjpl0nwsgfumdmpmrvvem4q.jpeg"><br><br>  Die neue Karte wurde geladen, wie das Robotermodell darauf, aber der Roboter befindet sich au√üerhalb der Karte. <br><br>  Wir werden sp√§ter dar√ºber sprechen, aber lassen Sie uns zun√§chst Folgendes zusammenfassen: <br><br><ul><li>  Lidar RP-Lidar A1 beherrschen </li><li>  Erstellen einer Raumkarte mit einem Lidar, Anpassen und Laden in den visuellen Editor von rviz. </li></ul><br>  Dateien zum Herunterladen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Raumkarte</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471028/">https://habr.com/ru/post/de471028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471018/index.html">Vergleich der Leistung von PC und Smartphone, einschlie√ülich iPhone 11</a></li>
<li><a href="../de471020/index.html">So finden Sie einen Fehler in einem Mikroprozessor, der vor 35 Jahren ver√∂ffentlicht wurde</a></li>
<li><a href="../de471022/index.html">Enth√ºllung eines 140 Jahre alten Geheimnisses in der Physik</a></li>
<li><a href="../de471024/index.html">Analyse: Was sind Futures und wie werden sie f√ºr Tauschinvestitionen verwendet?</a></li>
<li><a href="../de471026/index.html">TypeScript Macht niemals</a></li>
<li><a href="../de471032/index.html">Unsichtbares Foto</a></li>
<li><a href="../de471034/index.html">Interview mit Pornhub Web Developer</a></li>
<li><a href="../de471036/index.html">Lebe und lerne. Teil 5. Selbstbildung: Rei√ü dich zusammen</a></li>
<li><a href="../de471038/index.html">Linux-Deskriptordatei mit Beispielen</a></li>
<li><a href="../de471040/index.html">[Lesezeichen] PDF- und ePUB-Version des React-Handbuchs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>