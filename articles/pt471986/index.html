<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ê üöô üöÑ Gram√°tica PEG recursiva esquerda üåî ‚òÇÔ∏è üö¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mencionei a recurs√£o esquerda como uma pedra de trope√ßo v√°rias vezes, e √© hora de descobrir isso. O principal problema √© que um analisador com uma des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gram√°tica PEG recursiva esquerda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471986/"><p>  Mencionei a recurs√£o esquerda como uma pedra de trope√ßo v√°rias vezes, e √© hora de descobrir isso.  O principal problema √© que um analisador com uma descida recursiva esquerda falha instantaneamente devido a um estouro de pilha. </p><br><div class="spoiler">  <b class="spoiler_title">Conte√∫do da s√©rie Ps Parser Python</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Analisadores de Peg</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementa√ß√£o do Analisador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gera√ß√£o de analisador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visualiza√ß√£o do analisador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gram√°tica PEG recursiva esquerda</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Adicionando a√ß√µes √† gram√°tica PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Meta gram√°tica para analisador PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Implementando os recursos restantes do PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PEG no Core Developer Sprint</a> </li></ul></div></div><br><p>  Considere esta regra gramatical hipot√©tica: </p><br><pre><code class="plaintext hljs">expr: expr '+' term | term</code> </pre> <a name="habracut"></a><br><p>  Se implement√°ssemos esse peda√ßo de gram√°tica no m√©todo analisador recursivo esquerdo, obter√≠amos algo como o seguinte: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Assim, <code>expr()</code> come√ßa com uma chamada para <code>expr()</code> , que come√ßa com uma chamada para <code>expr()</code> , que come√ßa com uma chamada ... Isso s√≥ pode terminar com um estouro de pilha, expresso como uma exce√ß√£o <code>RecursionError</code> . </p><br><p>  A solu√ß√£o tradicional √© reescrever a gram√°tica.  Nas partes anteriores, fiz exatamente isso.  De fato, a regra gramatical acima pode ser reescrita da seguinte maneira: </p><br><pre> <code class="plaintext hljs">expr: term '+' expr | term</code> </pre> <br><p>  No entanto, na etapa de constru√ß√£o da √°rvore de an√°lise, sua forma seria diferente.  Isso pode arruinar a situa√ß√£o se adicionarmos o operador <code>'-'</code> √† gram√°tica (j√° que <code>a - (b - c)</code> n√£o <code>a - (b - c)</code> o mesmo que <code>(a - b) - c</code> ).  Isso geralmente √© resolvido com fun√ß√µes PEG mais poderosas, como agrupamento e itera√ß√£o, e podemos reescrever a regra acima como: </p><br><pre> <code class="plaintext hljs">expr: term ('+' term)*</code> </pre> <br><p>  Na verdade, √© assim que a gram√°tica Python atual √© escrita para o analisador pgen (que tem os mesmos problemas com as regras recursivas √† esquerda). </p><br><p>  No entanto, h√° um pequeno problema: como operadores como <code>'+'</code> e <code>'-'</code> (em Python) s√£o na maioria bin√°rios, quando analisamos algo como <code>a + b + c</code> , temos que passar pelo resultado da an√°lise (que essencialmente uma lista de <code>['a', '+', 'b', '+', 'c']</code> ) para criar uma √°rvore de an√°lise recursiva esquerda (que seria algo parecido com isto <code>[['a', '+', 'b'] , '+', 'c']</code> ). </p><br><p>  A gram√°tica recursiva esquerda original j√° sugere a associatividade desejada, portanto seria bom gerar um analisador diretamente desse formul√°rio.  E n√≥s podemos!  Um leitor apontou um bom truque com provas matem√°ticas f√°ceis de implementar.  Agora vou tentar explicar. </p><br><p>  Vejamos um exemplo de entrada <code>foo + bar + baz</code> .  A √°rvore de an√°lise que gostar√≠amos de obter corresponde a <code>(foo + bar) + baz</code> .  Isso requer tr√™s chamadas recursivas √† esquerda para a fun√ß√£o <code>expr()</code> : uma corresponde ao operador de n√≠vel superior <code>'+'</code> (ou seja, o segundo);  mais um - para o operador interno <code>'+'</code> (ou seja, o primeiro);  e a terceira √© a escolha da segunda alternativa (isto √©, <code>term</code> ). </p><br><p>  Como n√£o sou bom em desenhar diagramas reais usando ferramentas especiais, mostrarei isso aqui usando arte ASCII: </p><br><pre> <code class="plaintext hljs">expr------------+------+ | \ \ expr--+------+ '+' term | \ \ | expr '+' term | | | | term | | | | | 'foo' 'bar' 'baz'</code> </pre> <br><p>  A id√©ia √© que, na fun√ß√£o <code>expr()</code> , precisamos de um ‚Äúor√°culo‚Äù que nos diga se deve escolher a primeira alternativa (ou seja, a chamada recursiva para <code>expr()</code> ) ou a segunda (ou seja, o <code>term()</code> chamada).  Na primeira chamada para <code>expr()</code> or√°culo deve nos dizer para seguir a primeira alternativa ( <code>expr()</code> );  na segunda chamada (recursiva) - da mesma forma, mas na terceira deve nos solicitar a chamada <code>term()</code> .  No c√≥digo, ficar√° assim: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oracle() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Como escrever tal or√°culo?  Vamos ver ... Podemos tentar rastrear o n√∫mero de chamadas <code>expr()</code> esquerda (recursivas) na pilha de chamadas e compar√°-lo com o n√∫mero de operadores <code>'+'</code> na express√£o a seguir.  Se a pilha de chamadas for mais profunda que o n√∫mero de instru√ß√µes, o or√°culo deve retornar falso (for√ßar-nos a selecionar o <code>term()</code> ).  Mal posso esperar para implementar isso com <code>sys._getframe()</code> , mas existe uma maneira melhor: vamos virar a pilha de chamadas! </p><br><p>  A id√©ia √© que come√ßemos com uma chamada em que o or√°culo retorne falso e salve o resultado.  Isso nos d√° a sequ√™ncia <code>expr() -&gt; term() -&gt; 'foo'</code> .  (Ele deve retornar uma √°rvore de an√°lise para o <code>term</code> inicial, ou seja, <code>'foo'</code> . O c√≥digo acima retorna <code>True</code> , mas na segunda parte da s√©rie de artigos eu j√° mostrei como retornar a √°rvore de an√°lise.) Esse or√°culo √© f√°cil de implementar, pois deveria basta retornar <code>False</code> na primeira chamada - n√£o √© necess√°rio verificar ou espiar no futuro. </p><br><p>  Ent√£o chamamos <code>expr()</code> novamente, e desta vez o or√°culo retorna <code>True</code> , mas, em vez da chamada recursiva esquerda para <code>expr()</code> , substitu√≠mos o resultado salvo pela chamada anterior.  E como o operador esperado <code>'+'</code> e o pr√≥ximo token adequado tamb√©m est√£o presentes, isso nos dar√° uma √°rvore de an√°lise para <code>foo + bar</code> . </p><br><p>  Mais uma vez, repetimos o algoritmo e, novamente, tudo acontece: desta vez, obtemos uma √°rvore de an√°lise para a express√£o completa, e √© realmente recursiva √† esquerda ( <code>(foo + bar) + baz</code> ). </p><br><p>  Em seguida, repetimos o algoritmo novamente.  Mas desta vez, embora o Oracle retorne <code>True</code> e o resultado salvo da chamada anterior tamb√©m esteja dispon√≠vel, n√£o h√° mais operador <code>'+'</code> e a primeira alternativa falha.  Assim, tentamos a segunda op√ß√£o, que obt√©m sucesso, e encontra apenas o termo inicial ( <code>'foo'</code> ).  Esse resultado √© pior que o obtido na primeira alternativa, portanto, nesta etapa, paramos e salvamos a an√°lise mais longa (ou seja, <code>(foo + bar) + baz</code> ). </p><br><p>  Para transformar isso em c√≥digo funcional, modifiquei um pouco o algoritmo para combinar a chamada <code>oracle()</code> com a chamada recursiva esquerda para <code>expr()</code> .  Vamos cham√°-lo de <code>oracle_expr()</code> .  C√≥digo: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oracle_expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  A seguir, escreveremos um wrapper que implementa a l√≥gica descrita acima.  Ele usa uma vari√°vel global (n√£o se preocupe, vou me livrar dela mais tarde).  A fun√ß√£o <code>oracle_expr()</code> l√™ a vari√°vel global e o wrapper a controla: </p><br><pre> <code class="python hljs">saved_result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oracle_expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> saved_result <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saved_result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> saved_result saved_result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> parsed_length = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: new_result = expr() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> new_result: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> new_parsed_length = &lt;calculate size of new_result&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> new_parsed_length &lt;= parsed_length: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> saved_result = new_result parsed_length = new_parsed_length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saved_result</code> </pre> <br><p>  O c√≥digo, √© claro, √© terr√≠vel, mas pelo menos transmite a ess√™ncia do algoritmo.  Vamos refator√°-lo para que possamos nos orgulhar disso. </p><br><p>  O entendimento mais importante (que me pertence, embora provavelmente n√£o seja o primeiro a perceber isso) √© que podemos usar o cache de memoriza√ß√£o em vez de uma vari√°vel global.  Nele, armazenaremos o resultado de uma chamada para outra.  Ent√£o nos livramos de uma fun√ß√£o separada <code>oracle_expr()</code> , porque  podemos gerar uma chamada padr√£o para <code>expr()</code> independentemente de estar em uma posi√ß√£o recursiva √† esquerda ou √† direita. </p><br><p>  Portanto, precisamos de um decorador <code>@memoize_left_rec</code> separado, usado apenas para regras recursivas √† esquerda.  Ele chama a fun√ß√£o <code>oracle_expr()</code> , puxando o valor armazenado do cache de memoriza√ß√£o e cont√©m um loop que chama a fun√ß√£o <code>expr()</code> v√°rias vezes, at√© que cada novo resultado seja compar√°vel a uma por√ß√£o cada vez maior dos dados de entrada que o anterior.  E, √© claro, uma vez que cada posi√ß√£o de entrada e cada m√©todo de an√°lise s√£o armazenados em cache separadamente, n√£o se preocupa com o retorno ou algumas regras recursivas (por exemplo, na gram√°tica de brinquedos que usei, tanto <code>expr</code> quanto <code>term</code> s√£o deixados recursivos). </p><br><p>  Outra das vantagens do prot√≥tipo que criei na terceira parte √© que facilita verificar se o novo resultado √© maior que o antigo: o m√©todo <code>mark()</code> retorna o √≠ndice na matriz de tokens de entrada, para que possamos us√°-lo em vez de <code>parsed_length</code> . </p><br><p>  Omiti a prova de por que esse algoritmo sempre funciona, por mais insana que seja a gram√°tica.  Na verdade, eu nem li.  Vejo que isso funciona para casos simples, como <code>expr</code> na minha gram√°tica de brinquedos, bem como para casos um pouco mais complexos (por exemplo, usando a recurs√£o esquerda oculta por tr√°s de elementos opcionais em uma alternativa ou usando a recurs√£o m√∫tua entre v√°rias regras).  A situa√ß√£o mais dif√≠cil que me lembro na gram√°tica Python ainda √© resolvida por esse algoritmo, ent√£o confio apenas no teorema e nas pessoas que o provaram. </p><br><p>  Vamos escrever o c√≥digo de batalha. </p><br><p>  Primeiro, o gerador do analisador deve determinar quais regras s√£o deixadas recursivas.  Este √© um problema resolvido na teoria dos grafos.  N√£o vou mostrar o algoritmo aqui e, de fato, quero simplific√°-lo ainda mais.  Suponho que as √∫nicas regras recursivas √† esquerda na gram√°tica s√£o diretamente recursivas √† esquerda, como <code>expr</code> em nossa gram√°tica de brinquedos.  Em seguida, para verificar a recursividade √† esquerda, basta procurar uma alternativa que comece com o nome da regra atual: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_left_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rule)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> alt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rule.alts: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> alt[<span class="hljs-number"><span class="hljs-number">0</span></span>] == rule.name: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Agora vamos mudar o gerador do analisador para que, para regras recursivas √† esquerda, gere outro decorador.  Lembre-se de que na terceira parte, <code>@memoize</code> todos os m√©todos do analisador no <code>@memoize</code> .  Agora faremos uma pequena altera√ß√£o no gerador para que, para as regras recursivas √† esquerda, usemos <code>@memoize_left_rec</code> e, em seguida, implementaremos a m√°gica no decorador <code>memoize_left_rec</code> .  O restante do gerador e outros c√≥digos n√£o precisam ser alterados!  (Embora eu tenha que mexer no c√≥digo de visualiza√ß√£o) </p><br><p>  Para refer√™ncia, aqui est√° o decorador original <code>@memoize</code> , copiado da parte 3. Lembre-se de que <code>self</code> √© uma inst√¢ncia do <code>Parser</code> que possui um atributo de <code>memo</code> (inicializado com um dicion√°rio vazio) e os m√©todos <code>mark()</code> e <code>reset()</code> que obt√™m e definem a posi√ß√£o atual tokenizer: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = func(self, *args) endpos = self.mark() memo[key] = res, endpos <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoize_wrapper</code> </pre> <br><p>  O decorador <code>@memoize</code> lembra as chamadas anteriores para cada posi√ß√£o no fluxo de entrada - para cada posi√ß√£o na matriz (lenta) de tokens de entrada, h√° um dicion√°rio de <code>memo</code> separado.  As quatro primeiras linhas de <code>memoize_wrapper</code> dedicadas a obter o dicion√°rio de <code>memo</code> correto. </p><br><p>  E aqui est√° <code>@memoize_left_rec</code> .  Somente o ramo <code>else</code> √© um pouco diferente da implementa√ß√£o em <code>@memoize</code> acima: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_left_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_left_rec_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Prime the cache with a failure. memo[key] = lastres, lastpos = None, pos # Loop until no longer parse is obtained. while True: self.reset(pos) res = func(self, *args) endpos = self.mark() if endpos &lt;= lastpos: break memo[key] = lastres, lastpos = res, endpos res = lastres self.reset(lastpos) return res return memoize_left_rec_wrapper</span></span></code> </pre> <br><p>  Provavelmente √© interessante como isso funciona para o m√©todo <code>expr()</code> .  Vamos ver como o seguinte c√≥digo ser√° executado: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta"> @memoize_left_rec def expr(self): pos = self.mark() if ((expr := self.expr()) and self.expect('+') and (term := self.term())): return Node('expr', [expr, term]) self.reset(pos) if term := self.term(): return Node('term', [term]) self.reset(pos) return None</span></span></code> </pre> <br><p>  No exemplo de an√°lise <code>foo + bar + baz</code> . </p><br><p>  Sempre que voc√™ chama a fun√ß√£o <code>expr()</code> , a chamada √© "conectada" pelo decorador que est√° procurando a chamada anterior na posi√ß√£o atual.  Na primeira chamada, chegamos ao ramo <code>else</code> , onde chamamos repetidamente a fun√ß√£o decorada <code>expr()</code> .  Obviamente, voltaremos ao decorador primeiro, mas desta vez j√° existe algum valor no cache, portanto a recurs√£o √© interrompida. </p><br><p>  O que acontece depois?  O valor inicial do cache √© calculado nesta linha: </p><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># Prime the cache with a failure. memo[key] = lastres, lastpos = None, pos</span></span></code> </pre> <br><p>  Isso leva ao fato de que <code>expr()</code> decorado retorna <code>None</code> , ap√≥s o qual o primeiro <code>if</code> em <code>expr()</code> cai (quando <code>expr: = self.expr()</code> ).  Ou seja, passamos para o segundo <code>if</code> , que reconhece com sucesso o <code>term</code> (em nosso exemplo, <code>'foo'</code> ) e <code>expr</code> retorna uma inst√¢ncia de <code>Node</code> .  De onde estamos voltando?  Para o <code>while</code> no decorador.  Atualizamos o cache de memoriza√ß√£o com um novo resultado (a inst√¢ncia do <code>Node</code> ) e, em seguida, executamos a pr√≥xima itera√ß√£o. </p><br><p>  <code>expr()</code> √© chamado novamente e, desta vez, a chamada recursiva interceptada retorna a inst√¢ncia em cache do <code>Node</code> (term) e prossegue para a chamada em <code>expect('+')</code> .  Est√° tudo em ordem, pois agora estamos no primeiro operador <code>'+'</code> .  Depois disso, procuramos um termo que tamb√©m seja bem-sucedido (encontrado <code>'bar'</code> ). </p><br><p>  Portanto, agora <code>expr()</code> , j√° tendo reconhecido <code>foo + bar</code> , retorna <code>while</code> , que executa as mesmas a√ß√µes: atualiza o cache de memoriza√ß√£o com um novo resultado (mais longo) e inicia a pr√≥xima itera√ß√£o. </p><br><p>  Este jogo √© repetido novamente.  Novamente, a chamada recursiva interceptada <code>expr()</code> recupera um novo resultado (desta vez <code>foo + bar</code> ) do cache, e esperamos ver outro <code>'+'</code> (segundo) e outro <code>term</code> ( <code>'baz'</code> ).  Criamos um <code>Node</code> representa <code>(foo + bar) + baz</code> e o retornamos <code>while</code> , que o coloca no cache e se repete novamente. </p><br><p>  Mas agora vamos seguir outro ramo do algoritmo.  Esperamos encontrar outro <code>'+'</code> , mas n√£o o encontramos!  Portanto, essa chamada para <code>expr()</code> retorna para sua segunda alternativa e retorna apenas <code>term</code> .  Quando isso ocorre antes do <code>while</code> , esse resultado √© mais curto que o anterior.  Portanto, ele interrompe e retorna um resultado mais longo ( <code>(foo + bar) + baz</code> ) para quem iniciou a chamada <code>expr()</code> (por exemplo, a chamada de <code>statement()</code> n√£o √© mostrada aqui). </p><br><p>  Portanto, √© aqui que a hist√≥ria de hoje termina: implementamos com sucesso a recurs√£o esquerda em um analisador PEG.  Na pr√≥xima semana, pretendo discutir a adi√ß√£o de ‚Äúa√ß√µes‚Äù √† gram√°tica, o que nos permitir√° personalizar o resultado retornado pelo m√©todo analisador para essa alternativa (em vez de sempre retornar uma inst√¢ncia do <code>Node</code> ). </p><br><p>  Se voc√™ quiser brincar com o c√≥digo, confira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o reposit√≥rio do GitHub</a> .  Tamb√©m adicionei um c√≥digo de visualiza√ß√£o para recurs√£o √† esquerda, mas n√£o estou muito satisfeito com isso, ent√£o n√£o fornecerei um link para ele aqui. </p><br><p>  Licen√ßa para este artigo e c√≥digo citado: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471986/">https://habr.com/ru/post/pt471986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471974/index.html">Como dois capit√£es se tornaram generais: branco e vermelho</a></li>
<li><a href="../pt471976/index.html">Como um especialista em TI consegue um emprego no exterior?</a></li>
<li><a href="../pt471978/index.html">N√£o podemos confiar nos sistemas de IA constru√≠dos apenas com aprendizado profundo</a></li>
<li><a href="../pt471980/index.html">Golpistas por telefone. Ato Quatro, Final ...</a></li>
<li><a href="../pt471982/index.html">Discutindo o futuro do PHP</a></li>
<li><a href="../pt471988/index.html">Adicionando a√ß√µes √† gram√°tica PEG</a></li>
<li><a href="../pt471990/index.html">Meta gram√°tica para analisador PEG</a></li>
<li><a href="../pt471992/index.html">Implementando os recursos restantes do PEG</a></li>
<li><a href="../pt471994/index.html">Trabalhar no PEG no Core Developer Sprint</a></li>
<li><a href="../pt471998/index.html">F # 10: Listas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>