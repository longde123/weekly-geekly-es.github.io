<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏿 🐗 💨 Curso MIT "Segurança de sistemas de computadores". Palestra 4: “Compartilhando Privilégios”, Parte 3 🏮 🕝 👩🏼‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nº 6.858. "Segurança de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Segurança de sistemas de computadores". Palestra 4: “Compartilhando Privilégios”, Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418211/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nº 6.858.  "Segurança de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security é um curso sobre o desenvolvimento e implementação de sistemas de computador seguros.  As palestras abrangem modelos de ameaças, ataques que comprometem a segurança e técnicas de segurança baseadas em trabalhos científicos recentes.  Os tópicos incluem segurança do sistema operacional (SO), recursos, gerenciamento de fluxo de informações, segurança de idiomas, protocolos de rede, segurança de hardware e segurança de aplicativos da web. <br><br>  Palestra 1: “Introdução: modelos de ameaças” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: “Controle de ataques de hackers” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: “Estouros de Buffer: Explorações e Proteção” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 4: “Separação de Privilégios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Assim, nosso desenho mostra uma "obra de arte", que seus criadores tentaram proteger contra ameaças.  No caso deles, acho que estavam muito preocupados, porque, ao criar o <b>site de</b> namoro <b>okcupid.com</b> , eles realmente queriam garantir que a reputação dos usuários do site não fosse afetada pela divulgação de dados pessoais.  De uma conversa com um dos desenvolvedores do site que escreveu o artigo sobre isso, sabe-se que eles não foram realmente comprometidos.  Pelo menos, não houve vazamento de dados devido ao uso da arquitetura <b>OKWS</b> e em parte devido ao monitoramento de atividades maliciosas. <br><br>  A razão pela qual as pessoas não dividem seus aplicativos em componentes menores é porque esse processo exige algum esforço.  É necessário selecionar todas as partes do código, definir interfaces claras entre elas e decidir a quais dados cada componente deve ter acesso.  Se você decidir implementar uma nova função, precisará alterar os dados aos quais cada componente do programa tem acesso, para conceder novos privilégios ou selecionar alguns, e assim por diante.  Portanto, este é um processo bastante demorado. <br><br><img src="https://habrastorage.org/webt/th/7c/nb/th7cnbytweb-shrbg6mai4qmhpw.jpeg"><br><br>  Vamos tentar entender como o servidor da web é projetado, e talvez uma maneira de fazer isso seja rastrear como a solicitação http é processada pelo servidor <b>OKWS</b> .  Assim, semelhante ao mostrado na figura anterior, temos um navegador da web que deseja acessar <b>okcupid.com</b> .  Os desenvolvedores do projeto do site imaginaram que teriam um monte de máquinas, mas analisaremos apenas a interface do site em que o <b>OKWS</b> funcionará e outra máquina em segundo plano que armazenará o banco de dados.  Esta segunda máquina usa o <b>MySQL</b> porque é um bom software para muitas tarefas.  Eles querem realmente proteger esses dados porque é realmente difícil acessar um disco ou banco de dados bruto com datagramas brutos. <br><br>  Então, como a solicitação funciona, como a solicitação é processada pelo servidor <b>OKWS</b> ?  Primeiro, ele chega e é processado por um processo chamado <b>okd</b> para o despachante <b>OKWS</b> .  Ele verifica se solicita essa solicitação e, em seguida, faz algumas coisas.  Como você pode precisar registrar essa solicitação primeiro, ela a redireciona para um componente chamado <b>oklogd</b> , após o qual você precisará criar alguns modelos e pode ser necessário criá-los mesmo antes da chegada da solicitação.  E faz outro componente chamado <b>pubd</b> . <br><br><img src="https://habrastorage.org/webt/wq/uz/o0/wquzo0-ivmzrydzbxgj_ckcecsw.jpeg"><br><br>  E, finalmente, há um serviço específico para o qual essa solicitação é enviada; portanto, no <b>okd,</b> há uma tabela do conjunto de serviços que ele suporta.  Presumivelmente, essa solicitação trata de um desses serviços, portanto, após revisar o <b>okd, a</b> solicitação <b>será</b> redirecionada para um processo de serviço <b>svc</b> específico.  Este serviço fará exatamente o que a solicitação exige, por exemplo, inscrever o usuário no boletim informativo ou possibilitar a visualização do diretório de usuários do <b>ocupid</b> , utilizando o banco de dados, etc. <br><br>  E para isso, você provavelmente precisará do serviço para deixar as informações do aplicativo no <b>log do</b> componente <b>oklogd</b> .  E no final do dia, ele deve "conversar" com o banco de dados.  Os criadores do site implementaram esse processo de "comunicação" de maneira um pouco diferente do que normalmente acontece no <b>Apache</b> , onde você simplesmente se comunica com o banco de dados e emite consultas <b>SQL</b> arbitrárias.  Eles criaram esse conceito de proxy de banco de dados, <b>dbproxy</b> , localizado na frente do <b>banco de dados MySQL</b> e aceita solicitações do serviço <b>svc</b> para executá-los.  Penso que esta ilustração mostra basicamente como o <b>OKWS</b> funciona. <br><br><img src="https://habrastorage.org/webt/e1/nb/be/e1nbbexq_wqwyqtsop6vnvlmfd0.jpeg"><br><br>  Há outro componente que inicia tudo isso, chamado <b>okld</b> , e é responsável por iniciar todos os processos na interface deste servidor web.  Espero que algumas dessas coisas lhe pareçam familiares, porque essa é exatamente a arquitetura que foi considerada em laboratório.  Parece que é um bom design.  Você não tinha <b>pubd</b> , <b>logd</b> e <b>dbproxy no LR</b> , mas tinha <b>okd</b> e <b>svc</b> .  Tem dúvidas sobre o <b>OKWS</b> ? <br><br>  <b>Público:</b> entendemos corretamente que o <b>dbproxy</b> não aceita consultas SQL, mas um tipo diferente de consulta? <br><br>  <b>Professor:</b> sim, certo!  Como é essa interface?  Eles não descrevem isso detalhadamente, mas uma coisa que você pode fazer com esse <b>dbproxy</b> é estocar muitos argumentos para modelos de consulta <b>SQL</b> .  Por exemplo, poderia ser um modelo de consulta de pesquisa para seus amigos, selecionando-os por <b>ID</b> . <br><br><img src="https://habrastorage.org/webt/0e/fv/33/0efv33jbe-yuwdw82mwqzxof_xc.jpeg"><br><br>  Suponha que exista um modelo como “selecione <b>^ ID</b> da sua lista de amigos, em que <b>^ ID =“% S ”</b> .  Suponha que você queira encontrar <b>Alice</b> entre seus amigos e enviar uma solicitação <b>S</b> , onde o argumento é <b>"alice"</b> .  Deixe nosso aplicativo, disponível na interface, saber que o <b>dbproxy está</b> pronto para executar três tipos de solicitações em seu nome.  Se você deseja executar a consulta número 1 e seu argumento é <b>"Alice"</b> , ele fornece acesso ao banco de dados. <br><br>  <b>Público-alvo:</b> um usuário externo no nível de um navegador da Web pode enviar essa solicitação ao banco de dados ou tudo se aplica apenas a usuários internos da rede? <br><br>  <b>Professor:</b> sim, talvez.  Então, como isso funciona?  De fato, é estranho que esse banco de dados esteja em uma máquina separada, porque você pode simplesmente se conectar ao banco de dados <b>OKWS</b> ou ao servidor <b>MySQL</b> ?  Então, o que está parando isso? <br><br>  <b>Público:</b> firewall? <br><br>  <b>Professor:</b> sim, provavelmente em algum nível.  Os desenvolvedores não descrevem isso com muitos detalhes, mas provavelmente existe alguma rede interna na segunda máquina, e há uma alternância entre a interface e o banco de dados que não pode ser acessado do mundo exterior.  De fato, ambas as máquinas estão na mesma rede, mas há um firewall <b>Fw</b> que possui certas regras.  Talvez eles só possam ser conectados a esse computador de interface através da porta 80, mas não diretamente ao servidor interno.  Essa é uma das opções de proteção. <br><br><img src="https://habrastorage.org/webt/uu/lq/pt/uulqptu9yvouev1n-gdwegusujc.jpeg"><br><br>  Outro, provavelmente, é que, quando você se conecta a esse <b>proxy do</b> banco de dados <b>dbproxy</b> , precisa fornecer um token ou chave criptográfica de 20 bytes e, se não o fornecer, o <b>dbproxy</b> rejeitará sua conexão.  Portanto, a regra é que você abra uma conexão TCP, envie 20 bytes e, se estiverem errados, a conexão será fechada.  Acho que esse é o significado de um projeto desse sistema. <br><br>  Então, vamos tentar descobrir como esses diferentes processos são isolados aqui.  Como você pode garantir que todos esses componentes não se sobrecarreguem? <br><br>  <b>Público-alvo:</b> direitos de root diferentes e IDs de usuário diferentes? <br><br>  <b>Professor:</b> sim, quase cada um desses componentes funciona como um <b>uid</b> diferente; portanto, aqui, na descrição do sistema, há uma tabela inteira que descreve para cada componente onde ele trabalha e com qual <b>uid</b> .  Então, podemos escrever que o <b>okd</b> tem seu próprio <b>uid</b> , o <b>pubd</b> tem o seu próprio <b>uid</b> e o <b>oklogd</b> também tem o seu próprio <b>uid</b> . <br><br>  <b>Okld</b> funciona como <b>root</b> , o que é um pouco mal sucedido, mas talvez isso não seja um grande problema.  Depois, há um monte de identificadores de usuário atribuídos dinamicamente para cada serviço, por exemplo, ID 51001 etc. <br><br><img src="https://habrastorage.org/webt/hc/bp/bj/hcbpbjjrkwqqhtdun36v3fm7b_s.jpeg"><br><br>  Assim, isso garante que cada serviço não possa interferir nos processos de outros serviços.  <b>O chroot</b> também <b>é</b> amplamente usado aqui, portanto, alguns desses componentes têm direitos <b>chroot</b> em diretórios separados.  Por exemplo, <b>okd</b> e <b>svc</b> são dotados de direitos <b>chroot</b> comuns em alguns diretórios.  Por que você acha que esses dois componentes têm um separado e não é comum com outros componentes <b>chroot</b> ? <br><br>  <b>Público:</b> porque o <b>okd</b> não tem privilégios de root. <br><br>  <b>Professor:</b> sim, mas por que eles não colocam <b>pubd</b> , <b>oklogd</b> e todos os outros no mesmo <b>chroot</b> ? <br><br>  <b>Público-alvo: é</b> possível que, se os serviços precisem compartilhar muitos dados, eles sejam isolados um do outro? <br><br>  <b>Professor:</b> talvez.  Eu acho que eles devem compartilhar alguns dados, mas esses dados não estão nos arquivos, eles são transferidos através de sockets do <b>okd</b> para os serviços.  Mas, de fato, nenhum desses componentes armazena algo interessante no sistema de arquivos. <br><br>  Portanto, não há nada de interessante no diretório <b>chroot</b> , e acho que os <b>funcionários</b> da <b>OKWS</b> simplesmente decidiram reduzir despesas improdutivas para o <b>chroot</b> , como a necessidade de criar uma cópia do diretório.  Talvez eles também quisessem se livrar de algumas despesas gerais de gerenciamento para cada comando <b>chroot</b> .  Mas como não há arquivos reais aqui, tudo está em ordem. <br><br>  A razão pela qual esses caras atribuíram <b>chroot</b> diferente para os componentes do ambiente é por causa de algumas coisas interessantes.  Pode haver modelos, mas aqui, talvez, haja um arquivo de log, portanto eles não desejam que o arquivo de log seja lido acidentalmente e assim por diante. <br><br>  <b>Público-alvo:</b> esses serviços possuem arquivos, por exemplo, como <b>aspx</b> ? <br><br>  <b>Professor:</b> como eles descrevem no artigo, o serviço é um único binário <b>C ++</b> compilado; portanto, não há arquivos adicionais. <br><br>  Existem modelos, mas eles são realmente transmitidos por esse mecanismo estranho: o <b>pubd</b> possui modelos em seu diretório, os exibe em algum pré-computador, formulário inicial no <b>okd</b> e o <b>okd</b> já fornece modelos para todos os serviços através de chamadas <b>RPC</b> .  Assim, eles ficam na memória, mas na verdade são inacessíveis diretamente através do sistema de arquivos.  Esse é um design um tanto paranóico quando eu nem consigo ler os modelos. <br>  Então, qual é o sentido de separar todos esses componentes?  Por que precisamos de um <b>oklogd</b> separado? <br><br>  <b>Público:</b> para eliminar a possibilidade de substituir ou aparar o diário? <br><br>  <b>Professor:</b> sim, então queremos realmente garantir que, se algo der errado, o diário, pelo menos, não seja corrompido.  Portanto, há um arquivo de log separado gravável por este <b>uid</b> e todas as mensagens de log são enviadas como <b>RPC</b> para este serviço de log.  E mesmo que todo o resto esteja arruinado, bem, com exceção do <b>okld</b> , a revista permanecerá ilesa. <br><br>  <b>Público:</b> e se você acidentalmente encontrou uma maneira de ler a revista e não vê o que os outros fizeram com ela? <br><br>  <b>Professor:</b> não, acho que se você " <b>hackear</b> " algum serviço, <b>pubd</b> ou qualquer outra coisa, poderá escrever qualquer coisa no diário.  Portanto, a criação de uma <b>entrada oklogd</b> separada faz sentido.  Na verdade, o <b>oklogd</b> é um processo separado, e não apenas atualizado, anexando arquivos como <b>um arquivo somente anexado</b> .  Portanto, o <b>oklogd</b> não pode adicionar algumas informações adicionais a cada entrada de log, porque se o sistema operacional suportar o arquivo <b>somente anexado</b> , você não saberá que alguém gravou no arquivo quando isso acontecer.  Enquanto o <b>oklogd</b> coloca um registro de data e hora para cada mensagem e permite descobrir qual serviço fez a gravação ou veio do <b>okd</b> .  Portanto, você realmente obtém informações adicionais nesse arquivo de log porque é um serviço separado. <br><br>  E qual é o significado da <b>boa</b> separação e por que ela deveria funcionar com direitos de root?  Eu acho que existem várias razões para isso. <br><br>  Público: se você quiser que mais ninguém aja com privilégios de root, você precisará delegar a função de autenticação de usuário <b>okld</b> . <br><br><img src="https://habrastorage.org/webt/xg/c2/p0/xgc2p0qzezaptmg1jagd1l3koxi.jpeg"><br><br>  <b>Professor:</b> sim.  Alguém tem que configurar tudo isso <b>uid chroot</b> , e você precisa de <b>root</b> para este <b>Unix</b> , então o <b>okld</b> fornece isso.  Essa é uma das razões.  Mais alguma coisa? <br><br>  <b>Público:</b> definição de 80 portas? <br><br>  <b>Professor:</b> sim, claro!  Você precisa ligar a porta 80, que está <b>okld</b> e fornece mais <b>alguma</b> coisa? <br><br>  <b>Público:</b> conclui a abertura do arquivo de log <b>oklogd</b> porque não queremos deixar o <b>oklogd</b> aberto para impedir o acesso ao arquivo de log. <br><br>  <b>Professor:</b> talvez.  Mas não sei se os desenvolvedores realmente fizeram isso porque não examinaram o código-fonte.  Você acha que o <b>okld</b> abre o arquivo de log e o passa <b>oklogd</b> ?  Possivelmente. <br><br>  <b>Público-alvo:</b> caso contrário, um invasor que comprometeu o <b>oklogd</b> pode apagar o log inteiro. <br><br>  <b>Professor:</b> sim, está certo.  Talvez você queira abri-lo no modo de <b>acréscimo</b> e depois passá-lo para <b>oklogd</b> , para ter mais garantias de segurança para o log.  Isso é algo que você não pode fazer sem privilégios de root. <br><br>  Então, tivemos uma pergunta sobre a lição de casa, o que acontecerá quando esse token de 20 bytes for "vazado" para acessar o banco de dados.  Que dano isso pode causar?  Devemos nos preocupar com isso? <br><br>  <b>Público:</b> neste caso, um invasor pode assumir o controle de um serviço específico. <br><br>  <b>Professor:</b> sim, certo, porque agora você pode se conectar e obter todos os modelos de consulta.  Na verdade, parece bastante simples.  Você provavelmente precisará comprometer um desses componentes para poder conectar-se ao banco de dados do servidor primeiro.  Portanto, acho que se você tiver esse token e puder comprometer um desses componentes mostrados na figura, poderá usar todas essas consultas. <br><br>  Agora vamos ver como esse design do <b>OKWS</b> pode ser aprimorado?  Por exemplo, seria possível alocar uma unidade de <b>uid</b> separada para cada usuário, além de alocar uma <b>uid</b> separada para cada serviço.  Aqui, cada serviço, por exemplo, notícias, pesquisa de amigos ou criação de uma conta, possui um <b>ID do usuário</b> separado, mas cada usuário do <b>OKWS</b> não <b>é</b> representado como um <b>UID do Unix</b> .  Na verdade, não há <b>ID do usuário</b> aqui, apenas <b>IDs de</b> serviço estão presentes aqui.  Você acha que precisa ter um <b>uid</b> diferente para cada cliente do <b>OKWS</b> ? <br><br>  <b>Público:</b> neste caso, acontece que, se um usuário "hackear" um serviço, ele poderá acessar todos os dados de outros usuários deste servidor. <br><br>  <b>Professor:</b> sim, está certo! <br><br>  <b>Público:</b> mas se você tivesse, de fato, um serviço separado e um <b>dbproxy</b> separado para cada usuário, seria impossível acessar os dados de outras pessoas. <br><br>  <b>Professor:</b> sim, mas poderia ser um modelo mais forte?  Eu acho que os desenvolvedores <b>do OKWS</b> não dão esse passo por duas razões.  O primeiro é o desempenho.  Se você possui alguns milhões de usuários do site <b>okcupid</b> , vários milhões de processos em execução e alguns milhões de <b>dbproxie</b> , as despesas gerais de desempenho são possíveis.  E isso não permitirá obter o mesmo desempenho que a arquitetura <b>OKWS</b> existente <b>fornece</b> . <br><br>  <b>Público: a</b> descrição <b>da</b> <b>OKWS</b> diz que o desempenho deste sistema é melhor que outros sistemas.  Como isso foi alcançado? <br><br>  <b>Professor:</b> Eu acho que isso ocorre em parte porque eles ajustaram seu design para uma carga de trabalho específica. Além disso, eles escreveram tudo isso em <b>C ++</b> .  Uma alternativa é escrever algumas coisas em <b>PHP</b> , e é provável que você obtenha benefícios nessa frente. <br><br>  Além disso, eles não têm muitos dos recursos que o <b>Apache</b> possui.  Ele tem um design de uso geral, portanto, possui muitos processos de trabalho e os recarrega de tempos em tempos.  Existem muitas conexões <b>TTP</b> que garantem a duração do processo de conexão e mantêm suas atividades.  Também aumenta o número de processos em execução no sistema.  <b>O Apache tornou-se</b> mais universal e pode fazer tudo o que você deseja obter do servidor da Internet, e os <b>funcionários</b> da <b>OKWS estão</b> mais focados em resolver problemas específicos. <br><br>  Mas acho que <b>atualmente</b> existem outros servidores da web que provavelmente podem corresponder <b>ao</b> desempenho do <b>OKWS</b> .  Por exemplo, o <b>Nginx</b> é um servidor da web muito otimizado que você pode executar atualmente.  Se você deseja aplicativos de alto desempenho no lado do servidor, provavelmente deseja que o longo processo seja muito semelhante ao serviço <b>OKWS</b> .  E para que houvesse um mecanismo para uma interface rápida comum de gateway <b>CGI</b> para conectar um programa externo a um servidor da Web ou um tipo de protocolo que pudesse ser usado no servidor para implementar isso, mesmo no <b>Apache</b> ou <b>Nginx</b> .  Portanto, acho que muitas dessas idéias não são exclusivas do <b>OKWS</b> , elas podem ser implementadas em outros servidores da web.  Eles simplesmente mostram que melhorar a segurança não exclui o uso desses "truques".  Eu acho que eles começaram com um esquema semelhante ao <b>Apache</b> , mas pensaram que não seria seguro o suficiente. <br><br>  Portanto, acho que uma das razões pelas quais os criadores do <b>OKWS</b> não quiseram introduzir privilégios separados para os usuários foi uma possível degradação do desempenho. <br><br><img src="https://habrastorage.org/webt/ai/s9/zb/ais9zbrgrmnoslcojxk0jacxdyc.jpeg"><br><br>  Outro motivo é que o modelo de aplicativo completo "gira" em torno de um serviço que tenta acessar os dados de cada usuário, como encontrar amigos no <b>okcupid</b> ou alguém que você possa convidar para uma data.  Como resultado, esse modelo de isolamento do usuário não faz muito sentido, porque, em última análise, deve haver um serviço para o qual você envia uma solicitação e ele examinará todos os outros dados para encontrar uma correspondência para sua solicitação.  Portanto, mesmo se você tiver identificadores de usuário ou algum mecanismo para isolá-los, ainda precisará abrir o acesso ao serviço para cada usuário. <br><br>  Para outros serviços, como o <b>Gmail</b> ou o <b>Dropbox</b> , que são muito mais focados em um usuário específico e não oferecem uma capacidade aberta de compartilhar seus arquivos, o isolamento de usuários pode oferecer mais vantagens.  Por exemplo, no servidor do <b>Dropbox,</b> há um <b>ID</b> do <b>usuário</b> para cada cliente do <b>Dropbox</b> .  E se houver um processo em execução para você e outro para outra pessoa, mesmo usando uma exploração maliciosa, você não poderá se apossar das informações de outras pessoas. <br>  Agora vamos ver se o <b>OKWS realmente</b> conseguiu melhorar a segurança nesse modelo de servidor.  Para avaliar a segurança, você precisa considerar cada componente do sistema e determinar que tipo de ataque poderia prejudicá-lo. <br><br>  Vamos começar com <b>okd</b> .  Pode ser atacado com solicitações via navegador, por exemplo, causando um estouro de buffer.       c++,  ,       - ,   <b>okd</b>  .      ? <br><br><img src="https://habrastorage.org/webt/qz/md/d9/qzmdd9xheqlsc2fpbgs4e5to3_i.jpeg"><br><br> <b>:</b>        ? <br><br> <b>:</b> ,  ,      .   ? <br><br> <b>:</b>       ,  . <br><br> <b>:</b> ,  .  , ,       ,        <b>http</b> ,   ,   ,     .  ,     . <br><br> <b>:</b>           ? <br><br> <b>:</b> ,       .    ,  ,      ,        , ,  <b>match.com</b>    . , ,      <b>OkCupid</b> . , - ?          ? <br><br> <b>:</b> ,    ,      <b>okd</b> .           ,    ? <br><br> <b>:</b> .   , <b>okd</b>     . <br><br> <b>:</b> ,     ? <br><br> <b>:</b> !      ,      , , ,      ,   .      ,   , ,   ,      . , ,   .   «» <b>okd</b> ,     ,     ,         . <br><br> <b>:</b>         DOS-? <br><br> <b>:</b> ,  , , «»       «»  ,   DOS-    -   . <br><br> <b>:</b>       <b>okd</b> ,     ,  … <br><br> <b>:</b> ,  .  ,   , <b>okd</b>    ,         <b>okd</b> ,     .     <b>okd</b> ,           .  ,    <b>okd</b>  ,       ,      ,   ,            . <br><br> <b>:</b>          . <br><br> <b>:</b> ,    .  , <b>okd</b>     .   ,    <b>oklogd</b> ?    ? <br><br> <b>:</b>      . <br><br> <b>:</b> ,          ,             ,   ?       <b>pubd</b> ,  ,     ,  -  . <br><br> <b>:</b> ,    ,   «»  <b>oklogd</b> . <br><br> <b>:</b> ,  .      ,      ,   <b>append-only</b>    ,        . <br><br> <b>:</b> ,      … <br><br> <b>:</b> ,        ,   .          . <br><br>     <b>svc</b> ? ,  ,   .       , ,   <b>okd</b>  <b>oklogd</b>    .         ,  ,        . <br><br>   <b>svc</b>  - -,        ,       ,         .   ,         ,        ,       . <br><br>      <b>okld</b> ?       ,      root.       ? ,       .           <b>dbproxy</b> .    <b>okld</b> ?      «»?    ? <br><br> <b>:</b> ,  -   ? <br><br> <b>:</b> ,       .          ,    ,       . ,        ,  -    ,     , ,     -    .         -     .          root-   . <br><br> <b>:</b> -,    ,     -   <b>dbproxy</b> . <br><br> <b>:</b> ! <br><br> <b>:</b>  ,     ,  ,     <b>RPC</b> ,       ,     ,     ,  ,   !      . <br><br><img src="https://habrastorage.org/webt/qs/cu/x6/qscux6nxwgoo9wqu10wj04npz38.jpeg"><br><br> <b>:</b> ,    .       <b>dbproxy</b> ?  ,            .   ,   «»   ,      <b>dbproxy</b>  - . <br><br> <b>:</b>      ,   <b>svc</b>  … <br><br> <b>:</b> ,  <b>svc</b>   ,     ! <br><br> <b>:</b>  ,    ,     ! <br><br> <b>:</b>  ,  ,      <b>«»</b> ,       … <br><br> <b>:</b>   <b></b>     <b>dbproxy</b> . <br><br> <b>:</b> . ,      <b>dbproxy</b> ,   . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que você entenda o que os privilégios de compartilhamento de aplicativos nos dão. </font><font style="vertical-align: inherit;">E como podemos ver, isso não é perfeito. </font><font style="vertical-align: inherit;">Há muito mais coisas que podem dar errado. </font><font style="vertical-align: inherit;">Mas parece que esta solução é melhor que projetar aplicativos individuais sem privilégios de acesso, onde começamos.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dNl22h1kW1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A versão completa do curso está disponível </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Obrigado por ficar conosco.  Você gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usuários da Habr em um análogo exclusivo de servidores básicos que inventamos para você:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps de US $ 20 ou como dividir o servidor?</a>  (as opções estão disponíveis com RAID1 e RAID10, até 24 núcleos e até 40GB DDR4). <br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente nós temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um prédio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418211/">https://habr.com/ru/post/pt418211/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418201/index.html">Podemos reviver Duck Hunt?</a></li>
<li><a href="../pt418203/index.html">API do GraphQL (CRUD) on Go</a></li>
<li><a href="../pt418205/index.html">Space Language Vol. 2: Bem-vindo, GJ273b</a></li>
<li><a href="../pt418207/index.html">Análise dos laptops para jogos ASUS ROG Strix GL504GS SCAR II e ASUS ROG Strix GL504GM HERO II</a></li>
<li><a href="../pt418209/index.html">Recebemos dados dos contadores Mercury 203.2T na RS-485</a></li>
<li><a href="../pt418213/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 5: “De onde vêm os sistemas de segurança”, parte 1</a></li>
<li><a href="../pt418215/index.html">Curso MIT "Segurança de sistemas de computadores". Aula 5: “De onde vêm os erros do sistema de segurança”, Parte 2</a></li>
<li><a href="../pt418217/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 6: “Oportunidades”, parte 1</a></li>
<li><a href="../pt418219/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 6: Oportunidades, Parte 2</a></li>
<li><a href="../pt418221/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 6: “Oportunidades”, parte 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>