<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ ü•î ‚óΩÔ∏è Tornar o front-end "back-end" novamente üë©üèæ üë®üèº ‚úîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nikolai Ryzhikov prop√¥s sua vers√£o da resposta para a pergunta: por que √© t√£o dif√≠cil desenvolver uma interface com o usu√°rio? No exemplo de seu proje...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tornar o front-end "back-end" novamente</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/421789/">  Nikolai Ryzhikov prop√¥s sua vers√£o da resposta para a pergunta: por que √© t√£o dif√≠cil desenvolver uma interface com o usu√°rio?  No exemplo de seu projeto, ele mostrar√° que o aplicativo no frontend de algumas id√©ias do back-end afeta tanto a redu√ß√£o da complexidade do desenvolvimento quanto a testabilidade do front-end. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XBfi3Q74BnE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  O material foi preparado com base em um relat√≥rio de Nikolai Ryzhikov na confer√™ncia de primavera de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HolyJS 2018 Piter</a> . <br><a name="habracut"></a><br>  Atualmente, Nikolai Ryzhikov est√° trabalhando no setor de Sa√∫de-TI para criar sistemas de informa√ß√£o m√©dica.  Membro da comunidade de programadores funcionais de S√£o Petersburgo FPROG.  Membro ativo da comunidade Online Clojure, membro do padr√£o de troca de informa√ß√µes m√©dicas HL7 FHIR.  Programa h√° 15 anos. <br><br><hr><br>  - Eu sempre fui atormentado pela pergunta: por que a interface gr√°fica do usu√°rio era sempre dif√≠cil de fazer?  Por que isso sempre levantou muitas perguntas? <br><br>  Hoje vou tentar especular se √© poss√≠vel desenvolver efetivamente uma interface de usu√°rio.  Podemos reduzir a complexidade do seu desenvolvimento. <br><br><h3>  O que √© efici√™ncia? </h3><br>  Vamos definir o que √© efici√™ncia.  Do ponto de vista do desenvolvimento de uma interface do usu√°rio, efici√™ncia significa: <br><br><ul><li>  velocidade de desenvolvimento </li><li>  n√∫mero de bugs </li><li>  quantidade de dinheiro gasto ... </li></ul><br>  H√° uma defini√ß√£o muito boa: <br><br><blockquote>  Efici√™ncia est√° fazendo mais com menos </blockquote><br>  Ap√≥s essa determina√ß√£o, voc√™ pode colocar o que quiser - gastando menos tempo, menos esfor√ßo.  Por exemplo, "se voc√™ escrever menos c√≥digo, permita menos erros" e alcance o mesmo objetivo.  Em geral, dedicamos muito esfor√ßo em v√£o.  E a efici√™ncia √© um objetivo bastante alto - livrar-se dessas perdas e fazer apenas o necess√°rio. <br><br><h3>  O que √© complexidade? </h3><br>  Na minha opini√£o, a complexidade √© o principal problema no desenvolvimento. <br><br>  Fred Brooks escreveu um artigo em 1986 chamado Sem bala de prata.  Nele, ele reflete sobre o software.  No hardware, o progresso √© aos trancos e barrancos, e com o software tudo √© muito pior.  A principal quest√£o de Fred Brooks - pode haver uma tecnologia que nos acelere imediatamente por uma ordem de magnitude?  E ele pr√≥prio d√° uma resposta pessimista, afirmando que no software n√£o √© poss√≠vel conseguir isso, explicando sua posi√ß√£o.  Eu recomendo a leitura deste artigo. <br><br>  Um amigo meu disse que a programa√ß√£o da interface do usu√°rio √© um "problema sujo".  Voc√™ n√£o pode sentar uma vez e encontrar a op√ß√£o certa para que o problema seja resolvido para sempre.  Al√©m disso, nos √∫ltimos 10 anos, a complexidade do desenvolvimento aumentou apenas. <br><br><h3>  12 anos atr√°s ... </h3><br>  Come√ßamos a desenvolver um sistema de informa√ß√µes m√©dicas h√° 12 anos.  Primeiro com flash.  Depois, analisamos o que o Gmail come√ßou a fazer.  Gostamos e quer√≠amos mudar para JavaScript com HTML. <br><br>  De fato, est√°vamos muito adiantados.  Demos um dojo e, na verdade, t√≠nhamos tudo igual ao que temos agora.  Havia componentes que eram muito bons em widgets de dojo, havia um sistema de compila√ß√£o modular e requer que o Google Clojure Compiler seja constru√≠do e minificado (RequireJS e CommonJS nem cheiravam). <br><br>  Tudo deu certo.  Olhamos para o Gmail, ficamos inspirados, pensamos que estava tudo bem.  Inicialmente, escrevemos apenas um leitor de cart√£o de paciente.  Depois, eles mudaram gradualmente para a automa√ß√£o de outros fluxos de trabalho no hospital.  E tudo ficou complicado.  A equipe parece ser profissional - mas cada recurso come√ßou a ranger.  Essa sensa√ß√£o apareceu h√° 12 anos - e ainda n√£o me deixa. <br><br><h3>  Caminho dos trilhos + jQuery </h3><br>  Fizemos a certifica√ß√£o do sistema e era necess√°rio escrever um portal do paciente.  Este √© um sistema em que o paciente pode ir e ver seus dados m√©dicos. <br><br>  Nosso back-end foi ent√£o escrito em Ruby on Rails.  Embora a comunidade Ruby on Rails n√£o seja muito grande, ela teve um enorme impacto no setor.  Da sua pequena comunidade apaixonada, todos os seus gerenciadores de pacotes, GitHub, Git, maquiagem autom√°tica etc. vieram. <br><br>  A ess√™ncia do desafio que enfrentamos foi que tivemos que implementar o portal do paciente em duas semanas.  E decidimos tentar a maneira Rails - fazer tudo no servidor.  Uma web t√£o cl√°ssica 2.0.  E eles fizeram - eles realmente fizeram isso em duas semanas. <br><br>  Est√°vamos √† frente de todo o planeta: criamos o SPA, t√≠nhamos uma API REST, mas, por algum motivo, era ineficaz.  Alguns recursos j√° podiam criar unidades, porque somente eles eram capazes de acomodar toda essa complexidade de componentes, o relacionamento do back-end com o front-end.  E quando seguimos o caminho do Rails - um pouco desatualizado por nossos padr√µes, os recursos de repente come√ßaram a rebitar.  O desenvolvedor m√©dio come√ßou a lan√ßar o recurso em alguns dias.  E n√≥s at√© come√ßamos a escrever testes simples. <br><br>  Com base nisso, na verdade ainda tenho uma les√£o: houve perguntas.  Quando passamos do Java para o Rails no back-end, a efici√™ncia do desenvolvimento aumentou cerca de 10 vezes.  Mas quando pontuamos no SPA, a efici√™ncia do desenvolvimento tamb√©m aumentou significativamente.  Como assim? <br><br><h3>  Por que a Web 2.0 foi eficaz? </h3><br>  Vamos come√ßar com outra pergunta: por que fazemos um aplicativo de p√°gina √∫nica, por que acreditamos nele? <br><br>  Eles apenas nos dizem: precisamos fazer isso - e fazemos.  E muito raramente questiona.  A arquitetura REST API e SPA est√° correta?  √â realmente adequado para o caso em que o usamos?  N√≥s n√£o pensamos. <br><br>  Por outro lado, existem excelentes exemplos inversos.  Todo mundo usa o GitHub.  Voc√™ sabia que o GitHub n√£o √© um aplicativo de p√°gina √∫nica?  O GitHub √© um aplicativo "ferrovi√°rio" comum que √© renderizado no servidor e onde existem poucos widgets.  Algu√©m j√° experimentou farinha disso?  Eu acho que tem tr√™s pessoas.  O resto nem percebeu.  Isso n√£o afetou o usu√°rio de nenhuma maneira, mas, ao mesmo tempo, por algum motivo, temos que pagar 10 vezes mais pelo desenvolvimento de outros aplicativos (for√ßa, complexidade etc.).  Outro exemplo √© o Basecamp.  O Twitter j√° foi apenas um aplicativo Rails. <br><br>  De fato, existem muitas aplica√ß√µes Rails.  Isso foi parcialmente determinado pelo g√™nio DHH (David Heinemeier Hansson, criador do Ruby on Rails).  Ele conseguiu criar uma ferramenta focada nos neg√≥cios, que permite fazer imediatamente o que voc√™ precisa, sem se distrair com problemas t√©cnicos. <br><br>  Quando usamos o caminho Rails, √© claro, havia muita magia negra.  √Ä medida que evolu√≠mos gradualmente, mudamos de Ruby para Clojure, praticamente mantendo a mesma efici√™ncia, mas simplificando tudo em uma ordem de magnitude.  E foi maravilhoso. <br><br><h3>  12 anos se passaram </h3><br>  Com o tempo, novas tend√™ncias come√ßaram a aparecer no frontend. <br><br>  Ignoramos completamente o Backbone, porque o aplicativo dojo que escrevemos antes era ainda mais sofisticado do que o que o Backbone oferecia. <br><br>  Ent√£o veio Angular.  Era um "raio de luz" bastante interessante - do ponto de vista da efici√™ncia, Angular √© muito bom.  Voc√™ pega o desenvolvedor m√©dio e ele rebita o recurso.  Mas, do ponto de vista da simplicidade, o Angular traz muitos problemas - √© opaco, complexo, h√° observa√ß√£o, otimiza√ß√£o etc. <br><br>  O React apareceu, o que trouxe um pouco de simplicidade (pelo menos a franqueza da renderiza√ß√£o, que, devido ao DOM virtual, nos permite sempre como redesenhar, entender e escrever.  Mas em termos de efici√™ncia, para ser honesto, o React nos empurrou significativamente de volta. <br><br>  O pior √© que nada mudou em 12 anos.  Ainda estamos fazendo a mesma coisa que ent√£o.  √â hora de pensar - algo est√° errado aqui. <br><br>  Fred Brooks diz que h√° dois problemas com o desenvolvimento de software.  Obviamente, ele v√™ o principal problema da complexidade, mas o divide em dois grupos: <br><br><ul><li>  complexidade significativa que vem da pr√≥pria tarefa.  Simplesmente n√£o pode ser jogado fora, porque faz parte da tarefa. </li><li>  complexidade aleat√≥ria √© a que trazemos tentando resolver esse problema. </li></ul><br>  A quest√£o √©: qual √© o equil√≠brio entre eles.  √â exatamente isso que estamos discutindo agora. <br><br><h3>  Por que √© t√£o doloroso fazer a interface do usu√°rio? </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d22/667/d4e/d22667d4e3249034be27b07250a635ff.png"><br><br>  Parece-me que a primeira raz√£o √© o nosso modelo de aplica√ß√£o mental.  Os componentes de rea√ß√£o s√£o uma abordagem puramente OOP.  Nosso sistema √© um gr√°fico din√¢mico de objetos mut√°veis ‚Äã‚Äãinterconectados.  Tipos completos de Turing geram constantemente n√≥s deste gr√°fico, alguns n√≥s desaparecem.  Voc√™ j√° tentou imaginar sua aplica√ß√£o na sua cabe√ßa?  Isso √© assustador!  Normalmente, apresento um aplicativo OOP como este: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cd/7b4/c7a/7cd7b4c7a846d2e973b012d566945a19.png"><br><br>  Eu recomendo a leitura das teses de Roy Fielding (autor da arquitetura REST).  Sua disserta√ß√£o √© intitulada "Estilos arquitet√¥nicos e design de software baseado em rede".  No in√≠cio, h√° uma introdu√ß√£o muito boa, onde ele fala sobre como chegar √† arquitetura em geral e apresenta os conceitos: divide o sistema em componentes e os relacionamentos entre esses componentes.  Possui uma arquitetura "zero", na qual todos os componentes podem ser potencialmente associados a todos.  Isso √© um caos arquitet√¥nico.  Esta √© a nossa representa√ß√£o de objeto da interface do usu√°rio. <br><br>  Roy Fielding recomenda procurar e impor um conjunto de restri√ß√µes, porque √© um conjunto de restri√ß√µes que define sua arquitetura. <br><br>  Provavelmente a coisa mais importante √© que as restri√ß√µes s√£o amigas do arquiteto.  Procure essas limita√ß√µes reais e crie um sistema a partir delas.  Porque a liberdade √© m√°.  Liberdade significa que voc√™ tem um milh√£o de op√ß√µes dentre as quais pode escolher, e n√£o um crit√©rio √∫nico para determinar se a escolha foi correta.  Procure por restri√ß√µes e desenvolva-as. <br><br>  Existe um excelente artigo chamado OUT OF THE TAR PIT ("Mais f√°cil que um po√ßo de alcatr√£o"), no qual os caras depois de Brooks decidiram analisar o que exatamente contribui para a complexidade do aplicativo.  Eles chegaram √† conclus√£o decepcionante de que um sistema mut√°vel e espalhado pelo estado √© a principal fonte de complexidade.  Aqui √© poss√≠vel explicar de forma puramente combinat√≥ria - se voc√™ tem duas c√©lulas, e em cada uma delas uma bola pode mentir (ou n√£o mentir), quantos estados s√£o poss√≠veis?  Quatro. <br><br>  Se tr√™s c√©lulas - 2 <sup>3</sup> , se 100 c√©lulas - 2 <sup>100</sup> .  Se voc√™ apresentar seu aplicativo e entender quanto estado est√° desfocado, perceber√° que h√° um n√∫mero infinito de estados poss√≠veis do seu sistema.  Se ao mesmo tempo voc√™ n√£o estiver limitado por nada, √© muito dif√≠cil.  E o c√©rebro humano est√° fraco, isso j√° foi comprovado por v√°rios estudos.  Somos capazes de armazenar at√© tr√™s elementos em nossas cabe√ßas ao mesmo tempo.  Alguns dizem sete, mas mesmo para isso o c√©rebro usa um hack.  Portanto, a complexidade √© realmente um problema para n√≥s. <br><br>  Eu recomendo a leitura deste artigo, onde os caras chegam √† conclus√£o de que algo precisa ser feito com esse estado mut√°vel.  Por exemplo, existem bancos de dados relacionais, voc√™ pode remover todo o estado mut√°vel l√°.  E o resto √© feito em um estilo puramente funcional.  E eles apenas t√™m a ideia de uma programa√ß√£o funcional-relacional. <br><br>  Portanto, o problema vem do fato de que: <br><br><ul><li>  Em primeiro lugar, n√£o temos um bom modelo de interface de usu√°rio fixo.  As abordagens componentes nos levam ao inferno existente.  N√£o impomos nenhuma restri√ß√£o, espalhamos o estado mut√°vel; como resultado, a complexidade do sistema em algum momento simplesmente nos esmaga; <br></li><li>  segundo, se estamos escrevendo um aplicativo backend - frontend cl√°ssico, ele j√° √© um sistema distribu√≠do.  E a primeira regra dos sistemas distribu√≠dos √© n√£o criar sistemas distribu√≠dos (Primeira Lei do Design de Objetos Distribu√≠dos: n√£o distribua seus objetos - por Martin Fowler), pois voc√™ aumenta imediatamente a complexidade por uma ordem de magnitude.  Qualquer pessoa que tenha escrito alguma integra√ß√£o entende que, assim que voc√™ entra na intera√ß√£o entre os sistemas, todas as estimativas de projeto podem ser multiplicadas por 10. Mas simplesmente esquecemos disso e passamos para sistemas distribu√≠dos.  Essa foi provavelmente a principal considera√ß√£o quando mudamos para o Rails, retornando todo o controle ao servidor. <br></li></ul><br>  Tudo isso √© muito duro para um c√©rebro humano pobre.  Vamos pensar sobre o que podemos fazer com esses dois problemas - a falta de restri√ß√µes na arquitetura (o gr√°fico de objetos mut√°veis) e a transi√ß√£o para sistemas distribu√≠dos que s√£o t√£o complexos que os acad√™micos ainda est√£o intrigados sobre como faz√™-los corretamente (ao mesmo tempo, n√≥s nos condenamos a esses tormentos nos aplicativos de neg√≥cios mais simples)? <br><br><h3>  Como o back-end evoluiu? </h3><br>  Se escrevermos o back-end no mesmo estilo em que estamos criando a interface do usu√°rio agora, haver√° a mesma "bagun√ßa sangrenta".  Vamos gastar tanto tempo nisso.  Ent√£o, realmente, uma vez tentei fazer.  Ent√£o, gradualmente, come√ßaram a impor restri√ß√µes. <br><br>  A primeira grande inven√ß√£o de back-end √© o banco de dados. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/777/d5a/8aa/777d5a8aa62a6623e0918cdc57abdbee.png"><br><br>  No in√≠cio, no programa, todo o estado pendia inexplicavelmente onde, e era dif√≠cil gerenci√°-lo.  Com o tempo, os desenvolvedores criaram um banco de dados e removeram todo o estado de l√°. <br><br>  A primeira diferen√ßa interessante entre o banco de dados √© que os dados n√£o existem alguns objetos com seu pr√≥prio comportamento, isso √© pura informa√ß√£o.  Existem tabelas ou outras estruturas de dados (por exemplo, JSON).  Eles n√£o t√™m comportamento, e isso tamb√©m √© muito importante.  Porque o comportamento √© uma interpreta√ß√£o da informa√ß√£o e pode haver muitas interpreta√ß√µes.  E os fatos b√°sicos - eles permanecem b√°sicos. <br><br>  Outro ponto importante √© que, nesse banco de dados, temos uma linguagem de consulta como SQL.  Do ponto de vista das limita√ß√µes, na maioria dos casos o SQL n√£o √© uma linguagem completa de Turing, √© mais simples.  Por outro lado, √© declarativo - mais expressivo, porque no SQL voc√™ diz "o que", n√£o "como".  Por exemplo, quando voc√™ combina dois r√≥tulos no SQL, o SQL decide como executar essa opera√ß√£o com efici√™ncia.  Quando voc√™ est√° procurando algo, ele pega um √≠ndice para voc√™.  Voc√™ nunca declara explicitamente isso.  Se voc√™ tentar combinar algo em JavaScript, precisar√° escrever um monte de c√≥digo para isso. <br><br>  Aqui, novamente, √© importante que impusamos restri√ß√µes e agora vamos a essa base atrav√©s de uma linguagem mais simples e expressiva.  Complexidade redistribu√≠da. <br><br>  Depois que o back-end entrou na base, o aplicativo tornou-se sem estado.  Isso leva a efeitos interessantes - agora, por exemplo, podemos n√£o ter medo de atualizar o aplicativo (o estado n√£o fica na camada do aplicativo na mem√≥ria, que desaparecer√° se o aplicativo reiniciar).  Para uma camada de aplicativo, o stateless √© um bom recurso e uma excelente restri√ß√£o.  Coloque se puder.  Al√©m disso, um novo aplicativo pode ser colocado na base antiga, porque fatos e sua interpreta√ß√£o n√£o s√£o coisas relacionadas. <br><br>  Deste ponto de vista, objetos e classes s√£o terr√≠veis porque colam comportamento e informa√ß√£o.  A informa√ß√£o √© mais rica, vive mais.  Bancos de dados e fatos sobrevivem ao c√≥digo escrito em Delphi, Perl ou JavaScript. <br><br>  Quando o back-end chegou a essa arquitetura, tudo se tornou muito mais simples.  A era de ouro da Web 2.0 chegou.  Foi poss√≠vel obter algo do banco de dados, sujeitar os dados a modelos (fun√ß√£o pura) e retornar o HTML-ku, que √© enviado ao navegador. <br><br>  Aprendemos como escrever aplicativos bastante complexos no back-end.  E a maioria dos aplicativos √© escrita nesse estilo.  Mas assim que o back-end d√° um passo para o lado - na incerteza -, os problemas come√ßam novamente. <br><br>  As pessoas come√ßaram a pensar sobre isso e tiveram a id√©ia de jogar fora a OLP e os rituais. <br><br>  O que nossos sistemas realmente fazem?  Eles pegam informa√ß√µes de algum lugar - do usu√°rio, de outro sistema e similares - colocam no banco de dados, transformam, de alguma forma verificam.  A partir da base, eles o retiram com consultas astutas (anal√≠ticas ou sint√©ticas) e o retornam.  Isso √© tudo.  E isso √© importante para entender.  Deste ponto de vista, simula√ß√µes s√£o um conceito muito errado e ruim. <br><br>  Parece-me que, em geral, todo o POO realmente nasceu da interface do usu√°rio.  As pessoas tentaram simular e simular uma interface de usu√°rio.  Eles viram um determinado objeto gr√°fico no monitor e pensaram: seria bom estimul√°-lo em nosso tempo de execu√ß√£o, juntamente com suas propriedades, etc.  Toda essa hist√≥ria est√° intimamente ligada ao POO.  Mas a simula√ß√£o √© a maneira mais direta e ing√™nua de resolver a tarefa.  Coisas interessantes s√£o feitas quando voc√™ se afasta.  Desse ponto de vista, √© mais importante separar as informa√ß√µes do comportamento, livrar-se desses objetos estranhos e tudo ficar√° muito mais f√°cil: o servidor da Web recebe uma string HTTP, retorna uma string de resposta HTTP.  Se voc√™ adicionar uma base √† equa√ß√£o, obt√©m uma fun√ß√£o geralmente pura: o servidor aceita a base e a solicita√ß√£o, retorna uma nova base e resposta (dados inseridos - dados restantes). <br><br>  No caminho dessa simplifica√ß√£o, os funcion√°rios jogaram fora ‚Öî da bagagem acumulada no back-end.  Ele n√£o era necess√°rio, era apenas um ritual.  Ainda n√£o somos um desenvolvedor de jogos - n√£o precisamos que o paciente e o m√©dico vivam em tempo de execu√ß√£o, movam e acompanhem suas coordenadas.  Nosso modelo de informa√ß√£o √© outra coisa.  N√£o pretendemos ser rem√©dios, vendas ou qualquer outra coisa.  Estamos criando algo novo no cruzamento.  Por exemplo, o Uber n√£o simula o comportamento de operadores e m√°quinas - ele introduz um novo modelo de informa√ß√£o.  Em nosso campo, tamb√©m estamos criando algo novo, para que voc√™ possa sentir a liberdade. <br><br>  N√£o √© necess√°rio tentar simular completamente - criar. <br><br><h3>  Clojure = JS-- </h3><br>  √â hora de dizer exatamente como voc√™ pode jogar tudo fora.  E aqui eu quero mencionar Clojure Script.  De fato, se voc√™ conhece JavaScript, conhece Clojure.  No Clojure, n√£o adicionamos recursos ao JavaScript, mas os removemos. <br><br><ul><li>  Jogamos fora a sintaxe - no Clojure (no Lisp) n√£o h√° sintaxe.  Em uma linguagem comum, escrevemos algum c√≥digo, que √© ent√£o analisado e um AST √© obtido, que √© compilado e executado.  No Lisp, escrevemos imediatamente um AST que pode ser executado - interpretado ou compilado. <br></li><li>  Jogamos fora a mutabilidade.  N√£o h√° objetos ou matrizes mut√°veis ‚Äã‚Äãno Clojure.  Cada opera√ß√£o gera como se uma nova c√≥pia.  Al√©m disso, esta c√≥pia √© muito barata.  Isso √© t√£o inteligentemente feito para ser barato.  E isso nos permite trabalhar, como na matem√°tica, com valores.  N√£o estamos mudando nada - estamos criando algo novo.  Seguro, f√°cil. <br></li><li>  Damos aulas, jogos com prot√≥tipos, etc.  Isso simplesmente n√£o est√° l√°. </li></ul><br>  Como resultado, ainda temos fun√ß√µes e estruturas de dados sobre as quais operamos, al√©m de primitivas.  Aqui est√° o Clojure inteiro.  E, nele, voc√™ pode fazer o mesmo em outras l√≠nguas, onde existem muitas ferramentas extras que ningu√©m sabe usar. <br><br><h4>  Exemplos </h4><br>  Como chegamos ao Lisp atrav√©s do AST?  Aqui est√° uma express√£o cl√°ssica: <br><br><pre><code class="hljs lisp">(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Se tentarmos escrever seu AST, por exemplo, na forma de uma matriz, em que a cabe√ßa √© o tipo de n√≥ e o pr√≥ximo par√¢metro √© um par√¢metro, obteremos algo semelhante (estamos tentando escrever isso em Java Script): <br><br><pre> <code class="hljs json">['minus', ['plus', <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre><br>  Agora jogue fora as aspas extras, podemos substituir o sinal de menos por <code>-</code> e o sinal de mais por <code>+</code> .  Jogue fora as v√≠rgulas que est√£o em branco no Lisp.  Obteremos o mesmo AST: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  E no Lisp, todos escrevemos assim.  Podemos verificar - esta √© uma fun√ß√£o matem√°tica pura (meu emacs est√° conectado ao navegador; eu largo o script l√°, ele avalia o comando e o envia de volta para o emacs - voc√™ v√™ o valor ap√≥s o s√≠mbolo <code>=&gt;</code> ): <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">-</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Tamb√©m podemos declarar uma fun√ß√£o: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> xplus [ab] (<span class="hljs-name"><span class="hljs-name">+</span></span> ab)) ((<span class="hljs-name"><span class="hljs-name">fn</span></span> [xy] (<span class="hljs-name"><span class="hljs-name">*</span></span> xy)) <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Ou uma fun√ß√£o an√¥nima.  Talvez isso pare√ßa um pouco assustador: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">type</span></span> xplus)</code> </pre><br>  O tipo dela √© uma fun√ß√£o JavaScript: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> xplus) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>]</code> </pre><br>  Podemos cham√°-lo passando o par√¢metro: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">xplus</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br>  Ou seja, tudo o que fazemos √© escrever AST, que √© ent√£o compilado em JS ou bytecode ou interpretado. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defn</span></span> mymin [ab] (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">a</span></span> &gt; b) ba))</code> </pre><br>  Clojure √© um idioma hospedado.  Portanto, s√£o necess√°rias primitivas do tempo de execu√ß√£o pai, ou seja, no caso do Clojure Script, teremos tipos JavaScript: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[Number]</code> </pre><br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> "string") =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[String]</code> </pre><br>  Ent√£o, regexp est√° escrito: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> #"^Cl.*$") =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[RegExp]</code> </pre><br>  As fun√ß√µes que temos s√£o fun√ß√µes: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> (fn [x] x)) =&gt; #<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>]</code> </pre><br>  Em seguida, precisamos de algum tipo de tipo composto. <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> user {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"SPb"</span></span>} <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>}] <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>} (<span class="hljs-name"><span class="hljs-name">type</span></span> user)</code> </pre><br>  Isso pode ser lido como se voc√™ estivesse criando um objeto em JavaScript: <br><br><pre> <code class="hljs pgsql">(def <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> {<span class="hljs-type"><span class="hljs-type">name</span></span>: "niquola" ‚Ä¶</code> </pre><br>  No Clojure, isso √© chamado de hashmap.  Este √© um cont√™iner no qual os valores est√£o.  Se colchetes forem usados ‚Äã‚Äã- ent√£o isso √© chamado de vetor - esta √© sua matriz: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> user {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"SPb"</span></span>} <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>}] <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>} =&gt; #'intro/user (<span class="hljs-name"><span class="hljs-name">type</span></span> user)</code> </pre><br>  Registramos qualquer informa√ß√£o com hashmaps e vetores. <br><br>  Nomes de dois pontos estranhos ( <code>:name</code> ) s√£o os chamados caracteres: cadeias constantes criadas para serem usadas como chaves em hashmaps.  Em diferentes idiomas, eles s√£o chamados de formas diferentes - s√≠mbolos, algo mais.  Mas isso pode ser tomado simplesmente como uma cadeia constante.  Eles s√£o bastante eficazes - voc√™ pode escrever nomes longos e n√£o gastar muitos recursos nele, porque eles est√£o conectados (ou seja, n√£o s√£o repetidos). <br><br>  O Clojure fornece centenas de fun√ß√µes para lidar com essas estruturas de dados gen√©ricas e primitivas.  Podemos adicionar, adicionar novas chaves.  Al√©m disso, sempre temos sem√¢ntica de c√≥pia, ou seja, toda vez que obtemos uma nova c√≥pia.  Primeiro, voc√™ precisa se acostumar com isso, porque n√£o poder√° mais salvar algo, como antes, em algum lugar da vari√°vel e depois alterar esse valor.  Seu c√°lculo deve sempre ser direto - todos os argumentos devem ser passados ‚Äã‚Äãpara a fun√ß√£o explicitamente. <br><br>  Isso leva a uma coisa importante.  Nas linguagens funcionais, uma fun√ß√£o √© um componente ideal porque recebe tudo explicitamente na entrada.  Nenhum link oculto diverge no sistema.  Voc√™ pode pegar uma fun√ß√£o de um lugar, transferi-la para outro e us√°-la l√°. <br><br>  No Clojure, temos excelentes opera√ß√µes de igualdade em valor, mesmo para tipos compostos complexos: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">=</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:a</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>}) =&gt; true</code> </pre><br>  E essa opera√ß√£o √© barata devido ao fato de que estruturas imut√°veis ‚Äã‚Äãe astutas podem ser comparadas simplesmente por refer√™ncia.  Portanto, mesmo um hashmap com milh√µes de chaves, podemos comparar em uma opera√ß√£o. <br><br>  A prop√≥sito, os caras do React simplesmente copiaram a implementa√ß√£o do Clojure e criaram o JS imut√°vel. <br><br>  O Clojure tamb√©m possui v√°rias opera√ß√µes, por exemplo, obtendo algo de um caminho aninhado no hashmap: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">get-in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:city</span></span>])</code> </pre><br>  Coloque algo no caminho aninhado no hashmap: <br><br><pre> <code class="hljs ruby">(assoc-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:city</span></span>] <span class="hljs-string"><span class="hljs-string">"LA"</span></span>) =&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"niquola"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:city</span></span> <span class="hljs-string"><span class="hljs-string">"LA"</span></span>}, <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> [{<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"github"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>} {<span class="hljs-symbol"><span class="hljs-symbol">:type</span></span> <span class="hljs-string"><span class="hljs-string">"twitter"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span> <span class="hljs-string"><span class="hljs-string">"https://‚Ä¶.."</span></span>}], <span class="hljs-symbol"><span class="hljs-symbol">:age</span></span> <span class="hljs-number"><span class="hljs-number">37</span></span>}</code> </pre><br>  Atualize algum valor: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">update-in</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:link</span></span>] (<span class="hljs-name"><span class="hljs-name">fn</span></span> [old] (<span class="hljs-name"><span class="hljs-name">str</span></span> old <span class="hljs-string"><span class="hljs-string">"+++++"</span></span>)))</code> </pre><br>  Selecione apenas uma chave espec√≠fica: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">select-keys</span></span> user [<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:address</span></span>])</code> </pre><br>  A mesma coisa com vetor: <br><br><pre> <code class="hljs pgsql">(def clojurists [{:<span class="hljs-type"><span class="hljs-type">name</span></span> "Rich"} {:<span class="hljs-type"><span class="hljs-type">name</span></span> "Micael"}]) (first clojurists) (second clojurists) =&gt; {:<span class="hljs-type"><span class="hljs-type">name</span></span> "Michael"}</code> </pre><br>  Existem centenas de opera√ß√µes da biblioteca base que permitem operar nessas estruturas de dados.  H√° uma interoperabilidade com o host.  Voc√™ precisa se acostumar um pouco com isso: <br><br><pre> <code class="hljs pgsql">(js/alert "Hello!") =&gt; nil &lt;/csource&gt;         "".    <span class="hljs-keyword"><span class="hljs-keyword">location</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>: &lt;source lang="clojure"&gt; (.-<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span>)</code> </pre><br>  H√° todo a√ß√∫car para ir ao longo das correntes: <br><br><pre> <code class="hljs pgsql">(.. js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> -href) =&gt; "http://localhost:3000/#/billing/dashboard"</code> </pre><br><pre> <code class="hljs pgsql">(.. js/<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">location</span></span> -host) =&gt; "localhost:3000"</code> </pre><br>  Posso pegar a data JS e retornar o ano a partir dela: <br><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">let</span></span> [d (<span class="hljs-name"><span class="hljs-name">js/Date</span></span>.)] (.getFullYear d)) =&gt; <span class="hljs-number"><span class="hljs-number">2018</span></span></code> </pre><br>  Rich Hickey, o criador de Clojure, nos limitou severamente.  Realmente n√£o temos mais nada, ent√£o fazemos tudo por meio de estruturas de dados gen√©ricas.  Por exemplo, quando escrevemos SQL, geralmente escrevemos com uma estrutura de dados.  Se voc√™ olhar com cuidado, ver√° que este √© apenas um hashmap no qual algo est√° incorporado.  Depois, h√° alguma fun√ß√£o que traduz tudo isso em uma string SQL: <br><br><pre> <code class="hljs ruby">{select [<span class="hljs-symbol"><span class="hljs-symbol">:*</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>] <span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-symbol"><span class="hljs-symbol">:id</span></span> <span class="hljs-string"><span class="hljs-string">"user-1"</span></span>]} =&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:select</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:*</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">:from</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>], <span class="hljs-symbol"><span class="hljs-symbol">:where</span></span> [<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>= <span class="hljs-symbol"><span class="hljs-symbol">:id</span></span> <span class="hljs-string"><span class="hljs-string">"user-1"</span></span>]}</code> </pre><br>  Tamb√©m escrevemos roteiros com uma estrutura de dados e estruturas de dados tipogr√°ficas: <br><br><pre> <code class="hljs ruby">{<span class="hljs-string"><span class="hljs-string">"users"</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:get</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:handler</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:users-list</span></span>}} <span class="hljs-symbol"><span class="hljs-symbol">:get</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:handler</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:welcome-page</span></span>}}</code> </pre><br><pre> <code class="hljs json">[:div.row [:div {:on-click #(.log js/console <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>)} <span class="hljs-string"><span class="hljs-string">"User "</span></span>]]</code> </pre><br><h3>  DB na interface do usu√°rio </h3><br>  Ent√£o, discutimos o Clojure.  Mas mencionei anteriormente que uma grande conquista no back-end foi o banco de dados.  Se voc√™ observar o que est√° acontecendo no front-end agora, veremos que os caras usam o mesmo padr√£o - eles entram no banco de dados na Interface do Usu√°rio (em um aplicativo de p√°gina √∫nica). <br><br>  Os bancos de dados s√£o introduzidos na arquitetura elm, no re-frame com script Clojure e at√© de alguma forma limitada no fluxo e no redux (plugins adicionais devem ser configurados aqui para gerar solicita√ß√µes).  A arquitetura, a estrutura e o fluxo do olmo foram lan√ßados na mesma √©poca e emprestados um do outro.  Escrevemos no re-frame.  A seguir, falarei um pouco sobre como isso funciona. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ff/11e/ddf/8ff11eddf7c9e2eb3254a3d9eee47d3d.png"><br><br>  O evento (√© um pouco como redux) sai do view-chi, que √© capturado por um determinado controlador.  O controlador que chamamos de manipulador de eventos.  O manipulador de eventos emite um efeito, que tamb√©m √© algu√©m interpretado pela estrutura de dados. <br><br>  Um tipo de efeito est√° atualizando o banco de dados.  Ou seja, ele pega o valor atual do banco de dados e retorna um novo.  Tamb√©m temos assinatura - um an√°logo de solicita√ß√µes no back-end.  Ou seja, essas s√£o algumas consultas reativas que podemos lan√ßar nesse banco de dados.  Esses pedidos reativos, subseq√ºentemente agrupamos a vis√£o.  No caso de reagir, parecemos redesenhar completamente e, se o resultado dessa solicita√ß√£o foi alterado - isso √© conveniente. <br>  O React est√° presente conosco apenas em algum lugar no final e, em geral, a arquitetura n√£o est√° de forma alguma conectada a ela.  Parece algo como isto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42b/655/922/42b65592288ba93676e13b086f3f48b7.png"><br><br>  Aqui √© adicionado o que est√° faltando, por exemplo, no redux-s. <br><br>  Primeiro, separamos os efeitos.  O aplicativo de front-end n√£o √© aut√¥nomo.  Ele tem um certo back-end - um tipo, "fonte de verdade".  O aplicativo deve escrever constantemente algo l√° e ler algo a partir da√≠.  Pior ainda, se ele tem v√°rios back-ends que deveriam ir.  Na implementa√ß√£o mais simples, isso pode ser feito diretamente no criador de a√ß√µes - no seu controlador, mas isso √© ruim.  Portanto, o pessoal da nova estrutura introduz um n√≠vel adicional de indire√ß√£o: uma certa estrutura de dados sai do controlador, que diz o que precisa ser feito.  E este post tem seu pr√≥prio manipulador que faz o trabalho sujo.  Esta √© uma introdu√ß√£o muito importante, que discutiremos um pouco mais tarde. <br><br>  Tamb√©m √© importante (√†s vezes eles esquecem disso) - alguns fatos b√°sicos devem estar na base.  Tudo o mais pode ser removido do banco de dados - e as consultas geralmente fazem isso, eles transformam os dados - eles n√£o adicionam novas informa√ß√µes, mas estruturam corretamente as existentes.  Precisamos dessa consulta.  No redux, na minha opini√£o, isso agora fornece nova sele√ß√£o e, no re-frame, n√≥s o tiramos da caixa (embutido). <br><br>  D√™ uma olhada no nosso diagrama de arquitetura.  Reproduzimos um pequeno back-end (no estilo da Web 2.0) com uma visualiza√ß√£o b√°sica, controladora.  A √∫nica coisa adicionada √© a reatividade.  Isso √© muito semelhante ao MVC, exceto que tudo est√° em um s√≥ lugar.  Uma vez os MVCs iniciais de cada widget criaram seu pr√≥prio modelo, mas aqui tudo √© dobrado em uma base.  Em princ√≠pio, voc√™ pode sincronizar com o back-end do controlador por meio do efeito, pode criar uma apar√™ncia mais gen√©rica para que o banco de dados funcione como um proxy para o back-end.  Existe at√© algum tipo de algoritmo gen√©rico: voc√™ escreve no banco de dados local e ele sincroniza com o principal. <br><br>  Agora, na maioria dos casos, a base √© apenas algum tipo de objeto no qual escrevemos algo em redux.  Mas, em princ√≠pio, pode-se imaginar que ele se tornar√° um banco de dados completo com uma rica linguagem de consulta.  Talvez com algum tipo de sincroniza√ß√£o gen√©rica.  Por exemplo, existe o datomic - um banco de dados l√≥gico de armazenamento triplo que √© executado diretamente no navegador.  Voc√™ pega e coloca todo o seu estado l√°.  O Datomic possui uma linguagem de consulta bastante rica, compar√°vel em poder ao SQL e at√© mesmo ganhando em algum lugar.  Outro exemplo √© o Google escreveu lovefield.  Tudo vai se mover em algum lugar l√°. <br><br>  A seguir, explicarei por que precisamos de uma assinatura reativa. <br><br>  Agora temos a primeira percep√ß√£o ing√™nua - pegamos o usu√°rio do back-end, colocamos no banco de dados e precisamos desenh√°-lo.  No momento da renderiza√ß√£o, muita l√≥gica acontece, mas n√≥s a misturamos com a renderiza√ß√£o, com a visualiza√ß√£o.  Se come√ßarmos imediatamente a renderizar esse usu√°rio, obteremos uma grande pe√ßa complicada que faz algo com o Virtual DOM e outra coisa.  E √© misturado com o modelo l√≥gico de nossa vis√£o. <br><br>  Um conceito muito importante que precisa ser entendido: devido √† complexidade da interface do usu√°rio, ele tamb√©m precisa ser modelado.  √â necess√°rio separar como ele √© desenhado (como parece) do seu modelo l√≥gico.  Ent√£o o modelo l√≥gico ficar√° mais est√°vel.  Voc√™ n√£o pode sobrecarreg√°-lo com depend√™ncia de uma estrutura espec√≠fica - Angular, React ou VueJS.  Um modelo √© o cidad√£o de primeira classe usual em seu tempo de execu√ß√£o.  Idealmente, se houver apenas alguns dados e um conjunto de fun√ß√µes acima dele. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7b/52f/9c3/c7b52f9c3c048a91276c3ae8dcd33771.png"><br><br>  Ou seja, a partir do modelo de back-end (objeto), podemos obter um modelo de visualiza√ß√£o no qual, sem usar nenhuma renderiza√ß√£o ainda, podemos recriar o modelo l√≥gico.  Se houver algum tipo de menu ou algo semelhante - tudo isso pode ser feito no modelo de exibi√ß√£o. <br><br><h3>  Porque </h3><br>  Por que todos n√≥s estamos fazendo isso? <br><br>  Vi bons testes de interface do usu√°rio apenas onde h√° uma equipe de 10 testadores. <br>  Geralmente n√£o h√° teste de interface do usu√°rio.  Portanto, estamos tentando tirar essa l√≥gica dos componentes no modelo de exibi√ß√£o.  A falta de testes √© um sinal muito ruim, indicando que algo est√° errado l√°, de alguma forma tudo est√° mal estruturado. <br><br>  Por que a interface do usu√°rio √© dif√≠cil de testar?  Por que os funcion√°rios do back-end aprenderam a testar seu c√≥digo, forneceram uma cobertura enorme e realmente ajuda a conviver com o c√≥digo de back-end?  Por que a interface do usu√°rio est√° errada?  Provavelmente, estamos fazendo algo errado.  E tudo o que descrevi acima realmente nos moveu na dire√ß√£o da testabilidade. <br><br><h3>  Como fazemos testes? </h3><br>  Se voc√™ observar atentamente, a parte de nossa arquitetura, que cont√©m o controlador, a assinatura e o banco de dados, nem sequer est√° relacionada ao JS.  Ou seja, esse √© algum tipo de modelo que opera simplesmente em estruturas de dados: n√≥s as adicionamos em algum lugar, de alguma forma transformamos, realizamos a consulta.  Atrav√©s dos efeitos, estamos desconectados da intera√ß√£o com o mundo exterior.  E esta pe√ßa √© totalmente port√°til.  Ele pode ser escrito no chamado cljc - este √© um subconjunto comum entre o Clojure Script e o Clojure, que se comporta da mesma maneira, l√° e ali.  Podemos apenas recortar essa pe√ßa do frontend e coloc√°-lo na JVM - onde o backend mora.  Em seguida, podemos escrever outro efeito na JVM, que atinge diretamente o ponto final - ele puxa o roteador sem nenhuma convers√£o, an√°lise de string http etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b2/b23/d1d/5b2b23d1d90d589a6cff9d99582d416d.png"><br><br>  Como resultado, podemos escrever um teste muito simples - o mesmo teste integral funcional que os caras escrevem no back-end.  Lan√ßamos um determinado evento, que gera um efeito que atinge diretamente o ponto final no back-end.  Ele nos devolve algo, coloca no banco de dados, calcula a assinatura e na assinatura existe uma vis√£o l√≥gica (colocamos a l√≥gica da interface do usu√°rio no m√°ximo).  Afirmamos essa vis√£o. <br><br>  Portanto, podemos testar 80% do c√≥digo no back-end, enquanto todas as ferramentas de desenvolvimento de back-end est√£o dispon√≠veis para n√≥s.  Usando equipamentos ou algumas f√°bricas, podemos recriar uma situa√ß√£o espec√≠fica no banco de dados. <br><br>  Por exemplo, temos um novo paciente ou algo n√£o √© pago, etc.  Podemos passar por v√°rias combina√ß√µes poss√≠veis. <br><br>  Assim, podemos lidar com o segundo problema - com um sistema distribu√≠do.  Como o contrato entre os sistemas √© precisamente o principal ponto dolorido, porque esses s√£o dois tempos de execu√ß√£o diferentes, dois sistemas diferentes: o back-end mudou algo e algo quebrou em nosso front-end (voc√™ n√£o pode ter certeza de que isso n√£o acontecer√°). <br><br><h3>  Demonstra√ß√£o </h3><br>  √â assim que parece na pr√°tica.  Este √© um auxiliar de back-end que limpou a base e escreveu um pequeno mundo nela: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/919/ef0/e23/919ef0e23883707631e051ff6c62acf6.png"><br><br>  Em seguida, lan√ßamos a assinatura: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2a1/bcb/35a/2a1bcb35a77444806d276e859f7aaebb.png"><br><br>  Normalmente, o URL define completamente a p√°gina e algum evento √© lan√ßado - agora voc√™ est√° nessa e em uma p√°gina com um conjunto de par√¢metros.  Aqui entramos em um novo fluxo de trabalho e nossa assinatura retornou: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/956/34e/776/95634e7760690ebbef5ce5bbc51de9d6.png"><br><br>  Nos bastidores, ele foi para a base, conseguiu algo, colocou em nossa base de interface do usu√°rio.  A assinatura funcionou e deduziu do modelo l√≥gico de visualiza√ß√£o. <br><br>  N√≥s o inicializamos.  E aqui est√° o nosso modelo l√≥gico: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d84/ee7/e0a/d84ee7e0a7e22ab8da638d8488df8833.png"><br><br>  Mesmo sem olhar para a interface do usu√°rio, podemos adivinhar o que ser√° desenhado de acordo com este modelo: algum aviso vir√°, algumas informa√ß√µes sobre o paciente, encontros e um conjunto de links permanecer√£o (este √© um widget de fluxo de trabalho que lidera a recep√ß√£o) em certas etapas quando o paciente chega). <br><br>  Aqui chegamos a um mundo mais complexo.  Eles fizeram alguns pagamentos e tamb√©m testaram ap√≥s a inicializa√ß√£o: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/032/f24/4ea032f24871cc57608dddf4687c30d7.png"><br><br>  Se ele j√° pagou pela visita, ver√° isso na interface do usu√°rio: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b8/71a/910/0b871a910ae3741ebd45e2b442f76d9c.png"><br><br>  Execute testes, defina como CI.  A sincroniza√ß√£o entre o back-end e o front-end ser√° garantida por testes, e n√£o honestamente. <br><br><h3>  Voltar para o back-end? </h3><br>  Introduzimos os testes h√° seis meses e gostamos muito.  O problema da l√≥gica turva permanece.  Quanto mais inteligente um aplicativo de neg√≥cios se comportar, mais informa√ß√µes ele precisar√° para algumas etapas.  Se voc√™ tentar executar algum tipo de fluxo de trabalho no mundo real, haver√° depend√™ncias de tudo: para cada interface do usu√°rio, voc√™ precisa obter algo de diferentes partes do banco de dados no back-end.  Se escrevermos sistemas de contabilidade, isso n√£o pode ser evitado.  Como resultado, como eu disse, toda a l√≥gica est√° manchada. <br><br>  Com a ajuda de tais testes, podemos criar a ilus√£o, pelo menos em tempo de desenvolvimento - no momento do desenvolvimento - de que n√≥s, como nos velhos tempos da web 2.0, estamos sentados no servidor em um tempo de execu√ß√£o e tudo √© confort√°vel. <br><br>  Outra id√©ia maluca surgiu (ainda n√£o foi implementada).  Por que n√£o abaixar esta parte para o back-end?  Por que n√£o fugir completamente do aplicativo distribu√≠do agora?  Que essa assinatura e nosso modelo de exibi√ß√£o sejam gerados no back-end?  L√° a base est√° dispon√≠vel, tudo √© s√≠ncrono.  Tudo √© simples e claro. <br><br>  A primeira vantagem que vejo nisso √© que teremos o controle em um s√≥ lugar.  Apenas simplificamos tudo imediatamente em compara√ß√£o com nosso aplicativo distribu√≠do.  Os testes se tornam simples, as valida√ß√µes duplas desaparecem.  O mundo da moda dos sistemas interativos para m√∫ltiplos usu√°rios se abre (se dois usu√°rios seguem a mesma forma, n√≥s falamos sobre isso; eles podem edit√°-lo ao mesmo tempo). <br><br>  Um recurso interessante aparece: indo ao back-end e √† perspectiva da sess√£o, podemos entender quem est√° atualmente no sistema e o que ele est√° fazendo.  √â um pouco como game dev, onde os servidores funcionam assim.  L√°, o mundo vive no servidor, e o front-end √© processado apenas.  Como resultado, podemos obter um determinado thin client. <br><br>  Por outro lado, isso cria um desafio.  Teremos que ter um servidor statefull no qual essas sess√µes residam.  Se tivermos v√°rios servidores de aplicativos, ser√° necess√°rio equilibrar adequadamente a carga ou replicar a sess√£o.  No entanto, h√° uma suspeita de que esse problema seja menor que o n√∫mero de vantagens que obtemos. <br><br>  Portanto, volto ao slogan principal: existem muitos tipos de aplicativos que podem ser gravados e n√£o distribu√≠dos, para eliminar a complexidade deles.  E voc√™ pode obter um aumento m√∫ltiplo de efici√™ncia se revisar novamente os postulados b√°sicos nos quais confiamos no desenvolvimento. <br><br><blockquote>  Se voc√™ gostou do relat√≥rio, preste aten√ß√£o: de 24 a 25 de novembro, um novo <b>HolyJS</b> ser√° realizado em Moscou e tamb√©m haver√° muitas coisas interessantes por l√°.  Informa√ß√µes j√° conhecidas sobre o programa est√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no site</a> e os ingressos podem ser comprados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no site</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt421789/">https://habr.com/ru/post/pt421789/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt421775/index.html">Rede neural treinada para reconhecer a depress√£o atrav√©s do discurso arbitr√°rio de uma pessoa sem contexto</a></li>
<li><a href="../pt421779/index.html">OceanLotus: novo backdoor, esquemas antigos</a></li>
<li><a href="../pt421783/index.html">Estrutura divertida de gerenciamento de estado Huex</a></li>
<li><a href="../pt421785/index.html">A Calif√≥rnia est√° √† beira de uma completa rejei√ß√£o de carbono na produ√ß√£o de energia</a></li>
<li><a href="../pt421787/index.html">Desenvolvimento da arquitetura do projeto, navios e JavaScript</a></li>
<li><a href="../pt421791/index.html">Quest√µes √©ticas da intelig√™ncia artificial</a></li>
<li><a href="../pt421793/index.html">Em busca do melhor ou como escolhemos a rede blockchain para o projeto</a></li>
<li><a href="../pt421795/index.html">Decis√£o baseada em dados sobre o exemplo da escolha de uma cor para pintar paredes</a></li>
<li><a href="../pt421797/index.html">Por que voc√™ precisa do Splunk? Monitorando a infraestrutura de TI</a></li>
<li><a href="../pt421799/index.html">Como conseguir um emprego remotamente em uma empresa que n√£o aceita funcion√°rios remotos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>