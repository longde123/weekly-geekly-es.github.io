<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèº üì∏ üò∏ Inyecci√≥n de fallas: su sistema no es confiable si no ha intentado romperlo üìé üçé üõÄüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Me llamo Pavel Lipsky. Soy ingeniero, trabajo para Sberbank-Technology. Mi especializaci√≥n es probar la tolerancia a fallas y el rendimient...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inyecci√≥n de fallas: su sistema no es confiable si no ha intentado romperlo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/433468/">  Hola Habr!  Me llamo Pavel Lipsky.  Soy ingeniero, trabajo para Sberbank-Technology.  Mi especializaci√≥n es probar la tolerancia a fallas y el rendimiento de los servidores de grandes sistemas distribuidos.  En pocas palabras, rompo los programas de otras personas.  En esta publicaci√≥n hablar√© sobre la inyecci√≥n de fallas, un m√©todo de prueba que le permite encontrar problemas en el sistema creando fallas artificiales.  Comenzar√© con c√≥mo llegu√© a este m√©todo, luego hablaremos sobre el m√©todo en s√≠ y c√≥mo lo usamos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/593/a93/c50593a934415805dac00c5de3a07390.png"></div><a name="habracut"></a><br>  El art√≠culo tendr√° ejemplos de Java.  Si no est√° programando en Java, est√° bien, solo comprenda el enfoque en s√≠ y los principios b√°sicos.  Apache Ignite se usa como la base de datos, pero los mismos enfoques se aplican a cualquier otro DBMS.  Todos los ejemplos se pueden descargar desde mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> . <br><br><h2>  ¬øPor qu√© necesitamos todo esto? </h2><br>  Comenzar√© con la historia.  En 2005, trabaj√© para Rambler.  En ese momento, el n√∫mero de usuarios de Rambler estaba creciendo r√°pidamente, y nuestra arquitectura de dos niveles "servidor - base de datos - servidor - aplicaciones" dej√≥ de funcionar.  Pensamos en c√≥mo resolver problemas de rendimiento y llamamos la atenci√≥n sobre la tecnolog√≠a memcached. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e4e/907/91e/e4e90791ef24ecaba4ec24a941f6e5ce.png" width="600" height="278"><br><br>  ¬øQu√© es memcached?  Memcached: una tabla hash en la memoria de acceso aleatorio con acceso a los objetos almacenados por clave.  Por ejemplo, necesita obtener un perfil de usuario.  La aplicaci√≥n accede a memcached (2).  Si hay un objeto en √©l, se devuelve inmediatamente al usuario.  Si no hay ning√∫n objeto, se hace una apelaci√≥n a la base de datos (3), el objeto se forma y se coloca en memcached (4).  Luego, en la pr√≥xima llamada, ya no necesitamos hacer una llamada costosa de recursos a la base de datos, obtendremos un objeto listo de RAM, memcached. <br><br>  Debido a memcached, descargamos notablemente la base de datos y nuestras aplicaciones comenzaron a funcionar mucho m√°s r√°pido.  Pero, result√≥ que era demasiado temprano para alegrarse.  Junto con una mayor productividad, tenemos nuevos desaf√≠os. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42c/4f9/c03/42c4f9c03bf3a365e19b4cda2dc6562b.png" width="600" height="277"><br><br>  Cuando necesita cambiar los datos, la aplicaci√≥n primero realiza una correcci√≥n en la base de datos (2), crea un nuevo objeto y luego intenta colocarlo en memcached (3).  Es decir, el viejo objeto debe ser reemplazado por uno nuevo.  Imagine que en este momento sucede algo terrible: la conexi√≥n entre la aplicaci√≥n y memcached se rompe, el servidor memcached o incluso la aplicaci√≥n en s√≠ se bloquea.  Entonces, la aplicaci√≥n no pudo actualizar los datos en memcached.  Como resultado, el usuario ir√° a la p√°gina del sitio (por ejemplo, su perfil), ver√° los datos antiguos y no entender√° por qu√© sucedi√≥ esto. <br><br>  ¬øPodr√≠a detectarse este error durante las pruebas funcionales o las pruebas de rendimiento?  Creo que, muy probablemente, no lo encontrar√≠amos.  Para buscar tales errores hay un tipo especial de prueba: inyecci√≥n de fallas. <br><br>  Por lo general, durante la prueba de inyecci√≥n de fallas, hay errores que popularmente se llaman <i>flotantes</i> .  Aparecen bajo carga, cuando m√°s de un usuario est√° trabajando en el sistema, cuando ocurren situaciones anormales: mal funcionamiento del equipo, corte de electricidad, mal funcionamiento de la red, etc. <br><br><h2>  Nuevo sistema inform√°tico de Sberbank </h2><br>  Hace unos a√±os, Sberbank comenz√≥ a construir un nuevo sistema de TI.  Por qu√©  Aqu√≠ est√°n las estad√≠sticas del sitio web del Banco Central: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/32c/1ab/05232c1ab18a23996d9172fcdc05d970.png" width="600" height="229"><br><br>  La parte verde de la columna es el n√∫mero de retiros de efectivo en cajeros autom√°ticos, la parte azul es el n√∫mero de operaciones para pagar bienes y servicios.  Vemos que el n√∫mero de transacciones sin efectivo est√° creciendo de a√±o en a√±o.  En unos pocos a√±os, tendremos que ser capaces de manejar la creciente carga de trabajo y continuar ofreciendo a nuestros clientes nuevos servicios.  Esta es una de las razones para crear un nuevo sistema de TI de Sberbank.  Adem√°s, nos gustar√≠a reducir nuestra dependencia de las tecnolog√≠as occidentales y los mainframes caros, que cuestan millones de d√≥lares, y cambiar a tecnolog√≠as de c√≥digo abierto y servidores de gama baja. <br><br>  Inicialmente, sentamos las bases de la tecnolog√≠a Apache Ignite en el coraz√≥n de la nueva arquitectura Sberbank.  M√°s precisamente, usamos el complemento de pago Gridgain.  La tecnolog√≠a tiene una funcionalidad bastante rica: combina las propiedades de una base de datos relacional (hay soporte para consultas SQL), NoSQL, procesamiento distribuido y almacenamiento de datos en RAM.  Adem√°s, cuando reinicia, los datos que estaban en la RAM no se perder√°n en ninguna parte.  A partir de la versi√≥n 2.1, Apache Ignite ha distribuido Apache Ignite Persistent Data Store con soporte de SQL. <br><br>  Enumerar√© algunas caracter√≠sticas de esta tecnolog√≠a: <br><br><ul><li>  Almacenamiento y procesamiento de datos en RAM <br></li><li>  Almacenamiento en disco <br></li><li>  Soporte SQL <br></li><li>  Ejecuci√≥n distribuida de tareas <br></li><li>  Escala horizontal <br></li></ul><br>  La tecnolog√≠a es relativamente nueva, por lo que requiere atenci√≥n especial. <br><br>  El nuevo sistema de TI de Sberbank consiste f√≠sicamente en muchos servidores relativamente peque√±os ensamblados en un solo cl√∫ster en la nube.  Todos los nodos son id√©nticos en estructura, de igual a igual, realizan la funci√≥n de almacenar y procesar datos. <br><br>  Dentro del grupo se divide en las llamadas c√©lulas.  Una celda es de 8 nodos.  Cada centro de datos tiene 4 nodos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a6/e18/2da/7a6e182daba502a73800093e18e1b4f7.png" width="600" height="343"><br>  Como utilizamos Apache Ignite, la cuadr√≠cula de datos en memoria, entonces, en consecuencia, todo esto se almacena en cach√©s distribuidos por el servidor.  Adem√°s, los cach√©s, a su vez, se dividen en piezas id√©nticas: particiones.  En los servidores, se representan como archivos.  Las particiones del mismo cach√© se pueden almacenar en diferentes servidores.  Para cada partici√≥n en el cl√∫ster, hay nodos primarios y nodos de respaldo. <br><br>  Los nodos principales almacenan las particiones principales y procesan las solicitudes para ellas, replican los datos en los nodos de respaldo (nodo de respaldo), donde se almacenan las particiones de respaldo. <br><br>  Al dise√±ar la nueva arquitectura de Sberbank, llegamos a la conclusi√≥n de que los componentes del sistema pueden fallar.  Supongamos que si tiene un cl√∫ster de 1000 servidores de gama baja de hierro, de vez en cuando experimentar√° fallas de hardware.  Las tiras de RAM, las tarjetas de red y los discos duros, etc. fallar√°n.  Consideraremos que este comportamiento es un comportamiento del sistema completamente normal.  Tales situaciones deben manejarse correctamente y nuestros clientes no deben notarlas. <br><br>  Pero no es suficiente dise√±ar la resistencia del sistema a fallas; es imperativo probar los sistemas durante estas fallas.  Como dice Caitie McCaffrey de Microsoft Research, una conocida investigadora de sistemas distribuidos: "Nunca sabr√° c√≥mo se comporta el sistema durante una falla de contingencia hasta que reproduzca la falla". <br><br><h2>  Actualizaciones perdidas </h2><br>  Tomemos un ejemplo simple, una aplicaci√≥n bancaria que simula transferencias de dinero.  La aplicaci√≥n constar√° de dos partes: el servidor Apache Ignite y el cliente Apache Ignite.  El lado del servidor es un almac√©n de datos. <br><br>  La aplicaci√≥n cliente se conecta al servidor Apache Ignite.  Crea un cach√© donde la clave es la ID de la cuenta y el valor es el objeto de la cuenta.  En total, diez de estos objetos se almacenar√°n en la memoria cach√©.  En este caso, inicialmente pondremos $ 100 en cada cuenta (para que haya algo que transferir).  En consecuencia, el saldo total en todas las cuentas ser√° igual a $ 1,000. <br><br><pre><code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.ATOMIC); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IgniteCache&lt;Integer, Account&gt; cache = ignite.getOrCreateCache(cfg)) {   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= ENTRIES_COUNT; i++)       cache.put(i, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Account(i, <span class="hljs-number"><span class="hljs-number">100</span></span>));   System.out.println(<span class="hljs-string"><span class="hljs-string">"Accounts before transfers"</span></span>);   printAccounts(cache);   printTotalBalance(cache);   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) {       <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pairOfAccounts[] = getPairOfRandomAccounts();       transferMoney(cache, pairOfAccounts[<span class="hljs-number"><span class="hljs-number">0</span></span>], pairOfAccounts[<span class="hljs-number"><span class="hljs-number">1</span></span>]);   } } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IgniteCache&lt;Integer, Account&gt; cache, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{   Account fromAccount = cache.get(fromAccountId);   Account toAccount = cache.get(toAccountId);   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance);   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;   }   fromAccount.withdraw(amount);   toAccount.deposit(amount);   cache.put(fromAccountId, fromAccount);   cache.put(toAccountId, toAccount); }</code> </pre> <br><br>  Luego hacemos 100 transferencias de dinero al azar entre estas 10 cuentas.  Por ejemplo, $ 50 se transfieren de la cuenta A a otra cuenta B.  Esquem√°ticamente, este proceso se puede representar de la siguiente manera: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/526/dc8/626/526dc86262d11f823d0aabce90c2c429.png"><br><br>  El sistema est√° cerrado, las transferencias se realizan solo internamente, es decir  el saldo total debe permanecer igual a $ 1000. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6d/afe/366/f6dafe3664e4f55c07515fde18d0e92e.png" width="600" height="268"><br><br>  Inicia la aplicaci√≥n. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/S8_UMhMwhb0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Obtuvimos el valor esperado del saldo total: $ 1000.  Ahora, vamos a complicar un poco nuestra aplicaci√≥n, hag√°mosla multitarea.  En realidad, varias aplicaciones cliente pueden funcionar simult√°neamente con la misma cuenta.  Ejecute dos tareas que simult√°neamente har√°n transferencias de dinero entre diez cuentas. <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.ATOMIC); cfg.setCacheMode(CacheMode.PARTITIONED); cfg.setIndexedTypes(Integer.class, Account.class); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IgniteCache&lt;Integer, Account&gt; cache = ignite.getOrCreateCache(cfg)) {  <span class="hljs-comment"><span class="hljs-comment">// Initializing the cache.  for (int i = 1; i &lt;= ENTRIES_COUNT; i++)    cache.put(i, new Account(i, 100));  System.out.println("Accounts before transfers");  System.out.println();  printAccounts(cache);  printTotalBalance(cache);  IgniteRunnable run1 = new MyIgniteRunnable(cache, ignite,1);  IgniteRunnable run2 = new MyIgniteRunnable(cache, ignite,2);  List&lt;IgniteRunnable&gt; arr = Arrays.asList(run1, run2);  ignite.compute().run(arr); } ... private void transferMoney(int fromAccountId, int toAccountId) {  Account fromAccount = cache.get(fromAccountId);  Account toAccount = cache.get(toAccountId);  int amount = getRandomAmount(fromAccount.balance);  if (amount &lt; 1) {      return;  }  int fromAccountBalanceBeforeTransfer = fromAccount.balance;  int toAccountBalanceBeforeTransfer = toAccount.balance;  fromAccount.withdraw(amount);  toAccount.deposit(amount);  cache.put(fromAccountId, fromAccount);  cache.put(toAccountId, toAccount); }</span></span></code> </pre><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3RPeJlYNDFg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  El saldo total es de $ 1296.  Los clientes se alegran, el banco sufre p√©rdidas.  ¬øPor qu√© sucedi√≥ esto? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed1/636/2fd/ed16362fd78ed83f0ecb703941eb2596.png"><br><br>  Aqu√≠ vemos c√≥mo dos tareas cambian simult√°neamente el estado de la cuenta A. Pero la segunda tarea logra registrar sus cambios antes que la primera.  Luego, la primera tarea registra sus cambios, y todos los cambios realizados por la segunda tarea desaparecen inmediatamente.  Esta anomal√≠a se llama el problema de las actualizaciones perdidas. <br><br>  Para que la aplicaci√≥n funcione como deber√≠a, nuestra base de datos debe admitir transacciones ACID y nuestro c√≥digo debe tener esto en cuenta. <br><br>  Echemos un vistazo a las propiedades ACID de nuestra aplicaci√≥n para comprender por qu√© esto es tan importante. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/210/b47/f2f210b470dc23068ac49e0b68b54de3.png" width="315" height="315"><br><br><ul><li>  <i>A - Atomicidad, atomicidad.</i>  O todos los cambios propuestos se realizar√°n en la base de datos o no se har√° nada.  Es decir, si tuvimos una falla entre los pasos 3 y 6, los cambios no deber√≠an estar en la base de datos <br></li><li>  <i>C - Consistencia, Integridad.</i>  Una vez completada la transacci√≥n, la base de datos debe permanecer en un estado coherente.  En nuestro ejemplo, esto significa que la suma de A y B siempre debe ser la misma, el saldo total es de $ 1000. <br></li><li>  <i>I - Aislamiento, aislamiento.</i>  Las transacciones no deber√≠an afectarse entre s√≠.  Si una transacci√≥n realiza una transferencia y la otra recibe el valor de la cuenta A y B despu√©s del paso 3 y hasta el paso 6, cree que el sistema tiene menos dinero del necesario.  Aqu√≠ hay matices en los que me centrar√© m√°s adelante. <br></li><li>  <i>D - Durabilidad</i>  Una vez que la transacci√≥n ha realizado cambios en la base de datos, estos cambios no deben perderse como resultado de fallas. <br></li></ul><br>  Entonces, en el m√©todo transferMoney, haremos una transferencia de dinero dentro de la transacci√≥n. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart()) {      Account fromAccount = cache.get(fromAccountId);      Account toAccount = cache.get(toAccountId);      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance);      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;      }      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fromAccountBalanceBeforeTransfer = fromAccount.balance;      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> toAccountBalanceBeforeTransfer = toAccount.balance;          fromAccount.withdraw(amount);      toAccount.deposit(amount);          cache.put(fromAccountId, fromAccount);      cache.put(toAccountId, toAccount);          tx.commit();  } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){      e.printStackTrace();  } }</code> </pre><br>  Inicia la aplicaci√≥n. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/pEgyqAUAvM8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hm.  Las transacciones no ayudaron.  ¬°El saldo total es de $ 6951!  ¬øCu√°l es el problema con el comportamiento de esta aplicaci√≥n? <br><br>  Primero, eligieron el tipo de cach√© ATOMIC, es decir  sin soporte de transacciones ACID: <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.TOMIC);</code> </pre> <br>  En segundo lugar, el m√©todo txStart tiene dos par√°metros importantes del tipo de enumeraci√≥n que ser√≠a bueno especificar: el m√©todo de bloqueo (modo de concurrencia en Apache Ignite) y el nivel de aislamiento.  Dependiendo de los valores de estos par√°metros, una transacci√≥n puede leer y escribir datos de diferentes maneras.  En Apache Ignite, estos par√°metros se establecen de la siguiente manera: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart( ,  )) { Account fromAccount = cache.get(fromAccountId); Account toAccount = cache.get(toAccountId); ...  tx.commit(); }</code> </pre><br>  Puede usar PESSIMISTIC (bloqueo pesimista) u OPTIMISTIC (bloqueo optimista) como el valor del par√°metro LOCK METHOD.  Difieren en el instante del bloqueo.  Cuando se utiliza PESSIMISTIC, el bloqueo se impone en la primera lectura / escritura y se mantiene hasta que se confirma la transacci√≥n.  Por ejemplo, cuando una transacci√≥n con un bloqueo pesimista realiza una transferencia de la cuenta A a la cuenta B, otras transacciones no podr√°n leer ni escribir los valores de estas cuentas hasta que se confirme la transacci√≥n que realiza la transferencia.  Est√° claro que si otras transacciones desean acceder a las cuentas A y B, se ven obligadas a esperar a que se complete la transacci√≥n, lo que tiene un impacto negativo en el rendimiento general de la aplicaci√≥n.  El bloqueo optimista no restringe el acceso a los datos para otras transacciones, sin embargo, durante la fase de preparaci√≥n de la transacci√≥n para la confirmaci√≥n (fase de preparaci√≥n, Apache Ignite usa el protocolo 2PC), se realizar√° una verificaci√≥n: ¬øcambiaron los datos con otras transacciones?  Y si se produjeron cambios, la transacci√≥n se cancelar√°.  En t√©rminos de rendimiento, OPTIMISTIC se ejecutar√° m√°s r√°pido, pero es m√°s adecuado para aplicaciones donde no hay competencia con los datos. <br><br>  El par√°metro NIVEL DE AISLAMIENTO determina el grado de aislamiento de las transacciones entre s√≠.  El est√°ndar SQL ANSI / ISO define 4 tipos de aislamiento, y para cada nivel de aislamiento, el mismo escenario de transacci√≥n puede conducir a resultados diferentes. <br><br><ul><li>  READ_UNCOMMITED es el nivel de aislamiento m√°s bajo.  Las transacciones pueden ver datos no comprometidos "sucios". <br></li><li>  READ_COMMITTED: cuando una transacci√≥n ve dentro de s√≠ solo datos confidenciales <br></li><li>  REPEATABLE_READ: significa que si se realiza una lectura dentro de la transacci√≥n, esta lectura debe ser repetible. <br></li><li>  SERIALIZABLE: este nivel supone el grado m√°ximo de aislamiento de la transacci√≥n, como si no hubiera otros usuarios en el sistema.  El resultado de las transacciones paralelas ser√° como si se ejecutaran en orden (en orden).  Pero junto con un alto grado de aislamiento, obtenemos una reducci√≥n en el rendimiento.  Por lo tanto, debe abordar cuidadosamente la elecci√≥n de este nivel de aislamiento. <br></li></ul><br>  Para muchos DBMS modernos (Microsoft SQL Server, PostgreSQL y Oracle), el nivel de aislamiento predeterminado es READ_COMMITTED.  Para nuestro ejemplo, esto ser√≠a fatal, ya que no nos proteger√° de las actualizaciones perdidas.  El resultado ser√° el mismo que si no hubi√©ramos utilizado transacciones en absoluto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/32a/a26/0a6/32aa260a65aa3ad758dbecc220eef231.png"><br><br>  De la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de la transacci√≥n Apache Ignite</a> , es adecuado para nosotros usar una combinaci√≥n del m√©todo de bloqueo y el nivel de aislamiento: <br><br><ul><li>  <b>PESSIMISTIC REPEATABLE_READ</b> : el bloqueo se impone en la primera lectura o escritura de datos y se mantiene hasta que se completa. <br></li><li>  <b>PESSIMISTIC SERIALIZABLE</b> : funciona de forma similar a PESSIMISTIC REPEATABLE_READ <br></li><li>  <b>SERIALIZABLE OPTIMISTA</b> : se <b>recuerda</b> la versi√≥n de los datos obtenidos despu√©s de la primera lectura, y si esta versi√≥n es diferente durante la fase de preparaci√≥n para la confirmaci√≥n (los datos fueron modificados por otra transacci√≥n), la transacci√≥n se cancelar√°.  Probemos esta opci√≥n. <br></li></ul><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transferMoney</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromAccountId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toAccountId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (Transaction tx = ignite.transactions().txStart(OPTIMISTIC, SERIALIZABLE)) { Account fromAccount = cache.get(fromAccountId); Account toAccount = cache.get(toAccountId); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> amount = getRandomAmount(fromAccount.balance); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fromAccountBalanceBeforeTransfer = fromAccount.balance; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> toAccountBalanceBeforeTransfer = toAccount.balance; fromAccount.withdraw(amount); toAccount.deposit(amount); cache.put(fromAccountId, fromAccount); cache.put(toAccountId, toAccount); tx.commit(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e){ e.printStackTrace(); } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/vPZcW7qbvvs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hurra, recibi√≥ $ 1,000, como se esperaba.  En el tercer intento. <br><br><h2>  Prueba bajo carga </h2><br>  Ahora haremos que nuestra prueba sea m√°s realista, probaremos bajo carga.  Y agregue un nodo de servidor adicional.  Existen muchas herramientas para realizar pruebas de estr√©s, en Sberbank utilizamos el Centro de rendimiento de HP.  Esta es una herramienta bastante poderosa, admite m√°s de 50 protocolos, est√° dise√±ada para equipos grandes y cuesta mucho dinero.  Escrib√≠ mi ejemplo en JMeter: es gratis y resuelve nuestro problema al 100%.  No me gustar√≠a volver a escribir el c√≥digo en Java, por lo que utilizar√© el muestreador JSR223. <br><br>  Crearemos un archivo JAR a partir de las clases de nuestra aplicaci√≥n y lo cargaremos en el plan de prueba.  Para crear y llenar el cach√©, ejecute la clase CreateCache.  Despu√©s de inicializar el cach√©, puede ejecutar el script JMeter. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/i7jUnyfz_88" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Todo est√° bien, tengo $ 1,000. <br><br><h2>  Apagado de emergencia del nodo del cl√∫ster </h2><br>  Ahora seremos m√°s destructivos: durante la operaci√≥n del cl√∫ster, bloquearemos uno de los dos nodos del servidor.  A trav√©s de la utilidad Visor, que se incluye con el paquete Gridgain, podemos monitorear el cl√∫ster Apache Ignite y hacer diferentes muestras de datos.  En la pesta√±a SQL Viewer, ejecute una consulta SQL para obtener el saldo general de todas las cuentas. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/phUdYiMrPLg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Que es  553 dolares.  Los clientes est√°n aterrorizados, el banco sufre p√©rdidas de reputaci√≥n.  ¬øQu√© hemos hecho mal esta vez? <br><br>  Resulta que hay tipos de cach√© en Apache Ignite: <br><br><ul><li>  particionado: una o varias copias de seguridad se almacenan dentro del cl√∫ster <br></li><li>  cach√©s replicados: todas las particiones (todas las partes del cach√©) se almacenan en un servidor.  Tales cach√©s son adecuados principalmente para libros de referencia, algo que rara vez cambia y que a menudo se lee. <br></li><li>  local: todo en un nodo <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/032/23e/360/03223e3607e052fe4f0e3f24aca15837.png" width="600" height="344"><br><br>  A menudo cambiaremos nuestros datos, por lo que seleccionaremos un cach√© particionado y le agregaremos una copia de seguridad adicional.  Es decir, tendremos dos copias de los datos: la principal y la de respaldo. <br><br><pre> <code class="java hljs">CacheConfiguration&lt;Integer, Account&gt; cfg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CacheConfiguration&lt;&gt;(CACHE_NAME); cfg.setAtomicityMode(CacheAtomicityMode.TRANSACTIONAL); cfg.setCacheMode(CacheMode.PARTITIONED); cfg.setBackups(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Lanzamos la aplicaci√≥n.  Les recuerdo que antes de las transferencias tenemos $ 1000.  Comenzamos y durante la operaci√≥n "extinguimos" uno de los nodos <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1Y0C9eaTXFk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  En la utilidad Visor, realizamos una consulta SQL para obtener un saldo total de $ 1000.  ¬°Todo sali√≥ genial! <br><br><h2>  Casos de confiabilidad </h2><br>  Hace dos a√±os, est√°bamos comenzando a probar el nuevo sistema de TI de Sberbank.  De alguna manera fuimos a nuestros ingenieros de escolta y les preguntamos: ¬øqu√© podr√≠a romperse en absoluto?  Nos respondieron: ¬°todo puede romperse, probar todo!  Por supuesto, esta respuesta no nos vino bien.  Nos sentamos juntos, analizamos las estad√≠sticas de fallas y nos dimos cuenta de que el caso m√°s probable que podemos encontrar es una falla de nodo. <br><br>  Adem√°s, esto puede suceder por razones completamente diferentes.  Por ejemplo, una aplicaci√≥n puede bloquearse, un bloqueo de JVM, un bloqueo del sistema operativo o una falla de hardware. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68c/ea2/035/68cea2035db5f01d47e48943a2c8797a.png" width="600" height="197"><br><br>  Dividimos todos los posibles casos de fallas en 4 grupos: <br><br><ol><li>  Equipo <br></li><li>  Red <br></li><li>  Software <br></li><li>  Otros <br></li></ol><br>  Se les ocurrieron pruebas para ellos y los llamaron casos de fiabilidad.  Un caso t√≠pico de confiabilidad consiste en una descripci√≥n del estado del sistema antes de las pruebas, los pasos para reproducir la falla y una descripci√≥n del comportamiento esperado durante la falla. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/201/bc5/484/201bc5484c7811d1a70bb8da502e3ad9.png" width="600" height="313"><br><br><h4>  Casos de fiabilidad: equipamiento </h4><br>  Este grupo incluye casos como: <br><br><ul><li>  Falla de energ√≠a <br></li><li>  P√©rdida completa de acceso al disco duro. <br></li><li>  Fallo de una ruta de acceso al disco duro <br></li><li>  CPU, RAM, disco, carga de red <br></li></ul><br>  El cl√∫ster almacena 4 copias id√©nticas de cada partici√≥n: una partici√≥n primaria y tres particiones de respaldo.  Supongamos que un nodo abandona un cl√∫ster debido a una falla del equipo.  En este caso, las particiones principales deber√≠an moverse a otros nodos supervivientes. <br><br>  ¬øQu√© m√°s podr√≠a pasar?  P√©rdida de estante en la celda. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44d/2b8/132/44d2b81324d9a0d91ee63a5508652456.png" width="600" height="251"><br><br>  Todos los nodos de la celda est√°n en diferentes bastidores.  Es decir  la salida del bastidor no provocar√° fallas del cl√∫ster o p√©rdida de datos.  Tendremos tres copias de cuatro.  Pero incluso si perdemos todo el centro de datos, tampoco ser√° un gran problema para nosotros, porque  Todav√≠a tenemos dos copias m√°s de los datos de cuatro. <br><br>  Algunos casos se llevan a cabo directamente en el centro de datos con la asistencia de ingenieros de soporte.  Por ejemplo, apagar el disco duro, apagar el servidor o el rack. <br><br><h4>  Casos de fiabilidad: red </h4><br>  Para probar casos relacionados con la fragmentaci√≥n de la red, utilizamos iptables.  Y usando la utilidad NetEm emulamos: <br><br><ul><li>  retrasos en la red con diferentes funciones de distribuci√≥n <br></li><li>  p√©rdida de paquetes <br></li><li>  reintento de paquetes <br></li><li>  reordenando paquetes <br></li><li>  distorsi√≥n de paquete <br></li></ul><br>  Otro caso de red interesante que estamos probando es el cerebro dividido.  Esto es cuando todos los nodos del cl√∫ster est√°n vivos, pero debido a la segmentaci√≥n de la red no pueden comunicarse entre s√≠.  El t√©rmino proviene de la medicina y significa que el cerebro est√° dividido en dos hemisferios, cada uno de los cuales se considera √∫nico.  Lo mismo puede suceder con un cl√∫ster. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/778/cc0/58e/778cc058e68e7d552b612f9389af7499.png"><br>  Sucede que entre los centros de datos la conexi√≥n desaparece.  Por ejemplo, el a√±o pasado, debido a da√±os en el cable de fibra √≥ptica por una excavadora, un cliente de los bancos de los bancos Tochka, Otkrytie y Rocketbank no realiz√≥ transacciones por Internet durante varias horas, los terminales no aceptaron tarjetas y los cajeros autom√°ticos no funcionaron.  Mucho se ha escrito sobre este accidente en Twitter. <br><br>  En nuestro caso, la situaci√≥n del cerebro dividido debe manejarse correctamente.  Una cuadr√≠cula identifica un cerebro dividido, que divide un grupo en dos partes.  La mitad entra en modo de lectura.  Esta es la mitad donde hay m√°s nodos vivos o el coordinador est√° ubicado (el nodo m√°s antiguo en el cl√∫ster). <br><br><h4>  Casos de fiabilidad: software </h4><br>  Estos son casos relacionados con la falla de varios subsistemas: <br><br><ul><li>  DPL ORM: m√≥dulo de acceso a datos, como Hibernate ORM <br></li><li>  Transporte intermodular: mensajer√≠a entre m√≥dulos (microservicios) <br></li><li>  Sistema de registro <br></li><li>  Sistema de acceso <br></li><li>  Apache Ignite Cluster <br></li><li>  ... <br></li></ul><br>  Dado que la mayor√≠a del software est√° escrito en Java, somos propensos a todos los problemas inherentes a las aplicaciones Java.  Prueba varias configuraciones del recolector de basura.  Ejecuci√≥n de pruebas con un bloqueo de m√°quina virtual java. <br><br>  Para el cl√∫ster Apache Ignite, hay casos especiales para fuera del mont√≥n: esta es el √°rea de memoria que controla Apache Ignite.  Es mucho m√°s grande que el mont√≥n de Java y est√° dise√±ado para almacenar datos e √≠ndices.  Aqu√≠ puede, por ejemplo, probar el desbordamiento.  Nos desbordamos del mont√≥n y vemos c√≥mo funciona el cl√∫ster cuando algunos de los datos no caben en la RAM, es decir  Leer desde el disco. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d97/cb0/29a/d97cb029adf7075f155c3f68332b3a80.png" width="600" height="374"><br><br><h4>  Otros casos </h4><br>  Estos son casos que no est√°n incluidos en los primeros tres grupos.  Estos incluyen utilidades que permiten la recuperaci√≥n de datos en caso de un accidente grave o cuando los datos se migran a otro cl√∫ster. <br><br><ul><li>  La utilidad para crear instant√°neas (copia de seguridad) de datos: prueba de instant√°neas completas e incrementales. <br></li><li>  Recuperaci√≥n a un punto espec√≠fico en el tiempo: mecanismo PITR (punto de recuperaci√≥n en el tiempo). <br></li></ul><br><h2>  Utilidades para inyecci√≥n de fallas </h2><br>  Recuerdo el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> a ejemplos de mi informe.  Puede descargar la distribuci√≥n de Apache Ignite desde el sitio oficial: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descargas de Apache Ignite</a> .  Y ahora compartir√© las utilidades que utilizamos en Sberbank, si de repente te interesa el tema. <br><br>  Marcos <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jepsen</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mono caos</a> <br></li></ul><br>  Gesti√≥n de configuraci√≥n: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ansible</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Marioneta</a> <br></li></ul><br>  Utilidades de Linux: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NetEm (tc)</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estr√©s</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Iperf</a> <br></li><li>  matar -9 <br></li><li>  iptables <br></li></ul><br>  Herramientas de prueba de carga: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jmeter</a> <br></li></ul><br>  Tanto en el mundo moderno como en Sberbank, todos los cambios son din√°micos y es dif√≠cil predecir qu√© tecnolog√≠as se utilizar√°n en los pr√≥ximos a√±os.  Pero estoy seguro de que utilizaremos el m√©todo de inyecci√≥n de fallas.  El m√©todo es universal: es adecuado para probar cualquier tecnolog√≠a, realmente funciona, ayuda a detectar muchos errores y a mejorar los productos que desarrollamos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433468/">https://habr.com/ru/post/es433468/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433448/index.html">An√°lisis comparativo de mercados usados. Autos alemanes y franceses en el segmento B y C</a></li>
<li><a href="../es433450/index.html">Crece y ense√±a. C√≥mo nos hicimos amigos de PEGA</a></li>
<li><a href="../es433456/index.html">C√≥mo convencer a un cliente o empresa para que use Flutter</a></li>
<li><a href="../es433460/index.html">Simplifique las construcciones de edificios en Unity3D</a></li>
<li><a href="../es433466/index.html">Compara p√°ginas. Complemento simple para Atlassian Confluence</a></li>
<li><a href="../es433472/index.html">Lanzamiento de Unity 2018.3</a></li>
<li><a href="../es433474/index.html">Pylint de adentro hacia afuera. Como lo hace</a></li>
<li><a href="../es433476/index.html">50 tonos de apio</a></li>
<li><a href="../es433478/index.html">Por qu√© Django es elegido en la revista Tinkoff</a></li>
<li><a href="../es433480/index.html">Holivarny historia sobre linter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>