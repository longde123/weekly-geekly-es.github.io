<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-143967986-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-143967986-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùï ‚úäüèº üåé How to make a journalist out of a neural network, or "Secrets of reducing the text on Habr√© without a word" üë©üèæ‚Äç‚öïÔ∏è üòª ü•É</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Just do not be surprised, but the second heading to this post generated a neural network, or rather, the algorithm of sammarization. And what is samma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>How to make a journalist out of a neural network, or "Secrets of reducing the text on Habr√© without a word"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/abbyy/blog/479400/"><img src="https://habrastorage.org/webt/iq/f_/fg/iqf_fgkfyqb1rbtwvba0p4gbsiq.png" align="left">  Just do not be surprised, but the second heading to this post generated a neural network, or rather, the algorithm of sammarization.  And what is sammarization? <br><br>  This is one of the key and classic <a href="https://habr.com/ru/company/abbyy/blog/437008/">challenges of Natural Language Processing (NLP)</a> .  It consists in creating an algorithm that takes text as input and outputs an abridged version of it.  Moreover, the correct structure (corresponding to the norms of the language) is preserved in it and the main idea of ‚Äã‚Äãthe text is correctly transmitted. <br><br>  Such algorithms are widely used in the industry.  For example, they are useful for search engines: using text reduction, you can easily understand whether the main idea of ‚Äã‚Äãa site or document correlates with a search query.  They are used to search for relevant information in a large stream of media data and to filter out information garbage.  Text reduction helps in financial research, in the analysis of legal contracts, annotation of scientific papers and much more.  By the way, the sammarization algorithm generated all the subheadings for this post. <br><br>  To my surprise, on Habr√© there were very few articles about sammarization, so I decided to share my research and results in this direction.  This year I participated in the racetrack at the <a href="http://www.dialog-21.ru/">Dialogue</a> conference and experimented with headline generators for news items and for poems using neural networks.  In this post, I will first briefly go over the theoretical part of sammarization, and then I will give examples with the generation of headings, I will tell you what difficulties models have when reducing the text and how these models can be improved to achieve better headings. <br><a name="habracut"></a><br>  Below is an example of a news item and its original reference headline.  The models I will talk about will train to generate headers with this example: <br><br><img src="https://habrastorage.org/webt/8n/yy/gc/8nyygcx_ymy38dwrqpbqdiylvsu.png" alt="image"><br><br><h2>  Secrets to cutting text seq2seq architecture </h2><br>  There are two types of text reduction methods: <br><br><ol><li>  <b>Extractive</b> .  It consists in finding the most informative parts of the text and constructing from them the annotation correct for the given language.  This group of methods uses only those words that are in the source text. </li><li>  <b>Abstract</b>  It consists in extracting semantic links from the text, while taking into account language dependencies.  With abstract sammarization, annotation words are not selected from the abbreviated text, but from the dictionary (the list of words for a given language) - thereby rephrasing the main idea. </li></ol><br>  The second approach implies that the algorithm should take into account language dependencies, rephrase and generalize.  He also wants to have some knowledge of the real world in order to prevent factual errors.  For a long time, this was considered a difficult task, and researchers could not get a high-quality solution - a grammatically correct text while preserving the main idea.  That is why in the past, most algorithms were based on an extracting approach, since the selection of whole pieces of text and transferring them to the result allows you to maintain the same level of literacy as the source. <br><br>  But this was before the boom of neural networks and its imminent penetration into the NLP.  In 2014, the <b>seq2seq</b> architecture was <b>introduced with an attention mechanism</b> that can read some text sequences and generate others (which depends on what the model learned to output) ( <a href="https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf">article</a> by Sutskever et al.).  In 2016, such an architecture was applied directly to the solution of the problem of sammarization, thereby realizing an abstract approach and obtaining a result comparable to what a competent person could write ( <a href="https://arxiv.org/pdf/1602.06023.pdf">article</a> from Nallapati et al., 2016; <a href="https://arxiv.org/pdf/1509.00685.pdf">article</a> from Rush et al., 2015; )  How does this architecture work? <br><br><img src="https://habrastorage.org/webt/px/4x/wi/px4xwin577dd65z-lahsx7fvexs.png" alt="image"><br><br>  Seq2Seq consists of two parts: <br><br><ol><li>  <b>Encoder</b> (Encoder) - a two-way RNN, which is used to read the input sequence, that is, sequentially processes the input elements simultaneously from left to right and from right to left to better take into account the context. </li><li>  <b>decoder</b> (Decoder) - one-way RNN, which sequentially and element-wise produces an output sequence. </li></ol><br>  First, the input sequence is translated into an embedding sequence (in short, embedding is a concise representation of a word as a vector).  Embeddings then go through the recursive network of the encoder.  So, for each word, we get the encoder's hidden states ( <i>indicated by red rectangles on the diagram</i> ), and they contain information about the token itself and its context, allowing us to take into account the language connections between the words. <br><br>  Having processed the input, the encoder transfers its last hidden state (which contains compressed information about the entire text) to the decoder, which receives a special token <img src="https://habrastorage.org/webt/qn/ud/38/qnud38u15vpvzie4zkne-doze7k.png" alt="image">  and creates the first word of the output sequence ( <i>in the picture it is ‚ÄúGermany‚Äù</i> ).  Then he cyclically takes his previous output, feeds it to himself and again displays the next output element ( <i>so after ‚ÄúGermany‚Äù comes ‚Äúbeat‚Äù, and after ‚Äúbeat‚Äù comes the next word, etc.</i> ).  This is repeated until a special token is issued <img src="https://habrastorage.org/webt/vw/kv/4g/vwkv4gs-ul7vlvnkjwxag8njicw.png" alt="image">  .  This means the end of generation. <br><br>  To display the next element, the decoder, just like the encoder, converts the input token into embedding, takes a step of the recursive network and receives the next hidden state of the decoder ( <i>yellow rectangles in the diagram</i> ).  Then, using a fully connected layer, a probability distribution is obtained for all words from a pre-compiled model dictionary.  The most likely words will be deduced by the model. <br><br>  Adding <b>an attention mechanism</b> helps the decoder make better use of input information.  The mechanism at each step of the generation determines the so-called <b>attention distribution</b> (the <i>blue rectangles in the figure are the set of weights corresponding to the elements of the original sequence, the sum of the weights is 1, all weights&gt; = 0</i> ), and from it it receives the weighted sum of all the hidden states of the encoder, thereby forming context vector ( <i>the diagram shows a red rectangle with a blue stroke</i> ).  This vector concatenates with embedding the decoder input word at the stage of calculating the latent state and with the latent state itself at the stage of determining the next word.  So at each step of the output, the model can determine which encoder states are most important to it at the moment.  In other words, it decides the context of which input words should be taken into account the most (for example, in the picture, displaying the word ‚Äúbeat‚Äù, the attention mechanism gives large weights to the ‚Äúvictorious‚Äù and ‚Äúwin‚Äù tokens, and the rest are close to zero). <br><br>  Since the generation of headers is also one of the tasks of sammarization, only with the minimum possible output (1-12 words), I decided to apply <b>seq2seq with the attention mechanism</b> for our case.  We train such a system on texts with headings, for example, on the news.  Moreover, it is advisable at the training stage to submit to the decoder not his own output, but the words of the real heading (teacher forcing), making life easier for himself and the model.  As an error function, we use the standard cross-entropy loss function, showing how close the probability distributions of the output word and the word from the real header are: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3v/co/b9/3vcob9esvdhgsydjcnjfpzv2wbi.png"></div><br>  When using the trained model, we use ray search to find a more likely sequence of words than using the greedy algorithm.  To do this, at each step of generation, we derive not the most probable word, but at the same time look at beam_size of the most probable sequences of words.  When they end (each one ends on <img src="https://habrastorage.org/webt/vw/kv/4g/vwkv4gs-ul7vlvnkjwxag8njicw.png" alt="image">  ), we derive the most probable sequence. <br><br><img src="https://habrastorage.org/webt/t2/dt/ni/t2dtnicefjxn0hwd0elaeduekbk.png" alt="image"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yx/ln/q-/yxlnq-7z2-lwuyylmz83pferopm.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ey/81/9u/ey819uvi_jhx4wbwchr-wsixvgs.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/q1/tn/zu/q1tnzuopjtdslrltsmn8euup-kq.png"></div><br><br><h2>  Model evolution </h2><br>  One of the problems of the model on seq2seq is the inability to cite words that are not in the dictionary.  For example, the model has no chance to deduce "obamacare" from the article above.  The same goes for: <br><br><ul><li>  rare surnames and names </li><li>  new terms </li><li>  words in other languages, </li><li>  different pairs of words connected by a hyphen (as a "Republican Senator") </li><li>  and other designs. </li></ul><br>  Of course, you can expand the dictionary, but this greatly increases the number of trained parameters.  In addition, it is necessary to provide a large number of documents in which these rare words are found, so that the generator learns to use them in a qualitative manner. <br><br>  Another and more elegant solution to this problem was presented in a 2017 article - ‚Äú <a href="https://arxiv.org/pdf/1704.04368.pdf">Get To The Point: Summarization with Pointer-Generator Networks</a> ‚Äù (Abigail See et al.).  She adds a new mechanism to our model - <b>a</b> pointer <b>mechanism</b> , which can select words from the source text and directly insert into the generated sequence.  If the text contains OOV ( <i>out of vocabulary - a word that is not in the dictionary</i> ), then the model, if it considers it necessary, can isolate OOV and insert it at the output.  Such a system is called a <b>‚Äú</b> pointer-generator‚Äù (pointer-generator or pg) and is a synthesis of two approaches to sammarization.  She herself can decide at what step she should be abstract, and at what step - extracting.  How she does it, we‚Äôll figure it out now. <br><br><img src="https://habrastorage.org/webt/f-/9y/xw/f-9yxwborbgpjpalzwd5e_f74xi.png" alt="image"><br><br>  The main difference from the usual seq2seq model is the additional action on which p <sub>gen</sub> is calculated - the generation probability.  This is done using the hidden state of the decoder and the context vector.  The meaning of the additional action is simple.  The closer p <sub>gen is</sub> to 1, the more likely it is that the model will issue a word from its dictionary using abstract generation.  The closer p <sub>gen is</sub> to 0, the more likely it is that the generator will extract the word from the text, guided by the distribution of attention obtained earlier.  The final probability distribution of the word results is the sum of the generated probability distribution of the words (in which there is no OOV) multiplied by p <sub>gen</sub> and the distribution of attention (in which OOV is, for example, ‚Äú2-0‚Äù in the picture) multiplied by (1 - p <sub>gen</sub> ). <br><br><img src="https://habrastorage.org/webt/iv/8f/8q/iv8f8qvol1j3bbyx79vt5zo7-oq.png" alt="image"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/if/ew/s3/ifews3gqgojf5mclbxd0lpkz2q8.png"></div><br>  In addition to the pointing mechanism, the article introduces <b>a coverage mechanism</b> , which helps to avoid repeating words.  I also experimented with it, but did not notice significant improvements in the quality of headings - it is not really needed.  Most likely, this is due to the specifics of the task: since it is necessary to output a small number of words, the generator simply does not have time to repeat itself.  But for other tasks of sammarization, for example, annotation, it can come in handy.  If interested, you can read about it in the original <a href="https://arxiv.org/pdf/1704.04368.pdf">article</a> . <br><br><img src="https://habrastorage.org/webt/4q/bx/op/4qbxopqt862cphikmbezyaoadlk.png" alt="image"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/--/3m/mz/--3mmzahhdk8kelwoqyh9rdjg8e.png"></div><br><h2>  Great variety of Russian words </h2><br>  Another way to improve the quality of the output headers is to properly preprocess the input sequence.  In addition to the obvious disposal of uppercase characters, I also tried to convert words from the source text into pairs of styles and inflections (i.e. foundations and endings).  For splitting, use the Porter Stemmer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/j8/-y/jyj8-yonzpmvpyoye6mbygrlcjg.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/webt/_k/__/vy/_k__vyhouqm_ctxpsp8ukcselwe.png"></div><br>  We mark all inflections with the ‚Äú+‚Äù symbol at the beginning to distinguish them from other tokens.  We consider each topic and inflection as a separate word and learn from them in the same way as in words.  That is, we get embeddings from them and derive a sequence (also broken down into foundations and endings) that can be easily turned into words. <br><br>  Such a conversion is very useful when working with morphologically rich languages ‚Äã‚Äãlike Russian.  Instead of compiling huge dictionaries with a great variety of Russian word forms, you can limit yourself to a large number of stems of these words (they are several times smaller than the number of word forms) and a very small set of endings (I got a lot of 450 inflections).  Thus, we make it easier for the model to work with this ‚Äúwealth‚Äù and at the same time we do not increase the complexity of the architecture and the number of parameters. <br><br><img src="https://habrastorage.org/webt/a4/es/s5/a4ess5qr3vaxprksv7avun3obl8.png" alt="image"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/rk/6h/3drk6hntzcow2i3soi-heul7ckq.png"></div><br>  I also tried using the lemma + gramme transformation.  That is, from each word before processing, you can get its initial form and grammatical meaning using the pymorphy package (for example, ‚Äúwas‚Äù <img src="https://habrastorage.org/webt/95/wb/-a/95wb-aopfalycfvrshqfynxnwd4.png" alt="image">  ‚ÄúTo be‚Äù and ‚ÄúVERB | impf | past | sing | femn‚Äù).  Thus, I got a pair of parallel sequences (in one - the initial forms, in the other - grammatical values).  For each type of sequence, I compiled my embeddings, which I then concatenated and submitted to the pipeline described earlier.  In it, the decoder did not learn to give out a word, but a lemma and grammes.  But such a system did not bring visible improvements compared to pg on the topic.  Perhaps it was an overly simple architecture for working with grammatical values, and it was worth creating a separate classifier for each grammatical category in the output.  But I did not experiment with such or more complex models. <br><br>  I experimented with another addition to the original architecture of the pointer-generator, which, however, does not apply to preprocessing.  This is an increase in the number of layers (up to 3) of the recursive networks of the encoder and decoder.  Increasing the depth of the recurrent network can improve the quality of the output, since the hidden state of the last layers can contain information about a much longer input subsequence than the hidden state of a single-layer RNN.  This helps to take into account complex extended semantic connections between elements of the input sequence.  True, this costs a significant increase in the number of model parameters and complicates learning. <br><br><img src="https://habrastorage.org/webt/cf/7g/ej/cf7gejf-hxd5pbscvqgnvuuviqy.png" alt="image"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4g/ww/zy/4gwwzytsrt506_xllgy5xcis6vk.png"></div><br><h2>  Header Generator Experiments </h2><br>  All my experiments on headline generators can be divided into two types: experiments with news articles and verses.  I will tell you about them in order. <br><br><h3>  News Experiments </h3><br>  When working with news, I used models such as seq2seq, pg, pg with stems and inflections - single-layer and three-layer.  I also considered models that work with grams, but everything that I wanted to tell about them, I have already described above.  I must say right away that all pg described in this section used the coating mechanism, although its influence on the result is doubtful (since without it it was not much worse). <br><br>  I trained on the RIA Novosti dataset, which was provided by the Rossiya Segodnya news agency to conduct a headline generation track at the Dialog conference.  The dataset contains 1,003,869 news articles published from January 2010 to December 2014. <br><br>  All studied models used the same embeddings (128), vocabulary (100k), and latent states (256) and trained for the same number of eras.  Therefore, only qualitative changes in architecture or in preprocessing could affect the result. <br><br>  Models adapted to work with pre-processed text give better results than models that work with words.  A three-layer pg that uses information about topics and inflections works best.  When using any pg, the expected improvement in the quality of the headers as compared to seq2seq also appears, which hints at the preferred use of the pointer when generating headers.  Here is an example of the operation of all models: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6w/4u/0r/6w4u0ruudngxtt2szek31w0achq.png"></div><br>  Looking at the generated headers, we can distinguish the following problems from the models under study: <br><br><ol><li>  Models often use irregular forms of words.  Models with stems (as in the example above) are more relieved of this drawback; </li><li>  All models, except those that work with themes, can produce headers that seem incomplete, or strange designs that are not in the language (as in the example above); </li><li>  All studied models often confuse the described persons, substitute incorrect dates or use not quite suitable words. </li></ol><br><img src="https://habrastorage.org/webt/9c/-b/ot/9c-bote3bwomvfu_3bwaixhqnks.png" alt="image"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e-/3c/px/e-3cpxuknykthyu-xvf-cp-rdsi.png"></div><br><img src="https://habrastorage.org/webt/lf/ry/ep/lfryepksl4kmcqxttb14ikgx4wg.png" alt="image"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/b3/4m/fw/b34mfwpsffud2kaa93tccjvyja0.png"></div><br><h3>  Experiments with verses </h3><br>  Since the three-layer pg with the themes has the least inaccuracies in the generated headers, this is the model I chose for experiments with verses.  I taught her on the case, composed of 6 million Russian poems from the site "stihi.ru".  They include love (about half of the verses are devoted to this topic), civic (about a quarter), urban and landscape poetry.  Writing period: January 2014 - May 2019. I will give examples of generated headings for verses: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yv/mo/da/yvmodarkck7cgra-ymxigffwhik.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3u/mb/fn/3umbfnpzo1hwhqy0_glxyhxynu4.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tp/tk/5e/tptk5eoq9wa1xrnj9w0gewjeayk.png"></div><br><br>  The model turned out to be mostly extracting: almost all headers are a single line, often extracted from the first or last stanza.  In exceptional cases, the model can generate words that are not in the poem.  This is due to the fact that a very large number of texts in the case really have one of the lines as a name. <br><br>  In conclusion, I will say that the index generator, working on the stems and using a single-layer decoder and encoder, took second place on the <a href="https://vk.com/wall-177402111_31">competition track</a> for generating headlines for news articles at the scientific dialogue conference on computer linguistics "Dialogue".  The main organizer of this conference is ABBYY, the company is engaged in research in almost all modern areas of Natural Language Processing. <br><br>  Finally, I suggest you a little interactive: send news in the comments, and see what headers the neural network will generate for them. <br><br>  <i>Matvey, developer at NLP Group at ABBYY</i> </div></div><p>Source: <a href="https://habr.com/ru/post/479400/">https://habr.com/ru/post/479400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479384/index.html">What does Big Data do in MegaFon and how to get there?</a></li>
<li><a href="../479388/index.html">Features of the construction of national data centers, Mikhalych</a></li>
<li><a href="../479392/index.html">Pinebook Pro: No longer Chromebook</a></li>
<li><a href="../479394/index.html">How I searched for helpdesk among 15 solutions and ... did not find</a></li>
<li><a href="../479398/index.html">We bring the linear regression equation into matrix form</a></li>
<li><a href="../479402/index.html">How to officially pay for freelancer services abroad, pay 0% taxes and not feed payment systems</a></li>
<li><a href="../479404/index.html">Staff for Santa Claus</a></li>
<li><a href="../479406/index.html">16 development tips for Android in Kotlin. Part 1</a></li>
<li><a href="../479414/index.html">Ways to find the goal. The role of chance</a></li>
<li><a href="../479416/index.html">See where you are going (peripheral vision vs cognitive load)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter54458986 = new Ya.Metrika({
                  id:54458986,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/54458986" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-143967986-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=IU0EG0jaqnehka2lu5TyzAcchrZXI4Yb1QXKQvJxpqE&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>