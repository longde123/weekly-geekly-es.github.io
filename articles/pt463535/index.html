<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº üëàüèª üë®‚Äçüî¨ Verificando o c√≥digo-fonte das bibliotecas do .NET Core pelo analisador est√°tico PVS-Studio üï¥üèæ üôáüèº üç∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As bibliotecas do .NET Core s√£o um dos projetos C # mais populares no GitHub. N√£o √© uma surpresa, pois √© amplamente conhecido e usado. Devido a isso, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verificando o c√≥digo-fonte das bibliotecas do .NET Core pelo analisador est√°tico PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/463535/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/webt/-a/bm/pb/-abmpb2yelga7y1zu59bejm6vgo.png" alt="Quadro 19"></div><br>  As bibliotecas do .NET Core s√£o um dos projetos C # mais populares no GitHub.  N√£o √© uma surpresa, pois √© amplamente conhecido e usado.  Devido a isso, uma tentativa de revelar os cantos escuros do c√≥digo-fonte est√° se tornando mais cativante.  Portanto, √© isso que tentaremos fazer com a ajuda do analisador est√°tico PVS-Studio.  O que voc√™ acha - encontraremos algo interessante? <br><a name="habracut"></a><br>  Ando em dire√ß√£o a este artigo h√° mais de um ano e meio.  Em algum momento, tive uma ideia em minha cabe√ßa de que as bibliotecas do .NET Core s√£o um petisco e sua verifica√ß√£o √© uma grande promessa.  Eu estava verificando o projeto v√°rias vezes, o analisador continuava encontrando fragmentos de c√≥digo cada vez mais interessantes, mas n√£o foi al√©m de apenas rolar a lista de avisos.  E aqui est√° - finalmente aconteceu!  O projeto √© verificado, o artigo est√° bem na sua frente. <br><br><h2>  Detalhes sobre o projeto e verifica√ß√£o </h2><br>  Se voc√™ est√° se esfor√ßando para investigar o c√≥digo - voc√™ pode omitir esta se√ß√£o.  No entanto, gostaria muito que voc√™ o lesse, pois aqui estou falando mais sobre o projeto e o analisador, bem como sobre a realiza√ß√£o da an√°lise e a reprodu√ß√£o de erros. <br><br><h3>  Projeto sob verifica√ß√£o </h3><br>  Talvez eu tenha deixado de dizer o que √© o CoreFX (.NET Core Libraries), mas, caso voc√™ n√£o tenha ouvido falar, a descri√ß√£o √© dada abaixo.  √â o mesmo da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°gina</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto no GitHub</a> , onde voc√™ tamb√©m pode baixar o c√≥digo-fonte. <br><br>  Descri√ß√£o: <i>este reposit√≥rio cont√©m a implementa√ß√£o da biblioteca (chamada "CoreFX") para o .NET Core.</i>  <i>Inclui System.Collections, System.IO, System.Xml e muitos outros componentes.</i>  <i>O reposit√≥rio correspondente do .NET Core Runtime (chamado "CoreCLR") cont√©m a implementa√ß√£o de tempo de execu√ß√£o do .NET Core.</i>  <i>Inclui RyuJIT, o .NET GC e muitos outros componentes.</i>  <i>O c√≥digo da biblioteca espec√≠fica do tempo de execu√ß√£o (System.Private.CoreLib) fica no reposit√≥rio CoreCLR.</i>  <i>Ele precisa ser constru√≠do e versionado em conjunto com o tempo de execu√ß√£o.</i>  <i>O restante do CoreFX √© independente da implementa√ß√£o do tempo de execu√ß√£o e pode ser executado em qualquer tempo de execu√ß√£o .NET compat√≠vel (por exemplo, CoreRT)</i> . <br><br>
<h3>  Analisador usado e o m√©todo de an√°lise </h3><br>  Eu verifiquei o c√≥digo usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>analisador est√°tico PVS-Studio</u></a> .  De um modo geral, o PVS-Studio pode analisar n√£o apenas o c√≥digo C #, mas tamb√©m C, C ++, Java.  At√© o momento, a an√°lise do c√≥digo C # funciona apenas no Windows, enquanto o c√≥digo C, C ++, Java pode ser analisado no Windows, Linux e macOS. <br><br>  Normalmente, para verificar projetos C #, eu uso o plug-in PVS-Studio para Visual Studio (suporta as vers√µes 2010-2019), porque provavelmente √© o cen√°rio de an√°lise mais simples e conveniente neste caso: solu√ß√£o aberta, execute a an√°lise, manipule a lista de avisos.  No entanto, saiu um pouco mais complicado com o CoreFX. <br><br>  A parte complicada √© que o projeto n√£o possui um √∫nico arquivo .sln, portanto, n√£o √© poss√≠vel abri-lo no Visual Studio e realizar uma an√°lise completa, usando o plug-in PVS-Studio.  Provavelmente √© uma coisa boa - eu realmente n√£o sei como o Visual Studio lidaria com uma solu√ß√£o desse tamanho. <br><br>  No entanto, n√£o houve problemas com a an√°lise, pois a distribui√ß√£o PVS-Studio inclui a vers√£o da linha de comando do analisador para projetos MSBuild (e .sln).  Tudo o que eu precisava fazer era escrever um pequeno script, que executaria "PVS-Studio_Cmd.exe" para cada .sln no diret√≥rio CoreFX e salvasse os resultados em um diret√≥rio separado (√© especificado por um sinalizador de linha de comando do analisador) . <br><br>  Presto!  Como resultado, estou tendo uma caixa de Pandora com um conjunto de relat√≥rios armazenando algumas coisas interessantes.  Se desejado, esses logs podem ser combinados com o utilit√°rio PlogConverter, vindo como parte da distribui√ß√£o.  Para mim, era mais conveniente trabalhar com logs separados, para n√£o os mesclar. <br><br>  Ao descrever alguns erros, refiro-me √† documenta√ß√£o dos pacotes docs.microsoft.com e NuGet, dispon√≠veis para download em nuget.org.  Suponho que o c√≥digo descrito na documenta√ß√£o / pacotes possa ser ligeiramente diferente do c√≥digo analisado.  No entanto, seria muito estranho se, por exemplo, a documenta√ß√£o n√£o descrevesse exce√ß√µes geradas ao ter um determinado conjunto de dados de entrada, mas a nova vers√£o do pacote as incluiria.  Voc√™ deve admitir que seria uma surpresa duvidosa.  A reprodu√ß√£o de erros em pacotes do NuGet usando os mesmos dados de entrada usados ‚Äã‚Äãpara bibliotecas de depura√ß√£o mostra que esse problema n√£o √© novo.  Mais importante, voc√™ pode 'toc√°-lo' sem criar o projeto a partir de fontes. <br><br>  Assim, permitindo a possibilidade de alguma dessincroniza√ß√£o te√≥rica do c√≥digo, acho aceit√°vel consultar a descri√ß√£o dos m√©todos relevantes em docs.microsoft.com e reproduzir problemas usando pacotes do nuget.org. <br><br>  Al√©m disso, gostaria de observar que a descri√ß√£o pelos links fornecidos, as informa√ß√µes (coment√°rios) nos pacotes (em outras vers√µes) podem ter sido alteradas ao longo da reda√ß√£o do artigo. <br><br><h3>  Outros projetos verificados </h3><br>  A prop√≥sito, este artigo n√£o √© exclusivo desse tipo.  Escrevemos outros artigos sobre verifica√ß√µes de projetos.  Por esse link, voc√™ pode encontrar a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lista de projetos verificados</a> .  Al√©m disso, em nosso site, voc√™ encontrar√° n√£o apenas artigos de verifica√ß√£o de projetos, mas tamb√©m v√°rios artigos t√©cnicos sobre C, C ++, C #, Java, al√©m de algumas notas interessantes.  Voc√™ pode encontrar tudo isso no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>blog</u></a> . <br><br>  Meu colega j√° verificou anteriormente as bibliotecas do .NET Core no ano de 2015. Os resultados da an√°lise anterior podem ser encontrados no artigo relevante: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>An√°lise de Natal das bibliotecas do .NET Core (CoreFX)</u></a> ". <br><br><h2>  Erros detectados, fragmentos suspeitos e interessantes </h2><br>  Como sempre, para maior interesse, sugiro que voc√™ primeiro procure por erros nos fragmentos fornecidos e s√≥ ent√£o leia a mensagem do analisador e a descri√ß√£o do problema. <br><br>  Por conveni√™ncia, separei claramente as pe√ßas usando r√≥tulos do <b>Problema N</b> - dessa forma, √© mais f√°cil saber onde termina a descri√ß√£o de um erro, seguindo o pr√≥ximo.  Al√©m disso, √© mais f√°cil consultar fragmentos espec√≠ficos. <br><br>  <b>Edi√ß√£o 1</b> <br><br><pre><code class="cpp hljs">abstract <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Principal</span></span></span><span class="hljs-class"> :</span></span> IDisposable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PrincipalContext context)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( context.ContextType == ContextType.Machine || _ctx.ContextType == ContextType.Machine) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( SR.SaveToNotSupportedAgainstMachineStore); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context == null) { Debug.Assert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unpersisted == <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(SR.NullArguments); } .... } .... }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3095</u></a> O objeto 'context' foi usado antes de ser verificado contra nulo.  Verifique as linhas: 340, 346. Principal.cs 340 <br><br>  Os desenvolvedores afirmam claramente que o valor <i>nulo</i> do par√¢metro <i>context</i> √© inv√°lido. Eles desejam enfatizar isso usando a exce√ß√£o do tipo <i>InvalidOperationException</i> .  No entanto, logo acima, na condi√ß√£o anterior, podemos ver uma desrefer√™ncia incondicional do <i>contexto de</i> refer√™ncia - <i>context.ContextType</i> .  Como resultado, se o valor do <i>contexto</i> for <i>nulo,</i> a exce√ß√£o do tipo <i>NullReferenceException</i> ser√° gerada em vez da <i>InvalidOperationExcetion</i> esperada <i>.</i> <br><br>  Vamos tentar reproduzir o problema.  Adicionaremos refer√™ncia √† biblioteca <i>System.DirectoryServices.AccountManagement</i> ao projeto e executaremos o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs">GroupPrincipal groupPrincipal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GroupPrincipal(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrincipalContext(ContextType.Machine)); groupPrincipal.Save(null);</code> </pre> <br>  <i>O GroupPrincipal</i> herda da classe abstrata <i>Principal</i> que implementa o m√©todo <i>Save no</i> qual estamos interessados.  Ent√£o, executamos o c√≥digo e vemos o que era necess√°rio para provar. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/290/09a/2cc/29009a2cc3a5408808b9814d48bb0dea.png" alt="Quadro 1"></div><br>  Por uma quest√£o de interesse, voc√™ pode tentar fazer o download do pacote apropriado do NuGet e repetir o problema da mesma maneira.  Eu instalei o pacote 4.5.0 e obtive o resultado esperado. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3de/891/b4a/3de891b4a4ba8100bb63af19e4455842.png" alt="Quadro 2"></div><br>  <b>Edi√ß√£o 2</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> SearchResultCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> findMoreThanOne)</span></span></span><span class="hljs-function"> </span></span>{ searchResult = null; DirectoryEntry clonedRoot = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_assertDefaultNamingContext == null) { clonedRoot = SearchRoot.CloneBrowsable(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { clonedRoot = SearchRoot.CloneBrowsable(); } .... }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3004</u></a> A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>instru√ß√£o</u></a> 'then' √© equivalente √† instru√ß√£o 'else'.  DirectorySearcher.cs 629 <br><br>  Independentemente de a condi√ß√£o <i>nula _assertDefaultNamingContext ==</i> ser verdadeira ou falsa, as mesmas a√ß√µes ser√£o executadas, pois as ramifica√ß√µes da instru√ß√£o <i>if</i> ter√£o os mesmos corpos.  Ou deve haver outra a√ß√£o em uma ramifica√ß√£o, ou voc√™ pode omitir a instru√ß√£o <i>if</i> para n√£o confundir os desenvolvedores e o analisador. <br><br>  <b>Edi√ß√£o 3</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DirectoryEntry</span></span></span><span class="hljs-class"> :</span></span> Component { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] propertyNames)</span></span></span><span class="hljs-function"> </span></span>{ .... object[] names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> object[propertyNames.Length]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; propertyNames.Length; i++) names[i] = propertyNames[i]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_propertyCollection != null &amp;&amp; propertyNames != null) .... .... } .... }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3095</u></a> O objeto 'propertyNames' foi usado antes de ser verificado com valor nulo.  Verifique as linhas: 990, 1004. DirectoryEntry.cs 990 <br><br>  Novamente, vemos uma estranha ordem de a√ß√µes.  No m√©todo, h√° uma <i>propriedade de</i> verifica√ß√£oNomes <i>! = Nulo</i> , ou seja, os desenvolvedores cobrem suas bases de <i>nulos</i> que entram no m√©todo.  Mas acima, voc√™ pode ver algumas opera√ß√µes de acesso por essa refer√™ncia potencialmente nula - <i>propertyNames.Length</i> e <i>propertyNames [i]</i> .  O resultado √© bastante previs√≠vel - a ocorr√™ncia de uma exce√ß√£o do tipo <i>NullReferenceExcepption</i> no caso de uma refer√™ncia nula ser passada para o m√©todo. <br><br>  Que coincid√™ncia!  <i>RefreshCache</i> √© um m√©todo p√∫blico na classe p√∫blica.  Que tal tentar reproduzir o problema?  Para fazer isso, incluiremos a biblioteca necess√°ria System. Directory <i>Services</i> no projeto e escreveremos c√≥digo como este: <br><br><pre> <code class="cpp hljs">DirectoryEntry de = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DirectoryEntry(); de.RefreshCache(null);</code> </pre> <br>  Depois de executarmos o c√≥digo, podemos ver o que esper√°vamos. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/040/d0a/2d9040d0ae8d91394c476d6788aa7275.png" alt="Quadro 3"></div><br>  Apenas para come√ßar, voc√™ pode tentar reproduzir o problema na vers√£o de lan√ßamento do pacote NuGet.  Em seguida, adicionamos refer√™ncia ao pacote <i>System.DirectoryServices</i> (usei a vers√£o 4.5.0) ao projeto e executamos o c√≥digo j√° familiar.  O resultado est√° abaixo. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d6/31e/309/0d631e3096fa8ba00b41fe10ad1001db.png" alt="Quadro 4"></div><br>  <b>Edi√ß√£o 4</b> <br><br>  Agora vamos pelo contr√°rio - primeiro tentaremos escrever o c√≥digo, que usa uma inst√¢ncia de classe, e depois examinaremos o interior.  Vamos nos referir √† estrutura <i>System.Drawing.CharacterRange da</i> biblioteca <i>System.Drawing.Common</i> e ao pacote NuGet com o mesmo nome. <br><br>  Usaremos este peda√ßo de c√≥digo: <br><br><pre> <code class="cpp hljs">CharacterRange range = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CharacterRange(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> eq = range.Equals(null); Console.WriteLine(eq);</code> </pre> <br>  Apenas para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>garantir</u></a> que apenas movimentemos nossa mem√≥ria, trataremos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>docs.microsoft.com</u></a> para recuperar o valor esperado da express√£o <i>obj.Equals (null)</i> : <br><br>  <i>As instru√ß√µes a seguir devem ser verdadeiras para todas as implementa√ß√µes do m√©todo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u><i>Equals (Object)</i></u></a> .</i>  <i>Na lista, x, ye z representam refer√™ncias a objetos que n√£o s√£o nulos.</i> <br><br>  <i>....</i> <br><br>  <b><i>x.Equals (null) retorna false.</i></b> <br><br>  Voc√™ acha que o texto "False" ser√° exibido no console?  Claro que n√£o.  Seria f√°cil demais.  :) Portanto, executamos o c√≥digo e olhamos o resultado. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e87/159/8f6/e871598f6ca5dacdb4a4fae7b5776520.png" alt="Quadro 5"></div><br>  Foi a sa√≠da do c√≥digo acima usando o pacote NuGet <i>System.Drawing.Common</i> da vers√£o 4.5.1.  A pr√≥xima etapa √© executar o mesmo c√≥digo com a vers√£o da biblioteca de depura√ß√£o.  Isto √© o que vemos: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/f27/f1a/6e9f27f1a78768078fdd940e0a4be0ad.png" alt="Quadro 6"></div><br>  Agora, vejamos o c√≥digo fonte, em particular, a implementa√ß√£o do m√©todo <i>Equals</i> na estrutura <i>CharacterRange</i> e o aviso do analisador: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.GetType() != typeof(CharacterRange)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; CharacterRange cr = (CharacterRange)obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((_first == cr.First) &amp;&amp; (_length == cr.Length)); }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3115 A</u></a> passagem de 'null' para o m√©todo 'Equals' n√£o deve resultar em 'NullReferenceException'.  CharacterRange.cs 56 <br><br>  Podemos observar, o que tinha que ser provado - o par√¢metro <i>obj</i> √© tratado incorretamente.  Por esse motivo, a exce√ß√£o <i>NullReferenceException</i> ocorre na express√£o condicional ao chamar o m√©todo de inst√¢ncia <i>GetType.</i> <br><br>  <b>Edi√ß√£o 5</b> <br><br>  Enquanto estamos explorando esta biblioteca, vamos considerar outro fragmento interessante - o m√©todo <i>Icon</i> <i>.</i> <i>Save</i> <i>.</i>  Antes da pesquisa, vejamos a descri√ß√£o do m√©todo. <br><br>  N√£o h√° descri√ß√£o do m√©todo: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffd/fef/402/ffdfef402f77c462c94b9ff284f42e0c.png" alt="Quadro 7"></div><br>  Vamos abordar docs.microsoft.com - " <u>M√©todo Icon.Save (Stream)</u> ".  No entanto, tamb√©m n√£o h√° restri√ß√µes sobre entradas ou informa√ß√µes sobre as exce√ß√µes geradas. <br><br>  Agora vamos para a inspe√ß√£o de c√≥digo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sealed partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Icon</span></span></span><span class="hljs-class"> :</span></span> MarshalByRefObject, ICloneable, IDisposable, ISerializable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream outputStream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_iconData != null) { outputStream.Write(_iconData, <span class="hljs-number"><span class="hljs-number">0</span></span>, _iconData.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outputStream == null) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"dataStream"</span></span>); .... } } .... }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3095</u></a> O objeto ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>outputStream</u></a> ' foi usado antes de ser verificado em rela√ß√£o a nulo.  Verifique as linhas: 654, 672. Icon.Windows.cs 654 <br><br>  Novamente, √© a hist√≥ria que j√° conhecemos - poss√≠vel desrefer√™ncia de uma refer√™ncia nula, pois o par√¢metro do m√©todo √© desreferenciado sem verificar se √© <i>nulo</i> .  Mais uma vez, uma coincid√™ncia bem sucedida de circunst√¢ncias - tanto a classe quanto o m√©todo s√£o p√∫blicos, para que possamos tentar reproduzir o problema. <br><br>  Nossa tarefa √© simples - trazer a execu√ß√£o do c√≥digo para a express√£o <i>outputStream.Write (_iconData, 0, _iconData.Length);</i>  e, ao mesmo tempo, salve o valor da vari√°vel <i>outputStream</i> - <i>null</i> .  Atender √† condi√ß√£o <i>_iconData! = Nulo</i> √© suficiente para isso. <br><br>  Vejamos o construtor p√∫blico mais simples: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Icon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fileName, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Apenas delega o trabalho para outro construtor. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Icon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> width, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (FileStream f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read)) { Debug.Assert(f != null, <span class="hljs-string"><span class="hljs-string">"File.OpenRead returned null instead of throwing an exception"</span></span>); _iconData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)f.Length]; f.Read(_iconData, <span class="hljs-number"><span class="hljs-number">0</span></span>, _iconData.Length); } Initialize(width, height); }</code> </pre> <br>  √â isso, √© o que precisamos.  Depois de chamar esse construtor, se lermos com √™xito os dados do arquivo e n√£o houver falhas no m√©todo <i>Initialize</i> , o campo <i>_iconData</i> conter√° uma refer√™ncia a um objeto, √© disso que precisamos. <br><br>  Acontece que precisamos criar a inst√¢ncia da classe <i>Icon</i> e especificar um arquivo de √≠cone real para reproduzir o problema.  Depois disso, precisamos chamar o m√©todo <i>Save</i> , depois de passar o valor <i>nulo</i> como argumento, √© o que fazemos.  O c√≥digo pode ficar assim, por exemplo: <br><br><pre> <code class="cpp hljs">Icon icon = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Icon(@<span class="hljs-string"><span class="hljs-string">"D:\document.ico"</span></span>); icon.Save(null);</code> </pre> <br>  O resultado da execu√ß√£o √© esperado. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b37/fdb/dd1/b37fdbdd1288c054fdaaa0add0ffcfcf.png" alt="Quadro 8"></div><br>  <b>Edi√ß√£o 6</b> <br><br>  Continuamos a revis√£o e seguimos em frente.  Tente encontrar 3 diferen√ßas entre as a√ß√µes, executadas no <i>caso CimType.UInt32</i> e outro <i>caso</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConvertToNumericValueAndAddToArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> retFunctionName = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; enumType = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(cimType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt8: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt8: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt16: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt16: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.SInt32: arrayToAdd.Add(System.Convert.ToInt32( numericValue, (IFormatProvider)CultureInfo.InvariantCulture .GetFormat(typeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)))); retFunctionName = <span class="hljs-string"><span class="hljs-string">"ToInt32"</span></span>; enumType = <span class="hljs-string"><span class="hljs-string">"System.Int32"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CimType.UInt32: arrayToAdd.Add(System.Convert.ToInt32( numericValue, (IFormatProvider)CultureInfo.InvariantCulture .GetFormat(typeof(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)))); retFunctionName = <span class="hljs-string"><span class="hljs-string">"ToInt32"</span></span>; enumType = <span class="hljs-string"><span class="hljs-string">"System.Int32"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retFunctionName; }</code> </pre> <br>  Obviamente, n√£o h√° diferen√ßas, pois o analisador nos alerta sobre isso. <br><br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3139</u></a> Dois ou mais ramifica√ß√µes de caso executam as mesmas a√ß√µes.  WMIGenerator.cs 5220 <br><br>  Pessoalmente, esse estilo de c√≥digo n√£o √© muito claro.  Se n√£o houver erro, penso que a mesma l√≥gica n√£o deveria ter sido aplicada a casos diferentes. <br><br>  <b>Edi√ß√£o 7</b> <br><br>  Biblioteca <i>Microsoft.CSharp</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IList&lt;KeyValuePair&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, object&gt;&gt; QueryDynamicObject(object obj) { .... List&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; names = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(mo.GetDynamicMemberNames()); names.Sort(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (names != null) { .... } .... }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3022 A</u></a> express√£o 'names! = Null' sempre √© verdadeira.  DynamicDebuggerProxy.cs 426 <br><br>  Provavelmente, eu poderia ignorar esse aviso junto com muitos semelhantes que foram emitidos pelos diagn√≥sticos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3022</u></a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3063</u></a> .  Havia muitos (muitos) cheques estranhos, mas este de alguma forma entrou na minha alma.  Talvez, o motivo esteja no que acontece antes de comparar a vari√°vel de <i>nomes</i> locais com <i>nula.</i>  A refer√™ncia n√£o apenas √© armazenada na vari√°vel <i>names</i> para um objeto rec√©m-criado, como tamb√©m √© chamado o m√©todo <i>Sort</i> da inst√¢ncia.  Claro, n√£o √© um erro, mas, quanto a mim, vale a pena prestar aten√ß√£o. <br><br>  <b>Edi√ß√£o 8</b> <br><br>  Outro peda√ßo interessante de c√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InsertChildNoGrow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Symbol child)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sym?.nextSameName != null) { sym = sym.nextSameName; } Debug.Assert(sym != null &amp;&amp; sym.nextSameName == null); sym.nextSameName = child; .... }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3042</u></a> NullReferenceException poss√≠vel.  O '?'  e '.'  operadores s√£o usados ‚Äã‚Äãpara acessar membros do objeto 'sym' SymbolStore.cs 56 <br><br>  Olha o que √© isso.  O loop termina com a conformidade de pelo menos uma das duas condi√ß√µes: <br><br><ul><li>  <i>sym == nulo</i> ; </li><li>  <i>sym.nextSameName == null</i> . </li></ul><br>  N√£o h√° problemas com a segunda condi√ß√£o, o que n√£o pode ser dito sobre a primeira.  Como o campo da inst√¢ncia de <i>nomes</i> √© acessado incondicionalmente abaixo e, se for <i>nulo</i> , uma exce√ß√£o do tipo <i>NullReferenceException</i> ocorrer√°. <br><br>  Voc√™ √© cego?  Existe a chamada <i>Debug.Assert</i> , onde foi verificado que <i>sym! = Null</i> ‚Äù- algu√©m pode argumentar.  Muito pelo contr√°rio, esse √© o ponto!  Ao trabalhar na vers√£o Release, <i>Debug.Assert</i> n√£o ser√° de nenhuma ajuda e, com a condi√ß√£o acima, tudo o que obteremos √© <i>NullReferenceException</i> .  Al√©m disso, eu j√° vi um erro semelhante em outro projeto da Microsoft - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>Roslyn</u></a> , onde ocorreu uma situa√ß√£o semelhante com o <i>Debug.Assert</i> .  Deixe-me desviar por um momento para Roslyn. <br><br>  O problema pode ser reproduzido ao usar <i>as</i> bibliotecas <i>Microsoft.CodeAnalysis</i> ou diretamente no Visual Studio ao usar o Syntax Visualizer.  No Visual Studio 16.1.6 + Syntax Visualizer 1.0, esse problema ainda pode ser reproduzido. <br><br>  Este c√≥digo √© suficiente para isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  Al√©m disso, no Syntax Visualizer, precisamos encontrar o n√≥ da √°rvore de sintaxe do tipo <i>ConstantPatternSyntax</i> , correspondente a <i>null</i> no c√≥digo e solicitar <i>TypeSymbol</i> para ele. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/855/b9c/baa/855b9cbaa67c9a5909117d513e154293.png" alt="Quadro 9"></div><br>  Depois disso, o Visual Studio ser√° reiniciado.  Se formos ao Event Viewer, encontraremos algumas informa√ß√µes sobre problemas nas bibliotecas: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.Resources.MissingManifestResourceException at System.Resources.ManifestBasedResourceGroveler .HandleResourceStreamMissing(System.String) at System.Resources.ManifestBasedResourceGroveler.GrovelForResourceSet( System.Globalization.CultureInfo, System.Collections.Generic.Dictionary<span class="hljs-string"><span class="hljs-string">'2 &lt;System.String,System.Resources.ResourceSet&gt;, Boolean, Boolean, System.Threading.StackCrawlMark ByRef) at System.Resources.ResourceManager.InternalGetResourceSet( System.Globalization.CultureInfo, Boolean, Boolean, System.Threading.StackCrawlMark ByRef) at System.Resources.ResourceManager.InternalGetResourceSet( System.Globalization.CultureInfo, Boolean, Boolean) at System.Resources.ResourceManager.GetString(System.String, System.Globalization.CultureInfo) at Roslyn.SyntaxVisualizer.DgmlHelper.My. Resources.Resources.get_SyntaxNodeLabel() ....</span></span></code> </pre> <br>  Quanto ao problema com o devenv.exe: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.1</span></span><span class="hljs-number"><span class="hljs-number">.29102</span></span><span class="hljs-number"><span class="hljs-number">.190</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5d1c133b</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: KERNELBASE.dll, version: <span class="hljs-number"><span class="hljs-number">10.0</span></span><span class="hljs-number"><span class="hljs-number">.18362</span></span><span class="hljs-number"><span class="hljs-number">.145</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0xf5733ace</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xe0434352</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x001133d2</span></span> ....</code> </pre> <br>  Com as vers√µes de depura√ß√£o das bibliotecas Roslyn, voc√™ pode encontrar o local em que houve uma exce√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } .... }</code> </pre> <br>  Aqui, da mesma forma que no c√≥digo das bibliotecas do .NET Core considerado acima, h√° uma verifica√ß√£o do <i>Debug.Assert</i> que n√£o ajudaria ao usar vers√µes de lan√ßamento das bibliotecas. <br><br>  <b>Edi√ß√£o 9</b> <br><br>  Temos um pouco de desvantagem aqui, ent√£o vamos voltar √†s bibliotecas do .NET Core.  O pacote <i>System.IO.IsolatedStorage</i> cont√©m o seguinte c√≥digo interessante. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContainsUnknownFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> directory)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (files.Length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> || ( (!IsIdFile(files[<span class="hljs-number"><span class="hljs-number">0</span></span>]) &amp;&amp; !IsInfoFile(files[<span class="hljs-number"><span class="hljs-number">0</span></span>]))) || (files.Length == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; !IsIdFile(files[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &amp;&amp; !IsInfoFile(files[<span class="hljs-number"><span class="hljs-number">1</span></span>])) ); }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3088</u></a> A express√£o foi colocada entre par√™nteses duas vezes: ((express√£o)).  Um par de par√™nteses √© desnecess√°rio ou a impress√£o incorreta est√° presente.  IsolatedStorageFile.cs 839 <br><br>  Dizer que a formata√ß√£o do c√≥digo √© confusa √© outra maneira de n√£o dizer nada.  Dando uma breve olhada neste c√≥digo, eu diria que o operando esquerdo do primeiro ||  operador me deparei com <i>arquivos.Comprimento&gt; 2</i> , o <i>caminho</i> certo √© aquele entre par√™nteses.  Pelo menos o c√≥digo est√° formatado assim.  Depois de olhar um pouco mais cuidadosamente, voc√™ pode entender que n√£o √© o caso.  De fato, o operando certo - <i>((! IsIdFile (arquivos [0]) &amp;&amp;! IsInfoFile (arquivos [0])))</i> .  Eu acho que esse c√≥digo √© bastante confuso. <br><br>  <b>Edi√ß√£o 10</b> <br><br>  O PVS-Studio 7.03 introduziu a regra de diagn√≥stico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3138</u></a> , que procura erros na cadeia de caracteres interpolada.  Mais precisamente, na cadeia que provavelmente teve que ser interpolada, mas por causa do s√≠mbolo <i>$</i> perdido, eles n√£o s√£o <i>.</i>  Nas bibliotecas <i>System.Net</i> , encontrei v√°rias ocorr√™ncias interessantes dessa regra de diagn√≥stico. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheCredential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SafeFreeCredentials newHandle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ExceptionCheck.IsFatal(e)) { NetEventSource.Fail(null, <span class="hljs-string"><span class="hljs-string">"Attempted to throw: {e}"</span></span>); } } }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> O literal da string <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3138</u></a> cont√©m uma express√£o interpolada em potencial.  Considere inspecionar: e.  SSPIHandleCache.cs 42 <br><br>  √â altamente prov√°vel que o segundo argumento do m√©todo <i>Fail</i> tenha que ser uma string interpolada, na qual a representa√ß√£o da string da exce√ß√£o <i>e</i> seria substitu√≠da.  No entanto, devido a um s√≠mbolo <i>$</i> perdido, nenhuma representa√ß√£o de cadeia foi substitu√≠da. <br><br>  <b>Edi√ß√£o 11</b> <br><br>  Aqui est√° outro caso semelhante. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> async Task&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; GetDigestTokenForCredential(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) NetEventSource.Error(digestResponse, <span class="hljs-string"><span class="hljs-string">"Algorithm not supported: {algorithm}"</span></span>); .... }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> O literal da string <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3138</u></a> cont√©m uma express√£o interpolada em potencial.  Considere inspecionar: algoritmo.  AuthenticationHelper.Digest.cs 58 <br><br>  A situa√ß√£o √© semelhante √† acima, novamente o s√≠mbolo <i>$</i> est√° ausente, resultando na cadeia incorreta, entrando no m√©todo <i>Error</i> <i>.</i> <br><br>  <b>Edi√ß√£o 12</b> <br><br>  Pacote <i>System.Net.Mail</i> .  O m√©todo √© pequeno, cito-o por inteiro para tornar a pesquisa do bug mais interessante. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Stream stream)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stream == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(nameof(stream)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_streamSet) { _stream.Close(); _stream = null; _streamSet = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } _stream = stream; _streamSet = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _streamUsedOnce = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; TransferEncoding = TransferEncoding.Base64; }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3008</u></a> A vari√°vel '_streamSet' recebe valores duas vezes sucessivamente.  Talvez isso seja um erro.  Verifique as linhas: 123, 119. MimePart.cs 123 <br><br>  A atribui√ß√£o de valor duplo √† vari√°vel <i>_streamSet</i> parece estranha (primeiro - sob a condi√ß√£o e depois - fora).  A mesma hist√≥ria com a redefini√ß√£o da vari√°vel de <i>fluxo</i> .  Como resultado, <i>_stream</i> ainda ter√° o <i>fluxo de</i> valor e o <i>_streamSet</i> ser√° <i>verdadeiro.</i> <br><br>  <b>Edi√ß√£o 13</b> <br><br>  Um fragmento de c√≥digo interessante da biblioteca <i>System.Linq.Expressions</i> que aciona 2 avisos do analisador de uma s√≥ vez.  Nesse caso, √© mais um recurso do que um bug.  No entanto, o m√©todo √© bastante incomum ... <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// throws NRE when o is null protected static void NullCheck(object o) { if (o == null) { o.GetType(); } }</span></span></code> </pre> <br>  <b>Avisos do PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3010</u></a> O valor de retorno da fun√ß√£o 'GetType' deve ser utilizado.  Instruction.cs 36 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3080</u></a> Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'o'.  Instruction.cs 36 </li></ul><br>  Provavelmente n√£o h√° nada para comentar aqui. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c9/a88/a22/5c9a88a221d4cd5ba5f4f1d9f74a346b.png" alt="Quadro 20"></div><br>  <b>Edi√ß√£o 14</b> <br><br>  Vamos considerar outro caso, que trataremos "de fora".  Primeiro, escrevemos o c√≥digo, detectamos os problemas e depois examinamos o interior.  Levaremos a biblioteca <i>System.Configuration.ConfigurationManager</i> e o pacote NuGet de mesmo nome para revis√£o.  Eu usei o pacote da vers√£o 4.5.0.  Lidaremos com a classe <i>System.Configuration.CommaDelimitedStringCollection</i> . <br><br>  Vamos fazer algo sem sofistica√ß√£o.  Por exemplo, criaremos um objeto, extrairemos sua representa√ß√£o de string e obteremos o comprimento dessa string, depois imprimi-la.  O c√≥digo relevante: <br><br><pre> <code class="cpp hljs">CommaDelimitedStringCollection collection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommaDelimitedStringCollection(); Console.WriteLine(collection.ToString().Length);</code> </pre> <br>  Apenas no caso, vamos verificar a descri√ß√£o do m√©todo <i>ToString</i> : <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8dc/544/56d/8dc54456dd1296d89fbe447fac71ac17.png" alt="Quadro 11"></div><br>  Nada de especial - a representa√ß√£o de string de um objeto √© retornada.  Apenas no caso, consultarei docs.microsoft.com - " <u>M√©todo CommaDelimitedStringCollection.ToString</u> ".  Parece que n√£o h√° nada de especial aqui. <br><br>  Ok, vamos executar o c√≥digo, aaand ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa5/89f/1af/fa589f1afc8ceb9415694e1261e59ab7.png" alt="Quadro 12"></div><br>  Hummm, surpresa.  Bem, vamos tentar adicionar um item √† cole√ß√£o e obter sua representa√ß√£o de string.  Em seguida, adicionaremos "absolutamente acidentalmente" uma string vazia :).  O c√≥digo mudar√° e ficar√° assim: <br><br><pre> <code class="cpp hljs">CommaDelimitedStringCollection collection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CommaDelimitedStringCollection(); collection.Add(String.Empty); Console.WriteLine(collection.ToString().Length);</code> </pre> <br>  Execute e veja ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d37/4bc/d2e/d374bcd2ed23bd048276493ed19d30fe.png" alt="Quadro 13"></div><br>  O que, de novo ?!  Bem, vamos finalmente abordar a implementa√ß√£o do m√©todo <i>ToString</i> da classe <i>CommaDelimitedStringCollection</i> .  O c√≥digo est√° abaixo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Count &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); foreach (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str in <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { ThrowIfContainsDelimiter(str); <span class="hljs-comment"><span class="hljs-comment">// .... sb.Append(str.Trim()); sb.Append(','); } if (sb.Length &gt; 0) sb.Length = sb.Length - 1; return sb.Length == 0 ? null : sb.ToString(); }</span></span></code> </pre> <br>  <b>Avisos do PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3108</u></a> N√£o √© recomend√°vel retornar 'null' do m√©todo 'ToSting ()'.  StringAttributeCollection.cs 57 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3108</u></a> N√£o √© recomend√°vel retornar 'null' do m√©todo 'ToSting ()'.  StringAttributeCollection.cs 71 </li></ul><br>  Aqui podemos ver 2 fragmentos, nos quais a implementa√ß√£o atual do <i>ToString</i> pode retornar <i>nula.</i>  Neste ponto, recordaremos a recomenda√ß√£o da Microsoft sobre a implementa√ß√£o do m√©todo <i>ToString</i> .  Ent√£o, vamos consultar docs.microsoft.com - " <u>M√©todo Object.ToString</u> ": <br><br>  <i>Notas para os herdeiros .... As substitui√ß√µes do m√©todo ToString () devem seguir estas diretrizes:</i> <br><br><ul><li>  <i>....</i> </li><li>  <i>Sua substitui√ß√£o ToString () n√£o deve retornar vazia ou uma</i> <i>seq√º√™ncia</i> <b><i>nula</i></b> <i>.</i> </li><li>  <i>....</i> </li></ul><br>  √â sobre isso que o PVS-Studio alerta.  Dois fragmentos de c√≥digo fornecidos acima que est√°vamos escrevendo para reproduzir o problema obt√™m diferentes pontos de sa√≠da - o primeiro e o segundo pontos de retorno <i>nulos,</i> respectivamente.  Vamos cavar um pouco mais fundo. <br><br>  Primeiro caso.  <i>Count</i> √© uma propriedade da classe <i>StringCollection</i> base.  Como nenhum elemento foi adicionado, <i>Contagem == 0</i> , a condi√ß√£o <i>Contagem &lt;= 0</i> √© verdadeira, o valor <i>nulo</i> √© retornado. <br><br>  No segundo caso, adicionamos o elemento, usando o m√©todo <i>CommaDelimitedStringCollection.Add</i> da inst√¢ncia. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">new</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ ThrowIfReadOnly(); ThrowIfContainsDelimiter(value); _modified = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; base.Add(value.Trim()); }</code> </pre> <br>  As verifica√ß√µes s√£o bem-sucedidas no m√©todo <i>ThrowIf ...</i> e o elemento √© adicionado na cole√ß√£o base.  Conseq√ºentemente, o valor <i>Count</i> se torna 1. Agora, voltemos ao m√©todo <i>ToString</i> .  Valor da express√£o <i>Count &lt;= 0</i> - <i>false</i> , portanto, o m√©todo n√£o retorna e a execu√ß√£o do c√≥digo continua.  A cole√ß√£o interna √© percorrida, 2 elementos s√£o adicionados √† inst√¢ncia do tipo <i>StringBuilder</i> - uma sequ√™ncia vazia e uma v√≠rgula.  Como resultado, verifica-se que <i>sb</i> cont√©m apenas uma v√≠rgula, o valor da propriedade <i>Length</i> √© igual a 1. O valor da express√£o <i>sb.Length&gt; 0</i> √© <i>verdadeiro</i> , a subtra√ß√£o e a escrita em <i>sb.Length</i> s√£o executadas, agora o valor de <i>sb.Length</i> √© 0. Isso leva ao fato de que o valor <i>nulo</i> √© retornado novamente do m√©todo. <br><br>  <b>Edi√ß√£o 15</b> <br><br>  De repente, senti um desejo de usar a classe <i>System.Configuration.ConfigurationProperty</i> .  Vamos pegar um construtor com o maior n√∫mero de par√¢metros: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigurationProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, Type type, object defaultValue, TypeConverter typeConverter, ConfigurationValidatorBase validator, ConfigurationPropertyOptions options, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description)</span></span></span></span>;</code> </pre> <br>  Vamos ver a descri√ß√£o do √∫ltimo par√¢metro: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// description: // The description of the configuration entity.</span></span></code> </pre> <br>  O mesmo est√° escrito na descri√ß√£o do construtor em docs.microsoft.com.  Bem, vamos dar uma olhada em como esse par√¢metro √© usado no corpo do construtor: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigurationProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...., </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> description)</span></span></span><span class="hljs-function"> </span></span>{ ConstructorInit(name, type, options, validator, typeConverter); SetDefaultValue(defaultValue); }</code> </pre> <br>  Acredite ou n√£o, o par√¢metro n√£o √© usado. <br><br>  <b>Aviso do PVS-Studio:</b> O par√¢metro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3117</u></a> Constructor 'description' n√£o √© usado.  ConfigurationProperty.cs 62 <br><br>  Provavelmente, os autores do c√≥digo n√£o o usam intencionalmente, mas a descri√ß√£o do par√¢metro relevante √© muito confusa. <br><br>  <b>Edi√ß√£o 16</b> <br><br>  Aqui est√° outro fragmento semelhante: tente encontrar o erro voc√™ mesmo, estou fornecendo o c√≥digo do construtor abaixo. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SectionXmlInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configKey, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> definitionConfigPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> targetConfigPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> subPath, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lineNumber, object streamVersion, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rawXml, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configSource, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> configSourceStreamName, object configSourceStreamVersion, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> protectionProviderName, OverrideModeSetting overrideMode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> skipInChildApps)</span></span></span><span class="hljs-function"> </span></span>{ ConfigKey = configKey; DefinitionConfigPath = definitionConfigPath; TargetConfigPath = targetConfigPath; SubPath = subPath; Filename = filename; LineNumber = lineNumber; StreamVersion = streamVersion; RawXml = rawXml; ConfigSource = configSource; ConfigSourceStreamName = configSourceStreamName; ProtectionProviderName = protectionProviderName; OverrideModeSetting = overrideMode; SkipInChildApps = skipInChildApps; }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> O par√¢metro do construtor V3117 'configSourceStreamVersion' n√£o √© usado.  SectionXmlInfo.cs 16 <br><br>  Existe uma propriedade apropriada, mas, francamente, parece um pouco estranho: <br><br><pre> <code class="cpp hljs">internal object ConfigSourceStreamVersion { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { } }</code> </pre> <br>  Geralmente, o c√≥digo parece suspeito.  Talvez o par√¢metro / propriedade seja deixado para compatibilidade, mas esse √© apenas o meu palpite. <br><br>  <b>Edi√ß√£o 17</b> <br><br>  Vamos dar uma olhada em coisas interessantes na biblioteca <i>System.Runtime.WindowsRuntime.UI.Xaml</i> e no c√≥digo do pacote com o mesmo nome. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatBehavior</span></span></span><span class="hljs-class"> :</span></span> IFormattable { .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InternalToString(null, null); } .... }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3108</u></a> N√£o √© recomend√°vel retornar 'null' do m√©todo 'ToSting ()'.  RepeatBehavior.cs 113 <br><br>  Hist√≥ria familiar que j√° conhecemos - o m√©todo <i>ToString</i> pode retornar o valor <i>nulo</i> .  Por esse motivo, o autor do c√≥digo do chamador, que assume que <i>RepeatBehavior.ToString</i> sempre retorna uma refer√™ncia n√£o nula, pode ser desagrad√°vel em algum momento.  Mais uma vez, contradiz as diretrizes da Microsoft. <br><br>  Bem, mas o m√©todo n√£o deixa claro que o <i>ToString</i> pode retornar <i>nulo</i> - precisamos aprofundar e espiar o m√©todo <i>InternalToString</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InternalToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> format, IFormatProvider formatProvider)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_Type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Forever: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Forever"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Count: StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.AppendFormat( formatProvider, <span class="hljs-string"><span class="hljs-string">"{0:"</span></span> + format + <span class="hljs-string"><span class="hljs-string">"}x"</span></span>, _Count); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RepeatBehaviorType.Duration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _Duration.ToString(); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } }</code> </pre> <br>  O analisador detectou que, se a ramifica√ß√£o <i>padr√£o for</i> executada no <i>switch</i> , <i>InternalToString</i> retornar√° o valor <i>nulo</i> .  Portanto, <i>ToString</i> retornar√° <i>nulo</i> tamb√©m. <br><br>  <i>RepeatBehavior</i> √© uma estrutura p√∫blica e <i>ToString</i> √© um m√©todo p√∫blico, para que possamos tentar reproduzir o problema na pr√°tica.  Para isso, criaremos a inst√¢ncia <i>RepeatBehavior</i> , chamaremos o m√©todo <i>ToString</i> e, ao fazer isso, n√£o perderemos que <i>_Type</i> n√£o deve ser igual a <i>RepeatBehaviorType.Forever</i> , <i>RepeatBehaviorType.Count</i> ou <i>RepeatBehaviorType.Duration</i> . <br><br>  <i>_Type</i> √© um campo privado, que pode ser atribu√≠do por meio de uma propriedade p√∫blica: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepeatBehavior</span></span></span><span class="hljs-class"> :</span></span> IFormattable { .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RepeatBehaviorType _Type; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RepeatBehaviorType Type { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _Type; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { _Type = value; } } .... }</code> </pre> <br>  At√© agora, tudo bem.  Vamos seguir em frente e ver qual √© o tipo <i>RepeatBehaviorType</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> RepeatBehaviorType { Count, Duration, Forever }</code> </pre> <br>  Como podemos ver, <i>RepeatBehaviorType</i> √© a enumera√ß√£o, contendo todos os tr√™s elementos.  Junto com isso, todos esses tr√™s elementos s√£o abordados na express√£o do <i>switch em</i> que estamos interessados.  Isso, no entanto, n√£o significa que a ramifica√ß√£o padr√£o esteja inacess√≠vel. <br><br>  Para reproduzir o problema, adicionaremos refer√™ncia ao pacote <i>System.Runtime.WindowsRuntime.UI.Xaml</i> ao projeto (eu estava usando a vers√£o 4.3.0) e executaremos o c√≥digo a seguir. <br><br><pre> <code class="cpp hljs">RepeatBehavior behavior = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RepeatBehavior() { Type = (RepeatBehaviorType)<span class="hljs-number"><span class="hljs-number">666</span></span> }; Console.WriteLine(behavior.ToString() is null);</code> </pre> <br>  <i>True</i> √© exibido no console conforme o esperado, o que significa que <i>ToString</i> retornou <i>nulo</i> , j√° que <i>_Type</i> n√£o era igual a nenhum dos valores nas ramifica√ß√µes do <i>caso</i> , e a ramifica√ß√£o <i>padr√£o</i> recebeu o controle.  Era isso que est√°vamos tentando fazer. <br><br>  Tamb√©m gostaria de observar que nem os coment√°rios ao m√©todo nem o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>docs.microsoft.com</u></a> especificam que o m√©todo pode retornar o valor <i>nulo</i> . <br><br>  <b>Edi√ß√£o 18</b> <br><br>  Em seguida, verificaremos v√°rios avisos de <i>System.Private.DataContractSerialization</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharType</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte None = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte FirstName = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Name = <span class="hljs-number"><span class="hljs-number">0x02</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Whitespace = <span class="hljs-number"><span class="hljs-number">0x04</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Text = <span class="hljs-number"><span class="hljs-number">0x08</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte AttributeText = <span class="hljs-number"><span class="hljs-number">0x10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte SpecialWhitespace = <span class="hljs-number"><span class="hljs-number">0x20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byte Comment = <span class="hljs-number"><span class="hljs-number">0x40</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> byte[] s_charType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[<span class="hljs-number"><span class="hljs-number">256</span></span>] { .... CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* 9 (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace| CharType.Text| CharType.SpecialWhitespace, <span class="hljs-comment"><span class="hljs-comment">/* A (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace| CharType.Text| CharType.SpecialWhitespace, <span class="hljs-comment"><span class="hljs-comment">/* B (.) */</span></span> CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* C (.) */</span></span> CharType.None, <span class="hljs-comment"><span class="hljs-comment">/* D (.) */</span></span> CharType.None| CharType.Comment| CharType.Comment| CharType.Whitespace, <span class="hljs-comment"><span class="hljs-comment">/* E (.) */</span></span> CharType.None, .... };</code> </pre> <br>  <b>Avisos do PVS-Studio:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3001</u></a> Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>subexpress√µes</u></a> id√™nticas 'CharType.Comment' √† esquerda e √† direita do '|'  operador.  XmlUTF8TextReader.cs 56 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3001</u></a> Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>subexpress√µes</u></a> id√™nticas 'CharType.Comment' √† esquerda e √† direita do '|'  operador.  XmlUTF8TextReader.cs 58 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3001</u></a> Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>subexpress√µes</u></a> id√™nticas 'CharType.Comment' √† esquerda e √† direita do '|'  operador.  XmlUTF8TextReader.cs 64 </li></ul><br>  O analisador considerou o uso da express√£o <i>CharType.Comment | CharType.Comment</i> suspeito.  Parece um pouco estranho, como <i>(CharType.Comment | CharType.Comment) == CharType.Comment</i> .  Ao inicializar outros elementos da matriz, que usam <i>CharType.Comment</i> , n√£o existe essa duplica√ß√£o. <br><br>  <b>Edi√ß√£o 19</b> <br><br>  Vamos continuar.  Vamos verificar as informa√ß√µes no valor de retorno do m√©todo XmlBinaryWriterSession.TryAdd na descri√ß√£o do m√©todo e em docs.microsoft.com - " <u>M√©todo XmlBinaryWriterSession.TryAdd (XmlDictionaryString, Int32)</u> ": <i>Retorna: true se a string puder ser adicionada;</i>  <i>caso contr√°rio, false.</i> <br><br>  Agora, vamos examinar o corpo do m√©todo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TryAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlDictionaryString value, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> key)</span></span></span><span class="hljs-function"> </span></span>{ IntArray keys; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == null) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> System.Runtime .Serialization .DiagnosticUtility .ExceptionUtility .ThrowHelperArgumentNull(nameof(value)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_maps.TryGetValue(value.Dictionary, out keys)) { key = (keys[value.Key] - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// If the key is already set, then something is wrong throw System.Runtime .Serialization .DiagnosticUtility .ExceptionUtility .ThrowHelperError( new InvalidOperationException( SR.XmlKeyAlreadyExists)); } key = Add(value.Value); keys[value.Key] = (key + 1); return true; } key = Add(value.Value); keys = AddKeys(value.Dictionary, value.Key + 1); keys[value.Key] = (key + 1); return true; }</span></span></code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3009</u></a> √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'true'.  XmlBinaryWriterSession.cs 29 <br><br>  Parece estranho que o m√©todo retorne <i>verdadeiro</i> ou gere uma exce√ß√£o, mas o valor <i>falso</i> nunca √© retornado. <br><br>  <b>Edi√ß√£o 20</b> <br><br>  Me deparei com o c√≥digo com um problema semelhante, mas, neste caso, pelo contr√°rio - o m√©todo sempre retorna <i>false</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnHandleReference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xmlWriter.depth &lt; depthToCheckCyclicReference) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (canContainCyclicReference) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_byValObjectsInScope.Contains(obj)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ....; _byValObjectsInScope.Push(obj); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3009</u></a> √â estranho que esse m√©todo sempre retorne um e o mesmo valor de 'false'.  XmlObjectSerializerWriteContext.cs 415 <br><br>  Bem, j√° percorremos um longo caminho!  Portanto, antes de prosseguir, sugiro que voc√™ fa√ßa uma pequena pausa: agite os m√∫sculos, ande por a√≠, descanse os olhos, olhe pela janela ... <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/008/d6a/92d/008d6a92d6f4cf4066e744e4c857b47d.png" alt="Quadro 24"></div><br>  Espero que neste momento voc√™ esteja cheio de energia novamente, ent√£o vamos continuar.  :) <br><br>  <b>Edi√ß√£o 21</b> <br><br>  Vamos revisar alguns fragmentos envolventes do projeto <i>System.Security.Cryptography.Algorithms</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> override byte[] GenerateMask(byte[] rgbSeed, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cbReturn) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (HashAlgorithm hasher = (HashAlgorithm)CryptoConfig.CreateFromName(_hashNameValue)) { byte[] rgbCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[<span class="hljs-number"><span class="hljs-number">4</span></span>]; byte[] rgbT = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[cbReturn]; uint counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ib = <span class="hljs-number"><span class="hljs-number">0</span></span>; ib &lt; rgbT.Length;) { <span class="hljs-comment"><span class="hljs-comment">// Increment counter -- up to 2^32 * sizeof(Hash) Helpers.ConvertIntToByteArray(counter++, rgbCounter); hasher.TransformBlock(rgbSeed, 0, rgbSeed.Length, rgbSeed, 0); hasher.TransformFinalBlock(rgbCounter, 0, 4); byte[] hash = hasher.Hash; hasher.Initialize(); Buffer.BlockCopy(hash, 0, rgbT, ib, Math.Min(rgbT.Length - ib, hash.Length)); ib += hasher.Hash.Length; } return rgbT; } }</span></span></code> </pre> <br>  <b>Aviso do PVS-Studio:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3080</u></a> Poss√≠vel desrefer√™ncia nula.  Considere inspecionar 'hasher'.  PKCS1MaskGenerationMethod.cs 37 <br><br>  O analisador alerta que o valor da vari√°vel <i>hasher</i> pode ser <i>nulo</i> ao avaliar a express√£o <i>hash.TransformBlock,</i> resultando em uma exce√ß√£o do tipo <i>NullReferenceException</i> .  A ocorr√™ncia deste aviso tornou-se poss√≠vel devido √† an√°lise interprocedural. <br><br>  Portanto, para descobrir se o <i>hasher</i> pode pegar o valor <i>nulo</i> nesse caso, precisamos mergulhar no m√©todo <i>CreateFromName</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFromName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateFromName(name, null); }</code> </pre> <br>  Nada at√© agora - vamos mais fundo.  O corpo da vers√£o <i>CreateFromName</i> sobrecarregada com dois par√¢metros √© bastante grande, ent√£o cito a vers√£o curta. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateFromName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, params object[] args)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retvalType == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cons == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidates.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rci == null || typeof(Delegate).IsAssignableFrom(rci.DeclaringType)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre> <br> As you can see, there are several exit points in the method where the <i>null</i> value is explicitly returned. Therefore, at least theoretically, in the method above, that triggered a warning, an exception of the <i>NullReferenceException</i> type might occur. <br><br> Theory is great, but let's try to reproduce the problem in practice. To do this, we'll take another look at the original method and note the key points. Also, we'll reduce the irrelevant code from the method. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PKCS1MaskGenerationMethod</span></span></span><span class="hljs-class"> :</span></span> .... <span class="hljs-comment"><span class="hljs-comment">// &lt;= 1 { .... public PKCS1MaskGenerationMethod() // &lt;= 2 { _hashNameValue = DefaultHash; } .... public override byte[] GenerateMask(byte[] rgbSeed, int cbReturn) // &lt;= 3 { using (HashAlgorithm hasher = (HashAlgorithm)CryptoConfig.CreateFromName(_hashNameValue)) // &lt;= 4 { byte[] rgbCounter = new byte[4]; byte[] rgbT = new byte[cbReturn]; // &lt;= 5 uint counter = 0; for (int ib = 0; ib &lt; rgbT.Length;) // &lt;= 6 { .... Helpers.ConvertIntToByteArray(counter++, rgbCounter); // &lt;= 7 hasher.TransformBlock(rgbSeed, 0, rgbSeed.Length, rgbSeed, 0); .... } .... } } }</span></span></code> </pre> <br> Let's take a closer look at the key points: <br><br> <b>1, 3</b> . The class and method have <i>public</i> access modifiers. Hence, this interface is available when adding reference to a library ‚Äî we can try reproducing this issue. <br><br> <b>2</b> . The class is non-abstract instance, has a public constructor. It must be easy to create an instance, which we'll work with. In some cases, that I considered, classes were abstract, so to reproduce the issue I had to search for inheritors and ways to obtain them. <br><br> <b>4</b> . <i>CreateFromName</i> mustn't generate any exceptions and must return <i>null</i> ‚Äî the most important point, we'll get back to it later. <br><br> <b>5, 6</b> . The <i>cbReturn</i> value has to be &gt; 0 (but, of course, within adequate limits for the successful creation of an array). Compliance of the <i>cbReturn &gt; 0</i> condition is needed to meet the further condition <i>ib &lt; rgbT.Length</i> and enter the loop body. <br><br> <b>7</b> . <i>Helpres.ConvertIntToByteArray</i> must work without exceptions. <br><br> To meet the conditions that depend on the method parameters, it is enough to simply pass appropriate arguments, for example: <br><br><ul><li> <i>rgbCeed</i> ‚Äî new byte[] { 0, 1, 2, 3 }; </li><li> <i>cbReturn</i> ‚Äî 42. </li></ul><br> In order to ¬´discredit¬ª the <i>CryptoConfig.CreateFromName</i> method, we need to be able to change the value of the <i>_hashNameValue</i> field. Fortunately, we have it, as the class defines a wrapper property for this field: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> HashName { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _hashNameValue; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { _hashNameValue = value ?? DefaultHash; } }</code> </pre> <br> By setting a 'synthetic' value for <i>HashName</i> (that is <i>_hashNameValue),</i> we can get the <i>null</i> value from the <i>CreateFromName</i> method at the first exit point from the ones we marked. I won't go into the details of analyzing this method (hope you'll forgive me for this), as the method is quite large. <br><br> As a result, the code which will lead to an exception of the <i>NullReferenceException</i> type, might look as follows: <br><br><pre> <code class="cpp hljs">PKCS1MaskGenerationMethod tempObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PKCS1MaskGenerationMethod(); tempObj.HashName = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span>; tempObj.GenerateMask(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> byte[] { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br> Now we add reference to the debugging library, run the code and get the expected result: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ab/384/8e5/2ab3848e542172cd92a7e03f55bba9fe.png" alt="Quadro 10"></div><br> Just for the fun of it, I tried to execute the same code using the NuGet package of the 4.3.1 version. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/a94/766/7b4a947666444496ca077e7530415c76.png" alt="Quadro 14"></div><br> There's no information on generated exceptions, limitations of output parameters in the method description. Docs.microsoft.com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>PKCS1MaskGenerationMethod.GenerateMask(Byte[], Int32) Method</u></a> " doesn't specify it either. <br><br> By the way, right when writing the article and describing the order of actions to reproduce the problem, I found 2 more ways to ¬´break¬ª this method: <br><br><ul><li> pass a too large value as a <i>cbReturn</i> argument; </li><li> pass the <i>null</i> value as <i>rgbSeed.</i> </li></ul><br> In the first case, we'll get an exception of the <i>OutOfMemoryException</i> type. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c50/474/7f9/c504747f9a771843da10a128866811dd.png" alt="Quadro 15"></div><br> In the second case, we'll get an exception of the <i>NullReferenceException</i> type when executing the <i>rgbSeed.Length</i> expression. In this case, it's important, that <i>hasher</i> has a non-null value. Otherwise, the control flow won't get to <i>rgbSeed.Length</i> . <br><br> <b>Issue 22</b> <br><br> I came across a couple of similar places. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SignatureDescription</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> FormatterAlgorithm { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> DeformatterAlgorithm { get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignatureDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> AsymmetricSignatureDeformatter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDeformatter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AsymmetricAlgorithm key)</span></span></span><span class="hljs-function"> </span></span>{ AsymmetricSignatureDeformatter item = (AsymmetricSignatureDeformatter) CryptoConfig.CreateFromName(DeformatterAlgorithm); item.SetKey(key); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return item; } public virtual AsymmetricSignatureFormatter CreateFormatter( AsymmetricAlgorithm key) { AsymmetricSignatureFormatter item = (AsymmetricSignatureFormatter) CryptoConfig.CreateFromName(FormatterAlgorithm); item.SetKey(key); // &lt;= return item; } .... }</span></span></code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3080</u></a> Possible null dereference. Consider inspecting 'item'. SignatureDescription.cs 31 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3080</u></a> Possible null dereference. Consider inspecting 'item'. SignatureDescription.cs 38 </li></ul><br> Again, in <i>FormatterAlgorithm</i> and <i>DeformatterAlgorithm</i> properties we can write such values, for which the <i>CryptoConfig.CreateFromName</i> method return the <i>null</i> value in the <i>CreateDeformatter</i> and <i>CreateFormatter</i> methods. Further, when calling the <i>SetKey</i> instance method, a <i>NullReferenceException</i> exception will be generated. The problem, again, is easily reproduced in practice: <br><br><pre> <code class="cpp hljs">SignatureDescription signature = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SignatureDescription() { DeformatterAlgorithm = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span>, FormatterAlgorithm = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span> }; signature.CreateDeformatter(null); <span class="hljs-comment"><span class="hljs-comment">// NRE signature.CreateFormatter(null); // NRE</span></span></code> </pre> <br> In this case, when calling <i>CreateDeformatter</i> as well as calling <i>CreateFormatter</i> , an exception of the <i>NullReferenceException</i> type is thrown. <br><br> <b>Issue 23</b> <br><br> Let's review interesting fragments from the <i>System.Private.Xml</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteBase64</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte[] buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_inAttr &amp;&amp; (_inCDataSection || StartCDataSection())) _wrapped.WriteBase64(buffer, index, count); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> _wrapped.WriteBase64(buffer, index, count); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3004</u></a> The 'then' statement is equivalent to the 'else' statement. QueryOutputWriterV1.cs 242 <br><br> It looks strange that <i>then</i> and <i>else</i> branches of the <i>if</i> statement contain the same code. Either there's an error here and another action has to be made in one of the branches, or the <i>if</i> statement can be omitted. <br><br> <b>Issue 24</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Depends</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlSchemaObject item, ArrayList refs)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeRestriction) { baseType = ((XmlSchemaSimpleTypeRestriction)content).BaseType; baseName = ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeList) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (content is XmlSchemaSimpleTypeRestriction) { baseName = ((XmlSchemaSimpleTypeRestriction)content).BaseTypeName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t == typeof(XmlSchemaSimpleTypeUnion)) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3003</u></a> The use of 'if (A) {...} else if (A) {...}' pattern was detected. There is a probability of logical error presence. Check lines: 381, 396. ImportContext.cs 381 <br><br> In the <i>if-else-if</i> sequence there are two equal conditional expressions ‚Äî <i>content is XmlSchemaSimpleTypeRestriction</i> . What is more, bodies of <i>then</i> branches of respective statements contain a different set of expressions. Anyway, either the body of the first relevant <i>then</i> branch will be executed (if the conditional expression is true), or none of them in case if the relevant expression is false. <br><br> <b>Issue 25</b> <br><br> To make it more intriguing to search for the error in the next method, I'll cite is entire body. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MatchesXmlType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IList&lt;XPathItem&gt; seq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indexType)</span></span></span><span class="hljs-function"> </span></span>{ XmlQueryType typBase = GetXmlType(indexType); XmlQueryCardinality card; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (seq.Count) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: card = XmlQueryCardinality.Zero; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: card = XmlQueryCardinality.One; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: card = XmlQueryCardinality.More; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(card &lt;= typBase.Cardinality)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; typBase = typBase.Prime; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; seq.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!CreateXmlType(seq[<span class="hljs-number"><span class="hljs-number">0</span></span>]).IsSubtypeOf(typBase)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> If you've coped ‚Äî congratulations! <br> If not ‚Äî PVS-Studio to the rescue: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3102</u></a> Suspicious access to element of 'seq' object by a constant index inside a loop. XmlQueryRuntime.cs 738 <br><br> The <i>for</i> loop is executed, the expression <i>i &lt; seq.Count</i> is used as an exit condition. It suggests the idea that developers want to bypass the <i>seq</i> sequence. But in the loop, authors access sequence elements not by using the counter ‚Äî <i>seq[i]</i> , but a number literal ‚Äî zero ( <i>seq[0]</i> ). <br><br> <b>Issue 26</b> <br><br> The next error fits in a small piece of code, but it's no less interesting. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ WriteValue(value); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3110</u></a> Possible infinite recursion inside 'WriteValue' method. XmlAttributeCache.cs 166 <br><br> The method calls itself, forming recursion without an exit condition. <br><br> <b>Issue 27</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IList&lt;XPathNavigator&gt; DocOrderDistinct(IList&lt;XPathNavigator&gt; seq) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (seq.Count &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seq; XmlQueryNodeSequence nodeSeq = (XmlQueryNodeSequence)seq; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nodeSeq == null) nodeSeq = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XmlQueryNodeSequence(seq); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nodeSeq.DocOrderDistinct(_docOrderCmp); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3095</u></a> The 'seq' object was used before it was verified against null. Check lines: 880, 884. XmlQueryRuntime.cs 880 <br><br> The method can get the <i>null</i> value as an argument. Due to this, when accessing the <i>Count</i> property, an exception of the <i>NullReferenceException</i> type will be generated. Below the variable <i>nodeSeq</i> is checked. <i>nodeSeq</i> is obtained as a result of explicit <i>seq</i> casting, still it's not clear why the check takes place. If the <i>seq</i> value is <i>null</i> , the control flow won't get to this check because of the exception. If the <i>seq</i> value isn't <i>null</i> , then: <br><br><ul><li> if casting fails, an exception of the <i>InvalidCastException</i> type will be generated; </li><li> if casting is successful, <i>nodeSeq</i> definitely isn't <i>null</i> . </li></ul><br> <b>Issue 28</b> <br><br> I came across 4 constructors, containing unused parameters. Perhaps, they are left for compatibility, but I found no additional comments on these unused parameters. <br><br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3117</u></a> Constructor parameter 'securityUrl' is not used. XmlSecureResolver.cs 15 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3117</u></a> Constructor parameter 'strdata' is not used. XmlEntity.cs 18 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3117</u></a> Constructor parameter 'location' is not used. Compilation.cs 58 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3117</u></a> Constructor parameter 'access' is not used. XmlSerializationILGen.cs 38 </li></ul><br> The first one interested me the most (at least, it got into the list of warnings for the article). What's so special? Not sure. Perhaps, its name. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">XmlSecureResolver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XmlResolver resolver, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> securityUrl)</span></span></span><span class="hljs-function"> </span></span>{ _resolver = resolver; }</code> </pre> <br> Just for the sake of interest, I checked out what's written at docs.microsoft.com ‚Äî " <u>XmlSecureResolver Constructors</u> " about the <i>securityUrl</i> parameter: <br><br> <i>The URL used to create the PermissionSet that will be applied to the underlying XmlResolver. The XmlSecureResolver calls PermitOnly() on the created PermissionSet before calling GetEntity(Uri, String, Type) on the underlying XmlResolver.</i> <br><br> <b>Issue 29</b> <br><br> In the <i>System.Private.Uri</i> package I found the method, which wasn't following exactly Microsoft guidelines on the <i>ToString</i> method overriding. Here we need to recall one of the tips from the page " <u>Object.ToString Method</u> ": <b><i>Your ToString() override should not throw an exception</i></b> <i>.</i> <br><br> The overridden method itself looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_username.Length == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; _password.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriFormatException(SR.net_uri_BadUserPassword); } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3108</u></a> It is not recommended to throw exceptions from 'ToSting()' method. UriBuilder.cs 406 <br><br> The code first sets an empty string for the <i>_username</i> field and a nonempty one for the <i>_password</i> field respectively through the public properties <i>UserName</i> and <i>Password.</i> After that it calls the <i>ToString</i> method. Eventually this code will get an exception. An example of such code: <br><br><pre> <code class="cpp hljs">UriBuilder uriBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriBuilder() { UserName = String.Empty, Password = <span class="hljs-string"><span class="hljs-string">"Dummy"</span></span> }; String stringRepresentation = uriBuilder.ToString(); Console.WriteLine(stringRepresentation);</code> </pre> <br> But in this case developers honestly warn that calling might result in an exception. It is described in comments to the method and at docs.microsoft.com ‚Äî " <u>UriBuilder.ToString Method</u> ". <br><br> <b>Issue 30</b> <br><br> Look at the warnings, issued on the <i>System.Data.Common</i> project code. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ArrayList _tables; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> DataTable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tableName, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ns)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_tables.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (DataTable)_tables[<span class="hljs-number"><span class="hljs-number">0</span></span>]; .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3106</u></a> Possibly index is out of bound. The '0' index is pointing beyond '_tables' bound. XMLDiffLoader.cs 277 <br><br> Does this piece of code look unusual? What do you think it is? An unusual way to generate an exception of the <i>ArgumentOutOfRangeException</i> type? I wouldn't be surprised by this approach. Overall, it's very strange and suspicious code. <br><br> <b>Issue 31</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal XmlNodeOrder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComparePosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(XPathNodePointer other)</span></span></span><span class="hljs-function"> </span></span>{ RealFoliate(); other.RealFoliate(); Debug.Assert(other != null); .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3095</u></a> The 'other' object was used before it was verified against null. Check lines: 1095, 1096. XPathNodePointer.cs 1095 <br><br> The expression <i>other != null</i> as an argument of the <i>Debug.Assert</i> method suggests, that the <i>ComparePosition</i> method can obtain the <i>null</i> value as an argument. At least, the intention was to catch such cases. But at the same time, the line above the <i>other.RealFoliate</i> instance method is called. As a result, if <i>other</i> has the <i>null</i> value, an exception of the <i>NullReferenceException</i> type will be generated before checking through <i>Assert</i> . <br><br> <b>Issue 32</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> PropertyDescriptorCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Attribute[] attributes)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (Attribute attribute in attributes) { Attribute attr = property.Attributes[attribute.GetType()]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (attr == null &amp;&amp; !attribute.IsDefaultAttribute()) || !attr.Match(attribute)) { match = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3080</u></a> Possible null dereference. Consider inspecting 'attr'. DbConnectionStringBuilder.cs 534 <br><br> Conditional expression of the <i>if</i> statement looks quite suspicious. <i>Match</i> is an instance method. According to the check <i>attr == null</i> , <i>null</i> is the acceptable (expected) value for this variable. Therefore, if control flow gets to the right operand of the || operator (if <i>attr</i> ‚Äî <i>null</i> ), we'll get an exception of the <i>NullReferenceException</i> type. <br><br> Accordingly, conditions of the exception occurrence are the following: <br><br><ol><li> The value of <i>attr</i> ‚Äî <i>null</i> . The right operand of the &amp;&amp; operator is evaluated. </li><li> The value of <i>!attribute.IsDefaultAttribute()</i> ‚Äî <i>false</i> . The overall result of the expression with the &amp;&amp; operator ‚Äî <i>false</i> . </li><li> Since the left operand of the || operator is of the <i>false</i> value, the right operand is evaluated. </li><li> Since <i>attr</i> ‚Äî <i>null</i> , when calling the <i>Match</i> method, an exception is generated. </li></ol><br> <b>Issue 33</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadOldRowData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DataSet ds, ref DataTable table, ref </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos, XmlReader row)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (table == null) { row.Skip(); <span class="hljs-comment"><span class="hljs-comment">// need to skip this element if we dont know about it, // before returning -1 return -1; } .... if (table == null) throw ExceptionBuilder.DiffgramMissingTable( XmlConvert.DecodeName(row.LocalName)); .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3021</u></a> There are two 'if' statements with identical conditional expressions. The first 'if' statement contains method return. This means that the second 'if' statement is senseless XMLDiffLoader.cs 301 <br><br> There are two <i>if</i> statements, containing the equal expression ‚Äî <i>table == null</i> . With that, <i>then</i> branches of these statements contain different actions ‚Äî in the first case, the method exits with the value -1, in the second one ‚Äî an exception is generated. The <i>table</i> variable isn't changed between the checks. Thus, the considered exception won't be generated. <br><br> <b>Issue 34</b> <br><br> Look at the interesting method from the <i>System.ComponentModel.TypeConverter</i> project. Well, let's first read the comment, describing it: <br><br> <i>Removes the last character from the formatted string. (Remove last character in virtual string). On exit the out param contains the position where the operation was actually performed. This position is relative to the test string. The MaskedTextResultHint out param gives more information about the operation result. Returns</i> <b><i>true</i></b> <i>on success,</i> <b><i>false</i></b> <i>otherwise.</i> <br><br> The key point on the return value: if an operation is successful, the method returns <i>true</i> , otherwise ‚Äî <i>false</i> . Let's see what happens in fact. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> testPosition, out MaskedTextResultHint resultHint)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lastAssignedPos == INVALID_INDEX) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// nothing to remove. } .... return true; }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3009</u></a> It's odd that this method always returns one and the same value of 'true'. MaskedTextProvider.cs 1529 <br><br> In fact, it turns out that the only return value of the method is <i>true</i> . <br><br> <b>Issue 35</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_table != null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_table.fInitInProgress &amp;&amp; _delayLoadingConstraints != null) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3125</u></a> The '_table' object was used after it was verified against null. Check lines: 437, 423. ConstraintCollection.cs 437 <br><br> The <i>_table != null</i> check speaks for itself ‚Äî the <i>_table</i> variable can have the <i>null</i> value. At least, in this case code authors get reinsured. However, below they address the instance field via <i>_table</i> but without the check for <i>null</i> ‚Äî <i>_table .fInitInProgress</i> . <br><br> <b>Issue 36</b> <br><br> Now let's consider several warnings, issued for the code of the <i>System.Runtime.Serialization.Formatters</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (memberNameInfo != null) { .... _serWriter.WriteObjectEnd(memberNameInfo, typeNameInfo); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((objectInfo._objectId == _topId) &amp;&amp; (_topName != null)) { _serWriter.WriteObjectEnd(topNameInfo, typeNameInfo); .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ReferenceEquals(objectInfo._objectType, Converter.s_typeofString)) { _serWriter.WriteObjectEnd(typeNameInfo, typeNameInfo); } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3038</u></a> The argument was passed to method several times. It is possible that other argument should be passed instead. BinaryObjectWriter.cs 262 <br><br> The analyzer was confused by the last call <i>_serWriter.WriteObjectEnd</i> with two equal arguments ‚Äî <i>typeNameInfo</i> . It looks like a typo, but I can't say for sure. I decided to check out what is the callee <i>WriteObjectEnd</i> method. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteObjectEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NameInfo memberNameInfo, NameInfo typeNameInfo)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br> Well‚Ä¶ Let's move on.  :) <br><br> <b>Issue 37</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteSerializationHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> headerId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minorVersion, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> majorVersion)</span></span></span><span class="hljs-function"> </span></span>{ var record = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationHeaderRecord( BinaryHeaderEnum.SerializedStreamHeader, topId, headerId, minorVersion, majorVersion); record.Write(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br> When reviewing this code, I wouldn't say at once what's wrong here or what looks suspicious. But the analyzer may well say what's the thing. <br><br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3066</u></a> Possible incorrect order of arguments passed to 'SerializationHeaderRecord' constructor: 'minorVersion' and 'majorVersion'. BinaryFormatterWriter.cs 111 <br><br> See the callee constructor of the <i>SerializationHeaderRecord</i> class. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SerializationHeaderRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( BinaryHeaderEnum binaryHeaderEnum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> topId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> headerId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> majorVersion, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minorVersion)</span></span></span><span class="hljs-function"> </span></span>{ _binaryHeaderEnum = binaryHeaderEnum; _topId = topId; _headerId = headerId; _majorVersion = majorVersion; _minorVersion = minorVersion; }</code> </pre> <br> As we can see, constructor's parameters follow in the order <i>majorVersion</i> , <i>minorVersion</i> ; whereas when calling the constructor they are passed in this order: <i>minorVersion</i> , <i>majorVersion</i> . Seems like a typo. In case it was made deliberately (what if?) ‚Äî I think it would require an additional comment. <br><br> <b>Issue 38</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ISurrogateSelector selector, StreamingContext context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> checkSecurity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isCrossAppDomain)</span></span></span><span class="hljs-function"> </span></span>{ _objects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectHolder[DefaultInitialSize]; _selector = selector; _context = context; _isCrossAppDomain = isCrossAppDomain; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3117</u></a> Constructor parameter 'checkSecurity' is not used. ObjectManager.cs 33 <br><br> The <i>checkSecurity</i> parameter of the constructor isn't used in any way. There are no comments on it. I guess it's left for compatibility, but anyway, in the context of recent security conversations, it looks interesting. <br><br> <b>Issue 39</b> <br><br> Here's the code that seemed unusual to me. The pattern looks one and the same in all three detected cases and is located in methods with equal names and variables names. Consequently: <br><br><ul><li> either I'm not enlightened enough to get the purpose of such duplication; </li><li> or the error was spread by the copy-paste method. </li></ul><br> The code itself: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnlargeArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLength = _values.Length * <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newLength &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newLength == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializationException(SR.Serialization_TooManyElements); } newLength = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; } FixupHolder[] temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FixupHolder[newLength]; Array.Copy(_values, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">0</span></span>, _count); _values = temp; }</code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3022</u></a> Expression 'newLength == int.MaxValue' is always false. ObjectManager.cs 1423 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3022</u></a> Expression 'newLength == int.MaxValue' is always false. ObjectManager.cs 1511 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3022</u></a> Expression 'newLength == int.MaxValue' is always false. ObjectManager.cs 1558 </li></ul><br> What is different in other methods is the type of the <i>temp</i> array elements (not <i>FixupHolder</i> , but <i>long</i> or <i>object</i> ). So I still have suspicions of copy-paste‚Ä¶ <br><br> <b>Issue 40</b> <br><br> Code from the <i>System.Data.Odbc</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnquoteIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(quotePrefix) || quotePrefix != <span class="hljs-string"><span class="hljs-string">" "</span></span>) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3022</u></a> Expression '!string.IsNullOrEmpty(quotePrefix) || quotePrefix != " "' is always true. OdbcCommandBuilder.cs 338 <br><br> The analyzer assumes that the given expression always has the <i>true</i> value. It is really so. It even doesn't matter what value is actually in <i>quotePrefix</i> ‚Äî the condition itself is written incorrectly. Let's get to the bottom of this. <br><br> We have the || operator, so the expression value will be <i>true</i> , if the left or right (or both) operand will have the <i>true</i> value. It's all clear with the left one. The right one will be evaluated only in case if the left one has the <i>false</i> value. This means, if the expression is composed in the way that the value of the right operand is always <i>true</i> when the value of the left one is <i>false</i> , the result of the entire expression will permanently be <i>true</i> . <br><br> From the code above we know that if the right operand is evaluated, the value of the expression <i>string.IsNullOrEmpty(quotePrefix)</i> ‚Äî <i>true</i> , so one of these statements is true: <br><br><ul><li> <i>quotePrefix == null</i> ; </li><li> <i>quotePrefix.Length == 0</i> . </li></ul><br> If one of these statements is true, the expression <i>quotePrefix != " "</i> will also be true, which we wanted to prove. Meaning that the value of the entire expression is always <i>true</i> , regardless of the <i>quotePrefix</i> contents. <br><br> <b>Issue 41</b> <br><br> Going back to constructors with unused parameters: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> sealed <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PendingGetConnection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PendingGetConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dueTime, DbConnection owner, TaskCompletionSource&lt;DbConnectionInternal&gt; completion, DbConnectionOptions userOptions)</span></span></span><span class="hljs-function"> </span></span>{ DueTime = dueTime; Owner = owner; Completion = completion; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> DueTime { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DbConnection Owner { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TaskCompletionSource&lt;DbConnectionInternal&gt; Completion { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DbConnectionOptions UserOptions { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3117</u></a> Constructor parameter 'userOptions' is not used. DbConnectionPool.cs 26 <br><br> We can see from the analyzer warnings and the code, that only one constructor's parameter isn't used <i>‚Äî userOptions</i> , and others are used for initializing same-name properties. It looks like a developer forgot to initialize one of the properties. <br><br> <b>Issue 42</b> <br><br> There's suspicious code, that we've come across 2 times. The pattern is the same. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> DataTable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteCommand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (DataRow row in schemaTable.Rows) { resultTable.Columns .Add(row[<span class="hljs-string"><span class="hljs-string">"ColumnName"</span></span>] as <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, (Type)row[<span class="hljs-string"><span class="hljs-string">"DataType"</span></span>] as Type); } .... }</code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3051</u></a> An excessive type cast. The object is already of the 'Type' type. DbMetaDataFactory.cs 176 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3051</u></a> An excessive type cast. The object is already of the 'Type' type. OdbcMetaDataFactory.cs 1109 </li></ul><br> The expression <i>(Type)row[¬´DataType¬ª] as Type</i> looks suspicious. First, explicit casting will be performed, after that ‚Äî casting via the <i>as</i> operator. If the value <i>row[¬´DataType¬ª]</i> ‚Äî <i>null,</i> it will successfully 'pass' through both castings and will do as an argument to the <i>Add</i> method. If <i>row[¬´DataType¬ª]</i> returns the value, which cannot be casted to the <i>Type</i> type, an exception of the <i>InvalidCastException</i> type will be generated right during the explicit cast. In the end, why do we need two castings here? The question is open. <br><br> <b>Issue 43</b> <br><br> Let's look at the suspicious fragment from <i>System.Runtime.InteropServices.RuntimeInformation</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> FrameworkDescription { get { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s_frameworkDescription == null) { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> versionString = (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)AppContext.GetData(<span class="hljs-string"><span class="hljs-string">"FX_PRODUCT_VERSION"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (versionString == null) { .... versionString = typeof(object).Assembly .GetCustomAttribute&lt; AssemblyInformationalVersionAttribute&gt;() ?.InformationalVersion; .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> plusIndex = versionString.IndexOf(<span class="hljs-string"><span class="hljs-string">'+'</span></span>); .... } .... } .... } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3105</u></a> The 'versionString' variable was used after it was assigned through null-conditional operator. NullReferenceException is possible. RuntimeInformation.cs 29 <br><br> The analyzer warns about a possible exception of the <i>NullReferenceException</i> type when calling the <i>IndexOf</i> method for the <i>versionString</i> variable. When receiving the value for a variable, code authors use the '?.' operator to avoid a <i>NullReferenceException</i> exception when accessing the <i>InfromationalVersion</i> property. The trick is that if the call of <i>GetCustomAttribute&lt;...&gt;</i> returns <i>null</i> , an exception will still be generated, but below ‚Äî when calling the <i>IndexOf</i> method, as <i>versionString</i> will have the <i>null</i> value. <br><br> <b>Issue 44</b> <br><br> Let's address the <i>System.ComponentModel.Composition</i> project and look through several warnings. Two warnings were issued for the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CanSpecialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... object[] genericParameterConstraints = ....; GenericParameterAttributes[] genericParameterAttributes = ....; <span class="hljs-comment"><span class="hljs-comment">// if no constraints and attributes been specifed, anything can be created if ((genericParameterConstraints == null) &amp;&amp; (genericParameterAttributes == null)) { return true; } if ((genericParameterConstraints != null) &amp;&amp; (genericParameterConstraints.Length != partArity)) { return false; } if ((genericParameterAttributes != null) &amp;&amp; (genericParameterAttributes.Length != partArity)) { return false; } for (int i = 0; i &lt; partArity; i++) { if (!GenericServices.CanSpecialize( specialization[i], (genericParameterConstraints[i] as Type[]). CreateTypeSpecializations(specialization), genericParameterAttributes[i])) { return false; } } return true; }</span></span></code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3125</u></a> The 'genericParameterConstraints' object was used after it was verified against null. Check lines: 603, 589. GenericSpecializationPartCreationInfo.cs 603 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3125</u></a> The 'genericParameterAttributes' object was used after it was verified against null. Check lines: 604, 594. GenericSpecializationPartCreationInfo.cs 604 </li></ul><br> In code there are checks <i>genericParameterAttributes != null</i> and <i>genericParameterConstraints != null</i> . Therefore, <i>null</i> ‚Äî acceptable values for these variables, we'll take it into account. If both variables have the <i>null</i> value, we'll exit the method, no questions. What if one of two variables mentioned above is <i>null</i> , but in doing so we don't exit the method? If such case is possible and execution gets to traversing the loop, we'll get an exception of the <i>NullReferenceException</i> type. <br><br> <b>Issue 45</b> <br><br> Next we'll move to another interesting warning from this project. And though, let's do something different ‚Äî first we'll use the class again, and then look at the code. Next, we'll add reference to the same-name NuGet package of the last available prerelease version in the project (I installed the package of the version 4.6.0-preview6.19303.8). Let's write simple code, for example, such as: <br><br><pre> <code class="cpp hljs">LazyMemberInfo lazyMemberInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LazyMemberInfo(); var eq = lazyMemberInfo.Equals(null); Console.WriteLine(eq);</code> </pre> <br> The <i>Equals</i> method isn't commented, I didn't find this method description for .NET Core at docs.microsoft.com, only for .NET Framework. If we look at it (" <u>LazyMemberInfo.Equals(Object) Method</u> ") ‚Äî we won't see anything special whether it returns <i>true</i> or <i>false</i> , there is no information on generated exceptions. We'll execute the code and see: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e5/8f7/aa4/8e58f7aa4e5a274751cde57da4d9497f.png" alt="Quadro 16"></div><br> We can get a little twisted and write the following code and also get interesting output: <br><br><pre> <code class="cpp hljs">LazyMemberInfo lazyMemberInfo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LazyMemberInfo(); var eq = lazyMemberInfo.Equals(typeof(String)); Console.WriteLine(eq);</code> </pre> <br> The result of the code execution. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e74/199/292/e74199292d39b2df8a7b205218c9c1fe.png" alt="Quadro 17"></div><br><br> Interestingly, these both exceptions are generated in the same expression. Let's look insidethe <i>Equals</i> method. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object obj)</span></span></span><span class="hljs-function"> </span></span>{ LazyMemberInfo that = (LazyMemberInfo)obj; <span class="hljs-comment"><span class="hljs-comment">// Difefrent member types mean different members if (_memberType != that._memberType) { return false; } // if any of the lazy memebers create accessors in a delay-loaded fashion, // we simply compare the creators if ((_accessorsCreator != null) || (that._accessorsCreator != null)) { return object.Equals(_accessorsCreator, that._accessorsCreator); } // we are dealing with explicitly passed accessors in both cases if(_accessors == null || that._accessors == null) { throw new Exception(SR.Diagnostic_InternalExceptionMessage); } return _accessors.SequenceEqual(that._accessors); }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3115</u></a> Passing 'null' to 'Equals' method should not result in 'NullReferenceException'. LazyMemberInfo.cs 116 <br><br> Actually in this case the analyzer screwed up a bit, as it issued a warning for the <i>that._memberType</i> expression. However, exceptions occur earlier when executing the expression <i>(LazyMemberInfo)obj</i> . We've already made a note of it. <br><br> I think it's all clear with <i>InvalidCastException.</i> Why is <i>NullReferenceException</i> generated? The fact is that <i>LazyMemberInfo</i> is a struct, therefore, it gets unboxed. The <i>null</i> value unboxing, in turns, leads to occurrence of an exception of the <i>NullReferenceException</i> type. Also there is a couple of typos in comments ‚Äî authors should probably fix them. An explicit exception throwing is still on the authors hands. <br><br> <b>Issue 46</b> <br><br> By the way, I came across a similar case in <i>System.Drawing.Common</i> in the <i>TriState</i> structure. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object o)</span></span></span><span class="hljs-function"> </span></span>{ TriState state = (TriState)o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value == state._value; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3115</u></a> Passing 'null' to 'Equals' method should not result in 'NullReferenceException'. TriState.cs 53 <br><br> The problems are the same as in the case described above. <br><br> <b>Issue 47</b> <br><br> Let's consider several fragments from <i>System.Text.Json</i> . <br><br> Remember I wrote that <i>ToString</i> mustn't return <i>null</i> ? Time to solidify this knowledge. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (TokenType) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.None: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.Null: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.True: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>.TrueString; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.False: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>.FalseString; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.Number: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.StartArray: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> JsonTokenType.StartObject: { <span class="hljs-comment"><span class="hljs-comment">// null parent should have hit the None case Debug.Assert(_parent != null); return _parent.GetRawValueAsString(_idx); } case JsonTokenType.String: return GetString(); case JsonTokenType.Comment: case JsonTokenType.EndArray: case JsonTokenType.EndObject: default: Debug.Fail($"No handler for {nameof(JsonTokenType)}.{TokenType}"); return string.Empty; } }</span></span></code> </pre> <br> At first sight, this method doesn't return <i>null</i> , but the analyzer argues the converse. <br><br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3108</u></a> It is not recommended to return 'null' from 'ToSting()' method. JsonElement.cs 1460 <br><br> The analyzer points to the line with calling the <i>GetString()</i> method. Let's have a look at it. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CheckValidInstance(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _parent.GetString(_idx, JsonTokenType.String); }</code> </pre> <br> Let's go deeper in the overloaded version of the <i>GetString</i> method: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, JsonTokenType expectedType)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tokenType == JsonTokenType.Null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } .... }</code> </pre> <br> Right after we see the condition, whose execution will result in the <i>null</i> value ‚Äî both from this method and <i>ToString</i> which we initially considered. <br><br> <b>Issue 48</b> <br><br> Another interesting fragment: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal JsonPropertyInfo </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatePolymorphicProperty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ JsonPropertyInfo runtimeProperty = CreateProperty(property.DeclaredPropertyType, runtimePropertyType, property.ImplementedPropertyType, property?.PropertyInfo, Type, options); property.CopyRuntimeSettingsTo(runtimeProperty); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> runtimeProperty; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3042</u></a> Possible NullReferenceException. The '?.' and '.' operators are used for accessing members of the 'property' object JsonClassInfo.AddProperty.cs 179 <br><br> When calling the <i>CreateProperty</i> method, properties are referred several times through the variable <i>property</i> : <i>property.DeclaredPropertyType</i> , <i>property.ImplementedPropertyType</i> , <i>property?.PropertyInfo</i> . As you can see, in one case code authors use the '?.'  operador. If it's not out of place here and <i>property</i> can have the <i>null</i> value, this operator won't be of any help, as an exception of the <i>NullReferenceException</i> type will be generated with direct access. <br><br> <b>Issue 49</b> <br><br> The following suspicious fragments were found in the <i>System.Security.Cryptography.Xml</i> project. They are paired up, the same as it has been several times with other warnings. Again, the code looks like copy-paste, compare these yourself. <br><br> The first fragment: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StringBuilder strBuilder, DocPosition docPos, AncestralNamespaceContextManager anc)</span></span></span><span class="hljs-function"> </span></span>{ docPos = DocPosition.BeforeRootElement; foreach (XmlNode childNode in ChildNodes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childNode.NodeType == XmlNodeType.Element) { CanonicalizationDispatcher.Write( childNode, strBuilder, DocPosition.InRootElement, anc); docPos = DocPosition.AfterRootElement; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CanonicalizationDispatcher.Write(childNode, strBuilder, docPos, anc); } } }</code> </pre> <br> The second fragment. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteHash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HashAlgorithm hash, DocPosition docPos, AncestralNamespaceContextManager anc)</span></span></span><span class="hljs-function"> </span></span>{ docPos = DocPosition.BeforeRootElement; foreach (XmlNode childNode in ChildNodes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (childNode.NodeType == XmlNodeType.Element) { CanonicalizationDispatcher.WriteHash( childNode, hash, DocPosition.InRootElement, anc); docPos = DocPosition.AfterRootElement; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CanonicalizationDispatcher.WriteHash(childNode, hash, docPos, anc); } } }</code> </pre> <br> <b>PVS-Studio warnings:</b> <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3061</u></a> Parameter 'docPos' is always rewritten in method body before being used. CanonicalXmlDocument.cs 37 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3061</u></a> Parameter 'docPos' is always rewritten in method body before being used. CanonicalXmlDocument.cs 54 </li></ul><br> In both methods the <i>docPos</i> parameter is overwritten before its value is used. Therefore, the value, used as a method argument, is simply ignored. <br><br> <b>Issue 50</b> <br><br> Let's consider several warnings on the code of the <i>System.Data.SqlClient</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsBOMNeeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MetaType type, object value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.NullableType == TdsEnums.SQLXMLTYPE) { Type currentType = value.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(SqlString)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((SqlString)value).IsNull &amp;&amp; ((((SqlString)value).Value).Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((((SqlString)value).Value[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) != <span class="hljs-number"><span class="hljs-number">0xff</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((currentType == typeof(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)) &amp;&amp; (((String)value).Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((value != null) &amp;&amp; (((<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) != <span class="hljs-number"><span class="hljs-number">0xff</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(SqlXml)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((SqlXml)value).IsNull) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == typeof(XmlDataFeed)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Values will eventually converted to unicode string here } } return false; }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3095</u></a> The 'value' object was used before it was verified against null. Check lines: 8696, 8708. TdsParser.cs 8696 <br><br> The analyzer was confused by the check <i>value != null</i> in one of the conditions. It seems like it was lost there during refactoring, as <i>value</i> gets dereferenced many times. If <i>value</i> can have the <i>null</i> value ‚Äî things are bad. <br><br> <b>Issue 51</b> <br><br> The next error is from tests, but it seemed interesting to me, so I decided to cite it. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> TDSMessageCollection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateQueryResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"name"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"state"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"databases"</span></span>) &amp;&amp; lowerBatchText.Contains(<span class="hljs-string"><span class="hljs-string">"db_name"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// SELECT [name], [state] FROM [sys].[databases] WHERE [name] = db_name() { // Delegate to current database response responseMessage = _PrepareDatabaseResponse(session); } .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3053</u></a> An excessive expression. Examine the substrings 'name' and 'db_name'. QueryEngine.cs 151 <br><br> The fact is that in this case the combination of subexpressions <i>lowerBatchText.Contains(¬´name¬ª)</i> and <i>lowerBatchText.Contains(¬´db_name¬ª)</i> is redundant. Indeed, if the checked string contains the substring <i>¬´db_name¬ª</i> , it will contain the <i>¬´name¬ª</i> substring as well. If the string doesn't contain <i>¬´name¬ª</i> , it won't contain <i>¬´db_name¬ª</i> either. As a result, it turns out that the check <i>lowerBatchText.Contains(¬´name¬ª)</i> is redundant. Unless it can reduce the number of evaluated expressions, if the checked string doesn't contain <i>¬´name¬ª</i> . <br><br> <b>Issue 52</b> <br><br> A suspicious fragment from the code of the <i>System.Net.Requests</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override PipelineInstruction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PipelineCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( PipelineEntry entry, ResponseDescription response, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) NetEventSource.Info(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, $<span class="hljs-string"><span class="hljs-string">"Command:{entry?.Command} Description:{response?.StatusDescription}"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// null response is not expected if (response == null) return PipelineInstruction.Abort; .... if (entry.Command == "OPTS utf8 on\r\n") .... .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3125</u></a> The 'entry' object was used after it was verified against null. Check lines: 270, 227. FtpControlStream.cs 270 <br><br> When composing an interpolated string, such expressions as <i>entry?.Command</i> and <i>response?.Description</i> are used. The '?.' operator is used instead of the '.' operator not to get an exception of the <i>NullReferenceException</i> type in case if any of the corresponding parameters has the <i>null</i> value. In this case, this technique works. Further, as we can see from the code, a possible <i>null</i> value for <i>response</i> gets split off (exit from the method if <i>response == null</i> ), whereas there's nothing similar for <i>entry.</i> As a result, if <i>entry</i> ‚Äî <i>null</i> further along the code when evaluating <i>entry.Command</i> (with the usage of '.', not '?.'), an exception will be generated. <br><br> At this point, a fairly detailed code review is waiting for us, so I suggest that you have another break ‚Äî chill out, make some tea or coffee. After that I'll be right here to continue. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/3fc/f07/56a3fcf075284f021a56249627e518bb.png" alt="Quadro 21"></div><br> Are you back? Then let's keep going.  :) <br><br> <b>Issue 53</b> <br><br> Now let's find something interesting in the <i>System.Collections.Immutable</i> project. This time we'll have some experiments with the <i>System.Collections.Immutable.ImmutableArray&lt;T&gt;</i> struct. The methods <i>IStructuralEquatable.Equals</i> and <i>IStructuralComparable.CompareTo</i> are of special interest for us. <br><br> Let's start with the <i>IStructuralEquatable.Equals</i> method. The code is given below, I suggest that you try to get what's wrong yourself: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; Array otherArray = other as Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray == null) { var theirs = other as IImmutableArray; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (theirs != null) { otherArray = theirs.Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } } IStructuralEquatable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.Equals(otherArray, comparer); }</code> </pre> <br> Did you manage? If yes ‚Äî my congrats.  :) <br><br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3125</u></a> The 'ours' object was used after it was verified against null. Check lines: 1212, 1204. ImmutableArray_1.cs 1212 <br><br> The analyzer was confused by the call of the instance <i>Equals</i> method through the <i>ours</i> variable, located in the last <i>return</i> expression, as it suggests that an exception of the <i>NullReferenceException</i> type might occur here. Why does the analyzer suggest so? To make it easier to explain, I'm giving a simplified code fragment of the same method below. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null) { .... } } } IStructuralEquatable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.Equals(otherArray, comparer); }</code> </pre> <br> In the last expressions, we can see, that the value of the <i>ours</i> variable comes from <i>self.array</i> . The check <i>self.array == null</i> is performed several times above. Which means, <i>ours,</i> the same as <i>self.array,</i> can have the <i>null</i> value. At least in theory. Is this state reachable in practice? Let's try to find out. To do this, once again I cite the body of the method with set key points. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IStructuralEquatable.Equals(object other, IEqualityComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= 1 Array otherArray = other as Array; if (otherArray == null) // &lt;= 2 { var theirs = other as IImmutableArray; if (theirs != null) // &lt;= 3 { otherArray = theirs.Array; if (self.array == null &amp;&amp; otherArray == null) { return true; } else if (self.array == null) // &lt;= 4 { return false; } } IStructuralEquatable ours = self.array; // &lt;= 5 return ours.Equals(otherArray, comparer); }</span></span></code> </pre> <br> <b>Key point 1.</b> <i>self.array == this.array</i> (due to <i>self = this</i> ). Therefore, before calling the method, we need to get the condition <i>this.array == null</i> . <br><br> <b>Key point 2</b> . We can ignore this <i>if</i> , which will be the simplest way to get what we want. To ignore this <i>if</i> , we only need the <i>other</i> variable to be of the <i>Array</i> type or a derived one, and not to contain the <i>null</i> value. This way, after using the <i>as</i> operator, a non-null reference will be written in <i>otherArray</i> and we'll ignore the first <i>if</i> statement <i>.</i> <br><br> <b>Key point 3</b> . This point requires a more complex approach. We definitely need to exit on the second <i>if</i> statement (the one with the conditional expression <i>theirs != null</i> ). If it doesn't happen and <i>then</i> branch starts to execute, most certainly we won't get the needed point 5 under the condition <i>self.array == null</i> due to the key point 4. To avoid entering the <i>if</i> statement of the key point 3, one of these conditions has to be met: <br><br><ul><li> the <i>other</i> value has to be <i>null</i> ; </li><li> the actual <i>other</i> type mustn't implement the <i>IImmutableArray</i> interface. </li></ul><br> <b>Key point 5</b> . If we get to this point with the value <i>self.array == null</i> , it means that we've reached our aim, and an exception of the <i>NullReferenceException</i> type will be generated. <br><br> We get the following datasets that will lead us to the needed point. <br><br> First: <i>this.array ‚Äî null</i> . <br><br> Second ‚Äî one of the following ones: <br><br><ul><li> <i>other</i> ‚Äî <i>null</i> ; </li><li> <i>other</i> has the <i>Array</i> type or one derived from it; </li><li> <i>other</i> doesn't have the <i>Array</i> type or a derived from it and in doing so, doesn't implement the <i>IImmutableArray</i> interface. </li></ul><br> <i>array</i> is the field, declared in the following way: <br><br><pre> <code class="cpp hljs">internal T[] <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>;</code> </pre> <br> As <i>ImmutableArray&lt;T&gt;</i> is a structure, it has a default constructor (without arguments) that will result in the <i>array</i> field taking value by default, which is <i>null.</i> And that's what we need. <br><br> Let's not forget that we were investigating an explicit implementation of the interface method, therefore, casting has to be done before the call. <br><br> Now we have the game in hands to reach the exception occurrence in three ways. We add reference to the debugging library version, write the code, execute and see what happens. <br><br> <b>Code fragment 1.</b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(null, comparer);</code> </pre> <br> <b>Code fragment 2.</b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] { }, comparer);</code> </pre> <br> <b>Code fragment 3.</b> <br><br><pre> <code class="cpp hljs">var comparer = EqualityComparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralEquatable)immutableArray).Equals(typeof(Object), comparer);</code> </pre> <br> The execution result of all three code fragments will be the same, only achieved by different input entry data, and execution paths. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/a3b/e8a/13aa3be8a0b68a646aee130773f2c862.png" alt="Quadro 18"></div><br> <b>Issue 54</b> <br><br> If you didn't forget, we have another method that we need to discredit. :) But this time we won't cover it in such detail. Moreover, we already know some information from the previous example. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IStructuralComparable.CompareTo(object other, IComparer comparer) { var self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; Array otherArray = other as Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray == null) { var theirs = other as IImmutableArray; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (theirs != null) { otherArray = theirs.Array; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null &amp;&amp; otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> == null ^ otherArray == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentException( SR.ArrayInitializedStateNotEqual, nameof(other)); } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherArray != null) { IStructuralComparable ours = self.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ours.CompareTo(otherArray, comparer); <span class="hljs-comment"><span class="hljs-comment">// &lt;= } throw new ArgumentException(SR.ArrayLengthsNotEqual, nameof(other)); }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3125</u></a> The 'ours' object was used after it was verified against null. Check lines: 1265, 1251. ImmutableArray_1.cs 1265 <br><br> As you can see, the case is very similar to the previous example. <br><br> Let's write the following code: <br><br><pre> <code class="cpp hljs">Object other = ....; var comparer = Comparer&lt;String&gt;.Default; ImmutableArray&lt;String&gt; immutableArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImmutableArray&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(); ((IStructuralComparable)immutableArray).CompareTo(other, comparer);</code> </pre> <br> We'll try to find some entry data to reach the point, where exception of the <i>NullReferenceException</i> type might occur: <br><br> <b>Value:</b> <i>other</i> ‚Äî <i>new String[]{ }</i> ; <br><br> Result: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/d77/08a/eefd7708a187f5060f2074e642f18434.png" alt="Quadro 22"></div><br> Thus, we again managed to figure out such data, with which an exception occurs in the method. <br><br> <b>Issue 55</b> <br><br> In the <i>System.Net.HttpListener</i> project I stumbled upon several both suspicious and very similar places. Once again, I can't shake the feeling about copy-paste, taking place here. Since the pattern is the same, we'll look at one code example. I'll cite analyzer warnings for the rest cases. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override IAsyncResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byte[] buffer, ....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NetEventSource.IsEnabled) { NetEventSource.Enter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); NetEventSource.Info(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"buffer.Length:"</span></span> + buffer.Length + <span class="hljs-string"><span class="hljs-string">" size:"</span></span> + size + <span class="hljs-string"><span class="hljs-string">" offset:"</span></span> + offset); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(nameof(buffer)); } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3095</u></a> The 'buffer' object was used before it was verified against null. Check lines: 51, 53. HttpRequestStream.cs 51 <br><br> Generation of an exception of the <i>ArgumentNullException</i> type under the condition <i>buffer == null</i> obviously suggests that <i>null</i> is an unacceptable value for this variable. However, if the value of the <i>NetEventSource.IsEnabled</i> expression is <i>true</i> and <i>buffer</i> ‚Äî <i>null</i> , when evaluating the <i>buffer.Length</i> expression, an exception of the <i>NullReferenceException</i> type will be generated. As we can see, we won't even reach the <i>buffer == null</i> check in this case. <br><br> PVS-Studio warnings issued for other methods with the pattern: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3095</u></a> The 'buffer' object was used before it was verified against null. Check lines: 49, 51. HttpResponseStream.cs 49 </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3095</u></a> The 'buffer' object was used before it was verified against null. Check lines: 74, 75. HttpResponseStream.cs 74 </li></ul><br> <b>Issue 56</b> <br><br> A similar code snippet was in the <i>System.Transactions.Local</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InternalTransaction tx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tx._outcomeSource._isoLevel == IsolationLevel.Snapshot) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> TransactionException.CreateInvalidOperationException( TraceSourceType.TraceSourceLtm, SR.CannotPromoteSnapshot, null, tx == null ? Guid.Empty : tx.DistributedTxId); } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3095</u></a> The 'tx' object was used before it was verified against null. Check lines: 3282, 3285. TransactionState.cs 3282 <br><br> Under a certain condition, an author wants to throw an exception of the <i>InvalidOperationException</i> type. When calling the method for creating an exception object, code authors use the <i>tx</i> parameter, check it for <i>null</i> to avoid an exception of the <i>NullReferenceException</i> type when evaluating the <i>tx.DistributedTxId</i> expression. It's ironic that the check won't be of help, as when evaluating the condition of the <i>if</i> statement, instance fields are accessed via the <i>tx</i> variable ‚Äî <i>tx._outcomeSource._isoLevel</i> . <br><br> <b>Issue 57</b> <br><br> Code from the <i>System.Runtime.Caching</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLimit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> cacheMemoryLimitMegabytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> cacheMemoryLimit = cacheMemoryLimitMegabytes; cacheMemoryLimit = cacheMemoryLimit &lt;&lt; MEGABYTE_SHIFT; _memoryLimit = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// never override what the user specifies as the limit; // only call AutoPrivateBytesLimit when the user does not specify one. if (cacheMemoryLimit == 0 &amp;&amp; _memoryLimit == 0) { // Zero means we impose a limit _memoryLimit = EffectiveProcessMemoryLimit; } else if (cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0) { // Take the min of "cache memory limit" and // the host's "process memory limit". _memoryLimit = Math.Min(_memoryLimit, cacheMemoryLimit); } else if (cacheMemoryLimit != 0) { // _memoryLimit is 0, but "cache memory limit" // is non-zero, so use it as the limit _memoryLimit = cacheMemoryLimit; } .... }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3022</u></a> Expression 'cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0' is always false. CacheMemoryMonitor.cs 250 <br><br> If you look closely at the code, you'll notice that one of the expressions ‚Äî <i>cacheMemoryLimit != 0 &amp;&amp; _memoryLimit != 0</i> will always be <i>false</i> . Since <i>_memoryLimit</i> has the 0 value (is set before the <i>if</i> statement), the right operand of the &amp;&amp; operator is <i>false</i> . Therefore, the result of the entire expression is <i>false</i> . <br><br> <b>Issue 58</b> <br><br> I cite a suspicious code fragment from the <i>System.Diagnostics.TraceSource</i> project below. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ StackNode n = _stack.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == null) { base.Pop(); } _stack.Value = n.Prev; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n.Value; }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3125</u></a> The 'n' object was used after it was verified against null. Check lines: 115, 111. CorrelationManager.cs 115 <br><br> In fact, it is an interesting case. Due to the check <i>n == null,</i> I assume, that <i>null</i> is an expected value for this local variable. If so, an exception of the <i>NullReferenceException</i> type will be generated when accessing the instance property ‚Äî <i>n.Prev</i> . If in this case <i>n</i> can never be <i>null</i> , <i>base.Pop()</i> will never be called. <br><br> <b>Issue 59</b> <br><br> An interesting code fragment from the <i>System.Drawing.Primitives</i> project. Again, I suggest that you try to find the problem yourself. Here's the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToHtml</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Color c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> colorString = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.IsEmpty) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> colorString; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ColorUtil.IsSystemColor(c)) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.ToKnownColor()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveBorder: colorString = <span class="hljs-string"><span class="hljs-string">"activeborder"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GradientActiveCaption: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveCaption: colorString = <span class="hljs-string"><span class="hljs-string">"activecaption"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.AppWorkspace: colorString = <span class="hljs-string"><span class="hljs-string">"appworkspace"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Desktop: colorString = <span class="hljs-string"><span class="hljs-string">"background"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Control: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlDark: colorString = <span class="hljs-string"><span class="hljs-string">"buttonshadow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlText: colorString = <span class="hljs-string"><span class="hljs-string">"buttontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ActiveCaptionText: colorString = <span class="hljs-string"><span class="hljs-string">"captiontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GrayText: colorString = <span class="hljs-string"><span class="hljs-string">"graytext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.HotTrack: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Highlight: colorString = <span class="hljs-string"><span class="hljs-string">"highlight"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuHighlight: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.HighlightText: colorString = <span class="hljs-string"><span class="hljs-string">"highlighttext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveBorder: colorString = <span class="hljs-string"><span class="hljs-string">"inactiveborder"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.GradientInactiveCaption: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveCaption: colorString = <span class="hljs-string"><span class="hljs-string">"inactivecaption"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InactiveCaptionText: colorString = <span class="hljs-string"><span class="hljs-string">"inactivecaptiontext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Info: colorString = <span class="hljs-string"><span class="hljs-string">"infobackground"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.InfoText: colorString = <span class="hljs-string"><span class="hljs-string">"infotext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuBar: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Menu: colorString = <span class="hljs-string"><span class="hljs-string">"menu"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.MenuText: colorString = <span class="hljs-string"><span class="hljs-string">"menutext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ScrollBar: colorString = <span class="hljs-string"><span class="hljs-string">"scrollbar"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlDarkDark: colorString = <span class="hljs-string"><span class="hljs-string">"threeddarkshadow"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLightLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonhighlight"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Window: colorString = <span class="hljs-string"><span class="hljs-string">"window"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.WindowFrame: colorString = <span class="hljs-string"><span class="hljs-string">"windowframe"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.WindowText: colorString = <span class="hljs-string"><span class="hljs-string">"windowtext"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.IsNamedColor) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == Color.LightGray) { <span class="hljs-comment"><span class="hljs-comment">// special case due to mismatch between Html and enum spelling colorString = "LightGrey"; } else { colorString = c.Name; } } else { colorString = "#" + cRToString("X2", null) + cGToString("X2", null) + cBToString("X2", null); } return colorString; }</span></span></code> </pre> <br> Okay, okay, just kidding‚Ä¶ Or did you still find something? Anyway, let's reduce the code to clearly state the issue. <br><br> Here is the short code version: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (c.ToKnownColor()) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.Control: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KnownColor.ControlLight: colorString = <span class="hljs-string"><span class="hljs-string">"buttonface"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3139</u></a> Two or more case-branches perform the same actions. ColorTranslator.cs 302 <br><br> I can't say for sure, but I think it's an error. In other cases, when a developer wanted to return the same value for several enumerators he used several <i>case(s)</i> , following each other. And it's easy enough to make a mistake with copy-paste here, I think. <br><br> Let's dig a little deeper. To get the <i>¬´buttonface¬ª</i> value from the analyzed <i>ToHtml</i> method, you can pass one of the following values to it (expected): <br><br><ul><li> <i>SystemColors.Control</i> ; </li><li> <i>SystemColors.ControlLight</i> . </li></ul><br> If we check ARGB values for each of these colors, we'll see the following: <br><br><ul><li> <i>SystemColors.Control</i> ‚Äî <i>(255, 240, 240, 240)</i> ; </li><li> <i>SystemColors.ControlLight ‚Äî (255, 227, 227, 227)</i> . </li></ul><br> If we call the inverse conversion method <i>FromHtml</i> on the received value ( <i>¬´buttonface¬ª</i> ), we'll get the color <i>Control (255, 240, 240, 240)</i> . Can we get the <i>ControlLight</i> color from <i>FromHtml</i> ?  Sim This method contains the table of colors, which is the basis for composing colors (in this case). The table's initializer has the following line: <br><br><pre> <code class="cpp hljs">s_htmlSysColorTable[<span class="hljs-string"><span class="hljs-string">"threedhighlight"</span></span>] = ColorUtil.FromKnownColor(KnownColor.ControlLight);</code> </pre> <br> Accordingly, <i>FromHtml</i> returns the <i>ControlLight (255, 227, 227, 227)</i> color for the <i>¬´threedhighlight¬ª</i> value. I think that's exactly what should have been used in <i>case KnownColor.ControlLight</i> . <br><br> <b>Issue 60</b> <br><br> We'll check out a couple of interesting warnings from the <i>System.Text.RegularExpressions</i> project. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TextposDescription</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> remaining; sb.Append(runtextpos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sb.Length &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) sb.Append(<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> - sb.Length); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (runtextpos &gt; runtextbeg) sb.Append(RegexCharClass.CharDescription(runtext[runtextpos - <span class="hljs-number"><span class="hljs-number">1</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sb.Append(<span class="hljs-string"><span class="hljs-string">'^'</span></span>); sb.Append(<span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>); remaining = runtextend - runtextpos; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = runtextpos; i &lt; runtextend; i++) { sb.Append(RegexCharClass.CharDescription(runtext[i])); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sb.Length &gt;= <span class="hljs-number"><span class="hljs-number">64</span></span>) { sb.Length = <span class="hljs-number"><span class="hljs-number">61</span></span>; sb.Append(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sb.Append(<span class="hljs-string"><span class="hljs-string">'$'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.ToString(); }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3137</u></a> The 'remaining' variable is assigned but is not used by the end of the function. RegexRunner.cs 612 <br><br> A value is written in the local <i>remaining</i> variable, but it's not longer used in the method. Perhaps, some code, using it, was removed, but the variable itself was forgotten. Or there is a crucial error and this variable has to somehow be used. <br><br> <b>Issue 61</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> first, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> last)</span></span></span><span class="hljs-function"> </span></span>{ _rangelist.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SingleRange(first, last)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_canonical &amp;&amp; _rangelist.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; first &lt;= _rangelist[_rangelist.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>].Last) { _canonical = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3063</u></a> A part of conditional expression is always true if it is evaluated: _rangelist.Count &gt; 0. RegexCharClass.cs 523 <br><br> The analyzer rightly noted, that a part of the expression <i>_rangelist.Count &gt; 0</i> will always be <i>true</i> , if this code is executed. Even if this list (which <i>_rangelist</i> points at), was empty, after adding the element <i>_rangelist.Add(....)</i> it wouldn't be the same. <br><br> <b>Issue 62</b> <br><br> Let's look at the warnings of the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3128</u></a> diagnostic rule in the projects <i>System.Drawing.Common</i> and <i>System.Transactions.Local</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayEnumerator</span></span></span><span class="hljs-class"> :</span></span> IEnumerator { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> object[] _array; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> object _item; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _index; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _startIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _endIndex; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArrayEnumerator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object[] </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">array</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count)</span></span></span><span class="hljs-function"> </span></span>{ _array = <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; _startIndex = startIndex; _endIndex = _index + count; _index = _startIndex; } .... }</code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3128</u></a> The '_index' field is used before it is initialized in constructor. PrinterSettings.Windows.cs 1679 <br><br> When initializing the <i>_endIndex</i> field, another <i>_index</i> field is used, which has a standard value <i>default(int)</i> , (that is <i>0</i> ) at the moment of its usage. The <i>_index</i> field is initialized below. In case if it's not an error ‚Äî the <i>_index</i> variable should have been omitted in this expression not to be confusing. <br><br> <b>Issue 63</b> <br><br><pre> <code class="cpp hljs">internal <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TransactionTable</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _timerInterval; .... <span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TransactionTable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Create a timer that is initially disabled by specifing // an Infinite time to the first interval _timer = new Timer(new TimerCallback(ThreadTimer), null, Timeout.Infinite, _timerInterval); .... // Store the timer interval _timerInterval = 1 &lt;&lt; TransactionTable.timerInternalExponent; .... } }</span></span></code> </pre> <br> <b>PVS-Studio warning:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3128</u></a> The '_timerInterval' field is used before it is initialized in constructor. TransactionTable.cs 151 <br><br> The case is similar to the one above. First the value of the <i>_timerInterval</i> field is used (while it's still <i>default(int)</i> ) to initialize <i>_timer.</i> Only after that the <i>_timerInterval</i> field itself will be initialized. <br><br> <b>Issue 64</b> <br><br> Next warnings were issued by the diagnostic rule, which is still in development. There's no documentation or final message, but we've already found a couple of interesting fragments with its help. Again these fragments look like <i>copy-paste</i> , so we'll consider only one code fragment. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessNotifyConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... WeakReference reference = (WeakReference)( LdapConnection.s_handleTable[referralFromConnection]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( reference != null &amp;&amp; reference.IsAlive &amp;&amp; null != ((LdapConnection)reference.Target)._ldapHandle) { .... } .... }</code> </pre> <br> <b>PVS-Studio warning (stub):</b> VXXXX TODO_MESSAGE. LdapSessionOptions.cs 974 <br><br> The trick is that after checking <i>reference.IsAlive</i> , garbage might be collected and the object, which <i>WeakReference</i> points to, will be garbage collected. In this case, <i>Target</i> will return the <i>null</i> value. As a result, when accessing the instance field <i>_ldapHandle</i> , an exception of the <i>NullReferenceException</i> type will occur. Microsoft itself warns about this trap with the check IsAlive. A quote from docs.microsoft.com ‚Äî " <u>WeakReference.IsAlive Property</u> ": <i>Because an object could potentially be reclaimed for garbage collection immediately after the IsAlive property returns true, using this property is not recommended unless you are testing only for a false return value.</i> <br><br><h2> Summary on Analysis </h2><br> Are these all errors and interesting places, found during the analysis? Of course, not! When looking through the analysis results, I was thoroughly checking out the warnings. As their number increased and it became clear there were enough of them for an article, I was scrolling through the results, trying to select only the ones that seemed to me the most interesting. When I got to the last ones (the largest logs), I was only able to look though the warnings until the sight caught on something unusual. So if you dig around, I'm sure you can find much more interesting places. <br><br> For example, I ignored almost all <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3022</u></a> and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V3063</a> warnings. So to speak, if I came across such code: <br><br><pre> <code class="cpp hljs">String str = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str == null) ....</code> </pre> <br> I would omit it, as there were many other interesting places that I wanted to describe. There were warnings on unsafe locking using the <i>lock statement</i> with locking by <i>this</i> and so on ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3090</u></a> ; unsafe event calls ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3083</u></a> <u>;</u> objects, which types implement <i>IDisposable</i> , but for which <i>Dispose</i> / <i>Close</i> isn't called ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>V3072</u></a> and similar diagnostics and much more. <br><br> I also didn't note problems, written in tests. At least, I tried, but could accidentally take some. Except for a couple of places that I found interesting enough to draw attention to them. But the testing code can also contain errors, due to which the tests will work incorrectly. <br><br> Generally, there are still many things to investigate ‚Äî but I didn't have the intention to mark <i>all found issues</i> . <br><br> The quality of the code seemed uneven to me. Some projects were perfectly clean, others contained suspicious places. Perhaps we might expect clean projects, especially when it comes to the most commonly used library classes. <br><br> To sum up, we can say, that the code is of quite high-quality, as its amount was considerable. But, as this article suggests, there were some dark corners. <br><br> By the way, a project of this size is also a good test for the analyzer. I managed to find a number of false / weird warnings that I selected to study and correct. So as a result of the analysis, I managed to find the points, where we have to work on the PVS-Studio itself. <br><br><h2>  Conclus√£o </h2><br> If you got to this place by reading the whole article ‚Äî let me shake your hand! I hope that I was able to show you interesting errors and demonstrate the benefit of static analysis. If you have learned something new for yourself, that will let you write better code ‚Äî I will be doubly pleased. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/dbc/f2d/6efdbcf2d984bef000cf44face04c6a4.png" alt="Quadro 23"></div><br> Anyway, some help by the static analysis won't hurt, so suggest that you <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><u>try PVS-Studio</u></a> on your project and see what interesting places can be found with its usage. If you have any questions or you just want to share interesting found fragments ‚Äî don't hesitate to write at <a href="">support@viva64.com</a> .  :) <br><br> Best regards! <br><br><h2> PS For .NET Core libraries developers </h2><br> Thank you so much for what you do! Good job! Hopefully this article will help you make the code a bit better. Remember, that I haven't written all suspicious places and you'd better check the project yourself using the analyzer. This way, you'll be able to investigate all warnings in details. Moreover, it'll be more convenient to work with it, rather than with simple text log / list of errors ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">I wrote about this in more details here</a> ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463535/">https://habr.com/ru/post/pt463535/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463513/index.html">Melhores estruturas de desenvolvimento web em 2019</a></li>
<li><a href="../pt463515/index.html">Usando a API HTMS para trabalhar com um banco de dados de rede relacional</a></li>
<li><a href="../pt463525/index.html">Sel√™nio, Selen√≥ide, Selenide, Selendroid ... O que tudo isso significa?</a></li>
<li><a href="../pt463527/index.html">Pop up! Transcrito no iOS</a></li>
<li><a href="../pt463533/index.html">O que todo desenvolvedor deve saber desde o in√≠cio</a></li>
<li><a href="../pt463537/index.html">Verifica√ß√£o do c√≥digo-fonte das bibliotecas .NET Core pelo analisador est√°tico PVS-Studio</a></li>
<li><a href="../pt463541/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 17. Resumo e roteiro do curso da CCNA</a></li>
<li><a href="../pt463551/index.html">Como se relacionar com os funcion√°rios e organizar o fluxo de trabalho em grandes empresas de TI</a></li>
<li><a href="../pt463553/index.html">"Voc√™ pesquisa no Google?" ou 5 coisas que fizemos ao contratar (mas n√£o mais)</a></li>
<li><a href="../pt463559/index.html">Treinamento Cisco 200-125 CCNA v3.0. Dia 18. No√ß√µes b√°sicas de roteamento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>