<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§• üè© üëº Abh√§ngige Typen - Die Zukunft der Programmiersprachen üë®üèΩ‚Äçüåæ üë® üïó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! 

 Trotz der Fremdartigkeit und einer gewissen Abstraktion des heute behandelten Themas hoffen wir, dass es Ihr Wochenende abwechslu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Abh√§ngige Typen - Die Zukunft der Programmiersprachen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432416/">  Hallo allerseits! <br><br>  Trotz der Fremdartigkeit und einer gewissen Abstraktion des heute behandelten Themas hoffen wir, dass es Ihr Wochenende abwechslungsreich gestalten kann.  Am Ende des Beitrags platzieren wir drei Links des Autors, damit Sie sich mit der abh√§ngigen Eingabe in Idris, F * und JavaScript vertraut machen k√∂nnen <br><a name="habracut"></a><br>  Manchmal scheint es, als h√§tten sich die Programmiersprachen seit den 60er Jahren nicht viel ge√§ndert.  Wenn sie mir davon erz√§hlen, erinnere ich mich oft daran, wie viele coole Tools und Funktionen uns jetzt zur Verf√ºgung stehen und wie sie unser Leben vereinfachen.  Nebenbei: Dies sind integrierte Debugger, Komponententests, statische Analysatoren und coole IDEs sowie typisierte Arrays und vieles mehr.  Die Entwicklung von Sprachen ist ein langer und fortschrittlicher Prozess, und es gibt keine solchen ‚ÄûSilberkugeln‚Äú, mit denen sich die Entwicklung von Sprachen ein f√ºr alle Mal √§ndern w√ºrde. <br><br>  Heute m√∂chte ich Ihnen √ºber eine der letzten Phasen dieses laufenden Prozesses berichten.  Die Technologie, √ºber die wir sprechen, wird noch aktiv erforscht, aber alles deutet darauf hin, dass sie bald in den g√§ngigen Sprachen Fu√ü fassen wird.  Und unsere Geschichte beginnt mit einem der grundlegendsten Konzepte der Informatik: mit <b>Typen</b> . <br><br><h2>  Welt der Typen </h2><br>  Tippen ist eines der Dinge, die so untrennbar mit unserem Denken verbunden sind, dass wir kaum √ºber das Konzept der Typen als solche nachdenken?  Warum ist 1 ein <code>int</code> , aber wenn Sie diesen Wert nur in Anf√ºhrungszeichen setzen - und er wird zu einer <code>string</code> ?  Was ist im Wesentlichen ein "Typ"?  Wie so oft bei der Programmierung h√§ngt die Antwort vom Wortlaut der Frage ab. <br><br>  Typen sind vielf√§ltig.  In einigen Typsystemen gibt es sehr klare Grenzen zwischen Typen und Werten.  3, 2 und 1 sind also <code>integer</code> Werte, aber <code>integer</code> ist kein Wert.  Dieses Konstrukt ist in die Sprache "eingebettet" und unterscheidet sich grundlegend von der Bedeutung.  Tats√§chlich ist ein solcher Unterschied jedoch nicht notwendig und kann uns nur einschr√§nken. <br><br>  Wenn Sie die Typen freigeben und in eine andere Wertekategorie umwandeln, er√∂ffnen sich eine Reihe erstaunlicher M√∂glichkeiten.  Werte k√∂nnen gespeichert, konvertiert und an Funktionen √ºbergeben werden.  Auf diese Weise w√§re es m√∂glich, eine Funktion zu erstellen, die einen Typ als Parameter verwendet und verallgemeinerte Funktionen erstellt: solche, die mit vielen Typen ohne √úberlastung arbeiten k√∂nnen.  Sie k√∂nnen ein Array von Werten eines bestimmten Typs haben, anstatt wie in C seltsame Zeigerarithmetik und Typumwandlung durchzuf√ºhren. Sie k√∂nnen auch neue Typen sammeln, w√§hrend das Programm ausgef√ºhrt wird, und Funktionen wie die automatische JSON-Deserialisierung bereitstellen.  Aber selbst wenn Sie Typen als Werte behandeln, k√∂nnen Sie nicht alles tun, was Typen mit Werten tun k√∂nnen.  Wenn Sie also mit Benutzerinstanzen arbeiten, k√∂nnen Sie beispielsweise deren Namen vergleichen, deren Alter oder Kennung √ºberpr√ºfen usw. <br><br><pre> <code class="plaintext hljs">if user.name == "Marin" &amp;&amp; user.age &lt; 65 { print("You can't retire yet!") }</code> </pre> <br>  Wenn Sie jedoch versuchen, dasselbe mit dem <code>User</code> zu tun, k√∂nnen Sie nur Typnamen und m√∂glicherweise Eigenschaftsnamen vergleichen.  Da dies ein Typ und keine Instanz ist, k√∂nnen Sie die Werte seiner Eigenschaften nicht √ºberpr√ºfen. <br><br><pre> <code class="plaintext hljs">if typeof(user) == User { print("Well, it's a user. That's all I know") }</code> </pre> <br>  Wie cool w√§re es, wenn wir eine Funktion h√§tten, die nur eine nicht leere Benutzerliste empfangen kann?  Oder eine Funktion, die eine E-Mail-Adresse nur akzeptiert, wenn sie im richtigen Format aufgezeichnet wird?  F√ºr diese Zwecke ben√∂tigen Sie die Typen "Nicht leeres Array" oder "E-Mail-Adresse".  In diesem Fall ist es ein wertabh√§ngiger Typ, d.h.  √ºber <b>abh√§ngigen Typ</b> .  In g√§ngigen Sprachen ist dies nicht m√∂glich. <br><br>  Damit Typen verwendet werden k√∂nnen, muss der Compiler sie √ºberpr√ºfen.  Wenn Sie behaupten, dass die Variable eine Ganzzahl enth√§lt, ist es besser, wenn keine <code>string</code> darin enthalten ist, da der Compiler sonst schw√∂rt.  Im Prinzip ist das gut, weil es uns nicht erlaubt zu werben.  Das √úberpr√ºfen von Typen ist ganz einfach: Wenn eine Funktion eine <code>integer</code> zur√ºckgibt und wir versuchen, <code>"Marin"</code> darin zur√ºckzugeben, ist dies ein Fehler. <br><br>  Bei abh√§ngigen Typen werden die Dinge jedoch komplizierter.  Das Problem ist, wenn genau der Compiler die Typen √ºberpr√ºft.  Wie kann er sicherstellen, dass das Array genau drei Werte enth√§lt, wenn das Programm noch nicht einmal ausgef√ºhrt wird?  Wie kann sichergestellt werden, dass eine Ganzzahl gr√∂√üer als 3 ist, wenn sie noch nicht einmal zugewiesen ist?  Das ist <i>Magie</i> ... oder mit anderen Worten <i>Mathematik</i> .  Wenn mathematisch bewiesen werden kann, dass der Satz von Zahlen immer gr√∂√üer als 3 ist, kann der Compiler dies √ºberpr√ºfen. <br><br><h2>  Mathe im Studio! </h2><br>  <b>Die mathematische Induktion</b> wird verwendet, um Beweise zu formulieren.  Die Induktion erm√∂glicht es uns, die Wahrheit einer Aussage bedingungslos zu best√§tigen.  Zum Beispiel wollen wir beweisen, dass die folgende mathematische Formel f√ºr jede positive Zahl gilt: <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + x = x * (x + 1) / 2</code> </pre> <br>  Es gibt unendlich viele m√∂gliche x, daher w√ºrde es sehr lange dauern, bis wir alle Zahlen manuell √ºberpr√ºft haben.  Zum Gl√ºck ist dies nicht notwendig.  Wir m√ºssen nur zwei Dinge beweisen: <br><br><ol><li>  Diese Aussage wird f√ºr den ersten Tag eingehalten.  (Normalerweise ist es 0 oder 1) </li><li>  Wenn diese Aussage f√ºr die Zahl <code>n</code> , gilt sie f√ºr die n√§chste Zahl <code>n + 1</code> </li></ol><br>  Da die Aussage sowohl f√ºr die erste als auch f√ºr alle folgenden Zahlen eingehalten wird, wissen wir, dass sie f√ºr alle m√∂glichen Zahlen gilt. <br><br>  Dies zu beweisen ist nicht schwierig: <br><br><pre> <code class="plaintext hljs">1 = 1 * (1 + 1) / 2 1 = 1</code> </pre> <br>  Jetzt m√ºssen wir auch beweisen, dass die Aussage f√ºr alle anderen Zahlen gilt.  Nehmen Sie dazu an, dass es f√ºr eine Zahl n funktioniert, und stellen Sie dann sicher, dass es auch f√ºr n + 1 funktioniert. <br><br>  Angenommen, der folgende Ausdruck ist wahr: <br><br><pre> <code class="plaintext hljs">1 + 2 + 3 + ... + n = n * (n + 1) / 2</code> </pre> <br>  √úberpr√ºfen Sie es f√ºr <code>n + 1</code> : <br><br><pre> <code class="plaintext hljs">(1 + 2 + 3 + ... + n) + (n + 1) = (n + 1) * ((n + 1) + 1) / 2</code> </pre> <br>  Somit k√∂nnen wir <code>"(1 + 2 + 3 + ... + n)"</code> obige Gleichheit ersetzen: <br><br><pre> <code class="plaintext hljs">(n * (n + 1) / 2) + (n + 1) = (n + 1) * ((n + 2) / 2)</code> </pre> <br>  und vereinfachen <br><br><pre> <code class="plaintext hljs">(n + 1) * (n/2 + 1) = (n + 1) * (n/2 + 1)</code> </pre> <br>  Da beide Teile des Ausdrucks gleich sind, haben wir sichergestellt, dass diese Aussage wahr ist.  Dies ist eine der M√∂glichkeiten, wie Sie die Richtigkeit von Aussagen √ºberpr√ºfen k√∂nnen, ohne jeden Fall manuell zu berechnen, und auf der Grundlage dieses Prinzips funktionieren abh√§ngige Typen.  Sie schreiben eine mathematische Aussage, um sicherzustellen, dass die Typarbeit wahr ist. <br><br>  Das Sch√∂ne an diesem Ansatz liegt in der Tatsache, dass jeder mathematische Beweis in Form eines Computerprogramms ausgestellt werden kann - und genau das brauchen wir! <br><br><h2>  Zur√ºck zur Programmierung </h2><br>  Wir haben also festgestellt, dass einige Dinge zuerst bewiesen werden k√∂nnen und dann zu bestimmten Werten √ºbergehen.  Um dies in einer Programmiersprache zu tun, ben√∂tigen Sie eine M√∂glichkeit, diese Anweisungen in Code auszudr√ºcken, der in das Typsystem selbst geschrieben wird, dh das Typsystem muss verbessert werden. <br><br>  Betrachten Sie ein Beispiel.  Hier haben wir eine Append-Funktion, die zwei Arrays verwendet und kombiniert.  In der Regel sieht die Signatur einer solchen Funktion ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; Array</code> </pre> <br>  Wenn wir uns jedoch nur die Signatur ansehen, k√∂nnen wir nicht sicher sein, ob die Implementierung korrekt ist.  Die Tatsache, dass die Funktion ein Array zur√ºckgibt, bedeutet nicht, dass sie etwas getan hat.  Eine M√∂glichkeit, das Ergebnis zu √ºberpr√ºfen, besteht darin, sicherzustellen, dass die L√§nge des resultierenden Arrays gleich der Summe der L√§ngen der Parameterarrays ist. <br><br><pre> <code class="plaintext hljs">newArray = append([1], [2, 3]) assert(length(newArray) == 3)</code> </pre> <br>  Aber warum sollten Sie dies zur Laufzeit √ºberpr√ºfen, wenn Sie eine Einschr√§nkung erstellen k√∂nnen, die zur Kompilierungszeit √ºberpr√ºft wird: <br><br><pre> <code class="plaintext hljs">append: (arr1: Array, arr2: Array) -&gt; newArray: Array where length(newArray) == length(arr1) + length(arr2)</code> </pre> <br>  Wir erkl√§ren, dass <code>append</code> eine Funktion ist, die zwei <code>Array</code> Argumente <code>newArray</code> und ein neues <code>Array</code> Argument zur√ºckgibt, das wir <code>newArray</code> genannt <code>newArray</code> .  Nur dieses Mal f√ºgen wir eine Einschr√§nkung hinzu, dass die L√§nge des neuen Arrays der Summe der L√§ngen aller Argumente der Funktion entsprechen sollte.  Die Anweisung, die wir oben zur Laufzeit hatten, wird zur Kompilierungszeit in Typ konvertiert. <br><br>  Der obige Code bezieht sich auf die Welt der Typen, nicht auf Werte, <code>==</code> Zeichen <code>==</code> gibt einen Vergleich der zur√ºckgegebenen <code>length</code> an und nicht deren Wert.  Damit ein solcher Mechanismus funktioniert, muss uns die zur√ºckgegebene Typl√§nge einige Informationen √ºber die tats√§chliche Anzahl geben. <br><br>  Um den Betrieb eines solchen Mechanismus sicherzustellen, m√ºssen Sie sicherstellen, dass jede Nummer von einem separaten Typ ist.  Ein Typ kann nur einen Wert enthalten: 1. Gleiches gilt f√ºr Zwei, Drei und alle anderen Zahlen.  Nat√ºrlich ist eine solche Arbeit sehr anstrengend, aber f√ºr diese Arbeit haben wir Programmierung.  Sie k√∂nnen einen Compiler schreiben, der dies f√ºr uns erledigt. <br><br>  Anschlie√üend k√∂nnen Sie separate Typen f√ºr Arrays erstellen, die 1, 2, 3 und eine andere Anzahl von Elementen enthalten.  <code>ArrayOfOne</code> , <code>ArrayOfTwo</code> usw. <br><br>  Somit ist es m√∂glich, eine Funktionsl√§nge zu definieren, die einen der oben genannten Arten von Arrays verwendet und einen abh√§ngigen R√ºckgabetyp von <code>One</code> f√ºr <code>ArrayOfOne</code> , <code>Two</code> f√ºr <code>ArrayOfTwo</code> usw. hat.  f√ºr jede Nummer. <br><br>  Nachdem wir nun einen separaten Typ f√ºr eine bestimmte L√§nge des Arrays haben, k√∂nnen wir (zur Kompilierungszeit) √ºberpr√ºfen, ob beide Arrays gleich lang sind.  Vergleichen Sie dazu ihre Typen.  Und da Typen dieselben Werte wie alle anderen haben, k√∂nnen Sie ihnen Operationen zuweisen.  Sie k√∂nnen die Hinzuf√ºgung von zwei bestimmten Typen bestimmen, indem <code>ArrayOfOne</code> <code>ArrayOfTwo</code> , dass die Summe von <code>ArrayOfOne</code> und <code>ArrayOfTwo</code> gleich <code>ArrayOfThree</code> . <br><br>  Das sind alle Informationen, die der Compiler ben√∂tigt, um sicherzustellen, dass der von Ihnen geschriebene Code korrekt ist. <br><br>  Angenommen, wir m√∂chten eine Variable vom Typ <code>ArrayOfThree</code> : <br><br><pre> <code class="plaintext hljs">result: ArrayOfThree = append([1], [2, 3])</code> </pre> <br>  Der Compiler kann feststellen, dass [1] nur einen Wert hat, sodass Sie den Typ <code>ArrayOfOne</code> zuweisen <code>ArrayOfOne</code> .  Es kann auch <code>ArrayOfTwo</code> [2, 3] zuweisen. <br><br>  Der Compiler wei√ü, dass der Ergebnistyp gleich der Summe der Typen des ersten und zweiten Arguments sein muss.  Er wei√ü auch, dass ArrayOfOne + ArrayOfTwo gleich ArrayOfThree ist, dh er wei√ü, dass der gesamte Ausdruck auf der rechten Seite der Identit√§t vom Typ ArrayOfThree ist.  Es stimmt mit dem Ausdruck auf der linken Seite √ºberein, und der Compiler ist zufrieden. <br><br>  Wenn wir folgendes geschrieben haben: <br><br><pre> <code class="plaintext hljs">result: ArrayOfTwo = append([1], [2, 3])</code> </pre> <br>  dann w√§re der Compiler v√∂llig unzufrieden, da er wissen w√ºrde, dass der Typ falsch ist. <br><br><h2>  Abh√§ngiges Tippen ist sehr cool </h2><br>  In diesem Fall ist es einfach unm√∂glich, eine gro√üe Anzahl von Fehlern zuzulassen.  Durch abh√§ngige Typisierung k√∂nnen Fehler pro Einheit, Zugriffe auf nicht vorhandene Array-Indizes, Nullzeiger-Ausnahmen, Endlosschleifen und fehlerhafter Code vermieden werden. <br><br>  Mit abh√§ngigen Typen k√∂nnen Sie fast alles ausdr√ºcken.  Die Fakult√§tsfunktion akzeptiert nur nat√ºrliche Zahlen, die <code>login</code> akzeptiert keine leeren Zeilen, die Funktion <code>removeLast</code> akzeptiert nur nicht leere Arrays.  Dar√ºber hinaus wird dies alles √ºberpr√ºft, bevor Sie das Programm starten. <br><br>  Das Problem bei Laufzeitpr√ºfungen besteht darin, dass sie fehlschlagen, wenn das Programm bereits ausgef√ºhrt wird.  Dies ist normal, wenn das Programm nur von Ihnen, nicht aber vom Benutzer ausgef√ºhrt wird.  Abh√§ngige Typen erm√∂glichen es Ihnen, solche √úberpr√ºfungen auf die Ebene der Typen zu bringen, sodass ein Fehler dieser Art w√§hrend der Programmausf√ºhrung unm√∂glich wird. <br><br>  Ich denke, abh√§ngiges Tippen ist die Zukunft der g√§ngigen Programmiersprachen, und ich kann es kaum erwarten, darauf zu warten! <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Idris</a> <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F *</a> <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinzuf√ºgen abh√§ngiger Typen zu JavaScript</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432416/">https://habr.com/ru/post/de432416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432404/index.html">Backup f√ºr Linux schreibt keine Briefe</a></li>
<li><a href="../de432408/index.html">Fintech Digest: Vorbereitung f√ºr die Trennung kleiner Banken von Visa und Mastercard, einem Rentenrechner und nicht nur</a></li>
<li><a href="../de432410/index.html">Entit√§ten im DDD-Stil mit Entity Framework Core</a></li>
<li><a href="../de432412/index.html">Highload ++: So helfen Sie dem ERP-System, 500.000 Anfragen pro Sekunde zu bew√§ltigen</a></li>
<li><a href="../de432414/index.html">Alte Geheimnisse f√ºr schnelles Debuggen: Animieren des Quellcodes</a></li>
<li><a href="../de432418/index.html">Analysieren von Lambda-Ausdr√ºcken in Java</a></li>
<li><a href="../de432420/index.html">Einf√ºhrung in Git Merge und Git Rebase: Warum und wann sie verwendet werden sollen</a></li>
<li><a href="../de432422/index.html">Offline-Modus unter iOS und Funktionen seiner Implementierung unter Realm</a></li>
<li><a href="../de432424/index.html">HyperFlex Certified Infrastructure f√ºr SAP HANA</a></li>
<li><a href="../de432426/index.html">Debuggen eines Fehlers, der nicht abgespielt wird</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>