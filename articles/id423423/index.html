<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>âš½ï¸ ğŸ§‘ ğŸ‘‚ğŸ» Kursus MIT "Keamanan Sistem Komputer". Kuliah 8: Model Keamanan Jaringan, Bagian 3 â˜ºï¸ ğŸª ğŸš´ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Institut Teknologi Massachusetts. Kursus Kuliah # 6.858. "Keamanan sistem komputer." Nikolai Zeldovich, James Mickens. Tahun 2014 
 Keamanan Sistem Ko...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kursus MIT "Keamanan Sistem Komputer". Kuliah 8: Model Keamanan Jaringan, Bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/423423/"><h3>  Institut Teknologi Massachusetts.  Kursus Kuliah # 6.858.  "Keamanan sistem komputer."  Nikolai Zeldovich, James Mickens.  Tahun 2014 </h3><br>  Keamanan Sistem Komputer adalah kursus tentang pengembangan dan implementasi sistem komputer yang aman.  Ceramah mencakup model ancaman, serangan yang membahayakan keamanan, dan teknik keamanan berdasarkan pada karya ilmiah baru-baru ini.  Topik meliputi keamanan sistem operasi (OS), fitur, manajemen aliran informasi, keamanan bahasa, protokol jaringan, keamanan perangkat keras, dan keamanan aplikasi web. <br><br>  Kuliah 1: â€œPendahuluan: model ancamanâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 2: "Kontrol serangan hacker" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 3: â€œBuffer Overflows: Exploits and Protectionâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 4: â€œPemisahan Hak Istimewaâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 5: "Dari mana sistem keamanan berasal?" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> <br>  Kuliah 6: â€œPeluangâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 7: â€œKotak Pasir Klien Asliâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <br>  Kuliah 8: â€œModel Keamanan Jaringanâ€ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> <a name="habracut"></a><br><br>  <b>Pemirsa:</b> mengapa token acak selalu disertakan dalam URL, dan tidak di badan permintaan? <br><br>  <b>Profesor:</b> HTTPS digunakan dengan cara ini, tetapi tidak ada alasan kuat untuk tidak memasukkan variabel acak ke dalam tubuh permintaan.  Hanya saja ada beberapa bentuk warisan yang bekerja seperti itu melalui URL.  Namun dalam praktiknya, Anda dapat menempatkan informasi ini di tempat lain dalam permintaan HTTPS, kecuali untuk header. <br><br>  Namun, perhatikan bahwa hanya memindahkan informasi ini ke badan permintaan berpotensi tidak aman jika ada sesuatu di sana yang dapat ditebak penyerang.  Kemudian penyerang masih bisa memanggil URL yang dibutuhkannya.  Misalnya, ketika saya membuat permintaan HTTP HTTP, dan kemudian secara eksplisit memasukkan beberapa konten ke dalam tubuh yang dapat ditebak penyerang. <br><br><img src="https://habrastorage.org/webt/k8/00/rl/k800rljxqskwap85v7jdymt3sb8.jpeg"><br><br>  Jika Anda cukup mengatur frame di URL, maka penyerang dapat mengendalikannya.  Tetapi jika Anda menggunakan permintaan HTTP XML dan penyerang dapat menghasilkan salah satunya, maka antarmuka HTTP XML memungkinkan Anda untuk mengatur isi permintaan.  Permintaan HTTP XML terbatas pada sumber yang sama.  Namun, jika penyerang dapat melakukan sesuatu seperti: <br><br><pre><code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> x = â€œntrustedâ€; </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Kemudian dia akan dapat mengimplementasikan permintaan HTTP XML, yang akan dieksekusi dengan otoritas halaman yang disematkan. <br><br>  Itu semua tergantung pada apa yang penyerang akses.  Jika itu dapat memaksa halaman untuk menjalankan skrip yang tidak dicentang, seperti yang ditunjukkan di atas, maka ia dapat menggunakan properti JavaScript yang disebut HTML internal dan mendapatkan semua konten HTML halaman tersebut.  Jika penyerang dapat atau tidak dapat menghasilkan permintaan AJAX, ini adalah satu hal, jika ia dapat atau tidak dapat melihat kode HTML yang benar, ini adalah hal lain, dan seterusnya.  Singkatnya, token yang dibuat secara acak ini dapat mencegah serangan CSRF. <br><br>  Ada satu hal lagi yang perlu Anda perhatikan adalah alamat jaringan.  Mereka berhubungan dengan bagian dari percakapan kami yang mengatakan siapa penyerang tidak dapat berkomunikasi melalui permintaan HTTP XML. <br><br>  Mengenai alamat jaringan, frame dapat mengirim permintaan HTTP dan HTTPS ke (host + port) sesuai dengan asalnya.  Perhatikan bahwa keamanan kebijakan yang sama dari sumber yang sama sangat erat terkait dengan keamanan infrastruktur DNS, karena semua kebijakan semacam ini didasarkan pada apa yang Anda sebut. <br><br>  Jadi, jika Anda dapat mengontrol apa yang mereka sebut saya, Anda dapat membuat beberapa serangan yang agak berbahaya, misalnya, serangan pengikatan kembali DNS.  Tujuan dari serangan ini adalah untuk meluncurkan JavaScript yang dikendalikan penyerang dengan otoritas (atau atas nama) situs korban, sebut saja dia korban.com.  Dalam hal ini, penyerang menggunakan aturan kebijakan sumber yang sama dan akan meluncurkan kode yang ditulisnya dengan izin situs lain. <br><br>  Ini dilakukan sebagai berikut.  Pertama, seorang penyerang mendaftarkan nama domain, katakanlah attacker.com.  Ini sangat sederhana, cukup bayar beberapa dolar - dan saat bepergian, Anda memiliki nama domain sendiri.  Penyerang juga harus mengonfigurasi server DNS untuk menanggapi permintaan yang datang atas nama objek yang terletak di attacker.com. <br><br><img src="https://habrastorage.org/webt/wt/pf/jh/wtpfjh-yok0lfy5vp63pmv3t-ww.jpeg"><br><br>  Hal kedua yang harus terjadi adalah bahwa pengguna harus mengunjungi attacker.com.  Secara khusus, ia harus mengunjungi beberapa situs yang tergantung pada nama domain ini.  Tidak ada yang rumit di bagian serangan ini juga. <br><br>  Lihat apakah Anda dapat membuat kampanye iklan, misalnya, menawarkan iPad gratis.  Semua orang menginginkan iPad gratis, meskipun saya tidak tahu siapa pun yang pernah memenangkan iPad gratis.  Jadi, mengklik pesan seperti itu di email phising, dan Anda sudah berada di situs penyerang.  Tidak ada yang istimewa, bagian ini tidak rumit. <br><br>  Jadi apa yang akan terjadi setelah itu?  Browser akan mulai membuat permintaan DNS untuk attacker.com karena halaman yang Anda kunjungi berisi objek yang tertaut ke objek yang terletak di attacker.com.  Tetapi browser akan mengatakan: "Saya belum pernah melihat domain ini sebelumnya, jadi izinkan saya mengirim permintaan DNS untuk izin untuk menghubungi attacker.com"! <br><br><img src="https://habrastorage.org/webt/cz/qf/mw/czqfmwdiinh1lxrjntllnrkrktw.jpeg"><br><br>  Dan server DNS penyerang menjawab permintaan ini, tetapi tanggapannya berisi masa TTL yang sangat singkat, yang mencegah tanggapan dari di-cache.  Oleh karena itu, browser akan berpikir bahwa itu valid hanya untuk jangka waktu yang sangat singkat sebelum harus keluar dan mengkonfirmasi ini, yang sebenarnya berarti melarang caching. <br><br>  Ternyata segera setelah pengguna masuk ke domain peretas, server DNS penyerang pertama-tama mengembalikan alamat IP asli dari server web yang memberikan kode berbahaya kepada pengguna.  Kode sisi klien ini mengakses attacker.com karena kebijakan asal memungkinkan permintaan tersebut.  Pengguna menerima respons, dan sekarang situs web jahat dijalankan di sisi klien. <br><br>  Sementara itu, penyerang akan mengkonfigurasi server DNS, yang ia kendalikan, untuk mengikat nama attacker.com dan alamat IP dari korban.com.  Ini berarti bahwa jika browser pengguna meminta resolusi nama domain untuk sesuatu di dalam attacker.com, itu sebenarnya akan mendapatkan beberapa jenis alamat internal korban.com. <br><br><img src="https://habrastorage.org/webt/df/tt/jd/dfttjdzqo2hzt6dsttw7ch-mz5o.jpeg"><br><br>  Mengapa DNS penyerang bisa melakukan ini?  Karena peretas menyiapkannya untuk ini, dan server DNS si penyusup tidak perlu berkonsultasi untuk terhubung kembali dengan korban.com. <br><br>  Selain itu, jika situs kami ingin mendapatkan objek baru melalui, katakanlah, AJAX, itu akan mempertimbangkan bahwa permintaan AJAX ini pergi ke attacker.com di suatu tempat di luar, tetapi sebenarnya permintaan AJAX ini masuk ke dalam, ke korban.com.  Ini buruk, karena sekarang kami memiliki kode ini di sisi tempat halaman web attacker.com berada, yang sebenarnya mendapatkan akses ke data dari korban.com dengan sumber asal yang berbeda. <br><br><img src="https://habrastorage.org/webt/eo/tn/hr/eotnhr2eggyam1aggoimj-shebs.jpeg"><br><br>  Sederhananya, ketika skrip dieksekusi di browser korban karena usang tanggapan DNS sebelumnya, permintaan DNS baru dibuat untuk domain ini, yang, karena larangan caching, dikirim ke server DNS penyerang.  Dia menjawab bahwa sekarang attacker.com tampaknya memiliki alamat IP baru dari beberapa situs web lain, dan permintaan tersebut masuk ke server lain.  Dan kemudian, untuk mengembalikan informasi yang dikumpulkan oleh kode, penyerang memberikan alamat IP yang benar di salah satu permintaan DNS berikut. <br><br>  <b>Hadirin:</b> Bukankah lebih bijaksana untuk melakukan serangan sebaliknya, dari korban. Com untuk mendapatkan semua cookie penyerang dan sejenisnya? <br><br>  <b>Profesor:</b> ya, opsi itu juga akan berhasil.  Ini akan memungkinkan Anda melakukan hal-hal baik seperti pemindaian port.  Maksud saya, pendekatan Anda akan bekerja dengan benar.  Karena Anda dapat, selangkah demi selangkah, secara konstan menetapkan ulang attacker.com ke berbagai nama komputer dan port yang berbeda dalam jaringan korban.  Dengan kata lain, halaman web attacker.com akan selalu berpikir bahwa itu masuk ke attacker.com dan menerima permintaan AJAX dari sana. <br><br>  Bahkan, setiap kali server DNS terhubung kembali dengan attacker.com, ia mengirimkan permintaan ke beberapa alamat IP lain di dalam jaringan korban.  Dengan begitu, ia cukup "berjalan" melalui alamat IP satu per satu dan melihat apakah seseorang merespons permintaan ini. <br><br>  <b>Pemirsa:</b> tetapi pengguna yang Anda serang tidak harus memiliki akses internal ke jaringan korban. <br><br>  <b>Profesor:</b> sebagai aturan, serangan ini adalah bahwa ada aturan firewall tertentu yang dapat mencegah situs eksternal attacker.com melihat alamat IP di dalam jaringan korban.  Namun, jika Anda berada di dalam jaringan perusahaan seperti corp.net di belakang firewall perusahaan, maka komputer sering memiliki kemampuan untuk terhubung ke mesin di luar jaringan mereka. <br><br>  <b>Pemirsa:</b> Apakah metode serangan ini berfungsi melalui HTTPS? <br><br>  <b>Profesor:</b> ini pertanyaan yang menarik!  Faktanya adalah bahwa HTTPS menggunakan kunci.  Jika Anda menggunakan HTTPS, maka saat mengirim permintaan AJAX, mesin korban tidak akan memiliki kunci HTTPS penyerang, dan verifikasi enkripsi di korban.com akan menunjukkan ketidakcocokan kunci.  Oleh karena itu, saya pikir HTTPS mengesampingkan kemungkinan serangan jenis ini. <br><br>  <b>Hadirin:</b> bagaimana jika korban hanya menggunakan HTTPS? <br><br>  <b>Profesor:</b> Saya pikir ini akan menghentikan penyerang. <br><br>  <b>Pemirsa:</b> mengapa penyerang terutama merespons komputer korban dengan alamat IP-nya? <br><br>  <b>Profesor:</b> karena penyerang entah bagaimana harus menjalankan kode sendiri pada mesin korban sebelum ia dapat mengambil tindakan lebih lanjut untuk menemukan sesuatu di dalam jaringan korban.  Tapi jangan buang waktu, oleh karena itu, jika Anda memiliki pertanyaan tentang penugasan kembali DNS, datang kepada saya setelah kuliah. <br><br>  Jadi bagaimana Anda bisa memperbaikinya?  Salah satu cara untuk memperbaiki kerentanan ini adalah dengan memodifikasi resolver klien DNS sehingga nama host eksternal tidak pernah diizinkan untuk mengakses alamat IP internal. <br><br>  Agak bodoh bahwa seseorang di luar jaringan Anda harus dapat membuat DNS yang terikat pada sesuatu di dalam jaringan Anda.  Ini adalah solusi paling sederhana. <br><br><img src="https://habrastorage.org/webt/9_/2g/3x/9_2g3xpmlwnrztz5386gzndondi.jpeg"><br><br>  Anda dapat membayangkan bahwa browser dapat melakukan sesuatu yang disebut "DNS pinning," atau DNS pinning.  Akibatnya, jika browser menerima catatan DNS yang diselesaikan, maka ia akan selalu menganggap catatan ini dapat diterima, misalnya, untuk interaksi dalam waktu 30 menit, terlepas dari TTL mana yang diberikan penyerang, dan dengan cara ini dapat menahan serangan tersebut. <br>  Solusi ini agak rumit, karena ada situs yang sengaja menggunakan DNS dinamis untuk hal-hal seperti menyeimbangkan beban server dan sejenisnya.  Dengan demikian, solusi pertama dengan pinning DNS adalah pilihan terbaik. <br><br>  Dan sekarang kita akan melihat apa yang dilindungi oleh kebijakan sumber yang sama.  Bagaimana dengan piksel?  Bagaimana kebijakan asal melindungi piksel? <br><br>  Ternyata, piksel sebenarnya tidak memiliki asal.  Dengan demikian, setiap frame mendapatkan kotak pembatas kecilnya sendiri, pada dasarnya hanya persegi, dan frame dapat menggambar di mana saja di dalam area itu. <br><br>  Ini sebenarnya masalah karena itu berarti bahwa bingkai induk dapat menggambar di atas bingkai anak.  Dan ini, pada gilirannya, dapat menyebabkan serangan yang sangat berbahaya. <br><br>  Katakanlah penyerang membuat halaman yang mengatakan, "klik di sini untuk memenangkan iPad."  Trik standar yang sama.  Ini adalah kerangka induk. <br><br><img src="https://habrastorage.org/webt/ow/ul/sd/owulsdkyx1yy_wz5uyaskopock0.jpeg"><br><br>  Dan bingkai induk ini dapat membuat bingkai anak, yang sebenarnya adalah bingkai tombol Suka di situs Facebook.  Dengan demikian, Facebook memungkinkan Anda untuk menjalankan kode Facebook kecil ini yang dapat Anda masukkan ke halaman Anda. <br><br>  Anda tahu bahwa jika pengguna mengklik "suka", itu berarti bahwa ia akan pergi ke Facebook dan berkata: "Hei, saya suka halaman ini"!  Jadi, sekarang kita memiliki bingkai anak dari tombol Suka. <br><br><img src="https://habrastorage.org/webt/sp/dm/xk/spdmxk6xeyd9f6vvpes71las3aq.jpeg"><br><br>  Sekarang, seorang penyerang dapat menindih bingkai ini di area layar yang harus diklik pengguna untuk mendapatkan iPad gratis, dan juga membuat bingkai ini tidak terlihat, CSS mengizinkan ini. <br><br>  Jadi apa yang akan terjadi?  Seperti yang sudah kita instal, semua orang ingin mendapatkan iPad gratis.  Pengguna akan pergi ke situs ini dengan mengklik area layar ini, memastikan bahwa ia mengklik persis apa yang iPad gratis akan berikan padanya.  Tapi faktanya, dia mengklik tombol Like yang tidak terlihat.  Ini seperti pelapisan di atas indeks C. <br><br>  Ini berarti bahwa sekarang, mungkin, pengguna berakhir di profil Facebook, di mana ia mencatat bahwa ia menyukai attacker.com.  Anda tahu, dia bahkan tidak akan ingat bagaimana itu terjadi.  Jadi ini sebenarnya apa yang disebut serangan jacking klik - dukungan untuk serangan klik.  Dengan cara yang sama, Anda dapat melakukan banyak hal buruk - mencuri kata sandi, mendapatkan data pribadi, singkatnya, ini gila.  Saya tekankan - ini dimungkinkan karena fakta bahwa kerangka induk dapat menggambar apa pun di dalam kotak pembatas ini. <br><br>  Jadi, kerangka induk adalah apa yang Anda lihat pada halaman, panggilan untuk mendapatkan tablet gratis, dan kerangka anak adalah tombol seperti, yang ditumpangkan secara transparan pada bingkai induk. <br><br>  Ada berbagai solusi untuk masalah ini.  Yang pertama adalah menggunakan kode penghilang bingkai.  Dengan begitu, Anda dapat menggunakan ekspresi JavaScript untuk mengetahui apakah seseorang telah menyematkan bingkai mereka sendiri di bingkai Anda.  Sebagai contoh, salah satu dari tes ini adalah perbandingan dari bentuk berikut: if (self! = Top). <br><br>  Di sini, pernyataan diri mengacu pada bagian atas bingkai atas, yang dibandingkan dengan hierarki seluruh bingkai.  Karena itu, jika Anda melakukan tes ini dan menemukan bahwa diri tidak sama dengan bagian atas kerangka induk, maka Anda akan mengerti bahwa Anda memiliki kerangka anak.  Dalam hal ini, Anda dapat menolak untuk mengunduhnya. <br><br>  Ini terjadi jika Anda mencoba membuat bingkai, misalnya, untuk CNN.com.  Jika Anda melihat kode sumber untuk JavaScript, Anda dapat melihatnya melakukan tes ini karena CNN.com tidak ingin orang lain menggunakan kontennya.  Karena itu, frame ini selalu menempati posisi tertinggi.  Jadi, ini adalah salah satu solusi yang bisa digunakan di sini. <br><br>  Solusi kedua adalah untuk server web Anda mengirim header HTTP yang disebut opsi x-Frame sebagai respons.  Oleh karena itu, ketika server web mengembalikan respons, ia dapat mengatur tajuk ini, yang akan mengatakan: "Hei, browser, jangan biarkan siapa pun meletakkan konten saya di dalam bingkai!".  Solusi ini memungkinkan browser untuk melakukan tindakan penegakan hukum. <br><br>  Jadi itu sangat sederhana.  Tetapi masih ada banyak serangan gila lainnya yang dapat Anda atur. <br><br>  Seperti yang saya sebutkan sebelumnya, fakta bahwa kita sekarang hidup di Internet internasional menciptakan masalah menggunakan domain atau nama host. <br><br>  Misalkan kita memiliki huruf C. Tetapi dalam bahasa apa?  Dari alfabet apa huruf ini dari bahasa Latin ASCII atau apakah huruf C dalam bahasa Cyrillic?  Ini memungkinkan Anda untuk mengatur serangan yang menggunakan interpretasi berbeda dan penggunaan huruf yang berbeda, tetapi tampaknya serupa.  Misalnya, penyerang akan mendaftarkan nama domain cats.com.  Dan pengguna akan pergi ke domain ini, berpikir bahwa mereka akan mengunjungi situs "cats.com", tetapi pada kenyataannya mereka akan sampai ke situs penyerang "sats.com", karena huruf pertama di sini bukan Latin, tetapi Cyrillic. <br><br>  Seorang penyerang dapat mendaftarkan domain fcebook.com, tetapi orang-orang tidak memperhatikan, mereka akan menganggapnya sebagai facebook.com dan pergi ke sana.  Jadi, jika Anda mengontrol Facebook.com, Anda akan mendapatkan banyak lalu lintas dari orang-orang yang berpikir mereka telah masuk ke Facebook. <br><br><img src="https://habrastorage.org/webt/1w/0f/z-/1w0fz-myyja-qcjtcfwzn5yebl4.jpeg"><br><br>  Ada banyak serangan aneh dan berbeda yang dapat Anda luncurkan melalui sistem registrasi nama domain yang sulit dipertahankan, karena bagaimana Anda dapat mencegah pengguna membuat kesalahan ketik?  Atau bagaimana peramban menunjukkan kepada pengguna: "Hei, ini Cyrillic, bukan Latin"!? <br><br>  Jika peramban memperingatkan pengguna setiap kali font Cyrillic dihidupkan, itu akan membuat orang-orang yang menggunakan Cyrillic sebagai font asli mereka menjadi marah.  Jadi tidak sepenuhnya jelas bagaimana masalah seperti itu dapat diselesaikan dari sudut pandang teknis, itulah sebabnya masalah keamanan yang sangat sensitif muncul di sini. <br><br>  Hal lain yang menarik adalah plugin.  Bagaimana plugin berinteraksi dengan kebijakan asal?  Plugin sering memiliki ketidakcocokan dengan sisa browser sehubungan dengan sumber asal yang sama.  Sebagai contoh, jika Anda melihat plug-in Java, maka diasumsikan bahwa nama host berbeda yang memiliki alamat IP yang sama juga memiliki asal yang sama. <br><br>  Pada kenyataannya, ini adalah penyimpangan yang agak besar dari interpretasi standar kebijakan dari asal yang sama.  Pendekatan ini berarti bahwa jika Anda memiliki sesuatu seperti xycom dan zycom dan mereka diproyeksikan ke alamat IP yang sama, maka Java akan menganggap bahwa mereka memiliki sumber asal yang sama.  Ini bisa menjadi masalah, karena dalam kenyataannya satu situs memiliki sumber asal tepercaya, dan yang lainnya tidak.  Ada banyak kesulitan lain yang terkait dengan plugin, yang dapat Anda temukan dari sumber yang tersedia untuk umum di Internet atau dari catatan kuliah. <br><br>  Hal terakhir yang ingin saya diskusikan adalah serangan berbagi layar, atau serangan berbagi layar. <br><br>  HTML5 sebenarnya mendefinisikan API baru tempat laman web dapat berbagi semua bitnya untuk dibagikan dengan browser atau server lain.  Ini sepertinya ide yang sangat keren, karena memungkinkan beberapa pengguna untuk bekerja secara bersamaan pada dokumen yang sama.  Ini bagus karena kita hidup di masa depan. <br><br>  Tapi yang paling lucu adalah ketika mereka mengembangkan API baru ini, mereka sama sekali tidak memikirkan kebijakan sumber yang sama! <br><br>  Misalkan Anda memiliki halaman di mana beberapa frame berada, dan masing-masing dari mereka memiliki hak untuk mengambil screenshot dari seluruh monitor Anda.  Dia dapat mengambil tangkapan layar dari semua bingkai yang terletak di layar dan semua konten, terlepas dari sumber mana mereka berasal. <br><br><img src="https://habrastorage.org/webt/wz/ok/io/wzokioeio3vzffhinxhsdgau-ae.jpeg"><br><br>  Jadi, pada kenyataannya, ini adalah cacat yang agak merusak dalam kebijakan sumber asal yang sama, jadi Anda harus mempertimbangkan memperbaikinya.  Misalnya, jika seseorang dari bingkai kanan memiliki kemampuan untuk mengambil screenshot, maka ia akan dapat mengambil screenshot hanya dari frame yang tepat, dan bukan keseluruhan layar secara keseluruhan. <br><br>  Mengapa pengembang browser tidak menerapkannya seperti ini?  Karena mereka mengalami tekanan kompetitif dan dipaksa untuk memfokuskan upaya mereka pada pengembangan lebih banyak fungsi baru, fitur-fitur baru, alih-alih memperhatikan peningkatan hal-hal yang sudah dikembangkan. <br><br>  Banyak pertanyaan yang diajukan siswa di Internet tentang kuliah ini adalah: â€œmengapa para pengembang tidak melakukan apa yang dapat mereka lakukan?  Bukankah itu jelas? "  atau: â€œTampaknya skema khusus ini sudah mati.  Bukankah yang lain lebih baik? "  dan seterusnya. <br><br>  Saya akan memberitahu Anda dengan jujur â€‹â€‹- ya, itu sudah pasti, hampir semuanya akan lebih baik jika pengembang mengambil ini secara bertanggung jawab.  Jadi saya malu bahwa saya terhubung dengan ini. <br><br>  Tetapi kenyataannya adalah inilah yang kita miliki sebelumnya.  Jika Anda melihat semua elemen yang ada sebelumnya, Anda akan melihat bahwa browser web sedang berkembang, dan orang-orang menjadi sedikit lebih peduli tentang keamanan.  Tetapi tidak dalam hal berbagi layar, di mana pengembang sangat khawatir tentang kemampuan inovatif dari browser sehingga mereka benar-benar lupa tentang kemungkinan kebocoran sedikit. <br><br><img src="https://habrastorage.org/webt/0w/pr/lj/0wprljlz8_-bdy5l852zllntduu.jpeg"><br><br>  Karena itu, saya meminta Anda untuk selalu memperhatikan hal-hal yang kita bahas hari ini.  Bayangkan jika kita akan mulai dari awal, menghancurkan semua yang ada di hadapan kita, dan mencoba untuk membuat kebijakan keamanan yang lebih baik, bagaimana menurut Anda, berapa banyak situs yang akan bekerja untuk kita?  Saya pikir tidak lebih dari 2%.  Jadi pengguna mungkin akan mengeluh tentang kami. <br><br>  Ada properti menarik lain yang terkait dengan keamanan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah Anda memberikan fungsi kepada pengguna, sangat sulit untuk mengingatnya kembali, bahkan jika itu tidak aman untuk menggunakannya. </font><font style="vertical-align: inherit;">Oleh karena itu, hari ini kami membahas banyak hal terkait dengan kebijakan asal, dan kami akan terus membicarakan hal ini dalam kuliah berikutnya.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_1C62Twf0vs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br> ,    .    ?     ?       , <b>30%        entry-level ,      :</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps  $20     ?</a> (   RAID1  RAID10,  24    40GB DDR4). <br><br> <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps   </b>      ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br> <b>Dell R730xd  2  ?</b>    <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   .  c   Dell R730xd 5-2650 v4  9000   ?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423423/">https://habr.com/ru/post/id423423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423411/index.html">iOS CSS kematian</a></li>
<li><a href="../id423415/index.html">Multicopter dengan prinsip boneka bersarang atau "penangkap snitch"?</a></li>
<li><a href="../id423417/index.html">Kami sedang menulis aplikasi pertama untuk Samsung Smart Watch dan OS Tizen</a></li>
<li><a href="../id423419/index.html">Klien HTML5 untuk VMware vSphere Keluar Musim Gugur Ini - Yang Perlu Anda Ketahui</a></li>
<li><a href="../id423421/index.html">Mengapa rumput lebih hijau untuk indie</a></li>
<li><a href="../id423425/index.html">Sekolah tua: game apa yang keluar - kami membahas media yang tidak biasa</a></li>
<li><a href="../id423427/index.html">IndieVisible adalah komunitas indie online open-source</a></li>
<li><a href="../id423429/index.html">Pembaruan basis data dan penerapan zero-downtime</a></li>
<li><a href="../id423431/index.html">Kedalaman SIEM: korelasi out-of-box. Bagian 1: Pemasaran murni atau masalah yang tidak dapat diselesaikan?</a></li>
<li><a href="../id423437/index.html">Intisari materi menarik untuk pengembang ponsel # 270 (pada 10 - 16 September)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>