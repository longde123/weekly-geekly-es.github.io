<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍✈️ ☺️ 😕 Spesifikasi Steroid 🚼 🙍 💌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tema abstraksi dan segala macam pola yang indah adalah dasar yang baik untuk pengembangan holivar dan perselisihan abadi: di satu sisi, kita mengikuti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spesifikasi Steroid</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/singularis/blog/485328/">  Tema abstraksi dan segala macam pola yang indah adalah dasar yang baik untuk pengembangan holivar dan perselisihan abadi: di satu sisi, kita mengikuti arus utama, semua jenis kata-kata modis dan kode bersih, di sisi lain, kita memiliki praktik dan kenyataan yang selalu mendikte aturan mereka sendiri. <br><br>  Apa yang harus dilakukan jika abstraksi mulai “bocor”, bagaimana menggunakan chip bahasa dan apa yang dapat Anda peras dari pola “spesifikasi” - lihat di bawah potongan. <br><a name="habracut"></a><br>  Jadi, mari kita mulai bisnis.  Artikel ini akan berisi bagian-bagian berikut: sebagai permulaan, kita akan memeriksa apa pola "spesifikasi" dan mengapa penerapannya pada sampel basis data murni menyebabkan kesulitan. <br><br>  Selanjutnya, kita beralih ke pohon ekspresi, yang merupakan alat yang sangat kuat, dan melihat bagaimana mereka dapat membantu kita. <br><br>  pada akhirnya, saya akan menunjukkan penerapan "spesifikasi" saya pada steroid. <br><br>  Mari kita mulai dengan hal-hal dasar.  Saya pikir semua orang telah mendengar tentang pola "spesifikasi", tetapi bagi mereka yang belum mendengar, inilah definisi dari <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B5%25D1%2586%25D0%25B8%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Wikipedia</a> : <br><br><blockquote>  "Spesifikasi" dalam pemrograman adalah pola desain yang dengannya representasi aturan logika bisnis dapat diubah menjadi rantai objek yang terhubung oleh operasi logika Boolean. <br><br>  Templat ini menyoroti spesifikasi (aturan) dalam logika bisnis yang cocok untuk "digabungkan" dengan yang lain.  Objek logika bisnis mewarisi fungsinya dari kelas agregat abstrak CompositeSpecification, yang hanya berisi satu metode IsSatisfiedBy yang mengembalikan nilai Boolean.  Setelah instantiasi, objek dirantai bersama dengan objek lain.  Hasilnya, tanpa kehilangan fleksibilitas dalam menyiapkan logika bisnis, kami dapat dengan mudah menambahkan aturan baru. </blockquote><br>  Dengan kata lain, spesifikasi adalah objek yang mengimplementasikan antarmuka berikut (membuang metode untuk membangun rantai): <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSatisfiedBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> candidate</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Semuanya sederhana dan jelas di sini.  Tapi sekarang mari kita lihat contoh dari dunia nyata, di mana, selain domain, ada infrastruktur yang juga orang yang kejam: mari kita beralih ke kasus menggunakan ORM, DBMS dan spesifikasi untuk menyaring data dalam database. <br><br>  Agar tidak berdasar dan tidak menunjukkan jari, kami mengambil sebagai contoh area subjek berikut: misalkan kami sedang mengembangkan MMORPG, kami memiliki pengguna, setiap pengguna memiliki 1 atau lebih karakter, dan setiap karakter memiliki serangkaian item ( kami membuat asumsi bahwa item tersebut unik untuk setiap pengguna), dan untuk setiap item, pada gilirannya, rune perbaikan dapat diterapkan.  Secara total, dalam bentuk diagram (kami akan mempertimbangkan kelas ReadCharacter sesaat kemudian ketika kita berbicara tentang kueri yang bersarang): <br><br><img src="https://habrastorage.org/webt/k5/bx/iw/k5bxiwkvgl5vghoog71-9w6vqdo.png" alt="gambar"><br><br>  Model ini secara longgar terhubung dengan dunia nyata, dan itu juga berisi bidang yang mencerminkan beberapa koneksi dengan ORM yang digunakan, tetapi ini akan cukup bagi kita untuk menunjukkan pekerjaan. <br><br>  Misalkan kita ingin menyaring semua karakter yang dibuat setelah tanggal yang ditentukan. <br>  Untuk melakukan ini, kami menulis spesifikasi bentuk berikut: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedAfter</span></span>: <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> DateTime _target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatedAfter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime target</span></span></span><span class="hljs-function">)</span></span> { _target = target; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSatisfiedBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> candidate</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> character = candidate <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Character; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(character == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> character.CreatedAt &gt; target; } }</code> </pre><br>  Nah, kemudian, untuk menerapkan spesifikasi ini, kami melakukan hal berikut (selanjutnya saya akan mempertimbangkan kode berbasis NHibernate): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> characters = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> session.Query&lt;Character&gt;().ToListAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedAfter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newCharacters = characters.Where(x =&gt; filter.IsSatisfiedBy(x)).ToArray();</code> </pre><br>  Selama basis kami kecil, semuanya akan bekerja dengan indah dan cepat, tetapi jika permainan kami menjadi lebih atau kurang populer dan mendapatkan beberapa puluh ribu pengguna, semua pesona ini akan memakan memori, waktu dan uang, dan lebih baik untuk menembak binatang ini segera. karena  dia bukan penyewa.  Pada catatan sedih ini, kami akan menunda spesifikasi dan sedikit mengubah praktik saya. <br><br>  Sekali waktu, dalam satu proyek yang sangat, sangat jauh, saya memiliki kelas dalam kode saya yang berisi logika untuk mengambil data dari database.  Mereka terlihat seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ICharacterDal</span></span> { <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;Character&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCharactersCreatedAfter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime date</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;Character&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCharactersCreatedBefore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime date</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;Character&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCharactersCreatedBetween</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">from</span></span></span></span><span class="hljs-function"><span class="hljs-params">, DateTime to</span></span></span><span class="hljs-function">)</span></span>; ... }</code> </pre><br>  dan penggunaannya: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CharacterDal(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createdCharacters = dal.GetCharactersCreatedAfter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br>  Di dalam kelas ada logika untuk bekerja dengan DBMS (pada waktu itu ADO.NET). <br><br>  Segalanya tampak menyenangkan, tetapi dengan perluasan proyek, kelas-kelas ini juga tumbuh, berubah menjadi objek yang sulit dirawat.  Selain itu, ada aftertaste yang tidak menyenangkan - tampaknya menjadi aturan bisnis, tetapi mereka disimpan di tingkat infrastruktur, karena mereka terikat dengan implementasi tertentu. <br><br>  Pendekatan ini digantikan oleh repositori <i>IQueryable &lt;T&gt;</i> , yang memungkinkan untuk mengambil semua aturan secara langsung ke lapisan domain. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IRepository</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">IQueryable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">List</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Delete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T obj</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Save</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T obj</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  yang digunakan seperti ini: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repository = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> createdUsers = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> repository.List().Where(x =&gt; x.CreatedAd &gt; targetDate).ToListAsync();</code> </pre><br>  Sedikit lebih bagus, tetapi masalahnya adalah bahwa aturan merayap di sepanjang kode, dan pemeriksaan yang sama dapat terjadi di ratusan tempat, dan mudah untuk membayangkan apa yang dapat mengakibatkan perubahan persyaratan. <br><br>  Pendekatan ini menyembunyikan masalah lain - jika Anda tidak mematerialisasikan kueri, yaitu kesempatan untuk memenuhi beberapa pertanyaan ke database, alih-alih satu, yang, tentu saja, mempengaruhi kinerja sistem. <br><br>  Dan di sini di salah satu proyek, seorang rekan menyarankan menggunakan <a href="https://github.com/rjperes/DevelopmentWithADot.NHibernateSpecifications">perpustakaan</a> yang menyarankan penerapan pola "spesifikasi" berdasarkan pohon ekspresi. <br><br>  Singkatnya, berdasarkan pustaka ini, kami memfilmkan spesifikasi yang memungkinkan kami membuat filter untuk entitas dan membuat filter yang lebih kompleks berdasarkan gabungan aturan sederhana.  Misalnya, kami memiliki spesifikasi untuk karakter yang dibuat setelah tahun baru dan ada spesifikasi untuk memilih karakter dengan item tertentu - kemudian dengan menggabungkan aturan ini kami dapat membuat permintaan untuk daftar karakter yang dibuat setelah tahun baru dan memiliki item yang ditentukan.  Dan jika di masa depan kita akan mengubah aturan untuk menentukan karakter baru (misalnya, kita akan menggunakan tanggal tahun baru Cina), maka kita akan memperbaikinya hanya dalam spesifikasi itu sendiri dan tidak perlu mencari semua penggunaan logika ini dengan kode! <br><br>  Proyek ini berhasil diselesaikan, dan pengalaman menggunakan pendekatan ini sangat berhasil.  Tapi saya tidak mau diam, dan ada beberapa masalah dalam implementasinya, yaitu: <br><br><ul><li>  menempelkan operator ATAU tidak bekerja; </li><li>  serikat pekerja hanya berfungsi untuk kueri yang berisi filter bertipe Where, tapi saya ingin aturan yang lebih kaya (kueri bersarang, lewati / ambil, dapatkan proyeksi); <br></li><li>  kode spesifikasi tergantung pada ORM yang dipilih; </li><li>  tidak mungkin menggunakan fitur ORM, seperti  ini menyebabkan dimasukkannya dependensi di dalamnya dalam lapisan logika bisnis (misalnya, tidak mungkin dilakukan pengambilan). <br></li></ul><br>  Hasil dari penyelesaian masalah ini adalah kerangka kerja <i>Singularis.Spesifikasi</i> , yang terdiri dari beberapa majelis: <br><br><ul><li>  Singularis.Specification.Definition - mendefinisikan objek spesifikasi, dan juga berisi antarmuka IQuery yang dengannya aturan tersebut dibentuk. </li><li>  Singularis.Specification.Executor. * - mengimplementasikan repositori dan objek untuk mengeksekusi spesifikasi untuk ORM tertentu (saat ini didukung oleh ef.core dan NHibernate, sebagai bagian dari percobaan saya juga melakukan implementasi untuk mongodb, tetapi kode ini tidak masuk ke produksi). </li></ul><br>  Mari kita lihat lebih dekat implementasinya. <br><br>  Antarmuka spesifikasi mendefinisikan properti publik yang berisi aturan spesifikasi: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { IQuery Query { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } Type ResultType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISpefication</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt;: <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { }</code> </pre><br>  Selain itu, antarmuka berisi properti <i>ResultType</i> , yang mengembalikan tipe entitas yang diperoleh sebagai hasil dari kueri. <br><br>  Implementasinya terkandung dalam kelas <i>spesifikasi &lt;T&gt;</i> , yang mengimplementasikan properti <i>ResultType</i> , menghitungnya berdasarkan aturan yang disimpan dalam Query, serta dua metode: <i>Source ()</i> dan <i>Source &lt;TSource&gt; ()</i> .  Metode-metode ini berfungsi untuk membentuk sumber aturan.  <i>Source ()</i> membuat aturan dengan tipe yang cocok dengan argumen dari kelas spesifikasi, dan <i>Source &lt;TSource&gt; ()</i> memungkinkan Anda untuk membuat aturan untuk kelas arbitrer (digunakan saat membuat kueri bertingkat). <br><br>  Selain itu, ada juga kelas <i>SpecificationExtension</i> , yang berisi metode ekstensi untuk permintaan chaining. <br><br>  Dua jenis bergabung didukung: gabungan (dapat dianggap bergabung dengan kondisi "DAN") dan bergabung dengan kondisi "ATAU". <br><br>  Mari kita kembali ke contoh kita dan menerapkan dua aturan kita: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedAfter</span></span>: <span class="hljs-title"><span class="hljs-title">Specification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Character</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatedAfter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime target</span></span></span><span class="hljs-function">)</span></span> { Query = Source().Where(x =&gt; x.CreatedAt &gt; target); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CreatedBefore</span></span>: <span class="hljs-title"><span class="hljs-title">Specification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">Character</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreatedBefore</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DateTime target</span></span></span><span class="hljs-function">)</span></span> { Query = Source().Where(x =&gt; x.CreatedAt &lt; target); } }</code> </pre><br>  dan temukan semua pengguna yang memenuhi kedua aturan: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> specification = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedAfter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2019</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).Combine(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedBefore(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> users = repository.List(specification);</code> </pre><br>  Menggabungkan dengan metode <i>Combine</i> mendukung aturan arbitrer.  Yang utama adalah bahwa jenis sisi kiri yang dihasilkan bertepatan dengan tipe input sisi kanan.  Dengan demikian, Anda dapat membuat aturan yang berisi proyeksi, lewati / ambil untuk paginasi, aturan sortir, ambil, dll. <br><br>  Aturan Or lebih ketat - itu hanya mendukung rantai yang berisi kondisi penyaringan mana.  Pertimbangkan penggunaan contoh: kami menemukan semua karakter yang dibuat sebelum 2000 atau setelah 2020: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> specification = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedAfter(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2020</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>).Or(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreatedBefore(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-number"><span class="hljs-number">2000</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> users = repository.List(specification );</code> </pre><br>  Antarmuka <i>IQuery</i> sebagian besar mengulangi antarmuka <i>IQueryable</i> , jadi seharusnya tidak ada pertanyaan khusus.  Marilah kita memikirkan metode tertentu saja: <br><br>  <i>Fetch / ThenFetch</i> - memungkinkan Anda untuk memasukkan data terkait dalam kueri yang dihasilkan untuk tujuan optimasi.  Tentu saja, ini sedikit bengkok ketika kita memiliki fitur implementasi infrastruktur yang memengaruhi aturan bisnis, tetapi, seperti yang saya katakan, kenyataannya adalah abstraksi yang keras dan murni - ini adalah hal yang agak teoretis. <br><br>  <i>Di mana</i> - <i>IQuery</i> mendeklarasikan dua kelebihan metode ini, yang satu hanya mengambil ekspresi lambda untuk memfilter dalam bentuk <i>Ekspresi &lt;Func &lt;T, bool &gt;&gt;</i> , dan yang kedua juga mengambil parameter tambahan <i>IQueryContext</i> , yang memungkinkan Anda untuk mengeksekusi subqueries bersarang.  Mari kita lihat sebuah contoh. <br><br>  Kami memiliki kelas ReadCharacter dalam model - misalkan model kami disajikan sebagai bagian baca yang berisi data yang didenormalkan dan berfungsi untuk umpan balik cepat, dan bagian tulis yang berisi tautan, data yang dinormalkan, dll.  Kami ingin menampilkan semua karakter yang digunakan pengguna untuk mengirim email pada domain tertentu. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CharactersForUserWithEmailDomain</span></span>: <span class="hljs-title"><span class="hljs-title">Specification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">ReadCharacter</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CharactersForUserWithEmailDomain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> domain</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> usersQuery = Source&lt;User&gt;(x =&gt; x.Email.Contains(domain)).Projection(x =&gt; x.Id); Query = Source().Where((x, ctx) =&gt; ctx.GetQueryResult&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(usersQuery).Contains(x.Id)); } }</code> </pre><br>  Sebagai hasil dari eksekusi, kueri sql berikut akan dihasilkan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> readcharac0_.id <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> id1_3_, readcharac0_.UserId <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> userid2_3_, readcharac0_.Name <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> name3_3_ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ReadCharacters readcharac0_ <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> readcharac0_.UserId <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> user1_.Id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Users</span></span> user1_ <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> user1_.Email <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> (<span class="hljs-string"><span class="hljs-string">'%'</span></span>+@p0+<span class="hljs-string"><span class="hljs-string">'%'</span></span>) ); @p0 = '@inmagna.ca' [Type: String (4000:0:0)]</code> </pre><br>  Untuk memenuhi semua aturan yang luar biasa ini, antarmuka <i>IRepository didefinisikan</i> , yang memungkinkan Anda untuk menerima item dengan pengidentifikasi, menerima satu (yang pertama cocok) atau daftar objek sesuai dengan spesifikasi, dan juga menyimpan dan menghapus item dari repositori. <br>  Dengan definisi pertanyaan, kami menemukan, sekarang tetap mengajar ORM kami untuk memahami hal ini. <br>  Untuk melakukan ini, kita akan menganalisis perakitan <i>Singularis.Infrastructure.NHibernate</i> (untuk ef.core semuanya terlihat sama, hanya dengan spesifik dari ef.core). <br><br>  Jalur akses data adalah objek Repositori, yang mengimplementasikan antarmuka <i>IRepository</i> .  Dalam hal menerima objek dengan pengidentifikasi, serta untuk memodifikasi penyimpanan (menyimpan / menghapus), kelas ini mengakhiri sesi dan menyembunyikan implementasi spesifik dari lapisan bisnis.  Dalam hal bekerja dengan spesifikasi, ia membentuk objek yang dapat <i>IQuery</i> yang mencerminkan permintaan kami dalam hal <i>IQuery</i> , dan kemudian mengeksekusinya pada objek sesi. <br><br>  Sihir utama dan kode paling jelek terletak pada kelas yang bertanggung jawab untuk mengubah <i>IQuery</i> menjadi <i>IQueryable</i> - SpecificationExecutor.  Kelas ini berisi banyak refleksi, yang memanggil metode Queryable atau metode ekstensi ORM tertentu (EagerFetchingExtensionsMethods untuk NHiberante). <br><br>  Perpustakaan ini secara aktif digunakan dalam proyek-proyek kami (jujur, perpustakaan yang sudah diperbarui digunakan untuk proyek-proyek kami, tetapi secara bertahap semua perubahan ini akan dibuat tersedia untuk umum) terus-menerus mengalami perubahan.  Hanya beberapa minggu yang lalu, versi berikutnya dirilis, yang beralih ke metode asinkron, bug diperbaiki di executor untuk e.core, tes dan sampel ditambahkan.  Ada kemungkinan bahwa perpustakaan berisi kesalahan dan seratus tempat untuk optimasi - itu lahir sebagai proyek sampingan dalam kerangka kerja pada proyek-proyek utama, jadi saya akan dengan senang hati menyarankan saran untuk perbaikan.  Selain itu, Anda tidak boleh terburu-buru menggunakannya - kemungkinan bahwa dalam kasus khusus Anda ini tidak perlu atau tidak dapat diterapkan. <br><br>  Kapan layak menggunakan solusi yang dijelaskan?  Mungkin lebih mudah untuk memulai dari pertanyaan "kapan seharusnya tidak": <br><br><ul><li>  highload - jika Anda membutuhkan kinerja tinggi, penggunaan ORM sendiri menimbulkan pertanyaan.  Meskipun, tentu saja, tidak ada yang melarang menerapkan pelaksana yang akan menerjemahkan permintaan menjadi SQL dan mengeksekusi mereka ... </li><li>  proyek yang sangat kecil - ini sangat subyektif, tetapi Anda harus mengakui bahwa menarik ORM dan seluruh kebun binatang yang menyertainya ke dalam proyek "daftar tugas" tampak seperti menembak burung pipit dari meriam. </li></ul><br>  Bagaimanapun, yang menguasai membaca sampai akhir - terima kasih atas waktu Anda.  Saya berharap umpan balik untuk pengembangan di masa depan! <br><br>  Saya hampir lupa - kode proyek tersedia di GitHub'e - <a href="https://github.com/SingularisLab/singularis.specification">https://github.com/SingularisLab/singularis.specification</a> <br><br><div class="spoiler">  <b class="spoiler_title">Sidang tersedia untuk diunduh melalui nuget</b> <div class="spoiler_text"><ul><li>  <a href="https://www.nuget.org/packages/Singularis.Specification.Definition/">https://www.nuget.org/packages/Singularis.Specification.Definition/</a> </li><li>  <a href="https://www.nuget.org/packages/Singularis.Specification.Executor.EntityFramework/">https://www.nuget.org/packages/Singularis.Specification.Executor.EntityFramework/</a> </li><li>  <a href="https://www.nuget.org/packages/Singularis.Specification.Executor.Common/">https://www.nuget.org/packages/Singularis.Specification.Executor.Common/</a> </li><li>  <a href="https://www.nuget.org/packages/Singularis.Specification.Executor.Nhibernate/">https://www.nuget.org/packages/Singularis.Specification.Executor.Nhibernate/</a> </li></ul></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485328/">https://habr.com/ru/post/id485328/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485316/index.html">Semua Google SERP sekarang terlihat seperti iklan</a></li>
<li><a href="../id485318/index.html">Menambahkan keindahan dan interaktivitas ke Notebook Jupyter</a></li>
<li><a href="../id485322/index.html">Bicara tentang PostgreSQL. Wawancara dengan Alexei Lesovsky di podcast Zinc Prod. Bagian satu</a></li>
<li><a href="../id485324/index.html">Multithreading di Widget Qt</a></li>
<li><a href="../id485326/index.html">Membuat Micro Frontends Menggunakan Elemen Sudut: Panduan Pemula</a></li>
<li><a href="../id485330/index.html">Cara mengalahkan acak tanpa jiwa di game roguelike</a></li>
<li><a href="../id485334/index.html">Polling Sesi</a></li>
<li><a href="../id485336/index.html">Apa yang ada di Universitas ITMO: kuliah, lokakarya, kontes, dan hiburan</a></li>
<li><a href="../id485338/index.html">Cara mengatasi rasa takut dan mulai menggunakan Azure Machine Learning</a></li>
<li><a href="../id485342/index.html">Bagaimana tahun 2019 di bidang matematika dan Ilmu Komputer?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>