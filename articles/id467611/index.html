<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤯 🗝️ ⏸️ Algoritma Deteksi Garis Besar Gambar 👲🏾 👸 🐠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini menyajikan empat algoritma deteksi loop paling umum. 

 Dua yang pertama, yaitu algoritma untuk menelusuri kotak dan menelusuri lingkungan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritma Deteksi Garis Besar Gambar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467611/">  Artikel ini menyajikan empat algoritma deteksi loop paling umum. <br><br>  Dua yang pertama, yaitu algoritma untuk menelusuri kotak dan menelusuri lingkungan Moore, mudah diimplementasikan, dan oleh karena itu sering digunakan untuk menentukan kontur pola yang diberikan.  Sayangnya, kedua algoritma memiliki beberapa kelemahan, yang membuatnya <b>tidak mungkin untuk</b> mendeteksi kontur kelas pola yang besar karena jenis kedekatan khusus mereka. <br><br>  Algoritma ini akan mengabaikan semua <b><i>"lubang"</i></b> dalam pola.  Sebagai contoh, jika kita memiliki pola yang mirip dengan yang ditunjukkan pada <b><i>Gambar 1</i></b> , maka sirkuit yang dideteksi oleh algoritma akan serupa dengan yang ditunjukkan pada <b><i>Gambar 2</i></b> (garis besar ditunjukkan oleh piksel biru).  Di beberapa area aplikasi ini cukup dapat diterima, tetapi di area lain, misalnya, dalam pengenalan karakter, deteksi bagian internal suatu pola diperlukan untuk menemukan semua ruang yang membedakan karakter tertentu.  ( <b><i>Gambar 3</i></b> menunjukkan garis "penuh" dari pola.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e7/d3b/f5b/0e7d3bf5bc9c451588718fe5d909a2fb.gif" alt="gambar"></div><br><br>  Oleh karena itu, untuk mendapatkan kontur lengkap, pertama-tama perlu menggunakan algoritma <b><i>"pencarian lubang"</i></b> yang menentukan lubang dalam pola yang diberikan, dan kemudian menerapkan algoritma deteksi kontur untuk setiap lubang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb7/22c/32f/cb722c32fcc45aeea8d8b097a0d01f84.gif" alt="gambar"></div><a name="habracut"></a><br><h2>  Apa itu konektivitas? </h2><br>  Dalam gambar digital dengan nilai-nilai biner, sebuah piksel dapat memiliki salah satu dari nilai berikut: 1 - ketika itu merupakan bagian dari pola, atau 0 - ketika itu adalah bagian dari latar belakang, mis.  tidak ada gradasi abu-abu.  (Kami akan menganggap bahwa piksel dengan nilai 1 berwarna hitam, dan dengan nilai 0 berwarna putih). <br><br>  Untuk mengidentifikasi <b><i>objek</i></b> dalam pola digital, kita perlu menemukan kelompok piksel hitam yang "terhubung" satu sama lain.  Dengan kata lain, <b><i>objek</i></b> dalam pola digital yang diberikan adalah <b><i>komponen yang terhubung dari</i></b> pola ini. <br><br>  Dalam kasus umum, <b><i>komponen yang terhubung</i></b> adalah sekumpulan piksel hitam <b>P</b> , sehingga untuk setiap pasangan piksel <b>p <sub>i</sub></b> dan <b>p <sub>j</sub></b> dalam <b>P</b> ada urutan piksel <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> sedemikian rupa sehingga: <br><br>  a) semua piksel dalam urutan berada di set <b>P</b> , mis.  hitam, dan <br><br>  b) setiap 2 piksel <b><i>dalam urutan di samping</i></b> satu sama <b><i>lain</i></b> adalah "tetangga". <br><br>  Sebuah pertanyaan penting muncul: <b><i>kapan kita dapat mengatakan bahwa 2 piksel adalah "tetangga"?</i></b>  Karena kami menggunakan piksel kuadrat, jawaban untuk pertanyaan sebelumnya tidak sepele karena alasan berikut: dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">persegi kuadrat,</a> piksel memiliki tepi atau simpul yang sama, atau tidak memiliki kesamaan.  Setiap piksel memiliki 8 piksel yang sama dengannya;  piksel seperti itu membentuk "lingkungan Moore" dari piksel itu.  Haruskah kita mempertimbangkan piksel "tetangga" yang hanya memiliki satu simpul umum?  Atau untuk dianggap "tetangga", dua piksel harus memiliki keunggulan bersama? <br><br>  Jadi ada dua jenis konektivitas, yaitu: 4-connectedness dan 8-connectness. <br><br><h4>  4-koneksi </h4><br>  Kapan kita dapat mengatakan bahwa satu set piksel hitam yang diberikan adalah <b><i>4-terhubung?</i></b>  Pertama, Anda perlu mendefinisikan konsep <b><i>tetangga 4</i></b> (juga disebut <b><i>tetangga langsung</i></b> ): <br><br>  <b>Definisi 4-tetangga</b> : Sebuah piksel <b>Q</b> adalah <b><i>4-tetangga dari</i></b> piksel <b>P yang</b> diberikan jika <b>Q</b> dan <b>P</b> memiliki tepi yang sama.  4-tetangga piksel <b>P</b> (ditetapkan sebagai <b>P2, P4, P6,</b> dan <b>P8</b> ) ditunjukkan pada <b><i>Gambar 2 di</i></b> bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/592/5ef/02b5925eff29a4b14330e63c43714837.gif" height="202" width="177"></div><br>  <b>Definisi komponen yang terhubung 4</b> : himpunan piksel hitam <b>P</b> adalah <b><i>komponen yang terhubung 4</i></b> jika untuk setiap pasangan piksel <b>p <sub>i</sub></b> dan <b>p <sub>j</sub></b> dalam <b>P</b> ada urutan piksel <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> sedemikian rupa sehingga: <br><br>  a) semua piksel dalam urutan berada di set <b>P</b> , mis.  hitam, dan <br><br>  b) setiap dua piksel yang <b><i>berdekatan dalam urutan</i></b> adalah <b><i>4 tetangga</i></b> <br><br><h4>  Contoh 4 pola yang terhubung </h4><br>  Diagram di bawah ini menunjukkan contoh pola 4-terhubung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b71/3c8/b76/b713c8b761d034fc04d486aed3029149.gif" height="216" width="576"></div><br><br><h4>  8-koneksi </h4><br>  Kapan saya bisa mengatakan bahwa satu set piksel hitam yang <b><i>terhubung 8</i></b> ?  Pertama, kita perlu mendefinisikan konsep <b><i>tetangga 8</i></b> (juga disebut <b><i>tetangga tidak langsung</i></b> ): <br><br>  <b>Definisi 8-tetangga</b> : Sebuah piksel <b>Q</b> adalah <b><i>8-tetangga</i></b> (atau hanya <b><i>tetangga</i></b> ) dari piksel <b>P yang</b> diberikan jika <b>Q</b> dan <b>P</b> memiliki tepi atau simpul yang sama.  8-tetangga dari piksel <b>P yang</b> diberikan membentuk lingkungan Moore dari piksel ini. <br><br>  <b>Definisi komponen yang terhubung 8</b> : himpunan piksel hitam <b>P</b> adalah <b><i>komponen yang terhubung 8</i></b> (atau hanya <b><i>komponen yang terhubung</i></b> ) jika untuk setiap pasangan piksel <b>p <sub>i</sub></b> dan <b>p <sub>j</sub></b> di <b>P</b> ada urutan piksel <b><i>p <sub>i</sub> , ..., p <sub>j</sub></i></b> sedemikian rupa sehingga : <br><br>  a) semua piksel dalam urutan berada di set <b>P</b> , mis.  hitam, dan <br><br>  b) setiap dua piksel yang <b><i>berdekatan dalam urutan ini</i></b> adalah <b><i>8 tetangga</i></b> <br><br>  <b>Catatan</b> : semua pola 4-terhubung 8-terhubung, mis.  Pola 4-terhubung adalah bagian dari banyak pola 8-terhubung.  Di sisi lain, pola 8-terhubung mungkin tidak terhubung-4. <br><br><h4>  Contoh pola 8-linked </h4><br>  Diagram di bawah ini menunjukkan pola yang terhubung 8 tetapi tidak terhubung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f0/3d4/d90/7f03d4d904e9a4ebd1b7765ee7f4358f.gif" height="180" width="180"></div><br><br><h4>  Contoh pola yang tidak terhubung: </h4><br>  Diagram di bawah ini menunjukkan contoh pola yang tidak terhubung-8, mis.  terdiri dari lebih dari satu komponen yang terhubung (diagram menunjukkan tiga komponen yang terhubung): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/768/7bb/f90/7687bbf9070e4e581e4ebfde132a1164.gif" height="180" width="180"></div><br><br><h2>  Algoritma Jejak Persegi </h2><br><h4>  Ide </h4><br>  Gagasan di balik algoritma penelusuran persegi sangat sederhana;  ini dapat dikaitkan dengan fakta bahwa algoritma adalah salah satu upaya pertama untuk mendeteksi kontur pola biner. <br><br>  Untuk memahami cara kerjanya, Anda perlu sedikit imajinasi ... <br><br>  Misalkan kita memiliki pola digital, misalnya, sekelompok piksel hitam pada latar belakang piksel putih, mis.  di grid;  temukan piksel hitam dan nyatakan sebagai piksel " <b>awal</b> " kami.  (Menemukan piksel " <b>awal</b> " dapat diimplementasikan dengan berbagai cara; kita akan mulai dari sudut kiri bawah kisi, kami akan memindai setiap kolom piksel dari bawah ke atas, dari kolom paling kiri ke paling kanan, sampai kami menemukan piksel hitam. Kami akan mendeklarasikannya sebagai " <b>awal</b> " ".) <br><br>  Sekarang bayangkan Anda seorang ladybug yang berdiri di piksel <b>awal</b> , seperti yang ditunjukkan pada <b><i>Gambar 1 di</i></b> bawah ini.  Untuk mendapatkan garis besar pola, Anda perlu melakukan hal berikut: <br><br> <code> ,      ,  ,  <br> <br>  ,      ,  , <br> <br>      <b></b> .</code> <br> <br>  Pixel hitam yang Anda lingkari akan menjadi garis besar pola. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/baa/0c2/69e/baa0c269e22368fa231d774f6bf3b062.gif" height="252" width="216"></div><br>  Aspek penting dari algoritma jejak kuadrat adalah "sense of direction".  Beralih ke kiri dan kanan dilakukan relatif terhadap lokasi saat ini, yang tergantung pada bagaimana Anda mencapai piksel saat ini.  Karena itu, untuk membuat gerakan yang benar, Anda perlu melacak arah Anda. <br><br><h4>  Algoritma </h4><br>  Berikut ini adalah deskripsi formal dari algoritma penelusuran kuadrat: <br><br>  Input: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tessellation</a> kuadrat, <b>T</b> , berisi komponen <b>P yang</b> terhubung sel hitam. <br><br>  Output: baris <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> )</b> dari piksel batas, mis.  kontur. <br><br>  Mulai <br><br><ul><li>  Tentukan <b>B</b> sebagai set kosong. </li><li>  Pindai sel <b>T</b> dari bawah ke atas dan kiri ke kanan hingga ditemukan piksel hitam <b>s</b> dari <b>P.</b> </li><li>  Masukkan <b>s</b> ke <b>B.</b> </li><li>  Jadikan piksel saat ini sebagai piksel awal. </li><li>  Belok kiri, mis.  pergi ke piksel tetangga di sebelah kiri <b>p</b> . </li><li>  Perbarui <b>p</b> , mis.  itu menjadi piksel saat ini. </li><li>  Sementara <b>p</b> tidak sama dengan <b>s</b> , jalankan <br><br>  Jika <b>p</b> piksel saat ini berwarna hitam <br><ul><li>  masukkan <b>p</b> ke <b>B</b> dan belok kiri (pergi ke piksel tetangga di sebelah kiri <b>p</b> ). </li><li>  Perbarui <b>p</b> , mis.  itu menjadi piksel saat ini. </li></ul><br>  jika tidak <br><ul><li>  belok kanan (pergi ke piksel berikutnya di sebelah kanan <b>p</b> ). </li><li>  Perbarui <b>p</b> , mis.  itu menjadi piksel saat ini. </li></ul><br>  Akhir dari siklus "Sampai jumpa" </li></ul><br>  Akhirnya <br><br>  <b>Catatan:</b> konsep "kiri" dan "kanan" harus dianggap tidak berkenaan dengan halaman atau pembaca, tetapi sehubungan dengan arah entri ke dalam piksel "saat ini" selama pemindaian. <br><br><h4>  Demonstrasi </h4><br>  Berikut ini adalah demonstrasi animasi tentang bagaimana algoritme jejak kuadrat mendeteksi garis besar pola.  Jangan lupa bahwa kepik bergerak dalam piksel;  perhatikan bagaimana arahnya berubah ketika belok kiri dan kanan.  Belok kiri dan kanan dilakukan relatif terhadap arah saat ini dalam suatu piksel, mis.  orientasi kepik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39c/148/f77/39c148f774519015dc130273d8383dd3.gif" height="360" width="288"></div><br><h4>  Analisis </h4><br>  Ternyata kemampuan algoritma jejak kuadrat sangat terbatas.  Dia tidak dapat mendeteksi kontur pola keluarga besar yang sering muncul dalam aplikasi dunia nyata. <br><br>  Hal ini terutama disebabkan oleh kenyataan bahwa rotasi kiri dan kanan tidak memperhitungkan piksel akun yang terletak “sepanjang <br>  diagonal "dari piksel saat ini. <br><br>  Mari kita lihat pola yang berbeda dengan konektivitas yang berbeda dan lihat mengapa algoritma kuadrat persegi gagal.  Selain itu, kami akan mempelajari cara untuk meningkatkan kemampuan algoritme dan membuatnya bekerja bahkan dengan pola yang memiliki jenis konektivitas khusus. <br><br><h4>  Hentikan kriteria </h4><br>  Salah satu kelemahan dari algoritma adalah pilihan kriteria berhenti.  Dengan kata lain, kapan algoritma berhenti dijalankan? <br><br>  Dalam deskripsi asli algoritme jejak kuadrat, kondisi penyelesaian adalah untuk memukul piksel <b>awal</b> untuk kedua kalinya.  Ternyata jika algoritma tergantung pada kriteria seperti itu, maka itu tidak akan dapat mendeteksi kontur dari keluarga besar pola. <br><br>  Berikut ini adalah demo animasi yang menjelaskan bagaimana algoritme tidak dapat mendeteksi kontur pola yang tepat karena pemilihan kriteria berhenti buruk: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ef/783/09a/0ef78309a17e9e72b09a28890abb6791.gif" height="252" width="216"></div><br>  Seperti yang Anda lihat, meningkatkan kriteria penghentian bisa menjadi awal yang baik untuk meningkatkan kinerja algoritma secara keseluruhan.  Ada dua alternatif efektif untuk kriteria penutupan yang ada: <br><br>  a) Hentikan hanya dengan mengunjungi piksel <b>awal</b> <b><i>n</i></b> kali, di mana n setidaknya 2, ATAU <br><br>  b) Berhenti setelah menekan piksel <b>awal</b> untuk kedua kalinya, sama seperti kita menekannya pada awalnya. <br><br>  Kriteria ini diusulkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yakub Eliosoff</a> , jadi kita akan menyebutnya <b><i>kriteria untuk menghentikan Yakub</i></b> . <br><br>  Mengubah kriteria pemberhentian umumnya meningkatkan efektivitas algoritme jejak kuadrat, tetapi tidak memungkinkan untuk mengatasi kelemahan lain yang dimilikinya dalam hal pola dengan jenis konektivitas khusus. <br><br>  Algoritma Square Tracing tidak dapat mendeteksi kontur pola keluarga dengan konektivitas 8 yang TIDAK memiliki konektivitas 4. <br><br>  Berikut ini adalah demonstrasi animasi tentang bagaimana algoritme jejak kuadrat (dengan kriteria berhenti Jacob) gagal mendeteksi garis besar pola yang benar dengan konektivitas 8 tanpa konektivitas 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/c26/238/9bbc26238da41c3fb5c5eac1e44fe507.gif" height="288" width="216"></div><br><h2>  Apakah algoritma ini sama sekali tidak berguna? </h2><br>  Jika Anda membaca analisis di atas, Anda mungkin berpikir bahwa algoritme jejak kuadrat gagal mendeteksi garis besar sebagian besar pola.  Tapi ternyata itu.  bahwa ada keluarga khusus pola di mana jalur sepenuhnya terdeteksi oleh algoritma jejak kuadrat. <br><br>  Misalkan <b>P</b> adalah himpunan piksel hitam dengan konektivitas 4 di grid.  Biarkan piksel putih kotak, mis.  piksel latar belakang <b>W</b> juga memiliki konektivitas 4. Ternyata dalam kondisi pola dan latar belakang seperti itu, dapat dibuktikan bahwa algoritme jejak kuadrat (dengan kriteria stop Jacob) akan selalu berhasil menangani penentuan kontur. <br><br>  Di bawah ini adalah bukti bahwa dalam kasus di mana kedua pola dan piksel latar belakang terhubung, algoritma kuadrat persegi akan menentukan kontur dengan benar ketika menggunakan kriteria berhenti Jacob. <br><br>  Bukti <br>  <b>Diberikan</b> : pola <b>P</b> sedemikian rupa sehingga semua piksel pola (mis. Hitam) dan piksel latar belakang (mis. Putih) W memiliki konektivitas 4. <br><br>  <b>Pengamatan pertama</b> <br><br>  Karena himpunan piksel putih W memiliki konektivitas 4, ini berarti bahwa tidak ada " <b><i>lubang</i></b> " dalam pola (dalam istilah informal, " <b><i>lubang</i></b> " kami maksudkan kelompok piksel putih sepenuhnya dikelilingi oleh piksel hitam dari pola). <br><br>  Kehadiran " <b><i>lubang</i></b> " dalam pola akan mengarah pada pemisahan kelompok piksel putih dari piksel putih yang tersisa;  namun, banyak piksel putih kehilangan konektivitas 4. <br><br>  <i>Gambar 2</i> dan <b><i>Gambar 3 di</i></b> bawah ini menunjukkan dua jenis " <b><i>lubang</i></b> " yang dapat terjadi dalam suatu pola dengan konektivitas 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/a4e/9b1/8d9a4e9b18b2753038c0abbd11ad7dcd.gif" height="180" width="432"></div><br><br>  <b>Pengamatan kedua</b> <br><br>  Dua piksel hitam dari suatu pola HARUS memiliki satu sisi yang sama. <br><br>  Misalkan dua piksel hitam hanya memiliki satu simpul umum.  Kemudian, untuk memenuhi sifat 4-keterhubungan pola, harus ada jalur yang menghubungkan dua piksel ini sehingga setiap dua piksel yang berdekatan di jalur ini memiliki konektivitas 4. Tetapi ini akan memberi kita pola yang mirip dengan <b><i>Gambar 3</i></b> .  Dengan kata lain, ini akan menghasilkan pemisahan piksel putih.  <b><i>Gambar 4 di</i></b> bawah ini menunjukkan pola khas yang memuaskan asumsi bahwa piksel dalam pola dan latar belakang 4-terhubung, mis.  tidak memiliki " <b><i>lubang</i></b> ", dan setiap dua piksel hitam memiliki satu sisi yang sama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a68/2e0/7e0/a682e07e0732655da35269badcfe6b69.gif" height="216" width="216"></div><br>  Berguna untuk mewakili pola-pola seperti berikut: <br><br>  Pertama-tama kita mempertimbangkan piksel batas, mis.  garis besar polanya.  Kemudian, jika kita menganggap setiap piksel batas memiliki 4 tepi panjang unit, kita akan melihat bahwa beberapa tepi ini sama dengan piksel putih tetangga.  Kami akan memanggil tepi <b><i>batas</i></b> seperti <b><i>tepi</i></b> . <br><br>  Tepi batas seperti itu dapat dianggap sebagai tepi poligon.  Dalam <b><i>gambar</i></b> <b><i><br></i></b>  <b><i>5 di</i></b> bawah, ide ini ditunjukkan oleh contoh poligon yang sesuai dengan pola dari <b><i>Gambar 4 di</i></b> atas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/ebe/5ea/220ebe5ea9383e00a2709117b237248b.gif" height="216" width="216"></div><br>  Jika kita mempertimbangkan semua "konfigurasi" piksel batas yang mungkin terjadi dalam pola seperti itu, kita akan melihat bahwa ada dua kasus sederhana, yang ditunjukkan pada <b><i>Gambar 6</i></b> dan <b><i>Gambar 7 di</i></b> bawah ini. <br><br>  Piksel batas dapat merupakan kelipatan dari kasus ini atau pengaturan lainnya, mis.  liku-liku dari dua kasus ini.  Rusuk batas ditandai dengan warna biru sebagai <b>E1, E2, E3</b> dan <b>E4</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf5/99b/6fa/bf599b6fafebb09a80c32eceb0520270.gif" height="216" width="576"></div><br>  <b>Pengamatan ketiga</b> <br><br>  Dalam kasus dua kasus di atas, tidak peduli berapa piksel awal yang kita pilih, dan ke arah mana pun <b>jatuh</b> ke dalamnya, algoritma jejak persegi tidak akan pernah <b>"kembali" (mundur)</b> , itu tidak akan pernah <b>"melewati"</b> <i>batas tepi</i> dua kali ( hanya jika tidak melacak perbatasan untuk kedua kalinya) dan jangan pernah melewatkan <b><i>batas tepi</i></b> .  Lihat itu! <br><br>  Dua konsep perlu diklarifikasi di sini: <br><br>  a) algoritma <b>"kembali"</b> , ketika sebelum menelusuri seluruh perbatasan, kembali untuk mengunjungi piksel yang sudah dikunjungi, dan <br><br>  b) untuk setiap <b><i>tulang rusuk batas,</i></b> ada dua cara untuk <b>"melewatinya"</b> , yaitu "ke dalam" dan "ke luar" (di mana "ke dalam" berarti pergerakan ke dalam dari poligon yang sesuai, dan "ke luar" - ke luar dari poligon). <br><br>  Selain itu, ketika algoritma melewati "ke dalam" melalui salah satu tepi batas, itu akan melewati "ke luar" melalui tepi batas berikutnya, mis.  algoritme penelusuran kuadrat seharusnya tidak dapat melewati dua sisi berurutan dengan cara yang sama. <br><br>  <b>Pengamatan terakhir</b> <br><br>  Setiap pola memiliki <b>jumlah</b> <b>tepi batas</b> <b>genap</b> . <br><br>  Jika Anda melihat poligon dari <b><i>Gambar 5</i></b> , Anda dapat melihat bahwa: <br><br>  jika kita ingin memulai dari titik <b>S yang</b> ditandai dalam diagram dan mengikuti batas tepi sampai kita mencapai <b>S</b> lagi, maka kita perhatikan bahwa dalam proses kita melewati sejumlah tepi batas genap.  Kita dapat menganggap setiap batas batas sebagai "langkah" dalam arah yang terpisah.  Kemudian untuk setiap "langkah" ke kanan harus ada "langkah" yang sesuai ke kiri, jika kita ingin kembali ke posisi awal.  Hal yang sama berlaku untuk "langkah" vertikal.  Oleh karena itu, "langkah-langkah" harus memiliki pasangan yang sesuai, dan ini menjelaskan mengapa masing-masing pola ini akan memiliki jumlah tepi batas genap. <br><br>  Oleh karena itu, ketika algoritma untuk melacak kotak masuk melalui <b>batas batas awal</b> (dari piksel awal) untuk kedua kalinya, maka ia akan melakukannya <b>dengan</b> arah yang <b>sama</b> dengan yang pertama kali. <br><br>  Alasan untuk ini adalah karena ada dua cara untuk pergi melalui batas tepi, dan algoritma bergantian bergerak ke dalam dan ke luar, dan ada sejumlah tepi batas, algoritma akan melalui tepi batas awal untuk kedua kalinya dengan cara yang sama seperti di yang pertama. <br><br><h4>  Kesimpulan </h4><br>  Dalam kasus pola dan latar belakang yang terhubung 4, algoritme jejak kuadrat akan mendeteksi seluruh perbatasan, mis.  kontur, pola, dan akan berhenti bekerja setelah satu jejak, yaitu  itu tidak akan melacaknya lagi, karena ketika mencapai <b>batas batas awal</b> untuk kedua kalinya, itu akan masuk dengan cara yang sama seperti pertama kali.  Oleh karena itu, algoritme jejak kuadrat dengan kriteria stop Jacob akan dengan benar menentukan penghitung pola apa pun, asalkan pola dan latar belakangnya terhubung 4. <br><br><h2>  Menelusuri lingkungan Moore </h2><br><h4>  Ide </h4><br>  Gagasan di balik penelusuran Moore-Tetangga itu sederhana;  tetapi sebelum menjelaskannya, kita perlu menjelaskan konsep penting: <b><i>lingkungan Moore dari sebuah</i></b> piksel. <br><br><h4>  Lingkungan Moore </h4><br>  Lingkungan Moore dari piksel <b>P</b> adalah satu set 8 piksel yang memiliki simpul atau tepi yang sama dengan piksel tersebut.  Pixel tersebut, yaitu <b>P1, P2, P3, P4, P5, P6, P7 dan P8</b> , ditunjukkan pada <b><i>Gambar 1</i></b> . <br><br>  Lingkungan Moore (juga disebut <b><i>8-tetangga</i></b> atau <b><i>tetangga tidak langsung</i></b> ) adalah konsep penting yang sering disebut dalam literatur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/863/08c/2ea/86308c2ea8863bc111d206fb5070250f.gif" height="195" width="178"></div><br>  Sekarang kita siap untuk berkenalan dengan ide yang mendasari jejak lingkungan Moore. <br><br>  Biarkan ada pola digital, mis.  sekelompok piksel hitam, dengan latar belakang piksel putih, mis.  di grid;  temukan piksel hitam dan nyatakan sebagai piksel " <b>awal</b> ".  (Ada beberapa cara untuk menemukan piksel " <b>awal</b> ", tetapi kami, seperti sebelumnya, akan mulai dari sudut kiri bawah dan memindai semua kolom piksel secara berurutan, hingga kami menemukan piksel hitam pertama, yang akan kami nyatakan sebagai " <b>awal</b> ".) <br><br>  Sekarang lagi, bayangkan Anda seorang ladybug yang berdiri di piksel <b>awal</b> , seperti yang ditunjukkan pada <b><i>Gambar 2 di</i></b> bawah ini.  Tanpa kehilangan generalisasi, kami akan mendeteksi garis besar dengan bergerak di sekitar pola searah jarum jam.  (Tidak peduli arah mana yang kita pilih, hal utama adalah menggunakannya secara konstan dalam algoritma). <br><br>  Gagasan umumnya adalah ini: setiap kali kita sampai pada piksel hitam <b>P</b> , kita kembali, yaitu ke piksel putih tempat kita berdiri sebelumnya.  Lalu <b>kita</b> berkeliling pixel <b>P</b> searah jarum jam, mengunjungi setiap piksel di sekitar Moore, sampai kita sampai ke piksel hitam.  Algoritma berakhir ketika piksel awal mencapai piksel awal untuk kedua kalinya. <br><br>  Piksel hitam yang dikunjungi algoritma akan menjadi garis besar pola. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/afb/a2f/43eafba2f0611e11eb82c8ed7159971c.gif" height="252" width="216"></div><br><h4>  Algoritma </h4><br>  Berikut ini adalah deskripsi formal dari algoritma penelusuran lingkungan Moore: <br><br>  Input: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tessellation</a> kuadrat <b>T yang</b> mengandung komponen <b>P</b> sel-sel hitam yang terhubung. <br><br>  Output: baris <b>B (b <sub>1</sub> , b <sub>2</sub> , ..., b <sub>k</sub> ) dari</b> piksel batas, mis.  kontur. <br><br>  Ditunjukkan oleh <b>M (a)</b> lingkungan Moore dari pixel <b>a</b> . <br><br>  Biarkan <b>p</b> menjadi piksel batas saat ini. <br><br>  Biarkan <b>c</b> menjadi piksel saat ini dalam pertimbangan, mis.  <b>c</b> ada di <b>M (p)</b> . <br><br>  Mulai <br><br><ul><li>  Tentukan <b>B</b> sebagai set kosong. </li><li>  Dari bawah ke atas dan dari kiri ke kanan, pindai sel <b>T</b> hingga kami menemukan piksel hitam <b>s</b> dari <b>P.</b> </li><li>  Masukkan <b>s</b> ke <b>B.</b> </li><li>  Kami menetapkan titik <b>s</b> sebagai titik batas <b>p</b> saat ini, mis.  <b>p = s</b> </li><li>  Ayo kembali, mis.  mari kita beralih ke pixel dari mana kita sampai. </li><li>  Biarkan <b>c menjadi</b> piksel searah jarum jam berikutnya dalam <b>M (p)</b> . </li><li>  Sementara <b>c</b> tidak sama dengan <b>s</b> , jalankan <br><br><ul><li>  jika <b>c</b> berwarna hitam <br><ul><li>  Masukkan <b>c</b> ke <b>B</b> </li><li>  kita atur <b>p = c</b> </li><li>  kembali (pindahkan piksel saat ini <b>c</b> ke piksel dari mana kita harus <b>p</b> ) </li></ul><br>  jika tidak <br><ul><li>  pindahkan piksel saat ini <b>c</b> ke piksel searah jarum jam berikutnya dalam <b>M (p)</b> </li></ul><br>  Akhir Siklus Dah </li></ul></li></ul><br>  Akhirnya <br><br><h4>  Demonstrasi </h4><br>  Berikut ini adalah demonstrasi animasi tentang bagaimana jejak lingkungan Moore melakukan deteksi pola garis besar.  (Kami memutuskan untuk melacak garis searah jarum jam.) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/544/3f0/295/5443f02954a35cf08c7a9e462bfa0f8a.gif" height="360" width="360"></div><br><h4>  Analisis </h4><br>  Kelemahan utama dalam melacak lingkungan Moore terletak pada pilihan kriteria berhenti. <br><br>  Dalam uraian asli algoritma untuk melacak lingkungan Moore, kriteria berhenti adalah untuk memukul piksel <b>awal</b> untuk kedua kalinya.  Mirip dengan algoritma penelusuran persegi, ternyata menelusuri lingkungan Moore menggunakan kriteria ini tidak dapat mendeteksi kontur pola keluarga besar. <br><br>  Berikut ini adalah demo animasi yang menjelaskan mengapa algoritme tidak dapat menemukan garis besar pola yang tepat karena pemilihan kriteria berhenti buruk: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1c/d5e/7af/a1cd5e7afa1cd1b7312e5770c6cf826c.gif" height="252" width="216"></div><br>  Seperti yang Anda lihat, meningkatkan kriteria penghentian bisa menjadi awal yang baik untuk meningkatkan kinerja keseluruhan jejak.  Ada dua alternatif efektif untuk kriteria penutupan, mirip dengan kriteria penutupan Yakub. <br><br>  Menggunakan kriteria Jacob secara signifikan meningkatkan efektivitas penelusuran lingkungan Moore, menjadikannya algoritma terbaik untuk menentukan kontur pola apa pun, terlepas dari konektivitasnya. <br><br>  Alasan untuk ini terutama karena algoritma memeriksa seluruh lingkungan Moore dari piksel batas untuk mencari piksel batas berikutnya.  Berbeda dengan algoritma penelusuran kuadrat, yang hanya berputar ke kiri dan ke kanan dan melewatkan piksel “secara diagonal,” penelusuran lingkungan Moore akan selalu dapat mendeteksi batas luar komponen yang terhubung.  Alasannya adalah ini: untuk pola <b><i>8-terhubung</i></b> (atau hanya <b><i>terhubung</i></b> ), pixel perbatasan <b>berikutnya</b> terletak di dalam lingkungan Moore dari pixel perbatasan saat ini.  Karena penelusuran lingkungan Moore memeriksa masing-masing piksel di lingkungan Moore dari piksel batas saat ini, ia harus mendeteksi piksel batas berikutnya. <br><br>  Ketika penelusuran lingkungan Moore mencapai piksel awal untuk kedua kalinya dengan cara yang sama seperti yang ia lakukan pertama kali, ini berarti bahwa <b>kontur eksternal</b> <b>lengkap</b> <b>dari</b> pola telah terdeteksi, dan jika algoritme tidak dihentikan, ia akan kembali mendeteksi kontur yang sama. <br><br><h2>  Pemindaian radial </h2><br>  Radial Sweep Algorithm adalah algoritma pendeteksian kontur yang dibahas dalam beberapa buku.  Terlepas dari nama yang rumit, ide yang mendasarinya sangat sederhana.  Bahkan, ternyata algoritma sapuan radial <b>identik dengan</b> jejak lingkungan Moore.  Seseorang mungkin bertanya: "Mengapa kita menyebutkannya?" <br><br>  Menelusuri lingkungan Moore mencari di sekitar Moore untuk pixel batas saat ini dalam arah tertentu (kami memilih arah searah jarum jam) sampai menemukan pixel hitam.  Dia kemudian menyatakan piksel itu sebagai piksel batas saat ini dan berlanjut. <br><br>  Algoritma pemindaian radial melakukan hal yang sama.  Di sisi lain, ini menyediakan cara yang menarik untuk menemukan piksel hitam berikutnya di lingkungan Moore dari piksel batas yang diberikan. <br><br>  Metode ini didasarkan pada gagasan berikut: <br><br>  setiap kali kami menemukan piksel batas baru, jadikan itu piksel <b>P</b> saat ini, dan gambar <b>segmen garis imajiner yang</b> menghubungkan <b>P</b> dengan piksel batas <b>sebelumnya</b> .  Lalu kami <b>memutar</b> segmen relatif ke <b>P</b> searah jarum jam hingga muncul piksel hitam di lingkungan Moore dari piksel <b>P.</b>  Rotasi garis identik dengan memeriksa setiap piksel di sekitar Moore <b>P.</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami membuat demonstrasi animasi tentang bagaimana algoritma pemindaian radial bekerja dan bagaimana tampilannya menelusuri lingkungan Moore. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa1/419/ff6/fa1419ff6b8efc7ef94d978854f99fab.gif" height="360" width="326"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan kapan algoritma sapuan radial berhenti? </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita jelaskan perilaku algoritma menggunakan kriteria berhenti berikut ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hentikan kriteria 1 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biarkan algoritma pemindaian radial selesai ketika mengunjungi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">piksel awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk kedua kalinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bawah ini adalah demo animasi, yang jelas mengapa kriteria break akan diubah dengan benar.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04c/432/408/04c432408fca093316e950c77bdd5537.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu juga disebutkan bahwa ketika menggunakan kriteria berhenti ini di kedua algoritma, efektivitas algoritma pemindaian radial identik dengan penelusuran lingkungan Moore. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam algoritma penelusuran kuadrat dan penelusuran lingkungan Moore, kami menemukan bahwa menggunakan kriteria berhenti Jacob secara signifikan meningkatkan kinerja kedua algoritma. </font></font><br><br> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kriteria berhenti Jacob</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengharuskan algoritma untuk berhenti mengeksekusi ketika mengunjungi </font><font style="vertical-align: inherit;">pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk kedua kalinya dalam arah yang sama dengan yang pertama kali. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, kami tidak dapat menggunakan kriteria stop Jacob dalam algoritme sapuan radial. Alasannya adalah bahwa algoritma pemindaian radial tidak mendefinisikan konsep</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Arah" di mana ia menyentuh piksel batas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dengan kata lain, tidak jelas "arah" di mana algoritma jatuh ke piksel batas (dan definisinya adalah nontrivial). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, kita perlu mengusulkan kriteria penghentian lain, yang tidak tergantung pada arah memukul piksel tertentu, yang dapat meningkatkan efektivitas algoritma pemindaian radial ...</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hentikan kriteria 2 </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan setiap kali algoritme mendeteksi piksel batas baru </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dimasukkan ke dalam </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serangkaian</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> piksel batas: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; dan dinyatakan sebagai piksel batas saat ini. ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami akan mempertimbangkan </font><font style="vertical-align: inherit;">piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ini berarti bahwa kita mengetahui batas piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-1 sebelumnya dari</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setiap piksel batas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i saat ini</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Adapun </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">piksel awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kami akan menganggap bahwa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah piksel imajiner yang tidak sepadan dengan piksel di grid yang menghadap </font><font style="vertical-align: inherit;">piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di deretan piksel batas). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengingat asumsi di atas, kita dapat menentukan kriteria berhenti sebagai berikut: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma berakhir eksekusi ketika: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) arus batas pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> telah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelumnya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bertemu sebagai pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (di mana </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j &lt;i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dalam rangkaian piksel batas, dan </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i- 1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = P </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j-1</font></font></sub></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan kata lain, algoritma menyelesaikan eksekusi ketika mengunjungi batas pixel P pada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">detik</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lagi, jika pixel batas untuk P (dalam serangkaian piksel batas) di kedua kalinya adalah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sama</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel yang ke P, ketika P dikunjungi oleh </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pertama</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kalinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kondisi kriteria stop terpenuhi dan algoritme tidak dimatikan, maka algoritme pemindaian radial akan terus mendeteksi </font><font style="vertical-align: inherit;">batas yang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sama</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk kedua kalinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kinerja algoritme sapuan radial dengan kriteria penghentian ini mirip dengan kinerja penelusuran lingkungan Moore dengan kriteria penghentian Jacob.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritma Theo Pavlidis </font></font></h2><br><h4>  Ide </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma ini adalah salah satu algoritma deteksi loop terbaru yang diusulkan oleh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theo Pavlidis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dia mengutipnya dalam bukunya tahun 1982 </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma untuk Grafis dan Pemrosesan Gambar</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (bab 7, bagian 5). Ini tidak sesederhana algoritma untuk menelusuri kotak atau menelusuri lingkungan Moore, tetapi tidak begitu rumit (ini khas untuk kebanyakan algoritma deteksi tepi). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami tidak akan menjelaskan algoritma ini dengan cara yang sama seperti yang dilakukan dalam bukunya. Pendekatan kami lebih mudah dipahami dan memberikan gagasan tentang ide umum yang mendasari algoritma.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanpa kehilangan generalisasi, kami memutuskan untuk memutar loop searah jarum jam untuk mencocokkan urutan semua algoritma lain yang disajikan dalam artikel. Di sisi lain, Pavlidis memilih arah berlawanan arah jarum jam. Ini tidak akan mempengaruhi kinerja algoritma. Satu-satunya perbedaan adalah arah relatif dari gerakan yang akan kita lakukan ketika kita mengelilingi kontur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang mari kita beralih ke ide ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Katakanlah kita memiliki pola digital, yaitu sekelompok piksel hitam pada latar belakang piksel putih, mis. di grid; temukan piksel hitam dan nyatakan sebagai </font><font style="vertical-align: inherit;">piksel " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". Anda dapat mencari </font><font style="vertical-align: inherit;">piksel " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " dengan berbagai cara, misalnya, seperti dijelaskan di atas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menemukan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inisial</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">piksel untuk menggunakan metode ini adalah opsional. Sebagai gantinya, kami akan memilih </font><font style="vertical-align: inherit;">piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang memenuhi batasan berikut yang diberlakukan oleh algoritma Pavlidis untuk memilih piksel awal: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Batasan penting dari arah masuknya piksel awal.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faktanya, Anda dapat memilih SETIAP piksel perbatasan hitam sebagai piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam kondisi ini: jika Anda awalnya berdiri di atasnya, piksel tetangga sebelah kiri TIDAK hitam. Dengan kata lain, Anda harus memasukkan </font><font style="vertical-align: inherit;">piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sedemikian rupa sehingga piksel tetangga sebelahnya berwarna putih ("kiri" di sini diambil relatif terhadap arah </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masuknya piksel awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang bayangkan Anda seorang ladybug berdiri</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mulai</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pixel, seperti yang ditunjukkan pada </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 1 di</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bawah ini. Selama eksekusi algoritme, kami hanya akan tertarik pada tiga piksel di depan Anda, mis. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditunjukkan pada </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 1</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . (Kami akan menetapkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebagai </font><font style="vertical-align: inherit;">piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di depan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah piksel di sebelah kiri </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah piksel di sebelah kanan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/792/4b1/53e7924b1a7cb6c5e84f70a038d52bc8.gif" height="252" width="216"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti halnya dengan algoritma jejak kuadrat, hal terpenting dalam algoritma Pavlidis adalah “sense of direction”. Belok kiri dan kanan relatif terhadap posisi saat ini, yang tergantung pada bagaimana Anda memasukkan piksel saat ini. Karena itu, untuk membuat gerakan yang benar, penting untuk melacak orientasi Anda saat ini. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi tidak peduli bagaimana Anda berada, piksel P1, P2 dan P3 ditentukan seperti yang dijelaskan di atas.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dengan informasi ini, kami siap menjelaskan algoritme ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap kali Anda berdiri di piksel batas saat ini (yang merupakan </font><font style="vertical-align: inherit;">piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), kami melakukan yang berikut: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , periksa piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berwarna hitam, maka nyatakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixel batas saat ini dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bergerak satu langkah maju, dan kemudian mengambil langkah ke kiri</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk berada di P1 ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">urutan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gerakan sangat penting). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 2</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di bawah ini menggambarkan hal ini. </font><font style="vertical-align: inherit;">Jalur menuju ke </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditunjukkan dengan warna biru.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae9/c32/131/ae9c321310cb5a8902ae4df3dc42cdc9.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan hanya jika P1 berwarna putih, pergi untuk memeriksa P2 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berwarna hitam, maka mendeklarasikan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> piksel batas saat ini dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bergerak satu langkah maju</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk berada pada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kasus ini ditunjukkan pada </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 3 di</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bawah ini. </font><font style="vertical-align: inherit;">Jalur yang harus Anda ikuti pada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditunjukkan dengan warna biru.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/7eb/934/b347eb9345873e5ba6aa136ab2fbb406.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hanya jika P1 dan P2 berwarna putih, buka untuk memeriksa P3 ...</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berwarna hitam, maka nyatakan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> piksel batas saat ini dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gerakkan satu langkah ke kanan, lalu satu langkah ke kiri</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , seperti yang ditunjukkan pada Gambar 4 di bawah ini.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ad/bb6/7fa/0adbb67fa67183dec47bb4c1bf3221a7.gif" height="180" width="206"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu saja!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tiga aturan sederhana untuk tiga kasus sederhana. Seperti yang Anda lihat, penting untuk melacak arah Anda saat menikung, karena semua gerakan dibuat relatif terhadap orientasi saat ini. Tapi sepertinya kita lupa sesuatu? </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana jika ketiga piksel putih di depan kita?</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kemudian kita memutar (berdiri di piksel batas saat ini) 90 derajat searah jarum jam untuk melihat set baru tiga piksel di depan kita. Kemudian kami melakukan pemeriksaan yang sama untuk piksel baru ini. Anda mungkin masih tetap pertanyaan: Bagaimana jika semua </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiga piksel akan menjadi putih?! Kemudian lagi kita putar 90 derajat searah jarum jam, berdiri pada piksel yang sama. Sebelum Anda memeriksa seluruh lingkungan piksel Moore, Anda dapat memutar tiga kali (setiap kali 90 derajat searah jarum jam).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita memutar tiga kali tanpa pernah menemukan piksel hitam, maka ini berarti kita berdiri pada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">piksel yang terisolasi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tidak terhubung ke piksel hitam lainnya. </font><font style="vertical-align: inherit;">Itulah sebabnya algoritma memungkinkan Anda untuk memutar tiga kali, dan kemudian menyelesaikan eksekusi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aspek lain: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kapan algoritma menyelesaikan eksekusi? </font></font></i></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma berakhir dalam dua kasus: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) seperti yang disebutkan di atas. </font><font style="vertical-align: inherit;">algoritme memungkinkan Anda untuk memutar tiga kali (90 derajat searah jarum jam setiap kali), setelah menyelesaikan eksekusi dan mendeklarasikan piksel yang terisolasi ATAU </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) ketika piksel batas saat ini adalah </font><font style="vertical-align: inherit;">piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , algoritme menyelesaikan eksekusi dengan "menyatakan" bahwa ia mendeteksi garis besar pola.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritma </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini adalah deskripsi formal dari algoritma Pavlidis: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input: square </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tessellation </font></font></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengandung komponen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terhubung </font><font style="vertical-align: inherit;">sel hitam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Output: baris </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B (b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dari</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> piksel batas, mis. </font><font style="vertical-align: inherit;">kontur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Definisi:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ditunjukkan oleh </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> batas piksel saat ini, mis. </font><font style="vertical-align: inherit;">piksel tempat kami berdiri.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapkan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1, P2,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebagai berikut: </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(lihat juga Gambar 1 di atas)</font></font></i></b> </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah piksel di depan Anda, bersebelahan dengan piksel tempat Anda berdiri, mis. </font><font style="vertical-align: inherit;">dengan piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <b>P1</b> —  ,   <b>P2</b> . </li><li> <b>P3</b> —  ,   <b>P2</b> . </li><li>  <b>«»</b>            . </li></ul><br>  Mulai <br><br><ul><li>  <b>B</b>   . </li><li>   <b>T</b>     ,      <b></b>  <b>s</b>  <b>P</b> <b><i>(.     ,       )</i></b> </li><li>  <b>s</b>  <b>B</b> . </li><li>    <b>p</b>     <b>s</b> . </li><li>  : <br>   <b>P1</b>  <br><ul><li>  <b>P1</b>  <b>B</b> </li><li>  <b>p=P1</b> </li><li>     ,      </li></ul><br>   <b>P2</b>  <br><ul><li>  <b>P2</b>  <b>B</b> </li><li>  <b>p=P2</b> </li><li>      <b><i>(.   3)</i></b> </li></ul><br>   <b>P3</b>  <br><ul><li>  <b>P3</b>  <b>B</b> </li><li>  <b>p=P3</b> </li><li>    ,      <b><i>(.   4)</i></b> </li></ul><br>        90    ,   <b>  p</b> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menghentikan program dan mendeklarasikan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> piksel yang </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terisolasi</font></font></b><font style="vertical-align: inherit;"></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jika tidak </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">putar 90 derajat searah jarum jam, berdiri di </font><b><font style="vertical-align: inherit;">p</font></b><font style="vertical-align: inherit;"> piksel saat ini</font></font><b><font style="vertical-align: inherit;"></font></b> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejauh ini </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p = s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Akhiri loop berulang)</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akhirnya </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Demonstrasi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini adalah demonstrasi animasi tentang bagaimana algoritma Pavlidis mendeteksi kontur dari pola yang diberikan. </font><font style="vertical-align: inherit;">Jangan lupa bahwa kami berjalan dalam piksel; </font><font style="vertical-align: inherit;">perhatikan bagaimana orientasi berubah ketika belok kiri atau kanan. </font><font style="vertical-align: inherit;">Untuk menjelaskan algoritme sedetail mungkin, kami menyertakan semua kasus yang mungkin ada di dalamnya.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/f0f/1dd/22af0f1dd39a517bb6097cd0fe3ec99d.gif" height="324" width="288"></div><br><h4>  Analisis </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda berpikir bahwa algoritma Pavlidis ideal untuk mendeteksi garis pola, maka Anda harus berubah pikiran ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma ini benar-benar sedikit lebih rumit daripada, misalnya, menelusuri lingkungan Moore, di mana tidak ada kasus khusus yang memerlukan pemrosesan terpisah, tetapi tidak akan dapat menentukan garis besar dari besar keluarga pola yang memiliki jenis konektivitas tertentu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma bekerja dengan sangat baik pada pola 4-terhubung. Masalahnya terjadi ketika melacak beberapa pola 8-terhubung yang tidak 4-terhubung. Berikut ini adalah demonstrasi animasi tentang bagaimana algoritma Pavlidis gagal mendeteksi garis yang benar dari pola 8-terhubung (bukan 4-terhubung) - ia melompati sebagian besar perbatasan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/56a/816/22556a816442cf010492cc30b64392eb.gif" height="252" width="247"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada dua cara sederhana untuk memodifikasi suatu algoritma untuk secara signifikan meningkatkan kinerjanya. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a) Ganti kriteria berhenti</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alih-alih menyelesaikan algoritme saat mengunjungi piksel awal untuk kedua kalinya, Anda dapat mengakhirinya saat mengunjungi piksel awal untuk ketiga atau bahkan keempat kalinya. Ini akan meningkatkan kinerja keseluruhan algoritma. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATAU </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b) Dapatkan ke sumber masalah, yaitu, sebelum memilih piksel awal.Ada</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> batasan penting mengenai arah di mana entri ke piksel awal dilakukan. Pada dasarnya, Anda perlu memasukkan piksel awal sehingga ketika Anda berdiri di atasnya, piksel di sebelah kiri Anda berwarna putih. Alasan untuk memperkenalkan pembatasan ini adalah ini: karena kami selalu melihat tiga piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di depan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami pada</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam urutan tertentu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dalam beberapa pola kita akan melewati piksel batas yang terletak langsung di sebelah kiri piksel awal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami berisiko kehilangan tidak hanya piksel tetangga sebelah kiri dari piksel awal, tetapi juga </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">piksel tepat di bawahnya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (seperti yang ditunjukkan dalam analisis). Selain itu, dalam beberapa pola, piksel yang sesuai dengan piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 5 di</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bawah </font><font style="vertical-align: inherit;">ini akan dilewati </font><font style="vertical-align: inherit;">. Oleh karena itu, kami mengasumsikan bahwa piksel awal perlu dipukul sedemikian rupa sehingga piksel yang sesuai dengan piksel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L, W</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ditunjukkan pada </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 5 di</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bawah ini berwarna putih.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/a81/359/9c8a81359338b31b6f5c0e016230e629.gif" height="200" width="159"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, pola-pola seperti yang ditunjukkan pada demonstrasi akan dideteksi dengan benar dan efektivitas algoritma Pavlidis akan meningkat secara signifikan. </font><font style="vertical-align: inherit;">Di sisi lain, menemukan piksel awal yang memenuhi persyaratan ini dapat menjadi tantangan, dan dalam banyak kasus tidak mungkin menemukan piksel tersebut. </font><font style="vertical-align: inherit;">Dalam hal ini, Anda harus menggunakan cara alternatif untuk meningkatkan algoritma Pavlidis, yaitu penyelesaian algoritma setelah mengunjungi titik awal untuk ketiga kalinya.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467611/">https://habr.com/ru/post/id467611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467597/index.html">Personalisasi Pedoman Produk Big Data dengan Vowpal Wabbit</a></li>
<li><a href="../id467599/index.html">Render grafik 3D dengan OpenGL</a></li>
<li><a href="../id467605/index.html">Yang Anda butuhkan hanyalah URL</a></li>
<li><a href="../id467607/index.html">Pengakuan pembenci buruh pelabuhan</a></li>
<li><a href="../id467609/index.html">Membuat aplikasi seluler di React Native</a></li>
<li><a href="../id467615/index.html">Cara membuat pembungkus Python dan tidak menjadi gila</a></li>
<li><a href="../id467617/index.html">Kaspresso: kerangka kerja autotest yang Anda tunggu-tunggu</a></li>
<li><a href="../id467619/index.html">Aquafor pitcher adalah contoh yang baik tentang bagaimana filter untuk pengolahan air tidak dapat dirancang</a></li>
<li><a href="../id467621/index.html">Pertemuan Elasticsearch Moscow di Ozon</a></li>
<li><a href="../id467623/index.html">Bereaksi Asli: Membuat Bidang Input Animasi menggunakan API Animasi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>