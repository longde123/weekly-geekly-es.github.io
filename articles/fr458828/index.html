<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé± üçí üë©üèΩ‚Äçü§ù‚Äçüë®üèº Pourquoi, pourquoi et quand utiliser ValueTask üßíüèΩ üåà ‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cette traduction a √©t√© r√©alis√©e gr√¢ce au bon commentaire 0x1000000 . 
 




 Le .NET Framework 4 a introduit l'espace System.Threading.Tasks et, avec ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pourquoi, pourquoi et quand utiliser ValueTask</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458828/"><p>  <sup>Cette traduction a √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">r√©alis√©e</a> gr√¢ce au bon commentaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">0x1000000</a> .</sup> <sup><br></sup> </p><p><img src="https://habrastorage.org/webt/4t/kr/wh/4tkrwhp_br-sobqvgwwyimflsjq.jpeg" alt="image"></p><br><p>  Le .NET Framework 4 a introduit l'espace System.Threading.Tasks et, avec lui, la classe Task.  Ce type et la t√¢che &lt;TResult&gt; g√©n√©r√©e par celui-ci attendent depuis longtemps avant d'√™tre reconnus par les normes dans .NET comme les aspects cl√©s du mod√®le de programmation asynchrone introduit en C # 5 avec ses instructions async / attente.  Dans cet article, je parlerai de nouveaux types de ValueTask / ValueTask &lt;TResult&gt;, con√ßus pour am√©liorer les performances des m√©thodes asynchrones dans les cas o√π la surcharge d'allocation de m√©moire devrait √™tre prise en compte. </p><a name="habracut"></a><br><h3 id="task">  T√¢che </h3><br><p> La t√¢che agit dans diff√©rents r√¥les, mais le principal est la ¬´promesse¬ª (promesse), un objet repr√©sentant l'ach√®vement possible d'une op√©ration.  Vous lancez une op√©ration et obtenez un objet Task pour celle-ci, qui sera ex√©cut√© lorsque l'op√©ration sera termin√©e, ce qui peut se produire en mode synchrone dans le cadre de l'initialisation de l'op√©ration (par exemple, la r√©ception de donn√©es qui sont d√©j√† dans le tampon), en mode asynchrone avec ex√©cution au moment o√π vous obtenez Task (recevoir des donn√©es non pas du tampon, mais tr√®s rapidement), ou en mode asynchrone, mais apr√®s avoir d√©j√† Task (recevoir des donn√©es d'une ressource distante).  √âtant donn√© que l'op√©ration peut se terminer de mani√®re asynchrone, vous pouvez soit bloquer le flux d'ex√©cution, attendre le r√©sultat (ce qui rend souvent l'asynchronie de l'appel vide de sens), soit cr√©er une fonction de rappel qui sera activ√©e une fois l'op√©ration termin√©e.  Dans .Net 4, la cr√©ation d'un rappel est impl√©ment√©e par les m√©thodes ContinueWith de l'objet Task, qui illustrent explicitement ce mod√®le en acceptant une fonction d√©l√©gu√©e pour l'ex√©cuter apr√®s l'ex√©cution de la t√¢che: </p><br><pre><code class="plaintext hljs">SomeOperationAsync().ContinueWith(task =&gt; { try { TResult result = task.Result; UseResult(result); } catch (Exception e) { HandleException(e); } });</code> </pre> <br><p>  Mais dans le .NET Framework 4.5 et C # 5, les objets Task peuvent simplement √™tre appel√©s par l'op√©rateur wait, ce qui facilite l'obtention du r√©sultat d'une op√©ration asynchrone, et le code g√©n√©r√© optimis√© pour les options ci-dessus fonctionnera correctement dans tous les cas lorsque l'op√©ration se terminera en mode synchrone, asynchrone rapide ou asynchrone avec le rappel: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  La t√¢che est une classe tr√®s flexible et pr√©sente un certain nombre d'avantages.  Par exemple, vous pouvez effectuer plusieurs fois l'attente pour n'importe quel nombre de consommateurs √† la fois.  Vous pouvez le mettre dans une collection (dictionnaire) pour des attentes r√©p√©t√©es √† l'avenir, pour l'utiliser comme cache des r√©sultats des appels asynchrones.  Vous pouvez bloquer l'ex√©cution en attendant la fin de la t√¢che si n√©cessaire.  Et vous pouvez √©crire et appliquer diverses op√©rations sur des objets de t√¢che (parfois appel√©s ¬´combinateurs¬ª), par exemple, ¬´le cas √©ch√©ant¬ª pour attendre de mani√®re asynchrone la premi√®re ex√©cution de plusieurs t√¢ches. <br>  Mais cette flexibilit√© devient superflue dans le cas le plus courant: il suffit d'appeler l'op√©ration asynchrone et d'attendre la fin de la t√¢che: </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  Ici, nous n'avons pas besoin d'attendre l'ex√©cution plusieurs fois.  Nous n'avons pas besoin de nous assurer que les attentes sont comp√©titives.  Nous n'avons pas besoin d'effectuer un verrouillage synchrone.  Nous n'√©crirons pas de combinateurs.  Nous attendons juste que la promesse d'une op√©ration asynchrone soit termin√©e.  En fin de compte, c'est la fa√ßon dont nous √©crivons le code synchrone (par exemple, TResult result = SomeOperation ();), et il est normalement traduit en async / wait. </p><br><p>  De plus, Task a une faiblesse potentielle, en particulier lorsqu'un grand nombre d'instances sont cr√©√©es, et un d√©bit et des performances √©lev√©s sont des exigences cl√©s - Task est une classe.  Cela signifie que toute op√©ration qui avait besoin d'une t√¢che est oblig√©e de cr√©er et de placer un objet, et plus il y a d'objets cr√©√©s, plus le garbage collector (GC) est charg√©, et ce travail consomme des ressources que nous pourrions d√©penser pour quelque chose de plus utile. </p><br><p>  Les biblioth√®ques d'ex√©cution et syst√®me aident √† att√©nuer ce probl√®me dans de nombreuses situations.  Par exemple, si nous √©crivons une m√©thode comme celle-ci: </p><br><pre> <code class="plaintext hljs">public async Task WriteAsync(byte value) { if (_bufferedCount == _buffer.Length) { await FlushAsync(); } _buffer[_bufferedCount++] = value; }</code> </pre> <br><p>  en r√®gle g√©n√©rale, il y aura suffisamment d'espace libre dans le tampon et l'op√©ration sera ex√©cut√©e de mani√®re synchrone.  Lorsque cela se produit, il n'est pas n√©cessaire de faire quoi que ce soit avec la t√¢che, qui doit √™tre renvoy√©e, car il n'y a pas de valeur de retour, cela utilise la t√¢che comme l'√©quivalent d'une m√©thode synchrone renvoyant une valeur vide (void).  Par cons√©quent, l'environnement peut simplement mettre en cache une t√¢che non g√©n√©rique et l'utiliser √† plusieurs reprises comme r√©sultat de l'ex√©cution pour toute m√©thode asynchrone qui se termine de mani√®re synchrone (ce singleton mis en cache peut √™tre obtenu via Task.CompletedTask).  Ou, par exemple, vous √©crivez: </p><br><pre> <code class="plaintext hljs">public async Task&lt;bool&gt; MoveNextAsync() { if (_bufferedCount == 0) { await FillBuffer(); } return _bufferedCount &gt; 0; }</code> </pre> <br><p>  et en g√©n√©ral, attendez-vous √† ce que les donn√©es soient d√©j√† dans le tampon, de sorte que la m√©thode v√©rifie simplement la valeur de _bufferedCount, voit qu'elle est sup√©rieure √† 0 et renvoie true;  et uniquement s'il n'y a pas encore de donn√©es dans le tampon, vous devez effectuer une op√©ration asynchrone.  Et comme il n'y a que deux r√©sultats possibles de type bool√©en (vrai et faux), il n'y a que deux objets Task possibles qui sont n√©cessaires pour repr√©senter ces r√©sultats, l'environnement peut mettre en cache ces objets et les renvoyer avec la valeur correspondante sans allouer de m√©moire.  Uniquement en cas d'ach√®vement asynchrone, la m√©thode devra cr√©er une nouvelle t√¢che, car elle devra √™tre renvoy√©e avant que le r√©sultat de l'op√©ration ne soit connu. <br></p><p>  L'environnement fournit la mise en cache pour certains autres types, mais il n'est pas r√©aliste de mettre en cache tous les types possibles.  Par exemple, la m√©thode suivante: </p><br><pre> <code class="plaintext hljs">public async Task&lt;int&gt; ReadNextByteAsync() { if (_bufferedCount == 0) { await FillBuffer(); } if (_bufferedCount == 0) { return -1; } _bufferedCount--; return _buffer[_position++]; }</code> </pre> <br><p>  sera √©galement souvent ex√©cut√© de mani√®re synchrone.  Mais contrairement √† une variante avec un r√©sultat de type bool√©en, cette m√©thode renvoie Int32, qui a environ 4 milliards de valeurs, et la mise en cache de toutes les variantes de Task &lt;int&gt; n√©cessitera des centaines de gigaoctets de m√©moire.  L'environnement fournit un petit cache pour la t√¢che &lt;int&gt;, mais un ensemble tr√®s limit√© de valeurs, par exemple, si cette m√©thode se termine de mani√®re synchrone (les donn√©es sont d√©j√† dans le tampon) avec la valeur de retour de 4, ce sera une t√¢che mise en cache, mais si la valeur 42 est retourn√©e, vous devrez en cr√©er une nouvelle T√¢che &lt;int&gt;, similaire √† l'appel de Task.FromResult (42). </p><br><p>  De nombreuses m√©thodes de biblioth√®que tentent de r√©soudre ce probl√®me en fournissant leur propre cache.  Par exemple, une surcharge dans le .NET Framework 4.5 de la m√©thode MemoryStream.ReadAsync se termine toujours de mani√®re synchrone, car il lit les donn√©es de la m√©moire.  ReadAsync renvoie une t√¢che &lt;int&gt;, o√π un r√©sultat Int32 indique le nombre d'octets lus.  Cette m√©thode est souvent utilis√©e dans une boucle, souvent avec le m√™me nombre d'octets requis pour chaque appel, et souvent ce besoin est enti√®rement satisfait.  Ainsi, pour les appels r√©p√©t√©s √† ReadAsync, il est raisonnable de s'attendre √† ce que la t√¢che &lt;int&gt; revienne de mani√®re synchrone avec la m√™me valeur que lors de l'appel pr√©c√©dent.  Par cons√©quent, un MemoryStream cr√©e un cache pour un objet qui est retourn√© lors du dernier appel r√©ussi.  Et dans le prochain appel, si le r√©sultat est r√©p√©t√©, il renverra l'objet mis en cache et sinon, en cr√©era un nouveau avec Task.FromResult, l'enregistrera dans le cache et le renverra. </p><br><p>  N√©anmoins, il existe de nombreux autres cas o√π l'op√©ration est effectu√©e de mani√®re synchrone, mais l'objet Task &lt;TResult&gt; est oblig√© d'√™tre cr√©√©. </p><br><h4 id="valuetasktresult-i-sinhronnoe-vypolnenie">  ValueTask &lt;TResult&gt; et ex√©cution synchrone </h4><br><p>  Tout cela a n√©cessit√© l'impl√©mentation d'un nouveau type dans .NET Core 2.0, qui √©tait disponible dans les versions pr√©c√©dentes de .NET dans le package NuGet System.Threading.Tasks.Extensions: ValueTask &lt;TResult&gt;. <br>  ValueTask &lt;TResult&gt; a √©t√© cr√©√© dans .NET Core 2.0 en tant que structure capable d'encapsuler TResult et Task &lt;TResult&gt;.  Cela signifie qu'elle peut √™tre renvoy√©e par la m√©thode async, et si cette m√©thode est ex√©cut√©e de mani√®re synchrone et r√©ussie, vous n'avez pas besoin de placer d'objet sur le tas: vous pouvez simplement initialiser cette structure ValueTask &lt;TResult&gt; avec la valeur TResult et la renvoyer.  Seulement dans le cas d'une ex√©cution asynchrone, l'objet Task &lt;TResult&gt; sera plac√©, et ValueTask &lt;TResult&gt; l'enveloppera (pour minimiser la taille de la structure et optimiser le cas d'une ex√©cution r√©ussie, la m√©thode async, qui se termine par une exception non prise en charge, placera √©galement la t√¢che &lt;TResult&gt;, donc ValueTask &lt;TResult&gt; encapsule √©galement simplement la t√¢che &lt;TResult&gt;, et ne comporte pas de champ suppl√©mentaire pour stocker l'exception). </p><br><p>  Sur cette base, une m√©thode comme MemoryStream.ReadAsync, mais renvoyant une ValueTask &lt;int&gt;, ne devrait pas traiter la mise en cache, mais peut √† la place √™tre √©crite comme ceci: </p><br><pre> <code class="plaintext hljs">public override ValueTask&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask&lt;int&gt;(bytesRead); } catch (Exception e) { return new ValueTask&lt;int&gt;(Task.FromException&lt;int&gt;(e)); } }</code> </pre> <br><h4 id="valuetasktresult-i-asinhronnoe-vypolnenie">  ValueTask &lt;TResult&gt; et ex√©cution asynchrone </h4><br><p>  La possibilit√© d'√©crire une m√©thode asynchrone qui peut se terminer de mani√®re synchrone sans avoir besoin de placement suppl√©mentaire pour le r√©sultat est une grande victoire.  C'est pourquoi ValueTask &lt;TResult&gt; a √©t√© ajout√© dans .NET Core 2.0, et de nouvelles m√©thodes susceptibles d'√™tre utilis√©es dans des applications qui n√©cessitent des performances sont d√©sormais annonc√©es avec le retour de ValueTask &lt;TResult&gt; au lieu de Task &lt;TResult&gt;.  Par exemple, lorsque nous avons ajout√© une nouvelle surcharge ReadAsync de la classe Stream √† .NET Core 2.1, afin de pouvoir transmettre la m√©moire au lieu de l'octet [], nous y retournons le type ValueTask &lt;int&gt;.  Sous cette forme, les objets Stream (dans lesquels la m√©thode ReadAsync est tr√®s souvent ex√©cut√©e de mani√®re synchrone, comme dans l'exemple pr√©c√©dent pour le MemoryStream) peuvent √™tre utilis√©s avec beaucoup moins d'allocation de m√©moire. <br></p><p>  Cependant, lorsque nous travaillons avec des services √† tr√®s large bande passante, nous voulons toujours √©viter l'allocation de m√©moire autant que possible, ce qui signifie √©galement r√©duire et √©liminer l'allocation de m√©moire le long de la route d'ex√©cution asynchrone. <br>  Dans le mod√®le en attente, pour toute op√©ration qui se termine de mani√®re asynchrone, nous avons besoin de la possibilit√© de renvoyer un objet qui repr√©sente la fin possible de l'op√©ration: l'appelant doit rediriger le rappel qui sera initi√© √† la fin de l'op√©ration, et cela n√©cessite un objet unique dans le tas, qui peut servir de canal de transfert pour cette op√©ration particuli√®re.  En m√™me temps, cela ne veut rien dire si cet objet sera r√©utilis√© une fois l'op√©ration termin√©e.  Si cet objet peut √™tre r√©utilis√©, l'API peut organiser un cache pour un ou plusieurs de ces objets et l'utiliser pour des op√©rations s√©quentielles, dans le sens de ne pas utiliser le m√™me objet pour plusieurs op√©rations asynchrones interm√©diaires, mais pour un acc√®s non concurrentiel. <br>  Dans .NET Core 2.1, la classe ValueTask &lt;TResult&gt; a √©t√© am√©lior√©e pour prendre en charge le regroupement et la r√©utilisation similaires.  Au lieu de simplement encapsuler TResult ou Task &lt;TResult&gt;, une classe r√©vis√©e peut encapsuler une nouvelle interface IValueTaskSource &lt;TResult&gt;.  Cette interface fournit les fonctionnalit√©s de base requises pour accompagner une op√©ration asynchrone avec un objet ValueTask &lt;TResult&gt; de la m√™me mani√®re que la t√¢che &lt;TResult&gt;: </p><br><pre> <code class="plaintext hljs">public interface IValueTaskSource&lt;out TResult&gt; { ValueTaskSourceStatus GetStatus(short token); void OnCompleted(Action&lt;object&gt; continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags); TResult GetResult(short token); }</code> </pre> <br><p>  La m√©thode GetStatus est utilis√©e pour impl√©menter des propri√©t√©s telles que ValueTask &lt;TResult&gt; .IsCompleted, qui renvoie des informations indiquant si une op√©ration asynchrone est effectu√©e ou termin√©e, et comment elle est termin√©e (r√©ussie ou non).  La m√©thode OnCompleted est utilis√©e par l'objet en attente pour attacher un rappel afin de poursuivre l'ex√©cution √† partir du point d'attente une fois l'op√©ration termin√©e.  Et la m√©thode GetResult est n√©cessaire pour obtenir le r√©sultat de l'op√©ration, donc apr√®s la fin de l'op√©ration, l'appelant peut obtenir l'objet TResult ou passer toute exception lev√©e. </p><br><p>  La plupart des d√©veloppeurs n'ont pas besoin de cette interface: les m√©thodes renvoient simplement un objet ValueTask &lt;TResult&gt;, qui peut √™tre cr√©√© comme encapsuleur pour un objet qui impl√©mente cette interface, et la m√©thode appelante restera dans le noir.  Cette interface est destin√©e aux d√©veloppeurs qui doivent √©viter l'allocation de m√©moire lors de l'utilisation d'une API critique pour les performances. </p><br><p>  Il existe plusieurs exemples d'une telle API dans .NET Core 2.1.  Les m√©thodes les plus connues sont Socket.ReceiveAsync et Socket.SendAsync avec de nouvelles surcharges ajout√©es en 2.1, par exemple </p><br><pre> <code class="plaintext hljs">public ValueTask&lt;int&gt; ReceiveAsync(Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);</code> </pre> <br><p>  Cette surcharge renvoie une ValueTask &lt;int&gt;.  Si l'op√©ration se termine de mani√®re synchrone, il peut simplement renvoyer une ValueTask &lt;int&gt; avec la valeur correspondante: </p><br><pre> <code class="plaintext hljs">int result = ‚Ä¶; return new ValueTask&lt;int&gt;(result);</code> </pre> <br><p>  Lorsqu'il est termin√© de mani√®re asynchrone, il peut utiliser un objet du pool qui impl√©mente l'interface: </p><br><pre> <code class="plaintext hljs">IValueTaskSource&lt;int&gt; vts = ‚Ä¶; return new ValueTask&lt;int&gt;(vts);</code> </pre> <br><p>  L'impl√©mentation Socket prend en charge un tel objet dans le pool pour la r√©ception et un pour la transmission, car il ne peut pas y avoir plus d'un objet pour chaque direction en attente d'√™tre ex√©cut√© en m√™me temps.  Ces surcharges n'allouent pas de m√©moire, m√™me dans le cas d'une op√©ration asynchrone.  Ce comportement est plus apparent dans la classe NetworkStream. <br>  Par exemple, dans .NET Core 2.1 Stream fournit: </p><br><pre> <code class="plaintext hljs">public virtual ValueTask&lt;int&gt; ReadAsync(Memory&lt;byte&gt; buffer, CancellationToken cancellationToken);</code> </pre> <br><p>  qui est red√©fini dans NetworkStream.  La m√©thode NetworkStream.ReadAsync utilise simplement la m√©thode Socket.ReceiveAsync, de sorte que les gains dans Socket sont diffus√©s sur NetworkStream et que NetworkStream.ReadAsync n'alloue pas r√©ellement de m√©moire non plus. </p><br><h4 id="neobobschyonnyy-valuetask">  T√¢che de valeur non partag√©e </h4><br><p>  Lorsque ValueTask &lt;TResult&gt; est apparu dans .NET Core 2.0, seul le cas d'ex√©cution synchrone y a √©t√© optimis√© afin d'exclure le placement de l'objet Task &lt;TResult&gt; si la valeur TResult est d√©j√† pr√™te.  Cela signifiait que la classe g√©n√©rique ValueTask n'√©tait pas n√©cessaire: pour le cas d'une ex√©cution synchrone, le singleton Task.CompletedTask pouvait simplement √™tre renvoy√© par la m√©thode, ce qui √©tait fait implicitement par l'environnement dans les m√©thodes asynchrones renvoyant Task. </p><br><p>  Cependant, avec l'obtention d'op√©rations asynchrones sans allouer de m√©moire, l'utilisation de la ValueTask non partag√©e est redevenue pertinente.  Dans .NET Core 2.1, nous avons introduit les g√©n√©riques ValueTask et IValueTaskSource.  Ils fournissent des √©quivalents directs pour les versions g√©n√©riques, pour une utilisation similaire, avec uniquement une valeur de retour vide. </p><br><h4 id="realizaciya-ivaluetasksourceivaluetasksourcet">  Impl√©menter IValueTaskSource / IValueTaskSource &lt;T&gt; </h4><br><p>  La plupart des d√©veloppeurs ne devraient pas impl√©menter ces interfaces.  De plus, ce n'est pas si facile.  Si vous d√©cidez de le faire, plusieurs impl√©mentations dans .NET Core 2.1 peuvent servir de point de d√©part, par exemple: </p><br><ul><li>  AwaitableSocketAsyncEventArgs </li><li>  AsyncOperation &lt;TResult&gt; </li><li>  DefaultPipeReader </li></ul><br><p>  Pour faciliter cela, dans .NET Core 3.0, nous pr√©voyons d'introduire toute la logique n√©cessaire incluse dans le type ManualResetValueTaskSourceCore &lt;TResult&gt;, une structure qui peut √™tre incorpor√©e dans un autre objet qui impl√©mente IValueTaskSource &lt;TResult&gt; et / ou IValueTaskSource, afin qu'elle puisse √™tre d√©l√©gu√©e √† Cette structure constitue l'essentiel de la fonctionnalit√©.  Vous pouvez en savoir plus √† ce sujet sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/dotnet/corefx/issues/32664</a> dans le r√©f√©rentiel dotnet / corefx. </p><br><h4 id="patterny-primeneniya-valuetasks">  Mod√®les d'application ValueTasks </h4><br><p>  √Ä premi√®re vue, la port√©e de ValueTask et ValueTask &lt;TResult&gt; est beaucoup plus limit√©e que Task et Task &lt;TResult&gt;.  C'est bien, et m√™me attendu, car la principale fa√ßon de les utiliser est simplement d'utiliser l'op√©rateur wait. </p><br><p>  Cependant, comme ils peuvent encapsuler des objets qui sont r√©utilis√©s, il existe des restrictions importantes √† leur utilisation par rapport √† Task et Task &lt;TResult&gt;, si vous vous √©cartez de la mani√®re habituelle d'attendre simplement.  Dans les cas g√©n√©raux, les op√©rations suivantes ne doivent jamais √™tre effectu√©es avec ValueTask / ValueTask &lt;TResult&gt;: </p><br><ul><li>  <strong>Attente r√©p√©t√©e ValueTask / ValueTask &lt;TResult&gt;</strong> L'objet r√©sultat peut d√©j√† √™tre supprim√© et utilis√© dans une autre op√©ration.  En revanche, Task / Task &lt;TResult&gt; ne passe jamais d'un √©tat termin√© √† un √©tat incomplet, vous pouvez donc vous y attendre autant de fois que n√©cessaire et obtenir le m√™me r√©sultat √† chaque fois. </li><li>  <strong>Attente parall√®le ValueTask / ValueTask &lt;TResult&gt;</strong> L'objet r√©sultat attend un traitement avec un seul rappel d'un consommateur √† la fois, et essayer d'attendre √† partir de diff√©rents flux en m√™me temps peut facilement conduire √† des courses et √† de subtiles erreurs de programme.  De plus, il s'agit √©galement d'un cas plus sp√©cifique de la pr√©c√©dente op√©ration de ¬´r√©attente¬ª non valide.  En comparaison, Task / Task &lt;TResult&gt; fournit un nombre illimit√© d'attente parall√®le. </li><li>  <strong>Utilisation de .GetAwaiter (). GetResult () lorsque l'op√©ration n'est pas encore termin√©e. L'</strong> impl√©mentation de IValueTaskSource / IValueTaskSource n'a pas besoin de prise en charge du verrouillage tant que l'op√©ration n'est pas termin√©e, et tr√®s probablement ne le fera pas, donc une telle op√©ration entra√Ænera certainement une course et probablement ne s'ex√©cutera pas comme le pr√©voit la m√©thode appelante.  Task / Task &lt;TResult&gt; bloque le thread appelant jusqu'√† ce que la t√¢che soit termin√©e. </li></ul><br><p>  Si vous avez re√ßu une ValueTask ou ValueTask &lt;TResult&gt;, mais que vous devez effectuer l'une de ces trois op√©rations, vous pouvez utiliser .AsTask (), obtenir Task / Task &lt;TResult&gt;, puis travailler avec l'objet re√ßu.  Apr√®s cela, vous ne pouvez plus utiliser cette ValueTask / ValueTask &lt;TResult&gt;. </p><br><p>  En bref, la r√®gle est la suivante: lorsque vous utilisez ValueTask / ValueTask &lt;TResult&gt;, vous devez soit l'attendre directement (√©ventuellement avec .ConfigureAwait (false)), soit appeler AsTask () et ne plus l'utiliser: </p><br><pre> <code class="plaintext hljs">//   ,  ValueTask&lt;int&gt; public ValueTask&lt;int\&gt; SomeValueTaskReturningMethodAsync(); ... // GOOD int result = await SomeValueTaskReturningMethodAsync(); // GOOD int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false); // GOOD Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask(); // WARNING ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); //       , //     // BAD: await   ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = await vt; int result2 = await vt; // BAD: await  (    ) ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); Task.Run(async () =&gt; await vt); Task.Run(async () =&gt; await vt); // BAD:  GetAwaiter().GetResult(),     ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = vt.GetAwaiter().GetResult();</code> </pre> <br><p>  Il y a un autre mod√®le avanc√© que les programmeurs peuvent appliquer, j'esp√®re, seulement apr√®s une mesure minutieuse et l'obtention d'avantages significatifs.  Les classes ValueTask / ValueTask &lt;TResult&gt; ont plusieurs propri√©t√©s qui signalent l'√©tat actuel de l'op√©ration, par exemple, la propri√©t√© IsCompleted renvoie true si l'op√©ration est termin√©e (c'est-√†-dire qu'elle ne s'ex√©cute plus et s'est termin√©e avec succ√®s ou non) et la propri√©t√© IsCompletedSuccessfully renvoie true, uniquement s'il s'est termin√© avec succ√®s (en attendant et en recevant le r√©sultat, il n'a pas lev√© d'exception).  Pour les threads d'ex√©cution les plus exigeants, o√π le d√©veloppeur souhaite √©viter les co√ªts qui surviennent en mode asynchrone, ces propri√©t√©s peuvent √™tre v√©rifi√©es avant une op√©ration qui d√©truit r√©ellement l'objet ValueTask / ValueTask &lt;TResult&gt;, par exemple attendre, .AsTask ().  Par exemple, dans l'impl√©mentation de SocketsHttpHandler dans .NET Core 2.1, le code lit √† partir de la connexion et re√ßoit une ValueTask &lt;int&gt;.  Si cette op√©ration est effectu√©e de mani√®re synchrone, nous n'avons pas √† nous soucier de la r√©siliation anticip√©e de l'op√©ration.  Mais s'il s'ex√©cute de mani√®re asynchrone, nous devons raccorder le traitement d'interruption afin que la demande d'interruption rompt la connexion.  Comme il s'agit d'un morceau de code tr√®s stressant, si le profilage montre la n√©cessit√© du petit changement suivant, il peut √™tre structur√© comme ceci: </p><br><pre> <code class="plaintext hljs">int bytesRead; { ValueTask&lt;int&gt; readTask = _connection.ReadAsync(buffer); if (readTask.IsCompletedSuccessfully) { bytesRead = readTask.Result; } else { using (_connection.RegisterCancellation()) { bytesRead = await readTask; } } }</code> </pre> <br><h4 id="dolzhen-li-kazhdyy-novyy-metod-asinhronnogo-api-vozvraschat-valuetaskvaluetasktresult">  Chaque nouvelle m√©thode d'API asynchrone doit-elle renvoyer un ValueTask / ValueTask &lt;TResult&gt;? </h4><br><p>  Pour r√©pondre bri√®vement: non, par d√©faut, il vaut toujours la peine de choisir T√¢che / T√¢che &lt;R√©sultat&gt;. <br>  Comme soulign√© ci-dessus, la t√¢che et la t√¢che &lt;TResult&gt; sont plus faciles √† utiliser correctement que ValueTask et ValueTask &lt;TResult&gt;, et tant que les exigences de performances ne l'emportent pas sur les exigences pratiques, la t√¢che et la t√¢che &lt;TResult&gt; sont pr√©f√©r√©es.  De plus, il y a de petits co√ªts associ√©s au retour de ValueTask &lt;TResult&gt; au lieu de Task &lt;TResult&gt;, c'est-√†-dire que les microbenchmarks montrent qu'attendre la t√¢che &lt;TResult&gt; est plus rapide qu'attendre ValueTask &lt;TResult&gt;.  Ainsi, si vous utilisez la mise en cache des t√¢ches, par exemple, votre m√©thode renvoie T√¢che ou T√¢che, pour des performances il vaut la peine de rester avec T√¢che ou T√¢che.  Les objets ValueTask / ValueTask &lt;TResult&gt; occupent plusieurs mots en m√©moire. Par cons√©quent, lorsqu'ils sont attendus et que leurs champs sont r√©serv√©s dans la machine d'√©tat appelant la m√©thode async, ils y occuperont plus de m√©moire. <br></p><p>  - ValueTask/ValueTask&lt;TResult&gt;    : )  ,        await, )        , )     ,          .   ,                /  . </p><br><h4 id="chto-dalshe-s-valuetask-i-valuetasktresult">    ValueTask  ValueTask&lt;TResult&gt;? </h4><br><p>    .NET      ,  Task/Task&lt;TResult&gt;,  ,  ValueTask/ValueTask&lt;TResult&gt;,     ,   .      ‚Äì   IAsyncEnumerator&lt;T&gt;,     .NET Core 3.0. IEnumerator&lt;T&gt;   MoveNext,   bool,     IAsyncEnumerator&lt;T&gt;   MoveNextAsync.     , ,     Task,             . ,   ,       ,        (           ),        await   foreach,      ValueTask.        ,         .      C#   ,    ,     ,   . </p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458828/">https://habr.com/ru/post/fr458828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458812/index.html">JVM TI: comment cr√©er un plugin pour une machine virtuelle</a></li>
<li><a href="../fr458814/index.html">Lancement d'un site pour un produit avec une demande inform√©e</a></li>
<li><a href="../fr458818/index.html">Des contemporains √©minents</a></li>
<li><a href="../fr458820/index.html">Sur l'impl√©mentation du c√©l√®bre genre sur la plateforme Minecraft</a></li>
<li><a href="../fr458826/index.html">Comment √©liminer les anciens articles pour qu'ils croissent fortement dans le bio: + 104% de trafic pendant six mois</a></li>
<li><a href="../fr458830/index.html">Webinaires sur les technologies Dell: tous les d√©tails de notre didacticiel</a></li>
<li><a href="../fr458832/index.html">Cinq √©tudiants et trois magasins de valeurs cl√©s distribu√©s</a></li>
<li><a href="../fr458834/index.html">C√¥t√© de la personnalit√© de Paul Allen, que peu de gens connaissaient comme je le souhaiterais</a></li>
<li><a href="../fr458836/index.html">Indice de Borsch. Une approche syst√©matique pour √©valuer, comparer, d√©terminer le rapport qualit√© / prix</a></li>
<li><a href="../fr458840/index.html">Comment nous avons perc√© le grand pare-feu chinois (partie 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>