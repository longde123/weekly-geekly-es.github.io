<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïë ü§∏üèø üïµüèΩ Pengembalian GOTO üö° üîâ üëÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekarang semua orang mengerti bahwa menggunakan operator GOTO tidak hanya buruk, tetapi praktik yang mengerikan. Perdebatan tentang penggunaannya bera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembalian GOTO</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484840/"><p> Sekarang semua orang mengerti bahwa menggunakan operator GOTO tidak hanya buruk, tetapi praktik yang mengerikan.  Perdebatan tentang penggunaannya berakhir pada tahun 80-an abad XX dan dikeluarkan dari sebagian besar bahasa pemrograman modern.  Tetapi, sebagaimana layaknya kejahatan sejati, ia berhasil menyamarkan dirinya dan bangkit kembali pada abad ke-21 dengan kedok pengecualian. </p><a name="habracut"></a><br><p>  Pengecualian, di satu sisi, adalah konsep yang cukup sederhana dalam bahasa pemrograman modern.  Di sisi lain, mereka sering digunakan secara tidak benar.  Ada aturan sederhana dan terkenal - pengecualian hanya untuk menangani kerusakan.  Dan interpretasi yang terlalu longgar dari konsep "kerusakan" mengarah ke semua masalah menggunakan GOTO. </p><br><h2 id="teoreticheskiy-primer">  Contoh teoretis </h2><br><p>  Perbedaan antara gangguan dan skenario bisnis negatif terlihat jelas pada jendela masuk dengan kasus penggunaan yang sangat sederhana: </p><br><ol><li>  Pengguna memasukkan login / kata sandi. </li><li>  Pengguna mengklik tombol "Login". </li><li>  Aplikasi klien mengirimkan permintaan ke server. </li><li>  Server berhasil memeriksa nama pengguna / kata sandi (menganggap kehadiran pasangan yang sesuai sebagai berhasil). </li><li>  Server mengirim informasi ke klien bahwa otentikasi berhasil dan tautan ke halaman transisi. </li><li>  Klien pergi ke halaman yang ditentukan. </li></ol><br><p>  Dan satu ekstensi negatif: </p><br><p>  4.1.  Server tidak menemukan pasangan login / kata sandi yang sesuai dan mengirimkan pemberitahuan kepada klien tentang hal ini. </p><br><p>  Mempertimbangkan bahwa skenario 4.1 adalah "masalah" dan karenanya harus diimplementasikan menggunakan pengecualian adalah kesalahan yang cukup umum.  Ini sebenarnya tidak demikian.  Ketidakcocokan login dan kata sandi adalah bagian dari pengalaman pengguna standar kami yang disediakan oleh logika bisnis skrip.  Pelanggan bisnis kami mengharapkan perkembangan ini.  Karenanya, ini bukan gangguan dan Anda tidak dapat menggunakan pengecualian di sini. </p><br><p>  Kerusakan adalah: terputusnya koneksi antara klien dan utara, tidak dapat diaksesnya DBMS, skema yang salah dalam database.  Dan sejuta lagi alasan yang memecah aplikasi kita dan tidak ada hubungannya dengan logika bisnis pengguna. </p><br><p>  Di salah satu proyek, dalam pengembangan yang saya ikuti, ada logika logon yang lebih kompleks.  Dengan memasukkan kata sandi yang salah 3 kali berturut-turut, pengguna diblokir sementara selama 15 menit.  Mendapatkan 3 kali berturut-turut dalam kunci sementara, pengguna menerima kunci permanen.  Ada juga aturan tambahan tergantung pada jenis pengguna.  Implementasi pengecualian telah membuatnya sangat sulit untuk memperkenalkan aturan baru. </p><br><p>  Akan menarik untuk mempertimbangkan contoh ini, tetapi terlalu besar dan tidak terlalu visual.  Bagaimana kode yang membingungkan dengan logika bisnis tentang pengecualian menjadi jelas dan singkat, saya akan tunjukkan pada Anda dalam contoh lain. </p><br><h2 id="primer-zagruzka-svoystv">  Contoh Memuat Properti </h2><br><p>  Cobalah untuk melihat kode ini dan mengerti dengan jelas apa fungsinya.  Prosedurnya tidak besar dengan logika yang cukup sederhana.  Dengan gaya pemrograman yang baik, pemahaman tentang esensinya tidak boleh melebihi lebih dari 2-3 menit (saya tidak ingat berapa lama waktu saya untuk sepenuhnya memahami kode ini, tetapi jelas lebih dari 15 menit). </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkspaceProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Properties loadedProperties = readPropertiesFromFile(WORK_PROPERTIES_PATH, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">//These mappings will replace any mappings that this hashtable had for any of the //keys currently in the specified map. getProperties().putAll( loadedProperties ); //     loadedProperties = readPropertiesFromFile(MY_WORK_PROPERTIES_PATH, false); if (loadedProperties != null){ getProperties().putAll( loadedProperties ); } System.out.println("Loaded properties:" + getProperties()); } /** *  ,    . * @param filepath * @param throwIfNotFound -  FileNotFoundException,     * @return    null,      !throwIfNotFound * @throws FileNotFoundException throwIfNotFound        * @throws IOException     */ private Properties readPropertiesFromFile(String filepath, boolean throwIfNotExists){ Properties loadedProperties = new Properties(); System.out.println("Try loading workspace properties" + filepath); InputStream is = null; InputStreamReader isr = null; try{ int loadingTryLeft = 3; String relativePath = ""; while (loadingTryLeft &gt; 0){ try{ File file = new File(relativePath + filepath); is = new FileInputStream(file); isr = new InputStreamReader( is, "UTF-8"); loadedProperties.load(isr); loadingTryLeft = 0; } catch( FileNotFoundException e) { loadingTryLeft -= 1; if (loadingTryLeft &gt; 0) relativePath += "../"; else throw e; } finally { if (is != null) is.close(); if (isr != null) isr.close(); } } System.out.println("Found file " + filepath); } catch( FileNotFoundException e) { System.out.println("File not found " + filepath); if (throwIfNotExists) throw new RuntimeException("Can`t load workspace properties." + filepath + " not found", e ); }catch (IOException e){ throw new RuntimeException("Can`t read " + filepath, e); } return loadedProperties; }</span></span></code> </pre> <br><p>  Jadi, mari kita ungkapkan rahasianya - apa yang terjadi di sini.  Properti dari dua file <code>WORK_PROPERTIES</code> - <code>WORK_PROPERTIES</code> diperlukan dan <code>MY_WORK_PROPERTIES</code> tambahan, menambah toko properti umum.  Ada nuansa - kami tidak tahu persis di mana file properti tertentu berada - itu bisa terletak di direktori saat ini dan di direktori leluhur (hingga tiga tingkat ke atas). </p><br><p>  Setidaknya dua hal membingungkan di sini: parameter <code>throwIfNotExists</code> dan blok logika besar dalam <code>catch FileNotFoundException</code> .  Semua petunjuk yang tidak jelas ini - pengecualian digunakan untuk mengimplementasikan logika bisnis (tapi bagaimana cara lain untuk menjelaskan bahwa dalam satu skenario, melempar pengecualian adalah kegagalan, dan yang lain tidak?). </p><br><h2 id="delaem-pravilnyy-kontrakt">  Membuat kontrak yang tepat </h2><br><p>  Pertama, <code>throwIfNotExists</code> kita berurusan dengan <code>throwIfNotExists</code> .  Ketika bekerja dengan pengecualian, sangat penting untuk memahami di mana tepatnya itu perlu diproses dalam hal kasus penggunaan.  Dalam kasus ini, jelas bahwa metode <code>readPropertiesFromFile</code> tidak dapat memutuskan kapan tidak adanya file "buruk" dan ketika itu "baik".  Keputusan semacam itu dibuat pada titik panggilannya.  Komentar menunjukkan bahwa kami memutuskan apakah file ini harus ada atau tidak.  Namun pada kenyataannya, kami tertarik bukan pada file itu sendiri, tetapi pengaturan dari itu.  Sayangnya, ini tidak mengikuti dari kode. </p><br><p>  Kami memperbaiki kedua kekurangan ini: </p><br><pre> <code class="java hljs">Properties loadedProperties = readPropertiesFromFile(WORK_PROPERTIES_PATH); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadedProperties.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can`t load workspace properties"</span></span>); } loadedProperties = readPropertiesFromFile(MY_WORK_PROPERTIES_PATH); getProperties().putAll( loadedProperties );</code> </pre> <br><p>  Sekarang semantik ditampilkan dengan jelas - <br>  <code>WORK_PROPERTIES</code> harus ditentukan, tetapi <code>MY_WORK_PROPERTIES</code> tidak <code>MY_WORK_PROPERTIES</code> .  Juga, ketika refactoring, saya perhatikan bahwa <code>readPropertiesFromFile</code> tidak pernah dapat mengembalikan <code>null</code> dan mengambil keuntungan dari ini ketika membaca <code>MY_WORK_PROPERTIES</code> . </p><br><h2 id="proveryaem-ne-lomaya">  Kami memeriksa tanpa merusak </h2><br><p>  Refactoring sebelumnya juga mempengaruhi implementasi, tetapi tidak signifikan.  Saya baru saja menghapus <code>throwIfNotExists</code> pemrosesan <code>throwIfNotExists</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (throwIfNotExists) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(‚Ä¶);</code> </pre> <br><p>  Setelah memeriksa implementasi lebih dekat, kami mulai memahami logika pembuat kode untuk mencari file.  Pertama, diperiksa apakah file tersebut ada di direktori saat ini, jika tidak ditemukan, kami periksa di level yang lebih tinggi, dll.  Yaitu  menjadi jelas bahwa algoritma menyediakan tidak adanya file.  Dalam hal ini, pemeriksaan dilakukan menggunakan pengecualian.  Yaitu  prinsip tersebut dilanggar - pengecualian dianggap bukan sebagai "sesuatu telah rusak", tetapi sebagai bagian dari logika bisnis. </p><br><p>  Ada fungsi untuk memeriksa ketersediaan file untuk membaca <code>File.canRead()</code> .  Dengan menggunakannya, Anda dapat menyingkirkan logika bisnis di <code>catch</code> </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(relativePath + filepath); is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); isr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader( is, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); loadedProperties.load(isr); loadingTryLeft = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( FileNotFoundException e) { loadingTryLeft -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) relativePath += <span class="hljs-string"><span class="hljs-string">"../"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) is.close(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isr != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) isr.close(); } }</code> </pre> <br><p>  Mengubah kode, kita mendapatkan yang berikut: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Properties </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPropertiesFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String filepath)</span></span></span><span class="hljs-function"> </span></span>{ Properties loadedProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Properties(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Try loading workspace properties"</span></span> + filepath); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> loadingTryLeft = <span class="hljs-number"><span class="hljs-number">3</span></span>; String relativePath = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(relativePath + filepath); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.canRead()) { InputStream is = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; InputStreamReader isr = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); isr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(is, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); loadedProperties.load(isr); loadingTryLeft = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) is.close(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isr != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) isr.close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { loadingTryLeft -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { relativePath += <span class="hljs-string"><span class="hljs-string">"../"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException(); } } } System.out.println(<span class="hljs-string"><span class="hljs-string">"Found file "</span></span> + filepath); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (FileNotFoundException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"File not found "</span></span> + filepath); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can`t read "</span></span> + filepath, e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadedProperties; }</code> </pre> <br><p>  Saya juga mengurangi tingkat variabel ( <code>is</code> , <code>isr</code> ) ke minimum yang diizinkan. </p><br><p>  Refactoring sederhana seperti ini sangat meningkatkan keterbacaan kode.  Kode langsung menampilkan algoritme (jika file ada, maka kita membacanya, kalau tidak kita mengurangi jumlah upaya dan melihat di direktori di atas). </p><br><h2 id="vyyavlyaem-goto">  Mengungkap GOTO </h2><br><p>  Pertimbangkan secara rinci apa yang terjadi dalam suatu situasi jika file tidak ditemukan: </p><br><pre> <code class="java hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { loadingTryLeft -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { relativePath += <span class="hljs-string"><span class="hljs-string">"../"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException(); } }</code> </pre> <br><p>  Dapat dilihat bahwa di sini pengecualian digunakan untuk mengganggu siklus eksekusi dan benar-benar melakukan fungsi GOTO. </p><br><p>  Bagi yang ragu, kami akan membuat perubahan lain.  Alih-alih menggunakan kruk kecil dalam bentuk <code>loadingTryLeft = 0</code> (kruk, karena sebenarnya upaya yang berhasil tidak <code>loadingTryLeft = 0</code> jumlah upaya yang tersisa), kami secara eksplisit menunjukkan bahwa membaca file akan keluar dari fungsi (tanpa lupa menulis pesan): </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); isr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(is, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); loadedProperties.load(isr); System.out.println(<span class="hljs-string"><span class="hljs-string">"Found file "</span></span> + filepath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadedProperties; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> {</code> </pre> <br><p>  Ini memungkinkan kami untuk mengganti kondisi <code>while (loadingTryLeft &gt; 0)</code> dengan <code>while(true)</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> loadingTryLeft = <span class="hljs-number"><span class="hljs-number">3</span></span>; String relativePath = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(relativePath + filepath); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.canRead()) { InputStream is = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; InputStreamReader isr = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); isr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(is, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); loadedProperties.load(isr); System.out.println(<span class="hljs-string"><span class="hljs-string">"Found file "</span></span> + filepath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadedProperties; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) is.close(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isr != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) isr.close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { loadingTryLeft -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { relativePath += <span class="hljs-string"><span class="hljs-string">"../"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException(); <span class="hljs-comment"><span class="hljs-comment">// GOTO: FFN } } } } catch (FileNotFoundException e) { // LABEL: FFN System.out.println("File not found " + filepath); } catch (IOException e) { throw new RuntimeException("Can`t read " + filepath, e); }</span></span></code> </pre> <br><p>  Untuk menyingkirkan <code>throw new FileNotFoundException</code> berbau busuk, Anda perlu mengingat fungsi kontraknya.  Bagaimanapun, fungsi mengembalikan satu set properti, jika mereka tidak bisa membaca file, kami mengembalikannya kosong.  Karena itu, tidak ada alasan untuk melempar pengecualian dan menangkapnya.  Kondisi <code>while (loadingTryLeft &gt; 0)</code> biasa <code>while (loadingTryLeft &gt; 0)</code> cukup: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Properties </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPropertiesFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String filepath)</span></span></span><span class="hljs-function"> </span></span>{ Properties loadedProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Properties(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Try loading workspace properties"</span></span> + filepath); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> loadingTryLeft = <span class="hljs-number"><span class="hljs-number">3</span></span>; String relativePath = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(relativePath + filepath); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.canRead()) { InputStream is = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; InputStreamReader isr = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); isr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(is, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); loadedProperties.load(isr); System.out.println(<span class="hljs-string"><span class="hljs-string">"Found file "</span></span> + filepath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadedProperties; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) is.close(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isr != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) isr.close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { loadingTryLeft -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) relativePath += <span class="hljs-string"><span class="hljs-string">"../"</span></span>; } } System.out.println(<span class="hljs-string"><span class="hljs-string">"file not found"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can`t read "</span></span> + filepath, e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadedProperties; }</code> </pre> <br><p>  Pada prinsipnya, dari sudut pandang pekerjaan yang benar dengan pengecualian, semuanya ada di sini.  Ada keraguan tentang perlunya melempar RuntimeException jika terjadi masalah IOException, tetapi kami akan membiarkannya karena itu demi kompatibilitas. </p><br><h2 id="navodim-losk">  Bawa Gloss </h2><br><p>  Ada beberapa hal kecil yang tersisa sehingga kita dapat membuat kode lebih fleksibel dan mudah dimengerti: </p><br><ul><li>  Nama metode readPropertiesFromFile memperlihatkan implementasinya (by the way, serta melempar FileNotFoundException).  Lebih baik menyebutnya lebih netral dan ringkas - loadProperties (...) </li><li>  Metode ini secara simultan mencari dan membaca.  Bagi saya, ini adalah dua tanggung jawab berbeda yang dapat dibagi dalam metode yang berbeda. </li><li>  Kode ini awalnya ditulis di bawah Java 6, tetapi sekarang digunakan di Java 7. Ini memungkinkan penggunaan sumber daya yang dapat ditutup. </li><li>  Saya tahu dari pengalaman bahwa ketika menampilkan informasi tentang file yang ditemukan atau tidak ditemukan, lebih baik menggunakan path lengkap ke file, daripada relatif. </li><li> <code>if (loadingTryLeft &gt; 0) relativePath += "../";</code>  - jika Anda hati-hati melihat kode, Anda dapat melihat - pemeriksaan ini tidak perlu, karena  jika batas pencarian habis, nilai baru tidak akan digunakan.  Dan jika ada sesuatu yang berlebihan dalam kode, ini adalah sampah yang harus dibuang. </li></ul><br><p>  Versi terakhir dari kode sumber: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkspaceProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Properties()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (defaultInstance != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(); Properties loadedProperties = readPropertiesFromFile(WORK_PROPERTIES_PATH); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadedProperties.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can`t load workspace properties"</span></span>); } getProperties().putAll(loadedProperties); loadedProperties = readPropertiesFromFile(MY_WORK_PROPERTIES_PATH); getProperties().putAll(loadedProperties); System.out.println(<span class="hljs-string"><span class="hljs-string">"Loaded properties:"</span></span> + getProperties()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Properties </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPropertiesFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String filepath)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Try loading workspace properties"</span></span> + filepath); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> loadingTryLeft = <span class="hljs-number"><span class="hljs-number">3</span></span>; String relativePath = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(relativePath + filepath); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.canRead()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> read(file); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { relativePath += <span class="hljs-string"><span class="hljs-string">"../"</span></span>; loadingTryLeft -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } } System.out.println(<span class="hljs-string"><span class="hljs-string">"file not found"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can`t read "</span></span> + filepath, e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Properties(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Properties </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); InputStreamReader isr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(is, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>)) { Properties loadedProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Properties(); loadedProperties.load(isr); System.out.println(<span class="hljs-string"><span class="hljs-string">"Found file "</span></span> + file.getAbsolutePath()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadedProperties; } }</code> </pre> <br><h2 id="rezyume">  Ringkasan </h2><br><p>  Contoh yang diuraikan jelas menggambarkan penanganan kode sumber yang ceroboh.  Alih-alih menggunakan pengecualian untuk menangani kerusakan, diputuskan untuk menggunakannya untuk menerapkan logika bisnis.  Ini segera menyebabkan kompleksitas dukungannya, yang tercermin dalam pengembangan lebih lanjut untuk memenuhi persyaratan baru dan, sebagai akibatnya, penyimpangan dari prinsip-prinsip pemrograman struktural.  Menggunakan aturan sederhana - pengecualian hanya untuk gangguan - akan membantu Anda menghindari kembali ke era GOTO dan menjaga kode Anda tetap bersih, dapat dimengerti, dan dapat dikembangkan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484840/">https://habr.com/ru/post/id484840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484824/index.html">Perang untuk mematikan lampu</a></li>
<li><a href="../id484826/index.html">Kecerdasan buatan memperburuk kedokteran yang buruk bahkan lebih</a></li>
<li><a href="../id484834/index.html">Bagaimana membangun strategi perusahaan untuk pelatihan dan pengembangan</a></li>
<li><a href="../id484836/index.html">Perhitungan profitabilitas dari Tarif Hijau pada tahun 2020, Ukraina</a></li>
<li><a href="../id484838/index.html">13 contoh pengaturan aturan dalam Iklan Google [instruksi]</a></li>
<li><a href="../id484846/index.html">Hubungan saya dengan open source</a></li>
<li><a href="../id484854/index.html">Jalankan game dalam C # di MS-DOS</a></li>
<li><a href="../id484860/index.html">Nama Implementasi dan Nama Hasil</a></li>
<li><a href="../id484862/index.html">Bermigrasi dari AngularJS ke Angular7 melalui aplikasi hybrid</a></li>
<li><a href="../id484866/index.html">Menggunakan Astra Linux pada Komputer Tertanam ARM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>