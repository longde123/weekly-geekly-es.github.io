<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒ¬ï¸ ğŸ ğŸ”» Jangan mencoba memprediksi masalah besok ğŸ¯ ğŸ• â›“ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Baik, atau mulai melakukannya dengan benar. 

 Jika saya diminta untuk menunjukkan satu masalah spesifik yang membunuh sebagian besar produk perangkat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jangan mencoba memprediksi masalah besok</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/421901/">  Baik, atau mulai melakukannya dengan benar. <br><br>  Jika saya diminta untuk menunjukkan satu masalah spesifik yang membunuh sebagian besar produk perangkat lunak, maka saya pasti akan memanggil keinginan para pengembang untuk meramalkan masa depan yang jauh.  Ini dapat diungkapkan dalam banyak cara, tetapi skema umumnya kira-kira sebagai berikut: <br><br>  <i>â€œKita perlu mengimplementasikan solusi {X}, meskipun ada fakta bahwa ada solusi yang lebih sederhana dan lebih cocok untuk kita {Y}, karena ketika {Z} terjadi di masa depan, maka {X} akan bekerja jauh lebih baik daripada {Y}â€ .</i> <br><br>  Selain itu, tidak ada dan tidak dapat informasi yang pasti tentang probabilitas terjadinya peristiwa {Z}. <br><br>  Berikut adalah beberapa contoh: <br><br><ul><li>  Kita perlu menggunakan kubernet dan buruh pelabuhan!  Ya, satu server mengatasi beban saat ini dan mudah untuk mengkonfigurasi dan memelihara, tetapi ketika kita membutuhkan selusin server, akan lebih mudah untuk menyebarkannya dengan kubernet dan buruh pelabuhan. </li><li>  Kami membutuhkan arsitektur pemrosesan data terdistribusi!  Ya, sejauh ini satu PC rata-rata berurusan dengan segalanya, tetapi ketika kami memiliki solusi tingkat industri dan pelanggan menuntut uptime lima sembilan dalam SLA, kami akan siap untuk ini. </li><li>  Kita perlu merekrut tim pengembang dan membuat situs dari awal, meskipun faktanya akan lebih cepat untuk menggunakan sesuatu berdasarkan wordpress, karena ketika kita memiliki 100 kali lebih banyak pelanggan daripada sekarang, maka wordpress tidak akan begitu nyaman. </li><li>  Kita perlu menggunakan pewarisan alih-alih komposisi, karena setelah 5 tahun basis kode akan tumbuh sehingga tanpanya tidak akan ada jalan. </li><li>  Kita perlu menulis kode ini dalam C ++, terlepas dari kenyataan bahwa dalam Python akan beberapa kali lebih cepat, karena setelah bertahun-tahun akan memproses terabyte data dan Python mungkin tidak dapat mengatasinya di sini. </li></ul><br>  Baru-baru ini saya menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel</a> tentang masalah imajiner - mereka yang solusinya menghibur orang, karena memecahkannya lebih menarik daripada yang nyata.  Ini juga termasuk upaya-upaya ini untuk meramalkan masa depan.  Anda bahkan dapat mengatakan lebih banyak - ini adalah masalah imajiner favorit kebanyakan perusahaan kecil yang baru berdiri. <br><a name="habracut"></a><br>  Tapi jangan menyatukan semuanya: mencoba bersiap untuk masa depan bisa berguna jika Anda mendekati ini dengan bijak.  Tetapi hanya sedikit orang yang muncul dengan bijak - orang memiliki fantasi, ketakutan, emosi dan perasaan manusia lainnya. <br><br><h3>  Mencapai kesuksesan lebih sulit daripada hidup dengan kesuksesan yang sudah dicapai </h3><br>  Setiap orang terkadang berfantasi tentang bagaimana jadinya jika dia adalah orang lain.  Seseorang yang kaya, terkenal, kuat, diberkahi dengan kekuatan.  Memikirkannya cukup menarik, dan itu terjadi dengan sendirinya, tanpa sadar.  Jadi Anda melihat foto di sampul majalah - dan Anda berpikir, apa yang akan saya lakukan di tempat selebriti ini?  Oh, jadi saya akan menghabiskan uang untuk ini, dan jika saya akan melakukannya.  Dan juga itu.  Dan jika Anda masih bisa terbang dan memiliki kekuatan super!  Ya, itu akan luar biasa! <br><br>  Pengembang perangkat lunak juga manusia, dan mereka juga setuju dengan fantasi.  Jadi, itu berarti bahwa Facebook membangun platformnya di atas teknologi ini dan itu dan skala ke satu miliar pengguna ... Yah, kita tidak lebih buruk, dan teknologi tersedia, mari kita lakukan semuanya dengan baik, dengan simpanan satu miliar pengguna (meskipun sejauh ini ada seratus dari mereka).  Tetapi Facebook magic tidak dalam teknologi penskalaan untuk satu miliar pengguna.  Dia mampu memberi orang produk yang tepat di waktu dan tempat yang tepat.  Perangkat lunak, yang mampu meningkatkan hingga satu miliar pengguna, adalah bagian sekunder dan kurang penting dari perusahaan.  Itu diciptakan hanya ketika dibutuhkan dan hanya saat dibutuhkan. <br><br>  Medali itu memiliki dua sisi: <br><br>  <b>a)</b> Mencapai pertumbuhan lebih menantang daripada mempertahankan skala. <br>  <b>b)</b> Kebanyakan programmer yang berkualitas dan berbakat bekerja pada produk yang membutuhkan skalabilitas yang baik. <br><br>  Poin <b>"a"</b> mudah dikenali.  Pikirkan sendiri - dari semua perusahaan perangkat lunak yang pernah dibuat, hanya, mungkin, sekitar 0,05% mencapai tingkat jutaan pengguna dan miliaran laba.  Sisanya jatuh lebih awal atau kurang. <br><br>  Jadi, sebagian besar fantasi tentang fitur-fitur yang diperlukan di masa depan untuk perangkat lunak biasanya datang untuk mencoba memecahkan masalah-masalah 0,05% dari perusahaan ini.  "Di sini kami memiliki tim yang terdiri dari 1000 pengembang, 10 juta pengguna, dan selusin klien korporat besar dengan persyaratan kompleks mereka, dan kemudian kami akan membutuhkan ..."  Tidak, kamu tidak perlu.  Dengan probabilitas 99,95%. <br><br>  Tetapi mengatakan TIDAK untuk ide-ide yang menggoda seperti itu sulit - karena itu menghancurkan kepercayaan pada sebagian kecil dari persentase kemungkinan sukses.  Kami harus berhenti memperkenalkan diri sebagai pemilik Amazon baru dan kembali ke masalah hari ini.  Dan hari ini Anda memiliki 50 pengguna, 30 di antaranya adalah keluarga dan teman.  Ya, kesadaran akan keadaan saat ini dapat mendemotivasi. <br><br>  Butir <b>"b"</b> juga tidak membantu mengatasi obsesi.  Jelas bahwa programmer terbaik bekerja di perusahaan papan atas.  Entah karena mereka diciptakan berkat bakat mereka, atau karena perusahaan papan atas mampu merekrut programmer terbaik.  Prinsip Pareto bekerja di sini melawan kita: lebih baik bagi programmer untuk menulis buku, membuat presentasi, dan merancang sistem yang lebih baik.  Masing-masing dari kami mendengar dari mereka kisah-kisah menarik tentang kelompok-kelompok toleran-kesalahan yang didistribusikan di ribuan titik, memproses petabyte data menggunakan perangkat lunak yang dioptimalkan untuk beberapa angka kinerja luar biasa.  Tetapi kebanyakan dari kita tidak perlu memikirkan bagaimana membangun cluster seperti itu di perusahaan kita di sini dan sekarang.  Dia hanya tidak dibutuhkan. <br><br>  Jadi, memejamkan mata dan mewakili perusahaan Anda dalam 5 tahun adalah besar - apakah itu tidak membantu?  Apakah benar-benar perlu untuk berhenti memikirkan masa depan? <br><br>  Tentu saja tidak.  Berpikir tentang masa depan itu baik.  Dan merancang perangkat lunak dengan fondasi untuk masa depan juga berguna, tetapi Anda harus melakukannya dengan benar. <br><br><h3>  Desain fleksibel, implementasi tidak sempurna </h3><br>  Lebih baik berbuat lebih sedikit, tapi bagus.  Sangat sedikit produk yang benar-benar memuaskan kebutuhan pelanggan mereka.  Sehingga Anda melakukan <b>A</b> dan 90% dari pengguna Anda membutuhkan tepat <b>A</b> - tidak akan pernah ada.  90% dari pengguna potensial Anda memerlukan beberapa jenis <b>B</b> , dan <b>A</b> Anda <b>adalah</b> alternatif terdekat dari <b>B</b> , dan tidak ada yang menjual atau menjual <b>B</b> sendiri, sehingga beberapa pembeli akan puas dengan tit di tangan mereka. <br><br>  Apa yang baik dalam skenario ini?  Setelah Anda mendapatkan pembeli, Anda masih dapat mencoba memahami apa yang sebenarnya mereka butuhkan dan akhirnya menyadari hal ini.  Nah, atau alternatif yang sedikit lebih baik untuk ini.  Basis pengguna membantu Anda mempelajari pasar, menemukan ceruk pasar dan mengisinya.  Segera setelah Anda meraba-raba untuk niche ini, mulailah bekerja di dalamnya - di sini pertumbuhan Anda dimulai. <br><br>  Dan pendekatan ini sangat produktif.  Anda menerapkan sesuatu yang kecil, tetapi bekerja dengan baik, memberikannya kepada pengguna - dan kemudian mendengarkan pemikiran mereka tentang produk Anda.  Anda tidak lagi menebak, jangan menyelesaikan masalah imajiner, jangan tambahkan kompleksitas yang tidak perlu.  Anda beradaptasi, menambahkan sesuatu, menghapus sesuatu.  Dan ini menciptakan produk unik Anda. <br><br>  Dan dengan cara ini - semakin kecil basis kode Anda, semakin mudah untuk menyesuaikannya dengan sesuatu yang baru. <br><blockquote>  â€œSaya benci kode dan ingin melihatnya dalam produk kamiâ€ - Jack Diederich </blockquote>  Jika Anda membuat sesuatu bekerja dengan sempurna, Anda salah melakukannya.  Anda harus membuat pengorbanan terlalu besar di sepanjang jalan.  Mungkin itu buang-buang waktu atau uang, mungkin Anda memberikan fleksibilitas, mungkin sesuatu yang lain.  Yang ideal tidak tercapai secara gratis. <br><br>  Bukan perangkat lunak ideal yang lebih layak.  Dimungkinkan untuk membuatnya dalam waktu yang wajar dan dengan harga yang wajar.  Cukup sering melakukan segalanya atau hampir semua yang diperlukan.  Karena tidak sempurna, menurut definisi menyisakan ruang untuk pengembangan dan kebebasan manuvernya. <br><br><h3>  Desain arsitektur perangkat lunak yang optimis - masa depan dapat dengan senang hati dibangunkan </h3><br>  Penting untuk diingat bahwa dunia di sekitar Anda tidak statis.  Masalah yang muncul sebelum Anda setelah beberapa tahun mungkin dapat dengan mudah diselesaikan dengan bantuan teknologi yang tersedia setelah beberapa tahun.  Banyak orang merancang sesuatu, tidak hanya tidak memperhitungkan peluang masa depan, tetapi umumnya hanya mengandalkan alat yang sudah berusia puluhan tahun.  Mereka membatasi diri bahkan bukan hari ini, tetapi kemarin. <br><br>  Biarkan saya berbicara tentang satu contoh spesifik: merancang sistem terdistribusi dengan harapan siap untuk pertumbuhan apa pun.  Salah satu ketakutan umum yang mengarah pada penciptaan sistem seperti itu adalah ketakutan bahwa pada suatu titik server Anda tidak akan dapat melayani semua pengguna Anda.  Dan itu benar-benar terjadi.  Terkadang.  Tetapi tidak di perusahaan kecil, tidak di startup.  Selain itu, kebanyakan orang yang menulis perangkat lunak pada tahun 2018, karena alasan tertentu, yakin bahwa itu akan berfungsi pada server yang dibuat pada tahun 2005.  Komputer menjadi lebih baik setiap tahun dan server yang baik bisa disewa tidak begitu mahal. <br><br>  Biarkan saya menggambarkan server "nyata" awal: <br><br><ul><li>  Two Xeons E5-2680v4 (28cores &amp; 56 thread, cloking pada 2,4GHz ke 3,3GHz) </li><li>  512 Gigabytes dari DDR4-2400 RAM </li><li>  2 NVMe SSD masing-masing 1,2TB (masing-masing ~ 3GB / s dibaca dan ~ 1,5GB / s). </li></ul><br>  Ya, saya bertaruh bahwa setengah dari sistem terdistribusi yang ada di dunia akan berjalan di server ini sepenuhnya, dengan semua komponen dan dependensinya, berfungsi seperti biasa semua basis pengguna yang ada.  Dan ini jauh dari server paling keren hingga saat ini.  Ini bisa diambil dengan harga 800 hingga 1.300 dolar per bulan (tergantung di mana mendapatkannya).  Anda dapat menyewa selusin ini untuk gaji seorang insinyur yang berkualifikasi di London. <br><br>  Apa yang masih bagus di server ini adalah bahwa harga sewanya dalam 2 tahun akan turun 2 kali lipat. <br><br>  Komputer berevolusi, berkembang sangat linier dan dapat diprediksi dan akan terus berkembang seperti yang diperkirakan, di suatu tempat hingga akhir tahun 2020-an.  Sulit ditebak lebih lanjut, tetapi tidak mungkin manusia akan datang dengan sesuatu yang baru.  Dan orang-orang masih ingat besi awal abad ini dan takut bahwa itu tidak akan cukup bagi mereka untuk melayani beberapa ribu permintaan per hari. <br><br>  Tetapi kita berbicara tentang besi.  Dan pikirkan semua perangkat lunak yang muncul dan berkembang.  Hanya sedikit orang yang serius memikirkan kontrol suara 20 tahun yang lalu.  Dan lihat dunia hari ini - "OK Google," "Halo, Alexa," "seperti apa cuacanya sekarang, Siri?"  Siapa pun yang mulai menulis frontend suara di tahun 2016 - hanya berhasil ke 2018. <br><br>  Apa yang harus mulai ditulis pada tahun 2018?  Ah, kalau saya tahu :) Ini adalah sesuatu yang sudah muncul di cakrawala, tetapi belum menjadi terlalu besar untuk menaungi matahari.  Lihatlah ke sekeliling, mungkin Anda memperhatikan sesuatu seperti itu? <br><br>  Kemajuan dalam perangkat lunak luar biasa.  Benar-benar tanpa disadari, dengan munculnya WASM, browser telah menjadi mesin virtual universal.  Setelah 2 tahun, Anda dapat membangun aplikasi yang serbaguna, kompleks dan berkinerja tinggi dengan mengompilasinya untuk satu platform: perakitan web.  Dan itu akan mulai di mana-mana. <br><br>  Tetapi orang masih tinggal di suatu tempat di 2012.  Mereka menggunakan Babel, meskipun 99% pengguna memiliki setidaknya satu browser dengan dukungan ES6. <br><br>  Bahasa pemrograman baru muncul secara konstan.  Dan beberapa dari mereka cukup bagus.  Hanya dalam 8 tahun terakhir, kami mendapatkan Go, Rust, Scale, dan D - semuanya menemukan ceruk pasar mereka.  Dalam 2 tahun ke depan, saya berharap untuk melihat bagaimana Julia akan berkontribusi pada pemrograman ilmiah.  Dan inilah yang membuat saya khawatir secara pribadi dan apa yang saya ikuti.  Jumlah total teknologi dan pengetahuan luar biasa. <br><br><h3>  Tapi saya ngelantur ... </h3><br>  Menginspirasi masa depan relatif mudah.  Tetapi terus terang, selain kemajuan linear dari pertumbuhan produktivitas, sulit untuk membayangkan apa yang akan terjadi dalam 2 atau 5 tahun.  Beberapa ide melayang di udara, tim bekerja pada berbagai proyek perangkat lunak dan perangkat keras, tetapi apa yang akan "menembak" dari ini? <br><br>  Namun demikian, jika Anda ingin menyiapkan perangkat lunak Anda untuk masa depan, Anda harus terlebih dahulu memahami masa kini.  Apa yang baik di masa kini adalah bahwa hal itu sudah ada, dapat diamati, diukur.  Dan itu masih bertahan untuk sementara waktu.  Membuat perangkat lunak Anda setidaknya relevan hari ini adalah ide yang bagus.  Anda tidak akan siap untuk realitas 2020 menggunakan pendekatan tahun 2000.  Tetapi perangkat lunak yang ditulis dengan pendekatan yang relevan untuk 2018 dapat bekerja dengan baik untuk dirinya sendiri pada tahun 2020. <br><br>  Jadi jangan menyangkal kesenangan diri mengembangkan perangkat lunak dengan fondasi untuk masa depan.  Lakukan saja dengan lebih benar.  Pertimbangkan tidak hanya pengembangan produk masa depan Anda, tetapi juga pengembangan ekosistem di sekitarnya.  Segala sesuatu yang dapat dirancang secara fleksibel harus dirancang secara fleksibel.  Ini akan memberi Anda kesempatan untuk bermanuver pada saat Anda menemukan cara manuver mana yang harus diselesaikan.  Dan ini akan menyelamatkan Anda dari menghabiskan waktu mempersiapkan sesuatu yang tidak akan pernah terjadi. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421901/">https://habr.com/ru/post/id421901/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421891/index.html">Latar belakang: Minggu kerja 4 hari - peluang nyata atau fantasi?</a></li>
<li><a href="../id421893/index.html">Pengakuan seorang penguji: bagaimana saya mencari-cari IDS pesaing</a></li>
<li><a href="../id421895/index.html">Berhenti mengembangkan perangkat lunak dengan margin</a></li>
<li><a href="../id421897/index.html">Hogwarts Merah. Seri 10. Siswa - Ahli Metalurgi</a></li>
<li><a href="../id421899/index.html">Cara Penguji: Di â€‹â€‹Mana Mulai Belajar Otomasi</a></li>
<li><a href="../id421903/index.html">TiKV - database nilai kunci terdistribusi untuk cloud asli</a></li>
<li><a href="../id421905/index.html">Enam bulan dengan headphone nirkabel yang berbeda: apa yang saya pilih</a></li>
<li><a href="../id421909/index.html">Huawei di IFA 2018: chip, speaker pintar dan pelacak (terjemahan teks)</a></li>
<li><a href="../id421911/index.html">HP iPaq hx4700: lima menit hingga saat ini</a></li>
<li><a href="../id421913/index.html">Transaksi rahasia di Monero, atau cara transfernya tidak diketahui di mana tidak diketahui</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>