<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏏️ 🖕🏻 🌉 Docotic.Pdf：PVS-Studio在一个成熟的项目中检测到哪些问题？ 👉 📈 😺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="质量对我们很重要。 我们听说了PVS-Studio。 所有这些导致了检查Docotic.Pdf并找出其他可以改进的需求。 

 Docotic.Pdf是用于处理PDF文件的通用库。 它是用C＃编写的，除了.NET运行时以外，没有不安全的代码，没有外部依赖关系。 它可以在.NET 4+和.NET St...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docotic.Pdf：PVS-Studio在一个成熟的项目中检测到哪些问题？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425741/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/tt/fj/-u/ttfj-uhwy2ogamewgz6zit48lni.png" alt="Docotic.pdf和PVS-studio"></div><br> 质量对我们很重要。 我们听说了PVS-Studio。 所有这些导致了检查Docotic.Pdf并找出其他可以改进的需求。 <br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docotic.Pdf</a>是用于处理PDF文件的通用库。 它是用C＃编写的，除了.NET运行时以外，没有不安全的代码，没有外部依赖关系。 它可以在.NET 4+和.NET Standard 2+下工作。 <br><br> 该库已经开发了10年多，它有11万行代码，没有考虑测试，示例和其他内容。 对于静态分析，我们经常使用代码分析和StyleCop。 数以千计的自动化测试可保护我们免受回归影响。 来自不同国家和不同行业的客户对图书馆的质量表示信任。 <br><br>  PVS-Studio将检测到哪些问题？ <br><br><h3> 安装和第一印象 </h3><br> 我从PVS-Studio网站下载了试用版。 安装程序的体积小巧，令人惊喜。 使用默认设置安装：分析引擎，单独的PVS-Studio环境，集成到Visual Studio 2017中。 <br><br> 安装后，没有任何启动，并且带有相同图标的两个快捷方式被添加到“开始”菜单中：独立和PVS-Studio。 一会儿，我想到了从哪里开始。 启动独立版本，界面令人不愉快。 弯曲地支持为Windows设置的200％缩放比例。 文本的一部分太小，文本的一部分不适合为其提供的空间。 名称，独角兽和动作列表将针对任何窗口大小进行裁剪。 即使全屏显示。 <br><br><img src="https://habrastorage.org/webt/ll/3k/c5/ll3kc5bovj5wkbvtldfz9zhzpzk.png"><br><br> 好吧，好的，我决定打开我的项目文件。 突然，“文件”菜单没有找到这样的机会。 在那里，我只被提供打开个人文件。 谢谢，我想，我想尝试其他选择。 推出PVS-Studio-他们向我展示了一个带有模糊文字的窗口。 再次达到200％的规模。 文字报告： <s>在“三冠王”中</s>寻找<s>我，</s>在Visual Studio中寻找PVS-Studio菜单。 好的，打开Studio。 <br><br> 打开的解决方案。 实际上，有一个PVS-Studio菜单，它具有检查“当前项目”的功能。 他将我需要的项目列为最新项目，并启动了一项检查。  Studio中会弹出一个窗口，其中包含分析结果。 随着扫描的进行，背景中出现了一个窗口，但我没有立即找到它。 最初，感觉到支票没有开始或立即结束。 <br><br><h3> 第一次检查结果 </h3><br> 分析仪在大约9分钟30秒内检查了所有1253个项目文件。 到检查结束时，文件计数器的更改速度没有开始时的快。 扫描持续时间对扫描的文件数量可能存在某种非线性依赖性。 <br><br> 结果窗口中出现有关81高，109中和175低警告的信息。 如果计算频率，则将得到0.06高警告/文件，0.09中警告/文件和0.14低警告/文件。 或 <br> 每千行代码0.74高警告，每千行代码0.99中警告，每千行代码1.59低警告。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文中的</a>此处<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">表示</a> ，在CruiseControl.NET中，该程序具有25.6万行代码，分析器发现了15个高警告，151个中警告和32个低警告。 <br><br> 事实证明，就Docotic.Pdf而言，每个组中均发出了更多警告。 <br><br><h3> 发现了什么？ </h3><br> 我决定在此阶段忽略低警告。 <br><br> 我按“代码”列对警告进行了排序，结果发现频率的绝对记录保存者为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a> “表达式始终为true / false”和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3063</a> “条件表达式的一部分在被评估时始终为true / false”。 我认为它们只是一件事。 总共这两个警告给出了190个案例中的92个，相对频率= 48％。 <br><br> 分为高和中的逻辑尚不完全清楚。 我期待<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3072</a> “包含IDisposable成员的'A'类本身并不实现IDisposable”和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3073</a> “并非所有IDisposable成员都得到适当处置。 例如，在“高级”组中布置“ A”类时，请调用“布置”。 但这当然是味道。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">惊讶</a>于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3095</a> “在针对null进行验证之前使用了该对象。 检查行：N1，N2被标记为两次高，一次标记为中。 虫子？ <br><br><img src="https://habrastorage.org/webt/kz/dk/e8/kzdke88cvkewlgqplmw4xlp55ym.png"><br><br><h3> 信任但要验证 </h3><br> 现在该检查警告的合理性了。 是否发现任何实际错误？ 是否有任何不正确的警告？ <br><br> 我将发现的警告分为以下几组。 <br><br><h4> 重要警告 </h4><br> 他们的修正提高了稳定性，解决了内存泄漏等问题。 真正的错误/缺陷。 <br><br> 其中有16个已发布，占所有警告的8％。 <br><br> 我会举一些例子。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3019</a> “可能在使用'as'关键字进行类型转换后，将不正确的变量与null进行比较。 检查变量“颜色”，“索引”» <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsCompatible</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ColorImpl color</span></span></span><span class="hljs-function">)</span></span> { IndexedColorImpl indexed = color <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IndexedColorImpl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> indexed.ColorSpace.Equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br> 如您所见，将变量color与null进行比较，而不是对其进行索引。 这是不正确的，并可能导致NRE。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a> “可能取消空引用。 考虑检查“ cstr_index.tile_index”» <br><br> 一个小片段来说明： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cstr_index.tile_index == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cstr_index.tile_index[<span class="hljs-number"><span class="hljs-number">0</span></span>].tp_index == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// .. } }</span></span></code> </pre><br> 显然，第一个条件隐含！=空。 在当前形式下，代码将在每次调用时抛出NRE。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3083</a> “事件'OnProgress'的不安全调用，可能会发生NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。” <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Updated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (OnProgress != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) OnProgress(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventArgs()); }</code> </pre><br> 警告有助于解决潜在的异常。 为什么会出现？  Stackoverflow有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">很好的解释</a> 。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3106</a> “可能索引超出范围。 索引“ 0”指向“ v”界限之外» <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;FontStringPair&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; text.Length; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;FontStringPair&gt;(); createPairs(text[i].ToString(CultureInfo.InvariantCulture)); result.Add(v[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre><br> 错误是将忽略createPairs的结果，而是访问一个空列表。 显然，最初createPairs接受列表作为参数，但是在更改方法的过程中发生了错误。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3117</a> '构造函数参数'validateType'未使用 <br><br> 针对与此类似的代码发出了警告 <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDocument document, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> validateType = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">document, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span> { m_provider = document; }</code> </pre><br> 警告本身似乎并不重要。 但是这个问题比乍看之下要严重得多。 在添加可选的validateType参数的过程中，他们忘记了将调用固定到基类的构造函数。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3127？</a>找到了两个类似的代码片段。 也许，这是一个错字，应该使用“范围”变量而不是“域”“ <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillTransferFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PdfStreamImpl function</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// .. PdfArrayImpl domain = new PdfArrayImpl(); domain.AddReal(0); domain.AddReal(1); function.Add(Field.Domain, domain); PdfArrayImpl range = new PdfArrayImpl(); range.AddReal(0); range.AddReal(1); function.Add(Field.Range, domain); // .... }</span></span></code> </pre><br> 如果代码的部分稍有不同，则可能不会发出警告。 但是在这种情况下，使用复制粘贴时检测到错误。 <br><br><h4> 理论/形式警告 </h4><br> 它们要么是正确的，但是它们的更正不能解决任何特定的错误，并且不影响代码的可读性。 或者他们指出可能存在错误但不存在的地方。 例如，有意改变参数的顺序。 对于此类警告，您无需在程序中进行任何更改。 <br><br> 在这些警告中，有57个已发出，占所有警告的30％。 我将举一些值得关注的案例。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3013</a> “奇怪的是，“ BeginText”功能的主体完全等同于“ EndText”功能的主体（166，第171行）” <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { m_state.ResetTextParameters(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndText</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { m_state.ResetTextParameters(); }</code> </pre><br> 两种身体功能实际上是相同的。 但这是对的。 如果一行的功能主体重合真的真的很奇怪吗？ <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3106？</a>可能的负索引值。  “ c1”索引的值可能达到-1“ <br><br><pre> <code class="cs hljs">freq[<span class="hljs-number"><span class="hljs-number">256</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// .... c1 = -1; v = 1000000000L; for (i = 0; i &lt;= 256; i++) { if (freq[i] != 0 &amp;&amp; freq[i] &lt;= v) { v = freq[i]; c1 = i; } } // .... freq[c1] += freq[c2];</span></span></code> </pre><br> 我同意，我给出了一个不太清楚的算法。 但是，在我看来，在这种情况下，分析仪是徒劳的。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3107</a> “在化合物分配的左侧和右侧相同的表达式'neighsum'” <br><br> 该警告是由一个很普通的代码引起的： <br><br><pre> <code class="cs hljs">neighsum += neighsum;</code> </pre><br> 是的，可以通过乘法重写。 但是没有错。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3109</a> “ l_cblk.data_current_size”子表达式存在于运算符的两侧。 该表达式不正确或可以简化。 <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Check possible overflow on size */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((l_cblk.data_current_size + l_seg.newlen) &lt; l_cblk.data_current_size) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br> 代码中的注释阐明了意图。 再次虚惊一场。 <br><br><h4> 正当警告 </h4><br> 他们的更正对代码的可读性产生了积极的影响。 也就是说，它减少了不必要的条件，检查等。 对代码工作方式的影响并不明显。 <br><br> 在这些警告中，有103个被发布，占所有警告的54％。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3008</a> “ l_mct_deco_data”变量被连续两次分配值。 也许这是一个错误 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_nb_mct_records == m_nb_max_mct_records) { ResizeMctRecords(); l_mct_deco_data = (OPJ_INT32)m_nb_mct_records; } l_mct_deco_data = (OPJ_INT32)m_nb_mct_records;</code> </pre><br> 权限分析器：如果不需要，在内部分配。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3009</a> “奇怪的是，该方法总是返回一个相同的值” <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">opj_dwt_decode_tile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">opj_tcd_tilecomp_t tilec, OPJ_UINT32 numres</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numres == <span class="hljs-number"><span class="hljs-number">1U</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... return true; }</span></span></code> </pre><br> 根据分析仪的建议，该方法已更改，仅返回任何内容。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a> “表达式'！Add'始终为真” <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PdfDictionaryImpl controlDict, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">add</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... if (add) { // .. return; } if (!add) { // ... } // ... }</span></span></code> </pre><br> 的确，第二个if毫无意义。 条件将始终为真。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3029</a> “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">彼此并排放置</a>的'if'语句的条件表达式相同” <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stroke) extGState.OpacityStroke = opacity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stroke) state.AddReal(Field.CA, opacity);</code> </pre><br> 目前尚不清楚这种代码是如何产生的。 但是现在我们修复了它。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3031？</a>过度检查可以简化。  “ ||” 运算符被相反的表达式包围“ <br><br> 这是一场噩梦： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(cp.m_enc.m_tp_on != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; ((!opj_codec_t.OPJ_IS_CINEMA(cp.rsiz) &amp;&amp; (t2_mode == J2K_T2_MODE.FINAL_PASS)) || opj_codec_t.OPJ_IS_CINEMA(cp.rsiz)))) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br> 更改后，情况变得更好了 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(cp.m_enc.m_tp_on != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (opj_codec_t.OPJ_IS_CINEMA(cp.rsiz) || t2_mode == J2K_T2_MODE.FINAL_PASS))) { <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3063</a> “条件表达式的一部分如果被求值，则始终为true：x！= Null” <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a> “表达式'x！= Null'始终为真” <br><br> 在这里，我包含了警告，检查null没有意义。 这样做是否正确是一个有争议的问题。 我在下面更详细地描述了问题的实质。 <br><br><h4> 无根据的警告 </h4><br> 误报 由于特定测试的实施中的错误或某种分析仪缺陷。 <br><br> 其中，发布了14个，占所有警告的7％。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3081</a> “未在嵌套循环内使用'i'计数器。 考虑检查“ j”计数器的使用情况“ <br><br> 发出此警告的代码的稍微简化的版本： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; initialGlyphsCount - <span class="hljs-number"><span class="hljs-number">1</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; initialGlyphsCount - i - <span class="hljs-number"><span class="hljs-number">1</span></span>; ++j) { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre><br> 显然，我是在嵌套循环中使用的。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3125</a> “对象已针对null进行验证后使用” <br><br> 发出警告的代码： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Compare_SecondGreater</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cmapEncodingRecord er1, cmapEncodingRecord er2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (er1 == er2) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (er1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; er2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (er1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; er2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> er1.CompareTo(er2); }</code> </pre><br> 调用CompareTo（）时er1不能为null。 <br><br> 发出此警告的另一个代码： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">realloc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] table, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newSize</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] newTable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[newSize][]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> existingSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (table != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) existingSize = table.Length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; existingSize; i++) newTable[i] = table[i]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = existingSize; i &lt; newSize; i++) newTable[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">4</span></span>]; table = newTable; }</code> </pre><br>  table在循环中不能为null。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3134</a> “移位[32..255]位大于'UInt32'类型的表达式'（uint）1'的大小” <br><br> 发出此警告的一段代码： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> bitPos = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(numBits &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> mask = (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; bitPos;</code> </pre><br> 可以看出bitPos的值可以在[0..31]范围内，但分析仪认为它的值可以在[0..31]范围内，这是不正确的。 <br><br> 我不会给出其他类似情况，因为它们是等效的。 <br><br><h4> 一些检查的其他想法 </h4><br> 在我看来，不希望警告“ x！= Null”在x是调用某种方法的结果的情况下始终为真。 一个例子： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(...); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X(...); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentOutOfRangeException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(x)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... X x = GetX(..); if (x != null) { // ... } }</span></span></code> </pre><br> 是的，从形式上讲，分析器是正确的：x永远不会为null，因为GetX要么返回完整实例，要么抛出异常。 但是，代码是否可以将检查的清除效果提高为null？ 如果GetX以后更改怎么办？  Method是否必须知道GetX实现？ <br><br> 在团队内部，意见分歧。 有人建议当前方法有一个约定，根据该约定不应返回null。 而且，每次调用都编写“面向未来”的冗余代码是没有意义的。 并且如果合同更改，则必须更新调用代码。 <br><br> 为支持此观点，做出了以下判断：检查null就像将每个调用包装在try / catch中，以防万一该方法在将来开始引发异常。 <br><br> 结果，根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">YAGNI</a>原则，他们决定不保留支票并将其删除。 所有警告都从理论/正式转向合理。 <br><br> 我很高兴在评论中阅读您的意见。 <br><br><h3> 结论 </h3><br> 静态分析是一件好事。  PVS-Studio可让您发现真正的错误。 <br><br> 是的，有不合理/错误的警告。 但是，PVS-Studio仍然在已经使用代码分析的项目中发现了真正的错误。 我们的产品相当受测试覆盖，它是客户测试的一种或另一种方法，但是<s>机器人做得更好，</s>静态分析仍然是有益的。 <br><br> 最后是一些统计数据。 <br><br><h4> 前3个不合理的警告 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3081</a>嵌套循环中不使用“ X”计数器。 考虑检查“ Y”计数器的使用情况“ <br>  1人中有1人发现不合理 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3125</a> “将对象验证为空后，将使用该对象。 检查行：N1，N2“ <br>  10人中有9人被宣布为毫无根据 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3134</a> “ N位移位大于类型的大小” <br>  5人中有4人被发现是没有根据的 <br><br><h4> 前3个重要警告 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3083</a> “事件的不安全调用，可能是NullReferenceException。 考虑在调用事件之前将事件分配给本地变量“ <br>  5人中有5人被认为很重要。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3020</a> “循环内无条件的'中断/继续/返回/跳转'” <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3080</a> “可能的空取消引用” <br>  2人中有2人被认为很重要。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3019</a> “在使用'as'关键字进行类型转换后，有可能将不正确的变量与null比较” <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3127？</a>找到了两个类似的代码片段。 也许，这是一个错字，应该使用“ X”变量而不是“ Y” <br>  1中的1被认为很重要。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425741/">https://habr.com/ru/post/zh-CN425741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425727/index.html">直到下一次</a></li>
<li><a href="../zh-CN425729/index.html">Hackathon Pro欢迎：第一个慈善机构SmartMail Hack怎么样</a></li>
<li><a href="../zh-CN425731/index.html">不可能的GPU计算的秘密</a></li>
<li><a href="../zh-CN425737/index.html">桌上的地图：如何为移动应用程序选择地图提供商</a></li>
<li><a href="../zh-CN425739/index.html">微软宣布Project xCloud-尖端的游戏流媒体服务</a></li>
<li><a href="../zh-CN425743/index.html">心理治疗 火星在土星家中，脑内注射顺势性倍半胱氨酸</a></li>
<li><a href="../zh-CN425747/index.html">“ Timur和他的团队”发生了什么，或关于武装技术人员合作伙伴关系的想法</a></li>
<li><a href="../zh-CN425749/index.html">网络正处于危险之中。 加入我们为她而战</a></li>
<li><a href="../zh-CN425751/index.html">首次成功植入模仿骨骼结构的聚合物假体</a></li>
<li><a href="../zh-CN425753/index.html">Google+ RIP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>