<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌🏾 📪 🙌🏽 Wie wir die verzögerte Replikation für die Notfallwiederherstellung mit PostgreSQL verwendet haben 👩🏽‍🤝‍👨🏻 👩🏻‍⚕️ 🤷🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Replikation ist keine Sicherung. Oder nicht? So haben wir die verzögerte Replikation für die Wiederherstellung verwendet, indem wir versehentlich ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir die verzögerte Replikation für die Notfallwiederherstellung mit PostgreSQL verwendet haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/445446/"><p><img src="https://habrastorage.org/webt/d5/ij/ht/d5ijhtuldyyxn2aomtg2r4sdvum.jpeg"></p><br><p>  Die Replikation ist keine Sicherung.  Oder nicht?  So haben wir die verzögerte Replikation für die Wiederherstellung verwendet, indem wir versehentlich Verknüpfungen gelöscht haben. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Infrastrukturspezialisten</a> von GitLab sind für die Ausführung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitLab.com verantwortlich</a> , der größten Instanz von GitLab in der Natur.  Es gibt 3 Millionen Benutzer und fast 7 Millionen Projekte. Dies ist eine der größten Open-Source-SaaS-Sites mit einer dedizierten Architektur.  Ohne das PostgreSQL-Datenbanksystem wird die GitLab.com-Infrastruktur nicht weit gehen, und wir tun dies nur nicht aus Gründen der Fehlertoleranz, falls Fehler auftreten, wenn Daten verloren gehen können.  Es ist unwahrscheinlich, dass eine solche Katastrophe eintreten wird, aber wir sind gut vorbereitet und mit verschiedenen Sicherungs- und Replikationsmechanismen ausgestattet. </p><br><p> Die Replikation ist für Sie kein Datenbanksicherungstool ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe unten</a> ).  Jetzt werden wir sehen, wie versehentlich gelöschte Daten mithilfe einer verzögerten Replikation schnell wiederhergestellt werden können: Auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitLab.com hat der</a> Benutzer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Verknüpfung</a> für das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>gitlab-ce</code></a> Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gelöscht</a> und den Kontakt zu Zusammenführungsanforderungen und -aufgaben verloren. </p><br><p>  Mit einem verzögerten Replikat haben wir Daten in nur 1,5 Stunden wiederhergestellt.  Sehen Sie, wie es war. </p><a name="habracut"></a><br><h3 id="vosstanovlenie-na-moment-vremeni-s-postgresql">  Wiederherstellung zu einem bestimmten Zeitpunkt mit PostgreSQL </h3><br><p>  PostgreSQL verfügt über eine integrierte Funktion, die den Status der Datenbank zu einem bestimmten Zeitpunkt wiederherstellt.  Es wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Point-in-Time-Recovery</a> (PITR) bezeichnet und verwendet dieselben Mechanismen, die die Relevanz des Replikats erhalten: Ausgehend von einem zuverlässigen Snapshot des gesamten Datenbankclusters (Basissicherung) wenden wir eine Reihe von Statusänderungen bis zu einem bestimmten Zeitpunkt an. </p><br><p>  Um diese Funktion für eine kalte Sicherung zu verwenden, erstellen wir regelmäßig eine grundlegende Datenbanksicherung und speichern sie in einem Archiv (GitLab-Archive befinden sich live im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Cloud-Speicher</a> ).  Wir überwachen auch Änderungen im Status der Datenbank, indem wir das WAL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Protokoll</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Write-Ahead-Protokoll</a> ) archivieren.  Und mit all dem können wir PITR für die Notfallwiederherstellung durchführen: Wir beginnen mit dem vor dem Fehler aufgenommenen Bild und übernehmen die Änderungen aus dem WAL-Archiv bis zum Fehler. </p><br><h3 id="chto-takoe-otlozhennaya-replikaciya">  Was ist eine verzögerte Replikation? </h3><br><p>  Die verzögerte Replikation ist die Anwendung verzögerter WAL-Änderungen.  Das heißt, die Transaktion wurde zur Stunde <code>X</code> , sie wird jedoch im Replikat mit einer Verzögerung von <code>d</code> zur Stunde <code>X + d</code> . </p><br><p>  PostgreSQL bietet zwei Möglichkeiten, um das physische Replikat der Datenbank zu konfigurieren: Wiederherstellung aus dem Archiv und Streaming-Replikation.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Wiederherstellen aus dem Archiv</a> funktioniert zwar wie PITR, jedoch kontinuierlich: Wir extrahieren ständig die Änderungen aus dem WAL-Archiv und wenden sie auf das Replikat an.  Durch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Streaming-Replikation</a> wird der WAL-Stream direkt vom Upstream-Datenbankhost abgerufen.  Wir bevorzugen die Wiederherstellung aus dem Archiv - es ist einfacher zu verwalten und weist eine normale Leistung auf, die nicht hinter dem Arbeitscluster zurückbleibt. </p><br><h3 id="kak-nastroit-otlozhennoe-vosstanovlenie-iz-arhiva">  So richten Sie die verzögerte Wiederherstellung aus dem Archiv ein </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiederherstellungsoptionen werden</a> in der Datei <code>recovery.conf</code> beschrieben.  Ein Beispiel: </p><br><pre> <code class="plaintext hljs">standby_mode = 'on' restore_command = '/usr/bin/envdir /etc/wal-ed/env /opt/wal-e/bin/wal-e wal-fetch -p 4 "%f" "%p"' recovery_min_apply_delay = '8h' recovery_target_timeline = 'latest'</code> </pre> <br><p>  Mit diesen Parametern haben wir ein verzögertes Replikat mit Wiederherstellung aus dem Archiv eingerichtet.  Hier wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wal-e verwendet</a> , um WAL-Segmente ( <code>restore_command</code> ) aus dem Archiv zu extrahieren, und die Änderungen werden nach acht Stunden übernommen ( <code>recovery_min_apply_delay</code> ).  Das Replikat überwacht Änderungen in der Zeitleiste im Archiv, z. B. aufgrund eines Failovers im Cluster ( <code>recovery_target_timeline</code> ). </p><br><p>  Mit <code>recovery_min_apply_delay</code> Sie die verzögerte Streaming-Replikation konfigurieren. Es gibt jedoch einige Tricks, die mit Replikationssteckplätzen, Hot-Spare-Feedback usw. verbunden sind.  Mit dem WAL-Archiv können Sie diese vermeiden. </p><br><p>  Der Parameter <code>recovery_min_apply_delay</code> nur in PostgreSQL 9.3 angezeigt.  In früheren Versionen müssen Sie für die verzögerte Replikation eine Kombination <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Wiederherstellungsverwaltungsfunktionen</a> ( <code>pg_xlog_replay_pause(), pg_xlog_replay_resume()</code> ) <code>pg_xlog_replay_pause(), pg_xlog_replay_resume()</code> oder WAL-Segmente für die Zeitverzögerung im Archiv <code>pg_xlog_replay_pause(), pg_xlog_replay_resume()</code> . </p><br><h3 id="kak-postgresql-eto-delaet">  Wie macht PostgreSQL das? </h3><br><p>  Neugierig zu sehen, wie PostgreSQL die verzögerte Wiederherstellung implementiert.  Schauen wir uns <a href=""><code>recoveryApplyDelay(XlogReaderState)</code></a> .  Es wird von der <a href="">Hauptschleife</a> für jeden Eintrag in der WAL aufgerufen. </p><br><pre> <code class="plaintext hljs">static bool recoveryApplyDelay(XLogReaderState *record) { uint8 xact_info; TimestampTz xtime; long secs; int microsecs; /* nothing to do if no delay configured */ if (recovery_min_apply_delay &lt;= 0) return false; /* no delay is applied on a database not yet consistent */ if (!reachedConsistency) return false; /* * Is it a COMMIT record? * * We deliberately choose not to delay aborts since they have no effect on * MVCC. We already allow replay of records that don't have a timestamp, * so there is already opportunity for issues caused by early conflicts on * standbys. */ if (XLogRecGetRmid(record) != RM_XACT_ID) return false; xact_info = XLogRecGetInfo(record) &amp; XLOG_XACT_OPMASK; if (xact_info != XLOG_XACT_COMMIT &amp;&amp; xact_info != XLOG_XACT_COMMIT_PREPARED) return false; if (!getRecordTimestamp(record, &amp;xtime)) return false; recoveryDelayUntilTime = TimestampTzPlusMilliseconds(xtime, recovery_min_apply_delay); /* * Exit without arming the latch if it's already past time to apply this * record */ TimestampDifference(GetCurrentTimestamp(), recoveryDelayUntilTime, &amp;secs, &amp;microsecs); if (secs &lt;= 0 &amp;&amp; microsecs &lt;= 0) return false; while (true) { // Shortened: // Use WaitLatch until we reached recoveryDelayUntilTime // and then break; } return true; }</code> </pre> <br><p>  Unter dem Strich basiert die Verzögerung auf der physischen Zeit, die im Transaktions-Commit-Zeitstempel ( <code>xtime</code> ) <code>xtime</code> .  Wie Sie sehen, gilt die Verzögerung nur für Festschreibungen und berührt keine anderen Datensätze. Alle Änderungen werden direkt angewendet, und die Festschreibung wird verzögert, sodass die Änderungen erst nach der Konfiguration der Verzögerung angezeigt werden. </p><br><h3 id="kak-ispolzovat-otlozhennuyu-repliku-dlya-vosstanovleniya-dannyh">  Verwendung von Lazy Replica zum Wiederherstellen von Daten </h3><br><p>  Angenommen, wir haben einen Datenbankcluster in der Produktion und ein Replikat mit einer Verzögerung von acht Stunden.  Lassen Sie uns anhand des Beispiels zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">versehentlichen Löschen von Verknüpfungen</a> sehen, wie Daten wiederhergestellt werden. </p><br><p>  Als wir von dem Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erfuhren</a> , haben wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiederherstellung aus dem Archiv</a> für das faule Replikat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angehalten</a> : </p><br><pre> <code class="plaintext hljs">SELECT pg_xlog_replay_pause();</code> </pre> <br><p>  Mit einer Pause hatten wir kein Risiko, dass das Replikat die <code>DELETE</code> Anforderung wiederholt.  Nützliche Sache, wenn Sie Zeit brauchen, um es herauszufinden. </p><br><p>  Unter dem Strich muss das zurückgestellte Replikat den Punkt vor der <code>DELETE</code> Anforderung erreichen.  Wir kannten ungefähr den physischen Zeitpunkt der Entfernung.  Wir haben <code>recovery_min_apply_delay</code> entfernt und <code>recovery_target_time</code> zur <code>recovery.conf</code> hinzugefügt.  So erreicht die Replik unverzüglich den richtigen Moment: </p><br><pre> <code class="plaintext hljs">recovery_target_time = '2018-10-12 09:25:00+00'</code> </pre> <br><p>  Bei Zeitstempeln ist es besser, den Überschuss zu reduzieren, um ihn nicht zu verpassen.  Je größer die Abnahme, desto mehr Daten verlieren wir.  Wenn wir die <code>DELETE</code> Anforderung durchlaufen, wird alles erneut gelöscht und Sie müssen erneut beginnen (oder sogar ein kaltes Backup für PITR erstellen). </p><br><p>  Wir haben die verzögerte Instanz von Postgres neu gestartet und die WAL-Segmente wurden bis zum angegebenen Zeitpunkt wiederholt.  Sie können den Fortschritt in dieser Phase auf Anfrage verfolgen: </p><br><pre> <code class="plaintext hljs">SELECT -- current location in WAL pg_last_xlog_replay_location(), -- current transaction timestamp (state of the replica) pg_last_xact_replay_timestamp(), -- current physical time now(), -- the amount of time still to be applied until recovery_target_time has been reached '2018-10-12 09:25:00+00'::timestamptz - pg_last_xact_replay_timestamp() as delay;</code> </pre> <br><p>  Wenn sich der Zeitstempel nicht mehr ändert, ist die Wiederherstellung abgeschlossen.  Sie können die Aktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>recovery_target_action</code></a> so konfigurieren, dass eine Instanz nach einer Wiedergabe geschlossen, erweitert oder angehalten wird (standardmäßig wird sie angehalten). </p><br><p>  Die Datenbank wurde vor dieser unglücklichen Anfrage in einen Zustand versetzt.  Jetzt können Sie beispielsweise Daten exportieren.  Wir haben die gelöschten Daten über die Verknüpfung und alle Verbindungen mit Aufgaben und Zusammenführungsanforderungen exportiert und in die Arbeitsdatenbank übertragen.  Wenn die Verluste groß sind, können Sie das Replikat einfach bewerben und als Hauptreplikat verwenden.  Aber dann gehen alle Änderungen nach dem Moment verloren, in dem wir uns erholt haben. </p><br><p>  Anstelle von Zeitstempeln ist es besser, Transaktions-IDs zu verwenden.  Es ist nützlich, diese IDs beispielsweise für DDL-Anweisungen (wie <code>DROP TABLE</code> ) mit <code>log_statements = 'ddl'</code> zu schreiben.  Wenn wir eine Transaktions-ID hätten, würden wir <code>recovery_target_xid</code> nehmen und alles bis zur Transaktion vor der <code>DELETE</code> Anforderung ausführen. </p><br><p>  Die Rückkehr zur Arbeit ist sehr einfach: Entfernen Sie alle Änderungen aus der Datei <code>recovery.conf</code> und starten Sie Postgres neu.  Bald wird wieder eine Verzögerung von acht Stunden im Cue erscheinen, und wir sind bereit für zukünftige Probleme. </p><br><h3 id="preimuschestva-dlya-vosstanovleniya">  Wiederherstellungsvorteile </h3><br><p>  Bei einem verzögerten Replikat müssen Sie anstelle eines kalten Backups nicht stundenlang das gesamte Image aus dem Archiv wiederherstellen.  Zum Beispiel benötigen wir fünf Stunden, um die gesamte Basissicherung von 2 TB zu erhalten.  Und dann müssen Sie immer noch die gesamte tägliche WAL anwenden, um den gewünschten Zustand wiederherzustellen (im schlimmsten Fall). </p><br><p>  Ein verzögertes Replikat ist in zweierlei Hinsicht besser als ein kaltes Backup: </p><br><ol><li>  Es ist nicht erforderlich, die gesamte Basissicherung aus dem Archiv abzurufen. </li><li>  Es gibt ein festes Acht-Stunden-Fenster für WAL-Segmente, die wiederholt werden müssen. </li></ol><br><p>  Und wir überprüfen ständig, ob es möglich ist, PITR aus WAL zu erstellen, und wir würden schnell Schäden oder andere Probleme mit dem WAL-Archiv bemerken und auf die Verzögerung des verzögerten Replikats achten. </p><br><p>  In diesem Beispiel dauerte die Wiederherstellung 50 Minuten, dh die Geschwindigkeit betrug 110 GB WAL-Daten pro Stunde (das Archiv befand sich damals noch in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWS S3</a> ).  Insgesamt haben wir das Problem gelöst und die Daten in 1,5 Stunden wiederhergestellt. </p><br><h3 id="itogi-gde-prigoditsya-otlozhennaya-replika-a-gde-net">  Fazit: Wo die verzögerte Replik nützlich ist (und wo nicht) </h3><br><p>  Verwenden Sie die verzögerte Replikation als erste Hilfe, wenn Sie versehentlich Daten verlieren und diese Katastrophe innerhalb der konfigurierten Verzögerung bemerken. </p><br><blockquote>  Beachten Sie jedoch, dass die Replikation keine Sicherung ist. </blockquote><p>  Backup und Replikation haben unterschiedliche Ziele.  Eine kalte Sicherung ist nützlich, wenn Sie versehentlich eine <code>DELETE</code> oder <code>DROP TABLE</code> .  Wir machen eine Sicherung aus dem Kühlhaus und stellen den vorherigen Status der Tabelle oder der gesamten Datenbank wieder her.  Gleichzeitig wird die <code>DROP TABLE</code> Abfrage fast sofort in allen Replikaten des Arbeitsclusters abgespielt, sodass Sie hier nicht durch regelmäßige Replikation gespeichert werden.  Durch die Replikation selbst bleibt die Datenbank zugänglich, wenn separate Server geleast werden, und die Last wird verteilt. </p><br><p>  Selbst bei einem verzögerten Replikat benötigen wir manchmal wirklich ein kaltes Backup an einem sicheren Ort, wenn ein Rechenzentrum abstürzt, versteckte Schäden oder andere Ereignisse auftreten, die Sie nicht sofort bemerken.  Eine Replikation macht keinen Sinn. </p><br><p>  <strong>Hinweis</strong>  Bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitLab.com</a> schützen wir jetzt nur auf Systemebene vor Datenverlust und stellen keine Daten auf Benutzerebene wieder her. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445446/">https://habr.com/ru/post/de445446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445434/index.html">Bester schlechtester Job der Welt: Auf der Suche nach einem Habraautor</a></li>
<li><a href="../de445436/index.html">Umschulung in DevOps - worauf Sie sich vorbereiten müssen</a></li>
<li><a href="../de445438/index.html">Bekanntschaft mit darauf basierenden Lit-Element- und Web-Komponenten</a></li>
<li><a href="../de445440/index.html">Codeüberprüfung: schlechte Tipps für Mitwirkende und Prüfer</a></li>
<li><a href="../de445444/index.html">Hochleistungs-Solarmodul-Update von REC und Trina (Solar)</a></li>
<li><a href="../de445448/index.html">Konfigurieren des automatischen Empfangs von Letsencrypt-Zertifikaten mit Docker unter Linux</a></li>
<li><a href="../de445450/index.html">Browser-Erweiterung für toster.ru</a></li>
<li><a href="../de445452/index.html">Nützliche Repositories mit Eloquent?</a></li>
<li><a href="../de445454/index.html">Himbeer Pi Zero Inside Handy Tech Active Star 40 Braillezeile</a></li>
<li><a href="../de445456/index.html">Suche mit 1 TB / s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>