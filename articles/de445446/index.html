<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõåüèæ üì™ üôåüèΩ Wie wir die verz√∂gerte Replikation f√ºr die Notfallwiederherstellung mit PostgreSQL verwendet haben üë©üèΩ‚Äçü§ù‚Äçüë®üèª üë©üèª‚Äç‚öïÔ∏è ü§∑üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Replikation ist keine Sicherung. Oder nicht? So haben wir die verz√∂gerte Replikation f√ºr die Wiederherstellung verwendet, indem wir versehentlich ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie wir die verz√∂gerte Replikation f√ºr die Notfallwiederherstellung mit PostgreSQL verwendet haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/445446/"><p><img src="https://habrastorage.org/webt/d5/ij/ht/d5ijhtuldyyxn2aomtg2r4sdvum.jpeg"></p><br><p>  Die Replikation ist keine Sicherung.  Oder nicht?  So haben wir die verz√∂gerte Replikation f√ºr die Wiederherstellung verwendet, indem wir versehentlich Verkn√ºpfungen gel√∂scht haben. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Infrastrukturspezialisten</a> von GitLab sind f√ºr die Ausf√ºhrung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitLab.com verantwortlich</a> , der gr√∂√üten Instanz von GitLab in der Natur.  Es gibt 3 Millionen Benutzer und fast 7 Millionen Projekte. Dies ist eine der gr√∂√üten Open-Source-SaaS-Sites mit einer dedizierten Architektur.  Ohne das PostgreSQL-Datenbanksystem wird die GitLab.com-Infrastruktur nicht weit gehen, und wir tun dies nur nicht aus Gr√ºnden der Fehlertoleranz, falls Fehler auftreten, wenn Daten verloren gehen k√∂nnen.  Es ist unwahrscheinlich, dass eine solche Katastrophe eintreten wird, aber wir sind gut vorbereitet und mit verschiedenen Sicherungs- und Replikationsmechanismen ausgestattet. </p><br><p> Die Replikation ist f√ºr Sie kein Datenbanksicherungstool ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">siehe unten</a> ).  Jetzt werden wir sehen, wie versehentlich gel√∂schte Daten mithilfe einer verz√∂gerten Replikation schnell wiederhergestellt werden k√∂nnen: Auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitLab.com hat der</a> Benutzer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Verkn√ºpfung</a> f√ºr das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>gitlab-ce</code></a> Projekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gel√∂scht</a> und den Kontakt zu Zusammenf√ºhrungsanforderungen und -aufgaben verloren. </p><br><p>  Mit einem verz√∂gerten Replikat haben wir Daten in nur 1,5 Stunden wiederhergestellt.  Sehen Sie, wie es war. </p><a name="habracut"></a><br><h3 id="vosstanovlenie-na-moment-vremeni-s-postgresql">  Wiederherstellung zu einem bestimmten Zeitpunkt mit PostgreSQL </h3><br><p>  PostgreSQL verf√ºgt √ºber eine integrierte Funktion, die den Status der Datenbank zu einem bestimmten Zeitpunkt wiederherstellt.  Es wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Point-in-Time-Recovery</a> (PITR) bezeichnet und verwendet dieselben Mechanismen, die die Relevanz des Replikats erhalten: Ausgehend von einem zuverl√§ssigen Snapshot des gesamten Datenbankclusters (Basissicherung) wenden wir eine Reihe von Status√§nderungen bis zu einem bestimmten Zeitpunkt an. </p><br><p>  Um diese Funktion f√ºr eine kalte Sicherung zu verwenden, erstellen wir regelm√§√üig eine grundlegende Datenbanksicherung und speichern sie in einem Archiv (GitLab-Archive befinden sich live im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Google Cloud-Speicher</a> ).  Wir √ºberwachen auch √Ñnderungen im Status der Datenbank, indem wir das WAL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-Protokoll</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Write-Ahead-Protokoll</a> ) archivieren.  Und mit all dem k√∂nnen wir PITR f√ºr die Notfallwiederherstellung durchf√ºhren: Wir beginnen mit dem vor dem Fehler aufgenommenen Bild und √ºbernehmen die √Ñnderungen aus dem WAL-Archiv bis zum Fehler. </p><br><h3 id="chto-takoe-otlozhennaya-replikaciya">  Was ist eine verz√∂gerte Replikation? </h3><br><p>  Die verz√∂gerte Replikation ist die Anwendung verz√∂gerter WAL-√Ñnderungen.  Das hei√üt, die Transaktion wurde zur Stunde <code>X</code> , sie wird jedoch im Replikat mit einer Verz√∂gerung von <code>d</code> zur Stunde <code>X + d</code> . </p><br><p>  PostgreSQL bietet zwei M√∂glichkeiten, um das physische Replikat der Datenbank zu konfigurieren: Wiederherstellung aus dem Archiv und Streaming-Replikation.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Wiederherstellen aus dem Archiv</a> funktioniert zwar wie PITR, jedoch kontinuierlich: Wir extrahieren st√§ndig die √Ñnderungen aus dem WAL-Archiv und wenden sie auf das Replikat an.  Durch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Streaming-Replikation</a> wird der WAL-Stream direkt vom Upstream-Datenbankhost abgerufen.  Wir bevorzugen die Wiederherstellung aus dem Archiv - es ist einfacher zu verwalten und weist eine normale Leistung auf, die nicht hinter dem Arbeitscluster zur√ºckbleibt. </p><br><h3 id="kak-nastroit-otlozhennoe-vosstanovlenie-iz-arhiva">  So richten Sie die verz√∂gerte Wiederherstellung aus dem Archiv ein </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiederherstellungsoptionen werden</a> in der Datei <code>recovery.conf</code> beschrieben.  Ein Beispiel: </p><br><pre> <code class="plaintext hljs">standby_mode = 'on' restore_command = '/usr/bin/envdir /etc/wal-ed/env /opt/wal-e/bin/wal-e wal-fetch -p 4 "%f" "%p"' recovery_min_apply_delay = '8h' recovery_target_timeline = 'latest'</code> </pre> <br><p>  Mit diesen Parametern haben wir ein verz√∂gertes Replikat mit Wiederherstellung aus dem Archiv eingerichtet.  Hier wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wal-e verwendet</a> , um WAL-Segmente ( <code>restore_command</code> ) aus dem Archiv zu extrahieren, und die √Ñnderungen werden nach acht Stunden √ºbernommen ( <code>recovery_min_apply_delay</code> ).  Das Replikat √ºberwacht √Ñnderungen in der Zeitleiste im Archiv, z. B. aufgrund eines Failovers im Cluster ( <code>recovery_target_timeline</code> ). </p><br><p>  Mit <code>recovery_min_apply_delay</code> Sie die verz√∂gerte Streaming-Replikation konfigurieren. Es gibt jedoch einige Tricks, die mit Replikationssteckpl√§tzen, Hot-Spare-Feedback usw. verbunden sind.  Mit dem WAL-Archiv k√∂nnen Sie diese vermeiden. </p><br><p>  Der Parameter <code>recovery_min_apply_delay</code> nur in PostgreSQL 9.3 angezeigt.  In fr√ºheren Versionen m√ºssen Sie f√ºr die verz√∂gerte Replikation eine Kombination <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von Wiederherstellungsverwaltungsfunktionen</a> ( <code>pg_xlog_replay_pause(), pg_xlog_replay_resume()</code> ) <code>pg_xlog_replay_pause(), pg_xlog_replay_resume()</code> oder WAL-Segmente f√ºr die Zeitverz√∂gerung im Archiv <code>pg_xlog_replay_pause(), pg_xlog_replay_resume()</code> . </p><br><h3 id="kak-postgresql-eto-delaet">  Wie macht PostgreSQL das? </h3><br><p>  Neugierig zu sehen, wie PostgreSQL die verz√∂gerte Wiederherstellung implementiert.  Schauen wir uns <a href=""><code>recoveryApplyDelay(XlogReaderState)</code></a> .  Es wird von der <a href="">Hauptschleife</a> f√ºr jeden Eintrag in der WAL aufgerufen. </p><br><pre> <code class="plaintext hljs">static bool recoveryApplyDelay(XLogReaderState *record) { uint8 xact_info; TimestampTz xtime; long secs; int microsecs; /* nothing to do if no delay configured */ if (recovery_min_apply_delay &lt;= 0) return false; /* no delay is applied on a database not yet consistent */ if (!reachedConsistency) return false; /* * Is it a COMMIT record? * * We deliberately choose not to delay aborts since they have no effect on * MVCC. We already allow replay of records that don't have a timestamp, * so there is already opportunity for issues caused by early conflicts on * standbys. */ if (XLogRecGetRmid(record) != RM_XACT_ID) return false; xact_info = XLogRecGetInfo(record) &amp; XLOG_XACT_OPMASK; if (xact_info != XLOG_XACT_COMMIT &amp;&amp; xact_info != XLOG_XACT_COMMIT_PREPARED) return false; if (!getRecordTimestamp(record, &amp;xtime)) return false; recoveryDelayUntilTime = TimestampTzPlusMilliseconds(xtime, recovery_min_apply_delay); /* * Exit without arming the latch if it's already past time to apply this * record */ TimestampDifference(GetCurrentTimestamp(), recoveryDelayUntilTime, &amp;secs, &amp;microsecs); if (secs &lt;= 0 &amp;&amp; microsecs &lt;= 0) return false; while (true) { // Shortened: // Use WaitLatch until we reached recoveryDelayUntilTime // and then break; } return true; }</code> </pre> <br><p>  Unter dem Strich basiert die Verz√∂gerung auf der physischen Zeit, die im Transaktions-Commit-Zeitstempel ( <code>xtime</code> ) <code>xtime</code> .  Wie Sie sehen, gilt die Verz√∂gerung nur f√ºr Festschreibungen und ber√ºhrt keine anderen Datens√§tze. Alle √Ñnderungen werden direkt angewendet, und die Festschreibung wird verz√∂gert, sodass die √Ñnderungen erst nach der Konfiguration der Verz√∂gerung angezeigt werden. </p><br><h3 id="kak-ispolzovat-otlozhennuyu-repliku-dlya-vosstanovleniya-dannyh">  Verwendung von Lazy Replica zum Wiederherstellen von Daten </h3><br><p>  Angenommen, wir haben einen Datenbankcluster in der Produktion und ein Replikat mit einer Verz√∂gerung von acht Stunden.  Lassen Sie uns anhand des Beispiels zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">versehentlichen L√∂schen von Verkn√ºpfungen</a> sehen, wie Daten wiederhergestellt werden. </p><br><p>  Als wir von dem Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erfuhren</a> , haben wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wiederherstellung aus dem Archiv</a> f√ºr das faule Replikat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angehalten</a> : </p><br><pre> <code class="plaintext hljs">SELECT pg_xlog_replay_pause();</code> </pre> <br><p>  Mit einer Pause hatten wir kein Risiko, dass das Replikat die <code>DELETE</code> Anforderung wiederholt.  N√ºtzliche Sache, wenn Sie Zeit brauchen, um es herauszufinden. </p><br><p>  Unter dem Strich muss das zur√ºckgestellte Replikat den Punkt vor der <code>DELETE</code> Anforderung erreichen.  Wir kannten ungef√§hr den physischen Zeitpunkt der Entfernung.  Wir haben <code>recovery_min_apply_delay</code> entfernt und <code>recovery_target_time</code> zur <code>recovery.conf</code> hinzugef√ºgt.  So erreicht die Replik unverz√ºglich den richtigen Moment: </p><br><pre> <code class="plaintext hljs">recovery_target_time = '2018-10-12 09:25:00+00'</code> </pre> <br><p>  Bei Zeitstempeln ist es besser, den √úberschuss zu reduzieren, um ihn nicht zu verpassen.  Je gr√∂√üer die Abnahme, desto mehr Daten verlieren wir.  Wenn wir die <code>DELETE</code> Anforderung durchlaufen, wird alles erneut gel√∂scht und Sie m√ºssen erneut beginnen (oder sogar ein kaltes Backup f√ºr PITR erstellen). </p><br><p>  Wir haben die verz√∂gerte Instanz von Postgres neu gestartet und die WAL-Segmente wurden bis zum angegebenen Zeitpunkt wiederholt.  Sie k√∂nnen den Fortschritt in dieser Phase auf Anfrage verfolgen: </p><br><pre> <code class="plaintext hljs">SELECT -- current location in WAL pg_last_xlog_replay_location(), -- current transaction timestamp (state of the replica) pg_last_xact_replay_timestamp(), -- current physical time now(), -- the amount of time still to be applied until recovery_target_time has been reached '2018-10-12 09:25:00+00'::timestamptz - pg_last_xact_replay_timestamp() as delay;</code> </pre> <br><p>  Wenn sich der Zeitstempel nicht mehr √§ndert, ist die Wiederherstellung abgeschlossen.  Sie k√∂nnen die Aktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>recovery_target_action</code></a> so konfigurieren, dass eine Instanz nach einer Wiedergabe geschlossen, erweitert oder angehalten wird (standardm√§√üig wird sie angehalten). </p><br><p>  Die Datenbank wurde vor dieser ungl√ºcklichen Anfrage in einen Zustand versetzt.  Jetzt k√∂nnen Sie beispielsweise Daten exportieren.  Wir haben die gel√∂schten Daten √ºber die Verkn√ºpfung und alle Verbindungen mit Aufgaben und Zusammenf√ºhrungsanforderungen exportiert und in die Arbeitsdatenbank √ºbertragen.  Wenn die Verluste gro√ü sind, k√∂nnen Sie das Replikat einfach bewerben und als Hauptreplikat verwenden.  Aber dann gehen alle √Ñnderungen nach dem Moment verloren, in dem wir uns erholt haben. </p><br><p>  Anstelle von Zeitstempeln ist es besser, Transaktions-IDs zu verwenden.  Es ist n√ºtzlich, diese IDs beispielsweise f√ºr DDL-Anweisungen (wie <code>DROP TABLE</code> ) mit <code>log_statements = 'ddl'</code> zu schreiben.  Wenn wir eine Transaktions-ID h√§tten, w√ºrden wir <code>recovery_target_xid</code> nehmen und alles bis zur Transaktion vor der <code>DELETE</code> Anforderung ausf√ºhren. </p><br><p>  Die R√ºckkehr zur Arbeit ist sehr einfach: Entfernen Sie alle √Ñnderungen aus der Datei <code>recovery.conf</code> und starten Sie Postgres neu.  Bald wird wieder eine Verz√∂gerung von acht Stunden im Cue erscheinen, und wir sind bereit f√ºr zuk√ºnftige Probleme. </p><br><h3 id="preimuschestva-dlya-vosstanovleniya">  Wiederherstellungsvorteile </h3><br><p>  Bei einem verz√∂gerten Replikat m√ºssen Sie anstelle eines kalten Backups nicht stundenlang das gesamte Image aus dem Archiv wiederherstellen.  Zum Beispiel ben√∂tigen wir f√ºnf Stunden, um die gesamte Basissicherung von 2 TB zu erhalten.  Und dann m√ºssen Sie immer noch die gesamte t√§gliche WAL anwenden, um den gew√ºnschten Zustand wiederherzustellen (im schlimmsten Fall). </p><br><p>  Ein verz√∂gertes Replikat ist in zweierlei Hinsicht besser als ein kaltes Backup: </p><br><ol><li>  Es ist nicht erforderlich, die gesamte Basissicherung aus dem Archiv abzurufen. </li><li>  Es gibt ein festes Acht-Stunden-Fenster f√ºr WAL-Segmente, die wiederholt werden m√ºssen. </li></ol><br><p>  Und wir √ºberpr√ºfen st√§ndig, ob es m√∂glich ist, PITR aus WAL zu erstellen, und wir w√ºrden schnell Sch√§den oder andere Probleme mit dem WAL-Archiv bemerken und auf die Verz√∂gerung des verz√∂gerten Replikats achten. </p><br><p>  In diesem Beispiel dauerte die Wiederherstellung 50 Minuten, dh die Geschwindigkeit betrug 110 GB WAL-Daten pro Stunde (das Archiv befand sich damals noch in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AWS S3</a> ).  Insgesamt haben wir das Problem gel√∂st und die Daten in 1,5 Stunden wiederhergestellt. </p><br><h3 id="itogi-gde-prigoditsya-otlozhennaya-replika-a-gde-net">  Fazit: Wo die verz√∂gerte Replik n√ºtzlich ist (und wo nicht) </h3><br><p>  Verwenden Sie die verz√∂gerte Replikation als erste Hilfe, wenn Sie versehentlich Daten verlieren und diese Katastrophe innerhalb der konfigurierten Verz√∂gerung bemerken. </p><br><blockquote>  Beachten Sie jedoch, dass die Replikation keine Sicherung ist. </blockquote><p>  Backup und Replikation haben unterschiedliche Ziele.  Eine kalte Sicherung ist n√ºtzlich, wenn Sie versehentlich eine <code>DELETE</code> oder <code>DROP TABLE</code> .  Wir machen eine Sicherung aus dem K√ºhlhaus und stellen den vorherigen Status der Tabelle oder der gesamten Datenbank wieder her.  Gleichzeitig wird die <code>DROP TABLE</code> Abfrage fast sofort in allen Replikaten des Arbeitsclusters abgespielt, sodass Sie hier nicht durch regelm√§√üige Replikation gespeichert werden.  Durch die Replikation selbst bleibt die Datenbank zug√§nglich, wenn separate Server geleast werden, und die Last wird verteilt. </p><br><p>  Selbst bei einem verz√∂gerten Replikat ben√∂tigen wir manchmal wirklich ein kaltes Backup an einem sicheren Ort, wenn ein Rechenzentrum abst√ºrzt, versteckte Sch√§den oder andere Ereignisse auftreten, die Sie nicht sofort bemerken.  Eine Replikation macht keinen Sinn. </p><br><p>  <strong>Hinweis</strong>  Bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitLab.com</a> sch√ºtzen wir jetzt nur auf Systemebene vor Datenverlust und stellen keine Daten auf Benutzerebene wieder her. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de445446/">https://habr.com/ru/post/de445446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de445434/index.html">Bester schlechtester Job der Welt: Auf der Suche nach einem Habraautor</a></li>
<li><a href="../de445436/index.html">Umschulung in DevOps - worauf Sie sich vorbereiten m√ºssen</a></li>
<li><a href="../de445438/index.html">Bekanntschaft mit darauf basierenden Lit-Element- und Web-Komponenten</a></li>
<li><a href="../de445440/index.html">Code√ºberpr√ºfung: schlechte Tipps f√ºr Mitwirkende und Pr√ºfer</a></li>
<li><a href="../de445444/index.html">Hochleistungs-Solarmodul-Update von REC und Trina (Solar)</a></li>
<li><a href="../de445448/index.html">Konfigurieren des automatischen Empfangs von Letsencrypt-Zertifikaten mit Docker unter Linux</a></li>
<li><a href="../de445450/index.html">Browser-Erweiterung f√ºr toster.ru</a></li>
<li><a href="../de445452/index.html">N√ºtzliche Repositories mit Eloquent?</a></li>
<li><a href="../de445454/index.html">Himbeer Pi Zero Inside Handy Tech Active Star 40 Braillezeile</a></li>
<li><a href="../de445456/index.html">Suche mit 1 TB / s</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>