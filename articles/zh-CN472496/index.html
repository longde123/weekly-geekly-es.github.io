<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏿 👔 👼🏾 在CSS网格上创建剪贴簿布局 🔥 👏 👩‍❤️‍💋‍👩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，在学前训练课中，我的儿子被指示要照顾一个泰迪熊一个星期，这表明有必要带一只泰迪熊去冒险，并将他的记忆添加到专辑中。 我真的很喜欢制作这张专辑，并促使我思考如何使用CSS Grid做这样的事情！ 




 复合网 
 Andy Clarke 在浏览器状态会议上做了精彩的演讲“受CSS网格技术启...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在CSS网格上创建剪贴簿布局</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472496/">最近，在学前训练课中，我的儿子被指示要照顾一个泰迪熊一个星期，这表明有必要带一只泰迪熊去冒险，并将他的记忆添加到专辑中。 我真的很喜欢制作这张专辑，并促使我思考如何使用CSS Grid做这样的事情！ <br><br><img src="https://habrastorage.org/webt/co/84/km/co84km1cpdhbrsdnprqdgmki2tw.jpeg"><br><a name="habracut"></a><br><hr><br><h2> 复合网 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Andy Clarke</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">在浏览器状态</a>会议上做了精彩的演讲“受CSS网格技术启发”，对于像我这样的设计根基的开发人员来说，这是一个真正的见识。 在他的演讲中，他谈到了印刷设计思想可以在网络上用于创建令人惊叹的布局的方式，以及CSS Grid如何不仅使这成为可能，而且比以往更简单。 这些原理之一是使用复合网格。 <br><br> 我们大多数人可能熟悉使用网格进行Web设计和开发。 我分配给我开发的几乎所有场地布局都被划分为标准的12列（有时是24列）的网格，各列的宽度相等。 到目前为止，一切都是可以预料的。 <br><br> 另一方面，通过将两个或多个网格相互叠加来创建复合网格。 例如，将5列网格叠加在4列网格上的比较会产生有节奏的图案，并为构建比常规网格更动态的布局开辟了可能性。 <br><br><img src="https://habrastorage.org/webt/w6/po/kz/w6pokzpxipaqg6z9rvr4av1e1sy.png"><br>  <i>图2-我们从4列和5列网格开始</i> <br><br><img src="https://habrastorage.org/webt/z8/g8/1z/z8g81zsvr_xbmvumns335rhxluu.png"><br>  <i>图3-网格相互重叠。</i>  <i>结果，我们得到了一个复合网格</i> <br><br> 从心理学和技术角度来看，这都是适用的-尽管可以使用复合网格，但我们可以创建最常见的布局。 安迪（Andy）写了一篇详细的文章，“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">启发性设计决策：紧要事项</a> ”，其中更多地讨论了复合网格。 也可以从浏览器状态会议<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">上发表他的演讲</a> 。 <br><br><h2> 复合网格生成器 </h2><br>  fr单元使在CSS Grid中实现复合网格非常容易。 我喜欢在网站设计中使用复合网格的想法，但是我认为计算它们（尤其是更复杂的网格）的过程可能会非常耗时。 我希望能够快速方便地创建复合网格，因此，受安迪报告的启发，我I起袖子，创建了一个小工具来创建和可视化它们。 输入两个网格的列数（每个网格最多10列），生成器将合并它们，并提供可以设置为<code>grid-template-columns</code>属性的最终值。 例如，一个四列网格加上一个五列网格显示<code>4fr 1fr 3fr 2fr 2fr 3fr 1fr 4fr</code> 。 <br><br><img src="https://habrastorage.org/webt/hm/3e/_f/hm3e_fhzl88wxv29l8fluiq_ucg.jpeg"><br><br> 该工具在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Codepen</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">提供</a> ，因此可以随时使用或适应您的需求。 <br><br><h2> 为相册布局创建网格 </h2><br> 复合网格非常适合我想使自己无法预测但又保持节奏感和平衡感的专辑布局。 在使用生成器进行少量实验之后，我选择了一个6/5的复合网格，在我看来，该网格提供了正确数量的列以供进一步操作。 这使我可以使用原始网格： <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: grid; <span class="hljs-attribute"><span class="hljs-attribute">grid-template-columns</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">4</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">3</span></span>fr <span class="hljs-number"><span class="hljs-number">3</span></span>fr <span class="hljs-number"><span class="hljs-number">2</span></span>fr <span class="hljs-number"><span class="hljs-number">4</span></span>fr <span class="hljs-number"><span class="hljs-number">1</span></span>fr <span class="hljs-number"><span class="hljs-number">5</span></span>fr; <span class="hljs-attribute"><span class="hljs-attribute">gap</span></span>: <span class="hljs-number"><span class="hljs-number">1rem</span></span>; }</code> </pre><br><h3> 定义网格行 </h3><br> 定义网格线更加困难，并且需要更多的反复试验。 网格中的每张照片都应相互重叠。 事实证明，在纸上大致绘制一个网格以了解需要多少行很有用。 <br><br> 为了保持垂直节奏感，我决定照片应该以某种方式重叠。 我将此覆盖大小指定给一个变量，以便可以在整个页面中使用它，并在必要时进行更新（图4）。 <br><br><img src="https://habrastorage.org/webt/ls/ce/jo/lscejocsqud3pchqqe9bv9a-vgk.png"><br>  <i>图4-垂直图像叠加</i> <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.grid</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">--verticalPadding</span></span>: <span class="hljs-number"><span class="hljs-number">2rem</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">--overlap</span></span>: <span class="hljs-number"><span class="hljs-number">6rem</span></span>; }</code> </pre><br> 每个图像还附带文字。 为此，上方和下方应有足够的空间，以使其与上一张照片不重叠。 这涉及在标题上方和下方添加网格线，这将充当“填充”。 现在，每个图像都应至少覆盖网格的四行-并且在顶部和底部重叠的图像应占据五行。 <br><br><img src="https://habrastorage.org/webt/wz/pt/uu/wzptuu4gf6wimjmchtunumelxrw.png"><br>  <i>图5-执行“填充”角色的行，使您可以在文本块的末尾与下一个图像的开始之间保持最小间隔。</i> <br><br> 但是我们还没有完成网格的设计：我决定为图像设置一个固定的宽高比。 有些照片将是人像，而另一些将是风景。 我希望网格布局能够正常工作，而不管照片的长宽比或文本的长度如何，因此要求网格线必须能够适应。 <br><br> 我们可以使用minmax（）函数使这些轨道更灵活，而不是对用作覆盖或填充的字符串使用固定值。 这将提供以下情况：线迹将具有最小大小，但是如果需要，线迹会扩大。 <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--padding</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>));</code> </pre><br><h2> 元素放置 </h2><br> 现在我们有了网格的骨架，是时候处理元素的放置了。 有时很难理解和选择将它们放置在任何结构的网格中的最佳方法。 我们有许多不同的选择：行号，span关键字，命名的行或区域-在某些情况下，其中一些效果更好。 但是，没有正确或错误的选择，而且往往归结为寻找最适合您的方法。 <br><br> 只要一切都能正常进行，就不会有错误的方法 <br><br><h3> 使用网格线放置 </h3><br> 我通常从使用开始和结束值放置元素开始-通常是第一行和最后一行的数字，但是如果我知道元素应覆盖的确切轨道数，我将使用span关键字。 有时，我为网格线命名以添加重要的地标（例如<code>wrapper-start</code>和<code>wrapper-end</code> ），但是我很少为网格线命名或直接为网格中的每个元素创建网格区域。 一种对我有很大帮助的策略是在要将元素放置到网格末尾的情况下指定负网格线。 我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">另一篇文章中</a>写了这个。 我经常在列轴上使用负网格线，因为在大多数情况下（对于我使用的网格），列数是已知的并且是固定的。 <br><br> 通过<code>grid-column</code>属性定位的值为1 / -1的元素将覆盖网格的所有列，从第一列到最后一列： <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.item</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> / -<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br> 我更倾向于在网格具有大量轨迹的情况下命名网格线。 在所考虑的情况下，我们只有10个列轨道，因此在我看来，按行号放置元素似乎更便于进一步操作。 <br><br> 使用正负网格线和“ span”值的混合，只需将元素沿列的轴放置即可。 在Firefox开发人员面板中打开网格检查器对此很有帮助，因为它使我们能够看到行号。 <br><br><h3> 使用网格区域放置 </h3><br> 如果我们看一下网格。 我们可以看到我们有很多行。 <br><br><img src="https://habrastorage.org/webt/nb/tq/lo/nbtqlo8iuqfsibrgjm0dhx1v8sq.jpeg"><br>  <i>图7-开发人员面板中Firefox网格检查器的屏幕截图，显示了网格的列和行</i> <br><br> 尽管我开始在行轴上按行号放置元素，但很快变得难以控制。 这些元素应该重叠，在我看来，很难追踪一个元素应该结束而另一元素开始的轨迹。 另外，我不想使用负网格线，因为将来有可能我想补充布局。 如果最终向网格中添加了更多的显式行，则负行号将不再有效，可能会导致许多布局错误。 <br><br> 这是我决定在行轴上创建命名网格区域的时候。 网格区域以两种方式创建： <br><br><ol><li> 使用<code>grid-template-areas</code>属性，可让您有效地“绘制”网格布局为ascii图 </li><li> 使用命名的网格线，使用<code>-start</code>和<code>-end</code>作为行名的后缀 </li></ol><br>  <code>grid-template-areas</code>属性不允许我们定义重叠元素的区域，因此对于这种特殊布局并不能真正帮助我们。 但是，使用命名的网格区域无疑会使任务更加容易。 <br><br> 如果我们为行轴和列轴都命名线，则将得到一个网格区域（图8）。 <br><br><img src="https://habrastorage.org/webt/5z/1h/l8/5z1hl8xujhb6tjyljy-otd6tu9i.png"><br>  <i>图8-具有<code>-start</code>和<code>-end</code>的行名后缀创建一个网格区域</i> <br><br> 然后，当我们使用<code>grid-area</code>属性放置元素时，可以引用该区域： <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.item</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-area</span></span>: image; }</code> </pre><br> 与使用grid-column和grid-row属性并列出行名称相比，这使我们的代码更加简洁和可读： <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.item</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: image-start / image-end; <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: image-start / image-end; }</code> </pre><br> 但是在这种情况下，我们只需要在行轴上命名一个网格区域。 这是正常现象，因为我们可以使用grid-row属性引用它： <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.item</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: image; }</code> </pre><br> 由于我们有很多行，所以在我看来，垂直编写<code>grid-template-rows</code>属性要容易得多，以便它反映页面的结构： <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-rows</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span> 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">rem</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--overlap</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--overlap</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>);</code> </pre><br> 现在，将行名添加到正确的位置变得更加简单，因为我们可以可视化网格结构： <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">grid-template-rows</span></span>: <span class="hljs-selector-attr"><span class="hljs-selector-attr">[header-start]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[fig1-start]</span></span> 3<span class="hljs-selector-tag"><span class="hljs-selector-tag">rem</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[header-end]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[p1-start]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[p1-end]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[fig2-start]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--overlap</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[fig1-end]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[p2-start]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[p2-end]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[fig3-start]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--overlap</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[fig2-end]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[p3-start]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[p3-end]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">minmax</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">var</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">--verticalPadding</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">auto</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[fig3-end]</span></span>;</code> </pre><br> 剩下的只是在放置网格元素时引用行轴上区域的名称： <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.fig--1</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: span <span class="hljs-number"><span class="hljs-number">5</span></span> / -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: fig1; } <span class="hljs-selector-class"><span class="hljs-selector-class">.fig--2</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> / span <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: fig2; } <span class="hljs-selector-class"><span class="hljs-selector-class">.fig--3</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">grid-column</span></span>: span <span class="hljs-number"><span class="hljs-number">5</span></span> / -<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">grid-row</span></span>: fig3; }</code> </pre><br> 最终结果（图10）可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Codepen</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">查看</a> <br><br><img src="https://habrastorage.org/webt/yn/bf/0z/ynbf0z6bbqh5fwpwdltfdbdi-da.jpeg"><br>  <i>图10</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://codepen.io/michellebarker/embed/preview/gOYqmJQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 尽管我没有做出任何额外的努力来使此布局响应，但它可以在比平板电脑小的屏幕上使用。 为小屏幕调整布局不是很难。 就个人而言，我会为这种情况选择一个更简单的网格，因为许多视觉功能仍然会丢失。 但是话又说回来，这没有对与错。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN472496/">https://habr.com/ru/post/zh-CN472496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN472484/index.html">封闭Kubernetes集群中的漏洞。 使用DevOpsConf报告和成绩单</a></li>
<li><a href="../zh-CN472486/index.html">长期数据存储。 （文章-讨论）</a></li>
<li><a href="../zh-CN472488/index.html">DevOops 2019的三十份报告：Tim Lister，Hadi Hariri，Roman Shaposhnik和其他国际DevOps明星</a></li>
<li><a href="../zh-CN472490/index.html">我如何使用自然语言处理搜索美容标准（但没有找到）</a></li>
<li><a href="../zh-CN472492/index.html">分析根代码，科学数据分析框架</a></li>
<li><a href="../zh-CN472502/index.html">SOC是人：监控和响应网络攻击的中心服务经理的恶劣生活</a></li>
<li><a href="../zh-CN472504/index.html">PHP微服务框架Swoft：使用数据库第1部分</a></li>
<li><a href="../zh-CN472508/index.html">闪存可靠性：预期和意外。 第3部分。USENIX协会的XIV会议。 文件存储技术</a></li>
<li><a href="../zh-CN472514/index.html">从找到想法到完成的应用程序</a></li>
<li><a href="../zh-CN472516/index.html">适用于Python + GTK3的Linux的Yandex.Translator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>