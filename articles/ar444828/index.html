<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍀 🐠 🍢 شرح بسيط لخوارزميات العثور على المسار و A * 👨🏾‍🍳 🚉 💆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="الجزء 1. خوارزمية البحث العامة 
 مقدمة 
 يعد العثور على المسار أحد الموضوعات التي عادة ما تكون الأكثر صعوبة لمطوري الألعاب. الفقراء على وجه الخصوص يفه...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>شرح بسيط لخوارزميات العثور على المسار و A *</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444828/" style=";text-align:right;direction:rtl"><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif" alt="صورة"></div><br><h2 style=";text-align:right;direction:rtl">  الجزء 1. خوارزمية البحث العامة </h2><br><h2 style=";text-align:right;direction:rtl">  مقدمة </h2><br>  يعد العثور على المسار أحد الموضوعات التي عادة ما تكون الأكثر صعوبة لمطوري الألعاب.  الفقراء على وجه الخصوص يفهمون خوارزمية <strong>A *</strong> ، ويعتقد الكثيرون أن هذا نوع من السحر غير المفهوم. <br><br>  الغرض من هذه المقالة هو شرح البحث عن المسار بشكل عام و <strong>A *</strong> بشكل خاص بطريقة مفهومة للغاية ويمكن الوصول إليها ، وبالتالي وضع حد للاعتقاد الخاطئ السائد بأن هذا الموضوع معقد.  مع التفسير الصحيح ، كل شيء بسيط للغاية. <br><br>  يرجى ملاحظة أننا سننظر في المقال في البحث عن وسيلة <em>للألعاب</em> ؛  بخلاف المزيد من المقالات الأكاديمية ، فإننا نتجاهل خوارزميات البحث مثل Depth-First أو Breadth-First.  بدلاً من ذلك ، سنحاول الانتقال من الصفر إلى <strong>A * في</strong> أسرع وقت ممكن. <br><a name="habracut"></a><br>  في الجزء الأول ، سنشرح أبسط مفاهيم العثور على المسار.  من خلال فهم هذه المفاهيم الأساسية ، ستدرك أن <strong>A *</strong> واضحة بشكل مدهش. <br><br><h2 style=";text-align:right;direction:rtl">  دائرة بسيطة </h2><br>  على الرغم من أنه يمكنك تطبيق هذه المفاهيم على بيئات 3D المعقدة التعسفية ، دعنا نبدأ بمخطط بسيط للغاية: شبكة بحجم 5 × 5. للراحة ، قمت بتمييز كل خلية بحرف كبير. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/e2d/66c/ed8/e2d66ced82a4c1d4ed739583bd782245.png"></div><br>  <i>شبكة بسيطة.</i> <br><br>  أول شيء سنفعله هو تخيل هذه البيئة على أنها رسم بياني.  لن أشرح بالتفصيل ماهية الرسم البياني ؛  ببساطة ، هذه مجموعة من الدوائر متصلة بالسهام.  تسمى الدوائر <em>"عقدة"</em> ، <em>وتسمى</em> الأسهم <em>"الحواف"</em> . <br><br>  تمثل كل عقدة <em>"حالة"</em> قد تكون فيها الشخصية.  في حالتنا ، حالة الشخصية هي موضعه ، لذلك نقوم بإنشاء عقدة واحدة لكل خلية شبكة: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/68a/d4b/4db/68ad4b4db470c1ce34434e6489a5a986.png"></div><br>  <i>العقد التي تمثل خلايا الشبكة.</i> <br><br>  الآن إضافة الأضلاع.  وهي تشير إلى الحالات التي يمكن <em>"الوصول إليها"</em> من كل ولاية معينة ؛  في حالتنا ، يمكننا الانتقال من أي خلية إلى الخلية التالية ، باستثناء الخلايا المحظورة: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/f73/56c/9be/f7356c9be0171d61c31e3e4c21bf9385.png"></div><br>  <i>تشير الأقواس إلى الحركات المسموح بها بين خلايا الشبكة.</i> <br><br>  إذا استطعنا الانتقال من <strong>A</strong> إلى <strong>B</strong> ، فإننا نقول أن <strong>B</strong> هي <em>"جار"</em> للعقدة <strong>A.</strong> <br><br>  تجدر الإشارة إلى أن الأضلاع لها <em>اتجاه</em> ؛  نحتاج إلى حواف من <strong>A</strong> إلى <strong>B</strong> ومن <strong>B</strong> إلى <strong>A.</strong>  قد يبدو هذا غير ضروري ، ولكن ليس عندما تنشأ "شروط" أكثر تعقيدًا.  على سبيل المثال ، قد تسقط الشخصية من السقف إلى الأرض ، ولكنها غير قادرة على القفز من الأرض إلى السقف.  يمكنك الانتقال من حالة "الأحياء" إلى حالة "الموتى" ، ولكن ليس العكس.  و هكذا. <br><br><h2 style=";text-align:right;direction:rtl">  مثال </h2><br>  لنفترض أننا نريد الانتقال من <strong>A</strong> إلى <strong>T.</strong>  نبدأ بـ <strong>A.</strong>  يمكنك القيام بعملين بالضبط: اذهب إلى <strong>B</strong> أو اذهب إلى <strong>F.</strong> <br><br>  دعنا نقول انتقلنا إلى <strong>B.</strong>  الآن يمكننا أن نفعل شيئين: العودة إلى <strong>A</strong> أو الذهاب إلى <strong>C.</strong>  نتذكر أننا كنا بالفعل في <strong>A</strong> ونظرنا في الخيارات هناك ، لذلك ليس من المنطقي أن نفعل ذلك مرة أخرى (وإلا فبإمكاننا قضاء يوم كامل في نقل <strong>A</strong> → <strong>B</strong> → <strong>A</strong> → <strong>B</strong> ...).  لذلك سوف نذهب إلى <strong>C.</strong> <br><br>  يجري في <strong>C</strong> ، ليس لدينا مكان للتحرك.  إن العودة إلى " <strong>ب"</strong> لا معنى لها ، أي أنها طريق مسدود.  كان اختيار الانتقال إلى <strong>B</strong> عندما كنا في <strong>A</strong> فكرة سيئة ؛  ربما يجب أن تجرب <strong>F</strong> بدلاً من ذلك؟ <br><br>  نستمر في تكرار هذه العملية حتى ننتهي في <strong>T.</strong>  في هذه اللحظة ، نقوم ببساطة بإعادة إنشاء المسار من <strong>A</strong> ، والعودة في خطواتنا.  نحن في <strong>تي</strong> .  كيف وصلنا إلى هناك؟  من <strong>س</strong> ؟  أي أن نهاية المسار لها شكل <strong>O</strong> → <strong>T.</strong>  كيف وصلنا إلى <strong>يا</strong> ؟  و هكذا. <br><br>  ضع في اعتبارك أننا لا <em>نتحرك</em> حقًا ؛  كل هذا كان مجرد عملية فكرية.  نستمر في الوقوف في <strong>A</strong> ، ولن نخرج منه حتى نعثر على المسار بالكامل.  عندما أقول "انتقل إلى <strong>B</strong> " ، أعني "تخيل أننا انتقلنا إلى <strong>B</strong> ". <br><br><h2 style=";text-align:right;direction:rtl">  الخوارزمية العامة </h2><br>  <strong>هذا القسم هو الجزء الأكثر أهمية في المقال بأكمله</strong> .  <em>يجب أن</em> تفهمها تمامًا حتى تتمكن من تحقيق البحث عن الطريق ؛  الباقي (بما في ذلك <strong>A *</strong> ) هي مجرد تفاصيل.  في هذا القسم ، سوف تفهم حتى <em>تفهم المعنى</em> . <br><br>  بالإضافة إلى ذلك ، هذا القسم بسيط للغاية. <br><br>  دعونا نحاول إضفاء الطابع الرسمي على مثالنا ، وتحويله إلى رمز زائف. <br><br>  نحن بحاجة إلى تتبع العقد التي نعرف كيفية الوصول إليها من عقدة البداية.  في البداية ، هذه ليست سوى عقدة البداية ، ولكن في عملية "استكشاف" الشبكة ، سوف نتعلم كيفية الوصول إلى العقد الأخرى.  دعنا ندعو إلى قائمة العقد هذه <code>reachable</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">reachable = [start_node]</code> </pre> <br>  نحتاج أيضًا إلى تتبع العقد التي تم استعراضها بالفعل حتى لا نراها مرة أخرى.  <code>explored</code> ندعو لهم <code>explored</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">explored = []</code> </pre> <br>  <strong>بعد ذلك ، سأحدد جوهر الخوارزمية</strong> : في كل خطوة من خطوات البحث ، نختار إحدى العقد التي نعرف كيفية الوصول إلى العقد الجديدة التي يمكننا الحصول عليها وإلقاء نظرة عليها.  إذا حددنا كيفية الوصول إلى العقدة النهائية (الهدف) ، فسيتم حل المشكلة!  خلاف ذلك ، نواصل البحث. <br><br>  في غاية البساطة ، ما حتى الإحباط؟  وهذا صحيح.  ولكن هذه هي الخوارزمية بأكملها.  دعنا نكتبها خطوة بخطوة باستخدام الكود الزائف. <br><br>  نستمر في البحث حتى نصل إلى العقدة النهائية (في هذه الحالة ، نجد المسار من العقدة الأولى إلى العقدة الأخيرة) ، أو حتى نفد العقد التي يمكنك البحث فيها (في هذه الحالة ، لا توجد وسيلة بين العقد البداية والنهاية) . <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty:</code> </pre> <br>  نختار إحدى العقد التي نعرف كيف نحصل عليها ، والتي لم يتم التحقيق فيها بعد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"> node = choose_node(reachable)</code> </pre> <br>  إذا تعلمنا للتو كيفية الوصول إلى العقدة النهائية ، فإن المهمة تكون كاملة!  نحتاج فقط إلى بناء المسار باتباع الروابط <code>previous</code> مرة أخرى إلى عقدة البداية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == goal_node: path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(node) node = node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  لا معنى لفحص العقدة أكثر من مرة ، لذلك سنتعقب هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"> reachable.remove(node) explored.add(node)</code> </pre> <br>  نحدد العقد التي لا يمكننا الوصول إليها من هنا.  نبدأ بقائمة العقد المجاورة للعقد الحالي ونحذف العقد التي درسناها بالفعل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"> new_reachable = get_adjacent_nodes(node) - explored</code> </pre> <br>  نأخذ كل واحد منهم: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_reachable:</code> </pre> <br>  إذا كنا نعرف بالفعل كيفية الوصول إلى العقدة ، فتجاهلها.  بخلاف ذلك ، أضفه إلى القائمة <code>reachable</code> ، وتتبع كيف حصلت عليها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  العثور على عقدة النهاية هي طريقة واحدة للخروج من الحلقة.  والثاني هو عندما تصبح <code>reachable</code> : لقد نفدنا العقد التي يمكن استكشافها ، ولم نصل إلى العقدة النهائية ، أي أنه لا توجد طريقة من العقدة الأولية إلى العقدة الأخيرة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  و ... هذا كل شيء.  هذه هي الخوارزمية بأكملها ، ويتم تخصيص رمز إنشاء المسار بطريقة منفصلة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: if adjacent not in reachable adjacent.previous = node # Remember how we got there. reachable.add(adjacent) # If we get here, no path was found :( return None</span></span></code> </pre> <br>  فيما يلي الوظيفة التي تنشئ المسار ، تتبع الروابط <code>previous</code> مرة أخرى إلى عقدة البداية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  هذا كل شيء.  <em>هذا هو</em> الكود الكاذب <em>لكل</em> خوارزمية البحث عن المسار ، بما في ذلك <strong>A *</strong> . <br><br>  أعد قراءة هذا القسم حتى تفهم كيف يعمل كل شيء ، والأهم من ذلك ، <em>لماذا</em> يعمل كل شيء.  سيكون من المثالي رسم مثال باليد على الورق ، ولكن يمكنك أيضًا مشاهدة عرض توضيحي تفاعلي: <br><br><h2 style=";text-align:right;direction:rtl">  عرض تفاعلي </h2><br>  فيما يلي عرض توضيحي ومثال على تنفيذ الخوارزمية الموضحة أعلاه (يمكنك تشغيله على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">صفحة المقالة الأصلية</a> ).  <code>choose_node</code> فقط يختار عقدة عشوائية.  يمكنك بدء الخوارزمية خطوة بخطوة وإلقاء نظرة على قائمة <code>explored</code> <code>reachable</code> <code>explored</code> ، وكذلك المكان الذي تشير إليه الروابط <code>previous</code> . <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/vt/jk/cb/vtjkcb4tflduq7zu5p-oph2i73s.gif"></div><br>  لاحظ أن البحث ينتهي بمجرد اكتشاف المسار ؛  قد يحدث أن بعض العقد لا تعتبر حتى. <br><br><h2 style=";text-align:right;direction:rtl">  استنتاج </h2><br>  الخوارزمية المقدمة هنا هي خوارزمية عامة <em>لأي</em> خوارزمية البحث عن مسار. <br><br>  ولكن ما الذي يميز كل خوارزمية عن أخرى ، لماذا <strong>A *</strong> هي <strong>A *</strong> ؟ <br><br>  إليك نصيحة: إذا قمت بإجراء البحث في العرض التوضيحي عدة مرات ، فسترى أن الخوارزمية لا تجد دائمًا نفس المسار دائمًا.  يجد طريقًا ، وهذا المسار ليس بالضرورة <em>الأقصر</em> .  لماذا؟ <br><br><h2 style=";text-align:right;direction:rtl">  الجزء 2. استراتيجيات البحث </h2><br>  إذا لم تفهم الخوارزمية الموضحة في القسم السابق تمامًا ، فارجع إليها وقراءتها مرة أخرى ، لأنه ضروري لفهم مزيد من المعلومات.  عندما تكتشف ذلك ، ستظهر <strong>A *</strong> بشكل طبيعي ومنطقي تمامًا. <br><br><h2 style=";text-align:right;direction:rtl">  العنصر السري </h2><br>  في نهاية الجزء السابق ، تركت سؤالين مفتوحين: إذا كانت كل خوارزمية بحث تستخدم نفس الكود ، فلماذا تتصرف <strong>A *</strong> مثل <strong>A *</strong> ؟  ولماذا تجد التجريبي في بعض الأحيان مسارات مختلفة؟ <br><br>  ترتبط الإجابات على كلا السؤالين ببعضهما البعض.  على الرغم من أن الخوارزمية محددة جيدًا ، إلا أنني تركت جانبًا واحدًا دون حل ، وكما اتضح ، فهو المفتاح لشرح سلوك خوارزميات البحث: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">node = choose_node(reachable)</code> </pre> <br>  هذه السلسلة ذات المظهر البريء هي التي تميز كل خوارزميات البحث عن بعضها البعض.  <code>choose_node</code> يعتمد على طريقة تنفيذ <code>choose_node</code> . <br><br>  فلماذا يجد التجريبي مسارات مختلفة؟  لأن طريقة <code>choose_node</code> الخاصة <code>choose_node</code> تختار عقدة بشكل عشوائي. <br><br><h2 style=";text-align:right;direction:rtl">  طول المسائل </h2><br>  قبل الغوص في الاختلافات في سلوك وظيفة <code>choose_node</code> ، نحتاج إلى إصلاح رقابة صغيرة في الخوارزمية الموضحة أعلاه. <br><br>  عندما نظرنا في العقد المجاورة للتيار ، تجاهلنا تلك التي تعرف بالفعل كيفية تحقيقها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  هذا خطأ: ماذا لو اكتشفنا للتو <em>أفضل</em> طريقة للوصول إليه؟  في هذه الحالة ، من الضروري تغيير ارتباط العقدة <code>previous</code> لعكس هذا المسار الأقصر. <br><br>  للقيام بذلك ، نحتاج إلى معرفة طول المسار من عقدة البداية إلى أي عقدة قابلة للوصول.  سوف نسمي هذا تكلفة المسار.  في الوقت الحالي ، نفترض أن الانتقال من عقدة إلى إحدى العقد المجاورة له تكلفة ثابتة تبلغ <code>1</code> . <br><br>  قبل البدء في البحث ، نقوم بتعيين قيمة <code>cost</code> كل عقدة إلى <code>infinity</code> .  بفضل هذا ، فإن <em>أي</em> مسار سيكون أقصر من هذا.  سنقوم أيضًا بتعيين <code>cost</code> عقدة <code>start_node</code> على <code>0</code> . <br><br>  ثم هكذا سيبدو الرمز: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: reachable.add(adjacent) <span class="hljs-comment"><span class="hljs-comment"># If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1</span></span></code> </pre> <br><h2 style=";text-align:right;direction:rtl">  نفس تكلفة البحث </h2><br>  دعنا الآن نلقي نظرة على طريقة <code>choose_node</code> .  إذا سعينا جاهدين لإيجاد أقصر مسار ممكن ، فإن اختيار العقدة عشوائياً ليس فكرة جيدة. <br><br>  من الأفضل اختيار عقدة يمكننا الوصول إليها من العقدة الأولية على طول أقصر الطرق ؛  بفضل هذا ، نحن نفضل عمومًا الطرق الأقصر على المسارات الأطول.  هذا لا يعني أنه لن يتم النظر في المسارات الأطول على الإطلاق ، بل يعني أن المسارات الأقصر سيتم النظر فيها أولاً.  نظرًا لأن الخوارزمية تنتهي فور العثور على مسار مناسب ، فإن هذا سيسمح لنا بالعثور على مسارات قصيرة. <br><br>  فيما يلي مثال ممكن على وظيفة <code>choose_node</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">function choose_node (reachable): best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> best_node == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> best_node.cost &gt; node.cost: best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  بشكل حدسي ، يتوسع البحث عن هذه الخوارزمية "شعاعيًا" من عقدة البدء حتى تصل إلى عقدة النهاية.  إليك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">عرض توضيحي تفاعلي</a> لهذا السلوك: <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/nh/fn/jd/nhfnjd_ztdx3fbuqy5v5_am5hxw.gif"></div><br><h2 style=";text-align:right;direction:rtl">  استنتاج </h2><br>  سمح لنا تغيير بسيط في طريقة اختيار العقدة التي تم النظر فيها فيما يلي بالحصول على خوارزمية جيدة إلى حد ما: حيث تجد أقصر مسار من البداية إلى النهاية. <br><br>  ولكن هذه الخوارزمية ، إلى حد ما ، لا تزال "غبية".  يواصل البحث في كل مكان حتى يتعثر على عقدة طرفية.  على سبيل المثال ، ما هي النقطة في المثال الموضح أعلاه للبحث في الاتجاه <strong>A</strong> ، إذا كان من الواضح أننا <em>نتحرك</em> بعيدًا عن عقدة النهاية؟ <br><br>  هل من الممكن جعل <code>choose_node</code> أكثر ذكاءً؟  هل يمكننا أن نجعله <em>يوجه البحث باتجاه العقدة النهائية</em> ، حتى دون معرفة المسار الصحيح مقدمًا؟ <br><br>  اتضح أننا نستطيع - في الجزء التالي ، أن نصل في النهاية إلى <code>choose_node</code> ، مما يسمح لنا بتحويل خوارزمية البحث عن المسار العام إلى <strong>A *</strong> . <br><br><h2 style=";text-align:right;direction:rtl">  الجزء 3. إزالة حجاب السرية من A * </h2><br>  الخوارزمية التي تم الحصول عليها في الجزء السابق جيدة جدًا: حيث تجد أقصر مسار من عقدة البداية إلى النهاية الأخيرة.  ومع ذلك ، فهو يهدر طاقته: فهو يفكر في الطرق التي يصفها الشخص بوضوح بأنها خاطئة - وعادة ما <em>يتحرك بعيدًا</em> عن الهدف.  كيف يمكن تجنب ذلك؟ <br><br><h2 style=";text-align:right;direction:rtl">  خوارزمية السحر </h2><br>  تخيل أننا نقوم بتشغيل خوارزمية بحث على جهاز كمبيوتر خاص مع شريحة يمكن أن تفعل <em>السحر</em> .  بفضل هذه الشريحة المذهلة ، يمكننا التعبير عن <code>choose_node</code> بطريقة بسيطة للغاية ، وهي مضمونة لإنشاء أقصر طريق دون إضاعة الوقت في استكشاف المسارات الجزئية التي لا تؤدي إلى أي مكان: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">function choose_node (reachable): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> magic(reachable, <span class="hljs-string"><span class="hljs-string">" ,     "</span></span>)</code> </pre> <br>  يبدو مغريا ، ولكن لا تزال تحتاج رقائق سحرية نوعا من رمز المستوى المنخفض.  هنا تقريب جيد: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = magic(node, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  هذه طريقة رائعة لتحديد العقدة التالية: يمكنك تحديد العقدة التي تعطينا أقصر مسار من البداية إلى النهاية ، وهو ما نحتاجه. <br><br>  لقد <code>node.cost</code> أيضًا مقدار السحر المستخدم: نحن نعرف بالضبط تكلفة الانتقال من عقدة البداية إلى كل عقدة (هذا هو <code>node.cost</code> ) ، ونحن نستخدم السحر فقط للتنبؤ بتكلفة الانتقال من العقدة إلى العقدة النهائية. <br><br><h2 style=";text-align:right;direction:rtl">  ليست سحرية ، ولكن رهيبة جدا A * </h2><br>  لسوء الحظ ، فإن الرقائق السحرية جديدة ، ونحن بحاجة إلى دعم من المعدات القديمة.  معظم الكود يناسبنا ، باستثناء هذا السطر: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Throws MuggleProcessorException cost_node_to_goal = magic(node, "   ")</span></span></code> </pre> <br>  وهذا يعني أننا لا نستطيع استخدام السحر لمعرفة تكلفة مسار غير مستكشفة.  حسنًا ، دعنا نتنبأ.  سنكون متفائلين ونفترض أنه لا يوجد شيء بين العقد الحالية والنهائية ، ويمكننا ببساطة التحرك مباشرة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">cost_node_to_goal = distance(node, goal_node)</code> </pre> <br>  لاحظ أن <em>أقصر المسار</em> <em>والحد الأدنى للمسافة</em> مختلفان: يعني الحد الأدنى للمسافة أنه لا توجد أية عوائق بين العقد الحالية والأخيرة. <br><br>  هذا التقدير بسيط للغاية للحصول عليه.  في أمثلة شبكتنا ، هذه هي <em>المسافة</em> بين <em>كتل المدينة</em> بين العقدتين (أي <code>abs(Ax - Bx) + abs(Ay - By)</code> ).  إذا استطعنا التحرك قطريًا ، فستكون القيمة مساوية لـ <code>sqrt( (Ax - Bx)^2 + (Ay - By)^2 )</code> ، وهكذا.  الأهم من ذلك ، أننا لا نحصل على تقدير كبير للقيمة. <br><br>  إذن هنا إصدار غير <code>choose_node</code> من <code>choose_node</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  تسمى الوظيفة التي تقدر المسافة من الحالية إلى العقدة النهائية بأنها <em>مجريات</em> البحث ، وتسمى خوارزمية البحث هذه ، أيها السيدات والسادة ، ... <strong>A *</strong> . <br><br><h2 style=";text-align:right;direction:rtl">  عرض تفاعلي </h2><br>  بينما أنت تتعافى من الصدمة الناجمة عن إدراك أن <strong>A *</strong> الغامض <em>بسيط للغاية</em> بالفعل ، يمكنك إلقاء نظرة على العرض التوضيحي (أو تشغيله في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المقالة الأصلية</a> ).  ستلاحظ ، على عكس المثال السابق ، أن البحث يقضي وقتًا قصيرًا جدًا في التحرك في الاتجاه الخاطئ. <br><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif"></div><br><h2 style=";text-align:right;direction:rtl">  استنتاج </h2><br>  أخيرًا ، وصلنا إلى خوارزمية <strong>A *</strong> ، وهي ليست أكثر من خوارزمية البحث العامة الموضحة في الجزء الأول من المقالة مع بعض التحسينات الموضحة في الجزء الثاني وباستخدام دالة <code>choose_node</code> ، التي تحدد العقدة التي تقربنا من عقدة النهاية.  هذا كل شيء. <br><br>  فيما يلي رمز زائف كامل للطريقة الرئيسية للرجوع اليها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here that we haven't explored before? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: # First time we see this node? if adjacent not in reachable: reachable.add(adjacent) # If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1 # If we get here, no path was found :( return None</span></span></code> </pre> <br>  طريقة <code>build_path</code> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  <code>choose_node</code> طريقة <code>choose_node</code> ، والتي تحولها إلى <strong>A *</strong> : <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  هذا كل شيء. <br><br>  ولكن لماذا نحتاج <strong>الجزء 4</strong> ؟ <br><br>  الآن بعد أن أدركت كيف تعمل <strong>A *</strong> ، أريد أن أتحدث عن بعض المناطق المدهشة في تطبيقه ، والتي هي بعيدة كل البعد عن البحث عن مسارات في شبكة من الخلايا. <br><br><h2 style=";text-align:right;direction:rtl">  الجزء 4. أ * في الممارسة </h2><br>  تبدأ الأجزاء الثلاثة الأولى من المقالة بالأسس الأساسية لخوارزميات البحث عن المسار وتنتهي بوصف واضح لخوارزمية <strong>A *</strong> .  كل هذا رائع من الناحية النظرية ، لكن فهم كيفية تطبيقه في الممارسة هو موضوع مختلف تمامًا. <br><br>  على سبيل المثال ، ماذا يحدث إذا كان عالمنا ليس شبكة؟ <br><br>  ماذا لو كانت شخصية لا يمكن أن تدور على الفور 90 درجة؟ <br><br>  كيفية بناء الرسم البياني إذا كان العالم لا نهاية لها؟ <br><br>  ماذا لو كنا لا نهتم بطول المسار ، لكننا نعتمد على الطاقة الشمسية وعلينا أن نكون تحت أشعة الشمس قدر الإمكان؟ <br><br>  كيفية العثور على أقصر طريق إلى أي من العقدتين النهاية؟ <br><br><h2 style=";text-align:right;direction:rtl">  وظيفة التكلفة </h2><br>  في الأمثلة الأولى ، بحثنا عن أقصر الطرق بين العقد البداية والنهاية.  ومع ذلك ، بدلاً من تخزين أطوال المسار الجزئي في <code>length</code> المتغير ، أطلقنا عليه <code>cost</code> .  لماذا؟ <br><br>  يمكننا أن نجعل <strong>A *</strong> لا تبحث فقط عن <em>أقصر</em> ، ولكن أيضًا عن <em>أفضل</em> مسار ، ويمكن اختيار تعريف "best" استنادًا إلى أهدافنا.  عندما نحتاج إلى أقصر مسار ، تكون التكلفة هي طول المسار ، ولكن إذا كنا نريد تقليل ، على سبيل المثال ، استهلاك الوقود ، فإننا نحتاج إلى استخدامه كتكلفة.  إذا كنا نريد زيادة "الوقت الذي تقضيه تحت أشعة الشمس" ، فإن التكلفة هي الوقت الذي تقضيه بدون الشمس.  و هكذا. <br><br>  في الحالة العامة ، هذا يعني أن التكاليف المقابلة ترتبط بكل حافة من الرسم البياني.  في الأمثلة الموضحة أعلاه ، تم تعيين القيمة ضمنيًا وكانت تعتبر دائمًا تساوي <code>1</code> ، لأننا عدنا الخطوات على طول الطريق.  لكن يمكننا تغيير تكلفة الضلع وفقًا لما نريد تقليله. <br><br><h2 style=";text-align:right;direction:rtl">  وظيفة المعيار </h2><br>  دعنا نقول أن هدفنا هو سيارة ، وهو بحاجة للوصول إلى محطة الوقود.  أي التزود بالوقود سوف تناسبنا.  يستغرق أقصر طريق إلى أقرب محطة وقود. <br><br>  سيكون النهج الساذج هو حساب أقصر طريق لكل عملية تزود بالوقود بدوره وتحديد أقصرها.  هذا سوف ينجح ، لكنها ستكون عملية مكلفة للغاية. <br><br>  ماذا لو استطعنا استبدال أحد <code>goal_node</code> بأسلوب ، على عقدة معينة ، يمكنه معرفة ما إذا كانت محدودة أم لا.  بفضل هذا ، يمكننا البحث عن عدة أهداف في نفس الوقت.  نحتاج أيضًا إلى تعديل الاستدلال بحيث تعيد التكلفة المقدرة الدنيا لجميع العقد النهائية الممكنة. <br><br>  اعتمادًا على تفاصيل الموقف ، قد لا نتمكن من تحقيق الهدف <em>بشكل مثالي</em> ، أو <code>is_goal_node</code> الكثير (إذا أرسلنا الحرف من خلال نصف خريطة ضخمة ، فهل الفرق بوصة واحدة مهمة؟) ، لذلك يمكن أن تعود طريقة <code>is_goal_node</code> إلى <code>is_goal_node</code> عندما نتمكن من نحن "قريبون بما فيه الكفاية". <br><br><h2 style=";text-align:right;direction:rtl">  اليقين الكامل غير مطلوب. </h2><br>  قد لا يكون تمثيل العالم كشبكة منفصلة كافياً للعديد من الألعاب.  خذ على سبيل المثال مطلق النار أو لعبة السباق من الشخص الأول.  العالم منفصل ، لكن لا يمكن تمثيله كشبكة. <br><br>  ولكن هناك مشكلة أكثر خطورة: ماذا لو كان العالم لا نهاية له؟  في هذه الحالة ، حتى لو تمكنا من تقديمها في شكل شبكة ، فلن نتمكن ببساطة من بناء رسم بياني يتوافق مع الشبكة ، لأنه يجب أن يكون غير محدود. <br><br>  ومع ذلك ، لا تضيع كل شيء.  بالطبع ، بالنسبة لخوارزمية البحث عن الرسم البياني ، نحتاج بالتأكيد إلى رسم بياني.  لكن لا أحد قال إن الرسم البياني يجب أن يكون <em>شاملاً</em> ! <br><br>  إذا نظرت عن كثب إلى الخوارزمية ، ستلاحظ أننا لا نفعل أي شيء مع الرسم البياني ككل ؛  نحن نفحص الرسم البياني محليًا ، ونحصل على العقد التي يمكننا الوصول إليها من العقدة المعنية.  كما يتضح من العرض التوضيحي <strong>A *</strong> ، فإن بعض العقد من الرسم البياني لا يتم التحقيق فيها على الإطلاق. <br><br>  فلماذا لا نبني الرسم البياني في عملية البحث؟ <br><br>  نجعل الموضع الحالي للشخصية هو نقطة الانطلاق.  عند استدعاء <code>get_adjacent_nodes</code> يمكنه تحديد الطرق الممكنة التي يمكن للشخصية من خلالها الانتقال من عقدة معينة ، وإنشاء العقد المجاورة على الطاير. <br><br><h2 style=";text-align:right;direction:rtl">  وراء ثلاثة أبعاد </h2><br>  حتى لو كان <i>عالمك</i> عبارة عن شبكة ثنائية الأبعاد ، فهناك جوانب أخرى يجب مراعاتها.  على سبيل المثال ، ماذا لو لم تتمكن الشخصية من تدوير 90 أو 180 درجة على الفور ، كما هو الحال عادة؟ <br><br>  لا يجب أن تكون <em>الحالة</em> الممثلة بكل عقدة بحث مجرد <em>موقع</em> ؛  على العكس من ذلك ، قد يتضمن مجموعة من القيم المعقدة بشكل تعسفي.  على سبيل المثال ، إذا كانت المنعطفات بزاوية 90 درجة تستغرق وقتًا من الوقت الذي تستغرقه عملية الانتقال من خلية إلى أخرى ، فيمكن تعيين حالة الشخصية كـ <code>[position, heading]</code> .  لا يمكن أن تمثل كل عقدة موقف الشخصية فحسب ، بل يمكن أن تمثل أيضًا اتجاه نظرته ؛  والحواف الجديدة للرسم البياني (صريحة أو غير مباشرة) تعكس هذا. <br><br>  إذا عدت إلى شبكة 5 × 5 الأصلية ، يمكن الآن أن يكون موقع البحث الأولي هو <code>[A, East]</code> .  العقد المجاورة الآن هي <code>[B, East]</code> و <code>[A, South]</code> - إذا أردنا الوصول إلى <strong>F</strong> ، نحتاج أولاً إلى ضبط الاتجاه بحيث يأخذ المسار الشكل <code>[A, East]</code> ، <code>[A, South]</code> ، <code>[F, South]</code> . <br><br>  أول شخص مطلق النار؟  أربعة أبعاد على الأقل: <code>[X, Y, Z, Heading]</code> .  ربما حتى <code>[X, Y, Z, Heading, Health, Ammo]</code> . <br><br>  لاحظ أنه كلما كانت الحالة أكثر تعقيدًا ، كلما كانت الوظيفة الاستدلالية أكثر تعقيدًا.  <strong>* نفسه</strong> بسيط ؛  الفن غالبا ما ينشأ من الاستدلال الجيد. <br><br><h2 style=";text-align:right;direction:rtl">  استنتاج </h2><br>  الغرض من هذه المقالة هو تبديد الأسطورة مرة واحدة وإلى الأبد أن <strong>A *</strong> هي خوارزمية صوفية لا يمكن فك تشفيرها.  على العكس من ذلك ، لقد أظهرت أنه لا يوجد شيء غامض فيه ، وفي الواقع يمكن استنتاجه ببساطة من خلال البدء من نقطة الصفر. <br><br><h3 style=";text-align:right;direction:rtl">  مزيد من القراءة </h3><br>  يمتلك أميت باتيل <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"مقدمة لخوارزمية A *</a> ممتازة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">"</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الترجمة</a> على Habré] (ومقالاته الأخرى حول مواضيع مختلفة هي أيضًا ممتازة!). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar444828/">https://habr.com/ru/post/ar444828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar444816/index.html">DIY النجارة: التوقعات والواقع</a></li>
<li><a href="../ar444818/index.html">Citymobil - دليل للشركات الناشئة لزيادة الاستقرار وسط النمو. الجزء 1</a></li>
<li><a href="../ar444820/index.html">Mockdown: أسرع طريقة لإنشاء إطارات سلكية</a></li>
<li><a href="../ar444822/index.html">JDK 9 / JEP 280: سلسلة السلسلة لن تكون هي نفسها مرة أخرى</a></li>
<li><a href="../ar444824/index.html">ما الأمازون والروبوتات فيديكس ساعي تبدو الأولى</a></li>
<li><a href="../ar444830/index.html">سحابة التوقيع الإلكتروني في روسيا والعالم</a></li>
<li><a href="../ar444832/index.html">"لا عمليات نشر يوم الجمعة" وثلاثة قواعد تطوير غير معلن عنها</a></li>
<li><a href="../ar444836/index.html">لا حاجة للتفكير في الذاكرة ، قالوا ... ورشة عمل CLRium رقم 5: جامع القمامة</a></li>
<li><a href="../ar444838/index.html">OWASP روسيا ميتوب</a></li>
<li><a href="../ar444840/index.html">3. تحقق نقطة البدء R80.20. إعداد تخطيط</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>