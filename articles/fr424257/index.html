<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõå üéµ üåÖ Cartes hexagonales dans Unity: parties 1 √† 3 üïü üè¥ üßù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="D'un traducteur: cet article est le premier d'une s√©rie d√©taill√©e (27 parties) de tutoriels sur la cr√©ation de cartes √† partir d'hexagones. C'est ce q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cartes hexagonales dans Unity: parties 1 √† 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424257/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/305/0b2/d11/3050b2d115d1ec49e2b6c945ab9ed4c1.jpg" alt="image"></div><br>  <i>D'un traducteur: cet article est le premier d'une s√©rie d√©taill√©e (27 parties) de tutoriels sur la cr√©ation de cartes √† partir d'hexagones.</i>  <i>C'est ce qui devrait arriver √† la toute fin des tutoriels.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 1-3: maillage, couleurs et hauteurs de cellule</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 4-7: bosses, rivi√®res et routes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 8-11: eau, reliefs et remparts</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 12-15: sauvegarde et chargement, textures, distances</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 16-19: trouver le chemin, √©quipes de joueurs, animations</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 20-23: Brouillard de guerre, recherche cartographique, g√©n√©ration proc√©durale</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 24-27: cycle de l'eau, √©rosion, biomes, carte cylindrique</a> <br><br><h1>  Partie 1: maillage √† partir d'hexagones </h1><br><h2>  Table des mati√®res </h2><br><ul><li>  Convertissez les carr√©s en hexagones. </li><li>  Triangulez une grille d'hexagones. </li><li>  Nous travaillons avec des coordonn√©es cubiques. </li><li>  Nous interagissons avec les cellules de la grille. </li><li>  Cr√©ez un √©diteur en jeu. </li></ul><br>  Ce tutoriel est le d√©but d'une s√©rie sur les cartes hexagonales.  Les filets hexagonaux sont utilis√©s dans de nombreux jeux, en particulier dans les strat√©gies, notamment Age of Wonders 3, Civilization 5 et Endless Legend.  Nous commencerons par les bases, nous ajouterons progressivement de nouvelles fonctionnalit√©s et, par cons√©quent, nous cr√©erons un relief complexe bas√© sur des hexagones. <br><a name="habracut"></a><br>  Ce didacticiel suppose que vous avez d√©j√† √©tudi√© la s√©rie <i>Mesh Basics</i> , qui commence par la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">grille proc√©durale</a> .  Il a √©t√© cr√©√© sur Unity 5.3.1.  La s√©rie utilise plusieurs versions d'Unity.  La derni√®re partie est r√©alis√©e sur Unity 2017.3.0p3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54e/065/633/54e065633ba41c99214f720278b68336.png"></div><br>  <i>Une simple carte d'hexagones.</i> <br><br><h2>  √Ä propos des hexagones </h2><br>  Pourquoi les hexagones sont-ils n√©cessaires?  Si nous avons besoin d'une grille, il est logique d'utiliser des carr√©s.  Les carr√©s sont vraiment faciles √† dessiner et √† positionner, mais ils ont aussi un inconv√©nient.  Regardez un seul carr√© de la grille, puis ses voisins. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48f/d4f/9b8/48fd4f9b87d5aa2381d9b03dbae704ae.png"></div><br>  <i>La place et ses voisins.</i> <br><br>  Au total, la place a huit voisins.  Quatre d'entre eux peuvent √™tre atteints en traversant le bord du carr√©.  Ce sont des voisins horizontaux et verticaux.  Les quatre autres peuvent √™tre atteints en traversant le coin de la place.  Ce sont des voisins en diagonale. <br><br>  Quelle est la distance entre les centres des cellules de grille carr√©es adjacentes?  Si la longueur du bord est 1, alors pour les voisins horizontaux et verticaux, la r√©ponse est 1. Mais pour les voisins diagonaux, la r√©ponse est ‚àö2. <br><br>  La diff√©rence entre les deux types de voisins entra√Æne des difficult√©s.  Si nous utilisons un mouvement discret, alors comment percevoir le mouvement le long de la diagonale?  Dois-je le permettre du tout?  Comment rendre l'apparence plus organique?  Diff√©rents jeux utilisent diff√©rentes approches avec leurs avantages et leurs inconv√©nients.  Une approche n'est pas du tout d'utiliser une grille carr√©e, mais d'utiliser des hexagones √† la place. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/772/47a/9a1/77247a9a1784bdbe1b736672460b95bf.png"></div><br>  <i>Hexagone et ses voisins.</i> <br><br>  Contrairement √† un carr√©, un hexagone n'a pas huit, mais six voisins.  Tous ces voisins sont adjacents aux bords, il n'y a pas de voisins d'angle.  Autrement dit, il n'y a qu'un seul type de voisins, ce qui simplifie beaucoup.  Bien s√ªr, une grille d'hexagones est plus difficile √† construire qu'un carr√©, mais nous pouvons le g√©rer. <br><br>  Avant de commencer, nous devons d√©terminer la taille des hexagones.  Soit la longueur du bord √©gale √† 10 unit√©s.  √âtant donn√© que l'hexagone se compose d'un cercle de six triangles √©quilat√©raux, la distance entre le centre et n'importe quel angle est √©galement de 10. Cette valeur d√©termine le rayon ext√©rieur de la cellule hexagonale. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdb/a2f/82f/cdba2f82fb30358f0d2ca31c95f133d5.png"></div><br>  <i>Le rayon ext√©rieur et int√©rieur de l'hexagone.</i> <br><br>  Il y a aussi un rayon int√©rieur, qui est la distance du centre √† chacun des bords.  Ce param√®tre est important car la distance entre les centres des voisins est √©gale √† cette valeur multipli√©e par deux.  Le rayon int√©rieur est <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mtext" id="MJXp-Span-2">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;">s </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10"><font style="vertical-align: inherit;">q </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;">r </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12"><font style="vertical-align: inherit;">t </font></span></span><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mrow" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14"><font style="vertical-align: inherit;">3</font></span></span></span><span class="MJXp-mrow" id="MJXp-Span-15"><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"> 2</font></span></span></font><span class="MJXp-mrow" id="MJXp-Span-7"><span class="MJXp-mtext" id="MJXp-Span-8">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mrow" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14"><font style="vertical-align: inherit;"></font></span></span></span><span class="MJXp-mrow" id="MJXp-Span-15"><span class="MJXp-mn" id="MJXp-Span-16"><font style="vertical-align: inherit;"></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="12.098ex" height="2.419ex" viewBox="0 -780.1 5209 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-63" x="1781" y="0"></use><g transform="translate(2215,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-71" x="719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-72" x="1180" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-74" x="1631" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-33" x="1993" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-32" x="4708" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> \ frac {\ sqrt {3}} {2} </script>  du rayon ext√©rieur, c'est-√†-dire dans notre cas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-17"><span class="MJXp-mn" id="MJXp-Span-18"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20"><font style="vertical-align: inherit;">s </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21"><font style="vertical-align: inherit;">q </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mrow" id="MJXp-Span-24"><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;">3</font></span></span></font><span class="MJXp-mtext" id="MJXp-Span-19">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mrow" id="MJXp-Span-24"><span class="MJXp-mn" id="MJXp-Span-25"><font style="vertical-align: inherit;"></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.954ex" height="2.298ex" viewBox="0 -728.2 2994 989.6" role="img" focusable="false" style="vertical-align: -0.607ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-35" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-73" x="750" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-71" x="1220" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-72" x="1680" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-74" x="2132" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-33" x="2493" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> 5 \ sqrt {3} </script>  .  Mettons ces param√®tres dans une classe statique pour plus de commodit√©. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMetrics</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerRadius = <span class="hljs-number"><span class="hljs-number">10f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * <span class="hljs-number"><span class="hljs-number">0.866025404f</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comment d√©river la valeur du rayon interne?</b> <div class="spoiler_text">  Prenez l'un des six triangles d'un hexagone.  Le rayon int√©rieur est √©gal √† la hauteur de ce triangle.  Cette hauteur peut √™tre obtenue en divisant le triangle en deux triangles r√©guliers, puis en utilisant le th√©or√®me de Pythagore. <br><br>  Par cons√©quent, pour la longueur de la c√¥te <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">e</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.083ex" height="1.523ex" viewBox="0 -535.3 466.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-65" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> e </script>  le rayon int√©rieur est <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-28"><span class="MJXp-mtext" id="MJXp-Span-29">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">t</span><span class="MJXp-mrow" id="MJXp-Span-34"><span class="MJXp-msubsup" id="MJXp-Span-35"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36" style="margin-right: 0.05em;">e</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-37" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mo" id="MJXp-Span-39" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">e</span><span class="MJXp-mrow" id="MJXp-Span-41"><span class="MJXp-mo" id="MJXp-Span-42" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-43">2</span><span class="MJXp-msubsup" id="MJXp-Span-44"><span class="MJXp-mo" id="MJXp-Span-45" style="margin-left: 0em; margin-right: 0.05em;">)</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-46" style="vertical-align: 0.5em;">2</span></span></span><span class="MJXp-mo" id="MJXp-Span-47" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-48">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">t</span><span class="MJXp-mrow" id="MJXp-Span-53"><span class="MJXp-mn" id="MJXp-Span-54">3</span><span class="MJXp-msubsup" id="MJXp-Span-55"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56" style="margin-right: 0.05em;">e</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-57" style="vertical-align: 0.5em;">2</span></span><span class="MJXp-mrow" id="MJXp-Span-58"><span class="MJXp-mo" id="MJXp-Span-59" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-60">4</span></span><span class="MJXp-mo" id="MJXp-Span-61" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62">e</span><span class="MJXp-mtext" id="MJXp-Span-63">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">t</span><span class="MJXp-mrow" id="MJXp-Span-68"><span class="MJXp-mn" id="MJXp-Span-69">3</span></span><span class="MJXp-mrow" id="MJXp-Span-70"><span class="MJXp-mo" id="MJXp-Span-71" style="margin-left: 0.111em; margin-right: 0.111em;">/</span></span><span class="MJXp-mn" id="MJXp-Span-72">2</span><span class="MJXp-mtext" id="MJXp-Span-73">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">v</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80">n</span><span class="MJXp-mn" id="MJXp-Span-81">0</span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-83">886</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84">e</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="56.857ex" height="3.037ex" viewBox="0 -950 24479.9 1307.5" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-71" x="719" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-72" x="1180" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-74" x="1631" y="0"></use><g transform="translate(1993,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-65" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-32" x="659" y="513"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-2212" x="1142" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-28" x="2143" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-65" x="2532" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-2F" x="2999" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-32" x="3499" y="0"></use><g transform="translate(4000,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-32" x="550" y="513"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-3D" x="7114" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-73" x="8420" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-71" x="8890" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-72" x="9350" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-74" x="9802" y="0"></use><g transform="translate(10163,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-33" x="0" y="0"></use><g transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-65" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-32" x="659" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-2F" x="1420" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-34" x="1921" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-3D" x="12863" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-65" x="13919" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-73" x="14636" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-71" x="15105" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-72" x="15566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-74" x="16017" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-33" x="16379" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-2F" x="16879" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-32" x="17380" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-65" x="18130" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-6E" x="18597" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-76" x="19197" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-69" x="19683" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-72" x="20028" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-6F" x="20480" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-6E" x="20965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-30" x="21566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-2C" x="22066" y="0"></use><g transform="translate(22511,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-38"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-38" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMAIN-36" x="1001" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-65" x="24013" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> \ sqrt {e ^ 2 - (e / 2) ^ 2} = \ sqrt {3e ^ 2/4} = e \ sqrt {3} / 2 \ environ 0,886e </script>  . </div></div><br>  Si nous le faisons d√©j√†, d√©terminons les positions des six coins par rapport au centre de la cellule.  Il convient de noter qu'il existe deux fa√ßons d'orienter l'hexagone: vers le haut avec un c√¥t√© pointu ou plat.  Nous allons mettre le coin.  Commen√ßons par cet angle et ajoutons le reste dans le sens horaire.  Placez-les sur le plan XZ afin que les hexagones soient au sol. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b2/0eb/95a/5b20eb95ac844ed93a117b7d37f90e11.png"></div><br>  <i>Orientations possibles.</i> <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] corners = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, -outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius) };</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">paquet d'unit√©</a> <br><br><h2>  Maillage </h2><br>  Pour construire une grille d'hexagones, nous avons besoin de cellules de grille.  Pour cela, cr√©ez le composant <code>HexCell</code> .  Pour l'instant, laissez-le vide car nous n'utilisons pas encore de cellules donn√©es. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br>  Pour commencer avec le plus simple, cr√©ez un objet plan par d√©faut, ajoutez-y un composant de cellule et transformez-le en pr√©fabriqu√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b61/f1f/3ab/b61f1f3ab3210349434c2aff8c9ac374.png"></div><br>  <i>Utilisation d'un avion comme pr√©fabriqu√© d'une cellule hexagonale.</i> <br><br>  Entrons maintenant dans le filet.  Cr√©ons un composant simple avec des variables communes de largeur, hauteur et pr√©fabriqu√© de cellule.  Ajoutez ensuite un objet de jeu avec ce composant √† la sc√®ne. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGrid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCell cellPrefab; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/749/12e/cad74912e6a951918b4a3d0f4b9bb6bb.png"></div><br>  <i>Objet maill√© hexagonal.</i> <br><br>  Commen√ßons par cr√©er une grille r√©guli√®re de carr√©s, car nous savons d√©j√† comment proc√©der.  Sauvegardons les cellules dans un tableau pour pouvoir y acc√©der. <br><br>  √âtant donn√© que les avions par d√©faut ont une taille de 10 par 10 unit√©s, nous d√©placerons chaque cellule de ce montant. <br><br><pre> <code class="cs hljs"> HexCell[] cells; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[height * width]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; height; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { CreateCell(x, z, i++); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { Vector3 position; position.x = x * <span class="hljs-number"><span class="hljs-number">10f</span></span>; position.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; position.z = z * <span class="hljs-number"><span class="hljs-number">10f</span></span>; HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.transform.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/560/321/d11560321e63ac581846776aa5b658b6.png"></div><br>  <i>Grille carr√©e d'avions.</i> <br><br>  Nous avons donc obtenu une belle grille solide de cellules carr√©es.  Mais quelle cellule est o√π?  Bien s√ªr, c'est facile √† v√©rifier, mais il y a des difficult√©s avec les hexagones.  Il serait pratique de voir simultan√©ment les coordonn√©es de toutes les cellules. <br><br><h3>  Affichage des coordonn√©es </h3><br>  Ajoutez du canevas √† la sc√®ne en s√©lectionnant <i>GameObject / UI / Canvas</i> et faites-en un enfant de notre objet maill√©.  √âtant donn√© que ce canevas est uniquement √† titre d'information, nous supprimerons son composant raycaster.  Vous pouvez √©galement supprimer l'objet syst√®me d'√©v√©nement, qui a √©t√© automatiquement ajout√© √† la sc√®ne, car pour l'instant nous n'en avons pas besoin. <br><br>  D√©finissez le <i>mode de rendu</i> sur <i>Espace mondial</i> et faites-le pivoter de 90 degr√©s le long de l'axe X de sorte que le canevas recouvre la grille.  R√©glez le pivot et la position sur z√©ro.  Donnez-lui un l√©ger d√©calage vertical pour que son contenu soit au sommet.  La largeur et la hauteur ne sont pas importantes pour nous, car nous organisons nous-m√™mes le contenu.  Nous pouvons d√©finir la valeur sur 0 pour supprimer le grand rectangle dans la fen√™tre de la sc√®ne. <br><br>  Comme touche finale, augmentez les <i>pixels dynamiques par unit√©</i> √† 10. Nous garantissons donc que les objets texte utiliseront une r√©solution de texture suffisante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d37/d5e/34e/d37d5e34e417e5d703d2915ef2e6ad19.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/c37/273/374c37273c1e8e61befc30543efca5b2.png"></div><br>  <i>Toile pour les coordonn√©es de grille des hexagones.</i> <br><br>  Pour afficher les coordonn√©es, cr√©ez un objet Texte ( <i>GameObject / UI / Text</i> ) et transformez-le en pr√©fabriqu√©.  Centrez ses ancres et son pivot, d√©finissez la taille sur 5 par 15. Le texte doit √©galement √™tre align√© horizontalement et verticalement au centre.  D√©finissez la taille de police sur 4. Enfin, nous ne voulons pas utiliser le texte par d√©faut et nous n'utiliserons pas de <i>texte enrichi</i> .  En outre, peu importe que la <i>cible Raycast</i> soit activ√©e, car pour notre canevas, elle n'est toujours pas n√©cessaire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f15/c09/d55/f15c09d55444941d69d563940806340f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6d/0df/ab2/d6d0dfab20e21276e48a2ca5bdc36503.png"></div><br>  <i>√âtiquette de cellule pr√©fabriqu√©e.</i> <br><br>  Maintenant, nous devons indiquer √† la grille le canevas et le pr√©fabriqu√©.  Ajoutez au d√©but de son script en <code>using UnityEngine.UI;</code>  pour acc√©der <code>UnityEngine.UI.Text</code> type <code>UnityEngine.UI.Text</code> .  Une √©tiquette pr√©fabriqu√©e a besoin d'une variable partag√©e et le canevas peut √™tre trouv√© en appelant <code>GetComponentInChildren</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Text cellLabelPrefab; Canvas gridCanvas; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fae/b30/599/faeb3059923e68e4b072a5b401086072.png"></div><br>  <i>Balises pr√©fabriqu√©es de connexion.</i> <br><br>  Apr√®s avoir connect√© le pr√©fabriqu√© de l'√©tiquette, nous pouvons cr√©er ses instances et afficher les coordonn√©es de la cellule.  Entre X et Z, ins√©rez un caract√®re de nouvelle ligne de sorte qu'ils apparaissent sur des lignes distinctes. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); label.text = x.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + z.ToString(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e8/1e2/9b0/0e81e29b0fd80afb2f7056a5b8ed829d.png"></div><br>  <i>Affichage des coordonn√©es.</i> <br><br><h3>  Positions hexagonales </h3><br>  Maintenant que nous pouvons reconna√Ætre visuellement chaque cellule, commen√ßons √† les d√©placer.  Nous savons que la distance entre les cellules hexagonales adjacentes dans la direction X est √©gale au double du rayon int√©rieur.  Nous allons l'utiliser.  De plus, la distance jusqu'√† la prochaine rang√©e de cellules doit √™tre 1,5 fois sup√©rieure au rayon ext√©rieur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e4/269/f40/6e4269f40ead27d2ddb0dd75a1154d99.png"></div><br>  <i>G√©om√©trie des hexagones voisins.</i> <br><br><pre> <code class="cs hljs"> position.x = x * (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>); position.y = <span class="hljs-number"><span class="hljs-number">0f</span></span>; position.z = z * (HexMetrics.outerRadius * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ca/d03/034/5cad03034d4aacacf5ccd49dccf0af3a.png"></div><br>  <i>Nous appliquons des distances entre hexagones sans d√©calages.</i> <br><br>  Bien s√ªr, les rang√©es ordinales des hexagones ne sont pas situ√©es exactement l'une au-dessus de l'autre.  Chaque ligne est d√©cal√©e le long de l'axe X de la valeur du rayon int√©rieur.  Cette valeur peut √™tre obtenue en ajoutant la moiti√© de Z √† X, puis en multipliant par deux le rayon int√©rieur. <br><br><pre> <code class="cs hljs"> position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/75c/e06/f65/75ce06f65db02737bddf223d45f6b8f3.png"></div><br>  <i>Un placement correct des hexagones cr√©e une grille en forme de losange.</i> <br><br>  Bien que ce soit ainsi que nous avons plac√© les cellules aux bonnes positions des hexagones, notre grille remplit d√©sormais le losange plut√¥t que le rectangle.  Nous sommes beaucoup plus √† l'aise de travailler avec des grilles rectangulaires, alors remettons les cellules en service.  Cela peut √™tre fait en reculant une partie du d√©calage.  Dans chaque deuxi√®me ligne, toutes les cellules doivent √™tre recul√©es d'un pas suppl√©mentaire.  Pour ce faire, nous devons soustraire le r√©sultat de la division enti√®re de Z par 2 avant de multiplier. <br><br><pre> <code class="cs hljs"> position.x = (x + z * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> - z / <span class="hljs-number"><span class="hljs-number">2</span></span>) * (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/429/30a/51942930aa48daab518847429e4c8b74.png"></div><br>  <i>L'emplacement des hexagones dans une zone rectangulaire.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  Rendu hexagonal </h2><br>  Apr√®s avoir plac√© les cellules correctement, nous pouvons proc√©der √† l'affichage des vrais hexagones.  Nous devons d'abord nous d√©barrasser des avions, nous allons donc supprimer tous les composants √† l'exception de <code>HexCell</code> du <code>HexCell</code> cellule. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48f/32a/214/48f32a214e6ef61f580a0147a5f310da.png"></div><br>  <i>Il n'y a plus d'avions.</i> <br><br>  Comme dans les didacticiels de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">base</a> sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">maillage</a> , nous utilisons un seul maillage pour rendre le maillage entier.  Cependant, cette fois, nous ne pr√©d√©finissons pas le nombre de sommets et de triangles requis.  Au lieu de cela, nous utiliserons des listes. <br><br>  Cr√©ez un nouveau composant <code>HexMesh</code> qui <code>HexMesh</code> soin de notre maillage.  Il faudra un filtre et un rendu de maillage, il a un maillage et des listes pour les sommets et les triangles. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; [RequireComponent(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshFilter), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MeshRenderer))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMesh</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Mesh hexMesh; List&lt;Vector3&gt; vertices; List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); } }</code> </pre> <br>  Cr√©ez un nouvel objet enfant pour ce maillage avec ce composant.  Il recevra automatiquement un rendu de maillage, mais aucun mat√©riel ne lui sera attribu√©.  Par cons√©quent, ajoutez-y le mat√©riau par d√©faut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2a/831/2ab/f2a8312ab61274a7563aeeb7860c3609.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ab/bf1/710/8abbf17103e93485e696daf3a94bb277.png"></div><br>  <i>Objet maill√© hexagonal.</i> <br><br>  <code>HexGrid</code> pourra d√©sormais r√©cup√©rer son maillage hexagonal de la m√™me mani√®re qu'il a trouv√© la toile. <br><br><pre> <code class="cs hljs"> HexMesh hexMesh; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); ‚Ä¶ }</code> </pre> <br>  Apr√®s le maillage √©veill√©, il doit ordonner au maillage de trianguler ses cellules.  Nous devons √™tre s√ªrs que cela se produira apr√®s le composant Awake du maillage hexad√©cimal.  Puisque <code>Start</code> est appel√© plus tard, ins√©rez-y le code appropri√©. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br>  Cette m√©thode <code>HexMesh.Triangulate</code> peut √™tre appel√©e √† tout moment, m√™me si les cellules ont d√©j√† √©t√© triangul√©es auparavant.  Par cons√©quent, nous devons commencer par nettoyer les anciennes donn√©es.  Lorsque vous parcourez toutes les cellules, nous les triangulons individuellement.  Apr√®s avoir termin√© cette op√©ration, nous attribuons les sommets et triangles g√©n√©r√©s au maillage et terminons en recomptant les normales du maillage. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell[] cells</span></span></span><span class="hljs-function">)</span></span> { hexMesh.Clear(); vertices.Clear(); triangles.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } hexMesh.vertices = vertices.ToArray(); hexMesh.triangles = triangles.ToArray(); hexMesh.RecalculateNormals(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Puisque les hexagones sont compos√©s de triangles, cr√©ons une m√©thode pratique pour ajouter un triangle bas√© sur les positions de trois sommets.  Il ajoutera simplement des sommets dans l'ordre.  Il ajoute √©galement les indices de ces sommets pour former un triangle.  L'index du premier sommet est √©gal √† la longueur de la liste des sommets avant d'y ajouter de nouveaux sommets.  N'oubliez pas cela lors de l'ajout de sommets. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Maintenant, nous pouvons trianguler nos cellules.  Commen√ßons par le premier triangle.  Son premier pic est au centre de l'hexagone.  Les deux autres sommets sont les premier et deuxi√®me angles par rapport au centre. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; AddTriangle( center, center + HexMetrics.corners[<span class="hljs-number"><span class="hljs-number">0</span></span>], center + HexMetrics.corners[<span class="hljs-number"><span class="hljs-number">1</span></span>] ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/d2b/ca3/860d2bca3ec0d1c95bd66082735021f7.png"></div><br>  <i>Le premier triangle de chaque cellule.</i> <br><br>  Cela a fonctionn√©, alors passons en boucle autour des six triangles. <br><br><pre> <code class="cs hljs"> Vector3 center = cell.transform.localPosition; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { AddTriangle( center, center + HexMetrics.corners[i], center + HexMetrics.corners[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Les pics peuvent-ils √™tre partag√©s?</b> <div class="spoiler_text">  Oui tu peux.  En fait, nous pouvons faire encore mieux et utiliser seulement quatre au lieu de six triangles pour le rendu.  Mais en abandonnant cela, nous simplifierons notre travail, et ce sera correct, car dans les tutoriels suivants tout devient plus compliqu√©.  L'optimisation des sommets et des triangles √† ce stade nous g√™nera √† l'avenir. </div></div><br>  Malheureusement, ce processus entra√Ænera une <code>IndexOutOfRangeException</code> .  C'est parce que le dernier triangle essaie d'obtenir le septi√®me coin, qui n'existe pas.  Bien s√ªr, il devrait revenir en arri√®re et utiliser comme dernier sommet du premier coin.  Ou nous pouvons dupliquer le premier coin dans <code>HexMetrics.corners</code> afin de ne pas d√©passer les limites. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] corners = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, -outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius) };</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8d/277/e13/c8d277e139df24953e9b381fabca2a42.png"></div><br>  <i>Hexagones compl√®tement.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  Coordonn√©es hexagonales </h2><br>  Regardons √† nouveau les coordonn√©es des cellules, maintenant dans le contexte d'une grille d'hexagones.  La coordonn√©e Z semble bien, et la coordonn√©e X zigzague.  Il s'agit d'un effet secondaire du d√©calage de ligne pour couvrir une zone rectangulaire. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73f/745/502/73f745502f1d8d20245bd22edc99a3ce.png"></div><br>  <i>Coordonn√©es de d√©calage avec des lignes nulles en surbrillance.</i> <br><br>  Lorsque vous travaillez avec des hexagones, ces coordonn√©es de d√©calage ne sont pas faciles √† g√©rer.  Ajoutons une structure <code>HexCoordinates</code> , qui peut √™tre utilis√©e pour convertir en un autre syst√®me de coordonn√©es.  Rendons-le s√©rialisable pour qu'Unity puisse le stocker et il subira une recompilation en mode Play.  Nous rendons √©galement ces coordonn√©es immuables en utilisant les propri√©t√©s publiques en lecture seule. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> HexCoordinates { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { X = x; Z = z; } }</code> </pre> <br>  Ajoutez une m√©thode statique pour cr√©er un ensemble de coordonn√©es √† partir des coordonn√©es de d√©calage ordinaires.  Pour l'instant, nous allons simplement copier ces coordonn√©es. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromOffsetCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z); } }</code> </pre> <br>  Nous ajoutons √©galement des m√©thodes de conversion de cha√Ænes pratiques.  La m√©thode <code>ToString</code> renvoie par d√©faut un nom de type struct, ce qui ne nous est pas tr√®s utile.  Nous le red√©finissons afin qu'il renvoie les coordonn√©es sur une seule ligne.  Nous ajouterons √©galement une m√©thode d'affichage des coordonn√©es sur des lignes distinctes, car nous utilisons d√©j√† un tel sch√©ma. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> + X.ToString() + <span class="hljs-string"><span class="hljs-string">", "</span></span> + Z.ToString() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToStringOnSeparateLines</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + Z.ToString(); }</code> </pre> <br>  Maintenant, nous pouvons passer beaucoup de coordonn√©es √† notre composant <code>HexCell</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCoordinates coordinates; }</code> </pre> <br>  Modifiez <code>HexGrid.CreateCell</code> afin qu'il puisse utiliser les nouvelles coordonn√©es. <br><br><pre> <code class="cs hljs"> HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); label.rectTransform.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); label.rectTransform.anchoredPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(position.x, position.z); label.text = cell.coordinates.ToStringOnSeparateLines();</code> </pre> <br>  Refaisons maintenant ces coordonn√©es X afin qu'elles soient align√©es le long d'un axe droit.  Cela peut √™tre fait en annulant le d√©calage horizontal.  Le r√©sultat obtenu est g√©n√©ralement appel√© coordonn√©es axiales. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromOffsetCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x - z / <span class="hljs-number"><span class="hljs-number">2</span></span>, z); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/1bf/29d/4331bf29dbf016e466a3636b5cd90311.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ab/03d/7af/4ab03d7afdef480fe4657ae86901fd1a.png"></div><br>  <i>Coordonn√©es axiales.</i> <br><br>  Ce syst√®me de coordonn√©es bidimensionnelles nous permet de d√©crire s√©quentiellement le mouvement de d√©placement dans quatre directions.  Cependant, deux directions restantes n√©cessitent encore une attention particuli√®re.  Cela nous fait r√©aliser qu'il existe une troisi√®me dimension.  Et en fait, si nous devions inverser horizontalement la dimension de X, nous obtiendrions la dimension manquante de Y. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32c/39b/9b7/32c39b9b7705099d7bcb8e525aa6fe48.png"></div><br>  <i>La mesure Y appara√Æt.</i> <br><br>  Puisque ces mesures de X et Y sont des copies miroir l'une de l'autre, l'ajout de leurs coordonn√©es donne toujours le m√™me r√©sultat si Z reste constant.  En fait, si vous additionnez les trois coordonn√©es, nous obtiendrons toujours z√©ro.  Si vous augmentez une coordonn√©e, vous devez r√©duire l'autre.  Et en fait, cela nous donne six directions de mouvement possibles.  Ces coordonn√©es sont g√©n√©ralement appel√©es cubiques, car elles sont tridimensionnelles et la topologie ressemble √† un cube. <br><br>  Puisque la somme de toutes les coordonn√©es est nulle, nous pouvons toujours obtenir l'une des coordonn√©es des deux autres.  Comme nous stockons d√©j√† les coordonn√©es X et Z, nous n'avons pas besoin de stocker les coordonn√©es Y. <br>  Nous pouvons ajouter une propri√©t√© qui l'√©value si n√©cessaire et l'utiliser dans des m√©thodes de cha√Æne. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -X - Z; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"("</span></span> + X.ToString() + <span class="hljs-string"><span class="hljs-string">", "</span></span> + Y.ToString() + <span class="hljs-string"><span class="hljs-string">", "</span></span> + Z.ToString() + <span class="hljs-string"><span class="hljs-string">")"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToStringOnSeparateLines</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> X.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + Y.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + Z.ToString(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c36/ad9/d32/c36ad9d322193e811fd6c59b5d76249a.png"></div><br>  <i>Coordonn√©es cubiques.</i> <br><br><h3>  Coordonn√©es de l'inspecteur </h3><br>  En mode Lecture, s√©lectionnez l'une des cellules de la grille.  Il s'av√®re que l'inspecteur n'affiche pas ses coordonn√©es, seul le pr√©fixe <code>HexCell.coordinates</code> est <code>HexCell.coordinates</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d02/a1d/a0e/d02a1da0e906223abcb9aeeb46ce7477.png"></div><br>  <i>L'inspecteur n'affiche pas les coordonn√©es.</i> <br><br>  Bien qu'il n'y ait pas de gros probl√®me avec cela, ce serait bien d'afficher les coordonn√©es.  Unity n'affiche pas les coordonn√©es car elles ne sont pas marqu√©es comme des champs s√©rialisables.  Pour les afficher, vous devez sp√©cifier explicitement des champs s√©rialisables pour X et Z. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, z; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Z { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HexCoordinates</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.z = z; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ea/264/fff/5ea264fffa724e10205c41c8191ad78b.png"></div><br>  Les coordonn√©es X et Z sont maintenant affich√©es, mais elles peuvent √™tre modifi√©es.  Nous n'en avons pas besoin, car les coordonn√©es doivent √™tre fixes.  Il n'est √©galement pas tr√®s bon qu'ils soient affich√©s les uns sous les autres. <br><br>  Nous pouvons faire mieux: d√©finir notre propre tiroir de propri√©t√©s pour le type <code>HexCoordinates</code> .  Cr√©ez un script <code>HexCoordinatesDrawer</code> et collez-le dans le dossier <i>Editor</i> , car ce script est uniquement destin√© √† l'√©diteur. <br><br>  La classe doit √©tendre <code>UnityEditor.PropertyDrawer</code> et a besoin de l'attribut <code>UnityEditor.CustomPropertyDrawer</code> pour l'associer √† un type appropri√©. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; [CustomPropertyDrawer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(HexCoordinates))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCoordinatesDrawer</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyDrawer</span></span> { }</code> </pre> <br>  Les tiroirs de propri√©t√©s affichent leur contenu √† l'aide de la m√©thode <code>OnGUI</code> .  Cette m√©thode a permis de dessiner des donn√©es de propri√©t√© s√©rialisables et l'√©tiquette du champ auquel elles appartiennent √† l'int√©rieur du rectangle d'√©cran. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Rect position, SerializedProperty property, GUIContent label </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Nous extrayons les valeurs de x et z de la propri√©t√©, puis les utilisons pour cr√©er un nouvel ensemble de coordonn√©es.  Ensuite, dessinez l'√©tiquette GUI √† la position s√©lectionn√©e en utilisant notre m√©thode <code>HexCoordinates.ToString</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Rect position, SerializedProperty property, GUIContent label </span></span></span><span class="hljs-function">)</span></span> { HexCoordinates coordinates = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates( property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"x"</span></span>).intValue, property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"z"</span></span>).intValue ); GUI.Label(position, coordinates.ToString()); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d6/d0f/852/1d6d0f852f744b6b5080a54478a3f4bf.png"></div><br>  <i>Coordonn√©es sans √©tiquette de pr√©fixe.</i> <br><br>  Cela affichera les coordonn√©es, mais il nous manque maintenant le nom du champ.  Ces noms sont g√©n√©ralement rendus √† l'aide de la m√©thode <code>EditorGUI.PrefixLabel</code> .  En prime, il renvoie un rectangle align√© qui correspond √† l'espace √† droite de cette √©tiquette. <br><br><pre> <code class="cs hljs"> position = EditorGUI.PrefixLabel(position, label); GUI.Label(position, coordinates.ToString());</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6c/d34/856/a6cd348569c891e063c6fc515d075d04.png"></div><br>  <i>Coordonn√© avec une √©tiquette.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  Cellules tactiles </h2><br>  Une grille d'hexagones n'est pas tr√®s int√©ressante si on ne peut pas interagir avec elle.  L'interaction la plus simple est de toucher la cellule, alors ajoutons un support pour elle.  Pour l'instant, nous <code>HexGrid</code> simplement ce code directement dans <code>HexGrid</code> .  Quand il commencera √† fonctionner, nous le d√©placerons vers un autre endroit. <br><br>  Pour toucher une cellule, vous pouvez √©mettre des rayons dans la sc√®ne √† partir de la position du curseur de la souris.  Nous pouvons utiliser la m√™me approche que dans le didacticiel sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©formation</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">maillage</a> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleInput(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { TouchCell(hit.point); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); Debug.Log(<span class="hljs-string"><span class="hljs-string">"touched at "</span></span> + position); }</code> </pre> <br>  Jusqu'√† pr√©sent, le code ne fait rien.  Nous devons ajouter un collisionneur √† la grille afin que le faisceau puisse entrer en collision avec quelque chose.  Par cons√©quent, nous donnerons le <code>HexMesh</code> collisionneur <code>HexMesh</code> . <br><br><pre> <code class="cs hljs"> MeshCollider meshCollider; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); ‚Ä¶ }</code> </pre> <br>  Une fois la triangulation termin√©e, affectez un maillage au collisionneur. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell[] cells</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ meshCollider.sharedMesh = hexMesh; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Ne pouvons-nous pas simplement utiliser le collisionneur de bo√Ætes?</b> <div class="spoiler_text">  Nous le pouvons, mais cela ne correspondra pas exactement au contour de notre grille.  Oui, et notre grille ne restera pas plate longtemps, mais c'est un sujet pour les futurs tutoriels. </div></div><br>  Maintenant, nous pouvons toucher la grille!  Mais quelle cellule touchons-nous?  Pour le savoir, nous devons convertir la position tactile en coordonn√©es des hexagones.  Cela fonctionne pour <code>HexCoordinates</code> , nous <code>HexCoordinates</code> d√©clarer qu'il a une m√©thode <code>FromPosition</code> statique. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); Debug.Log(<span class="hljs-string"><span class="hljs-string">"touched at "</span></span> + coordinates.ToString()); }</code> </pre> <br>  Comment cette m√©thode d√©terminera-t-elle quelle coordonn√©e appartient √† la position?  On peut commencer par diviser x par la largeur horizontale de l'hexagone.  Et puisque la coordonn√©e Y est une image miroir de la coordonn√©e X, un x n√©gatif nous donne y. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexCoordinates </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = position.x / (HexMetrics.innerRadius * <span class="hljs-number"><span class="hljs-number">2f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -x; }</code> </pre> <br>  Bien s√ªr, cela nous donnerait les coordonn√©es correctes si Z √©tait nul.  Nous devons √† nouveau d√©placer lorsque nous nous d√©pla√ßons le long de Z. Toutes les deux lignes, nous devons d√©placer vers la gauche d'une unit√©. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = position.z / (HexMetrics.outerRadius * <span class="hljs-number"><span class="hljs-number">3f</span></span>); x -= offset; y -= offset;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En cons√©quence, nos valeurs x et y se r√©v√®lent √™tre des entiers au centre de chaque cellule. </font><font style="vertical-align: inherit;">Par cons√©quent, en les arrondissant √† l'entier le plus proche, nous devons obtenir les coordonn√©es. </font><font style="vertical-align: inherit;">Nous calculons √©galement Z et obtenons ainsi les coordonn√©es finales.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iX = Mathf.RoundToInt(x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iY = Mathf.RoundToInt(y); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iZ = Mathf.RoundToInt(-x -y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(iX, iZ);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les r√©sultats semblent prometteurs, mais ces coordonn√©es sont-elles correctes? </font><font style="vertical-align: inherit;">Avec une √©tude attentive, vous pouvez constater que parfois nous obtenons les coordonn√©es, dont la somme n'est pas √©gale √† z√©ro! </font><font style="vertical-align: inherit;">Allumons la notification pour nous assurer que cela se produit r√©ellement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iX + iY + iZ != <span class="hljs-number"><span class="hljs-number">0</span></span>) { Debug.LogWarning(<span class="hljs-string"><span class="hljs-string">"rounding error!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(iX, iZ);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous recevons effectivement des notifications. </font><font style="vertical-align: inherit;">Comment pouvons-nous corriger cette erreur? </font><font style="vertical-align: inherit;">Il n'appara√Æt qu'√† c√¥t√© des bords entre les hexagones. </font><font style="vertical-align: inherit;">Autrement dit, l'arrondi des coordonn√©es cause des probl√®mes. </font><font style="vertical-align: inherit;">Quelle coordonn√©e est arrondie dans la mauvaise direction? </font><font style="vertical-align: inherit;">Plus nous nous √©loignons du centre de la cellule, plus nous obtenons d'arrondi. </font><font style="vertical-align: inherit;">Par cons√©quent, il est logique de supposer que la coordonn√©e arrondie est surtout incorrecte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, la solution consiste √† supprimer les coordonn√©es avec le plus grand delta d'arrondi et √† les recr√©er √† partir des valeurs des deux autres. </font><font style="vertical-align: inherit;">Mais comme nous n'avons besoin que de X et Z, nous ne pouvons pas nous emb√™ter √† recr√©er Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iX + iY + iZ != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dX = Mathf.Abs(x - iX); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dY = Mathf.Abs(y - iY); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dZ = Mathf.Abs(-x -y - iZ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dX &gt; dY &amp;&amp; dX &gt; dZ) { iX = -iY - iZ; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dZ &gt; dY) { iZ = -iX - iY; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coloriage - Hexagones </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous pouvons toucher la bonne cellule, le moment est venu pour une v√©ritable interaction. </font><font style="vertical-align: inherit;">Changeons la couleur de chaque cellule dans laquelle nous entrons. </font><font style="vertical-align: inherit;">Ajoutez pour les </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">couleurs personnalis√©es de la cellule par d√©faut et de la cellule affect√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color defaultColor = Color.white; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color touchedColor = Color.magenta;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33d/89a/d05/33d89ad0522ace10075800607aac71b2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S√©lection de la couleur des cellules. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez au </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ de couleur g√©n√©ral.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexCell</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexCoordinates coordinates; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color color; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attribuez-le </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la couleur par d√©faut.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.color = defaultColor; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons √©galement ajouter </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des informations </font><font style="vertical-align: inherit;">sur </font><font style="vertical-align: inherit;">la couleur.</font></font><br><br><pre> <code class="cs hljs"> List&lt;Color&gt; colors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Color&gt;(); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell[] cells</span></span></span><span class="hljs-function">)</span></span> { hexMesh.Clear(); vertices.Clear(); colors.Clear(); ‚Ä¶ hexMesh.vertices = vertices.ToArray(); hexMesh.colors = colors.ToArray(); ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lors de la triangulation, nous devons ajouter des donn√©es de couleur √† chaque triangle. </font><font style="vertical-align: inherit;">√Ä cet effet, nous allons cr√©er une m√©thode distincte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { AddTriangle( center, center + HexMetrics.corners[i], center + HexMetrics.corners[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); AddTriangleColor(cell.color); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { colors.Add(color); colors.Add(color); colors.Add(color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retour √† </font></font><code>HexGrid.TouchCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tout d'abord, convertissez les coordonn√©es de la cellule en l'index correspondant du tableau. </font><font style="vertical-align: inherit;">Pour une grille carr√©e, ce serait juste X plus Z multipli√© par la largeur, mais dans notre cas, nous devrons √©galement ajouter un d√©calage de moiti√© Z. Ensuite, nous prenons la cellule, changeons sa couleur et triangulons √† nouveau le maillage.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avons-nous vraiment besoin de retrianguler tout le maillage?</font></font></b> <div class="spoiler_text">    ,       .       .    ,    ,     .       . </div></div><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TouchCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="hljs-number"><span class="hljs-number">2</span></span>; HexCell cell = cells[index]; cell.color = touchedColor; hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous puissions maintenant coloriser les cellules, les changements visuels ne sont pas encore visibles. </font><font style="vertical-align: inherit;">Cela est d√ª au fait que le shader n'utilise pas les couleurs de sommet par d√©faut. </font><font style="vertical-align: inherit;">Nous devons √©crire le n√¥tre. </font><font style="vertical-align: inherit;">Cr√©ez un nouveau shader par d√©faut ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actifs / Cr√©er / Shader / Shader de surface par d√©faut</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Seuls deux changements doivent y √™tre apport√©s. </font><font style="vertical-align: inherit;">Tout d'abord, ajoutez des donn√©es de couleur √† sa structure d'entr√©e. </font><font style="vertical-align: inherit;">Deuxi√®mement, multipliez l'alb√©do par cette couleur. </font><font style="vertical-align: inherit;">Nous ne nous int√©ressons qu'aux canaux RVB, car le mat√©riau est opaque.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/VertexColors" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; <span class="hljs-type"><span class="hljs-type">float4</span></span> color : COLOR; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez un nouveau mat√©riau √† l'aide de ce shader, puis faites en sorte que le maillage du maillage utilise ce mat√©riau. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, les couleurs des cellules appara√Ætront.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/223/efe/be1/223efebe1bdda83c9b383dac32197c6e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cellules color√©es.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'obtiens d'√©tranges artefacts d'ombre!</font></font></b> <div class="spoiler_text">    Unity        .          ,   ,   Z-.            . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âditeur de carte </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous savons comment changer les couleurs, cr√©ons un √©diteur de jeu simple. </font><font style="vertical-align: inherit;">Cette fonctionnalit√© ne s'applique pas aux capacit√©s </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous allons donc </font></font><code>TouchCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en faire une m√©thode g√©n√©rale avec un param√®tre de couleur suppl√©mentaire. </font><font style="vertical-align: inherit;">Supprimez √©galement le champ </font></font><code>touchedColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ColorCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position, Color color</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="hljs-number"><span class="hljs-number">2</span></span>; HexCell cell = cells[index]; cell.color = color; hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez un composant </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et d√©placez-y les m√©thodes </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>HandleInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ajoutez-y un champ commun pour faire r√©f√©rence √† la grille d'hexagones, un tableau de couleurs et un champ priv√© pour suivre la couleur active. </font><font style="vertical-align: inherit;">Enfin, ajoutez une m√©thode g√©n√©rale pour s√©lectionner une couleur et faites-lui d'abord s√©lectionner la premi√®re couleur.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapEditor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color[] colors; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid hexGrid; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Color activeColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SelectColor(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { HandleInput(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { hexGrid.ColorCell(hit.point, activeColor); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { activeColor = colors[index]; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un autre canevas, cette fois en conservant les param√®tres par d√©faut. </font><font style="vertical-align: inherit;">Ajoutez-y un composant </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, d√©finissez plusieurs couleurs et connectez-le √† une grille d'hexagones. </font><font style="vertical-align: inherit;">Cette fois, nous avons besoin d'un objet syst√®me d'√©v√©nement, et il a √©t√© automatiquement cr√©√© √† nouveau.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/0d6/be4/d180d6be4c656688f4ec6c4f5789bdba.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âditeur de carte hexagonale en quatre couleurs. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un panneau au canevas pour stocker les s√©lecteurs de couleurs ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Panel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Ajoutez son groupe de bascule ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composants / UI / Basculer le groupe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Rendez le panneau petit et placez-le dans le coin de l'√©cran.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/b05/4db/63fb054dbb5c64fce6c4671283df6e6a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panneau de couleur avec groupe de bascule. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remplissez maintenant le panneau avec des commutateurs pour chaque couleur ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / UI / Toggle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Tant que nous ne nous soucions pas de cr√©er une interface utilisateur complexe, une simple configuration manuelle suffit.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/40e/ffc/eef40effcb9510ba924186b766a1fee0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d58/0e4/595/d580e45954552b134082a9379af2eb8c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un interrupteur pour chaque couleur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allumez le premier interrupteur. </font><font style="vertical-align: inherit;">Int√©grez √©galement tous les commutateurs au groupe de bascule de sorte qu'un seul d'entre eux puisse √™tre s√©lectionn√© √† la fois. </font><font style="vertical-align: inherit;">Enfin, connectez-les √† </font></font><code>SelectColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la </font><font style="vertical-align: inherit;">m√©thode de </font><font style="vertical-align: inherit;">notre √©diteur. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en utilisant le bouton d'interface utilisateur "+" de l'√©v√©nement </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Value Changed</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">S√©lectionnez l'objet √©diteur de carte, puis s√©lectionnez la m√©thode souhait√©e dans la liste d√©roulante.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/e05/0af/7b4e050afca862a244607248834676aa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le premier interrupteur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cet √©v√©nement transmet un argument bool√©en qui d√©termine si le commutateur est activ√© √† chaque fois qu'il est modifi√©. </font><font style="vertical-align: inherit;">Mais on s'en fout. </font><font style="vertical-align: inherit;">Au lieu de cela, nous devrons passer manuellement un argument entier correspondant √† l'indice de couleur que nous voulons utiliser. </font><font style="vertical-align: inherit;">Par cons√©quent, laissez la valeur 0 pour le premier commutateur, d√©finissez la valeur 1 sur le second, et ainsi de suite.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quand la m√©thode d'√©v√©nement de commutation est-elle appel√©e?</font></font></b> <div class="spoiler_text">       .      ,    ,   . <br><br>      ,         ,    .  ,  <code>SelectColor</code>   .  ,      . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/0bb/8f4/35a0bb8f4425b0c821836f9aa9afda16.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coloration en plusieurs couleurs. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que l'interface utilisateur fonctionne, il y a un d√©tail ennuyeux. </font><font style="vertical-align: inherit;">Pour le voir, d√©placez le panneau afin qu'il recouvre la grille d'hexagones. </font><font style="vertical-align: inherit;">Lors du choix d'une nouvelle couleur, nous coloriserons √©galement les cellules sous l'interface utilisateur. </font><font style="vertical-align: inherit;">Autrement dit, nous interagissons simultan√©ment avec l'interface utilisateur et avec la grille. </font><font style="vertical-align: inherit;">Il s'agit d'un comportement ind√©sirable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela peut √™tre corrig√© en demandant au syst√®me d'√©v√©nements s'il a d√©termin√© l'emplacement du curseur sur un objet. </font><font style="vertical-align: inherit;">Comme elle ne conna√Æt que les objets d'interface utilisateur, cela nous dira que nous interagissons avec l'interface utilisateur. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devrons traiter nous-m√™mes l'entr√©e uniquement si cela ne se produit pas.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.EventSystems; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject() ) { HandleInput(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 2: M√©langer les couleurs des cellules </font></font></h1><br><h2>  Table des mati√®res </h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connectez les voisins. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpole les couleurs entre les triangles. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ez des zones de fusion. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simplifiez la g√©om√©trie. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la partie pr√©c√©dente, nous avons pos√© les bases de la grille et ajout√© la possibilit√© de modifier les cellules. </font><font style="vertical-align: inherit;">Chaque cellule a sa propre couleur unie et les couleurs aux bords des cellules changent consid√©rablement. </font><font style="vertical-align: inherit;">Dans ce tutoriel, nous allons cr√©er des zones de transition qui m√©langent les couleurs des cellules voisines.</font></font><br><cut></cut><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ca/518/132/8ca518132084099a6159027d4a345710.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transitions en douceur entre les cellules.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cellules voisines </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant d'effectuer un lissage entre les couleurs des cellules, nous devons d√©couvrir lesquelles des cellules sont adjacentes les unes aux autres. </font><font style="vertical-align: inherit;">Chaque cellule a six voisins qui peuvent √™tre identifi√©s dans les directions des points cardinaux. </font><font style="vertical-align: inherit;">Nous obtiendrons les directions suivantes: nord-est, est, sud-est, sud-ouest, ouest et nord-ouest. </font><font style="vertical-align: inherit;">Cr√©ons une √©num√©ration pour eux et collez-la dans un fichier de script distinct.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HexDirection { NE, E, SE, SW, W, NW }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que l'√©num√©ration?</font></font></b> <div class="spoiler_text"> <code>enum</code>     ,     .            .      ,      .  ,        . <br><br>  enum     .   ,     integer  .   ,    -  ,    integer. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/181/e0e/37f/181e0e37fdd59ab37214cc909409351c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Six voisins, six directions. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour stocker ces voisins, ajoutez-les au </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tableau. </font><font style="vertical-align: inherit;">Bien que nous puissions le rendre g√©n√©ral, nous le rendrons plut√¥t priv√© et donnerons acc√®s √† des m√©thodes utilisant des instructions. </font><font style="vertical-align: inherit;">Nous le rendons √©galement s√©rialisable afin que les liens ne soient pas perdus lors de la recompilation.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] HexCell[] neighbors;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avons-nous besoin de stocker toutes les connexions avec les voisins?</font></font></b> <div class="spoiler_text">       ,       .     ‚Äî    ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, le tableau des voisins est affich√© dans l'inspecteur. </font><font style="vertical-align: inherit;">Puisque chaque cellule a six voisins, pour notre pr√©fabriqu√© de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cellule hexad√©cimale,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous d√©finissons la taille du tableau 6.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ef/8c1/a2e/6ef8c1a2ee9478b007faefcef2516934.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a de la place pour six voisins dans notre pr√©fabriqu√©. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutons maintenant une m√©thode g√©n√©rale pour obtenir un voisin de cellule dans une direction. </font><font style="vertical-align: inherit;">√âtant donn√© que la valeur de direction est toujours comprise entre 0 et 5, nous n'avons pas besoin de v√©rifier si l'index se trouve dans le tableau.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNeighbor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez une m√©thode pour sp√©cifier un voisin. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetNeighbor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] = cell; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les relations des voisins sont bidirectionnelles. </font><font style="vertical-align: inherit;">Par cons√©quent, lors de la d√©finition d'un voisin dans une direction, il serait logique de d√©finir imm√©diatement un voisin dans la direction oppos√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetNeighbor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] = cell; cell.neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction.Opposite()] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b86/616/15c/b8661615ceece04f7f4c16fa1c032be4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voisins dans des directions oppos√©es. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, cela sugg√®re que nous pouvons demander des instructions pour le voisin oppos√©. </font><font style="vertical-align: inherit;">Nous pouvons impl√©menter cela en cr√©ant une m√©thode d'extension pour </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour obtenir la direction oppos√©e, vous devez ajouter √† l'original 3. Cependant, cela ne fonctionne que pour les trois premi√®res directions, pour le reste, vous devez soustraire 3.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HexDirection { NE, E, SE, SW, W, NW } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexDirectionExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Opposite</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> ? (direction + <span class="hljs-number"><span class="hljs-number">3</span></span>) : (direction - <span class="hljs-number"><span class="hljs-number">3</span></span>); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce qu'une m√©thode d'extension?</font></font></b> <div class="spoiler_text">   ‚Äî      ,       - .       ‚Äî , , ,    .         <code>this</code> .      ,     . <br><br>        ? ,  ,       ,      .    ?    ‚Äî .  ,      ,        . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connexion voisine </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons initialiser le lien des voisins </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En parcourant les cellules ligne par ligne, de gauche √† droite, nous savons quelles cellules ont d√©j√† √©t√© cr√©√©es. </font><font style="vertical-align: inherit;">Ce sont les cellules avec lesquelles nous pouvons nous connecter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le plus simple est le compos√© E - W. </font><font style="vertical-align: inherit;">La premi√®re cellule de chaque rang√©e n'a pas de voisin oriental. </font><font style="vertical-align: inherit;">Mais toutes les autres cellules l'ont. </font><font style="vertical-align: inherit;">Et ces voisins sont cr√©√©s avant la cellule avec laquelle nous travaillons actuellement. </font><font style="vertical-align: inherit;">Par cons√©quent, nous pouvons les connecter.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/787/3bf/16f/7873bf16fdecde4ff216cc30b206ce89.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La connexion de E √† W lors de la cr√©ation des cellules.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.color = defaultColor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/560/08e/8b6/56008e8b6b2c16f3da710a2cedebb7dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les voisins orientaux et occidentaux sont connect√©s. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons cr√©er deux connexions bidirectionnelles suppl√©mentaires. </font><font style="vertical-align: inherit;">Puisque ce sont les connexions entre les diff√©rentes lignes du r√©seau, nous ne pouvons communiquer qu'avec la ligne pr√©c√©dente. </font><font style="vertical-align: inherit;">Cela signifie que nous devons compl√®tement sauter la premi√®re ligne.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.W, cells[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme les lignes sont en zigzag, elles doivent √™tre trait√©es diff√©remment. </font><font style="vertical-align: inherit;">Voyons d'abord les lignes paires. </font><font style="vertical-align: inherit;">√âtant donn√© que toutes les cellules de ces lignes ont un voisin sur SE, nous pouvons les y connecter.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/e56/419/7d5e56419ed4a0fb7b2c506061543561.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connexion de NW √† SE pour les lignes paires.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width]); } }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que fait z &amp; 1?</font></font></b> <div class="spoiler_text"> <code>&amp;&amp;</code> ‚Äî    ,  <code>&amp;</code> ‚Äî    .     ,         .      1,      1. , <code>10101010 &amp; 00001111</code>  <code>00001010</code> . <br><br>     .    0  1.     1, 2, 3, 4   1, 10, 11, 100.  ,         0. <br><br>      ,  ,    .    0,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons nous connecter avec des voisins sur le SW, √† l'exception de la premi√®re cellule de chaque ligne qui ne l'a pas. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed1/f7a/73c/ed1f7a73c9e09970a041e4596668626b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connexion du NE au SW pour les lignes paires.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - width - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les lignes impaires suivent la m√™me logique, mais dans une image miroir. </font><font style="vertical-align: inherit;">Apr√®s avoir termin√© ce processus, tous les voisins de notre r√©seau sont connect√©s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((z &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cell.SetNeighbor(HexDirection.SW, cells[i - width - <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cell.SetNeighbor(HexDirection.SW, cells[i - width]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; width - <span class="hljs-number"><span class="hljs-number">1</span></span>) { cell.SetNeighbor(HexDirection.SE, cells[i - width + <span class="hljs-number"><span class="hljs-number">1</span></span>]); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00b/eee/ff1/00beeeff163b36232bd37f6076c34c90.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous les voisins sont connect√©s. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, toutes les cellules ne sont pas connect√©es √† exactement six voisins. </font><font style="vertical-align: inherit;">Les cellules √† la limite de la grille ont au moins deux et pas plus de cinq voisins. </font><font style="vertical-align: inherit;">Et cela doit √™tre pris en compte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/4a9/1c5/e7a4a91c55e7cc2574eed105f7b9a110.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voisins pour chaque cellule. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©lange de couleurs </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le m√©lange des couleurs compliquera la triangulation de chaque cellule. </font><font style="vertical-align: inherit;">Par cons√©quent, s√©parons le code de triangulation dans une partie distincte. </font><font style="vertical-align: inherit;">Puisque nous avons maintenant des directions, utilisons-les plut√¥t que des indices num√©riques pour indiquer les pi√®ces.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++) { Triangulate(d, cell); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; AddTriangle( center, center + HexMetrics.corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction], center + HexMetrics.corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] ); AddTriangleColor(cell.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, lorsque nous utilisons des directions, il serait pratique d'obtenir des angles avec des directions et de ne pas effectuer la conversion en index. </font></font><br><br><pre> <code class="cs hljs"> AddTriangle( center, center + HexMetrics.GetFirstCorner(direction), center + HexMetrics.GetSecondCorner(direction) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ce faire, vous devez ajouter √† </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deux m√©thodes statiques. </font><font style="vertical-align: inherit;">En prime, cela nous permet de rendre priv√© le tableau des angles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] corners = { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, -outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(-innerRadius, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * outerRadius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, outerRadius) }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plusieurs couleurs sur un triangle </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, la m√©thode </font></font><code>HexMesh.AddTriangleColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'a qu'un seul argument de couleur. </font><font style="vertical-align: inherit;">Il ne peut cr√©er qu'un triangle de couleur unie. </font><font style="vertical-align: inherit;">Cr√©ons une alternative qui prend en charge des couleurs distinctes pour chaque sommet.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color c1, Color c2, Color c3</span></span></span><span class="hljs-function">)</span></span> { colors.Add(c1); colors.Add(c2); colors.Add(c3); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons commencer √† m√©langer les couleurs! </font><font style="vertical-align: inherit;">Commen√ßons par utiliser simplement la couleur voisine pour les deux autres sommets.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; AddTriangle( center, center + HexMetrics.GetFirstCorner(direction), center + HexMetrics.GetSecondCorner(direction) ); HexCell neighbor = cell.GetNeighbor(direction); AddTriangleColor(cell.color, neighbor.color, neighbor.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, cela conduit √† </font></font><code>NullReferenceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, parce que les cellules √† la fronti√®re n'ont pas six voisins. </font><font style="vertical-align: inherit;">Que faire en cas de p√©nurie de voisin? </font><font style="vertical-align: inherit;">Soyons pragmatiques et utilisons la cellule elle-m√™me comme remplacement.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(direction) ?? cell;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que fait l'op√©rateur ??</font></font></b> <div class="spoiler_text">    null-coalescing operator.   ,  <code>a ?? b</code> ‚Äî      <code>a != null ? a : b</code> . <br><br>   ,     -   Unity   .           <code>null</code> .        . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/375/558/667/3755586675e7126b25e776f1283ec8b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a un m√©lange de couleurs, mais c'est mal fait.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O√π sont pass√©es les √©tiquettes de coordonn√©es?</font></font></b> <div class="spoiler_text">   ,       UI. </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moyenne des couleurs </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le m√©lange des couleurs fonctionne, mais les r√©sultats sont manifestement faux. </font><font style="vertical-align: inherit;">La couleur sur les bords des hexagones doit √™tre la moyenne de deux cellules adjacentes.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = cell.GetNeighbor(direction) ?? cell; Color edgeColor = (cell.color + neighbor.color) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; AddTriangleColor(cell.color, edgeColor, edgeColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aff/079/b26/aff079b261e39c1959d004c0ddf3a58f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©lange sur les c√¥tes. </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous m√©langions sur les bords, nous obtenons toujours des bordures de couleurs nettes. </font><font style="vertical-align: inherit;">Cela se produit car chaque sommet de l'hexagone est partag√© par trois hexagones.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/8f2/507/19e8f2507f011213c1514ea20ce04906.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trois voisins, quatre couleurs. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela signifie que nous devons √©galement tenir compte des voisins dans les directions pr√©c√©dente et suivante. </font><font style="vertical-align: inherit;">Autrement dit, nous obtenons quatre couleurs en deux ensembles de trois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutons </font></font><code>HexDirectionExtensions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deux m√©thodes d'addition pour une transition pratique vers les directions pr√©c√©dente et suivante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Previous</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction == HexDirection.NE ? HexDirection.NW : (direction - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction == HexDirection.NW ? HexDirection.NE : (direction + <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, nous pouvons obtenir les trois voisins et effectuer un m√©lange √† trois voies. </font></font><br><br><pre> <code class="cs hljs"> HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell; HexCell neighbor = cell.GetNeighbor(direction) ?? cell; HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell; AddTriangleColor( cell.color, (cell.color + prevNeighbor.color + neighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span>, (cell.color + neighbor.color + nextNeighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/b19/778/430b197786bb2bde51fb528946561733.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©langez dans les coins. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous obtenons donc les transitions de couleurs correctes, √† l'exception de la bordure de maillage. </font><font style="vertical-align: inherit;">Les cellules de bordure ne sont pas coh√©rentes avec les couleurs des voisins manquants, donc ici nous voyons toujours des bordures nettes. </font><font style="vertical-align: inherit;">Cependant, en g√©n√©ral, notre approche actuelle ne donne pas de bons r√©sultats. </font><font style="vertical-align: inherit;">Nous avons besoin d'une meilleure strat√©gie. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zones de m√©lange </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le m√©lange sur toute la surface de l'hexagone conduit √† un chaos flou. </font><font style="vertical-align: inherit;">Nous ne pouvons pas voir clairement les cellules individuelles. </font><font style="vertical-align: inherit;">Les r√©sultats peuvent √™tre grandement am√©lior√©s en m√©langeant uniquement √† c√¥t√© des bords des hexagones. </font><font style="vertical-align: inherit;">Dans ce cas, la r√©gion int√©rieure des hexagones conservera une couleur unie.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53e/82a/ff6/53e82aff62f060a51ef5645accd45d03.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ombrage continu des cents avec zones de m√©lange. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle devrait √™tre la taille de la r√©gion solide par rapport √† la r√©gion de m√©lange? </font><font style="vertical-align: inherit;">Des distributions diff√©rentes conduisent √† des r√©sultats diff√©rents. </font><font style="vertical-align: inherit;">Nous d√©finirons cette zone comme une fraction du rayon ext√©rieur. </font><font style="vertical-align: inherit;">Soit √©gal √† 75%. </font><font style="vertical-align: inherit;">Cela nous m√®nera √† deux nouvelles mesures, totalisant 100%.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> solidFactor = <span class="hljs-number"><span class="hljs-number">0.75f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blendFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> - solidFactor;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En cr√©ant ce nouveau facteur de remplissage solide, nous pouvons √©crire des m√©thodes pour obtenir les angles des hexagones internes solides. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFirstSolidCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] * solidFactor; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSecondSolidCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>] * solidFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, modifiez- </font></font><code>HexMesh.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le pour qu'il utilise ces angles d'ombrage solides au lieu des angles d'origine. </font><font style="vertical-align: inherit;">Nous laissons les couleurs les m√™mes pour l'instant.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle( center, center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d40/eb5/326/d40eb5326b0e0457e55ae2752897efc9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hexagones solides sans bords.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation des zones de m√©lange </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons remplir l'espace vide que nous avons cr√©√© en r√©duisant les triangles. </font><font style="vertical-align: inherit;">Dans chaque direction, cet espace a la forme d'un trap√®ze. </font><font style="vertical-align: inherit;">Pour le couvrir, vous pouvez utiliser le quadrangle (quad). </font><font style="vertical-align: inherit;">Par cons√©quent, nous allons cr√©er des m√©thodes pour ajouter un quadrilat√®re et ses couleurs.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2f/bc9/ce5/c2fbc9ce504e0e8df61b194f20c83f3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√¥te trap√©zo√Ødale.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); vertices.Add(v4); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">3</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color c1, Color c2, Color c3, Color c4</span></span></span><span class="hljs-function">)</span></span> { colors.Add(c1); colors.Add(c2); colors.Add(c3); colors.Add(c4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On le refait </font></font><code>HexMesh.Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour que le triangle re√ßoive une couleur, et le quadrilat√®re r√©alise un m√©lange entre une couleur unie et les couleurs de deux angles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); AddTriangle(center, v1, v2); AddTriangleColor(cell.color); Vector3 v3 = center + HexMetrics.GetFirstCorner(direction); Vector3 v4 = center + HexMetrics.GetSecondCorner(direction); AddQuad(v1, v2, v3, v4); HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell; HexCell neighbor = cell.GetNeighbor(direction) ?? cell; HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell; AddQuadColor( cell.color, cell.color, (cell.color + prevNeighbor.color + neighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span>, (cell.color + neighbor.color + nextNeighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span> ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aea/8de/d01/aea8ded01fc8928ec64293b11b335a91.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©lange avec des c√¥tes trap√©zo√Ødales.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ponts entre les c√¥tes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'image s'am√©liore, mais le travail n'est pas encore termin√©. </font><font style="vertical-align: inherit;">Le m√©lange des couleurs entre deux voisins est contamin√© par les cellules voisines. </font><font style="vertical-align: inherit;">Pour √©viter cela, nous devons couper les coins du trap√®ze et le transformer en rectangle. </font><font style="vertical-align: inherit;">Apr√®s cela, il cr√©era un pont entre la cellule et son voisin, laissant des lacunes sur les c√¥t√©s.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b76/acf/602/b76acf602ad32b7001117a17c0e6c72f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le pont entre les c√¥tes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons trouver de nouvelles positions </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en commen√ßant par </font></font><code>v1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis en longeant le pont jusqu'au bord de la cellule. </font><font style="vertical-align: inherit;">Quel sera le d√©placement du pont? </font><font style="vertical-align: inherit;">Nous pouvons le trouver en prenant le point m√©dian entre les deux angles correspondants, puis en lui appliquant le coefficient de m√©lange. </font><font style="vertical-align: inherit;">Cela fera l'affaire </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * blendFactor; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De retour √† </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, il sera d√©sormais logique d'ajouter une option </font></font><code>AddQuadColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui ne n√©cessite que deux couleurs.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color c1, Color c2</span></span></span><span class="hljs-function">)</span></span> { colors.Add(c1); colors.Add(c1); colors.Add(c2); colors.Add(c2); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changez-le </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il cr√©e des ponts correctement m√©lang√©s entre voisins.</font></font><br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; AddQuad(v1, v2, v3, v4); HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell; HexCell neighbor = cell.GetNeighbor(direction) ?? cell; HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell; AddQuadColor(cell.color, (cell.color + neighbor.color) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/0bd/fb3/2880bdfb3ae5b97a5907164fc8b71774.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ponts correctement peints avec des espaces d'angle.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Combler les lacunes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons maintenant form√© un espace triangulaire √† la jonction de trois cellules. </font><font style="vertical-align: inherit;">Nous avons obtenu ces lacunes en d√©coupant les c√¥t√©s triangulaires du trap√®ze. </font><font style="vertical-align: inherit;">R√©cup√©rons ces triangles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consid√©rons d'abord un triangle se connectant √† un voisin pr√©c√©dent. </font><font style="vertical-align: inherit;">Son premier sommet a une couleur de cellule. </font><font style="vertical-align: inherit;">La couleur du deuxi√®me pic sera un m√©lange de trois couleurs. </font><font style="vertical-align: inherit;">Et le dernier pic aura la m√™me couleur que le point au milieu du pont.</font></font><br><br><pre> <code class="cs hljs"> Color bridgeColor = (cell.color + neighbor.color) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; AddQuadColor(cell.color, bridgeColor); AddTriangle(v1, center + HexMetrics.GetFirstCorner(direction), v3); AddTriangleColor( cell.color, (cell.color + prevNeighbor.color + neighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span>, bridgeColor );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7f/d75/a50/b7fd75a50368ba2bcb79595fa1c58329.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Presque tout est pr√™t. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre triangle fonctionne de la m√™me mani√®re, sauf que le pont ne touche pas le troisi√®me, mais le deuxi√®me pic.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(v2, v4, center + HexMetrics.GetSecondCorner(direction)); AddTriangleColor( cell.color, bridgeColor, (cell.color + neighbor.color + nextNeighbor.color) / <span class="hljs-number"><span class="hljs-number">3f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a5/7b2/d71/9a57b2d71d5db4aa2c22a2aba954babe.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coloration compl√®te. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons maintenant de belles zones de m√©lange que nous pouvons donner √† n'importe quelle taille. </font><font style="vertical-align: inherit;">Les bords peuvent √™tre flous ou nets comme vous le souhaitez. </font><font style="vertical-align: inherit;">Mais vous pouvez voir que la fusion pr√®s de la bordure du maillage n'est toujours pas impl√©ment√©e correctement. </font><font style="vertical-align: inherit;">Et encore une fois, nous le laisserons pour plus tard, en nous concentrant sur un autre sujet pour l'instant.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais les transitions entre les couleurs sont toujours laides</font></font></b> <div class="spoiler_text">     .            .            . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fusion de c√¥tes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetez un ≈ìil √† la topologie de notre grille. </font><font style="vertical-align: inherit;">Quelles formes sont visibles ici? </font><font style="vertical-align: inherit;">Si vous ne faites pas attention √† la fronti√®re, nous pouvons distinguer trois types de formulaires distincts. </font><font style="vertical-align: inherit;">Il existe des hexagones monochromes, des rectangles bicolores et des triangles tricolores. </font><font style="vertical-align: inherit;">Ces trois couleurs apparaissent √† la jonction des trois cellules.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a27/370/ae7/a27370ae7474595516c3186adb393590.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trois structures visuelles. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, tous les deux hexagones sont reli√©s par un pont rectangulaire. </font><font style="vertical-align: inherit;">Et tous les trois hexagones sont reli√©s par un triangle. </font><font style="vertical-align: inherit;">Cependant, nous effectuons une triangulation plus complexe. </font><font style="vertical-align: inherit;">Maintenant, nous utilisons deux quadrangles au lieu d'un pour connecter une paire d'hexagones. </font><font style="vertical-align: inherit;">Et pour relier les trois hexagones, nous utilisons six triangles. </font><font style="vertical-align: inherit;">C'est trop redondant. </font><font style="vertical-align: inherit;">De plus, si nous devions nous connecter directement √† une forme, nous n'aurions pas besoin de faire la moyenne des couleurs. </font><font style="vertical-align: inherit;">Par cons√©quent, nous pourrions nous d√©brouiller avec moins de complexit√©, moins de travail et moins de triangles.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5d/448/ef3/e5d448ef31208fd42f3e7e73138c3b48.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus dur que n√©cessaire.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi en avons-nous m√™me besoin?</font></font></b> <div class="spoiler_text"> ,        .   ,     ,   .   ,        ,     .       ,   ,   . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pontage direct </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nos ponts entre les nervures se composent de deux quadrangles. Pour les √©tendre √† l'hexagone suivant, nous devons doubler la longueur du pont. Cela signifie que nous n'avons plus besoin de faire la moyenne de deux angles </font></font><code>HexMetrics.GetBridge</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Au lieu de cela, nous les ajoutons simplement puis multiplions par le facteur de m√©lange.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBridge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * blendFactor; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f16/8d6/33f/f168d633fff07b5ecd6bf361e14e0edd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les ponts s'√©tendent sur toute la longueur et se chevauchent. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les ponts cr√©ent d√©sormais des connexions directes entre les hexagones. </font><font style="vertical-align: inherit;">Mais nous g√©n√©rons toujours deux quadrangles par connexion, un dans chaque direction. </font><font style="vertical-align: inherit;">Autrement dit, un seul d'entre eux devrait cr√©er des ponts entre deux cellules. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplifions d'abord notre code de triangulation. </font><font style="vertical-align: inherit;">Nous supprimerons tout ce qui concerne les triangles de bords et le m√©lange des couleurs. </font><font style="vertical-align: inherit;">D√©placez ensuite le code qui ajoute le quadrilat√®re du pont √† la nouvelle m√©thode. </font><font style="vertical-align: inherit;">Nous passons les deux premiers sommets √† cette m√©thode pour ne pas avoir √† les recalculer.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.transform.localPosition; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); AddTriangle(center, v1, v2); AddTriangleColor(cell.color); TriangulateConnection(direction, cell, v1, v2); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction) ?? cell; Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; AddQuad(v1, v2, v3, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons facilement limiter la triangulation des compos√©s. </font><font style="vertical-align: inherit;">Pour commencer, nous ajouterons le pont uniquement lorsque vous travaillerez avec la connexion NE.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction == HexDirection.NE) { TriangulateConnection(direction, cell, v1, v2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfa/7ac/53f/cfa7ac53f3fbab322c4c481f29ec1cac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les ponts sont uniquement en direction de NE. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble que nous pouvons couvrir tous les compos√©s en les triangulant uniquement dans les trois premi√®res directions: NE, E et SE.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, v2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/568/698/e07/568698e079839a5ff4108083c6f71d8d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous les ponts internes et les ponts aux fronti√®res. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons couvert toutes les connexions entre deux cellules voisines. </font><font style="vertical-align: inherit;">Mais nous avons √©galement obtenu des ponts menant de la cellule √† nulle part. </font><font style="vertical-align: inherit;">D√©barrassons-nous d'eux, sortons </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quand les voisins sont absents. </font><font style="vertical-align: inherit;">Autrement dit, nous n'avons plus besoin de remplacer les voisins manquants par la cellule elle-m√™me.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a2/54c/21d/5a254c21d71cf66817a1ee42b7f02ddd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seuls les ponts internes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Articulations triangulaires </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons maintenant refermer les espaces triangulaires. </font><font style="vertical-align: inherit;">Faisons cela pour un triangle se connectant au prochain voisin. </font><font style="vertical-align: inherit;">Et cela ne doit √™tre fait √† nouveau que lorsqu'un voisin existe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { AddTriangle(v2, v4, v2); AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle sera la position du troisi√®me pic? </font><font style="vertical-align: inherit;">J'ai ins√©r√© en remplacement </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais c'est √©videmment faux. </font><font style="vertical-align: inherit;">√âtant donn√© que chaque bord de ces triangles est connect√© au pont, nous pouvons le trouver en marchant le long du pont jusqu'au prochain voisin.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(v2, v4, v2 + HexMetrics.GetBridge(direction.Next()));</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5c/256/bde/b5c256bde3a05d41287ca96007e208f4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous faisons √† nouveau une triangulation compl√®te. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avons-nous fini? </font><font style="vertical-align: inherit;">Pas encore, car maintenant nous cr√©ons des triangles qui se chevauchent. </font><font style="vertical-align: inherit;">√âtant donn√© que les trois cellules ont une connexion triangulaire commune, nous devons les ajouter pour seulement deux connexions. </font><font style="vertical-align: inherit;">Par cons√©quent, NE et E. feront l'affaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { AddTriangle(v2, v4, v2 + HexMetrics.GetBridge(direction.Next())); AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 3: hauteurs </font></font></h1><br><h2>  Table des mati√®res </h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez la hauteur des cellules. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulez les pentes. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ins√©rez les rebords. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Combinez corniches et falaises. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans cette partie du didacticiel, nous ajouterons la prise en charge de diff√©rents niveaux de hauteur et cr√©erons des transitions sp√©ciales entre eux. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8da/24a/e1f/8da24ae1f70e4770264ed0ab05d183ef.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauteurs et rebords.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hauteur de cellule </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons divis√© notre carte en cellules distinctes couvrant une zone plate. </font><font style="vertical-align: inherit;">Nous allons maintenant donner √† chaque cellule son propre niveau de hauteur. </font><font style="vertical-align: inherit;">Nous utiliserons des niveaux d'√©l√©vation discrets pour les stocker sous forme de champ entier dans </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle taille peut avoir chaque niveau de hauteur suivant? </font><font style="vertical-align: inherit;">Nous pouvons utiliser n'importe quelle valeur, nous allons donc la d√©finir comme une autre constante </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous utiliserons un pas de cinq unit√©s pour que les transitions soient clairement visibles. </font><font style="vertical-align: inherit;">Dans un vrai jeu, j'utiliserais un pas plus petit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationStep = <span class="hljs-number"><span class="hljs-number">5f</span></span>;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changer les cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous ne pouvions changer que la couleur de la cellule, mais maintenant nous pouvons changer sa hauteur. </font><font style="vertical-align: inherit;">Par cons√©quent, la m√©thode </font></font><code>HexGrid.ColorCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne nous suffit pas. </font><font style="vertical-align: inherit;">De plus, √† l'avenir, nous pourrons ajouter d'autres options d'√©dition de cellules, nous avons donc besoin d'une nouvelle approche. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renommer </font></font><code>ColorCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans </font></font><code>GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et faire en </font><font style="vertical-align: inherit;">sorte que ce sera plut√¥t revenir cellule de couleur de r√©f√©rence une cellule dans une position pr√©d√©termin√©e. </font><font style="vertical-align: inherit;">Comme cette m√©thode ne change rien d'autre, nous devons imm√©diatement trianguler les cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { position = transform.InverseTransformPoint(position); HexCoordinates coordinates = HexCoordinates.FromPosition(position); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[index]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'√©diteur s'occupe maintenant du changement de cellule. </font><font style="vertical-align: inherit;">Une fois les travaux termin√©s, la grille doit √™tre √† nouveau triangul√©e. </font><font style="vertical-align: inherit;">Pour ce faire, ajoutez une m√©thode g√©n√©rale </font></font><code>HexGrid.Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changez </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il puisse travailler avec de nouvelles m√©thodes. </font><font style="vertical-align: inherit;">Donnons-lui une nouvelle m√©thode </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qui traitera toutes les modifications apport√©es √† la cellule, apr√®s quoi elle mettra √† jour la grille.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCell(hexGrid.GetCell(hit.point)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; hexGrid.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons modifier les hauteurs simplement en attribuant √† la cellule souhait√©e le niveau de hauteur souhait√©. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> activeElevation; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.elevation = activeElevation; hexGrid.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme pour les couleurs, nous avons besoin d'une m√©thode pour d√©finir le niveau de hauteur actif, que nous associerons √† l'interface utilisateur. </font><font style="vertical-align: inherit;">Pour s√©lectionner des valeurs dans l'intervalle de hauteur, nous utilisons le curseur. </font><font style="vertical-align: inherit;">Puisque les curseurs fonctionnent avec float, notre m√©thode n√©cessite un param√®tre de type float. </font><font style="vertical-align: inherit;">Nous allons simplement le convertir en entier.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElevation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation</span></span></span><span class="hljs-function">)</span></span> { activeElevation = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)elevation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un curseur sur la toile ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameObject / Create / Slider</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et placez-le sous le panneau de couleurs. </font><font style="vertical-align: inherit;">Nous le rendons vertical, de bas en haut, pour qu'il corresponde visuellement aux niveaux de hauteurs. </font><font style="vertical-align: inherit;">Nous le limitons √† des entiers et cr√©ons un intervalle appropri√©, par exemple de 0 √† 6. Ensuite, nous attachons son √©v√©nement </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Value Changed</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† la m√©thode d' </font></font><code>SetElevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objet </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Editor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La m√©thode doit √™tre s√©lectionn√©e dans la liste dynamique pour √™tre appel√©e avec la valeur du curseur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/05f/6c5/93c/05f6c593cc553c4f4a86f9c2e9012156.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c6/0a5/e8b/7c60a5e8bfebd2ec87d2daaeeb148be6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur de hauteur.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visualisation de la hauteur </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors du changement d'une cellule, nous d√©finissons maintenant la couleur et la hauteur. </font><font style="vertical-align: inherit;">Bien que dans l'inspecteur, nous puissions voir que la hauteur change r√©ellement, le processus de triangulation l'ignore toujours. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il nous suffit de changer la position locale verticale de la cellule lors du changement de hauteur. </font><font style="vertical-align: inherit;">Pour plus de commodit√©, rendons la m√©thode </font></font><code>HexCell.elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">priv√©e et ajoutons une propri√©t√© g√©n√©rale </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons maintenant modifier la position verticale de la cellule lors de la modification de la hauteur. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, cela n√©cessite de petites modifications </font></font><code>HexMapEditor.EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.Elevation = activeElevation; hexGrid.Refresh(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/652/5de/6eb/6525de6ebae59208507af3e8b744bab5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cellules de hauteurs diff√©rentes.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le collisionneur de mailles change-t-il pour s'adapter √† la nouvelle hauteur?</font></font></b> <div class="spoiler_text">    Unity          mesh collider  null.  ,    ,      null    .   .     (     )  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La hauteur des cellules est d√©sormais visible, mais il y a deux probl√®mes. </font><font style="vertical-align: inherit;">Tout d'abord. </font><font style="vertical-align: inherit;">les √©tiquettes des cellules disparaissent sous les cellules sur√©lev√©es. </font><font style="vertical-align: inherit;">Deuxi√®mement, les connexions entre les cellules ignorent la hauteur. </font><font style="vertical-align: inherit;">Corrigeons-le.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modifier la position des √©tiquettes de cellule </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actuellement, les √©tiquettes d'interface utilisateur pour les cellules sont cr√©√©es et plac√©es une seule fois, apr√®s quoi nous les oublions. </font><font style="vertical-align: inherit;">Pour mettre √† jour leurs positions verticales, nous devons les suivre. </font><font style="vertical-align: inherit;">Donnons √† chacun un </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien vers </font></font><code>RectTransform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ses √©tiquettes d'interface utilisateur afin que vous puissiez le mettre √† jour plus tard.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RectTransform uiRect;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attribuez-les √† la fin </font></font><code>HexGrid.CreateCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.uiRect = label.rectTransform; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant d√©velopper la propri√©t√© </font></font><code>HexCell.Elevation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'elle modifie √©galement la position de l'interface utilisateur de la cellule. </font><font style="vertical-align: inherit;">√âtant donn√© que le maillage de la toile des hexagones est tourn√©, les √©tiquettes doivent √™tre d√©plac√©es dans le sens n√©gatif le long de l'axe Z, et non dans le c√¥t√© positif de l'axe Y.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = elevation * -HexMetrics.elevationStep; uiRect.localPosition = uiPosition; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c72/b81/c97/c72b81c970b2bddfe2b2ce6d22471dc0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags avec hauteur.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ation de pistes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous devons convertir les connexions de cellules plates en pentes. </font><font style="vertical-align: inherit;">Cela se fait en </font></font><code>HexMesh.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans le cas des connexions de bord, nous devons red√©finir la hauteur de l'autre extr√©mit√© du pont.</font></font><br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Elevation * HexMetrics.elevationStep;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dans le cas des joints d'angle, nous devons faire de m√™me avec le pont vers le prochain voisin. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Elevation * HexMetrics.elevationStep; AddTriangle(v2, v4, v5); AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49b/548/792/49b5487921c6844b7a282e049a97bbd9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connexion en tenant compte de la hauteur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons maintenant un support pour les cellules √† diff√©rentes hauteurs avec les articulations inclin√©es correctes entre elles. </font><font style="vertical-align: inherit;">Mais ne nous arr√™tons pas l√†. </font><font style="vertical-align: inherit;">Nous rendrons ces pistes plus int√©ressantes. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Articulations nervur√©es avec rebords </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les pentes droites ne semblent pas tr√®s attrayantes. </font><font style="vertical-align: inherit;">Nous pouvons les diviser en plusieurs √©tapes en ajoutant des √©tapes. </font><font style="vertical-align: inherit;">Cette approche est utilis√©e dans le jeu Endless Legend. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, nous pouvons ins√©rer deux rebords sur chaque pente. </font><font style="vertical-align: inherit;">En cons√©quence, une grande pente se transforme en trois petites, entre lesquelles se trouvent deux zones planes. </font><font style="vertical-align: inherit;">Pour trianguler un tel sch√©ma, nous devrons s√©parer chaque connexion en cinq √©tapes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce3/08b/82d/ce308b82db1bb0c72c387cc9da480d54.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deux corniches sur la pente. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons d√©finir le nombre d'√©tapes pour la pente </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et calculer le nombre d'√©tapes en fonction de cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terracesPerSlope = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> terraceSteps = terracesPerSlope * <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Id√©alement, nous pourrions simplement interpoler chaque √©tape le long de la pente. </font><font style="vertical-align: inherit;">Mais ce n'est pas tout √† fait trivial, car la coordonn√©e Y ne devrait changer qu'√† des √©tapes impaires. </font><font style="vertical-align: inherit;">Sinon, nous n'aurons pas de rebords plats. </font><font style="vertical-align: inherit;">Ajoutons une m√©thode d'interpolation sp√©ciale pour cela </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'interpolation horizontale est simple si nous connaissons la taille de l'√©tape d'interpolation. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> horizontalTerraceStepSize = <span class="hljs-number"><span class="hljs-number">1f</span></span> / terraceSteps; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = step * HexMetrics.horizontalTerraceStepSize; ax += (bx - ax) * h; az += (bz - az) * h; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment fonctionne l'interpolation entre deux valeurs?</font></font></b> <div class="spoiler_text">     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.23ex" height="1.523ex" viewBox="0 -535.3 529.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-61" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5">a</script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-87"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88">b</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.998ex" height="2.074ex" viewBox="0 -772.3 429.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-62" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6">b</script>      <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-89"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-90">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.84ex" height="1.936ex" viewBox="0 -713 361.5 833.5" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-74" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7">t</script>  .  Quand <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-91"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="0.84ex" height="1.936ex" viewBox="0 -713 361.5 833.5" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-74" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8">t</script>  0,    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">a</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.23ex" height="1.523ex" viewBox="0 -535.3 529.5 655.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/424257/&amp;usg=ALkJrhgA9BU2O_f93yyPpyFU8akzVnQC5g#MJMATHI-61" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9">a</script>  .    1,    <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96">b</span></span></span><script type="math/tex" id="MathJax-Element-10">b</script>  .  Quand <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-97"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">t</span></span></span><script type="math/tex" id="MathJax-Element-11">t</script>  -  0  1, <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-99"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100">a</span></span></span><script type="math/tex" id="MathJax-Element-12">a</script>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-102">b</span></span></span><script type="math/tex" id="MathJax-Element-13">b</script>  .       : <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-103"><span class="MJXp-mo" id="MJXp-Span-104" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-105">1</span><span class="MJXp-mo" id="MJXp-Span-106" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">t</span><span class="MJXp-mo" id="MJXp-Span-108" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">a</span><span class="MJXp-mo" id="MJXp-Span-110" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-111">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-112">b</span></span></span><script type="math/tex" id="MathJax-Element-14">(1 - t)a + tb</script>  . <br><br>  ,  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-113"><span class="MJXp-mo" id="MJXp-Span-114" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-115">1</span><span class="MJXp-mo" id="MJXp-Span-116" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-117">t</span><span class="MJXp-mo" id="MJXp-Span-118" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119">a</span><span class="MJXp-mo" id="MJXp-Span-120" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122">b</span><span class="MJXp-mo" id="MJXp-Span-123" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124">a</span><span class="MJXp-mo" id="MJXp-Span-125" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-126">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127">a</span><span class="MJXp-mo" id="MJXp-Span-128" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">b</span><span class="MJXp-mo" id="MJXp-Span-131" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132">a</span><span class="MJXp-mo" id="MJXp-Span-133" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134">t</span><span class="MJXp-mo" id="MJXp-Span-135" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-136">b</span><span class="MJXp-mo" id="MJXp-Span-137" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-138">a</span><span class="MJXp-mo" id="MJXp-Span-139" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-15">(1 - t)a + tb = a - ta + tb = a + t(b - a)</script>  .        <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-140"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-141">a</span></span></span><script type="math/tex" id="MathJax-Element-16">a</script>  dans <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-142"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-143">b</span></span></span><script type="math/tex" id="MathJax-Element-17">b</script>   <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-144"><span class="MJXp-mo" id="MJXp-Span-145" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146">b</span><span class="MJXp-mo" id="MJXp-Span-147" style="margin-left: 0.267em; margin-right: 0.267em;">‚àí</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148">a</span><span class="MJXp-mo" id="MJXp-Span-149" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><script type="math/tex" id="MathJax-Element-18">(b - a)</script>  .  ,         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour changer Y uniquement aux √©tapes impaires, nous pouvons utiliser </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-150"><span class="MJXp-mo" id="MJXp-Span-151" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-152"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-153"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-154"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-155"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mo" id="MJXp-Span-156" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-157"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-158" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font></span><span class="MJXp-mrow" id="MJXp-Span-159"><span class="MJXp-mo" id="MJXp-Span-160" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-161"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19">(step + 1) / 2</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si nous utilisons la division enti√®re, cela transformera les s√©ries 1, 2, 3, 4 en 1, 1, 2, 2. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> verticalTerraceStepSize = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (terracesPerSlope + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 a, Vector3 b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = step * HexMetrics.horizontalTerraceStepSize; ax += (bx - ax) * h; az += (bz - az) * h; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = ((step + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>) * HexMetrics.verticalTerraceStepSize; ay += (<span class="hljs-keyword"><span class="hljs-keyword">by</span></span> - ay) * v; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutons √©galement une m√©thode pour interpoler les rebords des couleurs. </font><font style="vertical-align: inherit;">Il suffit de les interpoler comme si les connexions √©taient plates.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Color </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color a, Color b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> h = step * HexMetrics.horizontalTerraceStepSize; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Color.Lerp(a, b, h); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme la triangulation de la connexion de bord devient plus compliqu√©e, nous supprimons le code correspondant </font></font><code>HexMesh.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le pla√ßons dans une m√©thode distincte. </font><font style="vertical-align: inherit;">Dans les commentaires, je vais enregistrer le code source afin de pouvoir y faire r√©f√©rence √† l'avenir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Elevation * HexMetrics.elevationStep; TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); <span class="hljs-comment"><span class="hljs-comment">// AddQuad(v1, v2, v3, v4); // AddQuadColor(cell.color, neighbor.color); ‚Ä¶ } void TriangulateEdgeTerraces ( Vector3 beginLeft, Vector3 beginRight, HexCell beginCell, Vector3 endLeft, Vector3 endRight, HexCell endCell ) { AddQuad(beginLeft, beginRight, endLeft, endRight); AddQuadColor(beginCell.color, endCell.color); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par la toute premi√®re √©tape du processus. </font><font style="vertical-align: inherit;">Nous utiliserons nos m√©thodes d'interpolation sp√©ciales pour cr√©er le premier quad. </font><font style="vertical-align: inherit;">Dans ce cas, une courte pente doit √™tre cr√©√©e, plus raide que celle d'origine.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 beginLeft, Vector3 beginRight, HexCell beginCell, Vector3 endLeft, Vector3 endRight, HexCell endCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(beginRight, endRight, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddQuad(beginLeft, beginRight, v3, v4); AddQuadColor(beginCell.color, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/434/174/aea/434174aea469a4ba7da285ff02d4467a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re √©tape de la cr√©ation d'un rebord. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous allons imm√©diatement passer √† la derni√®re √©tape, en sautant tout le reste. </font><font style="vertical-align: inherit;">Cela compl√®tera la connexion des bords, bien que jusqu'√† pr√©sent avec une forme irr√©guli√®re.</font></font><br><br><pre> <code class="cs hljs"> AddQuad(beginLeft, beginRight, v3, v4); AddQuadColor(beginCell.color, c2); AddQuad(v3, v4, endLeft, endRight); AddQuadColor(c2, endCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6f/1be/b3e/c6f1beb3ee6663cf8984130dc3d9378e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derni√®re √©tape de la cr√©ation d'un rebord. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des √©tapes interm√©diaires peuvent √™tre ajout√©es via la boucle. </font><font style="vertical-align: inherit;">√Ä chaque √©tape, les deux derniers sommets pr√©c√©dents deviennent les nouveaux premiers. </font><font style="vertical-align: inherit;">Il en va de m√™me pour la couleur. </font><font style="vertical-align: inherit;">Apr√®s avoir calcul√© les nouveaux vecteurs et couleurs, un autre quad est ajout√©.</font></font><br><br><pre> <code class="cs hljs"> AddQuad(beginLeft, beginRight, v3, v4); AddQuadColor(beginCell.color, c2); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c2; v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, i); v4 = HexMetrics.TerraceLerp(beginRight, endRight, i); c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i); AddQuad(v1, v2, v3, v4); AddQuadColor(c1, c2); } AddQuad(v3, v4, endLeft, endRight); AddQuadColor(c2, endCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6d/20f/64c/e6d20f64c28feaa5329f085d8a5b673a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes les √©tapes interm√©diaires. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sormais, tous les joints de bord ont deux rebords, ou tout autre nombre que vous sp√©cifiez dans </font></font><code>HexMetrics.terracesPerSlope</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bien s√ªr, jusqu'√† ce que nous ayons cr√©√© des rebords pour les joints d'angle, nous laisserons cela pour plus tard.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f3/37b/4f9/4f337b4f9ba0092144e1148b10a4970b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tous les joints des bords ont des rebords. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Types de connexion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convertir tous les joints de bord en rebords n'est pas une si bonne id√©e. </font><font style="vertical-align: inherit;">Ils ne semblent bons que lorsque la diff√©rence de hauteur n'est que d'un niveau. </font><font style="vertical-align: inherit;">Mais avec une diff√©rence plus grande, des rebords √©troits sont cr√©√©s avec de grands √©carts entre eux, et cela n'a pas l'air tr√®s beau. </font><font style="vertical-align: inherit;">De plus, nous n'avons pas besoin de cr√©er de rebords pour tous les joints. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formalisons cela et d√©finissons trois types d'ar√™tes: un plan, une pente et une falaise. </font><font style="vertical-align: inherit;">Cr√©ons une √©num√©ration pour cela.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> HexEdgeType { Flat, Slope, Cliff }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment d√©terminer √† quel type de connexion nous avons affaire? </font><font style="vertical-align: inherit;">Pour ce faire, nous pouvons ajouter √† une </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode qui utilise deux niveaux de hauteur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation2</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si les hauteurs sont les m√™mes, nous aurons une nervure plate. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation1 == elevation2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Flat; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la diff√©rence de niveaux est √©gale √† un pas, alors c'est une pente. </font><font style="vertical-align: inherit;">Peu importe si elle monte ou descend. </font><font style="vertical-align: inherit;">Dans tous les autres cas, nous obtenons une pause.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> elevation2</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation1 == elevation2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Flat; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> delta = elevation2 - elevation1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (delta == <span class="hljs-number"><span class="hljs-number">1</span></span> || delta == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Slope; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexEdgeType.Cliff; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutons √©galement une m√©thode pratique </font></font><code>HexCell.GetEdgeType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour obtenir le type de bord de cellule dans une certaine direction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.GetEdgeType( elevation, neighbors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction].elevation ); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N'avons-nous pas besoin de v√©rifier si un voisin existe dans cette direction?</font></font></b> <div class="spoiler_text">   ,       ,     .      ,    <code>NullReferenceException</code> .       ,    ,    - .    ,     .       . <br><br> ,        ,  ,       .    - ,   <code>NullReferenceException</code> . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©er des corniches uniquement pour les pentes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous pouvons d√©terminer le type de connexion, nous pouvons d√©cider d'ins√©rer des corniches. </font><font style="vertical-align: inherit;">Changez </font></font><code>HexMesh.TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour qu'il cr√©e des corniches uniquement pour les pentes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-comment"><span class="hljs-comment">// AddQuad(v1, v2, v3, v4); // AddQuadColor(cell.color, neighbor.color);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ä ce stade, nous pouvons d√©commenter le code pr√©c√©demment comment√© afin qu'il puisse g√©rer les avions et les coupures. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddQuad(v1, v2, v3, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15a/bb8/1e6/15abb81e60a35fb6383ff8be8b0a17dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les marches sont cr√©√©es uniquement sur les pentes. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rebords avec rebords </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les joints d'angle sont plus complexes que les joints de bord car ils ne sont pas impliqu√©s dans deux, mais dans trois cellules. </font><font style="vertical-align: inherit;">Chaque coin est reli√© √† trois bords, qui peuvent √™tre des plans, des pentes ou des falaises. </font><font style="vertical-align: inherit;">Par cons√©quent, il existe de nombreuses configurations possibles. </font><font style="vertical-align: inherit;">Comme pour les articulations des c√¥tes, il est pr√©f√©rable d'ajouter la </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">triangulation </font><font style="vertical-align: inherit;">√† la </font><font style="vertical-align: inherit;">nouvelle m√©thode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre nouvelle m√©thode n√©cessitera les sommets d'un triangle angulaire et les cellules connect√©es. </font><font style="vertical-align: inherit;">Pour plus de commodit√©, organisons les connexions pour savoir quelle cellule a la plus petite hauteur. </font><font style="vertical-align: inherit;">Apr√®s cela, nous pouvons commencer √† travailler en bas √† gauche et √† droite.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b24/351/681/b243516810fc9f0e8c44a5cb12f74cff.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Joint d'angle.</font></font></i> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, je </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois d√©terminer laquelle des cellules est la plus basse. </font><font style="vertical-align: inherit;">Nous v√©rifions d'abord si la cellule triangul√©e est en dessous de ses voisins ou est au m√™me niveau avec le plus bas. </font><font style="vertical-align: inherit;">Si oui, alors nous pouvons l'utiliser comme cellule la plus basse.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Elevation * HexMetrics.elevationStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la v√©rification la plus profonde √©choue, cela signifie que le prochain voisin est la cellule la plus basse. </font><font style="vertical-align: inherit;">Pour une orientation correcte, nous devons faire pivoter le triangle dans le sens antihoraire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le premier test √©choue, vous devez comparer deux cellules voisines. </font><font style="vertical-align: inherit;">Si le voisin de la nervure est le plus bas, vous devez tourner dans le sens horaire, sinon - dans le sens antihoraire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner(v4, neighbor, v5, nextNeighbor, v2, cell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8a/736/794/f8a736794c4e52c54ab018dcd55feba0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tournez dans le sens antihoraire, pas de tour, rotation dans le sens horaire.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation des pentes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour savoir comment trianguler un angle, nous devons comprendre de quels types d'ar√™tes il s'agit. </font><font style="vertical-align: inherit;">Pour simplifier cette t√¢che, ajoutons √† </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une autre m√©thode pratique pour reconna√Ætre la pente entre deux cellules quelconques.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexEdgeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEdgeType</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell otherCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HexMetrics.GetEdgeType( elevation, otherCell.elevation ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons cette nouvelle m√©thode </font></font><code>HexMesh.TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour d√©terminer les types de bords gauche et droit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell); HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell); AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si les deux c√¥tes sont des pentes, nous aurons des rebords √† gauche et √† droite. </font><font style="vertical-align: inherit;">De plus, la cellule inf√©rieure √©tant la plus basse, nous savons que ces pentes montent. </font><font style="vertical-align: inherit;">De plus, les cellules gauche et droite ont la m√™me hauteur, c'est-√†-dire que la connexion du bord sup√©rieur est plate. </font><font style="vertical-align: inherit;">Nous pouvons d√©signer ce cas comme ¬´pente-pente-plan¬ª, ou MTP.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b75/4a3/f9e/b754a3f9eccdb6baada2a51fef2c4301.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deux pentes et un avion, SSP.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous v√©rifierons si nous sommes dans cette situation, et si c'est le cas, nous appellerons une nouvelle m√©thode </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apr√®s cela, nous reviendrons de la m√©thode. </font><font style="vertical-align: inherit;">Ins√©rez cette v√©rification avant l'ancien code de triangulation afin qu'il remplace le triangle d'origine.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell); HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous ne faisons rien √† l'int√©rieur </font></font><code>TriangulateCornerTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, certaines jonctions de coin avec deux pentes deviendront vides. </font><font style="vertical-align: inherit;">Le fait que la connexion devienne vide ou non d√©pend de la cellule la plus basse.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26b/a54/2ea/26ba542eaed793e064e478cbdbc5f109.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a un vide. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour combler le vide, nous devons connecter le rebord gauche et droit √† travers un espace. </font><font style="vertical-align: inherit;">L'approche ici est la m√™me que pour joindre des bords, mais √† l'int√©rieur d'un triangle tricolore au lieu d'un quadrilat√®re bicolore. </font><font style="vertical-align: inherit;">Commen√ßons √† nouveau avec la premi√®re √©tape, qui est maintenant un triangle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangle(begin, v3, v4); AddTriangleColor(beginCell.color, c3, c4); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebf/a76/823/ebfa76823e5dba45fd97daa1f052b1fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re √©tape du triangle. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et nous passons √† nouveau directement √† la derni√®re √©tape. </font><font style="vertical-align: inherit;">Il s'agit du quadrilat√®re formant un trap√®ze. </font><font style="vertical-align: inherit;">La seule diff√©rence avec les connexions de bord ici est que nous ne traitons pas avec deux, mais avec quatre couleurs.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v3, v4); AddTriangleColor(beginCell.color, c3, c4); AddQuad(v3, v4, left, right); AddQuadColor(c3, c4, leftCell.color, rightCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/ab2/20b/99eab220bcbdda36896dbb1640995b33.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derni√®re √©tape du quadrilat√®re. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes les √©tapes entre elles sont √©galement des quadrangles.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v3, v4); AddTriangleColor(beginCell.color, c3, c4); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v3; Vector3 v2 = v4; Color c1 = c3; Color c2 = c4; v3 = HexMetrics.TerraceLerp(begin, left, i); v4 = HexMetrics.TerraceLerp(begin, right, i); c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, i); AddQuad(v1, v2, v3, v4); AddQuadColor(c1, c2, c3, c4); } AddQuad(v3, v4, left, right); AddQuadColor(c3, c4, leftCell.color, rightCell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b46/8bb/c69/b468bbc6989ae33c9a810f5e641f2446.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toutes les √©tapes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deux variations de pente </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le cas √† deux pentes a deux variations avec des orientations diff√©rentes, selon laquelle des cellules est le fond. </font><font style="vertical-align: inherit;">Nous pouvons les trouver en v√©rifiant les combinaisons gauche-droite pour pente-plan et plan-pente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b17/736/3ca/b177363ca9391a96905ce2a0717020d9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATP et MSS. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le bord droit est plat, nous devrions commencer √† cr√©er des rebords sur la gauche et non sur le bas. </font><font style="vertical-align: inherit;">Si le bord gauche est plat, vous devez commencer par la droite.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( left, leftCell, right, rightCell, bottom, bottomCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour cette raison, les corniches contournent les cellules sans interruption jusqu'√† ce qu'elles atteignent la falaise ou la fin de la carte. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/359/68c/4d835968ce882e260a2b4f7ec23979ab.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des rebords solides. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fusion des pentes et des falaises </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que diriez-vous de relier la pente et la falaise? </font><font style="vertical-align: inherit;">Si nous savons que le bord gauche est une pente et le bord droit est une falaise, alors quel sera le bord sup√©rieur? </font><font style="vertical-align: inherit;">Il ne peut pas √™tre plat, mais il peut s'agir d'une pente ou d'une falaise.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd9/6bc/0d3/dd96bc0d3fb89e029687c7b9c9312cc5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/049/07d/d22/04907dd22fc5da80ba59fa2dbb6abb82.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/463/24c/c57/46324cc57e9c3e79a21378c932e09ed9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOS et COO. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutons une nouvelle m√©thode pour g√©rer tous les cas de pente-falaise.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elle doit √™tre appel√©e comme derni√®re option </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque le bord gauche est une pente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( left, leftCell, right, rightCell, bottom, bottomCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TriangulateCornerTerracesCliff( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment triangulons-nous cela? </font><font style="vertical-align: inherit;">Cette t√¢che peut √™tre divis√©e en deux parties: inf√©rieure et sup√©rieure.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie inf√©rieure </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La partie inf√©rieure a des rebords √† gauche et une falaise √† droite. </font><font style="vertical-align: inherit;">Nous devons en quelque sorte les combiner. </font><font style="vertical-align: inherit;">La fa√ßon la plus simple de le faire est de serrer les rebords pour qu'ils se rejoignent dans le coin droit. </font><font style="vertical-align: inherit;">Cela soul√®vera les rebords.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/8e7/d53/d118e7d538c25cba75a31ca37c6096cc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compression des rebords. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais en fait, nous ne voulons pas qu'ils se rencontrent dans le coin droit, car cela interf√©rerait avec les rebords qui peuvent exister ci-dessus. </font><font style="vertical-align: inherit;">De plus, nous pouvons faire face √† une tr√®s haute falaise, en raison de laquelle nous obtenons des triangles tr√®s tombants et minces. </font><font style="vertical-align: inherit;">Au lieu de cela, nous les compresserons jusqu'√† un point limite qui se trouve le long d'une falaise.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df5/131/efa/df5131efa8069569630306b4cc8eb9b6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compression √† la fronti√®re. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Positionnons le point limite un niveau au-dessus de la cellule du bas. </font><font style="vertical-align: inherit;">Vous pouvez le trouver par interpolation bas√©e sur la diff√©rence de hauteur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour nous assurer que nous l'avons correctement, nous couvrons toute la partie inf√©rieure avec un triangle. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); AddTriangle(begin, left, boundary); AddTriangleColor(beginCell.color, leftCell.color, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03e/534/ab9/03e534ab927d5709aca721ccfd9bdc80.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangle inf√©rieur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir plac√© la bordure au bon endroit, nous pouvons proc√©der √† la triangulation des rebords. </font><font style="vertical-align: inherit;">Reprenons seulement √† partir de la premi√®re √©tape.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c2/4fc/3c1/6c24fc3c19580573b89d3259b855a692.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re √©tape de compression. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette fois, la derni√®re √©tape sera √©galement un triangle.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); AddTriangle(v2, left, boundary); AddTriangleColor(c2, leftCell.color, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/035/6db/5cb/0356db5cbaf4bd936ea4235af34eb1d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derni√®re √©tape de compression. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et toutes les √©tapes interm√©diaires sont √©galement des triangles.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangle(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangle(v2, left, boundary); AddTriangleColor(c2, leftCell.color, boundaryColor);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/987/744/6e698774450ec3502f52537936d8a29e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corniches compress√©es.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ne pouvons-nous pas garder le niveau du rebord?</font></font></b> <div class="spoiler_text"> ,     ,       ,       .         .        ,          .    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ach√®vement du coin </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir termin√© le bas, vous pouvez aller au sommet. </font><font style="vertical-align: inherit;">Si le bord sup√©rieur est une pente, nous devrons √† nouveau relier les rebords et la falaise. </font><font style="vertical-align: inherit;">D√©pla√ßons donc ce code dans une m√©thode distincte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); TriangulateBoundaryTriangle( begin, beginCell, left, leftCell, boundary, boundaryColor ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangle(begin, v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangle(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangle(v2, left, boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, compl√©ter le sommet sera facile. </font><font style="vertical-align: inherit;">Si nous avons une pente, ajoutez le triangle pivot√© de la bordure. </font><font style="vertical-align: inherit;">Sinon, un simple triangle suffit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, right, b); Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b); TriangulateBoundaryTriangle( begin, beginCell, left, leftCell, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, leftCell, right, rightCell, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangle(left, right, boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc5/ed2/8fb/bc5ed28fbb4a1a1f0015dafac63f5ec0.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59c/45b/241/59c45b2413d30e196fc195796e4b07e5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulation compl√®te des deux parties.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cas en miroir </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons examin√© des cas de ¬´pente-falaise¬ª. </font><font style="vertical-align: inherit;">Il y a aussi deux √©tuis √† miroir, dont chacun a une falaise sur la gauche.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c00/726/f4f/c00726f4fc6ef078b33782047f4e6b4d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSS et CCA. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utiliserons l'approche pr√©c√©dente, avec de l√©g√®res diff√©rences dues √† un changement d'orientation. </font><font style="vertical-align: inherit;">Nous le copions </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et le modifions en cons√©quence.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); Vector3 boundary = Vector3.Lerp(begin, left, b); Color boundaryColor = Color.Lerp(beginCell.color, leftCell.color, b); TriangulateBoundaryTriangle( right, rightCell, begin, beginCell, boundary, boundaryColor ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { TriangulateBoundaryTriangle( left, leftCell, right, rightCell, boundary, boundaryColor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangle(left, right, boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez ces cas √† </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } TriangulateCornerCliffTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d9/a9b/7e6/3d9a9b7e606cefd475ca14f53a48a683.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/495/6f4/3234956f44e8bcbd63d055a9a7f89c36.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSS triangul√© et CCA.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Falaises doubles </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les seuls cas non plans restants sont les cellules inf√©rieures avec des falaises des deux c√¥t√©s. </font><font style="vertical-align: inherit;">Dans ce cas, la nervure sup√©rieure peut √™tre quelconque - plate, inclin√©e ou falaise. </font><font style="vertical-align: inherit;">Nous ne nous int√©ressons qu'au cas ¬´falaise-falaise-pente¬ª, car il n'aura que des corniches. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, il existe deux versions diff√©rentes de la "falaise-falaise-pente", selon le c√¥t√© le plus √©lev√©. </font><font style="vertical-align: inherit;">Ce sont des images miroir les unes des autres. </font><font style="vertical-align: inherit;">D√©signons-les comme OOSP et OOSL.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/038/df7/b9f038df7a7d23da542430652adbd038.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c3/0b2/013/3c30b2013db25c9288ad551ec529c07b.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/e0d/151/7aee0d1512d324b1bd3c8e91f1b4134d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOSP et OOSL. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons couvrir les deux cas en </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appelant des m√©thodes </font></font><code>TriangulateCornerCliffTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>TriangulateCornerTerracesCliff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec diff√©rentes rotations de cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { TriangulateCornerCliffTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerTerracesCliff( left, leftCell, right, rightCell, bottom, bottomCell ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, cela cr√©e une triangulation √©trange. </font><font style="vertical-align: inherit;">C'est parce que maintenant nous triangulons de haut en bas. </font><font style="vertical-align: inherit;">Pour cette raison, notre fronti√®re est interpol√©e comme n√©gative, ce qui est incorrect. </font><font style="vertical-align: inherit;">La solution ici est de toujours avoir des interpolateurs positifs.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerTerracesCliff</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (rightCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCornerCliffTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (leftCell.Elevation - beginCell.Elevation); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { b = -b; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae8/f3d/bf8/ae8f3dbf8d5e2781cff2437d8ce4ad70.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/710/922/0aa/7109220aa668eae0d9904f48d7bd30ee.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOSP et OOSL triangul√©s.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Balayer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous avons examin√© tous les cas qui n√©cessitent une manipulation sp√©ciale pour assurer la triangulation correcte des rebords. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/280/86f/dc228086f73f694a351ec127e0e75e45.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulation compl√®te avec rebords. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons nettoyer un peu en nous </font></font><code>TriangulateCorner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©barrassant des op√©rateurs </font></font><code>return</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et en utilisant des blocs √† la place </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateCorner</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 bottom, HexCell bottomCell, Vector3 left, HexCell leftCell, Vector3 right, HexCell rightCell </span></span></span><span class="hljs-function">)</span></span> { HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell); HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { TriangulateCornerTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( left, leftCell, right, rightCell, bottom, bottomCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerTerracesCliff( bottom, bottomCell, left, leftCell, right, rightCell ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rightEdgeType == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftEdgeType == HexEdgeType.Flat) { TriangulateCornerTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerCliffTerraces( bottom, bottomCell, left, leftCell, right, rightCell ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leftCell.Elevation &lt; rightCell.Elevation) { TriangulateCornerCliffTerraces( right, rightCell, bottom, bottomCell, left, leftCell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCornerTerracesCliff( left, leftCell, right, rightCell, bottom, bottomCell ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangle(bottom, left, right); AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le dernier bloc </font></font><code>else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">couvre tous les cas restants qui n'ont pas encore √©t√© couverts. </font><font style="vertical-align: inherit;">Ces cas sont RFP (avion-avion-avion), OOP, LLC et LLC. </font><font style="vertical-align: inherit;">Tous sont couverts par un triangle.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/4da/58b/9444da58b33b9558b88fa8bb80102e34.png"></div><br> <i>  .</i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">unitypackage</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424257/">https://habr.com/ru/post/fr424257/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424245/index.html">√âcrire un client Telegram est facile</a></li>
<li><a href="../fr424247/index.html">KotlinConf 2018 Live - regardez l'√©mission du 4 au 5 octobre</a></li>
<li><a href="../fr424249/index.html">Mat√©riel de la r√©union #RuPostgres - vid√©os, pr√©sentations, analyse du quiz et reportage photo</a></li>
<li><a href="../fr424251/index.html">Nous consid√©rons les statistiques sur les exp√©riences sur hh.ru</a></li>
<li><a href="../fr424255/index.html">Comment utiliser correctement l'analyse statique</a></li>
<li><a href="../fr424259/index.html">Security Week 36: Telnet devrait √™tre ferm√©</a></li>
<li><a href="../fr424261/index.html">Comment r√©soudre tout probl√®me de programmation</a></li>
<li><a href="../fr424263/index.html">Mise √† niveau d'IDA Pro. Nous r√©parons les jambages des modules processeurs</a></li>
<li><a href="../fr424265/index.html">Test du v√©lo √©lectrique Twitter Mantis E-1</a></li>
<li><a href="../fr424267/index.html">Comment d√©boguer un ECS auto-√©crit dans un navigateur sur un serveur de jeu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>