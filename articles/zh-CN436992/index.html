<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛄 🛂 🛌🏾 选择HTTP反向代理时的尝试和错误 🚩 🤞🏽 🤘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 

 今天，我们想谈谈Ostrovok.ru酒店预订服务团队如何解决微服务增长的问题，其任务是与我们的供应商交换信息。 关于他的经历告诉了Ostrovok.ru DevOps团队负责人。 


 最初，微服务很小，并且执行以下功能： 



- 接受本地服务的请求； 
- 向合作伙伴提出要...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>选择HTTP反向代理时的尝试和错误</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ostrovok/blog/436992/"> 大家好！ <br><br> 今天，我们想谈谈<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ostrovok.ru</a>酒店预订服务团队如何解决微服务增长的问题，其任务是与我们的供应商交换信息。 关于他的经历告诉了Ostrovok.ru DevOps团队负责人。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mb/qx/eh/mbqxehqjq4oabybefapvvbpqadg.png"></div><a name="habracut"></a><br> 最初，微服务很小，并且执行以下功能： <br><br><ul><li> 接受本地服务的请求； </li><li> 向合作伙伴提出要求； </li><li> 规范响应； </li><li> 将结果返回给查询服务。 </li></ul><br> 但是，随着时间的流逝，服务随着合作伙伴的数量和对他们的请求而增长。 <br><br> 随着服务的增长，各种问题开始出现。 不同的提供程序提出了自己的规则：有人限制最大连接数，有人将客户端限制在白名单中。 <br><cut></cut><br> 结果，我们必须解决以下问题： <br><br><ul><li> 最好有几个固定的外部IP地址，以便您可以将它们提供给合作伙伴，以将其添加到白名单中， </li><li> 与所有供应商只有一个连接池，以便在扩展我们的微服务时，连接数量保持最小， </li><li> 终止SSL并将<code>keepalive</code>放在一个位置，从而减轻合作伙伴本身的负担。 </li></ul><br> 他们想了很久，立即想知道该选择什么：Nginx或Haproxy。 <br> 最初，钟摆转向Nginx，因为与HTTP / HTTPS相关的大多数问题我都借助它来解决，并且始终对结果感到满意。 <br><br> 该方案很简单：在Nginx上向我们的新代理服务器发出了一个请求，请求的域名格式为<code>&lt;partner_tag&gt;.domain.local</code> ，在Nginx中有一个<code>map</code> ，其中<code>&lt;partner_tag&gt;</code>对应于合作伙伴的地址。 从<code>map</code>中获取了一个地址，并对该地址进行了<code>proxy_pass</code> 。 <br><br> 这是一个示例<code>map</code> ，我们使用它来解析域并从列表中选择上游： <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment">###     : &lt;tag&gt;.domain.local map $http_host $upstream_prefix { default 0; "~^([^\.]+)\." $1; } ###      map $upstream_prefix $upstream_address { include snippet.d/upstreams_map; default http://127.0.0.1:8080; } ###   upstream_host    upstream_address map $upstream_address $upstream_host { default 0; "~^https?://([^:]+)" $1; }</span></span></code> </pre><br> 这是“ <code>snippet.d/upstreams_map</code> ”的样子： <br><pre> <code class="nginx hljs">“one” “http://one.domain.net”; “two” “https://two.domain.org”;</code> </pre><br> 这里我们有<code>server{}</code> ： <br><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_http_version</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> <span class="hljs-variable"><span class="hljs-variable">$upstream_address</span></span><span class="hljs-variable"><span class="hljs-variable">$request_uri</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$upstream_host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-For <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-Port <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-Proto <span class="hljs-string"><span class="hljs-string">""</span></span>; } } <span class="hljs-comment"><span class="hljs-comment"># service for error handling and logging server { listen 127.0.0.1:8080; location / { return 400; } location /ngx_status/ { stub_status; } }</span></span></code> </pre><br> 一切都很酷，一切正常。 如果没有任何细微差别，可以结束本文。 <br><br> 使用proxy_pass时，通常，使用不带有<code>keepalive</code>的HTTP / 1.0协议，请求直接转到所需地址，并在响应完成后立即关闭。 即使我们<code>proxy_http_version 1.1</code> ，没有上游（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://nginx.org/ru/docs/http/ngx_http_proxy_module.html&amp;usg=ALkJrhi6o0xaKw6jQYgxE83R7w1_Fr0qEQ#proxy_">proxy_http_version</a> ）也不会改变。 <br><br> 怎么办 首先想到的是让所有供应商进入上游，服务器将成为我们所需供应商的地址，并在<code>map</code>保留<code>"tag" "upstream_name"</code> 。 <br><br> 添加另一个<code>map</code>以解析该方案： <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment">###     : &lt;tag&gt;.domain.local map $http_host $upstream_prefix { default 0; "~^([^\.]+)\." $1; } ###      map $upstream_prefix $upstream_address { include snippet.d/upstreams_map; default http://127.0.0.1:8080; } ###   upstream_host    upstream_address map $upstream_address $upstream_host { default 0; "~^https?://([^:]+)" $1; } ###   ,       https,    ,    -  http map $upstream_address $upstream_scheme { default "http://"; "~(https?://)" $1; }</span></span></code> </pre><br> 并使用标签名称创建<code>upstreams</code> ： <br><pre> <code class="nginx hljs"> <span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> one { <span class="hljs-attribute"><span class="hljs-attribute">keepalive</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> one.domain.com; } <span class="hljs-attribute"><span class="hljs-attribute">upstream</span></span> two { <span class="hljs-attribute"><span class="hljs-attribute">keepalive</span></span> <span class="hljs-number"><span class="hljs-number">64</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server</span></span> two.domain.net; }</code> </pre><br> 对服务器本身进行了少许修改，以考虑到方案，并使用上游名称代替地址： <br><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">proxy_http_version</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> <span class="hljs-variable"><span class="hljs-variable">$upstream_scheme</span></span><span class="hljs-variable"><span class="hljs-variable">$upstream_prefix</span></span><span class="hljs-variable"><span class="hljs-variable">$request_uri</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$upstream_host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-For <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-Port <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Forwarded-Proto <span class="hljs-string"><span class="hljs-string">""</span></span>; } } <span class="hljs-comment"><span class="hljs-comment"># service for error handling and logging server { listen 127.0.0.1:8080; location / { return 400; } location /ngx_status/ { stub_status; } }</span></span></code> </pre><br> 太好了 该解决方案有效，在每个上游添加<code>keepalive</code>指令，设置<code>proxy_http_version 1.1</code> ，-现在我们有了一个连接池，一切正常。 <br><br> 这次，您绝对可以完成文章，然后去喝茶。 还是不行 <br><br> 确实，当我们喝茶时，其中一个供应商可能会更改同一域（例如，亚马逊）下的IP地址或地址组，因此其中一个供应商可能会在我们茶会的高峰期倒下。 <br><br> 好吧，该怎么办？  Nginx有一个有趣的细微差别：在重新加载期间，它可以将<code>upstream</code>内部的服务器清醒到新地址并向其发送流量。 一般来说，也是一种解决方案。 每5分钟投入<code>cron reload nginx</code>并继续喝茶。 <br><br> 但是在我看来，这似乎仍然是一个一般的决定，所以我开始对Haproxy产生疑问。 <br><br>  Haproxy可以指定<code>dns resolvers</code>和配置<code>dns cache</code> 。 因此，如果Haproxy中的条目已过期，则Haproxy将更新<code>dns cache</code>如果更改，则替换上游的地址。 <br><br> 太好了！ 现在由设置决定。 <br><br> 这是Haproxy的简短配置示例： <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">frontend</span></span> http bind *:<span class="hljs-number"><span class="hljs-number">80</span></span> http-request del-header X-Forwarded-For http-request del-header X-Forwarded-Port http-request del-header X-Forwarded-Proto capture request header Host len <span class="hljs-number"><span class="hljs-number">32</span></span> capture request header Referer len <span class="hljs-number"><span class="hljs-number">128</span></span> capture request header User-Agent len <span class="hljs-number"><span class="hljs-number">128</span></span> acl host_present hdr(host) -m len gt <span class="hljs-number"><span class="hljs-number">0</span></span> use_backend %[req.hdr(host),lower,field(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-string"><span class="hljs-string">'.'</span></span>)] if host_present default_backend default resolvers dns hold valid <span class="hljs-number"><span class="hljs-number">1s</span></span> timeout retry <span class="hljs-number"><span class="hljs-number">100ms</span></span> nameserver dns1 <span class="hljs-number"><span class="hljs-number">1.1.1.1:53</span></span> backend one http-request set-header Host one.domain.com server one--one.domain.com one.domain.com:<span class="hljs-number"><span class="hljs-number">80</span></span> resolvers dns check backend two http-request set-header Host two.domain.net server two--two.domain.net two.domain.net:<span class="hljs-number"><span class="hljs-number">443</span></span> resolvers dns check ssl verify <span class="hljs-literal"><span class="hljs-literal">none</span></span> check-sni two.domain.net sni str(two.domain.net)</code> </pre><br> 一切似乎都正常了，这一次。 我对Haproxy唯一不满意的是配置描述的复杂性。 您需要构建大量文本才能在上游添加一个文本。 但是懒惰是进步的动力：如果您不想写相同的东西，请编写生成器。 <br><br> 我已经从Nginx获得了一个映射，格式为<code>"tag" "upstream"</code> ，所以我决定以它为基础，解析并基于这些值生成haproxy后端。 <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#! /usr/bin/env bash haproxy_backend_map_file=./root/etc/haproxy/snippet.d/name_domain_map haproxy_backends_file=./root/etc/haproxy/99_backends.cfg nginx_map_file=./nginx_map while getopts 'n:b:m:' OPT;do case ${OPT} in n) nginx_map_file=${OPTARG} ;; b) haproxy_backends_file=${OPTARG} ;; m) haproxy_backend_map_file=${OPTARG} ;; *) echo 'Usage: ${0} -n [nginx_map_file] -b [haproxy_backends_file] -m [haproxy_backend_map_file]' exit esac done function write_backend(){ local tag=$1 local domain=$2 local port=$3 local server_options="resolvers dns check" [ -n "${4}" ] &amp;&amp; local ssl_options="ssl verify none check-sni ${domain} sni str(${domain})" [ -n "${4}" ] &amp;&amp; server_options+=" ${ssl_options}" cat &gt;&gt; ${haproxy_backends_file} &lt;&lt;EOF backend ${tag} http-request set-header Host ${domain} server ${tag}--${domain} ${domain}:${port} ${server_options} EOF } :&gt; ${haproxy_backends_file} :&gt; ${haproxy_backend_map_file} while read tag addr;do tag=${tag//\"/} [ -z "${tag:0}" ] &amp;&amp; continue [ "${tag:0:1}" == "#" ] &amp;&amp; continue IFS=":" read scheme domain port &lt;&lt;&lt;${addr//;} unset IFS domain=${domain//\/} case ${scheme} in http) port=${port:-80} write_backend ${tag} ${domain} ${port} ;; https) port=${port:-443} write_backend ${tag} ${domain} ${port} 1 esac done &lt; &lt;(sort -V ${nginx_map_file})</span></span></code> </pre><br> 现在，我们所需要做的就是在nginx_map中添加一个新主机，启动生成器并准备好haproxy配置。 <br><br> 今天可能就这些了。 本文更多地涉及介绍性文章，并且致力于选择解决方案并将其集成到当前环境中的问题。 <br><br> 在下一篇文章中，我将向您详细介绍使用Haproxy时遇到的陷阱，哪些指标对监控很有用，以及应该在系统中进行哪些优化以最大程度地发挥服务器性能。 <br><br> 谢谢大家的关注，再见！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN436992/">https://habr.com/ru/post/zh-CN436992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN436982/index.html">安全周04：如何处理密码</a></li>
<li><a href="../zh-CN436984/index.html">微软停止支持Windows 10移动版</a></li>
<li><a href="../zh-CN436986/index.html">Linux API 管理内核文件I / O缓冲</a></li>
<li><a href="../zh-CN436988/index.html">相机，马达，大数据：电影制片厂如何使用AI寻找新电影</a></li>
<li><a href="../zh-CN436990/index.html">Zimbra和Zextras Suite与NTC IT ROSA操作系统完全兼容</a></li>
<li><a href="../zh-CN436994/index.html">Liquibase和Maven</a></li>
<li><a href="../zh-CN436996/index.html">Mail.ru Group的Python专业化最终课程</a></li>
<li><a href="../zh-CN436998/index.html">保护微芯片免受逆向工程和未经授权的侵入</a></li>
<li><a href="../zh-CN437000/index.html">如何教人们使用git</a></li>
<li><a href="../zh-CN437002/index.html">有效的ASP.NET Core</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>