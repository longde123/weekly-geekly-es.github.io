<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎮 🛌🏼 🧓🏻 12 concepts JavaScript à connaître 👨‍👩‍👧‍👦 👋🏽 🚛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript est un langage complexe. Si vous, à n'importe quel niveau, êtes engagé dans le développement JavaScript, cela signifie qu'il est vital pour...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>12 concepts JavaScript à connaître</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441566/">  JavaScript est un langage complexe.  Si vous, à n'importe quel niveau, êtes engagé dans le développement JavaScript, cela signifie qu'il est vital pour vous de comprendre les concepts de base de ce langage.  Le matériel, dont nous publions aujourd'hui la traduction, couvre 12 concepts JavaScript essentiels.  Bien sûr, le développeur JavaScript doit en savoir beaucoup plus, mais sans ce dont nous allons parler aujourd'hui, il ne peut certainement pas le faire. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/xo/jx/x6/xojxx6etipvx2akmizisxctdubg.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">1. Variables stockant des valeurs et des références</font> </h2><br>  Comprendre comment les valeurs des variables sont attribuées exactement en JavaScript est extrêmement important pour ceux qui veulent écrire du code fonctionnant correctement.  Une mauvaise compréhension de ce mécanisme conduit à écrire des programmes dans lesquels les valeurs des variables peuvent changer par inadvertance. <br><br>  JavaScript, si une entité possède l'un des types primitifs (en particulier, les types <code>Boolean</code> , <code>null</code> , <code>undefined</code> , <code>String</code> et <code>Number</code> ), fonctionne toujours avec la valeur de cette entité.  Autrement dit, la valeur est écrite dans la variable correspondante.  Si nous parlons d'un objet (par exemple, les types <code>Object</code> , <code>Array</code> , <code>Function</code> ), alors lors de son affectation à une variable, une référence lui est écrite, l'adresse à laquelle il se trouve en mémoire. <br><br>  Prenons un exemple.  Dans l'extrait de code suivant, une chaîne est écrite dans <code>var1</code> .  Après cela, la valeur de <code>var2</code> écrite dans la variable <code>var2</code> .  Étant donné que la variable <code>var1</code> a un type primitif ( <code>String</code> ), une copie de la chaîne disponible dans <code>var1</code> <code>var2</code> écrite dans <code>var1</code> .  Cela nous permet de considérer <code>var2</code> comme une variable complètement indépendante de <code>var1</code> , bien qu'elle stocke la même valeur que <code>var1</code> .  L'écriture d'une nouvelle valeur dans <code>var1</code> n'affecte pas <code>var1</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1 = <span class="hljs-string"><span class="hljs-string">'My string'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = var1; var2 = <span class="hljs-string"><span class="hljs-string">'My new string'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-comment"><span class="hljs-comment">// 'My string' console.log(var2); // 'My new string'</span></span></code> </pre> <br>  Considérons maintenant un exemple de travail avec des objets. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jim'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = var1; var2.name = <span class="hljs-string"><span class="hljs-string">'John'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-comment"><span class="hljs-comment">// { name: 'John' } console.log(var2); // { name: 'John' }</span></span></code> </pre> <br>  Comme vous pouvez le voir, nous travaillons ici avec la variable <code>var2</code> , et ce qui lui arrive est reflété dans la variable <code>var1</code> car ils stockent une référence au même objet.  Il est facile d'imaginer ce que cela peut entraîner dans du code réel si quelqu'un décide que les variables qui stockent des objets se comportent de la même manière que les variables qui stockent des valeurs de types primitifs.  Cela est particulièrement désagréable, par exemple, dans les cas où ils créent une fonction conçue pour fonctionner avec la valeur d'objet qui lui est transmise, et cette fonction modifie cette valeur par inadvertance. <br><br><h2>  <font color="#3AC1EF">2. Court-circuits</font> </h2><br>  La fermeture est un modèle de conception important en JavaScript qui vous permet d'organiser le travail protégé avec des variables.  Dans l'exemple suivant, la fonction <code>createGreeter()</code> renvoie une fonction anonyme qui a accès à l'argument d'origine fourni avec l'argument d' <code>greeting</code> contenant la chaîne <code>Hello</code> .  Une référence à cette fonction anonyme est écrite dans la variable <code>sayHello</code> .  Après cela, quel que soit le nombre de fois que nous appelons la fonction <code>sayHello()</code> , elle aura toujours accès à la valeur d' <code>greeting</code> .  Dans ce cas, l'accès au <code>greeting</code> d' <code>greeting</code> ne sera qu'une fonction anonyme, dont un lien sera enregistré dans <code>sayHello</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGreeter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">greeting</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greeting + <span class="hljs-string"><span class="hljs-string">', '</span></span> + name); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sayHello = createGreeter(<span class="hljs-string"><span class="hljs-string">'Hello'</span></span>); sayHello(<span class="hljs-string"><span class="hljs-string">'Joe'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Hello, Joe</span></span></code> </pre> <br>  C'était un exemple très simple.  Si nous regardons quelque chose de plus proche du monde réel, nous pouvons imaginer, par exemple, une fonction de connexion à une certaine API (appelons-la <code>apiConnect()</code> ), qui, lors de son premier appel, reçoit une clé d'accès à l'API.  Cette fonction, à son tour, renvoie un objet contenant plusieurs méthodes qui utilisent la clé d'accès API passée à <code>apiConnect()</code> .  Dans ce cas, la clé est stockée dans la fermeture et lorsque vous appelez ces méthodes, il n'est plus nécessaire de la mentionner. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apiConnect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">apiKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">route</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${route}</span></span></span><span class="hljs-string">?key=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${apiKey}</span></span></span><span class="hljs-string">`</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">route, params</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(route, {     <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>,     <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(params),       <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: {         <span class="hljs-string"><span class="hljs-string">'Authorization'</span></span>: <span class="hljs-string"><span class="hljs-string">`Bearer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${apiKey}</span></span></span><span class="hljs-string">`</span></span>       }     }) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { get, post } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> api = apiConnect(<span class="hljs-string"><span class="hljs-string">'my-secret-key'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     API     api.get('http://www.example.com/get-endpoint'); api.post('http://www.example.com/post-endpoint', { name: 'Joe' });</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">3. Cession destructive</font> </h2><br>  Si vous n'avez pas encore utilisé d'affectation destructrice dans JavaScript, il est temps de le corriger.  L'affectation destructive est un moyen courant de récupérer des propriétés d'objet à l'aide d'une construction de langage syntaxique soignée. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: <span class="hljs-string"><span class="hljs-string">'cake'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, food } = obj; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, food); <span class="hljs-comment"><span class="hljs-comment">// 'Joe' 'cake'</span></span></code> </pre> <br>  Si vous devez attribuer des noms de propriétés extraits différents de ceux qu'ils ont dans l'objet, vous pouvez le faire: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: <span class="hljs-string"><span class="hljs-string">'cake'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: myName, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: myFood } = obj; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myName, myFood); <span class="hljs-comment"><span class="hljs-comment">// 'Joe' 'cake'</span></span></code> </pre> <br>  Dans l'exemple suivant, la déstructuration est utilisée pour transmettre avec précision les valeurs stockées dans les propriétés de l'objet <code>person</code> à la fonctiontrod <code>introduce()</code> .  Ceci est un exemple de la façon dont cette construction est utilisée lors de la déclaration d'une fonction pour récupérer des données d'un objet avec des paramètres qui lui sont passés.  Soit dit en passant, si vous connaissez React, vous l'avez probablement déjà vu. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Eddie'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">24</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">introduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, age }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string"> and I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${age}</span></span></span><span class="hljs-string"> years old!`</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(introduce(person)); <span class="hljs-comment"><span class="hljs-comment">// "I'm Eddie and I'm 24 years old!"</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">4. L'opérateur de spread</font> </h2><br>  L'opérateur de propagation est une construction assez simple qui peut sembler incompréhensible à une personne non préparée.  L'exemple suivant a un tableau numérique, la valeur maximale stockée dans laquelle nous devons trouver.  Nous voulons utiliser la méthode <code>Math.max()</code> pour cela, mais il ne sait pas comment travailler avec des tableaux.  Il, en tant qu'arguments, suppose des valeurs numériques indépendantes.  Afin d'extraire ses éléments du tableau, nous utilisons l'opérateur spread, qui ressemble à trois points. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> max = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(...arr); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(max); <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">5. La déclaration de repos</font> </h2><br>  L'opérateur reste vous permet de convertir n'importe quel nombre d'arguments passés à une fonction en un tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(args[<span class="hljs-number"><span class="hljs-number">0</span></span>] + args[<span class="hljs-number"><span class="hljs-number">1</span></span>]); } myFunc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">6. Méthodes de tableau</font> </h2><br>  Les méthodes de tableau fournissent souvent au développeur des outils pratiques pour résoudre magnifiquement une variété de tâches de conversion de données.  Je réponds parfois à des questions sur StackOverflow.  Parmi eux, il y a souvent ceux qui sont dédiés à quelque chose comme ça ou à d'autres façons de travailler avec des tableaux d'objets.  C'est dans de telles situations que les méthodes de tableau sont particulièrement utiles. <br><br>  Nous considérerons ici plusieurs de ces méthodes, unies par le principe de leur similitude.  Il convient de noter que je ne vous parlerai pas ici de toutes les méthodes de tableaux.  Vous pouvez trouver leur liste complète sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MDN</a> (soit dit en passant, c'est ma référence JavaScript préférée). <br><br><h3>  <font color="#3AC1EF">Méthodes apMap (), filter () et Reduce ()</font> </h3><br>  Les méthodes de tableau <code>map()</code> , <code>filter()</code> et <code>reduce()</code> vous permettent de transformer des tableaux ou de réduire des tableaux en une seule valeur (qui peut être un objet). <br><br>  La méthode <code>map()</code> renvoie un nouveau tableau contenant les valeurs transformées du tableau traité.  La manière exacte dont ils seront transformés est spécifiée dans la fonction passée à cette méthode. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapped = arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el + <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(mapped); <span class="hljs-comment"><span class="hljs-comment">// [21, 22, 23, 24, 25, 26]</span></span></code> </pre> <br>  La méthode <code>filter()</code> renvoie un tableau d'éléments, vérifiant les valeurs dont la fonction passée à cette méthode a renvoyé <code>true</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filtered = arr.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el === <span class="hljs-number"><span class="hljs-number">2</span></span> || el === <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(filtered); <span class="hljs-comment"><span class="hljs-comment">// [2, 4]</span></span></code> </pre> <br>  La méthode <code>reduce()</code> renvoie une certaine valeur, qui est le résultat du traitement de tous les éléments du tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reduced = arr.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total, current</span></span></span><span class="hljs-function">) =&gt;</span></span> total + current); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(reduced); <span class="hljs-comment"><span class="hljs-comment">// 21</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Méthodes find (), findIndex () et indexOf ()</font> </h3><br>  Les méthodes de tableau <code>find()</code> , <code>findIndex()</code> et <code>indexOf()</code> faciles à confondre.  Les explications suivantes vous aident à comprendre leurs fonctionnalités. <br><br>  La méthode <code>find()</code> renvoie le premier élément du tableau qui correspond aux critères spécifiés.  Cette méthode, qui recherche le premier élément approprié, ne poursuit pas la recherche dans le tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> found = arr.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(found); <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre> <br>  Veuillez noter que dans notre exemple, les critères donnés correspondent à tous les éléments du tableau qui suivent celui qui contient le chiffre 5, mais seul le premier élément approprié est renvoyé.  Cette méthode est très utile dans les situations où, en utilisant les boucles for pour énumérer et analyser les tableaux, ces boucles sont interrompues lorsque l'élément souhaité est trouvé dans le tableau à l'aide de l'instruction <code>break</code> . <br><br>  La méthode <code>findIndex()</code> est très similaire à <code>find()</code> , mais au lieu de renvoyer le premier élément approprié du tableau, elle renvoie l'index de cet élément.  Afin de mieux comprendre cette méthode, jetez un œil à l'exemple suivant, qui utilise un tableau de valeurs de chaîne. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'Nick'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>, <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foundIndex = arr.findIndex(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el === <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foundIndex); <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  La méthode <code>indexOf()</code> est très similaire à la méthode <code>findIndex()</code> , mais elle prend comme argument non pas une fonction, mais une valeur normale.  Il peut être utilisé si une logique complexe n'est pas nécessaire lors de la recherche de l'élément de tableau souhaité. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'Nick'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>, <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foundIndex = arr.indexOf(<span class="hljs-string"><span class="hljs-string">'Frank'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foundIndex); <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Méthodes Push (), pop (), shift () et unshift ()</font> </h3><br>  Les <code>unshift()</code> <code>push()</code> , <code>pop()</code> , <code>shift()</code> et <code>unshift()</code> sont utilisées pour ajouter de nouveaux éléments aux tableaux et en extraire les éléments déjà existants dans les tableaux.  Dans ce cas, le travail est effectué avec des éléments situés au début ou à la fin du tableau. <br><br>  La méthode <code>push()</code> vous permet d'ajouter des éléments à la fin d'un tableau.  Il modifie le tableau et, une fois terminé, renvoie l'élément ajouté au tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pushed = arr.push(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5] console.log(pushed); // 5</span></span></code> </pre> <br>  La méthode <code>pop()</code> supprime le dernier élément du tableau.  Il modifie le tableau et renvoie l'élément supprimé de celui-ci. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> popped = arr.pop(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3] console.log(popped); // 4</span></span></code> </pre> <br>  La méthode <code>shift()</code> supprime le premier élément du tableau et le renvoie.  Il modifie également le tableau pour lequel il est appelé. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shifted = arr.shift(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [2, 3, 4] console.log(shifted); // 1</span></span></code> </pre> <br>  La méthode <code>unshift()</code> ajoute un ou plusieurs éléments au début d'un tableau.  Il modifie à nouveau le tableau.  En même temps, contrairement aux trois autres méthodes décrites ici, elle renvoie la nouvelle longueur du tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unshifted = arr.unshift(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [5, 6, 7, 1, 2, 3, 4] console.log(unshifted); // 7</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">Méthodes lSlice () et splice ()</font> </h3><br>  Ces méthodes sont utilisées pour modifier le tableau ou pour renvoyer une partie du tableau. <br><br>  La méthode <code>splice()</code> modifie le contenu d'un tableau en supprimant des éléments existants ou en les remplaçant par d'autres éléments.  Il est capable d'ajouter de nouveaux éléments au tableau.  Cette méthode modifie le tableau. <br><br>  L'exemple suivant, si vous le décrivez en langage ordinaire, ressemble à ceci: vous devez, à la position de tableau <code>1</code> , supprimer <code>0</code> éléments et ajouter un élément contenant <code>b</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>]; arr.splice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>)</code> </pre> <br>  La méthode <code>slice()</code> renvoie une copie superficielle du tableau contenant ses éléments, à partir de la position de départ donnée et se terminant par la position précédant la position de fin donnée.  Si, lors de son appel, seule la position initiale est spécifiée, il renverra tout le tableau, à partir de cette position.  Cette méthode ne modifie pas le tableau.  Il ne renvoie que la partie de ce tableau décrite lors de son appel. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sliced = arr.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sliced); <span class="hljs-comment"><span class="hljs-comment">// ['c', 'd'] console.log(arr); // ['a', 'b', 'c', 'd', 'e']</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Méthode sort ()</font> </h3><br>  La méthode <code>sort()</code> trie le tableau conformément à la condition spécifiée par la fonction qui lui est transmise.  Cette fonction prend deux éléments du tableau (par exemple, ils peuvent être représentés comme les paramètres <code>a</code> et <code>b</code> ) et, en les comparant, retourne, si les éléments n'ont pas besoin d'être échangés, 0 si <code>a</code> doit être mis à un indice inférieur à <code>b</code> est un nombre négatif, et si <code>b</code> doit être mis à un indice inférieur à <code>a</code> est un nombre positif. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sorter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstEl, secondEl</span></span></span><span class="hljs-function">) =&gt;</span></span> firstEl - secondEl; arr.sort(sorter); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [-1, 1, 2, 3, 5, 7, 7]</span></span></code> </pre> <br>  Si vous ne vous souvenez pas de ces méthodes pour la première fois, vous vous en souvenez.  La chose la plus importante est que vous savez maintenant ce que les méthodes de tableau standard peuvent faire.  Par conséquent, si vous ne pouvez pas rappeler immédiatement les fonctionnalités d'une méthode particulière, ce que vous en savez vous permettra de trouver rapidement ce dont vous avez besoin dans la documentation. <br><br><h2>  <font color="#3AC1EF">7. Générateurs</font> </h2><br>  Les générateurs JavaScript sont déclarés à l'aide d'un caractère astérisque.  Ils vous permettent de spécifier la valeur qui sera retournée la prochaine fois que la méthode <code>next()</code> sera appelée.  Les générateurs peuvent être conçus pour renvoyer un nombre limité de valeurs.  Si un tel générateur a renvoyé toutes ces valeurs, le prochain appel à <code>next()</code> renverra <code>undefined</code> .  Vous pouvez également créer des générateurs conçus pour renvoyer un nombre illimité de valeurs à l'aide de cycles. <br><br>  Voici un générateur conçu pour renvoyer un nombre limité de valeurs: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greeter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'Hi'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'How are you?'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'Bye'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greet = greeter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greet.next().value); <span class="hljs-comment"><span class="hljs-comment">// 'Hi' console.log(greet.next().value); // 'How are you?' console.log(greet.next().value); // 'Bye' console.log(greet.next().value); // undefined</span></span></code> </pre> <br>  Et voici un générateur conçu pour renvoyer un nombre infini de valeurs à travers une boucle. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">idCreator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i++; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ids = idCreator(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ids.next().value); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(ids.next().value); // 1 console.log(ids.next().value); // 2 //   ...</span></span></code> </pre><br><h2>  <font color="#3AC1EF">8. Opérateurs de vérification de l'égalité (==) et de l'égalité stricte (===) des valeurs</font> </h2><br>  Il est extrêmement important pour tout développeur JS de comprendre la différence entre les opérateurs d'égalité ( <code>==</code> ) et d'égalité stricte ( <code>===</code> ).  Le fait est que l'opérateur <code>==</code> , avant de comparer les valeurs, effectue la conversion de leurs types (ce qui peut entraîner des conséquences étranges à première vue), et l'opérateur <code>===</code> n'effectue pas de conversion de type. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">0</span></span> == <span class="hljs-string"><span class="hljs-string">'0'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true console.log(0 === '0'); // false</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">9. Comparaison d'objets</font> </h2><br>  Je dois parfois voir comment les nouveaux venus dans la programmation JS font la même erreur.  Ils essaient de comparer directement les objets.  Les variables dans lesquelles les objets sont "stockés" contiennent des références à eux, et non ces objets eux-mêmes. <br><br>  Ainsi, par exemple, dans l'exemple suivant, les objets se ressemblent, mais lorsqu'ils sont comparés directement, nous sommes informés que les objets sont différents, car chacune des variables contient un lien vers son propre objet et ces liens ne sont pas égaux les uns aux autres. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe2 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(joe1 === joe2); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  De plus, dans l'exemple suivant, il s'avère que <code>joe1</code> est égal à <code>joe2</code> puisque les deux variables stockent une référence au même objet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe2 = joe1; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(joe1 === joe2); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  L'une des méthodes de comparaison d'objets réels est leur conversion préliminaire au format de chaîne JSON.  Certes, cette approche a un problème, qui est que dans la représentation en chaîne obtenue de l'objet, un certain ordre de ses propriétés n'est pas garanti.  Un moyen plus fiable de comparer des objets consiste à utiliser une bibliothèque spéciale contenant des outils pour une comparaison approfondie des objets (par exemple, il s'agit de la méthode <a href="">isEqual ()</a> de la bibliothèque <a href="">lodash</a> ). <br><br>  Afin de mieux comprendre les subtilités de la comparaison d'objets et de comprendre les conséquences possibles de l'écriture de liens vers les mêmes objets dans différentes variables, jetez un œil au premier concept JS discuté dans cet article. <br><br><h2>  <font color="#3AC1EF">10. Fonctions de rappel</font> </h2><br>  Les fonctions de rappel sont un concept JavaScript assez simple avec lequel les débutants ont parfois des difficultés.  Prenons l'exemple suivant.  Ici, la fonction <code>console.log</code> (juste comme ça - sans parenthèses) est passée à <code>myFunc()</code> tant que fonction de rappel.  Cette fonction définit un temporisateur, après quoi <code>console.log()</code> est appelée et la chaîne passée à <code>myFunc()</code> s'affiche dans la console. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text, callback</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   callback(text); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); } myFunc(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-comment"><span class="hljs-comment">// 'Hello world!'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">11. Promesses</font> </h2><br>  Après avoir maîtrisé les fonctions de rappel et commencé à les utiliser partout, vous vous retrouverez bientôt dans le soi-disant «enfer du rappel».  Si vous êtes vraiment là, jetez un œil aux promesses.  Le code asynchrone peut être enveloppé dans une promesse et, après son exécution réussie, informer le système de la résolution réussie de la promesse en appelant la méthode appropriée, et si quelque chose ne va pas - appelez la méthode pour l'indiquer et rejetez la promesse.  Pour traiter les résultats renvoyés par la promesse, utilisez la méthode <code>then()</code> et pour la gestion des erreurs, utilisez la méthode <code>catch()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, rej</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res(<span class="hljs-string"><span class="hljs-string">'Hooray!'</span></span>);   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rej(<span class="hljs-string"><span class="hljs-string">'Oh no!'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); myPromise .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Success: '</span></span> + data);  })  .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Error: '</span></span> + err);  }); <span class="hljs-comment"><span class="hljs-comment">//  Math.random()  , ,  0.9,    : // "Success: Hooray!" //  Math.random()  , ,  0.9,  0.9,    : // "Error: On no!"</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">12. async / attente de construction</font> </h2><br>  Après avoir travaillé avec les promesses, alors, très probablement, vous voudrez quelque chose de plus.  Par exemple, maîtrisez la construction async / wait.  C'est du sucre syntaxique pour les promesses.  Dans l'exemple suivant, nous créons, à l'aide du <code>async</code> - <code>async</code> , une fonction asynchrone, et dans celui-ci, à l'aide du mot-clé wait, nous organisons l'attente de la fin de la <code>greeter</code> réception. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, rej</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> res(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>), <span class="hljs-number"><span class="hljs-number">2000</span></span>); }) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> greeter; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greeting); } myFunc(); <span class="hljs-comment"><span class="hljs-comment">// 'Hello world!'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Si ce dont nous avons parlé ici ne vous était pas familier auparavant, vous avez probablement, au moins un peu, dépassé votre niveau en lisant cet article.  Si vous n'avez rien trouvé de nouveau ici, j'espère que ce matériel vous a donné l'occasion de pratiquer et de renforcer votre connaissance de JavaScript. <br><br>  <b>Chers lecteurs!</b>  Quels autres concepts JavaScript ajouteriez-vous à cet article? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441566/">https://habr.com/ru/post/fr441566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441546/index.html">Hayabusa-2 "a d'abord touché l'astéroïde</a></li>
<li><a href="../fr441550/index.html">La vie d'un simple programmeur est dure et simple</a></li>
<li><a href="../fr441554/index.html">Toute l'histoire de Linux. Partie I: comment tout a commencé</a></li>
<li><a href="../fr441560/index.html">Événements numériques à Moscou du 25 février au 3 mars</a></li>
<li><a href="../fr441562/index.html">Pixel Gallop - Cinquième partie - Animation de personnages. Marcher</a></li>
<li><a href="../fr441568/index.html">Gestion de la mémoire Python</a></li>
<li><a href="../fr441570/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 353 (17-24 février 2019)</a></li>
<li><a href="../fr441572/index.html">Frontend Weekly Digest (18-24 février 2019)</a></li>
<li><a href="../fr441574/index.html">Apprendre Docker Partie 6: Travailler avec des données</a></li>
<li><a href="../fr441576/index.html">Réseaux Kubernetes: Pods</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>