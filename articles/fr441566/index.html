<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÆ üõåüèº üßìüèª 12 concepts JavaScript √† conna√Ætre üë®‚Äçüë©‚Äçüëß‚Äçüë¶ üëãüèΩ üöõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript est un langage complexe. Si vous, √† n'importe quel niveau, √™tes engag√© dans le d√©veloppement JavaScript, cela signifie qu'il est vital pour...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>12 concepts JavaScript √† conna√Ætre</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441566/">  JavaScript est un langage complexe.  Si vous, √† n'importe quel niveau, √™tes engag√© dans le d√©veloppement JavaScript, cela signifie qu'il est vital pour vous de comprendre les concepts de base de ce langage.  Le mat√©riel, dont nous publions aujourd'hui la traduction, couvre 12 concepts JavaScript essentiels.  Bien s√ªr, le d√©veloppeur JavaScript doit en savoir beaucoup plus, mais sans ce dont nous allons parler aujourd'hui, il ne peut certainement pas le faire. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/xo/jx/x6/xojxx6etipvx2akmizisxctdubg.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">1. Variables stockant des valeurs et des r√©f√©rences</font> </h2><br>  Comprendre comment les valeurs des variables sont attribu√©es exactement en JavaScript est extr√™mement important pour ceux qui veulent √©crire du code fonctionnant correctement.  Une mauvaise compr√©hension de ce m√©canisme conduit √† √©crire des programmes dans lesquels les valeurs des variables peuvent changer par inadvertance. <br><br>  JavaScript, si une entit√© poss√®de l'un des types primitifs (en particulier, les types <code>Boolean</code> , <code>null</code> , <code>undefined</code> , <code>String</code> et <code>Number</code> ), fonctionne toujours avec la valeur de cette entit√©.  Autrement dit, la valeur est √©crite dans la variable correspondante.  Si nous parlons d'un objet (par exemple, les types <code>Object</code> , <code>Array</code> , <code>Function</code> ), alors lors de son affectation √† une variable, une r√©f√©rence lui est √©crite, l'adresse √† laquelle il se trouve en m√©moire. <br><br>  Prenons un exemple.  Dans l'extrait de code suivant, une cha√Æne est √©crite dans <code>var1</code> .  Apr√®s cela, la valeur de <code>var2</code> √©crite dans la variable <code>var2</code> .  √âtant donn√© que la variable <code>var1</code> a un type primitif ( <code>String</code> ), une copie de la cha√Æne disponible dans <code>var1</code> <code>var2</code> √©crite dans <code>var1</code> .  Cela nous permet de consid√©rer <code>var2</code> comme une variable compl√®tement ind√©pendante de <code>var1</code> , bien qu'elle stocke la m√™me valeur que <code>var1</code> .  L'√©criture d'une nouvelle valeur dans <code>var1</code> n'affecte pas <code>var1</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1 = <span class="hljs-string"><span class="hljs-string">'My string'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = var1; var2 = <span class="hljs-string"><span class="hljs-string">'My new string'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-comment"><span class="hljs-comment">// 'My string' console.log(var2); // 'My new string'</span></span></code> </pre> <br>  Consid√©rons maintenant un exemple de travail avec des objets. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jim'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = var1; var2.name = <span class="hljs-string"><span class="hljs-string">'John'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-comment"><span class="hljs-comment">// { name: 'John' } console.log(var2); // { name: 'John' }</span></span></code> </pre> <br>  Comme vous pouvez le voir, nous travaillons ici avec la variable <code>var2</code> , et ce qui lui arrive est refl√©t√© dans la variable <code>var1</code> car ils stockent une r√©f√©rence au m√™me objet.  Il est facile d'imaginer ce que cela peut entra√Æner dans du code r√©el si quelqu'un d√©cide que les variables qui stockent des objets se comportent de la m√™me mani√®re que les variables qui stockent des valeurs de types primitifs.  Cela est particuli√®rement d√©sagr√©able, par exemple, dans les cas o√π ils cr√©ent une fonction con√ßue pour fonctionner avec la valeur d'objet qui lui est transmise, et cette fonction modifie cette valeur par inadvertance. <br><br><h2>  <font color="#3AC1EF">2. Court-circuits</font> </h2><br>  La fermeture est un mod√®le de conception important en JavaScript qui vous permet d'organiser le travail prot√©g√© avec des variables.  Dans l'exemple suivant, la fonction <code>createGreeter()</code> renvoie une fonction anonyme qui a acc√®s √† l'argument d'origine fourni avec l'argument d' <code>greeting</code> contenant la cha√Æne <code>Hello</code> .  Une r√©f√©rence √† cette fonction anonyme est √©crite dans la variable <code>sayHello</code> .  Apr√®s cela, quel que soit le nombre de fois que nous appelons la fonction <code>sayHello()</code> , elle aura toujours acc√®s √† la valeur d' <code>greeting</code> .  Dans ce cas, l'acc√®s au <code>greeting</code> d' <code>greeting</code> ne sera qu'une fonction anonyme, dont un lien sera enregistr√© dans <code>sayHello</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGreeter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">greeting</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greeting + <span class="hljs-string"><span class="hljs-string">', '</span></span> + name); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sayHello = createGreeter(<span class="hljs-string"><span class="hljs-string">'Hello'</span></span>); sayHello(<span class="hljs-string"><span class="hljs-string">'Joe'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Hello, Joe</span></span></code> </pre> <br>  C'√©tait un exemple tr√®s simple.  Si nous regardons quelque chose de plus proche du monde r√©el, nous pouvons imaginer, par exemple, une fonction de connexion √† une certaine API (appelons-la <code>apiConnect()</code> ), qui, lors de son premier appel, re√ßoit une cl√© d'acc√®s √† l'API.  Cette fonction, √† son tour, renvoie un objet contenant plusieurs m√©thodes qui utilisent la cl√© d'acc√®s API pass√©e √† <code>apiConnect()</code> .  Dans ce cas, la cl√© est stock√©e dans la fermeture et lorsque vous appelez ces m√©thodes, il n'est plus n√©cessaire de la mentionner. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apiConnect</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">apiKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">route</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${route}</span></span></span><span class="hljs-string">?key=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${apiKey}</span></span></span><span class="hljs-string">`</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">route, params</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(route, {     <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>,     <span class="hljs-attr"><span class="hljs-attr">body</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(params),       <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: {         <span class="hljs-string"><span class="hljs-string">'Authorization'</span></span>: <span class="hljs-string"><span class="hljs-string">`Bearer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${apiKey}</span></span></span><span class="hljs-string">`</span></span>       }     }) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { get, post } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> api = apiConnect(<span class="hljs-string"><span class="hljs-string">'my-secret-key'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     API     api.get('http://www.example.com/get-endpoint'); api.post('http://www.example.com/post-endpoint', { name: 'Joe' });</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">3. Cession destructive</font> </h2><br>  Si vous n'avez pas encore utilis√© d'affectation destructrice dans JavaScript, il est temps de le corriger.  L'affectation destructive est un moyen courant de r√©cup√©rer des propri√©t√©s d'objet √† l'aide d'une construction de langage syntaxique soign√©e. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: <span class="hljs-string"><span class="hljs-string">'cake'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { name, food } = obj; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(name, food); <span class="hljs-comment"><span class="hljs-comment">// 'Joe' 'cake'</span></span></code> </pre> <br>  Si vous devez attribuer des noms de propri√©t√©s extraits diff√©rents de ceux qu'ils ont dans l'objet, vous pouvez le faire: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: <span class="hljs-string"><span class="hljs-string">'cake'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: myName, <span class="hljs-attr"><span class="hljs-attr">food</span></span>: myFood } = obj; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myName, myFood); <span class="hljs-comment"><span class="hljs-comment">// 'Joe' 'cake'</span></span></code> </pre> <br>  Dans l'exemple suivant, la d√©structuration est utilis√©e pour transmettre avec pr√©cision les valeurs stock√©es dans les propri√©t√©s de l'objet <code>person</code> √† la fonctiontrod <code>introduce()</code> .  Ceci est un exemple de la fa√ßon dont cette construction est utilis√©e lors de la d√©claration d'une fonction pour r√©cup√©rer des donn√©es d'un objet avec des param√®tres qui lui sont pass√©s.  Soit dit en passant, si vous connaissez React, vous l'avez probablement d√©j√† vu. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Eddie'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">24</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">introduce</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, age }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string"> and I'm </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${age}</span></span></span><span class="hljs-string"> years old!`</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(introduce(person)); <span class="hljs-comment"><span class="hljs-comment">// "I'm Eddie and I'm 24 years old!"</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">4. L'op√©rateur de spread</font> </h2><br>  L'op√©rateur de propagation est une construction assez simple qui peut sembler incompr√©hensible √† une personne non pr√©par√©e.  L'exemple suivant a un tableau num√©rique, la valeur maximale stock√©e dans laquelle nous devons trouver.  Nous voulons utiliser la m√©thode <code>Math.max()</code> pour cela, mais il ne sait pas comment travailler avec des tableaux.  Il, en tant qu'arguments, suppose des valeurs num√©riques ind√©pendantes.  Afin d'extraire ses √©l√©ments du tableau, nous utilisons l'op√©rateur spread, qui ressemble √† trois points. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> max = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max(...arr); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(max); <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">5. La d√©claration de repos</font> </h2><br>  L'op√©rateur reste vous permet de convertir n'importe quel nombre d'arguments pass√©s √† une fonction en un tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(args[<span class="hljs-number"><span class="hljs-number">0</span></span>] + args[<span class="hljs-number"><span class="hljs-number">1</span></span>]); } myFunc(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">6. M√©thodes de tableau</font> </h2><br>  Les m√©thodes de tableau fournissent souvent au d√©veloppeur des outils pratiques pour r√©soudre magnifiquement une vari√©t√© de t√¢ches de conversion de donn√©es.  Je r√©ponds parfois √† des questions sur StackOverflow.  Parmi eux, il y a souvent ceux qui sont d√©di√©s √† quelque chose comme √ßa ou √† d'autres fa√ßons de travailler avec des tableaux d'objets.  C'est dans de telles situations que les m√©thodes de tableau sont particuli√®rement utiles. <br><br>  Nous consid√©rerons ici plusieurs de ces m√©thodes, unies par le principe de leur similitude.  Il convient de noter que je ne vous parlerai pas ici de toutes les m√©thodes de tableaux.  Vous pouvez trouver leur liste compl√®te sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MDN</a> (soit dit en passant, c'est ma r√©f√©rence JavaScript pr√©f√©r√©e). <br><br><h3>  <font color="#3AC1EF">M√©thodes apMap (), filter () et Reduce ()</font> </h3><br>  Les m√©thodes de tableau <code>map()</code> , <code>filter()</code> et <code>reduce()</code> vous permettent de transformer des tableaux ou de r√©duire des tableaux en une seule valeur (qui peut √™tre un objet). <br><br>  La m√©thode <code>map()</code> renvoie un nouveau tableau contenant les valeurs transform√©es du tableau trait√©.  La mani√®re exacte dont ils seront transform√©s est sp√©cifi√©e dans la fonction pass√©e √† cette m√©thode. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapped = arr.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el + <span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(mapped); <span class="hljs-comment"><span class="hljs-comment">// [21, 22, 23, 24, 25, 26]</span></span></code> </pre> <br>  La m√©thode <code>filter()</code> renvoie un tableau d'√©l√©ments, v√©rifiant les valeurs dont la fonction pass√©e √† cette m√©thode a renvoy√© <code>true</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filtered = arr.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el === <span class="hljs-number"><span class="hljs-number">2</span></span> || el === <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(filtered); <span class="hljs-comment"><span class="hljs-comment">// [2, 4]</span></span></code> </pre> <br>  La m√©thode <code>reduce()</code> renvoie une certaine valeur, qui est le r√©sultat du traitement de tous les √©l√©ments du tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reduced = arr.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">total, current</span></span></span><span class="hljs-function">) =&gt;</span></span> total + current); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(reduced); <span class="hljs-comment"><span class="hljs-comment">// 21</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç M√©thodes find (), findIndex () et indexOf ()</font> </h3><br>  Les m√©thodes de tableau <code>find()</code> , <code>findIndex()</code> et <code>indexOf()</code> faciles √† confondre.  Les explications suivantes vous aident √† comprendre leurs fonctionnalit√©s. <br><br>  La m√©thode <code>find()</code> renvoie le premier √©l√©ment du tableau qui correspond aux crit√®res sp√©cifi√©s.  Cette m√©thode, qui recherche le premier √©l√©ment appropri√©, ne poursuit pas la recherche dans le tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> found = arr.find(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(found); <span class="hljs-comment"><span class="hljs-comment">// 6</span></span></code> </pre> <br>  Veuillez noter que dans notre exemple, les crit√®res donn√©s correspondent √† tous les √©l√©ments du tableau qui suivent celui qui contient le chiffre 5, mais seul le premier √©l√©ment appropri√© est renvoy√©.  Cette m√©thode est tr√®s utile dans les situations o√π, en utilisant les boucles for pour √©num√©rer et analyser les tableaux, ces boucles sont interrompues lorsque l'√©l√©ment souhait√© est trouv√© dans le tableau √† l'aide de l'instruction <code>break</code> . <br><br>  La m√©thode <code>findIndex()</code> est tr√®s similaire √† <code>find()</code> , mais au lieu de renvoyer le premier √©l√©ment appropri√© du tableau, elle renvoie l'index de cet √©l√©ment.  Afin de mieux comprendre cette m√©thode, jetez un ≈ìil √† l'exemple suivant, qui utilise un tableau de valeurs de cha√Æne. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'Nick'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>, <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foundIndex = arr.findIndex(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> el === <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foundIndex); <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  La m√©thode <code>indexOf()</code> est tr√®s similaire √† la m√©thode <code>findIndex()</code> , mais elle prend comme argument non pas une fonction, mais une valeur normale.  Il peut √™tre utilis√© si une logique complexe n'est pas n√©cessaire lors de la recherche de l'√©l√©ment de tableau souhait√©. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'Nick'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>, <span class="hljs-string"><span class="hljs-string">'Joe'</span></span>, <span class="hljs-string"><span class="hljs-string">'Frank'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foundIndex = arr.indexOf(<span class="hljs-string"><span class="hljs-string">'Frank'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foundIndex); <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç M√©thodes Push (), pop (), shift () et unshift ()</font> </h3><br>  Les <code>unshift()</code> <code>push()</code> , <code>pop()</code> , <code>shift()</code> et <code>unshift()</code> sont utilis√©es pour ajouter de nouveaux √©l√©ments aux tableaux et en extraire les √©l√©ments d√©j√† existants dans les tableaux.  Dans ce cas, le travail est effectu√© avec des √©l√©ments situ√©s au d√©but ou √† la fin du tableau. <br><br>  La m√©thode <code>push()</code> vous permet d'ajouter des √©l√©ments √† la fin d'un tableau.  Il modifie le tableau et, une fois termin√©, renvoie l'√©l√©ment ajout√© au tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pushed = arr.push(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3, 4, 5] console.log(pushed); // 5</span></span></code> </pre> <br>  La m√©thode <code>pop()</code> supprime le dernier √©l√©ment du tableau.  Il modifie le tableau et renvoie l'√©l√©ment supprim√© de celui-ci. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> popped = arr.pop(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 3] console.log(popped); // 4</span></span></code> </pre> <br>  La m√©thode <code>shift()</code> supprime le premier √©l√©ment du tableau et le renvoie.  Il modifie √©galement le tableau pour lequel il est appel√©. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shifted = arr.shift(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [2, 3, 4] console.log(shifted); // 1</span></span></code> </pre> <br>  La m√©thode <code>unshift()</code> ajoute un ou plusieurs √©l√©ments au d√©but d'un tableau.  Il modifie √† nouveau le tableau.  En m√™me temps, contrairement aux trois autres m√©thodes d√©crites ici, elle renvoie la nouvelle longueur du tableau. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unshifted = arr.unshift(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [5, 6, 7, 1, 2, 3, 4] console.log(unshifted); // 7</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">M√©thodes lSlice () et splice ()</font> </h3><br>  Ces m√©thodes sont utilis√©es pour modifier le tableau ou pour renvoyer une partie du tableau. <br><br>  La m√©thode <code>splice()</code> modifie le contenu d'un tableau en supprimant des √©l√©ments existants ou en les rempla√ßant par d'autres √©l√©ments.  Il est capable d'ajouter de nouveaux √©l√©ments au tableau.  Cette m√©thode modifie le tableau. <br><br>  L'exemple suivant, si vous le d√©crivez en langage ordinaire, ressemble √† ceci: vous devez, √† la position de tableau <code>1</code> , supprimer <code>0</code> √©l√©ments et ajouter un √©l√©ment contenant <code>b</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>]; arr.splice(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>)</code> </pre> <br>  La m√©thode <code>slice()</code> renvoie une copie superficielle du tableau contenant ses √©l√©ments, √† partir de la position de d√©part donn√©e et se terminant par la position pr√©c√©dant la position de fin donn√©e.  Si, lors de son appel, seule la position initiale est sp√©cifi√©e, il renverra tout le tableau, √† partir de cette position.  Cette m√©thode ne modifie pas le tableau.  Il ne renvoie que la partie de ce tableau d√©crite lors de son appel. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>, <span class="hljs-string"><span class="hljs-string">'d'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sliced = arr.slice(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sliced); <span class="hljs-comment"><span class="hljs-comment">// ['c', 'd'] console.log(arr); // ['a', 'b', 'c', 'd', 'e']</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç M√©thode sort ()</font> </h3><br>  La m√©thode <code>sort()</code> trie le tableau conform√©ment √† la condition sp√©cifi√©e par la fonction qui lui est transmise.  Cette fonction prend deux √©l√©ments du tableau (par exemple, ils peuvent √™tre repr√©sent√©s comme les param√®tres <code>a</code> et <code>b</code> ) et, en les comparant, retourne, si les √©l√©ments n'ont pas besoin d'√™tre √©chang√©s, 0 si <code>a</code> doit √™tre mis √† un indice inf√©rieur √† <code>b</code> est un nombre n√©gatif, et si <code>b</code> doit √™tre mis √† un indice inf√©rieur √† <code>a</code> est un nombre positif. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sorter = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstEl, secondEl</span></span></span><span class="hljs-function">) =&gt;</span></span> firstEl - secondEl; arr.sort(sorter); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr); <span class="hljs-comment"><span class="hljs-comment">// [-1, 1, 2, 3, 5, 7, 7]</span></span></code> </pre> <br>  Si vous ne vous souvenez pas de ces m√©thodes pour la premi√®re fois, vous vous en souvenez.  La chose la plus importante est que vous savez maintenant ce que les m√©thodes de tableau standard peuvent faire.  Par cons√©quent, si vous ne pouvez pas rappeler imm√©diatement les fonctionnalit√©s d'une m√©thode particuli√®re, ce que vous en savez vous permettra de trouver rapidement ce dont vous avez besoin dans la documentation. <br><br><h2>  <font color="#3AC1EF">7. G√©n√©rateurs</font> </h2><br>  Les g√©n√©rateurs JavaScript sont d√©clar√©s √† l'aide d'un caract√®re ast√©risque.  Ils vous permettent de sp√©cifier la valeur qui sera retourn√©e la prochaine fois que la m√©thode <code>next()</code> sera appel√©e.  Les g√©n√©rateurs peuvent √™tre con√ßus pour renvoyer un nombre limit√© de valeurs.  Si un tel g√©n√©rateur a renvoy√© toutes ces valeurs, le prochain appel √† <code>next()</code> renverra <code>undefined</code> .  Vous pouvez √©galement cr√©er des g√©n√©rateurs con√ßus pour renvoyer un nombre illimit√© de valeurs √† l'aide de cycles. <br><br>  Voici un g√©n√©rateur con√ßu pour renvoyer un nombre limit√© de valeurs: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greeter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'Hi'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'How are you?'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'Bye'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greet = greeter(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greet.next().value); <span class="hljs-comment"><span class="hljs-comment">// 'Hi' console.log(greet.next().value); // 'How are you?' console.log(greet.next().value); // 'Bye' console.log(greet.next().value); // undefined</span></span></code> </pre> <br>  Et voici un g√©n√©rateur con√ßu pour renvoyer un nombre infini de valeurs √† travers une boucle. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">idCreator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)   <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> i++; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ids = idCreator(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ids.next().value); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(ids.next().value); // 1 console.log(ids.next().value); // 2 //   ...</span></span></code> </pre><br><h2>  <font color="#3AC1EF">8. Op√©rateurs de v√©rification de l'√©galit√© (==) et de l'√©galit√© stricte (===) des valeurs</font> </h2><br>  Il est extr√™mement important pour tout d√©veloppeur JS de comprendre la diff√©rence entre les op√©rateurs d'√©galit√© ( <code>==</code> ) et d'√©galit√© stricte ( <code>===</code> ).  Le fait est que l'op√©rateur <code>==</code> , avant de comparer les valeurs, effectue la conversion de leurs types (ce qui peut entra√Æner des cons√©quences √©tranges √† premi√®re vue), et l'op√©rateur <code>===</code> n'effectue pas de conversion de type. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">0</span></span> == <span class="hljs-string"><span class="hljs-string">'0'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true console.log(0 === '0'); // false</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">9. Comparaison d'objets</font> </h2><br>  Je dois parfois voir comment les nouveaux venus dans la programmation JS font la m√™me erreur.  Ils essaient de comparer directement les objets.  Les variables dans lesquelles les objets sont "stock√©s" contiennent des r√©f√©rences √† eux, et non ces objets eux-m√™mes. <br><br>  Ainsi, par exemple, dans l'exemple suivant, les objets se ressemblent, mais lorsqu'ils sont compar√©s directement, nous sommes inform√©s que les objets sont diff√©rents, car chacune des variables contient un lien vers son propre objet et ces liens ne sont pas √©gaux les uns aux autres. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe2 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(joe1 === joe2); <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  De plus, dans l'exemple suivant, il s'av√®re que <code>joe1</code> est √©gal √† <code>joe2</code> puisque les deux variables stockent une r√©f√©rence au m√™me objet. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe1 = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Joe'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> joe2 = joe1; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(joe1 === joe2); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  L'une des m√©thodes de comparaison d'objets r√©els est leur conversion pr√©liminaire au format de cha√Æne JSON.  Certes, cette approche a un probl√®me, qui est que dans la repr√©sentation en cha√Æne obtenue de l'objet, un certain ordre de ses propri√©t√©s n'est pas garanti.  Un moyen plus fiable de comparer des objets consiste √† utiliser une biblioth√®que sp√©ciale contenant des outils pour une comparaison approfondie des objets (par exemple, il s'agit de la m√©thode <a href="">isEqual ()</a> de la biblioth√®que <a href="">lodash</a> ). <br><br>  Afin de mieux comprendre les subtilit√©s de la comparaison d'objets et de comprendre les cons√©quences possibles de l'√©criture de liens vers les m√™mes objets dans diff√©rentes variables, jetez un ≈ìil au premier concept JS discut√© dans cet article. <br><br><h2>  <font color="#3AC1EF">10. Fonctions de rappel</font> </h2><br>  Les fonctions de rappel sont un concept JavaScript assez simple avec lequel les d√©butants ont parfois des difficult√©s.  Prenons l'exemple suivant.  Ici, la fonction <code>console.log</code> (juste comme √ßa - sans parenth√®ses) est pass√©e √† <code>myFunc()</code> tant que fonction de rappel.  Cette fonction d√©finit un temporisateur, apr√®s quoi <code>console.log()</code> est appel√©e et la cha√Æne pass√©e √† <code>myFunc()</code> s'affiche dans la console. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text, callback</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   callback(text); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); } myFunc(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log); <span class="hljs-comment"><span class="hljs-comment">// 'Hello world!'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">11. Promesses</font> </h2><br>  Apr√®s avoir ma√Ætris√© les fonctions de rappel et commenc√© √† les utiliser partout, vous vous retrouverez bient√¥t dans le soi-disant ¬´enfer du rappel¬ª.  Si vous √™tes vraiment l√†, jetez un ≈ìil aux promesses.  Le code asynchrone peut √™tre envelopp√© dans une promesse et, apr√®s son ex√©cution r√©ussie, informer le syst√®me de la r√©solution r√©ussie de la promesse en appelant la m√©thode appropri√©e, et si quelque chose ne va pas - appelez la m√©thode pour l'indiquer et rejetez la promesse.  Pour traiter les r√©sultats renvoy√©s par la promesse, utilisez la m√©thode <code>then()</code> et pour la gestion des erreurs, utilisez la m√©thode <code>catch()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, rej</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &lt; <span class="hljs-number"><span class="hljs-number">0.9</span></span>) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res(<span class="hljs-string"><span class="hljs-string">'Hooray!'</span></span>);   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rej(<span class="hljs-string"><span class="hljs-string">'Oh no!'</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); myPromise .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Success: '</span></span> + data);  })  .catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Error: '</span></span> + err);  }); <span class="hljs-comment"><span class="hljs-comment">//  Math.random()  , ,  0.9,    : // "Success: Hooray!" //  Math.random()  , ,  0.9,  0.9,    : // "Error: On no!"</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">12. async / attente de construction</font> </h2><br>  Apr√®s avoir travaill√© avec les promesses, alors, tr√®s probablement, vous voudrez quelque chose de plus.  Par exemple, ma√Ætrisez la construction async / wait.  C'est du sucre syntaxique pour les promesses.  Dans l'exemple suivant, nous cr√©ons, √† l'aide du <code>async</code> - <code>async</code> , une fonction asynchrone, et dans celui-ci, √† l'aide du mot-cl√© wait, nous organisons l'attente de la fin de la <code>greeter</code> r√©ception. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, rej</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> res(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>), <span class="hljs-number"><span class="hljs-number">2000</span></span>); }) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> greeting = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> greeter; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greeting); } myFunc(); <span class="hljs-comment"><span class="hljs-comment">// 'Hello world!'</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Si ce dont nous avons parl√© ici ne vous √©tait pas familier auparavant, vous avez probablement, au moins un peu, d√©pass√© votre niveau en lisant cet article.  Si vous n'avez rien trouv√© de nouveau ici, j'esp√®re que ce mat√©riel vous a donn√© l'occasion de pratiquer et de renforcer votre connaissance de JavaScript. <br><br>  <b>Chers lecteurs!</b>  Quels autres concepts JavaScript ajouteriez-vous √† cet article? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441566/">https://habr.com/ru/post/fr441566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441546/index.html">Hayabusa-2 "a d'abord touch√© l'ast√©ro√Øde</a></li>
<li><a href="../fr441550/index.html">La vie d'un simple programmeur est dure et simple</a></li>
<li><a href="../fr441554/index.html">Toute l'histoire de Linux. Partie I: comment tout a commenc√©</a></li>
<li><a href="../fr441560/index.html">√âv√©nements num√©riques √† Moscou du 25 f√©vrier au 3 mars</a></li>
<li><a href="../fr441562/index.html">Pixel Gallop - Cinqui√®me partie - Animation de personnages. Marcher</a></li>
<li><a href="../fr441568/index.html">Gestion de la m√©moire Python</a></li>
<li><a href="../fr441570/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 353 (17-24 f√©vrier 2019)</a></li>
<li><a href="../fr441572/index.html">Frontend Weekly Digest (18-24 f√©vrier 2019)</a></li>
<li><a href="../fr441574/index.html">Apprendre Docker Partie 6: Travailler avec des donn√©es</a></li>
<li><a href="../fr441576/index.html">R√©seaux Kubernetes: Pods</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>