<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòΩ üëÇüèª ü§≤üèΩ Comment ne pas se tromper avec la concurrence dans Go üöµüèø ‚öôÔ∏è üëåüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi voulons-nous m√™me √©crire du code concurrentiel? Parce que les processeurs ont cess√© de cro√Ætre le long des creux et ont commenc√© √† cro√Ætre le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment ne pas se tromper avec la concurrence dans Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/466495/"><p>  Pourquoi voulons-nous m√™me √©crire du code concurrentiel?  Parce que les processeurs ont cess√© de cro√Ætre le long des creux et ont commenc√© √† cro√Ætre le long des noyaux.  Le nombre de c≈ìurs de processeur augmente chaque ann√©e et nous voulons les utiliser efficacement.  Go est la langue cr√©√©e pour cela.  La documentation le dit. </p><br><p> Nous prenons Go, commen√ßons √† √©crire du code comp√©titif.  Bien s√ªr, nous nous attendons √† pouvoir facilement limiter la puissance de chaque c≈ìur de notre processeur.  En est-il ainsi? </p><br><p>  <em>Je m'appelle Artemy.</em>  <em>Ce message est une transcription gratuite de mon entretien avec GopherCon Russie.</em>  <em>Il est apparu comme une tentative de donner un √©lan aux personnes qui veulent comprendre comment √©crire un bon code comp√©titif.</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/4U3EaVufuW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Vid√©o de la conf√©rence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GopherCon Russie</a></em> </p><a name="habracut"></a><br><h1 id="modeli-vzaimodeystviya">  Mod√®les d'interaction </h1><br><p>  Pour comprendre si Go nous facilite vraiment la t√¢che, examinons deux mod√®les d'interaction: <strong>m√©moire partag√©e</strong> et <strong>transmission de messages</strong> . </p><br><p><img src="https://habrastorage.org/webt/xv/09/f1/xv09f1rq3eum5hnsuwdqdgrj97m.png"></p><br><ul><li><p>  <strong>La m√©moire</strong> partag√©e concerne la m√©moire partag√©e que plusieurs threads utilisent pour √©changer des donn√©es.  L'acc√®s √† la m√©moire doit √™tre synchronis√©.  Cette synchronisation est g√©n√©ralement impl√©ment√©e par une sorte de verrous.  Cette approche est consid√©r√©e comme une communication implicite. </p><br></li><li><p>  <strong>La transmission de messages</strong> indique que nous interagirons explicitement, et pour cela, nous utiliserons les canaux dans lesquels nous enverrons des messages.  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CSP</a> ( <em>Communicating Sequential Processes</em> ) et le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le d'acteur</a> sont bas√©s sur cette approche. </p><br></li></ul><br><p><img src="https://habrastorage.org/webt/wi/ss/jr/wissjrv4uu2-3ng62qsdtjbunbk.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rob Pike</a> , qui est le p√®re fondateur de Go, dit que vous devez abandonner la programmation de bas niveau en utilisant la <strong>m√©moire partag√©e</strong> et utiliser l'approche de <strong>transmission de messages</strong> .  Cette approche vous aidera √† √©crire du code plus facilement, plus efficacement et, surtout, avec moins de bogues.  Go choisit l'approche <strong>CSP</strong> .  La m√™me approche a grandement influenc√© le d√©veloppement d'une langue comme Erlang. </p><br><p>  Question: Est-il vrai que si nous prenons Go, tout ira bien? </p><br><p><img src="https://habrastorage.org/webt/ld/uc/px/lducpx4ezb14rvygaamxzz0_-vy.png"></p><br><p>  Je suis tomb√© sur une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©tude</a> dans laquelle cette tablette a √©t√© trouv√©e.  La tablette indique les raisons et le nombre de bugs li√©s aux verrous.  La premi√®re colonne montre les produits qui ont √©t√© inclus dans l'√©tude.  Ce sont les produits les plus populaires √©crits en Go.  La colonne M√©moire partag√©e indique le nombre de bogues qui surviennent en raison d'une mauvaise utilisation de la m√©moire partag√©e et la colonne Message Passing, respectivement, indique le nombre de bogues dus √† Message Passing. </p><br><p>  La chose la plus importante sur cette plaque est la ligne <strong>Total</strong> .  Si vous le regardez, vous remarquerez qu'il y a plus de bogues lors de l'utilisation de la <strong>transmission de messages</strong> que lors de l'utilisation de la <strong>m√©moire partag√©e</strong> .  Je suis s√ªr que les personnes qui √©crivent Kubernetes, Docker ou etcd sont des d√©veloppeurs assez exp√©riment√©s, mais m√™me le <strong>passage de messages</strong> ne les sauve pas des erreurs, et ces erreurs ne sont pas moins qu'avec la m√©moire partag√©e. </p><br><p>  Donc, prendre Go et commencer √† √©crire du code sans erreur √©chouera. </p><br><h1 id="concurrency-i-parallelism">  Concurrence et parall√©lisme </h1><br><p>  Lorsque nous commen√ßons √† parler de d√©veloppement multi-thread, nous devons introduire des concepts tels que la <strong>concurrence</strong> et le <strong>parall√©lisme</strong> .  Dans le monde de Go, il y a l'expression <em>¬´la concurrence n'est pas le parall√©lisme¬ª</em> .  L'essentiel est que la <strong>concurrence</strong> concerne la conception, c'est-√†-dire la fa√ßon dont nous concevons notre programme.  <strong>Le parall√©lisme</strong> n'est qu'un moyen d'ex√©cuter notre code. </p><br><p><img src="https://habrastorage.org/webt/uk/tr/es/uktresizsgqpphu4mkmjlep00fe.png"></p><br><p>  Si nous avons plusieurs fils d'instructions qui sont ex√©cut√©s simultan√©ment, alors nous ex√©cutons le code en parall√®le.  Le parall√©lisme requiert de la concurrence.  Il ne sera pas possible de parall√©liser un programme sans une conception comp√©titive, tandis que la comp√©titivit√© ne n√©cessite pas le parall√©lisme, car un programme qui peut fonctionner sur de nombreux c≈ìurs, en fait, peut fonctionner sur un seul c≈ìur. </p><br><p>  Go est un langage qui nous aide √† √©crire des programmes comp√©titifs, nous aide √† construire le design.  Cela vous permet de penser un peu moins aux choses de bas niveau. </p><br><h1 id="zakon-amdala">  La loi d'Amdahl </h1><br><p>  Nous voulons utiliser les c≈ìurs de processeur, nous √©crivons du code pour cela.  Mais la question se pose: quel type d'augmentation de la productivit√© nous obtenons avec une augmentation du nombre de c≈ìurs.  Ainsi, l'acc√©l√©ration que nous pouvons obtenir, elle est, en fait, limit√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par la loi d'Amdal</a> . </p><br><p><img src="https://habrastorage.org/webt/dz/cc/bu/dzccbu8elu2vaogt54-u_gg4m4w.png"></p><br><p>  Qu'est-ce que l'acc√©l√©ration?  L'acc√©l√©ration est la dur√©e d'ex√©cution d'un programme sur un seul processeur divis√©e par la dur√©e d'ex√©cution d'un programme sur <strong>P</strong> processeurs.  La lettre <strong>F</strong> ( <em>fraction</em> ) d√©signe la partie du programme qui doit √™tre ex√©cut√©e s√©quentiellement.  Et ici, il n'est m√™me pas n√©cessaire de se plonger dans la formule, l'essentiel est de noter que l'acc√©l√©ration maximale que l'on obtient avec une augmentation du nombre de noyaux d√©pend fortement de <strong>F.</strong>  Jetez un ≈ìil au graphique pour visualiser cette relation. </p><br><p><img src="https://habrastorage.org/webt/uw/c7/bn/uwc7bn5ngru2scvqaphzayuvboc.png"></p><br><p>  M√™me si nous n'avons que 5% du programme √† ex√©cuter s√©quentiellement, l'acc√©l√©ration maximale que nous obtenons diminuera consid√©rablement avec une augmentation du nombre de c≈ìurs.  Vous pouvez estimer quelles sont les parties qui augmentent <strong>F.</strong> </p><br><p><img src="https://habrastorage.org/webt/4o/pu/a8/4opua82_adysln9-enejf9-m-iu.png"></p><br><h1 id="cpu-bound-vs-io-bound">  CPU Bound vs I / O Bound </h1><br><p>  Il n'est pas toujours judicieux d'utiliser le multithreading.  Vous devez d'abord regarder le type de charge.  Il existe deux types de charge: <strong>CPU Bound</strong> et <strong>I / O Bound</strong> .  La diff√©rence est qu'avec CPU Bound, nous sommes limit√©s par les performances du processeur, et avec I / O Bound, nous sommes limit√©s par la vitesse de notre sous-syst√®me d'E / S.  Pas m√™me la vitesse, mais le temps d'attente pour une r√©ponse.  Aller en ligne - attendre une r√©ponse, aller sur le disque - encore une fois attendre une r√©ponse.  Quelle est la diff√©rence, combien de c≈ìurs y a-t-il, si la plupart du temps on attend une r√©ponse? </p><br><p><img src="https://habrastorage.org/webt/xp/dk/yl/xpdkylyp6etnvk2qlw0txhjktby.png"></p><br><p>  Par cons√©quent, un c≈ìur ou mille, nous n'obtiendrons pas d'augmentation des performances sous la charge li√©e aux E / S.  Mais si nous avons une charge CPU Bound, alors il y a une chance d'obtenir une acc√©l√©ration lors de la parall√©lisation de notre programme. </p><br><p>  Bien qu'il existe des situations o√π la charge apparente du CPU Bound, elle d√©g√©n√®re en fait en un I / O Bound.  Si, par exemple, nous voulons prendre et additionner tous les √©l√©ments d'un grand tableau, que ferons-nous?  Nous √©crirons un cycle, tout fonctionnera.  Puis nous pensons: ¬´Nous avons donc un tas de c≈ìurs.  Prenons-le, divisons le tableau en morceaux et parall√©lisons le tout. ¬ª  Quel sera le r√©sultat? </p><br><p><img src="https://habrastorage.org/webt/5z/hy/zo/5zhyzoxnnpay_wnc1ypjmwesxeo.png"></p><br><p>  Le r√©sultat est une situation o√π notre processeur traite les donn√©es plus rapidement qu'il ne parvient √† provenir de la m√©moire.  Dans ce cas, la plupart du temps, nous attendrons les donn√©es de la m√©moire, et la charge, qui semblait √™tre li√©e au processeur, se r√©v√®le en fait √™tre li√©e aux E / S. </p><br><h1 id="false-sharing">  Faux partage </h1><br><p>  De plus, il y a une histoire comme <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">False Sharing</a></strong> .  Le faux partage est une situation o√π les noyaux commencent √† interf√©rer les uns avec les autres.  Il y a un premier noyau, il y a un deuxi√®me noyau, et chacun d'eux a son propre <strong>cache L1</strong> .  Le cache L1 est divis√© en lignes ( <em>ligne de cache</em> ) de 64 octets.  Lorsque nous obtenons des donn√©es de la m√©moire, nous obtenons toujours pas moins de 64 octets.  En modifiant ces donn√©es, nous d√©sactivons les caches de tous les c≈ìurs. </p><br><p><img src="https://habrastorage.org/webt/b4/ug/ne/b4ugnemfq4lkhv22yhxhuxeytdq.png"></p><br><p>  Il s'av√®re que si deux c≈ìurs modifient des donn√©es tr√®s proches l'une de l'autre ( <em>√† une distance inf√©rieure √† 64 octets</em> ), ils commencent √† interf√©rer l'un avec l'autre, invalidant les caches.  Dans ce cas, si le programme √©tait √©crit s√©quentiellement, il fonctionnerait plus rapidement que lors de l'utilisation de plusieurs c≈ìurs qui interf√®rent les uns avec les autres.  Plus il y a de c≈ìurs, plus les performances sont faibles. </p><br><h1 id="schedulers">  Planificateurs </h1><br><p>  Nous passerons au prochain niveau d'abstraction - aux planificateurs. </p><br><p>  Lorsque le travail commence avec un code concurrentiel, des planificateurs apparaissent.  Go a un soi-disant <strong>planificateur d'espace utilisateur</strong> qui fonctionne sur des <strong>goroutines</strong> .  Le syst√®me d'exploitation a √©galement son propre <strong>ordonnanceur</strong> , qui fonctionne avec les <strong>threads du syst√®me d'exploitation</strong> .  Et m√™me le processeur n'est pas si simple.  Par exemple, les processeurs modernes ont une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©diction de branche</a> et d'autres fa√ßons de g√¢cher notre belle image de la lin√©arisation du monde. </p><br><p><img src="https://habrastorage.org/webt/cf/dc/1k/cfdc1kw8l7axejmswctoqpawlmc.png"></p><br><p>  Les planificateurs sont divis√©s par type de multit√¢che.  Il existe <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un multit√¢che coop√©ratif</a></strong> et <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un multit√¢che pr√©emptif</a></strong> .  Dans le cas du <strong>multit√¢che coop√©ratif</strong> , le <strong>processus d'</strong> ex√©cution <strong>lui-m√™me d√©cide</strong> quand il doit transf√©rer le contr√¥le √† un autre processus, et dans le cas du <strong>multit√¢che surcharg√©,</strong> il existe <strong>un composant externe</strong> - planificateur, qui contr√¥le la quantit√© de ressources allou√©es au processus. </p><br><p><img src="https://habrastorage.org/webt/vo/o_/tx/voo_tx_4vfug0jinekpu5f-o-ha.png"></p><br><p>  Le multit√¢che coop√©ratif permet √† un processus de ¬´monopoliser¬ª la totalit√© de la ressource CPU.  Dans le multit√¢che pr√©emptif, cela ne se produira pas, car il existe un organisme de contr√¥le.  Mais avec le multit√¢che coop√©ratif, le changement de contexte est plus efficace, car le processus sait avec certitude √† quel moment il vaut mieux donner le contr√¥le √† un autre processus.  Dans le multit√¢che pr√©emptif, le planificateur peut arr√™ter le processus √† tout moment - ce n'est pas tr√®s efficace.  En m√™me temps, en multit√¢che pr√©emptif, nous pouvons fournir la m√™me ressource pour chaque processus gr√¢ce √† un planificateur externe. </p><br><p>  Le syst√®me d'exploitation utilise un planificateur bas√© sur le multit√¢che pr√©emptif, car le syst√®me d'exploitation est n√©cessaire pour garantir des conditions √©gales pour chaque utilisateur.  Et Go? </p><br><p><img src="https://habrastorage.org/webt/8d/ry/dd/8drydde54y4ytkr_t2qrcznevvy.png"></p><br><p>  Si nous lisons la documentation, nous apprenons que le planificateur de Go est pr√©emptif.  Mais, lorsque nous commen√ßons √† comprendre, il s'av√®re que Go n'a pas de planificateur comme composant externe.  Dans Go, le compilateur d√©finit les points de changement de contexte.  Et bien que nous, en tant que d√©veloppeurs, n'ayons pas besoin de changer manuellement le contexte, le contr√¥le de commutation n'est pas retir√© au composant externe.  Gr√¢ce √† cela, Go est tr√®s efficace pour passer d'un goroutine √† un autre.  Mais une mauvaise compr√©hension des caract√©ristiques du travail d'un tel ¬´planificateur¬ª peut conduire √† un comportement inattendu.  Par exemple, que produira ce code? </p><br><p><img src="https://habrastorage.org/webt/4p/7i/tm/4p7itmw8_pusfpg5whtkjawfqt4.png"></p><br><p>  Un tel code se fige. </p><br><p> Pourquoi?  Parce qu'au d√©but, en utilisant <code>GOMAXPROCS</code> , nous avons forc√© le programme √† utiliser un seul c≈ìur.  Apr√®s cela, le goroutine a √©t√© mis dans la file d'attente, √† l'int√©rieur duquel un cycle sans fin devrait fonctionner.  Ensuite, nous attendons 500 ms et imprimons <code>x</code> .  Apr√®s <code>time.Sleep</code> goroutine d√©marrera r√©ellement, mais il n'y aura aucun moyen de sortir de la boucle infinie, car le compilateur ne mettra pas le point de changement de contexte.  Le programme se bloque. </p><br><p>  Et si nous ajoutons <code>runtime.Gosched()</code> √† l'int√©rieur de la boucle, tout ira bien, car nous indiquerons explicitement que nous voulons changer de contexte. </p><br><p>  Ces fonctionnalit√©s doivent √©galement √™tre connues et m√©moris√©es. </p><br><p>  Nous avons parl√© de changement de contexte, mais o√π Go ins√®re-t-il g√©n√©ralement des points de commutation? </p><br><p><img src="https://habrastorage.org/webt/8k/6k/bo/8k6kbop0qpvsimvezerzshdc0qm.png"></p><br><p>  <code>runtime.morestack()</code> et <code>runtime.newstack()</code> sont g√©n√©ralement ins√©r√©s au moment o√π la fonction est appel√©e.  <code>runtime.Goshed()</code> nous pouvons nous fournir.  Et bien s√ªr, le changement de contexte se produit pendant les verrous, les hausses de r√©seau et les appels syst√®me.  Vous pouvez regarder √† ce sujet un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport de Kirill Lashkevich</a> .  Tr√®s bien, je conseille. </p><br><p>  Allons plus loin dans le code.  Nous allons examiner les erreurs. </p><br><h1 id="race-condition">  Condition de course </h1><br><p>  L'une des erreurs les plus populaires que nous commettons est la <code>Race Condition</code> .  L'essentiel, c'est que lorsque nous faisons, par exemple, un incr√©ment, en fait, nous ne faisons pas une op√©ration, mais plusieurs: le processeur lit les donn√©es de la m√©moire pour les enregistrer, met √† jour le registre et √©crit les donn√©es dans la m√©moire. </p><br><p><img src="https://habrastorage.org/webt/jf/ar/zs/jfarzsk1prxonyme8fx7b1yvg1s.png"></p><br><p>  Ces trois op√©rations ne sont pas effectu√©es de mani√®re atomique.  Par cons√©quent, le planificateur √† tout moment, sur n'importe laquelle de ces op√©rations, peut prendre et √©vincer notre flux.  Il s'av√®re que l'action n'est pas termin√©e, et √† cause de cela, nous attrapons des bugs. </p><br><p>  Voici un exemple d'un tel code (l' <em>incr√©ment est imm√©diatement d√©compos√© en plusieurs op√©rations</em> ). </p><br><p><img src="https://habrastorage.org/webt/jt/kj/c9/jtkjc97ruwb4ejlt7btjhybjh0u.png"></p><br><p>  Le planificateur peut pr√©empter le premier thread apr√®s l'ex√©cution de la premi√®re ligne et le deuxi√®me thread apr√®s avoir v√©rifi√© la condition.  Dans ce cas, les deux flux tomberont dans la section critique, et donc ils sont ¬´critiques¬ª - les deux flux ne peuvent pas y √™tre entr√©s simultan√©ment. </p><br><p>  Nous pouvons verrouiller en utilisant <code>sync.Mutex</code> partir du package de <code>sync</code> standard.  Le blocage d'acc√®s nous permet d'indiquer explicitement que le code doit √™tre ex√©cut√© par un thread √† la fois.  Avec ce code, nous obtenons ce dont nous avons besoin. </p><br><p><img src="https://habrastorage.org/webt/5w/hf/2w/5whf2wr5xmhbkhxrnarppopowfe.png"></p><br><p>  Les verrous sont une op√©ration assez co√ªteuse.  Par cons√©quent, il existe des op√©rations atomiques au niveau du processeur.  Dans ce cas, l'incr√©ment peut √™tre rendu atomique en le rempla√ßant par l'op√©ration <code>atomic.AddInt64</code> du package <code>atomic</code> . </p><br><p><img src="https://habrastorage.org/webt/-f/1o/rz/-f1orz2g4oar-_b0ef0vk7m4o6y.png"></p><br><p>  Si nous commen√ßons √† travailler avec des instructions atomiques, nous devons non seulement √©crire atomiquement, mais aussi lire atomiquement.  Si nous ne le faisons pas, des probl√®mes peuvent survenir. </p><br><h1 id="optimizacii--what-could-possibly-go-wrong">  Optimisation - Qu'est-ce qui pourrait mal tourner? </h1><br><p>  Les verrous sont bons, mais peuvent √™tre chers.  Les atomiques sont assez bon march√© pour ne pas se soucier des performances. </p><br><p>  Nous avons donc appris que les primitives de synchronisation introduisaient une surcharge et avons d√©cid√© d'ajouter une optimisation - nous v√©rifierons l'indicateur sans tenir compte du multithreading, puis rev√©rifierons en utilisant des primitives de synchronisation.  Tout semble bien et devrait fonctionner. </p><br><p><img src="https://habrastorage.org/webt/jq/9u/cm/jq9ucmurmj-x9y4i9eu8ojzkfem.png"></p><br><p>  Tout va bien, sauf que le compilateur essaie d'optimiser notre code.  Que fait-il?  Il √©change les instructions d'affectation, et nous obtenons un comportement non valide, car notre <code>done</code> devient <code>true</code> avant que la valeur de la variable ¬´ <code></code> ¬ª ne soit affect√©e. </p><br><p>  N'essayez pas de faire de telles optimisations - √† cause d'eux, vous aurez beaucoup de probl√®mes.  Je vous conseille de lire la sp√©cification du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le de m√©moire Go</a> et un article de Dmitry Vyukova ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@dvyukov</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Courses de donn√©es b√©nignes: qu'est-ce qui pourrait</a> mal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tourner</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">?</a>  pour mieux comprendre les enjeux. </p><br><p>  Si vous comptez vraiment sur les performances des verrous, √©crivez du code sans verrouillage, mais vous n'avez pas besoin de faire un acc√®s non synchronis√© √† la m√©moire. </p><br><h1 id="deadlock">  Impasse </h1><br><p>  Le prochain probl√®me auquel nous serons confront√©s est Deadlock.  Il peut sembler que tout est assez trivial ici.  Il existe deux ressources, par exemple, deux <code>Mutex</code> .  Dans le premier thread, nous capturons d'abord le premier <code>Mutex</code> , et dans le deuxi√®me thread, nous capturons d'abord le deuxi√®me <code>Mutex</code> .  De plus, nous voudrons prendre le deuxi√®me <code>Mutex</code> dans le premier thread, mais nous ne pourrons pas le faire, car il est d√©j√† bloqu√©.  Dans le deuxi√®me thread, nous allons essayer de prendre, respectivement, le premier <code>Mutex</code> et aussi le bloc.  Il est l√†, Deadlock. </p><br><p><img src="https://habrastorage.org/webt/pe/vk/y1/pevky1zcbkqtftopczdgbg2_xuu.png"></p><br><p>  Aucun de ces deux threads ne pourra progresser davantage, car les deux attendront la ressource.  Comment est-ce r√©solu?  Nous √©changeons les verrous, puis aucun probl√®me ne se pose.  Bien s√ªr, c'est facile √† dire, mais le maintien de cette r√®gle tout au long de la vie du produit n'est pas facile.  Si possible, faites-le - <strong>prenez et remettez les serrures dans le m√™me ordre</strong> . </p><br><p>  Il peut sembler que les d√©veloppeurs exp√©riment√©s ne rencontrent pas de telles erreurs, mais voici un exemple de blocage du code de projet etcd. </p><br><p><img src="https://habrastorage.org/webt/iq/8l/pe/iq8lpexqj2xc_ykt2qzzgbxxiwu.png"></p><br><p>  Ici, le principal probl√®me est que l'√©criture sur un canal sans tampon est bloquante; pour √©crire, vous avez besoin d'un lecteur d'autre part.  Prenant le mutex, le premier fil attend que le lecteur apparaisse.  Le deuxi√®me thread ne peut plus capturer le mutex.  Impasse </p><br><p>  Je vous conseille d'essayer le jeu passionnant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Deadlock Empire</a> .  Dans ce jeu, vous agissez comme un planificateur qui doit changer de contexte afin d'emp√™cher le code de s'ex√©cuter correctement. </p><br><h1 id="sort-of-problems">  Sorte de probl√®mes </h1><br><p>  Quels probl√®mes existent encore?  Nous avons commenc√© avec les <strong>conditions de course</strong> .  Ensuite, nous avons examin√© <strong>Deadlock</strong> (il existe encore une variante de <strong>Livelock</strong> , c'est √† ce moment que nous ne pouvons pas capturer la ressource, mais il n'y a pas de verrous explicites).  Il y a la <strong>famine</strong> , c'est quand nous allons √† l'imprimante pour imprimer un morceau de papier, et il y a une file d'attente, et nous ne pouvons pas acc√©der √† la ressource.  Nous avons examin√© le comportement du programme avec <strong>False Sharing</strong> .  Il y a toujours un probl√®me - <strong>Lock Contention</strong> , lorsque les performances se d√©gradent en raison de la forte concurrence pour une ressource (par exemple, un mutex dont un grand nombre de threads ont besoin). </p><br><p><img src="https://habrastorage.org/webt/yo/5x/dz/yo5xdzb1iqwunpsqjitejygw_ji.png"></p><br><h1 id="race-detection">  D√©tection de course </h1><br><p>  Go est puissant avec la bo√Æte √† outils fournie.  <strong>Race Detector</strong> est un de ces outils.  Son utilisation est simple: nous √©crivons des tests ou l'ex√©cutons sur une charge de combat et prenons des erreurs. <br>  Vous pouvez en savoir plus sur l'utilisation du Race Detector <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la documentation</a> , mais n'oubliez pas qu'il a des limites.  Arr√™tons-nous plus en d√©tail sur eux. </p><br><p><img src="https://habrastorage.org/webt/sq/ft/kq/sqftkq68nj93cffxblalpvqss9s.png"></p><br><p>  Premi√®rement, le code non ex√©cut√© n'est pas v√©rifi√© par le Race Detector.  Par cons√©quent, la couverture du test doit √™tre √©lev√©e.  De plus, le Race Detector se souvient de l'historique des appels √† chaque mot en m√©moire, mais cet historique des appels a de la profondeur.  Dans Go, par exemple, cette profondeur est de quatre √† quatre √©l√©ments, quatre acc√®s.  Si le d√©tecteur de course n'a pas pris de course dans cette profondeur, il pense qu'il n'y a pas de course.  Par cons√©quent, bien que le d√©tecteur de course ne se soit jamais tromp√©, il ne d√©tectera pas toutes les erreurs.  Vous pouvez esp√©rer pour le d√©tecteur de course, mais vous devez vous rappeler ses limites.  S√©par√©ment, vous pouvez lire sur l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">algorithme de travail</a> . </p><br><h1 id="block-profile">  Profil de bloc </h1><br><p>  <strong>Le profil de blocage</strong> est un autre outil qui nous permet de trouver et de r√©soudre les probl√®mes de blocage. </p><br><p><img src="https://habrastorage.org/webt/hg/ex/ft/hgexftmdroak4fgg0udjq4s4vow.png"></p><br><p>  Il peut √™tre utilis√© √† la fois au niveau du test de r√©f√©rence et peut √™tre observ√© pendant la charge de combat.  Par cons√©quent, si vous recherchez des probl√®mes associ√©s √† la synchronisation de l'acc√®s aux donn√©es, essayez de d√©marrer avec le d√©tecteur de course et continuez √† utiliser le profil de blocage. </p><br><h1 id="primer-programmy">  Exemple de programme </h1><br><p>  Regardons le vrai code sur lequel nous pouvons tomber.  Nous allons √©crire une fonction qui prend simplement un tableau de requ√™tes et essaie de les ex√©cuter: chaque requ√™te en s√©quence.  Si l'une des demandes renvoie une erreur, la fonction met fin √† l'ex√©cution. </p><br><p><img src="https://habrastorage.org/webt/r_/kl/3w/r_kl3wjbfxfsfa5dvbs34afvtww.png"></p><br><p>  Si nous √©crivons en Go, nous devons utiliser toute la puissance de la langue.  Nous essayons.  Nous obtenons trois fois plus de code. </p><br><p><img src="https://habrastorage.org/webt/nc/qt/_q/ncqt_qwhoahbahx9tdmuspt1_1c.png"></p><br><p>  Question: y a-t-il des erreurs dans le code? </p><br><p>  Bien s√ªr!  Regardons lesquels. </p><br><p>  Dans la boucle, nous courons des goroutines.  Pour l'orchestration de goroutine, nous utilisons <code>sync.WaitGroup</code> .  Mais qu'est-ce qu'on fait mal?  D√©j√† √† l'int√©rieur du goroutine en cours d'ex√©cution, nous appelons <code>wg.Add(1)</code> , c'est-√†-dire que nous ajoutons un goroutine de plus √† attendre.  Et en utilisant <code>wg.Wait()</code> , nous attendons que tous les goroutines se terminent.  Mais il peut arriver qu'au moment o√π <code>wg.Wait()</code> est appel√©, pas un seul goroutine ne d√©marre.  Dans ce cas, <code>wg.Wait()</code> consid√©rera que tout est fait, nous fermerons le canal et quitterons la fonction sans erreur, croyant que tout va bien. </p><br><p><img src="https://habrastorage.org/webt/o1/wv/7m/o1wv7mielcch1r4k3zmdgfksbk4.png"></p><br><p>  Que se passera-t-il ensuite?  Ensuite, les goroutines d√©marreront, le code s'ex√©cutera et peut-√™tre qu'une des requ√™tes retournera une erreur.  Une erreur est √©crite sur un canal ferm√© et l'√©criture sur un canal ferm√© est une panique.  Notre application va planter.  Il est peu probable que ce soit ce que je voulais obtenir, nous le corrigeons donc en indiquant √† l'avance combien de goroutines nous lancerons. </p><br><p><img src="https://habrastorage.org/webt/ly/re/v6/lyrev61roq8cswx4q0itv12reyy.png"></p><br><p>  Peut-√™tre qu'il y a encore des probl√®mes? </p><br><p>  Il y a une erreur li√©e √† la fa√ßon dont l'objet <code>req</code> appara√Æt √† l'int√©rieur de la fonction.  La variable <code>req</code> agit comme un it√©rateur du cycle, et nous ne savons pas quelle valeur elle aura au moment du lancement de la goroutine. </p><br><p><img src="https://habrastorage.org/webt/wi/xc/m2/wixcm2d3adxkmbqobaoapwm4ofq.png"></p><br><p>  En pratique, dans ce code, la valeur <code>req</code> sera tr√®s probablement √©gale au dernier √©l√©ment du tableau.  Par cons√©quent, vous envoyez simplement la m√™me demande N fois.  Correction: passez explicitement notre requ√™te en argument √† la fonction. </p><br><p><img src="https://habrastorage.org/webt/3g/gq/ty/3ggqtyg5-pgxmfhfkwruozrajyg.png"></p><br><p>  Examinons de plus pr√®s comment nous traitons les erreurs.  Nous d√©clarons un canal tamponn√© sur un emplacement.  Lorsqu'une erreur se produit, nous l'envoyons sur ce canal.  Tout semble aller bien: une erreur s'est produite - nous avons renvoy√© cette erreur √† partir d'une fonction. </p><br><p><img src="https://habrastorage.org/webt/3_/5-/ku/3_5-kufkknuxpfmc1tpsqn_aqr4.png"></p><br><p>  Mais que faire si toutes les demandes reviennent avec une erreur? </p><br><p>  Ensuite, l'√©criture sur le canal n'obtiendra que la premi√®re erreur, le reste bloquera l'ex√©cution des goroutines.  Puisqu'il n'y aura plus de lectures du canal au moment de quitter la fonction de lecture, nous obtenons une fuite de goroutine.  Autrement dit, tous ces gorutins qui n'ont pas pu √©crire l'erreur sur le canal se bloquent simplement en m√©moire. </p><br><p>  Nous le fixons tr√®s simplement: nous s√©lectionnons dans le canal de slot le nombre de requ√™tes.  Cela r√©sout notre probl√®me peu efficace en m√©moire, car si nous avons un milliard de requ√™tes, nous devons allouer un milliard de slots. </p><br><p><img src="https://habrastorage.org/webt/qe/nm/te/qenmteeutwuvzmmlu_lqjrnrhgy.png"></p><br><p>  Nous avons r√©solu les probl√®mes.  Le code est d√©sormais comp√©titif.  Mais le probl√®me vient de la lisibilit√© - par rapport √† la version synchrone du code, il y en a beaucoup.  Et ce n'est pas cool, car le d√©veloppement de programmes comp√©titifs est d√©j√† difficile, pourquoi le complique-t-on avec beaucoup de code? </p><br><p><img src="https://habrastorage.org/webt/ww/jx/v3/wwjxv3vhcewmqajtzlsrgqrsbli.png"></p><br><h1 id="errgroup">  Errgroup </h1><br><p>  Je sugg√®re d'augmenter la lisibilit√© du code. </p><br><p>  J'aime utiliser le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">errgroup</a> au lieu de <code>sync.WaitGroup</code> .  Ce package ne n√©cessite pas de sp√©cifier le nombre de goroutines √† attendre et vous permet d'ignorer la collection d'erreurs.  Voici √† quoi ressemblera notre fonction lorsque vous utiliserez <code>errgroup</code> : </p><br><p><img src="https://habrastorage.org/webt/p4/da/no/p4danooucpgyforvks7qd4eqmmi.png"></p><br><p>  De plus, <code>errgroup</code> permet d'orchestrer facilement les composants de notre programme en utilisant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">context.Context</a> .  Qu'est-ce que je veux dire? </p><br><p>  Supposons que nous ayons plusieurs composants de notre programme, si au moins l'un d'entre eux √©choue, nous voulons terminer soigneusement tous les autres.  Ainsi, <code>errgroup</code> lorsqu'une erreur <code>errgroup</code> , termine le <code>context</code> et, par cons√©quent, tous les composants re√ßoivent une notification sur la n√©cessit√© de terminer le travail. </p><br><p><img src="https://habrastorage.org/webt/5l/gb/95/5lgb95elqafmsoakuaktm1_nn2u.png"></p><br><p>  Cela peut √™tre utilis√© pour cr√©er des programmes multicomposants complexes qui se comportent de mani√®re pr√©visible. </p><br><h1 id="vyvody">  Conclusions </h1><br><p>  Rendez-le aussi simple que possible.  Mieux synchroniquement.  Le d√©veloppement de programmes multithread est g√©n√©ralement un processus complexe, conduisant √† l'apparition de bugs d√©sagr√©ables. </p><br><p><img src="https://habrastorage.org/webt/by/bl/nz/byblnzeor9pzwpraobylgc5yfme.png"></p><br><p>  N'utilisez pas de synchronisation implicite.  Si vous vous y √™tes vraiment repos√©, pensez √† comment vous d√©barrasser des verrous, comment cr√©er un algorithme sans verrouillage. </p><br><p>  Go est un bon langage pour √©crire des programmes qui fonctionnent efficacement avec un grand nombre de c≈ìurs, mais ce n'est pas mieux que toutes les autres langues, et des erreurs appara√Ætront toujours.  Par cons√©quent, m√™me arm√© de Go, essayez de comprendre plusieurs niveaux d'abstractions inf√©rieurs √† ce que vous travaillez. </p><br><p><img src="https://habrastorage.org/webt/ze/i7/rd/zei7rd4-t5-oxw-imkx2is7qlrc.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466495/">https://habr.com/ru/post/fr466495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466479/index.html">Utilisation de PVS-Studio lors de la v√©rification de projets Unreal Engine sur le syst√®me d'exploitation Windows</a></li>
<li><a href="../fr466485/index.html">Voitures √©lectriques des ann√©es 90. Partie 1. Fr√®res Citro√´n et Peugeot</a></li>
<li><a href="../fr466489/index.html">Des ing√©nieurs cor√©ens sugg√®rent d'utiliser Hololens comme alternative aux cloisons de bureau</a></li>
<li><a href="../fr466491/index.html">Projet d'entra√Ænement √† Godot - Pong (Partie 2) Cr√©ation et mise en place du ballon</a></li>
<li><a href="../fr466493/index.html">Docker: Pour commencer. Attention D√©ployer</a></li>
<li><a href="../fr466497/index.html">Environnement moderne pour les applications React Native</a></li>
<li><a href="../fr466499/index.html">C / C ++ de Python (ctypes)</a></li>
<li><a href="../fr466501/index.html">Actions Github et construction multiplateforme</a></li>
<li><a href="../fr466503/index.html">Slurm DevOps. Deuxi√®me jour. IaC, tests d'infrastructure et ¬´Slurm inspire!¬ª</a></li>
<li><a href="../fr466505/index.html">YIMP - Panneau de configuration pour Yii 2 sur Bootstrap 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>