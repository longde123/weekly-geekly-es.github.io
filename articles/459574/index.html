<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂üèª üôä üí™ Profundice en los espacios de nombres de Linux, parte 2 üèΩ üë®üèº‚Äçüè´ üë¶üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En la parte anterior, simplemente sumergimos nuestros dedos en las aguas del espacio de nombres y al mismo tiempo vimos lo f√°cil que era comenzar el p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Profundice en los espacios de nombres de Linux, parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459574/"><p>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte anterior,</a> simplemente sumergimos nuestros dedos en las aguas del espacio de nombres y al mismo tiempo vimos lo f√°cil que era comenzar el proceso en un espacio de nombres UTS aislado.  En esta publicaci√≥n cubriremos el espacio de nombres de usuario. </p><br><p>  Entre otros recursos relacionados con la seguridad, los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">espacios de nombres de usuario</a> a√≠slan los identificadores de usuarios y grupos en el sistema.  En esta publicaci√≥n, nos centraremos exclusivamente en los recursos de identificaci√≥n de usuarios y grupos (UID y GID, respectivamente), ya que desempe√±an un papel fundamental en la realizaci√≥n de comprobaciones de permisos y otras actividades relacionadas con la seguridad en todo el sistema. </p><br><p>  En Linux, estos ID son simplemente enteros que identifican a los usuarios y grupos en el sistema.  Y algunos de ellos se asignan a cada proceso con el fin de establecer a qu√© operaciones / recursos puede acceder este proceso.  La capacidad de un proceso de da√±ar depende de los permisos asociados con las ID asignadas. <a name="habracut"></a></p><br><h2 id="user-namespaces">  Espacios de nombres de usuario </h2><br><blockquote>  <em>Ilustraremos las capacidades de los espacios de nombres de usuario utilizando solo ID de usuario.</em>  <em>Exactamente las mismas acciones se aplican a las ID de grupo, que abordaremos m√°s adelante en esta publicaci√≥n.</em> </blockquote><p> El espacio de nombres de usuario tiene su propia copia de identificadores de usuario y grupo.  Luego, el aislamiento le permite asociar el proceso con otro conjunto de ID, dependiendo del espacio de nombres de usuario al que pertenece actualmente.  Por ejemplo, el proceso <code>$pid</code> puede ejecutarse desde la <code>root</code> (UID 0) en el espacio de nombres de usuario <strong>P</strong> y de repente contin√∫a ejecut√°ndose desde el <code>proxy</code> (UID 13) despu√©s de cambiar a otro espacio de nombres de usuario <strong>Q.</strong> </p><br><p>  ¬°Los espacios de usuario se pueden anidar!  Esto significa que una instancia de un espacio de nombres personalizado (principal) puede tener cero o m√°s espacios de nombres secundarios, y cada espacio de nombres secundario puede, a su vez, tener sus propios espacios de nombres secundarios y as√≠ sucesivamente ... (hasta alcanzar el l√≠mite de 32 niveles de anidamiento).  Cuando se crea un nuevo espacio de nombres <strong>C</strong> , Linux establece el espacio de nombres de usuario actual del proceso <strong>P que</strong> crea <strong>C</strong> como padre para <strong>C</strong> y esto no se puede cambiar m√°s adelante.  Como resultado, todos los espacios de nombres de usuario tienen exactamente un padre, formando una estructura de espacios de nombres en forma de √°rbol.  Y, como en el caso de los √°rboles, una excepci√≥n a esta regla est√° en la parte superior, donde tenemos el espacio de nombres ra√≠z (o inicial, predeterminado).  Esto, si a√∫n no est√° haciendo alg√∫n tipo de magia de contenedor, es muy probable que sea el espacio de nombres de usuario al que pertenecen todos sus procesos, ya que este es el √∫nico espacio de nombres de usuario desde que se inici√≥ el sistema. </p><br><blockquote>  <em>En esta publicaci√≥n, utilizaremos los mensajes de comando P $ y C $ para indicar el shell que se est√° ejecutando actualmente en el espacio de nombres de usuario <strong>P</strong> primario y <strong>C</strong> secundario respectivamente.</em> </blockquote><br><h2 id="mappingi-user-id">  Asignaciones de ID de usuario </h2><br><p>  El espacio de nombres de usuario, de hecho, contiene un conjunto de identificadores y cierta informaci√≥n que conecta estas ID con un conjunto de ID de otro espacio de nombres de usuario: este d√∫o define una idea completa de las ID de los procesos disponibles en el sistema.  Veamos c√≥mo podr√≠a verse: </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ id uid=1000(iffy) gid=1000(iffy)</code> </pre> <br><p>  En otra ventana de terminal, comencemos el shell usando <code>unshare</code> (el indicador <code>-U</code> crea un proceso en el nuevo espacio de nombres de usuario): </p><br><pre> <code class="bash hljs">P$ whoami iffy P$ unshare -U bash <span class="hljs-comment"><span class="hljs-comment">#    ,     user namespace C$ whoami nobody C$ id uid=65534(nobody) gid=65534(nogroup) C$ ls -l my_file -rw-r--r-- 1 nobody nogroup 0 May 18 16:00 my_file</span></span></code> </pre> <br><p>  Espera un minuto, quien?  Ahora que estamos en un shell anidado en <strong>C</strong> , ¬øel usuario actual se convierte en nadie?  Podr√≠amos haber adivinado que dado que <strong>C</strong> es un nuevo espacio de nombres de usuario, el proceso puede tener un tipo diferente de ID.  Por lo tanto, probablemente no esper√°bamos que se mantuviera <code>iffy</code> , pero <code>nobody</code> no es gracioso.  Por otro lado, es genial porque obtuvimos el aislamiento que quer√≠amos.  Nuestro proceso ahora tiene una sustituci√≥n de ID diferente (aunque rota) en el sistema, actualmente ve a todos como <code>nobody</code> y a cada grupo como <code>nogroup</code> . </p><br><p>  La informaci√≥n que vincula un UID de un espacio de nombres de usuario a otro se denomina <strong>mapeo de ID de usuario</strong> .  Es una tabla de b√∫squeda para identificar ID en el espacio de nombre de usuario actual para ID en otro espacio de nombre y cada espacio de nombre de usuario est√° asociado con exactamente una asignaci√≥n de UID (adem√°s de otra asignaci√≥n de GID para ID de grupo). </p><br><p>  Este mapeo es lo que est√° roto en nuestro shell no <code>unshare</code> .  Resulta que los nuevos espacios de nombres de usuario comienzan con un mapeo vac√≠o, y como resultado, Linux usa el horrible usuario <code>nobody</code> por defecto.  Necesitamos arreglar esto antes de que podamos hacer cualquier trabajo √∫til en nuestro nuevo espacio de nombres.  Por ejemplo, actualmente, las llamadas al sistema (como <code>setuid</code> ) que intentan trabajar con el UID fallar√°n.  Pero no tengas miedo!  Fiel a la tradici√≥n de <em>todo es archivo</em> , Linux presenta este mapeo utilizando el sistema de archivos <code>/proc</code> en <code>/proc/$pid/uid_map</code> (en <code>/proc/$pid/gid_map</code> para el GID), donde <code>$pid</code> es el ID del proceso.  Llamaremos a estos dos archivos archivos de <em>mapas.</em> </p><br><h2 id="map-fayly">  Archivos de mapas </h2><br><p>  Los archivos de mapas son archivos especiales en el sistema.  ¬øQu√© son especiales?  Bueno, al devolver diferentes contenidos cada vez que los lees, dependiendo de lo que est√© leyendo tu proceso.  Por ejemplo, el archivo de mapa <code>/proc/$pid/uid_maps</code> devuelve la asignaci√≥n de los UID del espacio de nombres de usuario que posee el proceso <code>$pid</code> a los UID en el espacio de nombres de usuario del proceso de lectura.  Y, como resultado, el contenido devuelto al proceso <strong>X</strong> puede diferir de lo que regres√≥ al proceso <strong>Y</strong> , incluso si leen el mismo archivo de mapa al mismo tiempo. </p><br><p>  En particular, el proceso <strong>X</strong> , que lee el archivo de mapa UID <code>/proc/$pid/uid_map</code> , recibe un conjunto de cadenas.  Cada l√≠nea asigna un rango continuo de UID al espacio <strong>de</strong> nombres de usuario <strong>C del</strong> proceso <code>$pid</code> , correspondiente a un rango de UID en otro espacio de nombres. </p><br><p>  Cada l√≠nea tiene el formato <code>$fromID $toID $length</code> , donde: </p><br><ul><li>  <code>$fromID</code> es el UID inicial del rango para el espacio de nombres de usuario del proceso <code>$pid</code> </li><li>  <code>$lenght</code> es la longitud del rango. </li><li>  La traducci√≥n de <code>$toID</code> depende del proceso de lectura <strong>X.</strong>  Si <strong>X</strong> pertenece a otro espacio de nombres de usuario <strong>U</strong> , entonces <code>$toID</code> es el UID inicial del rango en <strong>U</strong> que se asigna desde <code>$fromID</code> .  De lo contrario, <code>$toID</code> es el UID de inicio del rango en <strong>P</strong> , el espacio de nombres del usuario primario del proceso <strong>C.</strong> </li></ul><br><p>  Por ejemplo, si un proceso lee el archivo <code>/proc/1409/uid_map</code> y entre las l√≠neas recibidas puede ver <code>15 22 5</code> , los UID del 15 al 19 en el espacio de nombres de usuario del proceso <code>1409</code> asignan a los UID 22-26 de un espacio de nombres de usuario separado del proceso de lectura. </p><br><p>  Por otro lado, si un proceso lee del archivo <code>/proc/$$/uid_map</code> (o un archivo de mapa de cualquier proceso que pertenezca al mismo espacio de nombres de usuario que el proceso de lectura) y recibe <code>15 22 5</code> , entonces UID de 15 a 19 en el espacio de nombres de usuario <strong>C se</strong> asigna a los UID del 22 al 26 del padre para el espacio de nombres de usuario <strong>C.</strong> </p><br><p>  Prob√©moslo: </p><br><pre> <code class="bash hljs">P$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $$ 1442 <span class="hljs-comment"><span class="hljs-comment">#   user namespace... C$ echo $$ 1409 # C      ,     C$ cat /proc/1409/uid_map #  #   namespace P      # UIDs    UID    P$ cat /proc/1442/uid_map 0 0 4294967295 # UIDs  0  4294967294  P  #  4294967295 -  ID no user -  C. C$ cat /proc/1409/uid_map 0 4294967295 4294967295</span></span></code> </pre> <br><p>  Bueno, eso no fue muy emocionante, ya que estos fueron dos casos extremos, pero eso dice algunas cosas all√≠: </p><br><ol><li>  El espacio de nombres de usuario reci√©n creado tendr√° archivos de mapas vac√≠os. </li><li>  El UID 4294967295 no es mapeable y no es apto para su uso incluso en el espacio de nombres de usuario <code>root</code> .  Linux usa este UID espec√≠ficamente para indicar la <strong>ausencia de una ID de usuario</strong> . </li></ol><br><h2 id="napisanie-uid-map-faylov">  Escribir archivos de mapa UID </h2><br><p>  Para arreglar nuestro espacio de nombres de usuario <strong>C</strong> reci√©n creado, solo necesitamos proporcionar nuestras asignaciones necesarias escribiendo sus contenidos en los archivos de mapas para cualquier proceso que pertenezca a <strong>C</strong> (no podemos actualizar este archivo despu√©s de escribir en √©l).  Escribir en este archivo le dice a Linux dos cosas: </p><br><ol><li>  Qu√© UID est√°n disponibles para los procesos relacionados con el espacio de nombres de usuario de destino <strong>C.</strong> </li><li>  Qu√© UID en el espacio de nombres de usuario actual corresponden a los UID en <strong>C.</strong> </li></ol><br><p>  Por ejemplo, si escribimos lo siguiente desde el espacio de nombres de usuario primario <strong>P</strong> en el archivo de mapa para el espacio de nombres secundario <strong>C</strong> : </p><br><pre> <code class="plaintext hljs">0 1000 1 3 0 1</code> </pre> <br><p>  esencialmente le decimos a Linux que: </p><br><ol><li>  Para los procesos en <strong>C</strong> , los √∫nicos UID que existen en el sistema son los UID <code>0</code> y <code>3</code> .  Por ejemplo, la llamada al sistema <code>setuid(9)</code> siempre terminar√° con algo as√≠ como una <em>identificaci√≥n de usuario no v√°lida</em> . </li><li>  Los UID <code>1000</code> y <code>0</code> en <strong>P</strong> corresponden a los UID <code>0</code> y <code>3</code> en <strong>C.</strong>  Por ejemplo, si un proceso que se ejecuta con UID <code>1000</code> en <strong>P</strong> cambia a <strong>C</strong> , encontrar√° que despu√©s de cambiar, su UID se ha convertido en <code>root</code> <code>0</code> . </li></ol><br><h2 id="vladelec-prostranstv-imyon-i-privilegii">  Propietario de espacio de nombres y privilegios </h2><br><p>  En una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicaci√≥n anterior,</a> mencionamos que al crear nuevos espacios de nombres, se requiere acceso con nivel de superusuario.  Los espacios de nombres de usuario no imponen este requisito.  De hecho, otra caracter√≠stica es que pueden <em>poseer</em> otros espacios de nombres. </p><br><p>  Cada vez que <strong>se crea un</strong> espacio de nombres que no es usuario <strong>N</strong> , Linux asigna el espacio <strong>de</strong> nombres de usuario actual <strong>P del</strong> proceso que crea <strong>N para</strong> ser el <em>propietario del</em> espacio <em>de</em> nombres <strong>N.</strong>  Si <strong>se</strong> crea <strong>P</strong> junto con otros espacios de nombres en la misma llamada al sistema de <code>clone</code> , Linux asegura que <strong>P</strong> se crear√° primero y se convertir√° en el propietario de otros espacios de nombres. </p><br><p>  El propietario de los espacios de nombres es importante porque un proceso que solicite realizar una acci√≥n privilegiada en un recurso que no sea un espacio de nombres de usuario tendr√° sus privilegios UID contrastados con el propietario de este espacio de nombres de usuario y no con el espacio de nombres de usuario ra√≠z.  Por ejemplo, supongamos que <strong>P</strong> es el espacio de nombres de usuario primario del elemento secundario <strong>C</strong> , y <strong>P</strong> y <strong>C</strong> poseen su propio espacio de nombres de red <strong>M</strong> y <strong>N,</strong> respectivamente.  Un proceso puede no tener privilegios para crear los dispositivos de red incluidos en <strong>M</strong> , pero puede hacerlo para <strong>N.</strong> </p><br><p>  La consecuencia de tener un propietario de espacio de nombres para nosotros es que podemos eliminar el requisito de <code>sudo</code> al ejecutar comandos usando <code>unshare</code> o <code>isolate</code> si tambi√©n solicitamos la creaci√≥n de un espacio de nombres de usuario.  Por ejemplo, <code>unshare -u bash</code> requerir√° <code>sudo</code> , pero <code>unshare -Uu bash</code> ya no ser√°: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># UID 1000 --      user namespace P. P$ id uid=1000(iffy) gid=1000(iffy) #           # network namespace. P$ ip link add type veth RTNETLINK answers: Operation not permitted #     ,     #  user  network namespace P$ unshare -nU bash # :  sudo C$ ip link add type veth RTNETLINK answers: Operation not permitted # ,  . ,  # UID 0 (root)    ,  #     nobody.   . C$ echo $$ 13294 #   P,   UID 1000  P  UID 0  C P$ echo "0 1000 1" &gt; /proc/13294/uid_map #   ? C$ id uid=0(root) gid=65534(nogroup) C$ ip link add type veth # !</span></span></code> </pre> <br><blockquote>  <em>Desafortunadamente, volveremos a aplicar el requisito de superusuario en la pr√≥xima publicaci√≥n, ya que <code>isolate</code> necesita privilegios de <code>root</code> en el espacio de nombres de usuario root para configurar correctamente el espacio de nombres Mount y Network.</em>  <em>Pero seguramente eliminaremos los privilegios del proceso del equipo para asegurarnos de que el equipo no tenga permisos innecesarios.</em> </blockquote><br><h2 id="kak-razreshayutsya-id">  C√≥mo se resuelven los ID </h2><br><p>  Acabamos de ver un proceso que se ejecuta cuando un usuario normal <code>1000</code> repente cambi√≥ a <code>root</code> .  No se preocupe, no hubo escalada de privilegios.  Recuerde que esto es solo una identificaci√≥n de <em>mapeo</em> : mientras nuestro proceso <em>piensa</em> que es el <code>root</code> del sistema, Linux sabe que <code>root</code> , en su caso, significa el UID <code>1000</code> habitual (gracias a nuestro mapeo).  Entonces, en un momento en que los espacios de nombres que pertenecen a su nuevo espacio de nombres de usuario (como el espacio de nombres de red en <strong>C</strong> ) reconocen sus derechos como <code>root</code> , otros (como el espacio de nombres de red en <strong>P</strong> ) no lo hacen.  Por lo tanto, el proceso no puede hacer nada que el usuario <code>1000</code> no pueda hacer. </p><br><p>  Cada vez que un proceso en un espacio de nombres de usuario anidado realiza una operaci√≥n que requiere la verificaci√≥n de permisos, por ejemplo, crear un archivo, su UID en este espacio de nombres de usuario se compara con la ID de usuario equivalente en el espacio de nombres de usuario ra√≠z al atravesar las asignaciones en el √°rbol de espacio de nombres a la ra√≠z.  Hay un movimiento en la direcci√≥n opuesta, por ejemplo, cuando lee ID de usuario, como hacemos con <code>ls -l my_file</code> .  El UID del propietario <code>my_file</code> asigna desde el espacio de nombres de usuario ra√≠z al actual y el ID final correspondiente (o nadie si la asignaci√≥n estuvo ausente en alg√∫n lugar a lo largo de todo el √°rbol) se asigna al proceso de lectura. </p><br><h2 id="gruppovye-id">  ID de grupo </h2><br><p>  Incluso si fu√©ramos root en <strong>C</strong> , todav√≠a estamos asociados con el terrible <code>nogroup</code> como nuestra ID de grupo.  Solo necesitamos hacer lo mismo para el <code>/proc/$pid/gid_map</code> .  Antes de que podamos hacer esto, necesitamos deshabilitar la llamada al sistema <code>setgroups</code> (esto no es necesario si nuestro usuario ya tiene una capacidad <code>CAP_SETGID</code> en <strong>P</strong> , pero no asumiremos esto, ya que esto generalmente viene con privilegios de superusuario) escribiendo "denegar "al archivo <code>proc/$pid/setgroups</code> : </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  13294 -- pid  unshared  C$ id uid=0(root) gid=65534(nogroup) P$ echo deny &gt; /proc/13294/setgroups P$ echo "0 1000 1" &gt; /proc/13294/gid_map #  group ID   C$ id uid=0(root) gid=0(root)</span></span></code> </pre> <br><h2 id="realizaciya">  Implementaci√≥n </h2><br><blockquote>  <em>El c√≥digo fuente de esta publicaci√≥n se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .</em> </blockquote><p>  Como puede ver, existen muchas dificultades asociadas con la administraci√≥n de espacios de nombres de usuario, pero la implementaci√≥n es bastante simple.  Todo lo que necesitamos hacer es escribir un mont√≥n de l√≠neas en un archivo; era triste averiguar qu√© y d√≥nde escribir.  Sin m√°s pre√°mbulos, estos son nuestros objetivos: </p><br><ol><li>  Clonar un proceso de equipo en su propio espacio de nombres de usuario. </li><li>  Escriba en los archivos de mapas UID y GID del proceso del equipo. </li><li>  Restablezca todos los privilegios de superusuario antes de ejecutar el comando. </li></ol><br><p>  <code>1</code> logra simplemente agregando el indicador <code>CLONE_NEWUSER</code> a nuestra llamada al sistema de <code>clone</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> clone_flags = SIGCHLD | CLONE_NEWUTS | CLONE_NEWUSER;</code> </pre> <br><p>  Para <code>2</code> agregamos la funci√≥n <code>prepare_user_ns</code> , que representa cuidadosamente un usuario regular <code>1000</code> como <code>root</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare_userns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pid)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> line[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uid = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/uid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/setgroups"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"deny"</span></span>); write_file(path, line); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(path, <span class="hljs-string"><span class="hljs-string">"/proc/%d/gid_map"</span></span>, pid); <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(line, <span class="hljs-string"><span class="hljs-string">"0 %d 1\n"</span></span>, uid); write_file(path, line); }</code> </pre> <br><p>  Y lo llamaremos desde el proceso principal en el espacio de nombres del usuario principal justo antes de se√±alar el proceso de comando. </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//      . int pipe = params.fd[1]; //      namespace ... prepare_userns(cmd_pid); //   ,     . ...</span></span></code> </pre> <br><p>  Para el paso <code>3</code> actualizamos la funci√≥n <code>cmd_exec</code> para asegurarnos de que el comando se ejecute desde el usuario habitual sin privilegios <code>1000</code> que proporcionamos en la asignaci√≥n (recuerde que el usuario ra√≠z <code>0</code> en el espacio de nombres de usuario del proceso del equipo es el usuario <code>1000</code> ): </p><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//   ' '   . await_setup(params-&gt;fd[0]); if (setgid(0) == -1) die("Failed to setgid: %m\n"); if (setuid(0) == -1) die("Failed to setuid: %m\n"); ...</span></span></code> </pre> <br><p>  ¬°Y eso es todo!  <code>isolate</code> ahora inicia el proceso en un espacio de nombres de usuario aislado. </p><br><pre> <code class="bash hljs">$ ./isolate sh ===========sh============ $ id uid=0(root) gid=0(root)</code> </pre> <br><p>  Hubo bastantes detalles en esta publicaci√≥n sobre c√≥mo funcionan los espacios de nombres de usuario, pero al final, configurar la instancia fue relativamente sencillo.  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pr√≥xima publicaci√≥n,</a> veremos la posibilidad de ejecutar un comando en nuestro propio espacio de nombres Mount usando <code>isolate</code> (revelando el secreto detr√°s de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">declaraci√≥n</a> <code>FROM</code> del <code>Dockerfile</code> ).  All√≠ tendremos que ayudar a Linux un poco m√°s para configurar correctamente la instancia. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459574/">https://habr.com/ru/post/459574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459560/index.html">Capacidades de los centros de datos de contenedores: centro de conmutaci√≥n listo para usar en Myanmar en 50 d√≠as</a></li>
<li><a href="../459562/index.html">Programaci√≥n diferenciable</a></li>
<li><a href="../459564/index.html">Lo que los desarrolladores necesitan saber sobre negocios</a></li>
<li><a href="../459568/index.html">Letra vertical en TI moderna</a></li>
<li><a href="../459570/index.html">Beeline muestra anuncios al robot de Google. Bot infeliz</a></li>
<li><a href="../459576/index.html">Extensiones √∫tiles de Google Chrome para el programador</a></li>
<li><a href="../459578/index.html">Sistema de gesti√≥n de proyectos abiertos del sector p√∫blico</a></li>
<li><a href="../459580/index.html">Sistemas telef√≥nicos virtuales</a></li>
<li><a href="../459582/index.html">Resumen: c√≥mo comprar acciones de compa√±√≠as estadounidenses de Rusia</a></li>
<li><a href="../459584/index.html">Encontr√© un gran programador llamado Steve Wozniak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>