<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçò üë®‚Äçüåæ üë®‚Äç‚öñÔ∏è Cartes d'hexagone Unity: asp√©rit√©s, rivi√®res et routes üë©üèΩ‚Äçü§ù‚Äçüë®üèª üéà üëéüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parties 1-3: maillage, couleurs et hauteurs de cellule 

 Parties 4-7: bosses, rivi√®res et routes 

 Parties 8-11: eau, reliefs et remparts 

 Parties...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cartes d'hexagone Unity: asp√©rit√©s, rivi√®res et routes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424491/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/b6b/8a9/716b6b8a9d024dc87b2d645b5d4bdbb6.jpg" alt="image"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 1-3: maillage, couleurs et hauteurs de cellule</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 4-7: bosses, rivi√®res et routes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 8-11: eau, reliefs et remparts</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 12-15: sauvegarde et chargement, textures, distances</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 16-19: trouver le chemin, √©quipes de joueurs, animations</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 20-23: Brouillard de guerre, recherche cartographique, g√©n√©ration proc√©durale</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 24-27: cycle de l'eau, √©rosion, biomes, carte cylindrique</a> <br><br><h1>  Partie 4: Rugosit√©s </h1><br><h2>  Table des mati√®res </h2><br><ul><li>  √âchantillonnez la texture du bruit. </li><li>  D√©placez les sommets. </li><li>  Nous pr√©servons la plan√©it√© des cellules. </li><li>  Subdivisez les bords des cellules. </li></ul><br>  Alors que notre grille √©tait un mod√®le strict de nids d'abeilles.  Dans cette partie, nous ajouterons des bosses pour rendre la carte plus naturelle. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e33/034/982/e33034982aafb942e1e656b76dde0981.png"></div><br>  <i>Plus d'hexagones pairs.</i> <br><br><h2>  Le bruit </h2><br>  Pour ajouter des bosses, nous avons besoin de randomisation, mais pas de vrai hasard.  Nous voulons que tout soit coh√©rent lors du changement de carte.  Sinon, lorsque vous apportez des modifications, les objets sautent.  Autrement dit, nous avons besoin d'une certaine forme de bruit pseudo-al√©atoire reproductible. <br><br>  Un bon candidat est le bruit de Perlin.  Il est reproductible partout.  En combinant plusieurs fr√©quences, il cr√©e √©galement un bruit qui peut varier consid√©rablement sur de longues distances, mais reste presque le m√™me sur de courtes distances.  Gr√¢ce √† cela, des distorsions relativement lisses peuvent √™tre cr√©√©es.  Les points adjacents restent g√©n√©ralement proches et ne sont pas dispers√©s dans des directions oppos√©es. <br><br>  Nous pouvons g√©n√©rer du bruit Perlin par programmation.  Dans le didacticiel sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bruit</a> , j'explique comment proc√©der.  Mais nous pouvons √©galement √©chantillonner √† partir d'une texture de bruit pr√©-g√©n√©r√©e.  L'avantage d'utiliser la texture est qu'elle est plus simple et beaucoup plus rapide que le calcul du bruit multifr√©quence de Perlin.  Son inconv√©nient est que la texture prend plus de m√©moire et ne couvre qu'une petite zone de bruit.  Par cons√©quent, il doit √™tre connect√© de mani√®re transparente et suffisamment grand pour que la r√©p√©tition ne soit pas frappante. <br><br><h3>  Texture de bruit </h3><br>  Nous utiliserons la texture, donc le tutoriel sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bruit</a> est facultatif.  Nous avons donc besoin d'une texture.  Le voici: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/8e8/5d7/fbd8e85d783626c737decd6bc69a2519.png"></div><br>  <i>Connectez de mani√®re transparente la texture du bruit perlin.</i> <br><br>  La texture montr√©e ci-dessus contient le bruit multifr√©quence parfaitement coupl√© de Perlin.  Il s'agit d'une image en niveaux de gris.  Sa valeur moyenne est de 0,5 et les valeurs extr√™mes tendent √† 0 et 1. <br><br>  Mais attendez, il n'y a qu'une seule valeur pour chaque point.  Si nous avons besoin d'une distorsion 3D, nous avons besoin d'au moins trois √©chantillons pseudo-al√©atoires!  Par cons√©quent, nous avons besoin de deux textures suppl√©mentaires avec un bruit diff√©rent. <br><br>  Nous pouvons les cr√©er ou stocker diff√©rentes valeurs de bruit dans chacun des canaux de couleur.  Cela nous permettra de stocker jusqu'√† quatre mod√®les de bruit dans une seule texture.  Voici cette texture. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1d/509/aca/a1d509acaf05d64de002829afc59cb90.png"></div><br>  <i>Quatre en un.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Comment cr√©er une telle texture?</b> <div class="spoiler_text">  J'ai utilis√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NumberFlow</a> .  Il s'agit de l'√©diteur de texture proc√©durale que j'ai cr√©√© pour Unity. </div></div><br>  T√©l√©chargez cette texture et importez-la dans votre projet Unity.  Puisque nous allons √©chantillonner la texture via du code, elle doit √™tre lisible.  <em>R√©glez Type de texture</em> sur <em>Avanc√©</em> et activez la <em>lecture / √©criture activ√©e</em> .  Cela enregistrera les donn√©es de texture en m√©moire et sera accessible √† partir du code C #.  R√©glez <em>Format</em> sur <em>Automatic Truecolor</em> , sinon rien ne fonctionnera.  Nous ne voulons pas que la compression de texture d√©truise notre mod√®le de bruit. <br><br>  Vous pouvez d√©sactiver <em>Generate Mip Maps</em> , car nous n'en avons pas besoin.  <em>Activez</em> √©galement le <em>contournement de l'√©chantillonnage sRGB</em> .  Nous n'en aurons pas besoin, mais ce sera le cas.  Ce param√®tre indique que la texture ne contient pas de donn√©es de couleur dans l'espace gamma. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3aa/c36/e45/3aac36e45d7ead64823dc57b55afe67e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fe/6c8/99a/5fe6c899a966eecb34046d5c243036b7.png"></div><br>  Texture de bruit import√©e. <br><br><div class="spoiler">  <b class="spoiler_title">Quand l'√©chantillonnage sRGB est-il important?</b> <div class="spoiler_text">  Si nous voulions utiliser une texture dans un shader, cela ferait une diff√©rence.  Lorsque vous utilisez le mode de rendu lin√©aire, l'√©chantillonnage de la texture convertit automatiquement les donn√©es de couleur de la gamme en un espace colorim√©trique lin√©aire.  Dans le cas de notre texture de bruit, cela entra√Ænera des r√©sultats incorrects, nous n'en avons donc pas besoin. </div></div><br><div class="spoiler">  <b class="spoiler_title">Pourquoi mes param√®tres d'importation de texture sont-ils diff√©rents?</b> <div class="spoiler_text">  Ils ont √©t√© modifi√©s apr√®s la r√©daction de ce didacticiel.  Vous devez utiliser les param√®tres de texture 2D par d√©faut, <em>sRGB (Texture couleur)</em> doit √™tre d√©sactiv√© et la <em>compression</em> doit √™tre d√©finie sur <em>Aucune</em> . </div></div><br><h3>  √âchantillonnage du bruit </h3><br>  Ajoutons une fonctionnalit√© d'√©chantillonnage du bruit √† <code>HexMetrics</code> afin de pouvoir l'utiliser n'importe o√π.  Cela signifie que <code>HexMetrics</code> doit contenir une r√©f√©rence √† la texture du bruit. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Texture2D noiseSource;</code> </pre> <br>  Comme il ne s'agit pas d'un composant, nous ne pouvons pas lui affecter de texture via l'√©diteur.  Par cons√©quent, en tant qu'interm√©diaire, nous utilisons <code>HexGrid</code> .  Puisque <code>HexGrid</code> agira en premier, ce sera bien si nous passons la texture au d√©but de sa m√©thode <code>Awake</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D noiseSource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; ‚Ä¶ }</code> </pre> <br>  Cependant, cette approche ne survivra pas √† la recompilation en mode Play.  Les variables statiques ne sont pas s√©rialis√©es par le moteur Unity.  Pour r√©soudre ce probl√®me, r√©affectez √©galement la texture dans la m√©thode d'√©v√©nement <code>OnEnable</code> .  Cette m√©thode sera appel√©e apr√®s recompilation. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d87/4fd/3a5/d874fd3a57faad4e57e5af830b202a19.png"></div><br>  <i>Attribuez une texture de bruit.</i> <br><br>  Maintenant que <code>HexMetrics</code> a acc√®s √† la texture, ajoutons-y une m√©thode d'√©chantillonnage de bruit pratique.  Cette m√©thode prend position dans le monde et cr√©e un vecteur 4D contenant quatre √©chantillons de bruit. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Les √©chantillons ont √©t√© cr√©√©s en √©chantillonnant la texture en utilisant un filtrage bilin√©aire, dans lequel les coordonn√©es du monde X et Z ont √©t√© utilis√©es comme coordonn√©es UV. Puisque notre source de bruit est bidimensionnelle, nous ignorons la troisi√®me coordonn√©e du monde.  Si la source de bruit √©tait tridimensionnelle, nous utiliserions √©galement la coordonn√©e Y. <br><br>  En cons√©quence, nous obtenons une couleur qui peut √™tre convertie en vecteur 4D.  Une telle r√©duction peut √™tre indirecte, c'est-√†-dire que nous pouvons renvoyer la couleur directement, sans inclure explicitement <code>(Vector4)</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noiseSource.GetPixelBilinear(position.x, position.z); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comment fonctionne le filtrage bilin√©aire?</b> <div class="spoiler_text">  Pour une explication des coordonn√©es UV et du filtrage de texture, voir le didacticiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendu 2, Fondamentaux du shader</a> . </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  Mouvement du sommet </h2><br>  Nous allons d√©former notre grille lisse de nids d'abeilles, en d√©pla√ßant individuellement chacun des sommets.  Pour ce faire, ajoutons la m√©thode <code>Perturb</code> √† <code>Perturb</code> .  Il prend un point immobile et renvoie celui d√©plac√©.  Pour ce faire, il utilise un point non d√©cal√© lors de l'√©chantillonnage du bruit. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); }</code> </pre> <br>  Ajoutons simplement les √©chantillons de bruit X, Y et Z directement aux coordonn√©es des points correspondants et utilisons-les en cons√©quence. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += sample.x; position.y += sample.y; position.z += sample.z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br>  Comment changer rapidement <code>HexMesh</code> pour d√©placer tous les sommets?  <code>AddTriangle</code> modifiant chaque sommet lors de l'ajout de sommets √† la liste dans les <code>AddQuad</code> <code>AddTriangle</code> et <code>AddQuad</code> .  Faisons-le. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(Perturb(v1)); vertices.Add(Perturb(v2)); vertices.Add(Perturb(v3)); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(Perturb(v1)); vertices.Add(Perturb(v2)); vertices.Add(Perturb(v3)); vertices.Add(Perturb(v4)); ‚Ä¶ }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Les quadrangles resteront-ils plats apr√®s avoir d√©plac√© leurs sommets?</b> <div class="spoiler_text">  Probablement pas.  Ils sont constitu√©s de deux triangles qui ne se trouveront plus dans le m√™me plan.  Cependant, comme ces triangles ont deux sommets communs, les normales de ces sommets seront liss√©es.  Cela signifie que nous n'aurons pas de transitions nettes entre deux triangles.  Si la distorsion n'est pas trop importante, alors nous percevrons toujours les quadrangles comme plats. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/589/55c/47d/58955c47d221104096d943df9f9b948c.png"></div><br>  <i>Les sommets sont d√©plac√©s ou non.</i> <br><br>  Bien que les modifications ne soient pas tr√®s visibles, seules les √©tiquettes des cellules ont disparu.  Cela est arriv√© parce que nous avons ajout√© des √©chantillons de bruit aux points, et ils sont toujours positifs.  Par cons√©quent, en cons√©quence, tous les triangles se sont √©lev√©s au-dessus de leurs marques, les fermant.  Il faut centrer les changements pour qu'ils se produisent dans les deux sens.  Modifiez l'intervalle de l'√©chantillon de bruit de 0‚Äì1 √† ‚àí1‚Äì1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; position.y += sample.y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; position.z += sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f0/bd6/83a/1f0bd683ad92592fa6c5df171eab646c.png"></div><br>  <i>D√©placement centr√©.</i> <br><br><h3>  L'ampleur (force) du d√©placement </h3><br>  Il est maintenant √©vident que nous avons d√©form√© la grille, mais l'effet est √† peine perceptible.  Le changement dans chaque dimension ne d√©passe pas 1 unit√©.  Autrement dit, le d√©placement maximal th√©orique est de ‚àö3 ‚âà 1,73 unit√©s, ce qui se produira extr√™mement rarement, voire pas du tout.  Le rayon ext√©rieur des cellules √©tant de 10 unit√©s, les d√©placements sont relativement faibles. <br><br>  La solution consiste √† ajouter un param√®tre de <code>HexMetrics</code> √† <code>HexMetrics</code> afin de pouvoir mettre √† l'√©chelle les mouvements.  Essayons d'utiliser la force 5. Dans ce cas, le d√©placement maximum th√©orique sera de ‚àö75 ‚âà 8,66 unit√©s, ce qui est beaucoup plus notable. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">5f</span></span>;</code> </pre> <br>  Nous appliquons la force en la multipliant par des √©chantillons dans <code>HexMesh.Perturb</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; position.y += (sample.y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; position.z += (sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/2ef/fc0/fa82effc05a418729e81ee54f0922f26.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b19/fc8/3f0/b19fc83f0828160b2100a346083f1047.png"></div><br>  <i>Augmentation de la force.</i> <br><br><h3>  √âchelle de bruit </h3><br>  Bien que la grille semble bonne avant le changement, tout peut mal tourner apr√®s l'apparition des rebords.  Leurs pics peuvent √™tre d√©form√©s dans des directions impr√©visibles diff√©rentes, cr√©ant le chaos.  Lorsque vous utilisez du bruit Perlin, cela ne devrait pas se produire. <br><br>  Le probl√®me vient du fait que nous utilisons directement les coordonn√©es du monde pour √©chantillonner le bruit.  Pour cette raison, la texture est masqu√©e √† travers chaque unit√© et les cellules sont beaucoup plus grandes que cette valeur.  En fait, la texture est √©chantillonn√©e √† des points arbitraires, d√©truisant son int√©grit√© existante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/bd1/717/f3fbd1717515fdf4e500e9674d82a08f.png"></div><br>  <i>Des lignes de 10 x 10 cellules se chevauchent.</i> <br><br>  Nous devrons mettre √† l'√©chelle l'√©chantillonnage de bruit afin que la texture couvre une zone beaucoup plus grande.  Ajoutons cette √©chelle √† <code>HexMetrics</code> et <code>HexMetrics</code> -lui une valeur de 0,003, puis <code>HexMetrics</code> √† l'√©chelle les coordonn√©es des √©chantillons selon ce facteur. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> noiseScale = <span class="hljs-number"><span class="hljs-number">0.003f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); }</code> </pre> <br>  Il s'av√®re soudain que notre texture couvre 333 &amp; frac13;  unit√©s carr√©es, et son int√©grit√© locale devient apparente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/219/e7a/9de219e7ae0495bcc9dfc2eca4ce52d6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53c/0fc/e14/53c0fce142f96daecfd5001ac45e2222.png"></div><br>  <i>Bruit √† l'√©chelle.</i> <br><br>  De plus, une nouvelle √©chelle augmente la distance entre les joints de bruit.  En fait, comme les cellules ont un diam√®tre interne de 10‚àö3 unit√©s, elles ne seront jamais exactement carrel√©es dans la dimension X. Cependant, en raison de l'int√©grit√© locale du bruit, √† plus grande √©chelle, nous serons toujours en mesure de reconna√Ætre des motifs r√©p√©titifs, environ toutes les 20 cellules, m√™me si les d√©tails ne correspondent pas.  Mais ils ne seront √©vidents que sur la carte sans autres caract√©ristiques. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  Aligner les centres cellulaires </h2><br>  D√©placer tous les sommets donne √† la carte un aspect plus naturel, mais il y a plusieurs probl√®mes.  Comme les cellules sont maintenant irr√©guli√®res, leurs √©tiquettes se croisent avec le maillage.  Et dans les joints des corniches avec des falaises, des fissures apparaissent.  Nous laisserons les fissures pour plus tard, mais nous allons maintenant nous concentrer sur les surfaces des cellules. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/320/626/85f/32062685fe221819ba4d9375175f66ee.png"></div><br>  <i>La carte est devenue moins stricte, mais plus de probl√®mes sont apparus.</i> <br><br>  Le moyen le plus simple de r√©soudre le probl√®me d'intersection est de rendre les centres des cellules plats.  Ne changeons tout simplement pas la coordonn√©e Y dans <code>HexMesh.Perturb</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; <span class="hljs-comment"><span class="hljs-comment">// position.y += (sample.y * 2f - 1f) * HexMetrics.cellPerturbStrength; position.z += (sample.z * 2f - 1f) * HexMetrics.cellPerturbStrength; return position; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/6f6/38e/bfb6f638e8cdb45d6178d1f18cdb723b.png"></div><br>  <i>Cellules align√©es.</i> <br><br>  Avec ce changement, toutes les positions verticales resteront inchang√©es, √† la fois au centre des cellules et aux marches des rebords.  Il convient de noter que cela r√©duit le d√©placement maximal √† ‚àö50 ‚âà 7,07 uniquement dans le plan XZ. <br><br>  C'est un bon changement, car il simplifie l'identification des cellules individuelles et ne permet pas aux rebords de devenir trop chaotiques.  Mais ce serait quand m√™me bien d'ajouter un petit mouvement vertical. <br><br><h3>  D√©placer la hauteur des cellules </h3><br>  Au lieu d'appliquer un mouvement vertical √† chaque sommet, nous pouvons l'appliquer √† une cellule.  Dans ce cas, chaque cellule restera plate, mais la variabilit√© restera toujours entre les cellules.  Il serait √©galement logique d'utiliser une √©chelle diff√©rente pour d√©placer la hauteur, alors ajoutez-la √† <code>HexMetrics</code> .  Une force de 1,5 unit√© cr√©e une l√©g√®re variation, approximativement √©gale √† la hauteur d'une marche du rebord. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationPerturbStrength = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br>  Modifiez la propri√©t√© <code>HexCell.Elevation</code> afin qu'elle <code>HexCell.Elevation</code> ce d√©placement √† la position verticale de la cellule. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; } }</code> </pre> <br>  Pour que le d√©placement soit appliqu√© imm√©diatement, nous devons d√©finir explicitement la hauteur de chaque cellule dans <code>HexGrid.CreateCell</code> .  Sinon, la grille sera initialement plate.  Faisons-le √† la fin, apr√®s avoir cr√©√© l'interface utilisateur. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.Elevation = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4f/dd7/15c/d4fdd715c130c8cd8b2519ff37c837de.png"></div><br>  <i>Hauteurs d√©plac√©es avec fissures.</i> <br><br><h3>  En utilisant les m√™mes hauteurs </h3><br>  De nombreuses fissures sont apparues dans le maillage, car lorsque nous triangulons le maillage, nous n'utilisons pas les m√™mes hauteurs de cellule.  Ajoutons une propri√©t√© √† <code>HexCell</code> pour obtenir sa position afin de pouvoir l'utiliser n'importe o√π. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transform.localPosition; } }</code> </pre> <br>  Nous pouvons maintenant utiliser cette propri√©t√© dans <code>HexMesh.Triangulate</code> pour d√©terminer le centre de la cellule. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; ‚Ä¶ }</code> </pre> <br>  Et nous pouvons l'utiliser dans <code>TriangulateConnection</code> lors de la d√©finition des positions verticales des cellules voisines. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Position.y; ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Position.y; ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69b/9a2/d90/69b9a2d90b7f29ef57f658f8206f6dda.png"></div><br>  <i>Utilisation coh√©rente de la hauteur des cellules.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  Unit√© de bord de cellule </h2><br>  Bien que les cellules aient une belle variation, elles ressemblent toujours √† des hexagones √©vidents.  Ce n'est pas en soi un probl√®me, mais nous pouvons am√©liorer leur apparence. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/895/e86/6d5895e8650286653b532d9c6fa1c10d.png"></div><br>  <i>Cellules hexagonales clairement visibles.</i> <br><br>  Si nous avions plus de sommets, alors il y aurait une plus grande variabilit√© locale.  Divisons donc chaque bord de la cellule en deux parties en ajoutant le haut du bord au milieu entre chaque paire de coins.  Cela signifie que <code>HexMesh.Triangulate</code> doit ajouter non pas un, mais deux triangles. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); Vector3 e1 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); AddTriangle(center, v1, e1); AddTriangleColor(cell.color); AddTriangle(center, e1, v2); AddTriangleColor(cell.color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, v2); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b09/03c/d20/b0903cd20983599abdc064f04c95aa4f.png"></div><br>  <i>Douze c√¥t√©s au lieu de six.</i> <br><br>  Le doublement des sommets et des triangles ajoute plus de variabilit√© aux bords de la cellule.  Rendons-les encore plus in√©gaux en triplant le nombre de sommets. <br><br><pre> <code class="cs hljs"> Vector3 e1 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); Vector3 e2 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); AddTriangle(center, v1, e1); AddTriangleColor(cell.color); AddTriangle(center, e1, e2); AddTriangleColor(cell.color); AddTriangle(center, e2, v2); AddTriangleColor(cell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/852/e6c/ad2852e6ccbf3db0adca140818545bb3.png"></div><br>  <i>18 c√¥t√©s.</i> <br><br><h3>  Division conjointe des c√¥tes </h3><br>  Bien s√ªr, nous devons √©galement subdiviser les joints de bord.  Par cons√©quent, nous passerons les nouveaux bords de sommet √† <code>TriangulateConnection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, e1, e2, v2); }</code> </pre> <br>  Ajoutez les param√®tres appropri√©s √† <code>TriangulateConnection</code> afin qu'il puisse fonctionner avec des sommets suppl√©mentaires. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 e1, Vector3 e2, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br>  Nous devons √©galement calculer les ar√™tes suppl√©mentaires des ar√™tes pour les cellules voisines.  Nous pouvons les calculer apr√®s avoir connect√© le pont de l'autre c√¥t√©. <br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Position.y; Vector3 e3 = Vector3.Lerp(v3, v4, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); Vector3 e4 = Vector3.Lerp(v3, v4, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>);</code> </pre> <br>  Ensuite, nous devons changer la triangulation de la nervure.  Jusqu'√† ce que nous ignorions les pentes avec les rebords, ajoutez simplement trois au lieu d'un quad. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddQuad(v1, e1, v3, e3); AddQuadColor(cell.color, neighbor.color); AddQuad(e1, e2, e3, e4); AddQuadColor(cell.color, neighbor.color); AddQuad(e2, v2, e4, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afa/9d6/708/afa9d67080045b6ea2951a715c569003.png"></div><br>  <i>Connexions subdivis√©es.</i> <br><br><h3>  L'union des bords des bords </h3><br>  √âtant donn√© que pour d√©crire les ar√™tes, nous avons maintenant besoin de quatre sommets, il serait logique de les combiner en un ensemble.  C'est plus pratique que de travailler avec quatre sommets ind√©pendants.  Cr√©ez une structure <code>EdgeVertices</code> simple pour cela.  Il doit contenir quatre sommets allant dans le sens horaire le long du bord de la cellule. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EdgeVertices { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v3, v4; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Ne devraient-ils pas √™tre s√©rialisables?</b> <div class="spoiler_text">  Nous utiliserons cette structure uniquement pour la triangulation.  √Ä ce stade, nous n'avons pas besoin de stocker les sommets des bords, ils ne sont donc pas n√©cessaires pour √™tre s√©rialisables. </div></div><br>  Ajoutez-y une m√©thode constructeur pratique, qui traitera du calcul des points interm√©diaires de l'ar√™te. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); v4 = corner2; }</code> </pre> <br>  Nous pouvons maintenant ajouter une m√©thode de triangulation distincte √† <code>HexMesh</code> pour cr√©er un √©ventail de triangles entre le centre de la cellule et l'un de ses bords. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { AddTriangle(center, edge.v1, edge.v2); AddTriangleColor(color); AddTriangle(center, edge.v2, edge.v3); AddTriangleColor(color); AddTriangle(center, edge.v3, edge.v4); AddTriangleColor(color); }</code> </pre> <br>  Et une m√©thode pour trianguler une bande de quadrangles entre deux ar√™tes. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2 </span></span></span><span class="hljs-function">)</span></span> { AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); AddQuadColor(c1, c2); AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); AddQuadColor(c1, c2); AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); AddQuadColor(c1, c2); }</code> </pre> <br>  Cela nous permettra de simplifier la m√©thode des <code>Triangulate</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); TriangulateEdgeFan(center, e, cell.color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } }</code> </pre> <br>  Passons √† <code>TriangulateConnection</code> .  Nous pouvons maintenant utiliser <code>TriangulateEdgeStrip</code> , mais d'autres remplacements doivent √™tre effectu√©s.  L√† o√π nous <code>e1.v1</code> <code>v1</code> , nous devons utiliser <code>e1.v1</code> .  De m√™me, <code>v2</code> devient <code>e1.v4</code> , <code>v3</code> devient <code>e2.v1</code> et <code>v4</code> devient <code>e2.v4</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); bridge.y = neighbor.Position.y - cell.Position.y; EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v4 + bridge ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1.v1, e1.v4, cell, e2.v1, e2.v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, cell.color, e2, neighbor.color); } HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = e1.v4 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Position.y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner( e1.v4, cell, e2.v4, neighbor, v5, nextNeighbor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner( v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner( e2.v4, neighbor, v5, nextNeighbor, e1.v4, cell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner( v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor ); } }</code> </pre> <br><h3>  Division du rebord </h3><br>  Nous devons diviser les corniches.  Par cons√©quent, nous transmettons les bords √† <code>TriangulateEdgeTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor); }</code> </pre> <br>  Nous devons maintenant modifier <code>TriangulateEdgeTerraces</code> afin qu'il interpole entre les ar√™tes et non entre les paires de sommets.  Supposons <code>EdgeVertices</code> dispose d'une m√©thode statique pratique pour ce faire.  Cela nous permettra de simplifier <code>TriangulateEdgeTerraces</code> plut√¥t que de le compliquer. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, beginCell.color, e2, c2); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i); TriangulateEdgeStrip(e1, c1, e2, c2); } TriangulateEdgeStrip(e2, c2, end, endCell.color); }</code> </pre> <br>  La m√©thode <code>EdgeVertices.TerraceLerp</code> interpole simplement les rebords entre les quatre paires de sommets de deux ar√™tes. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EdgeVertices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices a, EdgeVertices b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { EdgeVertices result; result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step); result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step); result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step); result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7d/ead/906/a7dead9066cbd1f7ddd29ca751d81cb0.png"></div><br>  <i>Corniches subdivis√©es.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unit√©</a> <br><br><h2>  Reconnectez les falaises et les corniches </h2><br>  Jusqu'√† pr√©sent, nous avons ignor√© les fissures √† la jonction des falaises et des corniches.  Il est temps de r√©soudre ce probl√®me.  Examinons d'abord les cas falaise-pente-pente (OSS) et pente-falaise-pente (SOS). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/402/951/0fa/4029510fa08226cc4e4aee18faf1959b.png"></div><br>  <i>Trous de maille.</i> <br><br>  Le probl√®me vient du fait que les sommets des fronti√®res se sont d√©plac√©s.  Cela signifie que maintenant ils ne se trouvent pas exactement sur le c√¥t√© de la falaise, ce qui conduit √† une fissure.  Parfois, ces trous sont invisibles et parfois frappants. <br><br>  La solution est de ne pas d√©placer le haut de la fronti√®re.  Cela signifie que nous devons contr√¥ler si le point sera d√©plac√©.  Le moyen le plus simple serait de cr√©er une alternative <code>AddTriangle</code> qui ne d√©place pas du tout les sommets. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUnperturbed</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Modifiez le <code>TriangulateBoundaryTriangle</code> afin qu'il utilise cette m√©thode.  Cela signifie qu'il devra d√©placer explicitement tous les sommets, √† l'exception des sommets. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangleUnperturbed(Perturb(begin), Perturb(v2), boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangleUnperturbed(Perturb(v1), Perturb(v2), boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangleUnperturbed(Perturb(v2), Perturb(left), boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br>  Il convient de noter ce qui suit: puisque nous n'utilisons pas la <code>v2</code> pour obtenir un autre point, nous pouvons le d√©placer imm√©diatement.  Il s'agit d'une optimisation simple qui r√©duit la quantit√© de code, nous allons donc l'introduire. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangleUnperturbed(Perturb(begin), v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangleUnperturbed(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangleUnperturbed(v2, Perturb(left), boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/221/0ed/3fd2210ed0a8148ba9d39ef1655848e8.png"></div><br>  <i>Fronti√®res immobiles.</i> <br><br>  √áa a l'air mieux, mais nous n'avons pas encore fini.  √Ä l'int√©rieur de la m√©thode <code>TriangulateCornerTerracesCliff</code> , le point limite est interpol√© entre les points gauche et droit.  Cependant, ces points n'ont pas encore √©t√© d√©plac√©s.  Pour que le point limite corresponde √† la falaise r√©sultante, nous devons interpoler entre les points d√©plac√©s. <br><br><pre> <code class="cs hljs"> Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(right), b);</code> </pre> <br>  Il en va de m√™me pour la m√©thode <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(left), b);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/917/670/c189176704e7ebcdfd92bc6a1cffaee3.png"></div><br>  <i>Les trous ont disparu.</i> <br><br><h3>  Double falaise et pente </h3><br>  Dans tous les cas probl√©matiques restants, deux falaises et une pente sont pr√©sentes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/408/f2f/4a6/408f2f4a6fca5fffd8659b4380f59e51.png"></div><br>  <i>Gros trou √† cause d'un seul triangle.</i> <br><br>  Ce probl√®me est r√©solu en d√©pla√ßant manuellement un seul triangle dans le bloc <code>else</code> √† la fin de <code>TriangulateCornerTerracesCliff</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); }</code> </pre> <br>  Il en va de m√™me pour <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/b34/64a/9ffb3464a6de3dc443cede9d42797022.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©barrassez-vous des derni√®res fissures. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ach√®vement </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons maintenant un maillage d√©form√© compl√®tement correct. </font><font style="vertical-align: inherit;">Son apparence d√©pend du bruit sp√©cifique, de son √©chelle et des forces de distorsion. </font><font style="vertical-align: inherit;">Dans notre cas, la distorsion peut sembler trop forte. </font><font style="vertical-align: inherit;">Bien que cette irr√©gularit√© soit belle, nous ne voulons pas que les cellules s'√©cartent trop de la grille uniforme. </font><font style="vertical-align: inherit;">Au final, nous l'utilisons toujours pour d√©finir la cellule √† redimensionner. </font><font style="vertical-align: inherit;">Et si la taille des cellules varie trop, il nous sera plus difficile d'y placer le contenu.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35f/32e/d06/35f32ed066f03b1079ed0bec70ba83ca.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eac/3f5/d6c/eac3f5d6cd6a1e65185d1aec48e8abb0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mailles non d√©form√©es et d√©form√©es. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble que la force 5 de d√©formation des cellules soit trop importante.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distorsion des cellules est de 0 √† 5.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©duisons-la √† 4 pour augmenter la commodit√© de la grille, sans la rendre trop correcte. </font><font style="vertical-align: inherit;">Cela garantit que le d√©calage XZ maximum sera de ‚àö32 ‚âà 5,66 unit√©s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/803/2f6/b8d/8032f6b8d0cf048f5d55c30e2d0e465d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Force de distorsion cellulaire 4.</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une autre valeur qui peut √™tre modifi√©e est le coefficient d'int√©grit√©. </font><font style="vertical-align: inherit;">Si nous l'augmentons, les centres plats des cellules deviendront plus grands, c'est-√†-dire qu'il y aura plus d'espace pour le contenu futur. </font><font style="vertical-align: inherit;">Bien s√ªr, ce faisant, ils deviendront plus hexagonaux.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coefficient d'int√©grit√© de 0,75 √† 0,95. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une l√©g√®re augmentation du coefficient d'int√©grit√© √† 0,8 simplifiera l√©g√®rement notre vie √† l'avenir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> solidFactor = <span class="hljs-number"><span class="hljs-number">0.8f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/9a2/036/a9a9a2036fbcd0e4e5f11e56078911c1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coefficient d'int√©grit√© 0,8. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, vous remarquerez peut-√™tre que les diff√©rences entre les niveaux d'√©l√©vation sont trop marqu√©es. </font><font style="vertical-align: inherit;">C'est pratique lorsque vous devez vous assurer que le maillage est g√©n√©r√© correctement, mais nous avons d√©j√† termin√© avec cela. </font><font style="vertical-align: inherit;">R√©duisons-le √† 1 unit√© par √©tape, c'est-√†-dire √† 3.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationStep = <span class="hljs-number"><span class="hljs-number">3f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5cc/4b0/028/5cc4b002843f822556c7ced67b9f54db.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La hauteur est r√©duite √† 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons √©galement modifier la force de la distorsion de hauteur. </font><font style="vertical-align: inherit;">Mais maintenant, il a une valeur de 1,5, ce qui √©quivaut √† un demi-pas de hauteur, ce qui nous convient. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De petites marches de hauteurs permettent une utilisation plus logique des sept niveaux de hauteur. </font><font style="vertical-align: inherit;">Cela augmente la variabilit√© de la carte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f63/9b3/aac/f639b3aac128c4c72c28fa85d68cc0e4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons sept niveaux de hauteurs. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 5: cartes plus grandes </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous divisons la grille en fragments. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous contr√¥lons la cam√©ra. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colorisez les couleurs et les hauteurs s√©par√©ment. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisez la brosse agrandie des cellules. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, nous avons travaill√© avec une toute petite carte. </font><font style="vertical-align: inherit;">Il est temps de l'augmenter.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/11c/4b4/0c811c4b480c13b584a2b824fdae1cee.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est temps de zoomer.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragments de maille </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne pouvons pas rendre la grille trop grande, car nous nous heurtons aux limites de ce qui peut tenir dans un maillage. </font><font style="vertical-align: inherit;">Comment r√©soudre ce probl√®me? </font><font style="vertical-align: inherit;">Utilisez plusieurs maillages. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons diviser notre grille en plusieurs fragments. </font><font style="vertical-align: inherit;">Nous utilisons des fragments rectangulaires de taille constante.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/423/453/db2/423453db217ed74da2457198c576ef63.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diviser la grille en segments de 3 par 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisons 5 blocs par 5, soit 25 cellules par fragment. </font><font style="vertical-align: inherit;">D√©finissez-les </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeX = <span class="hljs-number"><span class="hljs-number">5</span></span>, chunkSizeZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle taille de fragment peut √™tre consid√©r√©e comme appropri√©e?</font></font></b> <div class="spoiler_text">  .       ,     .      .      ,       (frustum culling),       .            . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous ne pouvons pas utiliser de taille pour le maillage, il doit √™tre un multiple de la taille du fragment. </font><font style="vertical-align: inherit;">Par cons√©quent, modifions-le </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'il d√©finisse sa taille non pas dans des cellules distinctes, mais en fragments. </font><font style="vertical-align: inherit;">D√©finissez la taille par d√©faut sur 4 par 3 fragments, c'est-√†-dire seulement 12 fragments ou 300 cellules. </font><font style="vertical-align: inherit;">Nous obtenons donc une carte de test pratique.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkCountX = <span class="hljs-number"><span class="hljs-number">4</span></span>, chunkCountZ = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons toujours </font></font><code>width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>height</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais maintenant ils devraient devenir priv√©s. </font><font style="vertical-align: inherit;">Et renommez-les en </font></font><code>cellCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>cellCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Utilisez l'√©diteur pour renommer toutes les occurrences de ces variables √† la fois. </font><font style="vertical-align: inherit;">Maintenant, il sera clair quand nous aurons affaire au nombre de fragments ou de cellules.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int width = 6; // public int height = 6; int cellCountX, cellCountZ;</span></span></code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/ff4/160/227ff41602f115787a8a0e5d98ca89c9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sp√©cifiez la taille en fragments. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour que, si n√©cessaire, le nombre de cellules soit calcul√© √† partir du nombre de fragments. </font><font style="vertical-align: inherit;">Nous mettons en √©vidence la cr√©ation de cellules dans une m√©thode distincte, afin de ne pas obstruer </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateCells(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[cellCountZ * cellCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; cellCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; cellCountX; x++) { CreateCell(x, z, i++); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragment pr√©fabriqu√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour d√©crire les fragments de maillage, nous avons besoin d'un nouveau type de composant. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGridChunk</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous allons cr√©er un fragment pr√©fabriqu√©. </font><font style="vertical-align: inherit;">Nous le ferons en dupliquant l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et en le renommant </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Supprimez son composant </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ajoutez un composant √† la place </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Transformez-le ensuite en un pr√©fabriqu√© et retirez l'objet de la sc√®ne.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/a02/bea/106a02bead67c37151be26d5f6a4bea9.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cb/586/7a3/1cb5867a3851159ce2bf1747a4e213bc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un fragment pr√©fabriqu√© avec sa propre toile et maillage. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisqu'il cr√©era des instances de ces fragments </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous lui donnerons un lien vers le pr√©fabriqu√© du fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGridChunk chunkPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a9/6b8/882/2a96b8882c5d6cc5bdb6345d5217ae83.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant avec des fragments. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cr√©ation d'instances de fragments ressemble beaucoup √† la cr√©ation d'instances de cellules. </font><font style="vertical-align: inherit;">Nous allons les suivre √† l'aide d'un tableau et utiliser une double boucle pour le remplir.</font></font><br><br><pre> <code class="cs hljs"> HexGridChunk[] chunks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ CreateChunks(); CreateCells(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(transform); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'initialisation d'un fragment est similaire √† la fa√ßon dont nous avons initialis√© une grille d'hexagones. </font><font style="vertical-align: inherit;">Elle met tout en place </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et effectue la triangulation </font></font><code>Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il n√©cessite une r√©f√©rence √† son canevas et maillage, ainsi qu'un tableau pour les cellules. </font><font style="vertical-align: inherit;">Cependant, le fragment ne cr√©era pas ces cellules. </font><font style="vertical-align: inherit;">La grille continuera de le faire.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGridChunk</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { HexCell[] cells; HexMesh hexMesh; Canvas gridCanvas; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affectation de cellules √† des fragments </font></font></h3><br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cr√©e toujours toutes les cellules. </font><font style="vertical-align: inherit;">C'est normal, mais maintenant nous devons ajouter chaque cellule √† un fragment appropri√©, et non les d√©finir en utilisant notre propre maillage et toile.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); <span class="hljs-comment"><span class="hljs-comment">// cell.transform.SetParent(transform, false); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.color = defaultColor; ‚Ä¶ Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); // label.rectTransform.SetParent(gridCanvas.transform, false); label.rectTransform.anchoredPosition = new Vector2(position.x, position.z); label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; cell.Elevation = 0; AddCellToChunk(x, z, cell); } void AddCellToChunk (int x, int z, HexCell cell) { }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons trouver le fragment correct en utilisant la division enti√®re </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par taille de fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCellToChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkX = x / HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkZ = z / HexMetrics.chunkSizeZ; HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En utilisant des r√©sultats interm√©diaires, nous pouvons √©galement d√©terminer l'indice local de la cellule dans ce fragment. </font><font style="vertical-align: inherit;">Apr√®s cela, vous pouvez ajouter une cellule au fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCellToChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkX = x / HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkZ = z / HexMetrics.chunkSizeZ; HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localX = x - chunkX * HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localZ = z - chunkZ * HexMetrics.chunkSizeZ; chunk.AddCell(localX + localZ * HexMetrics.chunkSizeX, cell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, il </font></font><code>HexGridChunk.AddCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">place la cellule dans son propre tableau, puis il d√©finit les √©l√©ments parents de la cellule et de son interface utilisateur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cells[index] = cell; cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.uiRect.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Balayer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä ce stade, il </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut se d√©barrasser de la toile et du maillage hexagonal de ses enfants, ainsi que du code.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Canvas gridCanvas; // HexMesh hexMesh; void Awake () { HexMetrics.noiseSource = noiseSource; // gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); // hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); ‚Ä¶ } // void Start () { // hexMesh.Triangulate(cells); // } // public void Refresh () { // hexMesh.Triangulate(cells); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis que nous nous sommes d√©barrass√©s </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous ne devons </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus l'utiliser.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.Elevation = activeElevation; <span class="hljs-comment"><span class="hljs-comment">// hexGrid.Refresh(); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a0/f4b/c99/5a0f4bc99bce766e53ff1a0192abd16e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La grille nettoy√©e d'hexagones. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir d√©marr√© le mode Lecture, la carte est toujours la m√™me. </font><font style="vertical-align: inherit;">Mais la hi√©rarchie des objets sera diff√©rente. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cr√©e maintenant des objets enfants fragment√©s qui contiennent des cellules, ainsi que leur maillage et leur canevas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/bc4/f8e/a7fbc4f8e4898504bc34a4a918ebb567.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragments enfant en mode Lecture. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons peut-√™tre des probl√®mes avec les √©tiquettes des cellules. </font><font style="vertical-align: inherit;">Initialement, nous avons d√©fini la largeur de l'√©tiquette sur 5. Cela suffisait pour afficher les deux caract√®res qui nous suffisaient sur une petite carte. </font><font style="vertical-align: inherit;">Mais maintenant, nous pouvons avoir des coordonn√©es comme ‚àí10, dans lesquelles il y a trois caract√®res. </font><font style="vertical-align: inherit;">Ils ne rentreront pas et seront coup√©s. </font><font style="vertical-align: inherit;">Pour r√©soudre ce probl√®me, augmentez la largeur de l'√©tiquette de cellule √† 10, voire plus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e7/fd3/4a5/2e7fd34a5b649256e326b73a3aa9227a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/926/fae/f7c926fae8356aa8d2402a21359fea8f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtiquettes de cellules √©tendues. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant cr√©er des cartes beaucoup plus grandes! </font><font style="vertical-align: inherit;">Comme nous g√©n√©rons l'int√©gralit√© de la grille au d√©marrage, la cr√©ation de grandes cartes peut prendre beaucoup de temps. </font><font style="vertical-align: inherit;">Mais apr√®s l'ach√®vement, nous aurons un immense espace d'exp√©rimentation.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Correction de l'√©dition des cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'√©dition ne semble pas fonctionner au stade actuel, car nous ne mettons plus √† jour la grille. </font><font style="vertical-align: inherit;">Nous devons mettre √† jour des fragments individuels, alors ajoutez une m√©thode </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quand devrions-nous appeler cette m√©thode? </font><font style="vertical-align: inherit;">Nous avons mis √† jour la grille enti√®re √† chaque fois car nous n'avions qu'un seul maillage. </font><font style="vertical-align: inherit;">Mais maintenant, nous avons de nombreux fragments. </font><font style="vertical-align: inherit;">Au lieu de les mettre √† jour √† chaque fois, il sera beaucoup plus efficace de mettre √† jour les fragments modifi√©s. </font><font style="vertical-align: inherit;">Sinon, changer de grandes cartes deviendra une op√©ration tr√®s lente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais comment savoir quel fragment mettre √† jour? </font><font style="vertical-align: inherit;">Le moyen le plus simple est de faire savoir √† chaque cellule √† quel fragment elle appartient. </font><font style="vertical-align: inherit;">La cellule pourra alors mettre √† jour son fragment lors du changement de cette cellule. </font><font style="vertical-align: inherit;">Donnons donc un </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien vers son fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGridChunk chunk;</code> </pre> <br> <code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut s'ajouter √† la cellule lors de l'ajout. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cells[index] = cell; cell.chunk = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.uiRect.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En les connectant, nous ajoutons √† la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Chaque fois qu'une cellule est mise √† jour, elle met simplement √† jour son fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'avons pas besoin de le rendre </font></font><code>HexCell.Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commun, car la cellule elle-m√™me sait mieux quand elle a √©t√© chang√©e. </font><font style="vertical-align: inherit;">Par exemple, une fois sa hauteur modifi√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ Refresh(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, nous devons le mettre √† jour uniquement lorsque sa hauteur a chang√© pour une valeur diff√©rente. </font><font style="vertical-align: inherit;">Elle n'a m√™me pas besoin de recalculer quoi que ce soit si nous lui attribuons la m√™me hauteur qu'auparavant. </font><font style="vertical-align: inherit;">Par cons√©quent, nous pouvons quitter le d√©but du setter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, nous ignorerons √©galement les calculs pour la premi√®re fois lorsque la hauteur est d√©finie sur 0, car il s'agit de la valeur de hauteur de maillage par d√©faut. </font><font style="vertical-align: inherit;">Pour √©viter cela, nous allons cr√©er la valeur initiale telle que nous ne l'utilisons jamais.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que int.MinValue?</font></font></b> <div class="spoiler_text">   ,    integer.    C# integer ‚Äî <br>  32- ,   2 <sup>32</sup>  integer,    ,    .       . <br><br>  ‚Äî  ‚àí2 <sup>31</sup> = ‚àí2 147 483 648.        ! <br><br>   2 <sup>31</sup> ‚àí 1 = 2 147 483 647.     2 <sup>31</sup> - . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour reconna√Ætre le changement de couleur de la cellule, nous devons √©galement la transformer en propri√©t√©. </font><font style="vertical-align: inherit;">Renommez-le en </font></font><code>Color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">majuscules, puis transformez-le en une propri√©t√© avec une variable priv√©e </font></font><code>color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La valeur de couleur par d√©faut sera le noir transparent, ce qui nous convient.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } color = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } Color color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lorsque nous d√©marrons le mode Lecture, nous obtenons des exceptions de r√©f√©rence nulle. </font><font style="vertical-align: inherit;">Cela se produit car nous d√©finissons la couleur et la hauteur √† leurs valeurs par d√©faut avant d'affecter une cellule √† son fragment. </font><font style="vertical-align: inherit;">Il est normal que nous ne mettions pas √† jour les fragments √† ce stade, car nous les triangulons une fois l‚Äôinitialisation termin√©e. </font><font style="vertical-align: inherit;">En d'autres termes, nous mettons √† jour un fragment uniquement s'il est affect√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons enfin changer √† nouveau les cellules! </font><font style="vertical-align: inherit;">Cependant, un probl√®me se pose. </font><font style="vertical-align: inherit;">Lorsque vous dessinez le long des bordures de fragments, des coutures apparaissent.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/94f/50c/41a94f50c430ce8f13fb1a3be274b520.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erreurs aux limites des fragments.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C'est logique, car lorsqu'une seule cellule change, toutes les connexions avec ses voisins changent √©galement. Et ces voisins peuvent √™tre dans d'autres fragments. La solution la plus simple consiste √† mettre √† jour toutes les cellules voisines si elles sont diff√©rentes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { HexCell neighbor = neighbors[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.chunk != chunk) { neighbor.chunk.Refresh(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que cela fonctionne, il se peut que nous mettions √† jour un fragment plusieurs fois. Et lorsque nous commen√ßons √† colorer plusieurs cellules √† la fois, tout va empirer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais nous ne sommes pas tenus de trianguler imm√©diatement apr√®s la mise √† jour du fragment. Au lieu de cela, nous √©crivons simplement qu'une mise √† jour est n√©cessaire et triangulons une fois le changement termin√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisqu'il ne </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fait rien d'autre, nous pouvons utiliser son √©tat activ√© pour signaler la n√©cessit√© de mises √† jour. Lors de sa mise √† jour, nous incluons le composant. L'activer plusieurs fois ne changera rien. Le composant est mis √† jour ult√©rieurement. Nous allons trianguler √† ce stade et d√©sactiver √† nouveau le composant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons √† la </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">place</font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour garantir que la triangulation se produit une fois la modification termin√©e pour la trame actuelle. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// hexMesh.Triangulate(cells); enabled = true; } void LateUpdate () { hexMesh.Triangulate(cells); enabled = false; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle est la diff√©rence entre Update et LateUpdate?</font></font></b> <div class="spoiler_text">     <code>Update</code>    -     .          <code>LateUpdate</code> .      ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme notre composant est activ√© par d√©faut, nous n'avons plus besoin de trianguler explicitement </font></font><code>Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par cons√©quent, cette m√©thode peut √™tre supprim√©e.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void Start () { // hexMesh.Triangulate(cells); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6f/104/7c3/a6f1047c34bb9cf9b69360343ab53aac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragments de 20 par 20 contenant 10 000 cellules.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listes g√©n√©ralis√©es </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous ayons consid√©rablement modifi√© la fa√ßon dont la grille est triangul√©e, </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elle reste la m√™me. </font><font style="vertical-align: inherit;">Tout ce dont il a besoin pour travailler est un tableau de cellules. </font><font style="vertical-align: inherit;">Il ne se soucie pas s'il y a un maillage d'hexagones, ou plusieurs d'entre eux. </font><font style="vertical-align: inherit;">Mais nous n'avons pas encore envisag√© d'utiliser plusieurs maillages. </font><font style="vertical-align: inherit;">Peut-√™tre que quelque chose peut √™tre am√©lior√© ici? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">listes </font><font style="vertical-align: inherit;">utilis√©es </font><font style="vertical-align: inherit;">sont essentiellement des tampons temporaires. </font><font style="vertical-align: inherit;">Ils sont utilis√©s uniquement pour la triangulation. </font><font style="vertical-align: inherit;">Et les fragments sont triangul√©s un √† la fois. </font><font style="vertical-align: inherit;">Par cons√©quent, en fait, nous avons besoin d'un seul ensemble de listes, et non d'un ensemble pour chaque objet maill√© hexagonal. </font><font style="vertical-align: inherit;">Cela peut √™tre r√©alis√© en rendant les listes statiques.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Vector3&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Color&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Color&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// vertices = new List&lt;Vector3&gt;(); // colors = new List&lt;Color&gt;(); // triangles = new List&lt;int&gt;(); }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les listes statiques sont-elles vraiment si importantes?</font></font></b> <div class="spoiler_text">           .    ,   ,       . <br><br>     ,           .    20  20     100. </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contr√¥le de la cam√©ra </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le grand appareil photo est merveilleux, mais il est inutile si nous ne pouvons pas le voir. Pour inspecter la carte enti√®re, nous devons d√©placer la cam√©ra. Le zoom est √©galement utile. Par cons√©quent, cr√©ons une cam√©ra pour effectuer ces actions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez un objet factice et appelez-le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cam√©ra Hex Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . D√©posez son composant de transformation de sorte qu'il se d√©place vers l'origine sans modifier sa rotation et son √©chelle. Ajoutez-y un enfant appel√© </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swivel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et ajoutez-y un enfant </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stick</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Faites de la cam√©ra principale un enfant du Stick et r√©initialisez son composant de transformation.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a8/33f/3d9/0a833f3d9eea9b9fef1682ef63a7f372.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La hi√©rarchie de la cam√©ra. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le but de la charni√®re de la cam√©ra (pivotante) est de contr√¥ler l'angle sous lequel la cam√©ra regarde la carte. </font><font style="vertical-align: inherit;">Donnons-lui un tour (45, 0, 0). </font><font style="vertical-align: inherit;">La poign√©e (Stick) contr√¥le la distance √† laquelle les cam√©ras sont situ√©es. </font><font style="vertical-align: inherit;">Fixons-lui une position (0, 0, -45). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons besoin d'un composant pour contr√¥ler ce syst√®me. </font><font style="vertical-align: inherit;">Attribuez ce composant √† la racine de la hi√©rarchie des cam√©ras. </font><font style="vertical-align: inherit;">Donnez-lui un lien vers la charni√®re et la poign√©e, en les faisant entrer </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapCamera</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Transform swivel, stick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb6/2e5/44b/eb62e544b9e00bc558dfbc504802cfba.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cam√©ra de carte hexagonale.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zoom </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re fonction que nous allons cr√©er est le zoom (zoom). </font><font style="vertical-align: inherit;">Nous pouvons contr√¥ler le niveau de zoom actuel en utilisant la variable flottante. </font><font style="vertical-align: inherit;">Une valeur de 0 signifie que nous sommes compl√®tement √©loign√©s et une valeur de 1 signifie que nous sommes compl√®tement proches. </font><font style="vertical-align: inherit;">Commen√ßons par un zoom maximum.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoom = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le zoom est g√©n√©ralement effectu√© avec la molette de la souris ou un contr√¥le analogique. </font><font style="vertical-align: inherit;">Nous pouvons l'impl√©menter en utilisant l'axe d'entr√©e </font><font style="vertical-align: inherit;">par d√©faut de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">molette de la souris</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nous ajoutons une m√©thode </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui v√©rifie la pr√©sence d'un delta d'entr√©e, et s'il y en a un, il appelle la m√©thode pour changer le zoom.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour modifier le niveau de zoom, nous y ajoutons simplement un delta, puis limitons la valeur (pince) pour rester dans la plage 0‚Äì1. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors d'un zoom avant ou arri√®re, la distance par rapport √† la cam√©ra doit changer en cons√©quence. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en changeant la position de la poign√©e en Z. Ajoutez deux variables flottantes communes pour ajuster la position de la poign√©e au zoom minimum et maximum. </font><font style="vertical-align: inherit;">Puisque nous d√©veloppons une carte relativement petite, d√©finissez les valeurs sur -250 et -45.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stickMinZoom, stickMaxZoom;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir chang√© le zoom, nous effectuons une interpolation lin√©aire entre ces deux valeurs en fonction de la nouvelle valeur de zoom. </font><font style="vertical-align: inherit;">Mettez ensuite √† jour la position de la poign√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom); stick.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, distance); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cec/f4c/f07/cecf4cf07d627d6eaab94ecdc2953d30.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeurs de stick minimum et maximum. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, le zoom fonctionne, mais jusqu'√† pr√©sent, il n'est pas tr√®s utile. </font><font style="vertical-align: inherit;">Habituellement, lorsque le zoom est plus √©loign√©, la cam√©ra passe en vue de dessus. </font><font style="vertical-align: inherit;">Nous pouvons le r√©aliser en tournant la charni√®re. </font><font style="vertical-align: inherit;">Par cons√©quent, nous ajoutons les variables min et max pour la charni√®re. </font><font style="vertical-align: inherit;">Fixons-leur les valeurs 90 et 45.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> swivelMinZoom, swivelMaxZoom;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme pour la position de la poign√©e, nous interpolons pour trouver un angle de zoom appropri√©. </font><font style="vertical-align: inherit;">Ensuite, nous d√©finissons la rotation de la charni√®re.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom); stick.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, distance); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Mathf.Lerp(swivelMinZoom, swivelMaxZoom, zoom); swivel.localRotation = Quaternion.Euler(angle, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/766/0c3/fcd/7660c3fcd621567398ea7c013fae549c.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La valeur minimale et maximale de Swivel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le taux de changement du zoom peut √™tre ajust√© en changeant la sensibilit√© des param√®tres d'entr√©e de la molette de la souris. </font><font style="vertical-align: inherit;">Ils peuvent √™tre trouv√©s dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Edit / Project Settings / Input</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Par exemple, en les changeant de 0,1 √† 0,025, nous obtenons un changement de zoom plus lent et plus fluide.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d43/f86/ef3/d43f86ef3587be1bfd15ca208eec418f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Options de saisie de la molette de la souris.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©m√©nagement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passons maintenant au d√©placement de la cam√©ra. </font><font style="vertical-align: inherit;">Le mouvement dans la direction de X et Z doit √™tre impl√©ment√© dans </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comme dans le cas du zoom. </font><font style="vertical-align: inherit;">Nous pouvons utiliser des axes d'entr√©e </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontaux</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verticaux</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour cela </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela nous permettra de d√©placer la cam√©ra avec les fl√®ches et les touches WASD.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span> || zDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustPosition(xDelta, zDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'approche la plus simple consiste √† obtenir la position actuelle du syst√®me de cam√©ra, √† y ajouter des deltas X et Z et √† affecter le r√©sultat √† la position du syst√®me. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 position = transform.localPosition; position += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta); transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cette raison, la cam√©ra se d√©placera tout en maintenant les fl√®ches ou WASD, mais pas √† une vitesse constante. </font><font style="vertical-align: inherit;">Cela d√©pendra de la fr√©quence d'images. </font><font style="vertical-align: inherit;">Pour d√©terminer la distance √† parcourir, nous utilisons le delta temporel ainsi que la vitesse requise. </font><font style="vertical-align: inherit;">Par cons√©quent, nous ajoutons une variable commune </font></font><code>moveSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la d√©finissons sur 100, puis la multiplions par le delta temporel pour obtenir le delta de position.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moveSpeed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * Time.deltaTime; Vector3 position = transform.localPosition; position += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta) * distance; transform.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6da/1bc/307/6da1bc3074dc31868b934a35aaa31b10.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vitesse de d√©placement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant nous d√©placer √† une vitesse constante le long des axes X ou Z. Mais lorsque vous vous d√©placez le long des deux axes en m√™me temps (en diagonale), le mouvement sera plus rapide. </font><font style="vertical-align: inherit;">Pour r√©soudre ce probl√®me, nous devons normaliser le vecteur delta. </font><font style="vertical-align: inherit;">Cela vous permettra de l'utiliser comme destination.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * Time.deltaTime; Vector3 position = transform.localPosition; position += direction * distance; transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mouvement diagonal est maintenant correctement mis en ≈ìuvre, mais il s'av√®re soudain que la cam√©ra continue de bouger assez longtemps m√™me apr√®s avoir rel√¢ch√© toutes les touches. Cela se produit car les axes d'entr√©e ne sautent pas instantan√©ment aux valeurs limites imm√©diatement apr√®s avoir appuy√© sur les touches. Ils ont besoin de temps pour cela. Il en va de m√™me pour la lib√©ration des cl√©s. Il faut du temps pour revenir √† des valeurs d'axe nulles. Cependant, puisque nous avons normalis√© les valeurs d'entr√©e, la vitesse maximale est constamment maintenue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons ajuster les param√®tres d'entr√©e pour √©liminer les retards, mais ils donnent une sensation de douceur qui m√©rite d'√™tre sauvegard√©e. Nous pouvons appliquer la valeur la plus extr√™me des axes comme coefficient d'amortissement du mouvement.</font></font><br><br><pre> <code class="cs hljs"> Vector3 direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * damping * Time.deltaTime;</code> </pre><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mouvement avec att√©nuation. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, le mouvement fonctionne bien, au moins avec une augmentation du zoom. </font><font style="vertical-align: inherit;">Mais √† distance cela s'av√®re trop lent. </font><font style="vertical-align: inherit;">Avec un zoom r√©duit, nous devons acc√©l√©rer. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en rempla√ßant une variable </font></font><code>moveSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par deux pour le zoom minimum et maximum, puis en interpolant. </font><font style="vertical-align: inherit;">Attribuez-leur des valeurs de 400 et 100.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public float moveSpeed; public float moveSpeedMinZoom, moveSpeedMaxZoom; void AdjustPosition (float xDelta, float zDelta) { Vector3 direction = new Vector3(xDelta, 0f, zDelta).normalized; float damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta)); float distance = Mathf.Lerp(moveSpeedMinZoom, moveSpeedMaxZoom, zoom) * damping * Time.deltaTime; Vector3 position = transform.localPosition; position += direction * distance; transform.localPosition = position; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/cb8/65e/5a9cb865ee0a67d4b3ad056317faf479.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La vitesse de d√©placement varie en fonction du niveau de zoom. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant nous d√©placer rapidement sur la carte! </font><font style="vertical-align: inherit;">En fait, nous pouvons aller bien au-del√† de la carte, mais ce n'est pas souhaitable. </font><font style="vertical-align: inherit;">La cam√©ra doit rester √† l'int√©rieur de la carte. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons conna√Ætre les limites de la carte, donc un lien vers la grille est n√©cessaire. </font><font style="vertical-align: inherit;">Ajoutez-le et connectez-le.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e71/f87/68e/e71f8768e16aee250700a7bd694a0e6b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besoin de demander la taille de la grille. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir d√©plac√© vers une nouvelle position, nous la limiterons en utilisant la nouvelle m√©thode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transform.localPosition = ClampPosition(position); } <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La position X a une valeur minimale de 0 et la valeur maximale est d√©termin√©e par la taille de la carte. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il en va de m√™me pour la position Z. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = grid.chunkCountZ * HexMetrics.chunkSizeZ * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, c'est un peu inexact. </font><font style="vertical-align: inherit;">Le point de d√©part est au centre de la cellule, pas √† gauche. </font><font style="vertical-align: inherit;">Par cons√©quent, nous voulons que la cam√©ra s'arr√™te au centre des cellules les plus √† droite. </font><font style="vertical-align: inherit;">Pour ce faire, soustrayez la moiti√© de la cellule du maximum de X.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.chunkCountX * HexMetrics.chunkSizeX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour la m√™me raison, nous devons r√©duire le maximum Z. Puisque les mesures sont l√©g√®rement diff√©rentes, nous devons soustraire la cellule enti√®re. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.chunkCountZ * HexMetrics.chunkSizeZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec le mouvement, nous avons termin√©, il ne reste qu'un petit d√©tail. </font><font style="vertical-align: inherit;">Parfois, l'interface utilisateur r√©agit aux touches fl√©ch√©es, ce qui conduit au fait que lorsque vous d√©placez la cam√©ra, le curseur se d√©place. </font><font style="vertical-align: inherit;">Cela se produit lorsque l'interface utilisateur se consid√®re comme active, apr√®s avoir cliqu√© dessus et que le curseur reste au-dessus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez emp√™cher l'interface utilisateur d'√©couter les entr√©es au clavier. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demandant √† l'</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objet </font><em><font style="vertical-align: inherit;">EventSystem de</font></em><font style="vertical-align: inherit;"> ne pas ex√©cuter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Send Navigation Events</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/008/313/35c/00831335c530f6fcb06d4fe15890c316.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus d'√©v√©nements de navigation.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tourner </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous voulez voir ce qu'il y a derri√®re la falaise? </font><font style="vertical-align: inherit;">Il serait pratique de pouvoir faire pivoter la cam√©ra! </font><font style="vertical-align: inherit;">Ajoutons cette fonctionnalit√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le niveau de zoom n'est pas important pour la rotation, seule la vitesse suffit. </font><font style="vertical-align: inherit;">Ajoutez une variable commune </font></font><code>rotationSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et r√©glez-la sur 180 degr√©s. </font><font style="vertical-align: inherit;">V√©rifiez le delta de rotation en </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√©chantillonnant l'axe de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et en changeant la rotation si n√©cessaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Rotation"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustRotation(rotationDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span> || zDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustPosition(xDelta, zDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c17/189/c8f/c17189c8f16ef3e50aa8af32f7ff34c8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vitesse de rotation. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, l'axe de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'est </font><font style="vertical-align: inherit;">pas par d√©faut. </font><font style="vertical-align: inherit;">Nous devrons le cr√©er nous-m√™mes. </font><font style="vertical-align: inherit;">Acc√©dez aux param√®tres d'entr√©e et dupliquez l'entr√©e sup√©rieure </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verticale</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Changez le nom du doublon en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et changez les cl√©s en QE et une virgule (,) avec un point (.).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/549/6a8/50a/5496a850af906515b57a0d0fd1aea7b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tournez l'axe d'entr√©e.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai t√©l√©charg√© le paquet d'unit√©, pourquoi n'ai-je pas cette entr√©e?</font></font></b> <div class="spoiler_text">     .       Unity.  ,     .    ,    ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'angle de rotation que nous suivrons et changerons </font></font><code>AdjustRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apr√®s quoi, nous allons faire pivoter l'ensemble du syst√®me de cam√©ra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationAngle; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { rotationAngle += delta * rotationSpeed * Time.deltaTime; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, rotationAngle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âtant donn√© que le cercle complet est de 360 ‚Äã‚Äãdegr√©s, nous roulons l'angle de rotation de sorte qu'il se situe dans la plage de 0 √† 360. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { rotationAngle += delta * rotationSpeed * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationAngle &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { rotationAngle += <span class="hljs-number"><span class="hljs-number">360f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationAngle &gt;= <span class="hljs-number"><span class="hljs-number">360f</span></span>) { rotationAngle -= <span class="hljs-number"><span class="hljs-number">360f</span></span>; } transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, rotationAngle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mettez en action. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, la rotation fonctionne. </font><font style="vertical-align: inherit;">Si vous le v√©rifiez, vous pouvez voir que le mouvement est absolu. </font><font style="vertical-align: inherit;">Par cons√©quent, apr√®s avoir tourn√© √† 180 degr√©s, le mouvement sera l'oppos√© de ce qui √©tait attendu. </font><font style="vertical-align: inherit;">Il serait beaucoup plus pratique pour l'utilisateur que le mouvement soit effectu√© par rapport √† l'angle de vue de la cam√©ra. </font><font style="vertical-align: inherit;">Nous pouvons le faire en multipliant la rotation actuelle par la direction du mouvement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 direction = transform.localRotation * <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; ‚Ä¶ }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©placement relatif. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âdition avanc√©e </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons une carte plus grande, vous pouvez am√©liorer les outils d'√©dition de carte. </font><font style="vertical-align: inherit;">Changer une cellule √† la fois est trop long, donc ce serait bien de cr√©er un pinceau plus grand. </font><font style="vertical-align: inherit;">Il sera √©galement pratique si vous pouviez choisir de peindre ou de modifier la hauteur, en laissant tout le reste inchang√©.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Couleur et hauteur en option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons rendre les couleurs facultatives en ajoutant une option de s√©lection vide au groupe de bascule. </font><font style="vertical-align: inherit;">Dupliquez l'un des commutateurs de couleur et remplacez son √©tiquette par </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">---</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou quelque chose de similaire pour indiquer qu'il ne s'agit pas d'une couleur. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remplacez</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ensuite l'argument de son √©v√©nement </font><em><font style="vertical-align: inherit;">On Value Changed</font></em><font style="vertical-align: inherit;"> par ‚àí1.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/786/485/b0c/786485b0cbbae8edee6c80873f19afc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Index de couleur non valide. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, cet index n'est pas valide pour un tableau de couleurs. </font><font style="vertical-align: inherit;">Nous pouvons l'utiliser pour d√©terminer si la couleur doit √™tre appliqu√©e aux cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { applyColor = index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { activeColor = colors[index]; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } cell.Elevation = activeElevation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La hauteur est contr√¥l√©e par un curseur, nous ne pouvons donc pas y ajouter d'interrupteur. </font><font style="vertical-align: inherit;">Au lieu de cela, nous pouvons utiliser un commutateur s√©par√© pour activer ou d√©sactiver la modification de la hauteur. </font><font style="vertical-align: inherit;">Par d√©faut, il sera activ√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyElevation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un nouveau commutateur de hauteur √† l'interface utilisateur. </font><font style="vertical-align: inherit;">Je mettrai √©galement tout sur un nouveau panneau et rendrai le curseur de hauteur horizontal pour que l'interface utilisateur soit plus belle.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07d/cab/84d/07dcab84d8e8fe4daac4b6120df34d60.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Couleur et hauteur en option. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour activer la hauteur, nous avons besoin d'une nouvelle m√©thode, que nous connecterons √† l'interface utilisateur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyElevation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyElevation = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En le connectant au commutateur de hauteur, assurez-vous que la m√©thode bool dynamique est utilis√©e en haut de la liste des m√©thodes. </font><font style="vertical-align: inherit;">Les versions correctes n'affichent pas de coche dans l'inspecteur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/d5b/1b2/887d5b1b275cb18957b63bcbecf145d4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous transmettons l'√©tat de l'interrupteur de hauteur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons choisir uniquement la coloration avec des fleurs ou seulement la hauteur. </font><font style="vertical-align: inherit;">Ou les deux, comme d'habitude. </font><font style="vertical-align: inherit;">Nous pouvons m√™me choisir de ne changer ni l'un ni l'autre, mais pour l'instant cela ne nous est pas particuli√®rement utile.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basculez entre la couleur et la hauteur.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi la hauteur s'√©teint-elle lors du choix d'une couleur?</font></font></b> <div class="spoiler_text">  ,       toggle group. ,          ,     toggle group. </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Taille du pinceau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour prendre en charge la taille du pinceau redimensionnable, ajoutez une variable enti√®re </font></font><code>brushSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et une m√©thode pour la d√©finir via l'interface utilisateur. </font><font style="vertical-align: inherit;">Nous allons utiliser le curseur, donc encore une fois nous devrons convertir la valeur de float en int.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brushSize; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetBrushSize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size</span></span></span><span class="hljs-function">)</span></span> { brushSize = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)size; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/794/bfb/60f/794bfb60f2f1c777fa0363ede3f19540.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur de taille de brosse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez cr√©er un nouveau curseur en dupliquant le curseur de hauteur. </font><font style="vertical-align: inherit;">Modifiez sa valeur maximale √† 4 et associez-la √† la m√©thode correspondante. </font><font style="vertical-align: inherit;">Je lui ai √©galement ajout√© un tag.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88e/8b2/f58/88e8b2f58abfd48657387e6670c51215.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Param√®tres du curseur de taille de pinceau. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous pouvons √©diter plusieurs cellules en m√™me temps, nous devons utiliser la m√©thode </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette m√©thode fera appel </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† toutes les cellules impliqu√©es. </font><font style="vertical-align: inherit;">La cellule initialement s√©lectionn√©e sera consid√©r√©e comme le centre du pinceau.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCells(hexGrid.GetCell(hit.point)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La taille du pinceau d√©termine le rayon de l'√©dition. </font><font style="vertical-align: inherit;">Avec un rayon de 0, ce ne sera qu'une seule cellule centrale. </font><font style="vertical-align: inherit;">Avec un rayon de 1, ce sera le centre et ses voisins. </font><font style="vertical-align: inherit;">Dans un rayon de 2, les voisins du centre et leurs voisins imm√©diats sont allum√©s.</font></font> Et ainsi de suite. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/14d/b65/61214db6508869c0ceda156c103ca032.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'au rayon 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour modifier des cellules, vous devez les contourner en boucle. </font><font style="vertical-align: inherit;">Nous avons d'abord besoin des coordonn√©es X et Z du centre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous trouvons la coordonn√©e Z minimale en soustrayant le rayon. </font><font style="vertical-align: inherit;">Nous d√©finissons donc la ligne z√©ro. </font><font style="vertical-align: inherit;">√Ä partir de cette ligne, nous bouclons jusqu'√† ce que nous couvrions la ligne au centre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re cellule de la ligne inf√©rieure a la m√™me coordonn√©e X que la cellule centrale. </font><font style="vertical-align: inherit;">Cette coordonn√©e diminue avec l'augmentation du nombre de lignes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derni√®re cellule a toujours une coordonn√©e X √©gale √† la coordonn√©e centrale plus le rayon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons boucler autour de chaque ligne et obtenir des cellules par leurs coordonn√©es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - r; x &lt;= centerX + brushSize; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'avons pas encore de m√©thode </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un param√®tre de coordonn√©es, alors cr√©ez-le. </font><font style="vertical-align: inherit;">Convertissez les coordonn√©es des d√©placements et obtenez la cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = coordinates.X + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[x + z * cellCountX]; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/490/9f2/b594909f28de1c2d52c954d312d7b90f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La partie inf√©rieure de la brosse, taille 2.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous couvrons le reste de la brosse en effectuant un cycle de haut en bas jusqu'au centre. </font><font style="vertical-align: inherit;">Dans ce cas, la logique est mise en miroir et la ligne centrale doit √™tre exclue.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - r; x &lt;= centerX + brushSize; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ + brushSize; z &gt; centerZ; z--, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - brushSize; x &lt;= centerX + r; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e8/add/c7c/9e8addc7cf0012210cdd5dc0588bc6cf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le pinceau entier, taille 2.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cela fonctionne, √† moins que notre pinceau ne d√©passe les limites de la grille. </font><font style="vertical-align: inherit;">Lorsque cela se produit, nous obtenons une exception d'index hors plage. </font><font style="vertical-align: inherit;">Pour √©viter cela, v√©rifiez les limites </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et revenez </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsqu'une cellule inexistante est demand√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || z &gt;= cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = coordinates.X + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt;= cellCountX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[x + z * cellCountX]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour √©viter l'exception de r√©f√©rence nulle, il </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit v√©rifier avant de modifier si la cellule existe vraiment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisation de plusieurs tailles de pinceau. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basculer la visibilit√© des libell√©s de cellule </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus souvent qu'autrement, nous n'avons pas besoin de voir les √©tiquettes des cellules. </font><font style="vertical-align: inherit;">Rendons-les donc facultatifs. </font><font style="vertical-align: inherit;">Puisque chaque fragment contr√¥le son propre canevas, ajoutez une m√©thode </font></font><code>ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lorsque l'interface utilisateur doit √™tre visible, nous activons le canevas. </font><font style="vertical-align: inherit;">Sinon, d√©sactivez-le.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { gridCanvas.gameObject.SetActive(visible); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cachons l'interface utilisateur par d√©faut. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; ShowUI(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que la visibilit√© de l'interface utilisateur est commut√©e pour l'ensemble de la carte, nous ajoutons la m√©thode </font></font><code>ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il transmet simplement la demande √† ses fragments.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].ShowUI(visible); } }</code> </pre> <br> <code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> obtient la m√™me m√©thode, en passant la demande √† la grille. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { hexGrid.ShowUI(visible); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enfin, nous pouvons ajouter un commutateur √† l'interface utilisateur et le connecter. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/120/637/740/120637740d174168d298407ec129c0d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commutateur de visibilit√© des balises. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 6: rivi√®res </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajout de rivi√®res aux cellules. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faites glisser et d√©posez le support pour dessiner des rivi√®res. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ation de lits de rivi√®re. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisation de plusieurs maillages par fragment. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ez un pool de listes partag√©es. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation et animation de l'eau qui coule. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la partie pr√©c√©dente, nous avons parl√© de la prise en charge de grandes cartes. </font><font style="vertical-align: inherit;">Nous pouvons maintenant passer √† des √©l√©ments de relief plus grands. </font><font style="vertical-align: inherit;">Cette fois, nous parlerons des rivi√®res.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e66/4fb/56ae664fb799dd59d5d8e85397945937.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les rivi√®res coulent des montagnes.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cellules fluviales </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe trois fa√ßons d'ajouter des rivi√®res √† une grille d'hexagones. La premi√®re consiste √† les laisser passer de cellule en cellule. C'est ainsi qu'il est impl√©ment√© dans Endless Legend. La deuxi√®me fa√ßon consiste √† leur permettre de circuler entre les cellules, d'un bord √† l'autre. Il est donc impl√©ment√© dans Civilization 5. La troisi√®me fa√ßon n'est pas de cr√©er des structures fluviales sp√©ciales, mais d'utiliser des cellules d'eau pour les sugg√©rer. Les rivi√®res sont donc impl√©ment√©es dans Age of Wonders 3. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans notre cas, les bords des cellules sont d√©j√† occup√©s par des pentes et des falaises. Cela laisse peu de place aux rivi√®res. Par cons√©quent, nous les ferons passer de cellule en cellule. Cela signifie que dans chaque cellule, il n'y aura pas de rivi√®re, ou qu'une rivi√®re coulera le long de celle-ci, ou qu'il y aura un d√©but ou une fin de rivi√®re en elle. Dans les cellules le long desquelles la rivi√®re coule, elle peut couler directement, faire un tour d'un pas ou deux pas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/db2/2a4/e7fdb22a4346f9281865ad95a1946f75.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cinq configurations de rivi√®re possibles. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne soutiendrons pas la ramification ou la fusion de rivi√®res. </font><font style="vertical-align: inherit;">Cela compliquera encore les choses, en particulier l'√©coulement de l'eau. </font><font style="vertical-align: inherit;">De plus, nous ne serons pas intrigu√©s par de grands volumes d'eau. </font><font style="vertical-align: inherit;">Nous les consid√©rerons dans un autre tutoriel.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi de la rivi√®re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cellule le long de laquelle la rivi√®re coule peut √™tre consid√©r√©e simultan√©ment comme ayant une rivi√®re entrante et sortante. </font><font style="vertical-align: inherit;">S'il contient le d√©but d'une rivi√®re, il n'a alors qu'une rivi√®re sortante. </font><font style="vertical-align: inherit;">Et s'il contient la fin de la rivi√®re, alors il n'a qu'une rivi√®re entrante. </font><font style="vertical-align: inherit;">Nous pouvons stocker ces informations en </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisant deux valeurs bool√©ennes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasIncomingRiver, hasOutgoingRiver;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais cela ne suffit pas. </font><font style="vertical-align: inherit;">Nous devons √©galement conna√Ætre la direction de ces rivi√®res. </font><font style="vertical-align: inherit;">Dans le cas d'une rivi√®re sortante, elle indique o√π elle se d√©place. </font><font style="vertical-align: inherit;">Dans le cas d'une rivi√®re entrante, elle indique d'o√π elle vient.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasIncomingRiver, hasOutgoingRiver; HexDirection incomingRiver, outgoingRiver;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous aurons besoin de ces informations lors de la triangulation des cellules, alors ajoutez des propri√©t√©s pour y avoir acc√®s. </font><font style="vertical-align: inherit;">Nous ne prendrons pas en charge leur attribution directe. </font><font style="vertical-align: inherit;">Pour ce faire, nous ajouterons en outre une m√©thode distincte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasIncomingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasOutgoingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasOutgoingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection IncomingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> incomingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection OutgoingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une question importante est de savoir s'il y a une rivi√®re dans la cellule, quels que soient les d√©tails. </font><font style="vertical-align: inherit;">Par cons√©quent, ajoutons √©galement une propri√©t√© pour cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver || hasOutgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre question logique: c'est le d√©but ou la fin de la rivi√®re dans la cellule. </font><font style="vertical-align: inherit;">Si l'√©tat de la rivi√®re entrante et sortante est diff√©rent, alors c'est juste le cas. </font><font style="vertical-align: inherit;">Par cons√©quent, nous en ferons une autre propri√©t√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRiverBeginOrEnd { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver != hasOutgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et enfin, il sera utile de savoir si la rivi√®re traverse une certaine cr√™te, qu'elle soit entrante ou sortante. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasRiverThroughEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver &amp;&amp; incomingRiver == direction || hasOutgoingRiver &amp;&amp; outgoingRiver == direction; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enl√®vement de la rivi√®re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de commencer √† ajouter une rivi√®re √† une cellule, impl√©mentons d'abord la prise en charge de la suppression de la rivi√®re. </font><font style="vertical-align: inherit;">Pour commencer, nous √©crirons une m√©thode pour ne retirer que la partie sortante de la rivi√®re. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il n'y a pas de rivi√®re sortante dans la cellule, alors rien ne doit √™tre fait. </font><font style="vertical-align: inherit;">Sinon, d√©sactivez-le et effectuez la mise √† jour.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais ce n'est pas tout. </font><font style="vertical-align: inherit;">La rivi√®re sortante doit se d√©placer quelque part. </font><font style="vertical-align: inherit;">Par cons√©quent, il doit y avoir un voisin avec la rivi√®re entrante. </font><font style="vertical-align: inherit;">Nous devons aussi nous d√©barrasser d'elle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Refresh(); HexCell neighbor = GetNeighbor(outgoingRiver); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.Refresh(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une rivi√®re ne peut-elle pas sortir d'une carte?</font></font></b> <div class="spoiler_text">      ,     .     ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supprimer une rivi√®re d'une cellule ne change que l'apparence de cette cellule. </font><font style="vertical-align: inherit;">Contrairement √† la modification de la hauteur ou de la couleur, cela n'affecte pas les voisins. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons mettre √† jour uniquement la cellule elle-m√™me, mais pas ses voisins.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshSelfOnly(); HexCell neighbor = GetNeighbor(outgoingRiver); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette m√©thode </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">met simplement √† jour le fragment auquel appartient la cellule. </font><font style="vertical-align: inherit;">Comme nous ne changeons pas la rivi√®re lors de l'initialisation du r√©seau, nous n'avons pas √† nous inqui√©ter si un fragment a d√©j√† √©t√© attribu√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La suppression des rivi√®res entrantes fonctionne de la m√™me mani√®re. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveIncomingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasIncomingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshSelfOnly(); HexCell neighbor = GetNeighbor(incomingRiver); neighbor.hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et la suppression de la rivi√®re enti√®re signifie simplement la suppression des parties entrantes et sortantes de la rivi√®re. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RemoveOutgoingRiver(); RemoveIncomingRiver(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajout de rivi√®res </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour soutenir la cr√©ation de rivi√®res, nous avons besoin d'une m√©thode pour sp√©cifier la rivi√®re sortante de la cellule. </font><font style="vertical-align: inherit;">Il doit red√©finir toutes les rivi√®res sortantes pr√©c√©dentes et d√©finir la rivi√®re entrante correspondante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour commencer, nous n'avons rien √† faire si la rivi√®re existe d√©j√†.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous devons nous assurer qu'il y a un voisin dans la bonne direction. </font><font style="vertical-align: inherit;">De plus, les rivi√®res ne peuvent pas remonter. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons terminer l'op√©ration si le voisin est plus √©lev√©.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || elevation &lt; neighbor.elevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous devons nettoyer la rivi√®re sortante pr√©c√©dente. </font><font style="vertical-align: inherit;">Et nous devons √©galement supprimer la rivi√®re entrante, si elle est superpos√©e √† une nouvelle rivi√®re sortante.</font></font><br><br><pre> <code class="cs hljs"> RemoveOutgoingRiver(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasIncomingRiver &amp;&amp; incomingRiver == direction) { RemoveIncomingRiver(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons maintenant passer √† la mise en place de la rivi√®re sortante. </font></font><br><br><pre> <code class="cs hljs"> hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; RefreshSelfOnly();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et n'oubliez pas de d√©finir la rivi√®re entrante pour une autre cellule apr√®s avoir supprim√© sa rivi√®re entrante actuelle, si elle existe. </font></font><br><br><pre> <code class="cs hljs"> neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; neighbor.incomingRiver = direction.Opposite(); neighbor.RefreshSelfOnly();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se d√©barrasser des rivi√®res qui coulent </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons permis d'ajouter uniquement les bonnes rivi√®res, d'autres actions peuvent encore cr√©er les mauvaises. </font><font style="vertical-align: inherit;">Lorsque nous modifions la hauteur de la cellule, nous devons √† nouveau nous assurer avec force que les rivi√®res ne peuvent que couler. </font><font style="vertical-align: inherit;">Toutes les rivi√®res irr√©guli√®res doivent √™tre supprim√©es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasOutgoingRiver &amp;&amp; elevation &lt; GetNeighbor(outgoingRiver).elevation ) { RemoveOutgoingRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasIncomingRiver &amp;&amp; elevation &gt; GetNeighbor(incomingRiver).elevation ) { RemoveIncomingRiver(); } Refresh(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changer les rivi√®res </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour prendre en charge l'√©dition de la rivi√®re, nous devons ajouter un commutateur de rivi√®re √† l'interface utilisateur. </font><font style="vertical-align: inherit;">En fait. </font><font style="vertical-align: inherit;">nous avons besoin de la prise en charge de trois modes d'√©dition. </font><font style="vertical-align: inherit;">Nous devons soit ignorer les rivi√®res, soit les ajouter, soit les supprimer. </font><font style="vertical-align: inherit;">Nous pouvons utiliser une simple √©num√©ration d'aide de commutateurs pour suivre l'√©tat. </font><font style="vertical-align: inherit;">Comme nous ne l'utiliserons qu'√† l'int√©rieur de l'√©diteur, nous pouvons le d√©finir √† l'int√©rieur de la classe </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, avec le champ mode rivi√®re.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OptionalToggle { Ignore, Yes, No } OptionalToggle riverMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et nous avons besoin d'une m√©thode pour changer le r√©gime fluvial via l'interface utilisateur. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRiverMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { riverMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour contr√¥ler le r√©gime de la rivi√®re, ajoutez trois commutateurs √† l'interface utilisateur et connectez-les au nouveau groupe de bascule, comme nous l'avons fait avec les couleurs. </font><font style="vertical-align: inherit;">J'ai configur√© les commutateurs de sorte que leurs √©tiquettes soient sous les cases √† cocher. </font><font style="vertical-align: inherit;">Pour cette raison, ils resteront suffisamment minces pour s'adapter aux trois options sur une seule ligne.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/1bf/d9c/0f51bfd9ce2a73bc23f1ef99cbd4b24e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fleuves UI</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ne pas utiliser une liste d√©roulante?</font></font></b> <div class="spoiler_text">  ,    .   dropdown list  Unity        Play.    ,      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reconnaissance par glisser-d√©poser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cr√©er une rivi√®re, nous avons besoin √† la fois d'une cellule et d'une direction. </font><font style="vertical-align: inherit;">Pour le moment, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne nous fournit pas ces informations. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons ajouter la prise en charge du glisser-d√©poser d'une cellule √† l'autre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons savoir si cette tra√Æn√©e sera correcte et √©galement d√©terminer sa direction. </font><font style="vertical-align: inherit;">Et pour reconna√Ætre le glisser-d√©poser, nous devons nous souvenir de la cellule pr√©c√©dente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isDrag; HexDirection dragDirection; HexCell previousCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialement, lorsque le glissement n'est pas effectu√©, la cellule pr√©c√©dente ne l'est pas. </font><font style="vertical-align: inherit;">Autrement dit, lorsqu'il n'y a pas d'entr√©e ou que nous n'interagissons pas avec la carte, vous devez lui attribuer une valeur </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject() ) { HandleInput(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCells(hexGrid.GetCell(hit.point)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cellule actuelle est celle que nous avons trouv√©e en croisant le faisceau avec le maillage. </font><font style="vertical-align: inherit;">Apr√®s avoir modifi√© les cellules, il est mis √† jour et devient la cellule pr√©c√©dente pour une nouvelle mise √† jour.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); EditCells(currentCell); previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir d√©termin√© la cellule actuelle, nous pouvons la comparer avec la cellule pr√©c√©dente, le cas √©ch√©ant. </font><font style="vertical-align: inherit;">Si nous obtenons deux cellules diff√©rentes, nous pouvons avoir le glisser-d√©poser correct et nous devons le v√©rifier. </font><font style="vertical-align: inherit;">Sinon, ce n'est certainement pas un glisser-d√©poser.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } EditCells(currentCell); previousCell = currentCell; isDrag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment v√©rifions-nous le glisser-d√©poser? </font><font style="vertical-align: inherit;">V√©rifier si la cellule actuelle est voisine de la pr√©c√©dente. </font><font style="vertical-align: inherit;">Nous v√©rifions cela en contournant ses voisins dans un cycle. </font><font style="vertical-align: inherit;">Si nous trouvons une correspondance, nous reconnaissons √©galement imm√©diatement la direction de la tra√Æn√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDrag</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell currentCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( dragDirection = HexDirection.NE; dragDirection &lt;= HexDirection.NW; dragDirection++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell.GetNeighbor(dragDirection) == currentCell) { isDrag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allons-nous cr√©er des tra√Æn√©es saccad√©es?</font></font></b> <div class="spoiler_text">       ,          .         ¬´¬ª ,     . <br><br>    ,   .            . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changer les cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous pouvons reconna√Ætre le glisser-d√©poser, nous pouvons d√©finir les rivi√®res sortantes. </font><font style="vertical-align: inherit;">Nous pouvons √©galement supprimer des rivi√®res; pour cela, le support par glisser-d√©poser n'est pas n√©cessaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes) { previousCell.SetOutgoingRiver(dragDirection); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce code dessinera la rivi√®re de la cellule pr√©c√©dente au courant. </font><font style="vertical-align: inherit;">Mais il ignore la taille de la brosse. </font><font style="vertical-align: inherit;">C'est assez logique, mais dessinons les rivi√®res pour toutes les cellules ferm√©es par le pinceau. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en effectuant des op√©rations sur la cellule modifi√©e. </font><font style="vertical-align: inherit;">Dans notre cas, nous devons nous assurer qu'une autre cellule existe vraiment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes) { HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherCell) { otherCell.SetOutgoingRiver(dragDirection); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant √©diter les rivi√®res, mais ne les voyons pas encore. </font><font style="vertical-align: inherit;">Nous pouvons v√©rifier que cela fonctionne en examinant les cellules modifi√©es dans l'inspecteur de d√©bogage.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/927/46f/4fe92746f97fc517dc0d1da7c0aeee62.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une cellule avec une rivi√®re dans l'inspecteur de d√©bogage.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce qu'un inspecteur de d√©bogage?</font></font></b> <div class="spoiler_text">             .        .    ,     . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lits de rivi√®re entre les cellules </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la triangulation d'une rivi√®re, nous devons consid√©rer deux parties: l'emplacement du lit de la rivi√®re et l'eau qui la traverse. </font><font style="vertical-align: inherit;">Tout d'abord, nous allons cr√©er un canal et quitter l'eau pour plus tard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La partie la plus simple de la rivi√®re est l'endroit o√π elle coule en jonction entre les cellules. </font><font style="vertical-align: inherit;">Pendant que nous triangulons cette zone avec une bande de trois quadruples. </font><font style="vertical-align: inherit;">Nous pouvons y ajouter un lit de rivi√®re en abaissant le quad central et en ajoutant deux parois de canaux.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/545/b3c/b93/545b3cb9373e9479011916513c3c51da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajout d'une rivi√®re √† une bande de c√¥tes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cela, dans le cas de la rivi√®re, deux quads suppl√©mentaires seront n√©cessaires et un canal avec deux parois verticales sera cr√©√©. </font><font style="vertical-align: inherit;">Une autre approche consiste √† utiliser quatre quadruples. </font><font style="vertical-align: inherit;">Ensuite, nous abaissons le pic central pour cr√©er un lit avec des murs en pente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/7d9/ac1/7577d9ac1978be05cbdda0f8925c75d0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toujours quatre quad. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation constante du m√™me nombre de quadrangles est pratique, alors choisissons cette option.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajout de sommets de bord </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La transition de trois √† quatre par ar√™te n√©cessite la cr√©ation d'un sommet suppl√©mentaire de l'ar√™te. </font><font style="vertical-align: inherit;">Nous r√©√©crivons </font></font><code>EdgeVertices</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en renommant d'abord </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>v5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis en renommant </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les actions dans cet ordre garantissent que tout le code continue de r√©f√©rencer les bons sommets. </font><font style="vertical-align: inherit;">Utilisez l'option renommer ou refactoriser de votre √©diteur pour que les modifications s'appliquent partout. </font><font style="vertical-align: inherit;">Sinon, vous devrez inspecter manuellement l'int√©gralit√© du code et apporter des modifications.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v4, v5;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir renomm√© tout, ajoutez-en un nouveau </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v3, v4, v5;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un nouveau sommet au constructeur. </font><font style="vertical-align: inherit;">Il est situ√© au milieu entre les sommets des coins. </font><font style="vertical-align: inherit;">De plus, les autres sommets devraient maintenant √™tre en ¬Ω et ¬æ, et non en &amp; frac13; </font><font style="vertical-align: inherit;">et &amp; frac23;.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); v4 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.75f</span></span>); v5 = corner2; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajouter </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font><font style="vertical-align: inherit;">ajouter </font></font><code>TerraceLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EdgeVertices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices a, EdgeVertices b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { EdgeVertices result; result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step); result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step); result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step); result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step); result.v5 = HexMetrics.TerraceLerp(a.v5, b.v5, step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, je </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois inclure un sommet suppl√©mentaire dans les triangles en √©ventail de la nervure.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { AddTriangle(center, edge.v1, edge.v2); AddTriangleColor(color); AddTriangle(center, edge.v2, edge.v3); AddTriangleColor(color); AddTriangle(center, edge.v3, edge.v4); AddTriangleColor(color); AddTriangle(center, edge.v4, edge.v5); AddTriangleColor(color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et aussi dans ses rayures de quadrangles. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2 </span></span></span><span class="hljs-function">)</span></span> { AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); AddQuadColor(c1, c2); AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); AddQuadColor(c1, c2); AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); AddQuadColor(c1, c2); AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); AddQuadColor(c1, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/819/89d/599/81989d5996d7c2832e3dd7f61b4a9bb1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/625/9b1/6a2/6259b16a2776344c51725d32d70001e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparaison de quatre et cinq sommets par ar√™te.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La hauteur du lit de la rivi√®re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons cr√©√© le canal en abaissant le bas en haut de la nervure. </font><font style="vertical-align: inherit;">Il d√©termine la position verticale du lit de la rivi√®re. </font><font style="vertical-align: inherit;">Bien que la position verticale exacte de chaque cellule soit d√©form√©e, nous devons maintenir la m√™me hauteur du lit de la rivi√®re dans les cellules de m√™me hauteur. </font><font style="vertical-align: inherit;">Gr√¢ce √† cette eau, elle n'a pas √† s'√©couler en amont. </font><font style="vertical-align: inherit;">De plus, le lit doit √™tre suffisamment bas pour rester en dessous, m√™me dans le cas des cellules verticales les plus d√©vi√©es, tout en laissant suffisamment de place pour l'eau. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©finissons ce d√©calage </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et exprimons-le en hauteur. </font><font style="vertical-align: inherit;">Des d√©calages d'un niveau suffiront.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> streamBedElevationOffset = <span class="hljs-number"><span class="hljs-number">-1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons utiliser cette m√©trique pour ajouter des propri√©t√©s </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour obtenir la position verticale du lit de la rivi√®re cellulaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> StreamBedY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.streamBedElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ation d'une cha√Æne </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'une </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des six parties triangulaires d'une cellule est triangul√©e, nous pouvons d√©terminer si une rivi√®re coule le long de son bord. </font><font style="vertical-align: inherit;">Si c'est le cas, nous pouvons alors abaisser le pic m√©dian de la c√¥te √† la hauteur du lit de la rivi√®re.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; } TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0d/a57/028/d0da570288985442d990858b2831c07a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez le sommet m√©dian de la c√¥te. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons voir comment apparaissent les premiers signes de la rivi√®re, mais des trous apparaissent dans le relief. </font><font style="vertical-align: inherit;">Pour les fermer, nous devons changer un autre bord, puis trianguler la connexion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); bridge.y = neighbor.Position.y - cell.Position.y; EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v5 + bridge ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4c/aa9/5f4/b4caa95f424004569e7876bc19c73a20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canaux termin√©s des articulations des c√¥tes. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lits de rivi√®re passant √† travers une cellule </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons les bons lits de rivi√®re entre les cellules. Mais lorsque la rivi√®re traverse la cellule, les canaux se terminent toujours en son centre. Pour r√©soudre ce probl√®me devra travailler. Commen√ßons par le cas o√π une rivi√®re traverse directement une cellule, d'un bord √† l'autre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il n'y a pas de rivi√®re, chaque partie de la cellule peut √™tre un simple √©ventail de triangles. Mais lorsque la rivi√®re coule directement, il faut ins√©rer un canal. En fait, nous devons √©tirer le sommet central en une ligne, transformant ainsi les deux triangles du milieu en quadrangles. Puis l'√©ventail de triangles se transforme en trap√®ze.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a9/919/ffb/9a9919ffbb99bcded8d44f45e62c3955.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ins√©rons le canal dans le triangle. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces canaux seront beaucoup plus longs que ceux passant par la connexion des cellules. </font><font style="vertical-align: inherit;">Cela devient apparent lorsque les positions des sommets sont d√©form√©es. </font><font style="vertical-align: inherit;">Par cons√©quent, divisons le trap√®ze en deux segments en ins√©rant un autre ensemble d'ar√™tes de sommet au milieu entre le centre et l'ar√™te.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/f94/109/650f9410923cb781f145b5211dbe4950.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulation des canaux. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que la triangulation avec une rivi√®re sera tr√®s diff√©rente de la triangulation sans rivi√®re, cr√©ons-en une m√©thode distincte. </font><font style="vertical-align: inherit;">Si nous avons une rivi√®re, nous utilisons cette m√©thode, sinon nous laisserons un √©ventail de triangles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; TriangulateWithRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeFan(center, e, cell.Color); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/f0f/526/928f0f526852960fce6c37bdb480b5bc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trous dans lesquels il devrait y avoir des rivi√®res. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour mieux voir ce qui se passe, d√©sactivez temporairement la distorsion cellulaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 4f;</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2aa/f49/ae3/2aaf49ae366805585727f1a1ed11c2aa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pics non d√©form√©s.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation directement √† travers la cellule </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cr√©er un canal directement √† travers une partie de la cellule, nous devons √©tirer le centre en ligne. </font><font style="vertical-align: inherit;">Cette ligne doit avoir la m√™me largeur que le canal. </font><font style="vertical-align: inherit;">Nous pouvons trouver le sommet gauche en d√©pla√ßant ¬º de la distance du centre au premier coin de la partie pr√©c√©dente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De m√™me pour le sommet droit. </font><font style="vertical-align: inherit;">Dans ce cas, nous avons besoin du deuxi√®me coin de la partie suivante.</font></font><br><br><pre> <code class="cs hljs"> Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; Vector3 centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La ligne m√©diane peut √™tre trouv√©e en cr√©ant des ar√™tes de sommet entre le centre et l'ar√™te. </font></font><br><br><pre> <code class="cs hljs"> EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(centerL, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(centerR, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, changez le sommet moyen de la nervure centrale, ainsi que le centre, car ils deviendront les points inf√©rieurs du canal. </font></font><br><br><pre> <code class="cs hljs"> m.v3.y = center.y = e.v3.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons utiliser </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour remplir l'espace entre la ligne m√©diane et la ligne de bord.</font></font><br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip(m, cell.Color, e, cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ab/050/b30/3ab050b301f8815479142c5b8feae26e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canaux compress√©s.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Malheureusement, les canaux semblent compress√©s. Cela se produit car les sommets m√©dians de la nervure sont trop proches les uns des autres. Pourquoi est-ce arriv√©? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous supposons que la longueur du bord ext√©rieur est de 1, la longueur de la ligne m√©diane sera de ¬Ω. √âtant donn√© que le bord central est au milieu entre eux, sa longueur doit √™tre √©gale √† ¬æ. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La largeur du canal est de ¬Ω et doit rester constante. Comme la longueur du bord central est is, il ne reste que ¬º, selon &amp; frac18; des deux c√¥t√©s du canal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e1/25f/037/2e125f03727f078ccfd094a29ad4d596.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Longueurs relatives. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme la longueur du bord central est ¬æ, alors &amp; frac18; </font><font style="vertical-align: inherit;">devient par rapport √† la longueur de la nervure centrale √©gale √† &amp; frac16 ;. </font><font style="vertical-align: inherit;">Cela signifie que ses deuxi√®me et quatri√®me sommets doivent √™tre interpol√©s avec des sixi√®mes, pas des quarts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons fournir un support pour une telle interpolation alternative en ajoutant √† </font></font><code>EdgeVertices</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un autre constructeur. </font><font style="vertical-align: inherit;">Au lieu d'interpolations fixes pour </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisons un param√®tre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outerStep</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, outerStep); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); v4 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">1f</span></span> - outerStep); v5 = corner2; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant l'utiliser avec &amp; frac16; </font><font style="vertical-align: inherit;">c </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(centerL, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(centerR, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4a/df8/cb5/c4adf8cb5aa6b1685f6d5c592976ea3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cha√Ænes directes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir rectifi√© le canal, nous pouvons passer √† la deuxi√®me partie du trap√®ze. </font><font style="vertical-align: inherit;">Dans ce cas, nous ne pouvons pas utiliser la bande de c√¥tes, nous devons donc le faire manuellement. </font><font style="vertical-align: inherit;">Cr√©ons d'abord des triangles sur les c√¥t√©s.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(centerL, m.v1, m.v2); AddTriangleColor(cell.Color); AddTriangle(centerR, m.v4, m.v5); AddTriangleColor(cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10b/dc7/a5b/10bdc7a5b1d32d03dbc155a2d00bbfb5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangles lat√©raux. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble bon, remplissons donc l'espace restant avec deux quadrangles, cr√©ant la derni√®re partie du canal.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(centerL, m.v1, m.v2); AddTriangleColor(cell.Color); AddQuad(centerL, center, m.v2, m.v3); AddQuadColor(cell.Color); AddQuad(center, centerR, m.v3, m.v4); AddQuadColor(cell.Color); AddTriangle(centerR, m.v4, m.v5); AddTriangleColor(cell.Color);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, nous n'avons pas d'alternative </font></font><code>AddQuadColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne n√©cessitant qu'un seul param√®tre. </font><font style="vertical-align: inherit;">Alors que nous n'en avions pas besoin. </font><font style="vertical-align: inherit;">Cr√©ons-le donc.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { colors.Add(color); colors.Add(color); colors.Add(color); colors.Add(color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af0/b62/c32/af0b62c3232b36cd0a136b1fc009b7dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cha√Ænes droites termin√©es.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©but et fin de la triangulation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La triangulation d'une partie qui n'a que le d√©but ou la fin d'une rivi√®re est assez diff√©rente, et n√©cessite donc sa propre m√©thode. </font><font style="vertical-align: inherit;">Par cons√©quent, nous allons v√©rifier cela </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et appeler la m√©thode appropri√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { TriangulateWithRiverBeginOrEnd(direction, cell, center, e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithRiver(direction, cell, center, e); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, nous voulons terminer le canal au centre, mais nous utilisons toujours deux √©tapes pour cela. </font><font style="vertical-align: inherit;">Par cons√©quent, nous allons √† nouveau cr√©er le bord m√©dian entre le centre ou le bord. </font><font style="vertical-align: inherit;">Puisque nous voulons terminer le canal, nous sommes tr√®s heureux qu'il soit compress√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afin que le canal ne devienne pas trop peu profond, nous assignerons la hauteur du lit de la rivi√®re au pic moyen. </font><font style="vertical-align: inherit;">Mais le centre n'a pas besoin d'√™tre chang√©.</font></font><br><br><pre> <code class="cs hljs"> m.v3.y = e.v3.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On peut trianguler avec une bande de c√¥tes et un √©ventail. </font></font><br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip(m, cell.Color, e, cell.Color); TriangulateEdgeFan(center, m, cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16b/0c5/9e0/16b0c59e0999f2a505e709648c1e1af7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Points de d√©part et d'arriv√©e.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Virages en une √©tape </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, consid√©rez les virages serr√©s qui zigzaguent entre les cellules adjacentes. </font><font style="vertical-align: inherit;">Nous les g√©rerons aussi </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons d√©terminer avec quel type de rivi√®re nous travaillons.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/523/c03/e37/523c03e370096f804df6b84a97dbdfbf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivi√®re Zigzag. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la cellule a une rivi√®re qui coule dans la direction oppos√©e, ainsi que dans la direction avec laquelle nous travaillons, alors ce devrait √™tre une rivi√®re droite. </font><font style="vertical-align: inherit;">Dans ce cas, nous pouvons enregistrer la ligne m√©diane que nous avons d√©j√† calcul√©e. </font><font style="vertical-align: inherit;">Sinon, il revient √† un point, repliant la ligne m√©diane.</font></font><br><br><pre> <code class="cs hljs"> Vector3 centerL, centerR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/992/4c0/90c9924c049cf8033e7480c90b74b903.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zigzags recourb√©s. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons reconna√Ætre les virages serr√©s en v√©rifiant si la cellule a une rivi√®re traversant la partie suivante ou pr√©c√©dente de la cellule. </font><font style="vertical-align: inherit;">S'il y en a, alors nous devons aligner la ligne centrale avec le bord entre celui-ci et la partie voisine. </font><font style="vertical-align: inherit;">Nous pouvons le faire en pla√ßant le c√¥t√© correspondant de la ligne au milieu entre le centre et l'angle commun. </font><font style="vertical-align: inherit;">L'autre c√¥t√© de la ligne devient alors le centre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s avoir d√©cid√© o√π se trouvent les points gauche et droit, nous pouvons d√©terminer le centre r√©sultant en les faisant la moyenne. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { ‚Ä¶ } center = Vector3.Lerp(centerL, centerR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f14/cc6/4f9/f14cc64f953da69fb270ff2adf613b2e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√¥te centrale d√©cal√©e. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que le canal ait la m√™me largeur des deux c√¥t√©s, il semble assez compress√©. </font><font style="vertical-align: inherit;">Cela est d√ª au fait de tourner la ligne m√©diane de 60 ¬∞. </font><font style="vertical-align: inherit;">Vous pouvez lisser cet effet en augmentant l√©g√®rement la largeur de la ligne centrale. </font><font style="vertical-align: inherit;">Au lieu d'interpoler avec ¬Ω, nous utilisons &amp; frac23 ;.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/c01/ea3/28cc01ea3d203243a1dfe49cde5e9802.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zigzag sans compression.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Virages en deux √©tapes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les autres cas se situent entre des zigzags et des rivi√®res droites. </font><font style="vertical-align: inherit;">Ce sont des virages en deux √©tapes qui cr√©ent des rivi√®res l√©g√®rement courbes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67d/bab/9b2/67dbab9b235833d69b3201c9b38ac653.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La rivi√®re sinueuse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour distinguer entre deux orientations possibles, nous devons utiliser </font></font><code>direction.Next().Next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais nous allons en ajoutant le </font><font style="vertical-align: inherit;">rendre plus pratique des </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thodes d'extension </font></font><code>Next2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Previous2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Previous2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { direction -= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &gt;= HexDirection.NE ? direction : (direction + <span class="hljs-number"><span class="hljs-number">6</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { direction += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &lt;= HexDirection.NW ? direction : (direction - <span class="hljs-number"><span class="hljs-number">6</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retour √† </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Maintenant, nous pouvons reconna√Ætre la direction de notre rivi√®re sinueuse avec </font></font><code>direction.Next2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ces deux derniers cas, nous devons d√©placer la ligne m√©diane vers la partie de la cellule situ√©e √† l'int√©rieur de la courbe. </font><font style="vertical-align: inherit;">Si nous avions un vecteur au milieu d'un bord solide, nous pourrions l'utiliser pour positionner le point final. </font><font style="vertical-align: inherit;">Imaginons que nous ayons une m√©thode pour cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = center; centerR = center + HexMetrics.GetSolidEdgeMiddle(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = center + HexMetrics.GetSolidEdgeMiddle(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, nous devons maintenant ajouter une telle m√©thode √† </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il lui suffit de faire la moyenne de deux vecteurs d'angles adjacents et d'appliquer le coefficient d'int√©grit√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSolidEdgeMiddle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * solidFactor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be1/058/429/be1058429e3d36cd25b8e1da0c1be77a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Courbes l√©g√®rement compress√©es. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos axes m√©dians sont maintenant correctement tourn√©s de 30 ¬∞. </font><font style="vertical-align: inherit;">Mais ils ne sont pas assez longs, c'est pourquoi les canaux sont un peu compress√©s. </font><font style="vertical-align: inherit;">Cela se produit parce que le milieu de la c√¥te est plus proche du centre que l'angle de la c√¥te. </font><font style="vertical-align: inherit;">Sa distance est √©gale au rayon int√©rieur, pas √† l'ext√©rieur. </font><font style="vertical-align: inherit;">Autrement dit, nous travaillons √† la mauvaise √©chelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous convertissons d√©j√† le rayon externe en rayon interne √† </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous devons effectuer l'op√©ration inverse. </font><font style="vertical-align: inherit;">Rendons donc les deux facteurs de conversion disponibles via </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerToInner = <span class="hljs-number"><span class="hljs-number">0.866025404f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerToOuter = <span class="hljs-number"><span class="hljs-number">1f</span></span> / outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerRadius = <span class="hljs-number"><span class="hljs-number">10f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant passer √† la bonne √©chelle </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les cha√Ænes resteront encore un peu serr√©es √† cause de leur tour, mais cela est beaucoup moins prononc√© que dans le cas des zigzags. </font><font style="vertical-align: inherit;">Par cons√©quent, nous n'avons pas besoin de compenser cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = center; centerR = center + HexMetrics.GetSolidEdgeMiddle(direction.Next()) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * HexMetrics.innerToOuter); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = center + HexMetrics.GetSolidEdgeMiddle(direction.Previous()) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * HexMetrics.innerToOuter); centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a2/849/49c/2a284949c066c558391613611b93d093.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Courbes lisses. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation au voisinage des rivi√®res </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos rivi√®res sont pr√™tes. </font><font style="vertical-align: inherit;">Mais nous n'avons pas encore triangul√© d'autres parties des cellules contenant les rivi√®res. </font><font style="vertical-align: inherit;">Nous allons maintenant fermer ces trous.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f47/5fd/74d/f475fd74d147a577e8adb72cd1ff63fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trous pr√®s des canaux. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la cellule a une rivi√®re, mais qu'elle ne coule pas dans la direction actuelle, alors </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous appellerons une nouvelle m√©thode dans.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { TriangulateWithRiverBeginOrEnd(direction, cell, center, e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateAdjacentToRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeFan(center, e, cell.Color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette m√©thode, nous remplissons le triangle cellulaire avec une bande et un ventilateur. </font><font style="vertical-align: inherit;">Un simple ventilateur ne nous suffira pas, car les pics doivent correspondre au bord m√©dian des parties contenant la rivi√®re.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); TriangulateEdgeStrip(m, cell.Color, e, cell.Color); TriangulateEdgeFan(center, m, cell.Color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/059/4df/7bb/0594df7bb3225d20852c9e0d0d708101.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Superposition dans les courbes et les rivi√®res droites.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faire correspondre la cha√Æne </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, nous devons faire correspondre le centre que nous utilisons √† la partie centrale utilis√©e par les parties de la rivi√®re. </font><font style="vertical-align: inherit;">Avec les zigzags, tout est en ordre, et les courbes et les rivi√®res droites n√©cessitent de l'attention. </font><font style="vertical-align: inherit;">Par cons√©quent, nous devons d√©terminer √† la fois le type de rivi√®re et son orientation relative. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commen√ßons par v√©rifier si nous sommes √† l'int√©rieur de la courbe. </font><font style="vertical-align: inherit;">Dans ce cas, les directions pr√©c√©dente et suivante contiennent la rivi√®re. </font><font style="vertical-align: inherit;">Si c'est le cas, nous devons d√©placer le centre vers le bord.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } } EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/016/620/d89/016620d89847368d487d49bb1c81cdc7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correction d'un cas o√π la rivi√®re coulait des deux c√¥t√©s. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous avons une rivi√®re dans une direction diff√©rente, mais pas dans la pr√©c√©dente, alors nous v√©rifions si elle est droite. </font><font style="vertical-align: inherit;">Si c'est le cas, d√©placez le centre vers le premier coin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous2()) ) { center += HexMetrics.GetFirstSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1d/85a/366/a1d85a3669a55984eb69a43af5e8631f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correction d'une demi-superposition avec une rivi√®re droite. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc r√©solu le probl√®me avec la moiti√© des parties adjacentes aux rivi√®res droites. </font><font style="vertical-align: inherit;">Le dernier cas - nous avons une rivi√®re dans la direction pr√©c√©dente, et elle est droite. </font><font style="vertical-align: inherit;">Dans ce cas, vous devez d√©placer le centre vers le coin suivant.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous2()) ) { center += HexMetrics.GetFirstSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous()) &amp;&amp; cell.HasRiverThroughEdge(direction.Next2()) ) { center += HexMetrics.GetSecondSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9d/d1a/20c/c9dd1a20c213658aeed27b9065e6bf58.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus de superpositions. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> G√©n√©ralisation HexMesh </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons termin√© la triangulation des canaux. </font><font style="vertical-align: inherit;">Maintenant, nous pouvons les remplir d'eau. </font><font style="vertical-align: inherit;">√âtant donn√© que l'eau est diff√©rente de la terre, nous devrons utiliser un maillage diff√©rent avec diff√©rentes donn√©es de sommet et diff√©rents mat√©riaux. </font><font style="vertical-align: inherit;">Ce serait tr√®s pratique si nous pouvions utiliser √† la </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fois des sushis et de l'eau. </font><font style="vertical-align: inherit;">G√©n√©ralisons donc </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la transformant en une classe qui traite de ces maillages, quelle que soit leur utilisation. </font><font style="vertical-align: inherit;">Nous passerons la t√¢che de trianguler ses cellules </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©placer la m√©thode Perturb </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que la m√©thode est </font></font><code>Perturb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assez g√©n√©ralis√©e et sera utilis√©e √† diff√©rents endroits, d√©pla√ßons-la </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tout d'abord, renommez-le en </font></font><code>HexMetrics.Perturb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il s'agit d'un nom de m√©thode incorrect, mais il refacture tout le code pour son utilisation appropri√©e. </font><font style="vertical-align: inherit;">Si votre √©diteur de code poss√®de des fonctionnalit√©s sp√©ciales pour d√©placer des m√©thodes, utilisez-le. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En d√©pla√ßant la m√©thode vers l'int√©rieur </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, rendez-la g√©n√©rale et statique, puis corrigez son nom.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * cellPerturbStrength; position.z += (sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * cellPerturbStrength; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©placement des m√©thodes de triangulation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le changement de variables </font></font><code>hexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la variable partag√©e </font></font><code>terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain; <span class="hljs-comment"><span class="hljs-comment">// HexMesh hexMesh; void Awake () { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); // hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = new HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; ShowUI(false); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous refactorisons toutes les m√©thodes </font></font><code>Add‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>terrain.Add‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">D√©placez ensuite toutes les m√©thodes </font></font><code>Triangulate‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vers </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Apr√®s cela, vous pouvez corriger les noms des m√©thodes </font></font><code>Add‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et les rendre g√©n√©raux. </font><font style="vertical-align: inherit;">En cons√©quence, toutes les m√©thodes de triangulation complexes seront trouv√©es </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et les m√©thodes simples pour ajouter des donn√©es au maillage resteront </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'avons pas encore fini. </font><font style="vertical-align: inherit;">Maintenant, il </font></font><code>HexGridChunk.LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait appeler sa propre m√©thode </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En outre, il ne doit plus passer de cellules en argument. </font><font style="vertical-align: inherit;">Par cons√©quent, il </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut perdre son param√®tre. </font><font style="vertical-align: inherit;">Et il doit d√©l√©guer le nettoyage et l'application des donn√©es de maillage </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Triangulate(); <span class="hljs-comment"><span class="hljs-comment">// hexMesh.Triangulate(cells); enabled = false; } public void Triangulate () { terrain.Clear(); // hexMesh.Clear(); // vertices.Clear(); // colors.Clear(); // triangles.Clear(); for (int i = 0; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); // hexMesh.vertices = vertices.ToArray(); // hexMesh.colors = colors.ToArray(); // hexMesh.triangles = triangles.ToArray(); // hexMesh.RecalculateNormals(); // meshCollider.sharedMesh = hexMesh; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez les m√©thodes n√©cessaires </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices.Clear(); colors.Clear(); triangles.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); hexMesh.SetColors(colors); hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); hexMesh.RecalculateNormals(); meshCollider.sharedMesh = hexMesh; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'en est-il de SetVertices, SetColors et SetTriangles?</font></font></b> <div class="spoiler_text">        <code>Mesh</code> .        .  ,           . <br><br>  <code>SetTriangles</code>    integer,    .      ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, attachez manuellement l'enfant du maillage au pr√©fabriqu√© de fragment. </font><font style="vertical-align: inherit;">Nous ne pouvons plus le faire automatiquement, car nous ajouterons bient√¥t un deuxi√®me enfant au maillage. </font><font style="vertical-align: inherit;">Renommez-le en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour indiquer son objectif.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/614/3b4/0dc/6143b40dc88ecec6761348d9e6208944.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attribuez un relief.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renommer un enfant pr√©fabriqu√© ne fonctionne pas?</font></font></b> <div class="spoiler_text">          .    ,   .  ,     <em>Apply</em> ,       .        . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ation de pools de listes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous ayons d√©plac√© un peu de code, notre carte devrait toujours fonctionner de la m√™me mani√®re qu'auparavant. </font><font style="vertical-align: inherit;">L'ajout d'un autre maillage au fragment ne changera rien √† cela. </font><font style="vertical-align: inherit;">Mais si nous faisons cela avec le pr√©sent </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, des erreurs peuvent survenir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le probl√®me est que nous avons suppos√© que nous ne travaillerions qu'avec un maillage √† la fois. </font><font style="vertical-align: inherit;">Cela nous a permis d'utiliser des listes statiques pour stocker des donn√©es de maillage temporaires. </font><font style="vertical-align: inherit;">Mais apr√®s avoir ajout√© de l'eau, nous travaillerons simultan√©ment avec deux mailles, nous ne pourrons donc plus utiliser de listes statiques. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, nous ne reviendrons pas sur les ensembles de listes pour chaque instance </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de cela, nous utilisons un pool de listes statiques. </font><font style="vertical-align: inherit;">Par d√©faut, ce pool n'existe pas, commen√ßons donc par cr√©er nous-m√™mes une classe de pool de liste commune.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListPool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment fonctionne ListPool &lt;T&gt;?</font></font></b> <div class="spoiler_text">     ,  <code>List&lt;int&gt;</code>    .  <code>&lt;T&gt;</code>    <code>ListPool</code> ,  ,    .      ,    <code>T</code> (  template). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour stocker une collection de listes dans un pool, nous pouvons utiliser la pile. </font><font style="vertical-align: inherit;">Je n'utilise g√©n√©ralement pas de listes car Unity ne les s√©rialise pas, mais dans ce cas, cela n'a pas d'importance.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListPool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Stack&lt;List&lt;T&gt;&gt; stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;List&lt;T&gt;&gt;(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que signifie stack &lt;list &lt;t&gt;&gt;?</font></font></b> <div class="spoiler_text">     .  ,     .      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une m√©thode statique commune pour obtenir la liste du pool. </font><font style="vertical-align: inherit;">Si la pile n'est pas vide, nous allons extraire la liste du haut et retourner celle-ci. </font><font style="vertical-align: inherit;">Sinon, nous cr√©erons une nouvelle liste en place.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stack.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stack.Pop(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour r√©utiliser des listes, vous devez les ajouter au pool une fois que vous avez fini de travailler avec elles. </font></font><code>ListPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effacera la liste et la poussera sur la pile.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;T&gt; list</span></span></span><span class="hljs-function">)</span></span> { list.Clear(); stack.Push(list); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons utiliser les piscines dans </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Remplacez les listes statiques par des liens priv√©s non statiques. </font><font style="vertical-align: inherit;">Marquons-les </font></font><code>NonSerialized</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour que Unity ne les conserve pas lors de la recompilation. </font><font style="vertical-align: inherit;">Ou √©crivez </font></font><code>System.NonSerialized</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou ajoutez </font></font><code>using System;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au d√©but du script.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">NonSerialized</span></span>] List&lt;Vector3&gt; vertices; [NonSerialized] List&lt;Color&gt; colors; [NonSerialized] List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles; <span class="hljs-comment"><span class="hljs-comment">// static List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;(); // static List&lt;Color&gt; colors = new List&lt;Color&gt;(); // static List&lt;int&gt; triangles = new List&lt;int&gt;();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puisque le maillage est nettoy√© juste avant d'y ajouter de nouvelles donn√©es, c'est ici que vous devez obtenir les listes des pools. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); colors = ListPool&lt;Color&gt;.Get(); triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s avoir appliqu√© ces maillages, nous n'en avons plus besoin, nous pouvons donc les ajouter ici aux pools. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Add(triangles); hexMesh.RecalculateNormals(); meshCollider.sharedMesh = hexMesh; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous avons donc mis en ≈ìuvre plusieurs utilisations des listes, quel que soit le nombre de mailles que nous remplissons en m√™me temps. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collisionneur en option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que notre terrain ait besoin d'un collisionneur, il n'est pas vraiment n√©cessaire pour les rivi√®res. </font><font style="vertical-align: inherit;">Les rayons traversent simplement l'eau et se croisent avec le canal en dessous. </font><font style="vertical-align: inherit;">Faisons en sorte que nous puissions configurer la pr√©sence d'un collisionneur pour </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous le r√©alisons en ajoutant un champ commun </font></font><code>bool useCollider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour le terrain, nous l'activons.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/f19/a3c/4e7f19a3c7eb01a1432618a8be6903e5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation d'un collisionneur de mailles. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons cr√©er et affecter le collisionneur uniquement lorsqu'il est activ√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCollider) { meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); } hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCollider) { meshCollider.sharedMesh = hexMesh; } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Couleurs en option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les couleurs des sommets peuvent √©galement √™tre facultatives. </font><font style="vertical-align: inherit;">Nous en avons besoin pour d√©montrer diff√©rents types de relief, mais l'eau ne change pas de couleur. </font><font style="vertical-align: inherit;">Nous pouvons les rendre facultatifs tout comme nous avons rendu le collisionneur facultatif.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { colors = ListPool&lt;Color&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bien s√ªr, le terrain doit utiliser les couleurs des sommets, alors activez-les. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/624/c01/bbd/624c01bbda8ad0250747b9c1af852590.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de couleurs.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UV en option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendant ce temps, nous pouvons √©galement ajouter la prise en charge des coordonn√©es UV facultatives. </font><font style="vertical-align: inherit;">Bien que le relief ne les utilise pas, nous en aurons besoin pour l'eau.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates; [NonSerialized] List&lt;Vector2&gt; uvs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { colors = ListPool&lt;Color&gt;.Get(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">0</span></span>, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/a99/559/b01a9955989cdc83a2e8de2582c1cbeb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'utilisons pas de coordonn√©es UV. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour utiliser cette fonction, cr√©ez des m√©thodes pour ajouter des coordonn√©es UV aux triangles et quadrangles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(uv1); uvs.Add(uv2); uvs.Add(uv3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3, Vector3 uv4</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(uv1); uvs.Add(uv2); uvs.Add(uv3); uvs.Add(uv4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutons une m√©thode suppl√©mentaire </font></font><code>AddQuadUV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour ajouter facilement une zone UV rectangulaire. </font><font style="vertical-align: inherit;">C'est le cas standard lorsque le quad et sa texture sont les m√™mes, nous l'utiliserons pour l'eau de la rivi√®re.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMax, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMax</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMin)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMin)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMax)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMax)); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivi√®res actuelles </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, il est temps de cr√©er de l'eau! </font><font style="vertical-align: inherit;">Nous le ferons avec un quad, qui indiquera la surface de l'eau. </font><font style="vertical-align: inherit;">Et puisque nous travaillons avec les rivi√®res, l'eau doit couler. </font><font style="vertical-align: inherit;">Pour ce faire, nous utilisons des coordonn√©es UV indiquant l'orientation de la rivi√®re. </font><font style="vertical-align: inherit;">Pour visualiser cela, nous avons besoin d'un nouveau shader. </font><font style="vertical-align: inherit;">Par cons√©quent, cr√©ez un nouveau shader standard et appelez-le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Modifiez-le pour que les coordonn√©es UV soient enregistr√©es dans les canaux d'alb√©do vert et rouge.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/River" { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez au </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ g√©n√©ral </font></font><code>HexMesh rivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous le nettoyons et l'appliquons de la m√™me mani√®re qu'en cas de relief.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aurons-nous des appels de tirage suppl√©mentaires, m√™me si nous n'avons pas de rivi√®res?</font></font></b> <div class="spoiler_text">  Unity  ,        .     ,  -  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez le pr√©fabriqu√© (via l'instance), dupliquez son objet terrain, renommez-le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et connectez-le.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/0d6/680/efd0d66801d78d636d07f59b34e5c615.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e46/119/b43/e46119b43f4cd398d96261715975a36a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment pr√©fabriqu√© avec rivi√®res. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ez le mat√©riau </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† l' </font><font style="vertical-align: inherit;">aide de notre nouveau shader et faites en sorte que l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers l'</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilise </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous avons √©galement configur√© le composant maillage hexagonal de l'objet afin qu'il utilise les coordonn√©es UV, mais pas les couleurs de sommet ni le collisionneur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7df/db6/134/7dfdb6134b4dc27d843db92492b61708.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sous-objet Rivers.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trianguler l'eau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de pouvoir trianguler l'eau, nous devons d√©terminer le niveau de sa surface. </font><font style="vertical-align: inherit;">Faisons un changement de hauteur </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comme nous l'avons fait avec le lit de la rivi√®re. </font><font style="vertical-align: inherit;">√âtant donn√© que la distorsion verticale de la cellule est √©gale √† la moiti√© du d√©calage de hauteur, utilisons-la pour d√©placer la surface de la rivi√®re. </font><font style="vertical-align: inherit;">Nous garantissons donc que l'eau ne sera jamais au-dessus de la topographie de la cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> riverSurfaceElevationOffset = <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ne pas le faire un peu plus bas?</font></font></b> <div class="spoiler_text">          ,   . ,         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√© pour obtenir la position verticale de la surface de sa rivi√®re.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RiverSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.riverSurfaceElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons travailler </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font><font style="vertical-align: inherit;">Puisque nous allons cr√©er de nombreux quadrilat√®res de rivi√®res, ajoutons une m√©thode distincte pour cela. </font><font style="vertical-align: inherit;">Donnons-lui quatre sommets et une hauteur comme param√®tres. </font><font style="vertical-align: inherit;">Cela nous permettra de d√©finir commod√©ment la position verticale des quatre sommets simultan√©ment avant d'ajouter un quad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = v3.y = v4.y = y; rivers.AddQuad(v1, v2, v3, v4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ajouterons ici les coordonn√©es UV du quadrilat√®re. </font><font style="vertical-align: inherit;">Il suffit de faire le tour de gauche √† droite et de bas en haut.</font></font><br><br><pre> <code class="cs hljs"> rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br> <code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- C'est la premi√®re m√©thode √† laquelle nous ajouterons les quadrangles des rivi√®res. </font><font style="vertical-align: inherit;">Le premier quad se situe entre le centre et le milieu. </font><font style="vertical-align: inherit;">Le second est entre le milieu et la c√¥te. </font><font style="vertical-align: inherit;">Nous utilisons simplement les sommets que nous avons d√©j√†. </font><font style="vertical-align: inherit;">√âtant donn√© que ces pics seront sous-estim√©s, l'eau sera par cons√©quent partiellement sous les parois inclin√©es du canal. </font><font style="vertical-align: inherit;">Par cons√©quent, nous n'avons pas √† nous soucier de la position exacte du bord de l'eau.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateRiverQuad(centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY); TriangulateRiverQuad(m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/418/a40/e9c/418a40e9c73fd3da885ce467e475ff63.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les premiers signes d'eau. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi la largeur de l'eau change-t-elle?</font></font></b> <div class="spoiler_text">  ,     ,      ‚Äî .           .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se d√©placer avec le flux </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actuellement, les coordonn√©es UV ne sont pas coh√©rentes avec la direction de la rivi√®re. </font><font style="vertical-align: inherit;">Nous devons maintenir la coh√©rence ici. </font><font style="vertical-align: inherit;">Supposons que la coordonn√©e U soit 0 sur le c√¥t√© gauche de la rivi√®re et 1 sur la droite, en regardant en aval. </font><font style="vertical-align: inherit;">Et la coordonn√©e V devrait varier de 0 √† 1 en direction de la rivi√®re. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En utilisant cette sp√©cification, les UV seront corrects lors de la triangulation de la rivi√®re sortante, mais ils se r√©v√©leront incorrects et devront √™tre retourn√©s lors de la triangulation de la rivi√®re entrante. </font><font style="vertical-align: inherit;">Pour simplifier le travail, ajoutez au </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param√®tre </font></font><code>bool reversed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Utilisez-le pour retourner les UV si n√©cessaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = v3.y = v4.y = y; rivers.AddQuad(v1, v2, v3, v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous savons que nous devons tourner la direction, lorsqu'il s'agit de rivi√®re entrant.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, reversed ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, reversed );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/546/c86/e9d/546c86e9d2d8752caa30523098283542.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La direction convenue des rivi√®res.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le d√©but et la fin de la rivi√®re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ä l'int√©rieur, </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous devons seulement v√©rifier si nous avons une rivi√®re entrante pour d√©terminer la direction du d√©bit. </font><font style="vertical-align: inherit;">Ensuite, nous pouvons ins√©rer une autre rivi√®re quad entre le milieu et la c√¥te.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, reversed ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La partie entre le centre et le milieu est un triangle, nous ne pouvons donc pas l'utiliser </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La seule diff√©rence significative ici est que le pic central est au milieu de la rivi√®re. </font><font style="vertical-align: inherit;">Par cons√©quent, sa coordonn√©e U est toujours √©gale √† ¬Ω.</font></font><br><br><pre> <code class="cs hljs"> center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c04/07f/539/c0407f539ce2ff6a91081e84062a4097.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'eau au d√©but et √† la fin.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y a-t-il des portions d'eau manquantes aux extr√©mit√©s?</font></font></b> <div class="spoiler_text">       ,   quad  ,     .           .           . <br><br>      ,  .     ,      .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flux entre les cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de l'ajout d'eau entre les cellules, nous devons faire attention √† la diff√©rence de hauteur. </font><font style="vertical-align: inherit;">Pour que l'eau puisse descendre les pentes et les falaises, elle </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit supporter deux param√®tres de hauteur. </font><font style="vertical-align: inherit;">Ajoutons donc un deuxi√®me.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = y1; v3.y = v4.y = y2; rivers.AddQuad(v1, v2, v3, v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aussi, pour plus de commodit√©, ajoutons une option qui recevra une hauteur. </font><font style="vertical-align: inherit;">Il appellera simplement une autre m√©thode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, reversed); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons ajouter quad river et in </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√âtant entre les cellules, nous ne pouvons pas imm√©diatement savoir de quel type de rivi√®re il s'agit. </font><font style="vertical-align: inherit;">Pour d√©terminer si un virage est n√©cessaire, nous devons v√©rifier si nous avons une rivi√®re entrante et si elle se d√©place dans notre direction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/1f2/62e/2831f262ed46e82bebabf45d0a8215f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La rivi√®re termin√©e.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âtirement des coordonn√©es V </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† pr√©sent, dans chaque segment de la rivi√®re, nous avons des coordonn√©es V allant de 0 √† 1. Autrement dit, il n'y en a que quatre sur la cellule. Cinq si l'on ajoute √©galement des connexions entre les cellules. Tout ce que nous utilisons pour texturer la rivi√®re, il doit √™tre r√©p√©t√© autant de fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons r√©duire le nombre de r√©p√©titions en √©tirant les coordonn√©es V pour qu'elles passent de 0 √† 1 dans toute la cellule plus une connexion. Cela peut √™tre fait en augmentant la coordonn√©e V dans chaque segment de 0,2. Si nous mettons 0,4 au centre, au milieu, cela deviendra 0,6 et sur le bord, il atteindra 0,8. Ensuite, dans la connexion de cellule, la valeur sera 1.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la rivi√®re coule dans la direction oppos√©e, nous pouvons toujours mettre 0,4 au centre, mais au milieu, elle devient 0,2, et sur le bord - 0. Si nous continuons jusqu'√† ce que la cellule se rejoigne, nous obtenons -0,2 en cons√©quence. </font><font style="vertical-align: inherit;">Ceci est normal car il est similaire √† 0,8 pour une texture avec mode de filtrage r√©p√©t√©, tout comme 0 √©quivaut √† 1.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22e/4de/cd9/22e4decd99e9c2f0c9312be9eaaceb9a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changement de coordonn√©es V.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour cr√©er un support pour cela, nous devons ajouter </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un param√®tre suppl√©mentaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque la direction n'est pas invers√©e, nous utilisons simplement les coordonn√©es transmises au bas du quadrilat√®re et ajoutons 0,2 en haut. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, v, v + <span class="hljs-number"><span class="hljs-number">0.2f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons travailler avec une direction invers√©e en soustrayant les coordonn√©es de 0,8 et 0,6. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span> - v, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> - v); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous devons transmettre les coordonn√©es correctes, comme s'il s'agissait d'un fleuve sortant. </font><font style="vertical-align: inherit;">Commen√ßons par </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, reversed ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez ensuite </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme suit.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed ); center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44e/786/63f/44e78663f2d77264660f30917a5e1a94.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordonn√©es V √©tir√©es.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour afficher correctement le pliage des coordonn√©es V, assurez-vous qu'elles restent positives dans le shader de la rivi√®re.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y += <span class="hljs-number"><span class="hljs-number">1</span></span>; } o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/30e/a84/aec30ea849af0c8ba42cd6e0cef44635.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordonn√©es </font></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">r√©duites </font></a><i><font style="vertical-align: inherit;">V. </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">package d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Animation fluviale </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir fini avec les coordonn√©es UV, nous pouvons passer √† l'animation des rivi√®res. Le shader de rivi√®re le fera pour que nous n'ayons pas √† mettre √† jour constamment le maillage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne cr√©erons pas de shader de rivi√®re complexe dans ce tutoriel, mais nous le ferons plus tard. Pour l'instant, nous allons cr√©er un effet simple qui permet de comprendre le fonctionnement de l'animation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'animation est cr√©√©e en d√©calant les coordonn√©es V en fonction de l'heure de la partie. Unity vous permet d'obtenir sa valeur √† l'aide d'une variable </font></font><code>_Time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sa composante Y contient le temps inchang√©, que nous utilisons. D'autres composants contiennent des √©chelles de temps diff√©rentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons nous d√©barrasser du pliage le long de V, car nous n'en avons plus besoin. Au lieu de cela, nous soustrayons l'heure actuelle de la coordonn√©e V. Cela d√©place la coordonn√©e vers le bas, ce qui cr√©e l'illusion du courant qui coule en aval de la rivi√®re.</font></font><br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y += <span class="hljs-number"><span class="hljs-number">1</span></span>; // } <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y -= _Time.y; o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En une seconde, la coordonn√©e V √† tous les points deviendra inf√©rieure √† z√©ro, nous ne verrons donc plus la diff√©rence. </font><font style="vertical-align: inherit;">Encore une fois, cela est normal lorsque vous utilisez le filtrage en mode de r√©p√©tition de texture. </font><font style="vertical-align: inherit;">Mais pour voir ce qui se passe, nous pouvons prendre la partie fractionnaire de la coordonn√©e V.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y -= _Time.y; <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y = frac(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y); o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordonn√©es V anim√©es.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisation du bruit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, notre rivi√®re est anim√©e, mais dans le sens et la vitesse, il y a de fortes transitions. </font><font style="vertical-align: inherit;">Notre motif UV les rend assez √©vidents, mais il sera plus difficile √† reconna√Ætre si vous utilisez un motif plus aqueux. </font><font style="vertical-align: inherit;">Ainsi, au lieu d'afficher des UV bruts, √©chantillonnons la texture. </font><font style="vertical-align: inherit;">Nous pouvons utiliser notre texture de bruit existante. </font><font style="vertical-align: inherit;">Nous l'√©chantillons et multiplions la couleur du mat√©riau par le premier canal de bruit.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.y -= _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv); fixed4 c = _Color * noise.r; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attribuez la texture du bruit au mat√©riau de la rivi√®re et assurez-vous qu'elle est blanche. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/dd4/e4e/dc8dd4e4ee9b92f2f104ba3107da30ce.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3f/0ca/319/b3f0ca31928fd594a715868ebbb7265c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de la texture du bruit. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les coordonn√©es V √©tant tr√®s √©tir√©es, la texture du bruit s'√©tend √©galement le long de la rivi√®re. </font><font style="vertical-align: inherit;">Malheureusement, le parcours n'est pas tr√®s beau. </font><font style="vertical-align: inherit;">Essayons de l'√©tirer d'une autre mani√®re - en r√©duisant consid√©rablement l'√©chelle des coordonn√©es de U. Un seizi√®me suffira. </font><font style="vertical-align: inherit;">Cela signifie que nous n'√©chantillonnerons qu'une bande √©troite de texture de bruit.</font></font><br><br><pre> <code class="hljs pgsql"> float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.x *= <span class="hljs-number"><span class="hljs-number">0.0625</span></span>; uv.y -= _Time.y;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/957/2a9/aa99572a9c0ad3daaa7b5b4eb3978cc0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtirement de la coordonn√©e U.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ralentissons √©galement √† un quart par seconde pour que l'ach√®vement du cycle de texture prenne quatre secondes.</font></font><br><br><pre> <code class="hljs"> uv.y -= _Time.y * 0.25;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le bruit actuel.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©lange de bruit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout semble d√©j√† beaucoup mieux, mais le motif reste toujours le m√™me. L'eau ne se comporte pas comme √ßa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous n'utilisons qu'une petite bande de bruit, nous pouvons faire varier le motif en d√©calant cette bande le long de la texture. Cela se fait en ajoutant du temps √† la coordonn√©e U. Nous devons le faire lentement, sinon la rivi√®re semblera couler lat√©ralement. Essayons le coefficient de 0,005. Cela signifie qu'il faut 200 secondes pour terminer le motif.</font></font><br><br><pre> <code class="hljs markdown"> uv.x = uv.x <span class="hljs-bullet"><span class="hljs-bullet">* 0.0625 + _Time.y *</span></span> 0.005;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bruit en mouvement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, cela n'a pas l'air tr√®s beau. </font><font style="vertical-align: inherit;">L'eau semble toujours statique et le changement est clairement perceptible, bien qu'il soit tr√®s lent. </font><font style="vertical-align: inherit;">Nous pouvons masquer le d√©calage en combinant deux √©chantillons de bruit et en les d√©calant dans des directions oppos√©es. </font><font style="vertical-align: inherit;">Et si nous utilisons des valeurs l√©g√®rement diff√©rentes pour d√©placer le deuxi√®me √©chantillon, nous cr√©erons une animation l√©g√®re du changement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De sorte que, par cons√©quent, nous ne chevauchons jamais le m√™me motif de bruit, nous utilisons un canal diff√©rent pour le deuxi√®me √©chantillon.</font></font><br><br><pre> <code class="hljs pgsql"> float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.x = uv.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> + _Time.y * <span class="hljs-number"><span class="hljs-number">0.005</span></span>; uv.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv); float2 uv2 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv2.x = uv2.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> - _Time.y * <span class="hljs-number"><span class="hljs-number">0.0052</span></span>; uv2.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.23</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(_MainTex, uv2); fixed4 c = _Color * (noise.r * noise2.a);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une combinaison de deux mod√®les de bruit changeant.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eau translucide </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre mod√®le semble assez dynamique. </font><font style="vertical-align: inherit;">L'√©tape suivante consiste √† le rendre translucide. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, assurez-vous que l'eau ne projette pas d'ombres. </font><font style="vertical-align: inherit;">Vous pouvez les d√©sactiver via le composant de rendu de l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le pr√©fabriqu√©.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a61/894/e14/a61894e14d9999315d59b5ff0c0de517.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La projection d'ombres est d√©sactiv√©e. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basculez maintenant le shader en mode transparent. </font><font style="vertical-align: inherit;">Pour indiquer cela, utilisez des balises shader. </font><font style="vertical-align: inherit;">Ajoutez ensuite le </font></font><code>#pragma surface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mot </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">cl√© </font><font style="vertical-align: inherit;">√† la ligne </font></font><code>alpha</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pendant que nous sommes ici, vous pouvez supprimer le mot-cl√© </font></font><code>fullforwardshadows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car nous ne projetons toujours pas d'ombres.</font></font><br><br><pre> <code class="hljs cs"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard alpha // fullforwardshadows #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.0</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous allons changer la fa√ßon dont nous d√©finissons la couleur de la rivi√®re. </font><font style="vertical-align: inherit;">Au lieu de multiplier le bruit par la couleur, nous y ajouterons du bruit. </font><font style="vertical-align: inherit;">Ensuite, nous utilisons la fonction </font></font><code>saturate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour limiter le r√©sultat afin qu'il ne d√©passe pas 1.</font></font><br><br><pre> <code class="hljs swift"> fixed4 <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = saturate(_Color + noise.r * noise2.a);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela nous permettra d'utiliser la couleur du mat√©riau comme couleur de base. </font><font style="vertical-align: inherit;">Le bruit augmentera sa luminosit√© et son opacit√©. </font><font style="vertical-align: inherit;">Essayons d'utiliser une couleur bleue avec une opacit√© assez faible. </font><font style="vertical-align: inherit;">En cons√©quence, nous obtenons de l'eau translucide bleue avec des √©claboussures blanches.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/3f7/5a1/af83f75a143aabdd3b83525e4114fc3b.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eau translucide color√©e. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ach√®vement </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que tout semble fonctionner, il est temps de d√©former √† nouveau les pics. </font><font style="vertical-align: inherit;">En plus de d√©former les bords des cellules, cela rendra nos rivi√®res in√©gales.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c8/ff5/96b/8c8ff596bc247be79a30122e49ca27f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ca/664/808/6ca66480859e94d00e2e558caa17cbf4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pics d√©form√©s et d√©form√©s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinons le terrain pour les probl√®mes qui sont survenus en raison de la distorsion. </font><font style="vertical-align: inherit;">On dirait qu'ils sont! </font><font style="vertical-align: inherit;">Voyons les grandes cascades.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df1/95b/a33/df195ba33947744e97173412373f5ad4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eau tronqu√©e par des falaises.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'eau qui tombe d'une haute cascade dispara√Æt derri√®re une falaise. Lorsque cela se produit, c'est tr√®s visible, nous devons donc faire quelque chose. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beaucoup moins √©vident est que les chutes d'eau peuvent √™tre en pente, plut√¥t que de descendre directement vers le bas. Bien qu'en r√©alit√© l'eau ne coule pas comme √ßa, elle n'est pas particuli√®rement visible. Notre cerveau va l'interpr√©ter de telle mani√®re qu'il nous semble normal. Alors ignorez-le. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fa√ßon la plus simple d'√©viter la perte d'eau est d'approfondir les lits des rivi√®res. Nous allons donc cr√©er plus d'espace entre la surface de l'eau et le lit de la rivi√®re. Cela rendra √©galement les parois du canal plus verticales, alors n'allez pas trop loin. Demandons</font></font><code>HexMetrics.streamBedElevationOffset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur -1,75. </font><font style="vertical-align: inherit;">Cela r√©soudra la majeure partie des probl√®mes et le lit ne deviendra pas trop profond. </font><font style="vertical-align: inherit;">Une partie de l'eau sera toujours coup√©e, mais pas la totalit√© des cascades.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> streamBedElevationOffset = <span class="hljs-number"><span class="hljs-number">-1.75f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/80c/d26/57b80cd2687ff6afb9be83176e984b7d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canaux approfondis. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 7: routes </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez un support routier. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulez la route. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous combinons routes et rivi√®res. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Am√©lioration de l'apparence des routes. </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f7/b24/05e/9f7b2405e5ceed9842cc1ebd7b549b0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les premiers signes de civilisation.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cellules avec routes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme les rivi√®res, les routes vont de cellule en cellule, au milieu des bords de la cellule. </font><font style="vertical-align: inherit;">La grande diff√©rence est qu'il n'y a pas d'eau qui coule sur les routes, donc elles sont bidirectionnelles. </font><font style="vertical-align: inherit;">De plus, des intersections sont n√©cessaires pour un r√©seau routier fonctionnel, nous devons donc prendre en charge plus de deux routes par cellule. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous autorisez les routes √† aller dans les six directions, la cellule peut contenir de z√©ro √† six routes. </font><font style="vertical-align: inherit;">C'est un total de quatorze configurations de routes possibles. </font><font style="vertical-align: inherit;">Cela repr√©sente bien plus de cinq configurations de rivi√®re possibles. </font><font style="vertical-align: inherit;">Pour g√©rer cela, nous devons utiliser une approche plus g√©n√©rale qui peut g√©rer toutes les configurations.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/965/5b7/d469655b7efdbab33a6cac1c42e61a7e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14 configurations de routes possibles.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi routier </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le moyen le plus simple de suivre les routes dans une cellule est d'utiliser un tableau de valeurs bool√©ennes. </font><font style="vertical-align: inherit;">Ajoutez le champ priv√© du tableau √† </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et rendez-le s√©rialisable pour que vous puissiez le voir dans l'inspecteur. </font><font style="vertical-align: inherit;">D√©finissez la taille du tableau via le pr√©fabriqu√© de cellule afin qu'il prenne en charge six routes.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] roads;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/439/167/2c4/4391672c4c1de9075138eef3f1cafd73.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cellule pr√©fabriqu√©e √† six routes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une m√©thode pour v√©rifier si la cellule a un chemin dans une certaine direction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasRoadThroughEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il sera √©galement pratique de savoir s'il y a au moins une route dans la cellule, nous allons donc ajouter une propri√©t√© pour cela. </font><font style="vertical-align: inherit;">Il suffit de faire le tour du tableau dans la boucle et de revenir </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√®s que nous trouvons le chemin. </font><font style="vertical-align: inherit;">S'il n'y a pas de routes, revenez </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRoads { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enl√®vement de route </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme pour les rivi√®res, nous ajouterons une m√©thode pour supprimer toutes les routes de la cellule. </font><font style="vertical-align: inherit;">Cela peut √™tre fait avec une boucle qui d√©connecte chaque route qui √©tait pr√©c√©demment activ√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRoads</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bien s√ªr, nous devons √©galement d√©sactiver les cellules co√ªteuses correspondantes chez les voisins. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)i).Opposite()] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s cela, nous devons mettre √† jour chacune des cellules. </font><font style="vertical-align: inherit;">√âtant donn√© que les routes sont locales aux cellules, nous devons mettre √† jour uniquement les cellules elles-m√™mes sans leurs voisins.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)i).Opposite()] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].RefreshSelfOnly(); RefreshSelfOnly(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajout de routes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ajout de routes est similaire √† la suppression de routes. </font><font style="vertical-align: inherit;">La seule diff√©rence est que nous attribuons une valeur √† Boolean </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, non </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous pouvons cr√©er une m√©thode priv√©e qui peut effectuer les deux op√©rations. </font><font style="vertical-align: inherit;">Ensuite, il sera possible de l'utiliser √† la fois pour ajouter et supprimer la route.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRoads</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { SetRoad(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { roads[index] = state; neighbors[index].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)index).Opposite()] = state; neighbors[index].RefreshSelfOnly(); RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne pouvons pas avoir √† la fois une rivi√®re et une route allant dans la m√™me direction en m√™me temps. </font><font style="vertical-align: inherit;">Par cons√©quent, avant d'ajouter la route, nous v√©rifierons s'il y a une place pour celle-ci.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction)) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, les routes ne peuvent pas √™tre combin√©es avec des falaises car elles sont trop tranchantes. </font><font style="vertical-align: inherit;">Ou peut-√™tre qu'il vaut la peine d'ouvrir la voie √† travers une falaise basse, mais pas √† travers une haute? </font><font style="vertical-align: inherit;">Pour le d√©terminer, nous devons cr√©er une m√©thode qui nous indique la diff√©rence de hauteur dans une certaine direction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetElevationDifference</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> difference = elevation - GetNeighbor(direction).elevation; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> difference &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? difference : -difference; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons ajouter des routes √† une diff√©rence de hauteur suffisamment petite. </font><font style="vertical-align: inherit;">Je ne me limiterai qu'aux pentes, c'est-√†-dire au maximum 1 unit√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction) &amp;&amp; GetElevationDifference(direction) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Supprimer les mauvaises routes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons ajout√© des routes uniquement lorsque cela est autoris√©. </font><font style="vertical-align: inherit;">Maintenant, nous devons nous assurer qu'ils sont supprim√©s s'ils deviennent incorrects ult√©rieurement, par exemple, lors de l'ajout d'une rivi√®re. </font><font style="vertical-align: inherit;">Nous pouvons interdire le placement de rivi√®res au-dessus des routes, mais les rivi√®res ne sont pas interrompues par des routes. </font><font style="vertical-align: inherit;">Laissez-les nettoyer la route. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il nous suffira de demander la route </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qu'elle soit ou non. </font><font style="vertical-align: inherit;">Il y aura toujours mis √† </font><font style="vertical-align: inherit;">jour les </font><font style="vertical-align: inherit;">deux cellules, donc on n'a plus besoin d'appeler explicitement </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans </font></font><code>SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } HexCell neighbor = GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || elevation &lt; neighbor.elevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } RemoveOutgoingRiver(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasIncomingRiver &amp;&amp; incomingRiver == direction) { RemoveIncomingRiver(); } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; <span class="hljs-comment"><span class="hljs-comment">// RefreshSelfOnly(); neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = true; neighbor.incomingRiver = direction.Opposite(); // neighbor.RefreshSelfOnly(); SetRoad((int)direction, false); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre op√©ration qui peut fausser la route est un changement de hauteur. </font><font style="vertical-align: inherit;">Dans ce cas, nous devrons v√©rifier les routes dans toutes les directions. </font><font style="vertical-align: inherit;">Si la diff√©rence de hauteur est trop importante, la route existante doit √™tre supprim√©e.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i] &amp;&amp; GetElevationDifference((HexDirection)i) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { SetRoad(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } Refresh(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edition de route </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La modification des routes fonctionne comme la modification des rivi√®res. </font><font style="vertical-align: inherit;">Par cons√©quent </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un commutateur suppl√©mentaire est requis, ainsi qu'une m√©thode pour d√©finir son √©tat.</font></font><br><br><pre> <code class="cs hljs"> OptionalToggle riverMode, roadMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRiverMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { riverMode = (OptionalToggle)mode; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRoadMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { roadMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La m√©thode </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait maintenant prendre en charge la suppression avec l'ajout de routes. </font><font style="vertical-align: inherit;">Cela signifie que lors d'un glisser-d√©poser, il peut effectuer l'une des deux actions possibles. </font><font style="vertical-align: inherit;">Nous restructurons un peu le code afin que lors de l'ex√©cution du glisser-d√©poser correct, les √©tats des deux commutateurs soient v√©rifi√©s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.No) { cell.RemoveRoads(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag) { HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.Yes) { otherCell.SetOutgoingRiver(dragDirection); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.Yes) { otherCell.AddRoad(dragDirection); } } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons rapidement ajouter une barre de route √† l'interface utilisateur en copiant la barre de la rivi√®re et en changeant la m√©thode appel√©e par les commutateurs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En cons√©quence, nous obtenons une interface utilisateur assez √©lev√©e. </font><font style="vertical-align: inherit;">Pour r√©soudre ce probl√®me, j'ai chang√© la disposition des panneaux de couleur pour l'adapter aux panneaux de route et de rivi√®re plus compacts.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fd/de5/a8a/0fdde5a8a4abc86308b771f43b36bf4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI avec des routes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis maintenant, j'utilise deux lignes de trois options pour les couleurs, il y a de la place pour une autre couleur. </font><font style="vertical-align: inherit;">J'ai donc ajout√© un √©l√©ment pour l'orange.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/9c6/08d/a069c608dfe531a5e1b2a8c59fef5846.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/12a/499/e9612a49993e3a2d4cb20790186ecf02.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cinq couleurs: jaune, vert, bleu, orange et blanc. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant modifier les routes, mais jusqu'√† pr√©sent, elles ne sont pas visibles. </font><font style="vertical-align: inherit;">Vous pouvez utiliser l'inspecteur pour vous assurer que tout fonctionne.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/160/c4f/0e4/160c4f0e496acec2a2a2d739152a7cfa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cellule avec routes dans l'inspecteur. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation routi√®re </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour afficher les routes, vous devez les trianguler. </font><font style="vertical-align: inherit;">Cela revient √† cr√©er un maillage pour les rivi√®res, seul le lit de la rivi√®re n'appara√Ætra pas dans le relief. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, cr√©ez un nouveau shader standard qui utilisera √† nouveau les coordonn√©es UV pour peindre la surface de la route.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/Road" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = fixed4(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cr√©ez un mat√©riau routier √† l'aide de ce shader. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/9e3/2b8/9739e32b82ad2148c559b8f7c4caa868.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Route mat√©rielle. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©finissez le pr√©fabriqu√© du fragment afin qu'il re√ßoive un autre maillage enfant d'hexagones pour les routes. </font><font style="vertical-align: inherit;">Ce maillage ne doit pas projeter d'ombres et doit utiliser uniquement des coordonn√©es UV. </font><font style="vertical-align: inherit;">Le moyen le plus rapide de le faire consiste √† utiliser une instance pr√©fabriqu√©e - dupliquez l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et remplacez son mat√©riau.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/476/a9e/bf8476a9e950a13c69051a5cd43480c1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a64/4d8/776/a644d8776f3c6f0ba64cf3aef666f475.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes d'objets enfants. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s cela, ajoutez au </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ g√©n√©ral </font></font><code>HexMesh roads</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et incluez-le dans </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Connectez-le dans l'inspecteur avec l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a95/c0e/c2a/a95c0ec2ae59dccbb249e6a02ccdc7c5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'objet Roads est connect√©.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Routes entre les cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons d'abord les segments de route entre les cellules. </font><font style="vertical-align: inherit;">Comme les rivi√®res, les routes sont ferm√©es par deux quadruples moyens. </font><font style="vertical-align: inherit;">Nous couvrons compl√®tement ces quadrangles de connexion avec les quadrangles routiers afin que les positions des m√™mes six pics puissent √™tre utilis√©es. </font><font style="vertical-align: inherit;">Ajoutez pour cela √† la </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©thode </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6 </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous n'avons plus √† nous soucier du d√©bit d'eau, la coordonn√©e V n'est pas n√©cessaire, nous lui affectons donc la valeur 0 partout. Nous pouvons utiliser la coordonn√©e U pour indiquer si nous sommes au milieu de la route ou sur le c√¥t√©. </font><font style="vertical-align: inherit;">Soit √©gal √† 1 au milieu et √©gal √† 0 des deux c√¥t√©s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6 </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26a/730/868/26a73086896099b06098de0a25eb63ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un segment de la route entre les cellules. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il serait logique d'appeler cette m√©thode </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais seulement s'il y a vraiment une route. </font><font style="vertical-align: inherit;">Ajoutez un param√®tre bool√©en √† la m√©thode pour transmettre ces informations.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, nous allons maintenant recevoir des erreurs de compilation, car jusqu'√† pr√©sent, ces informations n'ont pas encore √©t√© transmises. </font><font style="vertical-align: inherit;">Comme dernier argument dans tous les cas, l'appel </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut √™tre ajout√© </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cependant, nous pouvons √©galement d√©clarer que la valeur par d√©faut de ce param√®tre est √©gale </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour cette raison, le param√®tre deviendra facultatif et les erreurs de compilation dispara√Ætront.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment fonctionnent les param√®tres facultatifs?</font></font></b> <div class="spoiler_text">        ,   . ,  <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; }</code> </pre> <br>    <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyMethod(x, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyMethod(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; }</code> </pre> <br>   .      .    .      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour trianguler la route, il suffit d'appeler </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec les six pics du milieu, si n√©cessaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est ainsi que nous g√©rons les connexions √† cellules plates. </font><font style="vertical-align: inherit;">Pour soutenir les routes sur les rebords, nous devons √©galement indiquer </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o√π la route doit √™tre ajout√©e. </font><font style="vertical-align: inherit;">Il peut simplement transmettre ces informations </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.Color, endCell.Color, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, beginCell.Color, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(beginCell.Color, endCell.Color, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, endCell.Color, hasRoad); }</code> </pre> <br> <code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appel√© √† l'int√©rieur </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C'est ici que nous pouvons d√©terminer s'il existe r√©ellement une route allant dans la direction actuelle, √† la fois lors de la triangulation d'une ar√™te et lors de la triangulation des rebords.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces( e1, cell, e2, neighbor, cell.HasRoadThroughEdge(direction) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip( e1, cell.Color, e2, neighbor.Color, cell.HasRoadThroughEdge(direction) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7a/67d/e7d/d7a67de7d2edeb2d23b63e9b37bc7508.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segments de route entre les cellules.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cellule sur le rendu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous dessinez des routes, vous verrez que des segments de route apparaissent entre les cellules. Le milieu de ces segments sera violet avec une transition vers le bleu sur les bords. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, lorsque vous d√©placez la cam√©ra, les segments peuvent scintiller et parfois dispara√Ætre compl√®tement. En effet, les triangles des routes chevauchent exactement les triangles de terrain. Les triangles pour le rendu sont s√©lectionn√©s au hasard. Ce probl√®me peut √™tre r√©solu en deux √©tapes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Premi√®rement, nous voulons dessiner les routes apr√®s le trac√© du relief. Ceci peut √™tre r√©alis√© en les rendant apr√®s avoir rendu la g√©om√©trie habituelle, c'est-√†-dire en les pla√ßant dans une file d'attente de rendu ult√©rieure.</font></font><br><br><pre> <code class="hljs objectivec"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Geometry+1"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxi√®mement, nous devons nous assurer que les routes sont trac√©es sur des triangles de terrain dans la m√™me position. </font><font style="vertical-align: inherit;">Cela peut √™tre fait en ajoutant le d√©calage du test de profondeur. </font><font style="vertical-align: inherit;">Cela permettra au GPU de supposer que les triangles sont plus proches de la cam√©ra qu'ils ne le sont r√©ellement.</font></font><br><br><pre> <code class="hljs powershell"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Geometry+1"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> Offset <span class="hljs-literal"><span class="hljs-literal">-1</span></span>, <span class="hljs-literal"><span class="hljs-literal">-1</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Routes √† travers les cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la triangulation des rivi√®res, nous n'avons pas eu √† traiter plus de deux directions de rivi√®re par cellule. Nous pourrions identifier cinq options possibles et les trianguler diff√©remment pour cr√©er les rivi√®res qui paraissent correctes. Cependant, dans le cas des routes, il y a quatorze options possibles. Nous n'utiliserons pas d'approches distinctes pour chacune de ces options. Au lieu de cela, nous traiterons chacune des six directions de cellule de la m√™me mani√®re, quelle que soit la configuration de route sp√©cifique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'une route passe le long d'une partie de la cellule, nous la tracerons directement au centre de la cellule, sans quitter la zone de triangles. Nous allons dessiner un segment de la route du bord √† la moiti√© en direction du centre. Ensuite, nous utilisons deux triangles pour fermer le reste au centre.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df0/659/a13/df0659a13206731d401579ba8c7f3b8f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulation d'une partie de la route. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour trianguler ce sch√©ma, nous devons conna√Ætre le centre de la cellule, les sommets du milieu gauche et droit et les sommets du bord. </font><font style="vertical-align: inherit;">Ajoutez une m√©thode </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec les param√®tres appropri√©s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour construire un segment de route, nous avons besoin d'un pic suppl√©mentaire. </font><font style="vertical-align: inherit;">Il est situ√© entre les pics m√©dians gauche et droit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, nous pouvons √©galement ajouter les deux triangles restants. </font></font><br><br><pre> <code class="cs hljs"> TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons √©galement ajouter les coordonn√©es UV des triangles. </font><font style="vertical-align: inherit;">Deux de leurs sommets sont au milieu de la route, et le reste est sur le bord.</font></font><br><br><pre> <code class="cs hljs"> roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour l'instant, confinons-nous aux cellules dans lesquelles il n'y a pas de rivi√®res. </font><font style="vertical-align: inherit;">Dans ces cas, cela </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cr√©e simplement un √©ventail de triangles. </font><font style="vertical-align: inherit;">D√©placez ce code vers une m√©thode distincte. </font><font style="vertical-align: inherit;">Ensuite, nous ajoutons un appel </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque la route est r√©ellement. </font><font style="vertical-align: inherit;">Les sommets du milieu gauche et droit peuvent √™tre trouv√©s par interpolation entre le centre et deux sommets d'angle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithoutRiver(direction, cell, center, e); } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { TriangulateRoad( center, Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), e ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29d/ae4/def/29dae4def1f841ae190e64b267f6e4ea.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes traversant les cellules.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√¥tes de route </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons voir les routes, mais plus pr√®s du centre des cellules, elles se r√©tr√©cissent. Comme nous ne v√©rifions pas laquelle des quatorze options que nous traitons, nous ne pouvons pas d√©placer le centre de la route pour cr√©er des formes plus belles. Au lieu de cela, nous pouvons ajouter des bords de route suppl√©mentaires dans d'autres parties de la cellule. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque les routes traversent la cellule, mais pas dans la direction actuelle, nous ajouterons un triangle aux bords de la route. Ce triangle est d√©fini par les sommets centraux central, gauche et droit. Dans ce cas, seul le pic central se situe au milieu de la route. Les deux autres se trouvent sur sa c√¥te.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, Vector3 mL, Vector3 mR</span></span></span><span class="hljs-function">)</span></span> { roads.AddTriangle(center, mL, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/293/6ec/bd12936ec0833f7d7da4e038158bb167.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une partie du bord de la route. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous devons trianguler une route pleine ou juste un bord, nous devons la laisser pour </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour ce faire, cette m√©thode doit savoir si la route passe par la direction du bord de cellule actuel. </font><font style="vertical-align: inherit;">Par cons√©quent, nous ajoutons un param√®tre pour cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoadThroughCellEdge </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoadThroughCellEdge) { Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateRoadEdge(center, mL, mR); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il devra appeler </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque des routes traverseront la cellule. </font><font style="vertical-align: inherit;">Et il devra transmettre des informations pour savoir si la route passe par le bord actuel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { TriangulateRoad( center, Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), e, cell.HasRoadThroughEdge(direction) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89e/f99/1a0/89ef991a0790911d140b68b1457fb9df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes avec nervures termin√©es.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lissage des routes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les routes sont maintenant termin√©es. </font><font style="vertical-align: inherit;">Malheureusement, cette approche cr√©e des renflements au centre des cellules. </font><font style="vertical-align: inherit;">Placer les pics gauche et droit au milieu entre le centre et les coins nous convient quand il y a une route √† c√¥t√© d'eux. </font><font style="vertical-align: inherit;">Mais si ce n'est pas le cas, il y a un renflement. </font><font style="vertical-align: inherit;">Pour √©viter cela, dans de tels cas, nous pouvons placer les sommets plus pr√®s du centre. </font><font style="vertical-align: inherit;">Plus pr√©cis√©ment, puis interpoler avec ¬º, pas avec ¬Ω. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ons une m√©thode distincte pour d√©terminer les interpolateurs √† utiliser. </font><font style="vertical-align: inherit;">Puisqu'il y en a deux, nous pouvons mettre le r√©sultat </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Son composant X sera l'interpolateur du point gauche, et le composant Y sera l'interpolateur du point droit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S'il y a une route dans la direction actuelle, nous pouvons placer les points au milieu. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { interpolators.x = interpolators.y = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinon, les options peuvent √™tre diff√©rentes. </font><font style="vertical-align: inherit;">Pour le point de gauche, nous pouvons utiliser ¬Ω s'il y a une route qui va dans la direction pr√©c√©dente. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, nous devons utiliser ¬º. </font><font style="vertical-align: inherit;">La m√™me chose s'applique au bon point, mais en tenant compte de la direction suivante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { interpolators.x = interpolators.y = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { interpolators.x = cell.HasRoadThroughEdge(direction.Previous()) ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; interpolators.y = cell.HasRoadThroughEdge(direction.Next()) ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez maintenant utiliser cette nouvelle m√©thode pour d√©terminer quels interpolateurs sont utilis√©s. </font><font style="vertical-align: inherit;">Gr√¢ce √† cela, les routes seront liss√©es.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { Vector2 interpolators = GetRoadInterpolators(direction, cell); TriangulateRoad( center, Vector3.Lerp(center, e.v1, interpolators.x), Vector3.Lerp(center, e.v5, interpolators.y), e, cell.HasRoadThroughEdge(direction) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c9/d0b/d12/3c9d0bd1262c2d47a3efc2d300212efd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84c/5fa/4f8/84c5fa4f8ef27bd4f6d294d0bf50acf6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes lisses. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La combinaison des rivi√®res et des routes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au stade actuel, nous avons des routes fonctionnelles, mais seulement s'il n'y a pas de rivi√®res. </font><font style="vertical-align: inherit;">S'il y a une rivi√®re dans la cellule, les routes ne seront pas triangul√©es.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5e/76f/814/f5e76f814407359057d0c1bb1688988c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a pas de routes pr√®s des rivi√®res. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cr√©ons une m√©thode </font></font><code>TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour g√©rer cette situation. </font><font style="vertical-align: inherit;">Nous le r√©glons sur les param√®tres habituels. </font><font style="vertical-align: inherit;">Nous l'appellerons au d√©but de la m√©thode </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { TriangulateRoadAdjacentToRiver(direction, cell, center, e); } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour commencer, nous ferons de m√™me que pour les routes sans rivi√®res. </font><font style="vertical-align: inherit;">Nous v√©rifierons si la route passe par le bord actuel, obtiendrons des interpolateurs, cr√©erons des pics moyens et appellerons </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais comme les rivi√®res appara√Ætront sur le chemin, nous devons en √©loigner les routes. </font><font style="vertical-align: inherit;">Par cons√©quent, le centre de la route sera dans une position diff√©rente. </font><font style="vertical-align: inherit;">Nous utilisons une variable pour stocker cette nouvelle position </font></font><code>roadCenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Initialement, il sera √©gal au centre de la cellule.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons donc cr√©er des routes partielles dans des cellules avec des rivi√®res. </font><font style="vertical-align: inherit;">Les directions par lesquelles les rivi√®res passent couperont les lacunes des routes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/029/595/95e0295954967415965a3992ffd91882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes avec espaces.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D√©but ou fin de la rivi√®re </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinons d'abord les cellules contenant le d√©but ou la fin d'une rivi√®re. </font><font style="vertical-align: inherit;">Pour que les routes ne se chevauchent pas avec de l'eau, √©loignons le centre de la route de la rivi√®re. </font><font style="vertical-align: inherit;">Pour obtenir la direction de la rivi√®re entrante ou sortante, ajoutez la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propri√©t√©.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection RiverBeginOrEndDirection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver ? incomingRiver : outgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons utiliser cette propri√©t√© </font></font><code>HexGridChunk.TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour d√©placer le centre de la route dans la direction oppos√©e. </font><font style="vertical-align: inherit;">Il suffira de d√©placer un tiers vers la c√¥te m√©diane dans cette direction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/12b/280/f1812b2807add77e4d173b85ad65e4da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes modifi√©es. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous devons combler les lacunes. </font><font style="vertical-align: inherit;">Nous le ferons en ajoutant des triangles suppl√©mentaires aux bords de la route lorsque nous serons pr√®s de la rivi√®re. </font><font style="vertical-align: inherit;">S'il y a une rivi√®re dans la direction pr√©c√©dente, alors nous ajoutons un triangle entre le centre de la route, le centre de la cellule et le point central gauche. </font><font style="vertical-align: inherit;">Et si la rivi√®re est dans la direction suivante, alors nous ajoutons un triangle entre le centre de la route, le point milieu droit et le centre de la cellule. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous le ferons quelle que soit la configuration de la rivi√®re, alors mettez ce code √† la fin de la m√©thode.</font></font><br><br><pre> <code class="cs hljs"> Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { TriangulateRoadEdge(roadCenter, center, mL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { TriangulateRoadEdge(roadCenter, mR, center); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous ne pouvez pas utiliser l'instruction else?</font></font></b> <div class="spoiler_text">      .   ,     . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93d/485/bc8/93d485bc8072e6fa8471fb98d084467a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes pr√™tes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivi√®res droites </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cellules avec des rivi√®res droites sont particuli√®rement difficiles car elles divisent essentiellement le centre de la cellule en deux. </font><font style="vertical-align: inherit;">Nous ajoutons d√©j√† des triangles suppl√©mentaires pour combler les lacunes entre les rivi√®res, mais nous devons √©galement d√©connecter les routes sur les c√¥t√©s oppos√©s de la rivi√®re.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab6/203/055/ab62030558305530ed4aed038669ba9c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes chevauchant une rivi√®re droite. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la cellule n'a pas le d√©but ou la fin de la rivi√®re, nous pouvons v√©rifier si les rivi√®res entrantes et sortantes vont dans des directions oppos√©es. </font><font style="vertical-align: inherit;">Si oui, alors nous avons une rivi√®re directe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour d√©terminer o√π la rivi√®re est par rapport √† la direction actuelle, nous devons v√©rifier les directions voisines. </font><font style="vertical-align: inherit;">La rivi√®re est √† gauche ou √† droite. </font><font style="vertical-align: inherit;">Puisque nous le faisons √† la fin de la m√©thode, nous mettons en cache ces requ√™tes dans des variables bool√©ennes. </font><font style="vertical-align: inherit;">Cela simplifiera √©galement la lecture de notre code.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> previousHasRiver = cell.HasRiverThroughEdge(direction.Previous()); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> nextHasRiver = cell.HasRiverThroughEdge(direction.Next()); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { } } Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { TriangulateRoadEdge(roadCenter, center, mL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { TriangulateRoadEdge(roadCenter, mR, center); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons d√©placer le centre de la route vers un vecteur angulaire pointant dans la direction oppos√©e √† la rivi√®re. </font><font style="vertical-align: inherit;">Si la rivi√®re passe par la direction pr√©c√©dente, c'est le deuxi√®me angle solide. </font><font style="vertical-align: inherit;">Sinon, c'est le premier angle solide.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { Vector3 corner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { corner = HexMetrics.GetFirstSolidCorner(direction); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour d√©placer la route de mani√®re √† ce qu'elle soit adjacente √† la rivi√®re, nous devons d√©placer le centre de la route de la moiti√© de la distance jusqu'√† ce coin. </font><font style="vertical-align: inherit;">Ensuite, nous devons √©galement d√©placer le centre de la cellule d'un quart de la distance dans cette direction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { Vector3 corner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { corner = HexMetrics.GetFirstSolidCorner(direction); } roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/6bf/85b/e4c6bf85b3120697996ad75a3256a3a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes divis√©es. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons partag√© un r√©seau de routes √† l'int√©rieur de cette cellule. </font><font style="vertical-align: inherit;">C'est normal lorsque les routes sont des deux c√¥t√©s de la rivi√®re. </font><font style="vertical-align: inherit;">Mais si d'un c√¥t√© il n'y a pas de route, alors nous aurons un petit morceau de route isol√©e. </font><font style="vertical-align: inherit;">C'est illogique, alors d√©barrassons-nous de ces parties. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assurez-vous qu'il y a une route qui va dans la direction actuelle. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, v√©rifiez dans l'autre sens du m√™me c√¥t√© de la rivi√®re la pr√©sence de la route. </font><font style="vertical-align: inherit;">S'il n'y a pas de route de passage l√† ou l√†, alors on quitte la m√©thode avant de trianguler.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !hasRoadThroughEdge &amp;&amp; !cell.HasRoadThroughEdge(direction.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !hasRoadThroughEdge &amp;&amp; !cell.HasRoadThroughEdge(direction.Previous()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } corner = HexMetrics.GetFirstSolidCorner(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/398/532/09e398532543dcd7f78987c23e012571.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes tronqu√©es.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et les ponts?</font></font></b> <div class="spoiler_text">     .         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivi√®res en zigzag </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le prochain type de rivi√®re est le zigzag. </font><font style="vertical-align: inherit;">Ces rivi√®res ne partagent pas le r√©seau routier, il nous suffit donc de d√©placer le centre de la route.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/851/29b/f56/85129bf56e4948296b17916094fd9d8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zigzags traversant les routes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fa√ßon la plus simple de v√©rifier les zigzags est de comparer les directions des rivi√®res entrantes et sortantes. </font><font style="vertical-align: inherit;">S'ils sont adjacents, alors nous avons un zigzag. </font><font style="vertical-align: inherit;">Cela conduit √† deux options possibles, selon le sens de l'√©coulement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Previous()) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons d√©placer le centre de la route en utilisant l'un des coins de la direction de la rivi√®re entrante. </font><font style="vertical-align: inherit;">L'angle que vous s√©lectionnez d√©pend de la direction du flux. </font><font style="vertical-align: inherit;">D√©placez le centre de la route de cet angle avec un facteur de 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Previous()) { roadCenter -= HexMetrics.GetSecondCorner(cell.IncomingRiver) * <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { roadCenter -= HexMetrics.GetFirstCorner(cell.IncomingRiver) * <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/3c6/f27/1fa3c6f277079e277491027207f9398f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La route s'√©loigna des zigzags.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ä l'int√©rieur des rivi√®res tortueuses </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La derni√®re configuration de rivi√®re est une courbe lisse. </font><font style="vertical-align: inherit;">Comme pour la rivi√®re directe, celle-ci peut √©galement s√©parer les routes. </font><font style="vertical-align: inherit;">Mais dans ce cas, les parties seront diff√©rentes. </font><font style="vertical-align: inherit;">Nous devons d'abord travailler avec l'int√©rieur de la courbe.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/566/b8f/3db/566b8f3dbffec4cdc91556abe0f2bf5e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une rivi√®re incurv√©e avec des routes pav√©es. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous avons une rivi√®re des deux c√¥t√©s de la direction actuelle, nous sommes √† l'int√©rieur de la courbe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons d√©placer le centre de la route vers le bord actuel de la cellule, raccourcissant un peu la route. </font><font style="vertical-align: inherit;">Un coefficient de 0,7 fera l'affaire. </font><font style="vertical-align: inherit;">Le centre cellulaire devrait √©galement se d√©placer avec un coefficient de 0,5.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { Vector3 offset = HexMetrics.GetSolidEdgeMiddle(direction) * HexMetrics.innerToOuter; roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>; center += offset * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2d/64f/a82/a2d64fa828544540d43856bf94e34f9d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes raccourcies. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans le cas des rivi√®res droites, nous devrons couper les parties isol√©es des routes. </font><font style="vertical-align: inherit;">Dans ce cas, il suffit de v√©rifier uniquement la direction actuelle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasRoadThroughEdge) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 offset = HexMetrics.GetSolidEdgeMiddle(direction) * HexMetrics.innerToOuter; roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>; center += offset * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/6a0/d9d/30b6a0d9db5fe0960265713c62ef2ae5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coupez les routes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En dehors des rivi√®res tortueuses </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir v√©rifi√© tous les cas pr√©c√©dents, la seule option restante √©tait la partie ext√©rieure de la rivi√®re incurv√©e. </font><font style="vertical-align: inherit;">Dehors, il y a trois parties de la cellule. </font><font style="vertical-align: inherit;">Nous devons trouver la direction du milieu. </font><font style="vertical-align: inherit;">Apr√®s l'avoir re√ßue, nous pouvons d√©placer le centre de la route vers cette nervure d'un facteur de 0,25.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } roadCenter += HexMetrics.GetSolidEdgeMiddle(middle) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b8/84c/a29/8b884ca29118c36e522674cd00ab8613.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chang√© l'ext√©rieur de la route. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme derni√®re √©tape, nous devons tronquer les routes de ce c√¥t√© de la rivi√®re. </font><font style="vertical-align: inherit;">Le moyen le plus simple consiste √† v√©rifier les trois directions de la route par rapport au milieu. </font><font style="vertical-align: inherit;">S'il n'y a pas de routes, nous arr√™tons de travailler.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !cell.HasRoadThroughEdge(middle) &amp;&amp; !cell.HasRoadThroughEdge(middle.Previous()) &amp;&amp; !cell.HasRoadThroughEdge(middle.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } roadCenter += HexMetrics.GetSolidEdgeMiddle(middle) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56d/69a/d1b/56d69ad1b8d6ffdf74e9adb1c4800695.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/8c3/178/a9a8c3178c8a44738b4bbd01ef5f221d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes avant et apr√®s d√©tourage. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir trait√© toutes les options fluviales, nos rivi√®res et nos routes peuvent coexister. </font><font style="vertical-align: inherit;">Les rivi√®res ignorent les routes et les routes s'adaptent aux rivi√®res.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b32/6e4/28b/b326e428b45df027cac2f99a336e71e9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La combinaison des rivi√®res et des routes. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'apparence des routes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'√† ce moment, nous utilisions leurs coordonn√©es UV comme couleurs de route. </font><font style="vertical-align: inherit;">√âtant donn√© que seule la coordonn√©e U a chang√©, nous avons en fait affich√© la transition entre le milieu et le bord de la route.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/cb2/8ac/084cb28ac448ddb258846c09d8b3b83a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Affichage des coordonn√©es UV. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que les routes sont correctement triangul√©es correctement, nous pouvons changer le shader de la route pour qu'il ressemble davantage √† des routes. </font><font style="vertical-align: inherit;">Comme dans le cas des rivi√®res, ce sera une visualisation simple, sans fioritures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous commencerons par utiliser la couleur unie pour les routes. </font><font style="vertical-align: inherit;">Utilisez simplement la couleur du mat√©riau. </font><font style="vertical-align: inherit;">Je l'ai rendu rouge.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/304/2e4/ab4/3042e4ab4b01b3389822072244208cb6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes rouges. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et √ßa a d√©j√† l'air beaucoup mieux! </font><font style="vertical-align: inherit;">Mais continuons et m√©langeons la route avec le terrain, en utilisant la coordonn√©e U comme facteur de m√©lange.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = blend; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble que cela n'ait rien chang√©. </font><font style="vertical-align: inherit;">C'est arriv√© parce que notre shader est opaque. </font><font style="vertical-align: inherit;">Maintenant, il a besoin d'un m√©lange alpha. </font><font style="vertical-align: inherit;">En particulier, nous avons besoin d'un shader pour une surface de d√©calcomanie d'accouplement. </font><font style="vertical-align: inherit;">Nous pouvons obtenir le shader requis en ajoutant une </font></font><code>#pragma surface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ligne </font><font style="vertical-align: inherit;">√† la directive </font></font><code>decal:blend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows decal:blend</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/66c/501/7a066c5015ea14533f1b9ed881469323.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le m√©lange des routes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc cr√©√© un m√©lange lin√©aire lisse du milieu au bord qui n'est pas tr√®s joli. </font><font style="vertical-align: inherit;">Pour qu'elle ressemble √† une route, nous avons besoin d'une zone solide, suivie d'une transition rapide vers une zone opaque. </font><font style="vertical-align: inherit;">Vous pouvez utiliser la fonction pour cela </font></font><code>smoothstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il convertit une progression lin√©aire de 0 √† 1 en une courbe en forme de S.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b0/030/f57/2b0030f57819183470fc7fae72ea18bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Progression lin√©aire et lisse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction </font></font><code>smoothstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a un param√®tre minimum et maximum pour ajuster la courbe dans un intervalle arbitraire. </font><font style="vertical-align: inherit;">Les valeurs d'entr√©e en dehors de la plage sont limit√©es pour maintenir la courbe plate. </font><font style="vertical-align: inherit;">Utilisons 0,4 au d√©but de la courbe et 0,7 √† la fin. </font><font style="vertical-align: inherit;">Cela signifie que la coordonn√©e U de 0 √† 0,4 sera compl√®tement transparente. </font><font style="vertical-align: inherit;">Et les coordonn√©es U de 0,7 √† 1 seront compl√®tement opaques. </font><font style="vertical-align: inherit;">La transition se produit entre 0,4 et 0,7.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; blend = smoothstep(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/543/fe1/4b4/543fe14b4d760b820ec106626230876f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transition rapide entre les zones opaques et transparentes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Route avec bruit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que le maillage de la route sera d√©form√©, les routes ont des largeurs variables. </font><font style="vertical-align: inherit;">Par cons√©quent, la largeur de la transition sur les bords sera √©galement variable. </font><font style="vertical-align: inherit;">Parfois, c'est flou, parfois dur. </font><font style="vertical-align: inherit;">Une telle variabilit√© nous convient, si nous percevons les routes comme sablonneuses ou terreuses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prenons la prochaine √©tape et ajoutons du bruit aux bords de la route. </font><font style="vertical-align: inherit;">Cela les rendra plus in√©gaux et moins polygonaux. </font><font style="vertical-align: inherit;">Nous pouvons le faire en √©chantillonnant la texture du bruit. </font><font style="vertical-align: inherit;">Pour l'√©chantillonnage, vous pouvez utiliser les coordonn√©es du monde XZ, comme nous l'avons fait lors de la distorsion des sommets des cellules. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour acc√©der √† la position du monde dans le shader de surface, ajoutez √† la structure d'entr√©e </font></font><code>float3 worldPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float3 worldPos; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons utiliser cette position </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour √©chantillonner la texture principale. </font><font style="vertical-align: inherit;">Effectuez √©galement un zoom arri√®re, sinon la texture se r√©p√©tera trop souvent.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous d√©formons la transition en multipliant la coordonn√©e U par </font></font><code>noise.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais comme les valeurs de bruit sont en moyenne de 0,5, la plupart des routes dispara√Ætront. </font><font style="vertical-align: inherit;">Pour √©viter cela, ajoutez 0,5 au bruit avant multiplication.</font></font><br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blend = IN.uv_MainTex.x; blend *= <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; blend = <span class="hljs-keyword"><span class="hljs-keyword">smoothstep</span></span>(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/b7d/e28/c08b7de2879b84c816286530871b6a6f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/bdf/28f/4bebdf28fc519b3f186f119b6e501261.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bords d√©form√©s de la route. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour y mettre fin, nous d√©naturerons √©galement la couleur des routes. </font><font style="vertical-align: inherit;">Cela donnera aux routes une sensation de salet√© correspondant aux bords flous. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multipliez la couleur par un autre canal de bruit, disons par </font></font><code>noise.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous obtenons donc en moyenne la moiti√© de la valeur de la couleur. </font><font style="vertical-align: inherit;">Comme c'est trop, nous r√©duirons l√©g√®rement l'√©chelle de bruit et ajouterons une constante pour que la somme puisse atteindre 1.</font></font><br><br><pre> <code class="hljs swift"> fixed4 <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = _Color * (noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d2/a25/d49/6d2a25d4929cf56f7c4059352b4ed70a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes cahoteuses. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unit√©</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424491/">https://habr.com/ru/post/fr424491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424475/index.html">Rapport du Centre de surveillance de la s√©curit√© des informations pour le premier semestre 2018</a></li>
<li><a href="../fr424477/index.html">La disponibilit√© des jeux sur pygame</a></li>
<li><a href="../fr424481/index.html">Toute la v√©rit√© sur RTOS. Article # 11. T√¢ches: configuration et introduction √† l'API</a></li>
<li><a href="../fr424483/index.html">Accord de 38 milliards de dollars et ses implications: comment Comcast et Disney combattent Amazon et Netflix avec des investissements</a></li>
<li><a href="../fr424485/index.html">SSL Pinning Bypass dans l'application iOS</a></li>
<li><a href="../fr424495/index.html">Google Chrome ajoutera la possibilit√© de refuser la synchronisation automatique des profils lors de la connexion aux services de l'entreprise *</a></li>
<li><a href="../fr424497/index.html">Arr√™tez de soup√ßonner les d√©veloppeurs d'imposture. Apprenez √† mieux interviewer</a></li>
<li><a href="../fr424499/index.html">Eh bien lui, ton pentest</a></li>
<li><a href="../fr424501/index.html">Terminaux de diagnostic pour les vrais soudeurs</a></li>
<li><a href="../fr424503/index.html">D√©marrez-vous, le printemps arrive (partie 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>