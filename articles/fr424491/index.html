<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍘 👨‍🌾 👨‍⚖️ Cartes d'hexagone Unity: aspérités, rivières et routes 👩🏽‍🤝‍👨🏻 🎈 👎🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parties 1-3: maillage, couleurs et hauteurs de cellule 

 Parties 4-7: bosses, rivières et routes 

 Parties 8-11: eau, reliefs et remparts 

 Parties...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cartes d'hexagone Unity: aspérités, rivières et routes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424491/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/b6b/8a9/716b6b8a9d024dc87b2d645b5d4bdbb6.jpg" alt="image"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 1-3: maillage, couleurs et hauteurs de cellule</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 4-7: bosses, rivières et routes</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 8-11: eau, reliefs et remparts</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 12-15: sauvegarde et chargement, textures, distances</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 16-19: trouver le chemin, équipes de joueurs, animations</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 20-23: Brouillard de guerre, recherche cartographique, génération procédurale</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Parties 24-27: cycle de l'eau, érosion, biomes, carte cylindrique</a> <br><br><h1>  Partie 4: Rugosités </h1><br><h2>  Table des matières </h2><br><ul><li>  Échantillonnez la texture du bruit. </li><li>  Déplacez les sommets. </li><li>  Nous préservons la planéité des cellules. </li><li>  Subdivisez les bords des cellules. </li></ul><br>  Alors que notre grille était un modèle strict de nids d'abeilles.  Dans cette partie, nous ajouterons des bosses pour rendre la carte plus naturelle. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e33/034/982/e33034982aafb942e1e656b76dde0981.png"></div><br>  <i>Plus d'hexagones pairs.</i> <br><br><h2>  Le bruit </h2><br>  Pour ajouter des bosses, nous avons besoin de randomisation, mais pas de vrai hasard.  Nous voulons que tout soit cohérent lors du changement de carte.  Sinon, lorsque vous apportez des modifications, les objets sautent.  Autrement dit, nous avons besoin d'une certaine forme de bruit pseudo-aléatoire reproductible. <br><br>  Un bon candidat est le bruit de Perlin.  Il est reproductible partout.  En combinant plusieurs fréquences, il crée également un bruit qui peut varier considérablement sur de longues distances, mais reste presque le même sur de courtes distances.  Grâce à cela, des distorsions relativement lisses peuvent être créées.  Les points adjacents restent généralement proches et ne sont pas dispersés dans des directions opposées. <br><br>  Nous pouvons générer du bruit Perlin par programmation.  Dans le didacticiel sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bruit</a> , j'explique comment procéder.  Mais nous pouvons également échantillonner à partir d'une texture de bruit pré-générée.  L'avantage d'utiliser la texture est qu'elle est plus simple et beaucoup plus rapide que le calcul du bruit multifréquence de Perlin.  Son inconvénient est que la texture prend plus de mémoire et ne couvre qu'une petite zone de bruit.  Par conséquent, il doit être connecté de manière transparente et suffisamment grand pour que la répétition ne soit pas frappante. <br><br><h3>  Texture de bruit </h3><br>  Nous utiliserons la texture, donc le tutoriel sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bruit</a> est facultatif.  Nous avons donc besoin d'une texture.  Le voici: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/8e8/5d7/fbd8e85d783626c737decd6bc69a2519.png"></div><br>  <i>Connectez de manière transparente la texture du bruit perlin.</i> <br><br>  La texture montrée ci-dessus contient le bruit multifréquence parfaitement couplé de Perlin.  Il s'agit d'une image en niveaux de gris.  Sa valeur moyenne est de 0,5 et les valeurs extrêmes tendent à 0 et 1. <br><br>  Mais attendez, il n'y a qu'une seule valeur pour chaque point.  Si nous avons besoin d'une distorsion 3D, nous avons besoin d'au moins trois échantillons pseudo-aléatoires!  Par conséquent, nous avons besoin de deux textures supplémentaires avec un bruit différent. <br><br>  Nous pouvons les créer ou stocker différentes valeurs de bruit dans chacun des canaux de couleur.  Cela nous permettra de stocker jusqu'à quatre modèles de bruit dans une seule texture.  Voici cette texture. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1d/509/aca/a1d509acaf05d64de002829afc59cb90.png"></div><br>  <i>Quatre en un.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Comment créer une telle texture?</b> <div class="spoiler_text">  J'ai utilisé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">NumberFlow</a> .  Il s'agit de l'éditeur de texture procédurale que j'ai créé pour Unity. </div></div><br>  Téléchargez cette texture et importez-la dans votre projet Unity.  Puisque nous allons échantillonner la texture via du code, elle doit être lisible.  <em>Réglez Type de texture</em> sur <em>Avancé</em> et activez la <em>lecture / écriture activée</em> .  Cela enregistrera les données de texture en mémoire et sera accessible à partir du code C #.  Réglez <em>Format</em> sur <em>Automatic Truecolor</em> , sinon rien ne fonctionnera.  Nous ne voulons pas que la compression de texture détruise notre modèle de bruit. <br><br>  Vous pouvez désactiver <em>Generate Mip Maps</em> , car nous n'en avons pas besoin.  <em>Activez</em> également le <em>contournement de l'échantillonnage sRGB</em> .  Nous n'en aurons pas besoin, mais ce sera le cas.  Ce paramètre indique que la texture ne contient pas de données de couleur dans l'espace gamma. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3aa/c36/e45/3aac36e45d7ead64823dc57b55afe67e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fe/6c8/99a/5fe6c899a966eecb34046d5c243036b7.png"></div><br>  Texture de bruit importée. <br><br><div class="spoiler">  <b class="spoiler_title">Quand l'échantillonnage sRGB est-il important?</b> <div class="spoiler_text">  Si nous voulions utiliser une texture dans un shader, cela ferait une différence.  Lorsque vous utilisez le mode de rendu linéaire, l'échantillonnage de la texture convertit automatiquement les données de couleur de la gamme en un espace colorimétrique linéaire.  Dans le cas de notre texture de bruit, cela entraînera des résultats incorrects, nous n'en avons donc pas besoin. </div></div><br><div class="spoiler">  <b class="spoiler_title">Pourquoi mes paramètres d'importation de texture sont-ils différents?</b> <div class="spoiler_text">  Ils ont été modifiés après la rédaction de ce didacticiel.  Vous devez utiliser les paramètres de texture 2D par défaut, <em>sRGB (Texture couleur)</em> doit être désactivé et la <em>compression</em> doit être définie sur <em>Aucune</em> . </div></div><br><h3>  Échantillonnage du bruit </h3><br>  Ajoutons une fonctionnalité d'échantillonnage du bruit à <code>HexMetrics</code> afin de pouvoir l'utiliser n'importe où.  Cela signifie que <code>HexMetrics</code> doit contenir une référence à la texture du bruit. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Texture2D noiseSource;</code> </pre> <br>  Comme il ne s'agit pas d'un composant, nous ne pouvons pas lui affecter de texture via l'éditeur.  Par conséquent, en tant qu'intermédiaire, nous utilisons <code>HexGrid</code> .  Puisque <code>HexGrid</code> agira en premier, ce sera bien si nous passons la texture au début de sa méthode <code>Awake</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D noiseSource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; … }</code> </pre> <br>  Cependant, cette approche ne survivra pas à la recompilation en mode Play.  Les variables statiques ne sont pas sérialisées par le moteur Unity.  Pour résoudre ce problème, réaffectez également la texture dans la méthode d'événement <code>OnEnable</code> .  Cette méthode sera appelée après recompilation. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d87/4fd/3a5/d874fd3a57faad4e57e5af830b202a19.png"></div><br>  <i>Attribuez une texture de bruit.</i> <br><br>  Maintenant que <code>HexMetrics</code> a accès à la texture, ajoutons-y une méthode d'échantillonnage de bruit pratique.  Cette méthode prend position dans le monde et crée un vecteur 4D contenant quatre échantillons de bruit. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Les échantillons ont été créés en échantillonnant la texture en utilisant un filtrage bilinéaire, dans lequel les coordonnées du monde X et Z ont été utilisées comme coordonnées UV. Puisque notre source de bruit est bidimensionnelle, nous ignorons la troisième coordonnée du monde.  Si la source de bruit était tridimensionnelle, nous utiliserions également la coordonnée Y. <br><br>  En conséquence, nous obtenons une couleur qui peut être convertie en vecteur 4D.  Une telle réduction peut être indirecte, c'est-à-dire que nous pouvons renvoyer la couleur directement, sans inclure explicitement <code>(Vector4)</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noiseSource.GetPixelBilinear(position.x, position.z); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Comment fonctionne le filtrage bilinéaire?</b> <div class="spoiler_text">  Pour une explication des coordonnées UV et du filtrage de texture, voir le didacticiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendu 2, Fondamentaux du shader</a> . </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unité</a> <br><br><h2>  Mouvement du sommet </h2><br>  Nous allons déformer notre grille lisse de nids d'abeilles, en déplaçant individuellement chacun des sommets.  Pour ce faire, ajoutons la méthode <code>Perturb</code> à <code>Perturb</code> .  Il prend un point immobile et renvoie celui déplacé.  Pour ce faire, il utilise un point non décalé lors de l'échantillonnage du bruit. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); }</code> </pre> <br>  Ajoutons simplement les échantillons de bruit X, Y et Z directement aux coordonnées des points correspondants et utilisons-les en conséquence. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += sample.x; position.y += sample.y; position.z += sample.z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br>  Comment changer rapidement <code>HexMesh</code> pour déplacer tous les sommets?  <code>AddTriangle</code> modifiant chaque sommet lors de l'ajout de sommets à la liste dans les <code>AddQuad</code> <code>AddTriangle</code> et <code>AddQuad</code> .  Faisons-le. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(Perturb(v1)); vertices.Add(Perturb(v2)); vertices.Add(Perturb(v3)); … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(Perturb(v1)); vertices.Add(Perturb(v2)); vertices.Add(Perturb(v3)); vertices.Add(Perturb(v4)); … }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Les quadrangles resteront-ils plats après avoir déplacé leurs sommets?</b> <div class="spoiler_text">  Probablement pas.  Ils sont constitués de deux triangles qui ne se trouveront plus dans le même plan.  Cependant, comme ces triangles ont deux sommets communs, les normales de ces sommets seront lissées.  Cela signifie que nous n'aurons pas de transitions nettes entre deux triangles.  Si la distorsion n'est pas trop importante, alors nous percevrons toujours les quadrangles comme plats. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/589/55c/47d/58955c47d221104096d943df9f9b948c.png"></div><br>  <i>Les sommets sont déplacés ou non.</i> <br><br>  Bien que les modifications ne soient pas très visibles, seules les étiquettes des cellules ont disparu.  Cela est arrivé parce que nous avons ajouté des échantillons de bruit aux points, et ils sont toujours positifs.  Par conséquent, en conséquence, tous les triangles se sont élevés au-dessus de leurs marques, les fermant.  Il faut centrer les changements pour qu'ils se produisent dans les deux sens.  Modifiez l'intervalle de l'échantillon de bruit de 0–1 à −1–1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; position.y += sample.y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; position.z += sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f0/bd6/83a/1f0bd683ad92592fa6c5df171eab646c.png"></div><br>  <i>Déplacement centré.</i> <br><br><h3>  L'ampleur (force) du déplacement </h3><br>  Il est maintenant évident que nous avons déformé la grille, mais l'effet est à peine perceptible.  Le changement dans chaque dimension ne dépasse pas 1 unité.  Autrement dit, le déplacement maximal théorique est de √3 ≈ 1,73 unités, ce qui se produira extrêmement rarement, voire pas du tout.  Le rayon extérieur des cellules étant de 10 unités, les déplacements sont relativement faibles. <br><br>  La solution consiste à ajouter un paramètre de <code>HexMetrics</code> à <code>HexMetrics</code> afin de pouvoir mettre à l'échelle les mouvements.  Essayons d'utiliser la force 5. Dans ce cas, le déplacement maximum théorique sera de √75 ≈ 8,66 unités, ce qui est beaucoup plus notable. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">5f</span></span>;</code> </pre> <br>  Nous appliquons la force en la multipliant par des échantillons dans <code>HexMesh.Perturb</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; position.y += (sample.y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; position.z += (sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/2ef/fc0/fa82effc05a418729e81ee54f0922f26.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b19/fc8/3f0/b19fc83f0828160b2100a346083f1047.png"></div><br>  <i>Augmentation de la force.</i> <br><br><h3>  Échelle de bruit </h3><br>  Bien que la grille semble bonne avant le changement, tout peut mal tourner après l'apparition des rebords.  Leurs pics peuvent être déformés dans des directions imprévisibles différentes, créant le chaos.  Lorsque vous utilisez du bruit Perlin, cela ne devrait pas se produire. <br><br>  Le problème vient du fait que nous utilisons directement les coordonnées du monde pour échantillonner le bruit.  Pour cette raison, la texture est masquée à travers chaque unité et les cellules sont beaucoup plus grandes que cette valeur.  En fait, la texture est échantillonnée à des points arbitraires, détruisant son intégrité existante. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/bd1/717/f3fbd1717515fdf4e500e9674d82a08f.png"></div><br>  <i>Des lignes de 10 x 10 cellules se chevauchent.</i> <br><br>  Nous devrons mettre à l'échelle l'échantillonnage de bruit afin que la texture couvre une zone beaucoup plus grande.  Ajoutons cette échelle à <code>HexMetrics</code> et <code>HexMetrics</code> -lui une valeur de 0,003, puis <code>HexMetrics</code> à l'échelle les coordonnées des échantillons selon ce facteur. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> noiseScale = <span class="hljs-number"><span class="hljs-number">0.003f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); }</code> </pre> <br>  Il s'avère soudain que notre texture couvre 333 &amp; frac13;  unités carrées, et son intégrité locale devient apparente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/219/e7a/9de219e7ae0495bcc9dfc2eca4ce52d6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53c/0fc/e14/53c0fce142f96daecfd5001ac45e2222.png"></div><br>  <i>Bruit à l'échelle.</i> <br><br>  De plus, une nouvelle échelle augmente la distance entre les joints de bruit.  En fait, comme les cellules ont un diamètre interne de 10√3 unités, elles ne seront jamais exactement carrelées dans la dimension X. Cependant, en raison de l'intégrité locale du bruit, à plus grande échelle, nous serons toujours en mesure de reconnaître des motifs répétitifs, environ toutes les 20 cellules, même si les détails ne correspondent pas.  Mais ils ne seront évidents que sur la carte sans autres caractéristiques. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unité</a> <br><br><h2>  Aligner les centres cellulaires </h2><br>  Déplacer tous les sommets donne à la carte un aspect plus naturel, mais il y a plusieurs problèmes.  Comme les cellules sont maintenant irrégulières, leurs étiquettes se croisent avec le maillage.  Et dans les joints des corniches avec des falaises, des fissures apparaissent.  Nous laisserons les fissures pour plus tard, mais nous allons maintenant nous concentrer sur les surfaces des cellules. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/320/626/85f/32062685fe221819ba4d9375175f66ee.png"></div><br>  <i>La carte est devenue moins stricte, mais plus de problèmes sont apparus.</i> <br><br>  Le moyen le plus simple de résoudre le problème d'intersection est de rendre les centres des cellules plats.  Ne changeons tout simplement pas la coordonnée Y dans <code>HexMesh.Perturb</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; <span class="hljs-comment"><span class="hljs-comment">// position.y += (sample.y * 2f - 1f) * HexMetrics.cellPerturbStrength; position.z += (sample.z * 2f - 1f) * HexMetrics.cellPerturbStrength; return position; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/6f6/38e/bfb6f638e8cdb45d6178d1f18cdb723b.png"></div><br>  <i>Cellules alignées.</i> <br><br>  Avec ce changement, toutes les positions verticales resteront inchangées, à la fois au centre des cellules et aux marches des rebords.  Il convient de noter que cela réduit le déplacement maximal à √50 ≈ 7,07 uniquement dans le plan XZ. <br><br>  C'est un bon changement, car il simplifie l'identification des cellules individuelles et ne permet pas aux rebords de devenir trop chaotiques.  Mais ce serait quand même bien d'ajouter un petit mouvement vertical. <br><br><h3>  Déplacer la hauteur des cellules </h3><br>  Au lieu d'appliquer un mouvement vertical à chaque sommet, nous pouvons l'appliquer à une cellule.  Dans ce cas, chaque cellule restera plate, mais la variabilité restera toujours entre les cellules.  Il serait également logique d'utiliser une échelle différente pour déplacer la hauteur, alors ajoutez-la à <code>HexMetrics</code> .  Une force de 1,5 unité crée une légère variation, approximativement égale à la hauteur d'une marche du rebord. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationPerturbStrength = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br>  Modifiez la propriété <code>HexCell.Elevation</code> afin qu'elle <code>HexCell.Elevation</code> ce déplacement à la position verticale de la cellule. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; } }</code> </pre> <br>  Pour que le déplacement soit appliqué immédiatement, nous devons définir explicitement la hauteur de chaque cellule dans <code>HexGrid.CreateCell</code> .  Sinon, la grille sera initialement plate.  Faisons-le à la fin, après avoir créé l'interface utilisateur. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … cell.Elevation = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4f/dd7/15c/d4fdd715c130c8cd8b2519ff37c837de.png"></div><br>  <i>Hauteurs déplacées avec fissures.</i> <br><br><h3>  En utilisant les mêmes hauteurs </h3><br>  De nombreuses fissures sont apparues dans le maillage, car lorsque nous triangulons le maillage, nous n'utilisons pas les mêmes hauteurs de cellule.  Ajoutons une propriété à <code>HexCell</code> pour obtenir sa position afin de pouvoir l'utiliser n'importe où. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transform.localPosition; } }</code> </pre> <br>  Nous pouvons maintenant utiliser cette propriété dans <code>HexMesh.Triangulate</code> pour déterminer le centre de la cellule. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; … }</code> </pre> <br>  Et nous pouvons l'utiliser dans <code>TriangulateConnection</code> lors de la définition des positions verticales des cellules voisines. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { … Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Position.y; … HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Position.y; … } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69b/9a2/d90/69b9a2d90b7f29ef57f658f8206f6dda.png"></div><br>  <i>Utilisation cohérente de la hauteur des cellules.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unité</a> <br><br><h2>  Unité de bord de cellule </h2><br>  Bien que les cellules aient une belle variation, elles ressemblent toujours à des hexagones évidents.  Ce n'est pas en soi un problème, mais nous pouvons améliorer leur apparence. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/895/e86/6d5895e8650286653b532d9c6fa1c10d.png"></div><br>  <i>Cellules hexagonales clairement visibles.</i> <br><br>  Si nous avions plus de sommets, alors il y aurait une plus grande variabilité locale.  Divisons donc chaque bord de la cellule en deux parties en ajoutant le haut du bord au milieu entre chaque paire de coins.  Cela signifie que <code>HexMesh.Triangulate</code> doit ajouter non pas un, mais deux triangles. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); Vector3 e1 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); AddTriangle(center, v1, e1); AddTriangleColor(cell.color); AddTriangle(center, e1, v2); AddTriangleColor(cell.color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, v2); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b09/03c/d20/b0903cd20983599abdc064f04c95aa4f.png"></div><br>  <i>Douze côtés au lieu de six.</i> <br><br>  Le doublement des sommets et des triangles ajoute plus de variabilité aux bords de la cellule.  Rendons-les encore plus inégaux en triplant le nombre de sommets. <br><br><pre> <code class="cs hljs"> Vector3 e1 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); Vector3 e2 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); AddTriangle(center, v1, e1); AddTriangleColor(cell.color); AddTriangle(center, e1, e2); AddTriangleColor(cell.color); AddTriangle(center, e2, v2); AddTriangleColor(cell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/852/e6c/ad2852e6ccbf3db0adca140818545bb3.png"></div><br>  <i>18 côtés.</i> <br><br><h3>  Division conjointe des côtes </h3><br>  Bien sûr, nous devons également subdiviser les joints de bord.  Par conséquent, nous passerons les nouveaux bords de sommet à <code>TriangulateConnection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, e1, e2, v2); }</code> </pre> <br>  Ajoutez les paramètres appropriés à <code>TriangulateConnection</code> afin qu'il puisse fonctionner avec des sommets supplémentaires. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 e1, Vector3 e2, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br>  Nous devons également calculer les arêtes supplémentaires des arêtes pour les cellules voisines.  Nous pouvons les calculer après avoir connecté le pont de l'autre côté. <br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Position.y; Vector3 e3 = Vector3.Lerp(v3, v4, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); Vector3 e4 = Vector3.Lerp(v3, v4, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>);</code> </pre> <br>  Ensuite, nous devons changer la triangulation de la nervure.  Jusqu'à ce que nous ignorions les pentes avec les rebords, ajoutez simplement trois au lieu d'un quad. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddQuad(v1, e1, v3, e3); AddQuadColor(cell.color, neighbor.color); AddQuad(e1, e2, e3, e4); AddQuadColor(cell.color, neighbor.color); AddQuad(e2, v2, e4, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afa/9d6/708/afa9d67080045b6ea2951a715c569003.png"></div><br>  <i>Connexions subdivisées.</i> <br><br><h3>  L'union des bords des bords </h3><br>  Étant donné que pour décrire les arêtes, nous avons maintenant besoin de quatre sommets, il serait logique de les combiner en un ensemble.  C'est plus pratique que de travailler avec quatre sommets indépendants.  Créez une structure <code>EdgeVertices</code> simple pour cela.  Il doit contenir quatre sommets allant dans le sens horaire le long du bord de la cellule. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EdgeVertices { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v3, v4; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Ne devraient-ils pas être sérialisables?</b> <div class="spoiler_text">  Nous utiliserons cette structure uniquement pour la triangulation.  À ce stade, nous n'avons pas besoin de stocker les sommets des bords, ils ne sont donc pas nécessaires pour être sérialisables. </div></div><br>  Ajoutez-y une méthode constructeur pratique, qui traitera du calcul des points intermédiaires de l'arête. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); v4 = corner2; }</code> </pre> <br>  Nous pouvons maintenant ajouter une méthode de triangulation distincte à <code>HexMesh</code> pour créer un éventail de triangles entre le centre de la cellule et l'un de ses bords. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { AddTriangle(center, edge.v1, edge.v2); AddTriangleColor(color); AddTriangle(center, edge.v2, edge.v3); AddTriangleColor(color); AddTriangle(center, edge.v3, edge.v4); AddTriangleColor(color); }</code> </pre> <br>  Et une méthode pour trianguler une bande de quadrangles entre deux arêtes. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2 </span></span></span><span class="hljs-function">)</span></span> { AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); AddQuadColor(c1, c2); AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); AddQuadColor(c1, c2); AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); AddQuadColor(c1, c2); }</code> </pre> <br>  Cela nous permettra de simplifier la méthode des <code>Triangulate</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); TriangulateEdgeFan(center, e, cell.color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } }</code> </pre> <br>  Passons à <code>TriangulateConnection</code> .  Nous pouvons maintenant utiliser <code>TriangulateEdgeStrip</code> , mais d'autres remplacements doivent être effectués.  Là où nous <code>e1.v1</code> <code>v1</code> , nous devons utiliser <code>e1.v1</code> .  De même, <code>v2</code> devient <code>e1.v4</code> , <code>v3</code> devient <code>e2.v1</code> et <code>v4</code> devient <code>e2.v4</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); bridge.y = neighbor.Position.y - cell.Position.y; EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v4 + bridge ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1.v1, e1.v4, cell, e2.v1, e2.v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, cell.color, e2, neighbor.color); } HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = e1.v4 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Position.y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner( e1.v4, cell, e2.v4, neighbor, v5, nextNeighbor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner( v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner( e2.v4, neighbor, v5, nextNeighbor, e1.v4, cell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner( v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor ); } }</code> </pre> <br><h3>  Division du rebord </h3><br>  Nous devons diviser les corniches.  Par conséquent, nous transmettons les bords à <code>TriangulateEdgeTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor); }</code> </pre> <br>  Nous devons maintenant modifier <code>TriangulateEdgeTerraces</code> afin qu'il interpole entre les arêtes et non entre les paires de sommets.  Supposons <code>EdgeVertices</code> dispose d'une méthode statique pratique pour ce faire.  Cela nous permettra de simplifier <code>TriangulateEdgeTerraces</code> plutôt que de le compliquer. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, beginCell.color, e2, c2); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i); TriangulateEdgeStrip(e1, c1, e2, c2); } TriangulateEdgeStrip(e2, c2, end, endCell.color); }</code> </pre> <br>  La méthode <code>EdgeVertices.TerraceLerp</code> interpole simplement les rebords entre les quatre paires de sommets de deux arêtes. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EdgeVertices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices a, EdgeVertices b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { EdgeVertices result; result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step); result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step); result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step); result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7d/ead/906/a7dead9066cbd1f7ddd29ca751d81cb0.png"></div><br>  <i>Corniches subdivisées.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">paquet d'unité</a> <br><br><h2>  Reconnectez les falaises et les corniches </h2><br>  Jusqu'à présent, nous avons ignoré les fissures à la jonction des falaises et des corniches.  Il est temps de résoudre ce problème.  Examinons d'abord les cas falaise-pente-pente (OSS) et pente-falaise-pente (SOS). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/402/951/0fa/4029510fa08226cc4e4aee18faf1959b.png"></div><br>  <i>Trous de maille.</i> <br><br>  Le problème vient du fait que les sommets des frontières se sont déplacés.  Cela signifie que maintenant ils ne se trouvent pas exactement sur le côté de la falaise, ce qui conduit à une fissure.  Parfois, ces trous sont invisibles et parfois frappants. <br><br>  La solution est de ne pas déplacer le haut de la frontière.  Cela signifie que nous devons contrôler si le point sera déplacé.  Le moyen le plus simple serait de créer une alternative <code>AddTriangle</code> qui ne déplace pas du tout les sommets. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUnperturbed</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Modifiez le <code>TriangulateBoundaryTriangle</code> afin qu'il utilise cette méthode.  Cela signifie qu'il devra déplacer explicitement tous les sommets, à l'exception des sommets. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangleUnperturbed(Perturb(begin), Perturb(v2), boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangleUnperturbed(Perturb(v1), Perturb(v2), boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangleUnperturbed(Perturb(v2), Perturb(left), boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br>  Il convient de noter ce qui suit: puisque nous n'utilisons pas la <code>v2</code> pour obtenir un autre point, nous pouvons le déplacer immédiatement.  Il s'agit d'une optimisation simple qui réduit la quantité de code, nous allons donc l'introduire. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangleUnperturbed(Perturb(begin), v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangleUnperturbed(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangleUnperturbed(v2, Perturb(left), boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/221/0ed/3fd2210ed0a8148ba9d39ef1655848e8.png"></div><br>  <i>Frontières immobiles.</i> <br><br>  Ça a l'air mieux, mais nous n'avons pas encore fini.  À l'intérieur de la méthode <code>TriangulateCornerTerracesCliff</code> , le point limite est interpolé entre les points gauche et droit.  Cependant, ces points n'ont pas encore été déplacés.  Pour que le point limite corresponde à la falaise résultante, nous devons interpoler entre les points déplacés. <br><br><pre> <code class="cs hljs"> Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(right), b);</code> </pre> <br>  Il en va de même pour la méthode <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(left), b);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/917/670/c189176704e7ebcdfd92bc6a1cffaee3.png"></div><br>  <i>Les trous ont disparu.</i> <br><br><h3>  Double falaise et pente </h3><br>  Dans tous les cas problématiques restants, deux falaises et une pente sont présentes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/408/f2f/4a6/408f2f4a6fca5fffd8659b4380f59e51.png"></div><br>  <i>Gros trou à cause d'un seul triangle.</i> <br><br>  Ce problème est résolu en déplaçant manuellement un seul triangle dans le bloc <code>else</code> à la fin de <code>TriangulateCornerTerracesCliff</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); }</code> </pre> <br>  Il en va de même pour <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/b34/64a/9ffb3464a6de3dc443cede9d42797022.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Débarrassez-vous des dernières fissures. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Achèvement </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons maintenant un maillage déformé complètement correct. </font><font style="vertical-align: inherit;">Son apparence dépend du bruit spécifique, de son échelle et des forces de distorsion. </font><font style="vertical-align: inherit;">Dans notre cas, la distorsion peut sembler trop forte. </font><font style="vertical-align: inherit;">Bien que cette irrégularité soit belle, nous ne voulons pas que les cellules s'écartent trop de la grille uniforme. </font><font style="vertical-align: inherit;">Au final, nous l'utilisons toujours pour définir la cellule à redimensionner. </font><font style="vertical-align: inherit;">Et si la taille des cellules varie trop, il nous sera plus difficile d'y placer le contenu.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35f/32e/d06/35f32ed066f03b1079ed0bec70ba83ca.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eac/3f5/d6c/eac3f5d6cd6a1e65185d1aec48e8abb0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mailles non déformées et déformées. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble que la force 5 de déformation des cellules soit trop importante.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distorsion des cellules est de 0 à 5.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Réduisons-la à 4 pour augmenter la commodité de la grille, sans la rendre trop correcte. </font><font style="vertical-align: inherit;">Cela garantit que le décalage XZ maximum sera de √32 ≈ 5,66 unités.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/803/2f6/b8d/8032f6b8d0cf048f5d55c30e2d0e465d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Force de distorsion cellulaire 4.</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Une autre valeur qui peut être modifiée est le coefficient d'intégrité. </font><font style="vertical-align: inherit;">Si nous l'augmentons, les centres plats des cellules deviendront plus grands, c'est-à-dire qu'il y aura plus d'espace pour le contenu futur. </font><font style="vertical-align: inherit;">Bien sûr, ce faisant, ils deviendront plus hexagonaux.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coefficient d'intégrité de 0,75 à 0,95. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une légère augmentation du coefficient d'intégrité à 0,8 simplifiera légèrement notre vie à l'avenir.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> solidFactor = <span class="hljs-number"><span class="hljs-number">0.8f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/9a2/036/a9a9a2036fbcd0e4e5f11e56078911c1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coefficient d'intégrité 0,8. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, vous remarquerez peut-être que les différences entre les niveaux d'élévation sont trop marquées. </font><font style="vertical-align: inherit;">C'est pratique lorsque vous devez vous assurer que le maillage est généré correctement, mais nous avons déjà terminé avec cela. </font><font style="vertical-align: inherit;">Réduisons-le à 1 unité par étape, c'est-à-dire à 3.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationStep = <span class="hljs-number"><span class="hljs-number">3f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5cc/4b0/028/5cc4b002843f822556c7ced67b9f54db.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La hauteur est réduite à 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons également modifier la force de la distorsion de hauteur. </font><font style="vertical-align: inherit;">Mais maintenant, il a une valeur de 1,5, ce qui équivaut à un demi-pas de hauteur, ce qui nous convient. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De petites marches de hauteurs permettent une utilisation plus logique des sept niveaux de hauteur. </font><font style="vertical-align: inherit;">Cela augmente la variabilité de la carte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f63/9b3/aac/f639b3aac128c4c72c28fa85d68cc0e4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons sept niveaux de hauteurs. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 5: cartes plus grandes </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous divisons la grille en fragments. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous contrôlons la caméra. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colorisez les couleurs et les hauteurs séparément. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisez la brosse agrandie des cellules. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à présent, nous avons travaillé avec une toute petite carte. </font><font style="vertical-align: inherit;">Il est temps de l'augmenter.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/11c/4b4/0c811c4b480c13b584a2b824fdae1cee.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est temps de zoomer.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragments de maille </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne pouvons pas rendre la grille trop grande, car nous nous heurtons aux limites de ce qui peut tenir dans un maillage. </font><font style="vertical-align: inherit;">Comment résoudre ce problème? </font><font style="vertical-align: inherit;">Utilisez plusieurs maillages. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons diviser notre grille en plusieurs fragments. </font><font style="vertical-align: inherit;">Nous utilisons des fragments rectangulaires de taille constante.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/423/453/db2/423453db217ed74da2457198c576ef63.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diviser la grille en segments de 3 par 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisons 5 blocs par 5, soit 25 cellules par fragment. </font><font style="vertical-align: inherit;">Définissez-les </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeX = <span class="hljs-number"><span class="hljs-number">5</span></span>, chunkSizeZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle taille de fragment peut être considérée comme appropriée?</font></font></b> <div class="spoiler_text">  .       ,     .      .      ,       (frustum culling),       .            . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous ne pouvons pas utiliser de taille pour le maillage, il doit être un multiple de la taille du fragment. </font><font style="vertical-align: inherit;">Par conséquent, modifions-le </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">afin qu'il définisse sa taille non pas dans des cellules distinctes, mais en fragments. </font><font style="vertical-align: inherit;">Définissez la taille par défaut sur 4 par 3 fragments, c'est-à-dire seulement 12 fragments ou 300 cellules. </font><font style="vertical-align: inherit;">Nous obtenons donc une carte de test pratique.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkCountX = <span class="hljs-number"><span class="hljs-number">4</span></span>, chunkCountZ = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons toujours </font></font><code>width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>height</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais maintenant ils devraient devenir privés. </font><font style="vertical-align: inherit;">Et renommez-les en </font></font><code>cellCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>cellCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Utilisez l'éditeur pour renommer toutes les occurrences de ces variables à la fois. </font><font style="vertical-align: inherit;">Maintenant, il sera clair quand nous aurons affaire au nombre de fragments ou de cellules.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int width = 6; // public int height = 6; int cellCountX, cellCountZ;</span></span></code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/ff4/160/227ff41602f115787a8a0e5d98ca89c9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spécifiez la taille en fragments. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour que, si nécessaire, le nombre de cellules soit calculé à partir du nombre de fragments. </font><font style="vertical-align: inherit;">Nous mettons en évidence la création de cellules dans une méthode distincte, afin de ne pas obstruer </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateCells(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[cellCountZ * cellCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; cellCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; cellCountX; x++) { CreateCell(x, z, i++); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragment préfabriqué </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour décrire les fragments de maillage, nous avons besoin d'un nouveau type de composant. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGridChunk</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous allons créer un fragment préfabriqué. </font><font style="vertical-align: inherit;">Nous le ferons en dupliquant l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et en le renommant </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Supprimez son composant </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ajoutez un composant à la place </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Transformez-le ensuite en un préfabriqué et retirez l'objet de la scène.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/a02/bea/106a02bead67c37151be26d5f6a4bea9.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cb/586/7a3/1cb5867a3851159ce2bf1747a4e213bc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un fragment préfabriqué avec sa propre toile et maillage. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisqu'il créera des instances de ces fragments </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous lui donnerons un lien vers le préfabriqué du fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGridChunk chunkPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a9/6b8/882/2a96b8882c5d6cc5bdb6345d5217ae83.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant avec des fragments. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La création d'instances de fragments ressemble beaucoup à la création d'instances de cellules. </font><font style="vertical-align: inherit;">Nous allons les suivre à l'aide d'un tableau et utiliser une double boucle pour le remplir.</font></font><br><br><pre> <code class="cs hljs"> HexGridChunk[] chunks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … CreateChunks(); CreateCells(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(transform); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'initialisation d'un fragment est similaire à la façon dont nous avons initialisé une grille d'hexagones. </font><font style="vertical-align: inherit;">Elle met tout en place </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et effectue la triangulation </font></font><code>Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il nécessite une référence à son canevas et maillage, ainsi qu'un tableau pour les cellules. </font><font style="vertical-align: inherit;">Cependant, le fragment ne créera pas ces cellules. </font><font style="vertical-align: inherit;">La grille continuera de le faire.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGridChunk</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { HexCell[] cells; HexMesh hexMesh; Canvas gridCanvas; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Affectation de cellules à des fragments </font></font></h3><br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crée toujours toutes les cellules. </font><font style="vertical-align: inherit;">C'est normal, mais maintenant nous devons ajouter chaque cellule à un fragment approprié, et non les définir en utilisant notre propre maillage et toile.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { … HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); <span class="hljs-comment"><span class="hljs-comment">// cell.transform.SetParent(transform, false); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.color = defaultColor; … Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); // label.rectTransform.SetParent(gridCanvas.transform, false); label.rectTransform.anchoredPosition = new Vector2(position.x, position.z); label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; cell.Elevation = 0; AddCellToChunk(x, z, cell); } void AddCellToChunk (int x, int z, HexCell cell) { }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons trouver le fragment correct en utilisant la division entière </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par taille de fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCellToChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkX = x / HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkZ = z / HexMetrics.chunkSizeZ; HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En utilisant des résultats intermédiaires, nous pouvons également déterminer l'indice local de la cellule dans ce fragment. </font><font style="vertical-align: inherit;">Après cela, vous pouvez ajouter une cellule au fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCellToChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkX = x / HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkZ = z / HexMetrics.chunkSizeZ; HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localX = x - chunkX * HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localZ = z - chunkZ * HexMetrics.chunkSizeZ; chunk.AddCell(localX + localZ * HexMetrics.chunkSizeX, cell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, il </font></font><code>HexGridChunk.AddCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">place la cellule dans son propre tableau, puis il définit les éléments parents de la cellule et de son interface utilisateur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cells[index] = cell; cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.uiRect.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Balayer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À ce stade, il </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut se débarrasser de la toile et du maillage hexagonal de ses enfants, ainsi que du code.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Canvas gridCanvas; // HexMesh hexMesh; void Awake () { HexMetrics.noiseSource = noiseSource; // gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); // hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); … } // void Start () { // hexMesh.Triangulate(cells); // } // public void Refresh () { // hexMesh.Triangulate(cells); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis que nous nous sommes débarrassés </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous ne devons </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus l'utiliser.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.Elevation = activeElevation; <span class="hljs-comment"><span class="hljs-comment">// hexGrid.Refresh(); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a0/f4b/c99/5a0f4bc99bce766e53ff1a0192abd16e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La grille nettoyée d'hexagones. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir démarré le mode Lecture, la carte est toujours la même. </font><font style="vertical-align: inherit;">Mais la hiérarchie des objets sera différente. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> crée maintenant des objets enfants fragmentés qui contiennent des cellules, ainsi que leur maillage et leur canevas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/bc4/f8e/a7fbc4f8e4898504bc34a4a918ebb567.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragments enfant en mode Lecture. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons peut-être des problèmes avec les étiquettes des cellules. </font><font style="vertical-align: inherit;">Initialement, nous avons défini la largeur de l'étiquette sur 5. Cela suffisait pour afficher les deux caractères qui nous suffisaient sur une petite carte. </font><font style="vertical-align: inherit;">Mais maintenant, nous pouvons avoir des coordonnées comme −10, dans lesquelles il y a trois caractères. </font><font style="vertical-align: inherit;">Ils ne rentreront pas et seront coupés. </font><font style="vertical-align: inherit;">Pour résoudre ce problème, augmentez la largeur de l'étiquette de cellule à 10, voire plus.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e7/fd3/4a5/2e7fd34a5b649256e326b73a3aa9227a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/926/fae/f7c926fae8356aa8d2402a21359fea8f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étiquettes de cellules étendues. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant créer des cartes beaucoup plus grandes! </font><font style="vertical-align: inherit;">Comme nous générons l'intégralité de la grille au démarrage, la création de grandes cartes peut prendre beaucoup de temps. </font><font style="vertical-align: inherit;">Mais après l'achèvement, nous aurons un immense espace d'expérimentation.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Correction de l'édition des cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'édition ne semble pas fonctionner au stade actuel, car nous ne mettons plus à jour la grille. </font><font style="vertical-align: inherit;">Nous devons mettre à jour des fragments individuels, alors ajoutez une méthode </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quand devrions-nous appeler cette méthode? </font><font style="vertical-align: inherit;">Nous avons mis à jour la grille entière à chaque fois car nous n'avions qu'un seul maillage. </font><font style="vertical-align: inherit;">Mais maintenant, nous avons de nombreux fragments. </font><font style="vertical-align: inherit;">Au lieu de les mettre à jour à chaque fois, il sera beaucoup plus efficace de mettre à jour les fragments modifiés. </font><font style="vertical-align: inherit;">Sinon, changer de grandes cartes deviendra une opération très lente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais comment savoir quel fragment mettre à jour? </font><font style="vertical-align: inherit;">Le moyen le plus simple est de faire savoir à chaque cellule à quel fragment elle appartient. </font><font style="vertical-align: inherit;">La cellule pourra alors mettre à jour son fragment lors du changement de cette cellule. </font><font style="vertical-align: inherit;">Donnons donc un </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien vers son fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGridChunk chunk;</code> </pre> <br> <code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut s'ajouter à la cellule lors de l'ajout. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cells[index] = cell; cell.chunk = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.uiRect.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En les connectant, nous ajoutons à la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Chaque fois qu'une cellule est mise à jour, elle met simplement à jour son fragment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'avons pas besoin de le rendre </font></font><code>HexCell.Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">commun, car la cellule elle-même sait mieux quand elle a été changée. </font><font style="vertical-align: inherit;">Par exemple, une fois sa hauteur modifiée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … Refresh(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, nous devons le mettre à jour uniquement lorsque sa hauteur a changé pour une valeur différente. </font><font style="vertical-align: inherit;">Elle n'a même pas besoin de recalculer quoi que ce soit si nous lui attribuons la même hauteur qu'auparavant. </font><font style="vertical-align: inherit;">Par conséquent, nous pouvons quitter le début du setter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } … } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, nous ignorerons également les calculs pour la première fois lorsque la hauteur est définie sur 0, car il s'agit de la valeur de hauteur de maillage par défaut. </font><font style="vertical-align: inherit;">Pour éviter cela, nous allons créer la valeur initiale telle que nous ne l'utilisons jamais.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce que int.MinValue?</font></font></b> <div class="spoiler_text">   ,    integer.    C# integer — <br>  32- ,   2 <sup>32</sup>  integer,    ,    .       . <br><br>  —  −2 <sup>31</sup> = −2 147 483 648.        ! <br><br>   2 <sup>31</sup> − 1 = 2 147 483 647.     2 <sup>31</sup> - . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour reconnaître le changement de couleur de la cellule, nous devons également la transformer en propriété. </font><font style="vertical-align: inherit;">Renommez-le en </font></font><code>Color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">majuscules, puis transformez-le en une propriété avec une variable privée </font></font><code>color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La valeur de couleur par défaut sera le noir transparent, ce qui nous convient.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } color = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } Color color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, lorsque nous démarrons le mode Lecture, nous obtenons des exceptions de référence nulle. </font><font style="vertical-align: inherit;">Cela se produit car nous définissons la couleur et la hauteur à leurs valeurs par défaut avant d'affecter une cellule à son fragment. </font><font style="vertical-align: inherit;">Il est normal que nous ne mettions pas à jour les fragments à ce stade, car nous les triangulons une fois l’initialisation terminée. </font><font style="vertical-align: inherit;">En d'autres termes, nous mettons à jour un fragment uniquement s'il est affecté.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons enfin changer à nouveau les cellules! </font><font style="vertical-align: inherit;">Cependant, un problème se pose. </font><font style="vertical-align: inherit;">Lorsque vous dessinez le long des bordures de fragments, des coutures apparaissent.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/94f/50c/41a94f50c430ce8f13fb1a3be274b520.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erreurs aux limites des fragments.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C'est logique, car lorsqu'une seule cellule change, toutes les connexions avec ses voisins changent également. Et ces voisins peuvent être dans d'autres fragments. La solution la plus simple consiste à mettre à jour toutes les cellules voisines si elles sont différentes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { HexCell neighbor = neighbors[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.chunk != chunk) { neighbor.chunk.Refresh(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que cela fonctionne, il se peut que nous mettions à jour un fragment plusieurs fois. Et lorsque nous commençons à colorer plusieurs cellules à la fois, tout va empirer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais nous ne sommes pas tenus de trianguler immédiatement après la mise à jour du fragment. Au lieu de cela, nous écrivons simplement qu'une mise à jour est nécessaire et triangulons une fois le changement terminé. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisqu'il ne </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fait rien d'autre, nous pouvons utiliser son état activé pour signaler la nécessité de mises à jour. Lors de sa mise à jour, nous incluons le composant. L'activer plusieurs fois ne changera rien. Le composant est mis à jour ultérieurement. Nous allons trianguler à ce stade et désactiver à nouveau le composant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous utilisons à la </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">place</font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour garantir que la triangulation se produit une fois la modification terminée pour la trame actuelle. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// hexMesh.Triangulate(cells); enabled = true; } void LateUpdate () { hexMesh.Triangulate(cells); enabled = false; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle est la différence entre Update et LateUpdate?</font></font></b> <div class="spoiler_text">     <code>Update</code>    -     .          <code>LateUpdate</code> .      ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme notre composant est activé par défaut, nous n'avons plus besoin de trianguler explicitement </font></font><code>Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par conséquent, cette méthode peut être supprimée.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void Start () { // hexMesh.Triangulate(cells); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6f/104/7c3/a6f1047c34bb9cf9b69360343ab53aac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragments de 20 par 20 contenant 10 000 cellules.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listes généralisées </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous ayons considérablement modifié la façon dont la grille est triangulée, </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elle reste la même. </font><font style="vertical-align: inherit;">Tout ce dont il a besoin pour travailler est un tableau de cellules. </font><font style="vertical-align: inherit;">Il ne se soucie pas s'il y a un maillage d'hexagones, ou plusieurs d'entre eux. </font><font style="vertical-align: inherit;">Mais nous n'avons pas encore envisagé d'utiliser plusieurs maillages. </font><font style="vertical-align: inherit;">Peut-être que quelque chose peut être amélioré ici? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">listes </font><font style="vertical-align: inherit;">utilisées </font><font style="vertical-align: inherit;">sont essentiellement des tampons temporaires. </font><font style="vertical-align: inherit;">Ils sont utilisés uniquement pour la triangulation. </font><font style="vertical-align: inherit;">Et les fragments sont triangulés un à la fois. </font><font style="vertical-align: inherit;">Par conséquent, en fait, nous avons besoin d'un seul ensemble de listes, et non d'un ensemble pour chaque objet maillé hexagonal. </font><font style="vertical-align: inherit;">Cela peut être réalisé en rendant les listes statiques.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Vector3&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Color&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Color&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// vertices = new List&lt;Vector3&gt;(); // colors = new List&lt;Color&gt;(); // triangles = new List&lt;int&gt;(); }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les listes statiques sont-elles vraiment si importantes?</font></font></b> <div class="spoiler_text">           .    ,   ,       . <br><br>     ,           .    20  20     100. </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contrôle de la caméra </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le grand appareil photo est merveilleux, mais il est inutile si nous ne pouvons pas le voir. Pour inspecter la carte entière, nous devons déplacer la caméra. Le zoom est également utile. Par conséquent, créons une caméra pour effectuer ces actions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez un objet factice et appelez-le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caméra Hex Map</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Déposez son composant de transformation de sorte qu'il se déplace vers l'origine sans modifier sa rotation et son échelle. Ajoutez-y un enfant appelé </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swivel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et ajoutez-y un enfant </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stick</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Faites de la caméra principale un enfant du Stick et réinitialisez son composant de transformation.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a8/33f/3d9/0a833f3d9eea9b9fef1682ef63a7f372.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La hiérarchie de la caméra. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le but de la charnière de la caméra (pivotante) est de contrôler l'angle sous lequel la caméra regarde la carte. </font><font style="vertical-align: inherit;">Donnons-lui un tour (45, 0, 0). </font><font style="vertical-align: inherit;">La poignée (Stick) contrôle la distance à laquelle les caméras sont situées. </font><font style="vertical-align: inherit;">Fixons-lui une position (0, 0, -45). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons besoin d'un composant pour contrôler ce système. </font><font style="vertical-align: inherit;">Attribuez ce composant à la racine de la hiérarchie des caméras. </font><font style="vertical-align: inherit;">Donnez-lui un lien vers la charnière et la poignée, en les faisant entrer </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapCamera</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Transform swivel, stick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb6/2e5/44b/eb62e544b9e00bc558dfbc504802cfba.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caméra de carte hexagonale.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zoom </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La première fonction que nous allons créer est le zoom (zoom). </font><font style="vertical-align: inherit;">Nous pouvons contrôler le niveau de zoom actuel en utilisant la variable flottante. </font><font style="vertical-align: inherit;">Une valeur de 0 signifie que nous sommes complètement éloignés et une valeur de 1 signifie que nous sommes complètement proches. </font><font style="vertical-align: inherit;">Commençons par un zoom maximum.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoom = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le zoom est généralement effectué avec la molette de la souris ou un contrôle analogique. </font><font style="vertical-align: inherit;">Nous pouvons l'implémenter en utilisant l'axe d'entrée </font><font style="vertical-align: inherit;">par défaut de la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">molette de la souris</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Nous ajoutons une méthode </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui vérifie la présence d'un delta d'entrée, et s'il y en a un, il appelle la méthode pour changer le zoom.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour modifier le niveau de zoom, nous y ajoutons simplement un delta, puis limitons la valeur (pince) pour rester dans la plage 0–1. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors d'un zoom avant ou arrière, la distance par rapport à la caméra doit changer en conséquence. </font><font style="vertical-align: inherit;">Cela peut être fait en changeant la position de la poignée en Z. Ajoutez deux variables flottantes communes pour ajuster la position de la poignée au zoom minimum et maximum. </font><font style="vertical-align: inherit;">Puisque nous développons une carte relativement petite, définissez les valeurs sur -250 et -45.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stickMinZoom, stickMaxZoom;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir changé le zoom, nous effectuons une interpolation linéaire entre ces deux valeurs en fonction de la nouvelle valeur de zoom. </font><font style="vertical-align: inherit;">Mettez ensuite à jour la position de la poignée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom); stick.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, distance); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cec/f4c/f07/cecf4cf07d627d6eaab94ecdc2953d30.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valeurs de stick minimum et maximum. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, le zoom fonctionne, mais jusqu'à présent, il n'est pas très utile. </font><font style="vertical-align: inherit;">Habituellement, lorsque le zoom est plus éloigné, la caméra passe en vue de dessus. </font><font style="vertical-align: inherit;">Nous pouvons le réaliser en tournant la charnière. </font><font style="vertical-align: inherit;">Par conséquent, nous ajoutons les variables min et max pour la charnière. </font><font style="vertical-align: inherit;">Fixons-leur les valeurs 90 et 45.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> swivelMinZoom, swivelMaxZoom;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme pour la position de la poignée, nous interpolons pour trouver un angle de zoom approprié. </font><font style="vertical-align: inherit;">Ensuite, nous définissons la rotation de la charnière.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom); stick.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, distance); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Mathf.Lerp(swivelMinZoom, swivelMaxZoom, zoom); swivel.localRotation = Quaternion.Euler(angle, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/766/0c3/fcd/7660c3fcd621567398ea7c013fae549c.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La valeur minimale et maximale de Swivel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le taux de changement du zoom peut être ajusté en changeant la sensibilité des paramètres d'entrée de la molette de la souris. </font><font style="vertical-align: inherit;">Ils peuvent être trouvés dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Edit / Project Settings / Input</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Par exemple, en les changeant de 0,1 à 0,025, nous obtenons un changement de zoom plus lent et plus fluide.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d43/f86/ef3/d43f86ef3587be1bfd15ca208eec418f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Options de saisie de la molette de la souris.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Déménagement </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passons maintenant au déplacement de la caméra. </font><font style="vertical-align: inherit;">Le mouvement dans la direction de X et Z doit être implémenté dans </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comme dans le cas du zoom. </font><font style="vertical-align: inherit;">Nous pouvons utiliser des axes d'entrée </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontaux</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verticaux</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour cela </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cela nous permettra de déplacer la caméra avec les flèches et les touches WASD.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span> || zDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustPosition(xDelta, zDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'approche la plus simple consiste à obtenir la position actuelle du système de caméra, à y ajouter des deltas X et Z et à affecter le résultat à la position du système. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 position = transform.localPosition; position += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta); transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cette raison, la caméra se déplacera tout en maintenant les flèches ou WASD, mais pas à une vitesse constante. </font><font style="vertical-align: inherit;">Cela dépendra de la fréquence d'images. </font><font style="vertical-align: inherit;">Pour déterminer la distance à parcourir, nous utilisons le delta temporel ainsi que la vitesse requise. </font><font style="vertical-align: inherit;">Par conséquent, nous ajoutons une variable commune </font></font><code>moveSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la définissons sur 100, puis la multiplions par le delta temporel pour obtenir le delta de position.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moveSpeed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * Time.deltaTime; Vector3 position = transform.localPosition; position += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta) * distance; transform.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6da/1bc/307/6da1bc3074dc31868b934a35aaa31b10.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vitesse de déplacement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant nous déplacer à une vitesse constante le long des axes X ou Z. Mais lorsque vous vous déplacez le long des deux axes en même temps (en diagonale), le mouvement sera plus rapide. </font><font style="vertical-align: inherit;">Pour résoudre ce problème, nous devons normaliser le vecteur delta. </font><font style="vertical-align: inherit;">Cela vous permettra de l'utiliser comme destination.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * Time.deltaTime; Vector3 position = transform.localPosition; position += direction * distance; transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mouvement diagonal est maintenant correctement mis en œuvre, mais il s'avère soudain que la caméra continue de bouger assez longtemps même après avoir relâché toutes les touches. Cela se produit car les axes d'entrée ne sautent pas instantanément aux valeurs limites immédiatement après avoir appuyé sur les touches. Ils ont besoin de temps pour cela. Il en va de même pour la libération des clés. Il faut du temps pour revenir à des valeurs d'axe nulles. Cependant, puisque nous avons normalisé les valeurs d'entrée, la vitesse maximale est constamment maintenue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons ajuster les paramètres d'entrée pour éliminer les retards, mais ils donnent une sensation de douceur qui mérite d'être sauvegardée. Nous pouvons appliquer la valeur la plus extrême des axes comme coefficient d'amortissement du mouvement.</font></font><br><br><pre> <code class="cs hljs"> Vector3 direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * damping * Time.deltaTime;</code> </pre><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mouvement avec atténuation. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, le mouvement fonctionne bien, au moins avec une augmentation du zoom. </font><font style="vertical-align: inherit;">Mais à distance cela s'avère trop lent. </font><font style="vertical-align: inherit;">Avec un zoom réduit, nous devons accélérer. </font><font style="vertical-align: inherit;">Cela peut être fait en remplaçant une variable </font></font><code>moveSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par deux pour le zoom minimum et maximum, puis en interpolant. </font><font style="vertical-align: inherit;">Attribuez-leur des valeurs de 400 et 100.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public float moveSpeed; public float moveSpeedMinZoom, moveSpeedMaxZoom; void AdjustPosition (float xDelta, float zDelta) { Vector3 direction = new Vector3(xDelta, 0f, zDelta).normalized; float damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta)); float distance = Mathf.Lerp(moveSpeedMinZoom, moveSpeedMaxZoom, zoom) * damping * Time.deltaTime; Vector3 position = transform.localPosition; position += direction * distance; transform.localPosition = position; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/cb8/65e/5a9cb865ee0a67d4b3ad056317faf479.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La vitesse de déplacement varie en fonction du niveau de zoom. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant nous déplacer rapidement sur la carte! </font><font style="vertical-align: inherit;">En fait, nous pouvons aller bien au-delà de la carte, mais ce n'est pas souhaitable. </font><font style="vertical-align: inherit;">La caméra doit rester à l'intérieur de la carte. </font><font style="vertical-align: inherit;">Pour ce faire, nous devons connaître les limites de la carte, donc un lien vers la grille est nécessaire. </font><font style="vertical-align: inherit;">Ajoutez-le et connectez-le.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e71/f87/68e/e71f8768e16aee250700a7bd694a0e6b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besoin de demander la taille de la grille. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir déplacé vers une nouvelle position, nous la limiterons en utilisant la nouvelle méthode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { … transform.localPosition = ClampPosition(position); } <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La position X a une valeur minimale de 0 et la valeur maximale est déterminée par la taille de la carte. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il en va de même pour la position Z. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = grid.chunkCountZ * HexMetrics.chunkSizeZ * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, c'est un peu inexact. </font><font style="vertical-align: inherit;">Le point de départ est au centre de la cellule, pas à gauche. </font><font style="vertical-align: inherit;">Par conséquent, nous voulons que la caméra s'arrête au centre des cellules les plus à droite. </font><font style="vertical-align: inherit;">Pour ce faire, soustrayez la moitié de la cellule du maximum de X.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.chunkCountX * HexMetrics.chunkSizeX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour la même raison, nous devons réduire le maximum Z. Puisque les mesures sont légèrement différentes, nous devons soustraire la cellule entière. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.chunkCountZ * HexMetrics.chunkSizeZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec le mouvement, nous avons terminé, il ne reste qu'un petit détail. </font><font style="vertical-align: inherit;">Parfois, l'interface utilisateur réagit aux touches fléchées, ce qui conduit au fait que lorsque vous déplacez la caméra, le curseur se déplace. </font><font style="vertical-align: inherit;">Cela se produit lorsque l'interface utilisateur se considère comme active, après avoir cliqué dessus et que le curseur reste au-dessus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez empêcher l'interface utilisateur d'écouter les entrées au clavier. </font><font style="vertical-align: inherit;">Cela peut être fait en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demandant à l'</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objet </font><em><font style="vertical-align: inherit;">EventSystem de</font></em><font style="vertical-align: inherit;"> ne pas exécuter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Send Navigation Events</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/008/313/35c/00831335c530f6fcb06d4fe15890c316.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus d'événements de navigation.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tourner </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous voulez voir ce qu'il y a derrière la falaise? </font><font style="vertical-align: inherit;">Il serait pratique de pouvoir faire pivoter la caméra! </font><font style="vertical-align: inherit;">Ajoutons cette fonctionnalité. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le niveau de zoom n'est pas important pour la rotation, seule la vitesse suffit. </font><font style="vertical-align: inherit;">Ajoutez une variable commune </font></font><code>rotationSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et réglez-la sur 180 degrés. </font><font style="vertical-align: inherit;">Vérifiez le delta de rotation en </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">échantillonnant l'axe de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et en changeant la rotation si nécessaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Rotation"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustRotation(rotationDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span> || zDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustPosition(xDelta, zDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c17/189/c8f/c17189c8f16ef3e50aa8af32f7ff34c8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vitesse de rotation. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, l'axe de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'est </font><font style="vertical-align: inherit;">pas par défaut. </font><font style="vertical-align: inherit;">Nous devrons le créer nous-mêmes. </font><font style="vertical-align: inherit;">Accédez aux paramètres d'entrée et dupliquez l'entrée supérieure </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verticale</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Changez le nom du doublon en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotation</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et changez les clés en QE et une virgule (,) avec un point (.).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/549/6a8/50a/5496a850af906515b57a0d0fd1aea7b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tournez l'axe d'entrée.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai téléchargé le paquet d'unité, pourquoi n'ai-je pas cette entrée?</font></font></b> <div class="spoiler_text">     .       Unity.  ,     .    ,    ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'angle de rotation que nous suivrons et changerons </font></font><code>AdjustRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Après quoi, nous allons faire pivoter l'ensemble du système de caméra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationAngle; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { rotationAngle += delta * rotationSpeed * Time.deltaTime; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, rotationAngle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Étant donné que le cercle complet est de 360 ​​degrés, nous roulons l'angle de rotation de sorte qu'il se situe dans la plage de 0 à 360. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { rotationAngle += delta * rotationSpeed * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationAngle &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { rotationAngle += <span class="hljs-number"><span class="hljs-number">360f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationAngle &gt;= <span class="hljs-number"><span class="hljs-number">360f</span></span>) { rotationAngle -= <span class="hljs-number"><span class="hljs-number">360f</span></span>; } transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, rotationAngle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mettez en action. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, la rotation fonctionne. </font><font style="vertical-align: inherit;">Si vous le vérifiez, vous pouvez voir que le mouvement est absolu. </font><font style="vertical-align: inherit;">Par conséquent, après avoir tourné à 180 degrés, le mouvement sera l'opposé de ce qui était attendu. </font><font style="vertical-align: inherit;">Il serait beaucoup plus pratique pour l'utilisateur que le mouvement soit effectué par rapport à l'angle de vue de la caméra. </font><font style="vertical-align: inherit;">Nous pouvons le faire en multipliant la rotation actuelle par la direction du mouvement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 direction = transform.localRotation * <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; … }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Déplacement relatif. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Édition avancée </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons une carte plus grande, vous pouvez améliorer les outils d'édition de carte. </font><font style="vertical-align: inherit;">Changer une cellule à la fois est trop long, donc ce serait bien de créer un pinceau plus grand. </font><font style="vertical-align: inherit;">Il sera également pratique si vous pouviez choisir de peindre ou de modifier la hauteur, en laissant tout le reste inchangé.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Couleur et hauteur en option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons rendre les couleurs facultatives en ajoutant une option de sélection vide au groupe de bascule. </font><font style="vertical-align: inherit;">Dupliquez l'un des commutateurs de couleur et remplacez son étiquette par </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">---</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou quelque chose de similaire pour indiquer qu'il ne s'agit pas d'une couleur. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remplacez</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ensuite l'argument de son événement </font><em><font style="vertical-align: inherit;">On Value Changed</font></em><font style="vertical-align: inherit;"> par −1.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/786/485/b0c/786485b0cbbae8edee6c80873f19afc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Index de couleur non valide. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sûr, cet index n'est pas valide pour un tableau de couleurs. </font><font style="vertical-align: inherit;">Nous pouvons l'utiliser pour déterminer si la couleur doit être appliquée aux cellules.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { applyColor = index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { activeColor = colors[index]; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } cell.Elevation = activeElevation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La hauteur est contrôlée par un curseur, nous ne pouvons donc pas y ajouter d'interrupteur. </font><font style="vertical-align: inherit;">Au lieu de cela, nous pouvons utiliser un commutateur séparé pour activer ou désactiver la modification de la hauteur. </font><font style="vertical-align: inherit;">Par défaut, il sera activé.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyElevation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un nouveau commutateur de hauteur à l'interface utilisateur. </font><font style="vertical-align: inherit;">Je mettrai également tout sur un nouveau panneau et rendrai le curseur de hauteur horizontal pour que l'interface utilisateur soit plus belle.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07d/cab/84d/07dcab84d8e8fe4daac4b6120df34d60.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Couleur et hauteur en option. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour activer la hauteur, nous avons besoin d'une nouvelle méthode, que nous connecterons à l'interface utilisateur.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyElevation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyElevation = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En le connectant au commutateur de hauteur, assurez-vous que la méthode bool dynamique est utilisée en haut de la liste des méthodes. </font><font style="vertical-align: inherit;">Les versions correctes n'affichent pas de coche dans l'inspecteur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/d5b/1b2/887d5b1b275cb18957b63bcbecf145d4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous transmettons l'état de l'interrupteur de hauteur. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons choisir uniquement la coloration avec des fleurs ou seulement la hauteur. </font><font style="vertical-align: inherit;">Ou les deux, comme d'habitude. </font><font style="vertical-align: inherit;">Nous pouvons même choisir de ne changer ni l'un ni l'autre, mais pour l'instant cela ne nous est pas particulièrement utile.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basculez entre la couleur et la hauteur.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi la hauteur s'éteint-elle lors du choix d'une couleur?</font></font></b> <div class="spoiler_text">  ,       toggle group. ,          ,     toggle group. </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Taille du pinceau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour prendre en charge la taille du pinceau redimensionnable, ajoutez une variable entière </font></font><code>brushSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et une méthode pour la définir via l'interface utilisateur. </font><font style="vertical-align: inherit;">Nous allons utiliser le curseur, donc encore une fois nous devrons convertir la valeur de float en int.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brushSize; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetBrushSize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size</span></span></span><span class="hljs-function">)</span></span> { brushSize = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)size; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/794/bfb/60f/794bfb60f2f1c777fa0363ede3f19540.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curseur de taille de brosse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez créer un nouveau curseur en dupliquant le curseur de hauteur. </font><font style="vertical-align: inherit;">Modifiez sa valeur maximale à 4 et associez-la à la méthode correspondante. </font><font style="vertical-align: inherit;">Je lui ai également ajouté un tag.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88e/8b2/f58/88e8b2f58abfd48657387e6670c51215.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paramètres du curseur de taille de pinceau. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous pouvons éditer plusieurs cellules en même temps, nous devons utiliser la méthode </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cette méthode fera appel </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à toutes les cellules impliquées. </font><font style="vertical-align: inherit;">La cellule initialement sélectionnée sera considérée comme le centre du pinceau.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCells(hexGrid.GetCell(hit.point)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La taille du pinceau détermine le rayon de l'édition. </font><font style="vertical-align: inherit;">Avec un rayon de 0, ce ne sera qu'une seule cellule centrale. </font><font style="vertical-align: inherit;">Avec un rayon de 1, ce sera le centre et ses voisins. </font><font style="vertical-align: inherit;">Dans un rayon de 2, les voisins du centre et leurs voisins immédiats sont allumés.</font></font> Et ainsi de suite. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/14d/b65/61214db6508869c0ceda156c103ca032.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'au rayon 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour modifier des cellules, vous devez les contourner en boucle. </font><font style="vertical-align: inherit;">Nous avons d'abord besoin des coordonnées X et Z du centre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous trouvons la coordonnée Z minimale en soustrayant le rayon. </font><font style="vertical-align: inherit;">Nous définissons donc la ligne zéro. </font><font style="vertical-align: inherit;">À partir de cette ligne, nous bouclons jusqu'à ce que nous couvrions la ligne au centre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La première cellule de la ligne inférieure a la même coordonnée X que la cellule centrale. </font><font style="vertical-align: inherit;">Cette coordonnée diminue avec l'augmentation du nombre de lignes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La dernière cellule a toujours une coordonnée X égale à la coordonnée centrale plus le rayon. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons boucler autour de chaque ligne et obtenir des cellules par leurs coordonnées.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - r; x &lt;= centerX + brushSize; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'avons pas encore de méthode </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un paramètre de coordonnées, alors créez-le. </font><font style="vertical-align: inherit;">Convertissez les coordonnées des déplacements et obtenez la cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = coordinates.X + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[x + z * cellCountX]; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/490/9f2/b594909f28de1c2d52c954d312d7b90f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La partie inférieure de la brosse, taille 2.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous couvrons le reste de la brosse en effectuant un cycle de haut en bas jusqu'au centre. </font><font style="vertical-align: inherit;">Dans ce cas, la logique est mise en miroir et la ligne centrale doit être exclue.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - r; x &lt;= centerX + brushSize; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ + brushSize; z &gt; centerZ; z--, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - brushSize; x &lt;= centerX + r; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e8/add/c7c/9e8addc7cf0012210cdd5dc0588bc6cf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le pinceau entier, taille 2.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cela fonctionne, à moins que notre pinceau ne dépasse les limites de la grille. </font><font style="vertical-align: inherit;">Lorsque cela se produit, nous obtenons une exception d'index hors plage. </font><font style="vertical-align: inherit;">Pour éviter cela, vérifiez les limites </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et revenez </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsqu'une cellule inexistante est demandée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || z &gt;= cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = coordinates.X + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt;= cellCountX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[x + z * cellCountX]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour éviter l'exception de référence nulle, il </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit vérifier avant de modifier si la cellule existe vraiment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisation de plusieurs tailles de pinceau. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basculer la visibilité des libellés de cellule </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus souvent qu'autrement, nous n'avons pas besoin de voir les étiquettes des cellules. </font><font style="vertical-align: inherit;">Rendons-les donc facultatifs. </font><font style="vertical-align: inherit;">Puisque chaque fragment contrôle son propre canevas, ajoutez une méthode </font></font><code>ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lorsque l'interface utilisateur doit être visible, nous activons le canevas. </font><font style="vertical-align: inherit;">Sinon, désactivez-le.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { gridCanvas.gameObject.SetActive(visible); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cachons l'interface utilisateur par défaut. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; ShowUI(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que la visibilité de l'interface utilisateur est commutée pour l'ensemble de la carte, nous ajoutons la méthode </font></font><code>ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il transmet simplement la demande à ses fragments.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].ShowUI(visible); } }</code> </pre> <br> <code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> obtient la même méthode, en passant la demande à la grille. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { hexGrid.ShowUI(visible); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enfin, nous pouvons ajouter un commutateur à l'interface utilisateur et le connecter. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/120/637/740/120637740d174168d298407ec129c0d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commutateur de visibilité des balises. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 6: rivières </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajout de rivières aux cellules. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faites glisser et déposez le support pour dessiner des rivières. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Création de lits de rivière. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisation de plusieurs maillages par fragment. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Créez un pool de listes partagées. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation et animation de l'eau qui coule. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la partie précédente, nous avons parlé de la prise en charge de grandes cartes. </font><font style="vertical-align: inherit;">Nous pouvons maintenant passer à des éléments de relief plus grands. </font><font style="vertical-align: inherit;">Cette fois, nous parlerons des rivières.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e66/4fb/56ae664fb799dd59d5d8e85397945937.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les rivières coulent des montagnes.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cellules fluviales </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il existe trois façons d'ajouter des rivières à une grille d'hexagones. La première consiste à les laisser passer de cellule en cellule. C'est ainsi qu'il est implémenté dans Endless Legend. La deuxième façon consiste à leur permettre de circuler entre les cellules, d'un bord à l'autre. Il est donc implémenté dans Civilization 5. La troisième façon n'est pas de créer des structures fluviales spéciales, mais d'utiliser des cellules d'eau pour les suggérer. Les rivières sont donc implémentées dans Age of Wonders 3. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans notre cas, les bords des cellules sont déjà occupés par des pentes et des falaises. Cela laisse peu de place aux rivières. Par conséquent, nous les ferons passer de cellule en cellule. Cela signifie que dans chaque cellule, il n'y aura pas de rivière, ou qu'une rivière coulera le long de celle-ci, ou qu'il y aura un début ou une fin de rivière en elle. Dans les cellules le long desquelles la rivière coule, elle peut couler directement, faire un tour d'un pas ou deux pas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/db2/2a4/e7fdb22a4346f9281865ad95a1946f75.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cinq configurations de rivière possibles. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne soutiendrons pas la ramification ou la fusion de rivières. </font><font style="vertical-align: inherit;">Cela compliquera encore les choses, en particulier l'écoulement de l'eau. </font><font style="vertical-align: inherit;">De plus, nous ne serons pas intrigués par de grands volumes d'eau. </font><font style="vertical-align: inherit;">Nous les considérerons dans un autre tutoriel.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi de la rivière </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cellule le long de laquelle la rivière coule peut être considérée simultanément comme ayant une rivière entrante et sortante. </font><font style="vertical-align: inherit;">S'il contient le début d'une rivière, il n'a alors qu'une rivière sortante. </font><font style="vertical-align: inherit;">Et s'il contient la fin de la rivière, alors il n'a qu'une rivière entrante. </font><font style="vertical-align: inherit;">Nous pouvons stocker ces informations en </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisant deux valeurs booléennes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasIncomingRiver, hasOutgoingRiver;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais cela ne suffit pas. </font><font style="vertical-align: inherit;">Nous devons également connaître la direction de ces rivières. </font><font style="vertical-align: inherit;">Dans le cas d'une rivière sortante, elle indique où elle se déplace. </font><font style="vertical-align: inherit;">Dans le cas d'une rivière entrante, elle indique d'où elle vient.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasIncomingRiver, hasOutgoingRiver; HexDirection incomingRiver, outgoingRiver;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous aurons besoin de ces informations lors de la triangulation des cellules, alors ajoutez des propriétés pour y avoir accès. </font><font style="vertical-align: inherit;">Nous ne prendrons pas en charge leur attribution directe. </font><font style="vertical-align: inherit;">Pour ce faire, nous ajouterons en outre une méthode distincte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasIncomingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasOutgoingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasOutgoingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection IncomingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> incomingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection OutgoingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une question importante est de savoir s'il y a une rivière dans la cellule, quels que soient les détails. </font><font style="vertical-align: inherit;">Par conséquent, ajoutons également une propriété pour cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver || hasOutgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre question logique: c'est le début ou la fin de la rivière dans la cellule. </font><font style="vertical-align: inherit;">Si l'état de la rivière entrante et sortante est différent, alors c'est juste le cas. </font><font style="vertical-align: inherit;">Par conséquent, nous en ferons une autre propriété.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRiverBeginOrEnd { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver != hasOutgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et enfin, il sera utile de savoir si la rivière traverse une certaine crête, qu'elle soit entrante ou sortante. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasRiverThroughEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver &amp;&amp; incomingRiver == direction || hasOutgoingRiver &amp;&amp; outgoingRiver == direction; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enlèvement de la rivière </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de commencer à ajouter une rivière à une cellule, implémentons d'abord la prise en charge de la suppression de la rivière. </font><font style="vertical-align: inherit;">Pour commencer, nous écrirons une méthode pour ne retirer que la partie sortante de la rivière. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il n'y a pas de rivière sortante dans la cellule, alors rien ne doit être fait. </font><font style="vertical-align: inherit;">Sinon, désactivez-le et effectuez la mise à jour.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais ce n'est pas tout. </font><font style="vertical-align: inherit;">La rivière sortante doit se déplacer quelque part. </font><font style="vertical-align: inherit;">Par conséquent, il doit y avoir un voisin avec la rivière entrante. </font><font style="vertical-align: inherit;">Nous devons aussi nous débarrasser d'elle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Refresh(); HexCell neighbor = GetNeighbor(outgoingRiver); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.Refresh(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une rivière ne peut-elle pas sortir d'une carte?</font></font></b> <div class="spoiler_text">      ,     .     ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supprimer une rivière d'une cellule ne change que l'apparence de cette cellule. </font><font style="vertical-align: inherit;">Contrairement à la modification de la hauteur ou de la couleur, cela n'affecte pas les voisins. </font><font style="vertical-align: inherit;">Par conséquent, nous devons mettre à jour uniquement la cellule elle-même, mais pas ses voisins.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshSelfOnly(); HexCell neighbor = GetNeighbor(outgoingRiver); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette méthode </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">met simplement à jour le fragment auquel appartient la cellule. </font><font style="vertical-align: inherit;">Comme nous ne changeons pas la rivière lors de l'initialisation du réseau, nous n'avons pas à nous inquiéter si un fragment a déjà été attribué.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La suppression des rivières entrantes fonctionne de la même manière. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveIncomingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasIncomingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshSelfOnly(); HexCell neighbor = GetNeighbor(incomingRiver); neighbor.hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et la suppression de la rivière entière signifie simplement la suppression des parties entrantes et sortantes de la rivière. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RemoveOutgoingRiver(); RemoveIncomingRiver(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajout de rivières </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour soutenir la création de rivières, nous avons besoin d'une méthode pour spécifier la rivière sortante de la cellule. </font><font style="vertical-align: inherit;">Il doit redéfinir toutes les rivières sortantes précédentes et définir la rivière entrante correspondante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour commencer, nous n'avons rien à faire si la rivière existe déjà.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous devons nous assurer qu'il y a un voisin dans la bonne direction. </font><font style="vertical-align: inherit;">De plus, les rivières ne peuvent pas remonter. </font><font style="vertical-align: inherit;">Par conséquent, nous devons terminer l'opération si le voisin est plus élevé.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || elevation &lt; neighbor.elevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous devons nettoyer la rivière sortante précédente. </font><font style="vertical-align: inherit;">Et nous devons également supprimer la rivière entrante, si elle est superposée à une nouvelle rivière sortante.</font></font><br><br><pre> <code class="cs hljs"> RemoveOutgoingRiver(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasIncomingRiver &amp;&amp; incomingRiver == direction) { RemoveIncomingRiver(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons maintenant passer à la mise en place de la rivière sortante. </font></font><br><br><pre> <code class="cs hljs"> hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; RefreshSelfOnly();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et n'oubliez pas de définir la rivière entrante pour une autre cellule après avoir supprimé sa rivière entrante actuelle, si elle existe. </font></font><br><br><pre> <code class="cs hljs"> neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; neighbor.incomingRiver = direction.Opposite(); neighbor.RefreshSelfOnly();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se débarrasser des rivières qui coulent </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous avons permis d'ajouter uniquement les bonnes rivières, d'autres actions peuvent encore créer les mauvaises. </font><font style="vertical-align: inherit;">Lorsque nous modifions la hauteur de la cellule, nous devons à nouveau nous assurer avec force que les rivières ne peuvent que couler. </font><font style="vertical-align: inherit;">Toutes les rivières irrégulières doivent être supprimées.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasOutgoingRiver &amp;&amp; elevation &lt; GetNeighbor(outgoingRiver).elevation ) { RemoveOutgoingRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasIncomingRiver &amp;&amp; elevation &gt; GetNeighbor(incomingRiver).elevation ) { RemoveIncomingRiver(); } Refresh(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changer les rivières </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour prendre en charge l'édition de la rivière, nous devons ajouter un commutateur de rivière à l'interface utilisateur. </font><font style="vertical-align: inherit;">En fait. </font><font style="vertical-align: inherit;">nous avons besoin de la prise en charge de trois modes d'édition. </font><font style="vertical-align: inherit;">Nous devons soit ignorer les rivières, soit les ajouter, soit les supprimer. </font><font style="vertical-align: inherit;">Nous pouvons utiliser une simple énumération d'aide de commutateurs pour suivre l'état. </font><font style="vertical-align: inherit;">Comme nous ne l'utiliserons qu'à l'intérieur de l'éditeur, nous pouvons le définir à l'intérieur de la classe </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, avec le champ mode rivière.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OptionalToggle { Ignore, Yes, No } OptionalToggle riverMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et nous avons besoin d'une méthode pour changer le régime fluvial via l'interface utilisateur. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRiverMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { riverMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour contrôler le régime de la rivière, ajoutez trois commutateurs à l'interface utilisateur et connectez-les au nouveau groupe de bascule, comme nous l'avons fait avec les couleurs. </font><font style="vertical-align: inherit;">J'ai configuré les commutateurs de sorte que leurs étiquettes soient sous les cases à cocher. </font><font style="vertical-align: inherit;">Pour cette raison, ils resteront suffisamment minces pour s'adapter aux trois options sur une seule ligne.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/1bf/d9c/0f51bfd9ce2a73bc23f1ef99cbd4b24e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fleuves UI</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ne pas utiliser une liste déroulante?</font></font></b> <div class="spoiler_text">  ,    .   dropdown list  Unity        Play.    ,      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reconnaissance par glisser-déposer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour créer une rivière, nous avons besoin à la fois d'une cellule et d'une direction. </font><font style="vertical-align: inherit;">Pour le moment, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne nous fournit pas ces informations. </font><font style="vertical-align: inherit;">Par conséquent, nous devons ajouter la prise en charge du glisser-déposer d'une cellule à l'autre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons savoir si cette traînée sera correcte et également déterminer sa direction. </font><font style="vertical-align: inherit;">Et pour reconnaître le glisser-déposer, nous devons nous souvenir de la cellule précédente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isDrag; HexDirection dragDirection; HexCell previousCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialement, lorsque le glissement n'est pas effectué, la cellule précédente ne l'est pas. </font><font style="vertical-align: inherit;">Autrement dit, lorsqu'il n'y a pas d'entrée ou que nous n'interagissons pas avec la carte, vous devez lui attribuer une valeur </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject() ) { HandleInput(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCells(hexGrid.GetCell(hit.point)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La cellule actuelle est celle que nous avons trouvée en croisant le faisceau avec le maillage. </font><font style="vertical-align: inherit;">Après avoir modifié les cellules, il est mis à jour et devient la cellule précédente pour une nouvelle mise à jour.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); EditCells(currentCell); previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir déterminé la cellule actuelle, nous pouvons la comparer avec la cellule précédente, le cas échéant. </font><font style="vertical-align: inherit;">Si nous obtenons deux cellules différentes, nous pouvons avoir le glisser-déposer correct et nous devons le vérifier. </font><font style="vertical-align: inherit;">Sinon, ce n'est certainement pas un glisser-déposer.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } EditCells(currentCell); previousCell = currentCell; isDrag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment vérifions-nous le glisser-déposer? </font><font style="vertical-align: inherit;">Vérifier si la cellule actuelle est voisine de la précédente. </font><font style="vertical-align: inherit;">Nous vérifions cela en contournant ses voisins dans un cycle. </font><font style="vertical-align: inherit;">Si nous trouvons une correspondance, nous reconnaissons également immédiatement la direction de la traînée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDrag</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell currentCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( dragDirection = HexDirection.NE; dragDirection &lt;= HexDirection.NW; dragDirection++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell.GetNeighbor(dragDirection) == currentCell) { isDrag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allons-nous créer des traînées saccadées?</font></font></b> <div class="spoiler_text">       ,          .         «» ,     . <br><br>    ,   .            . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changer les cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que nous pouvons reconnaître le glisser-déposer, nous pouvons définir les rivières sortantes. </font><font style="vertical-align: inherit;">Nous pouvons également supprimer des rivières; pour cela, le support par glisser-déposer n'est pas nécessaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes) { previousCell.SetOutgoingRiver(dragDirection); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce code dessinera la rivière de la cellule précédente au courant. </font><font style="vertical-align: inherit;">Mais il ignore la taille de la brosse. </font><font style="vertical-align: inherit;">C'est assez logique, mais dessinons les rivières pour toutes les cellules fermées par le pinceau. </font><font style="vertical-align: inherit;">Cela peut être fait en effectuant des opérations sur la cellule modifiée. </font><font style="vertical-align: inherit;">Dans notre cas, nous devons nous assurer qu'une autre cellule existe vraiment.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes) { HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherCell) { otherCell.SetOutgoingRiver(dragDirection); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant éditer les rivières, mais ne les voyons pas encore. </font><font style="vertical-align: inherit;">Nous pouvons vérifier que cela fonctionne en examinant les cellules modifiées dans l'inspecteur de débogage.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/927/46f/4fe92746f97fc517dc0d1da7c0aeee62.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une cellule avec une rivière dans l'inspecteur de débogage.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce qu'un inspecteur de débogage?</font></font></b> <div class="spoiler_text">             .        .    ,     . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lits de rivière entre les cellules </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la triangulation d'une rivière, nous devons considérer deux parties: l'emplacement du lit de la rivière et l'eau qui la traverse. </font><font style="vertical-align: inherit;">Tout d'abord, nous allons créer un canal et quitter l'eau pour plus tard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La partie la plus simple de la rivière est l'endroit où elle coule en jonction entre les cellules. </font><font style="vertical-align: inherit;">Pendant que nous triangulons cette zone avec une bande de trois quadruples. </font><font style="vertical-align: inherit;">Nous pouvons y ajouter un lit de rivière en abaissant le quad central et en ajoutant deux parois de canaux.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/545/b3c/b93/545b3cb9373e9479011916513c3c51da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajout d'une rivière à une bande de côtes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour cela, dans le cas de la rivière, deux quads supplémentaires seront nécessaires et un canal avec deux parois verticales sera créé. </font><font style="vertical-align: inherit;">Une autre approche consiste à utiliser quatre quadruples. </font><font style="vertical-align: inherit;">Ensuite, nous abaissons le pic central pour créer un lit avec des murs en pente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/7d9/ac1/7577d9ac1978be05cbdda0f8925c75d0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toujours quatre quad. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation constante du même nombre de quadrangles est pratique, alors choisissons cette option.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajout de sommets de bord </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La transition de trois à quatre par arête nécessite la création d'un sommet supplémentaire de l'arête. </font><font style="vertical-align: inherit;">Nous réécrivons </font></font><code>EdgeVertices</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en renommant d'abord </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>v5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puis en renommant </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les actions dans cet ordre garantissent que tout le code continue de référencer les bons sommets. </font><font style="vertical-align: inherit;">Utilisez l'option renommer ou refactoriser de votre éditeur pour que les modifications s'appliquent partout. </font><font style="vertical-align: inherit;">Sinon, vous devrez inspecter manuellement l'intégralité du code et apporter des modifications.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v4, v5;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir renommé tout, ajoutez-en un nouveau </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v3, v4, v5;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un nouveau sommet au constructeur. </font><font style="vertical-align: inherit;">Il est situé au milieu entre les sommets des coins. </font><font style="vertical-align: inherit;">De plus, les autres sommets devraient maintenant être en ½ et ¾, et non en &amp; frac13; </font><font style="vertical-align: inherit;">et &amp; frac23;.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); v4 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.75f</span></span>); v5 = corner2; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajouter </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font><font style="vertical-align: inherit;">ajouter </font></font><code>TerraceLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EdgeVertices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices a, EdgeVertices b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { EdgeVertices result; result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step); result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step); result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step); result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step); result.v5 = HexMetrics.TerraceLerp(a.v5, b.v5, step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, je </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dois inclure un sommet supplémentaire dans les triangles en éventail de la nervure.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { AddTriangle(center, edge.v1, edge.v2); AddTriangleColor(color); AddTriangle(center, edge.v2, edge.v3); AddTriangleColor(color); AddTriangle(center, edge.v3, edge.v4); AddTriangleColor(color); AddTriangle(center, edge.v4, edge.v5); AddTriangleColor(color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et aussi dans ses rayures de quadrangles. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2 </span></span></span><span class="hljs-function">)</span></span> { AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); AddQuadColor(c1, c2); AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); AddQuadColor(c1, c2); AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); AddQuadColor(c1, c2); AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); AddQuadColor(c1, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/819/89d/599/81989d5996d7c2832e3dd7f61b4a9bb1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/625/9b1/6a2/6259b16a2776344c51725d32d70001e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparaison de quatre et cinq sommets par arête.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La hauteur du lit de la rivière </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons créé le canal en abaissant le bas en haut de la nervure. </font><font style="vertical-align: inherit;">Il détermine la position verticale du lit de la rivière. </font><font style="vertical-align: inherit;">Bien que la position verticale exacte de chaque cellule soit déformée, nous devons maintenir la même hauteur du lit de la rivière dans les cellules de même hauteur. </font><font style="vertical-align: inherit;">Grâce à cette eau, elle n'a pas à s'écouler en amont. </font><font style="vertical-align: inherit;">De plus, le lit doit être suffisamment bas pour rester en dessous, même dans le cas des cellules verticales les plus déviées, tout en laissant suffisamment de place pour l'eau. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Définissons ce décalage </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et exprimons-le en hauteur. </font><font style="vertical-align: inherit;">Des décalages d'un niveau suffiront.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> streamBedElevationOffset = <span class="hljs-number"><span class="hljs-number">-1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons utiliser cette métrique pour ajouter des propriétés </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour obtenir la position verticale du lit de la rivière cellulaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> StreamBedY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.streamBedElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Création d'une chaîne </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'une </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des six parties triangulaires d'une cellule est triangulée, nous pouvons déterminer si une rivière coule le long de son bord. </font><font style="vertical-align: inherit;">Si c'est le cas, nous pouvons alors abaisser le pic médian de la côte à la hauteur du lit de la rivière.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; } TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0d/a57/028/d0da570288985442d990858b2831c07a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez le sommet médian de la côte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons voir comment apparaissent les premiers signes de la rivière, mais des trous apparaissent dans le relief. </font><font style="vertical-align: inherit;">Pour les fermer, nous devons changer un autre bord, puis trianguler la connexion.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); bridge.y = neighbor.Position.y - cell.Position.y; EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v5 + bridge ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4c/aa9/5f4/b4caa95f424004569e7876bc19c73a20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canaux terminés des articulations des côtes. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lits de rivière passant à travers une cellule </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous avons les bons lits de rivière entre les cellules. Mais lorsque la rivière traverse la cellule, les canaux se terminent toujours en son centre. Pour résoudre ce problème devra travailler. Commençons par le cas où une rivière traverse directement une cellule, d'un bord à l'autre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il n'y a pas de rivière, chaque partie de la cellule peut être un simple éventail de triangles. Mais lorsque la rivière coule directement, il faut insérer un canal. En fait, nous devons étirer le sommet central en une ligne, transformant ainsi les deux triangles du milieu en quadrangles. Puis l'éventail de triangles se transforme en trapèze.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a9/919/ffb/9a9919ffbb99bcded8d44f45e62c3955.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous insérons le canal dans le triangle. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ces canaux seront beaucoup plus longs que ceux passant par la connexion des cellules. </font><font style="vertical-align: inherit;">Cela devient apparent lorsque les positions des sommets sont déformées. </font><font style="vertical-align: inherit;">Par conséquent, divisons le trapèze en deux segments en insérant un autre ensemble d'arêtes de sommet au milieu entre le centre et l'arête.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/f94/109/650f9410923cb781f145b5211dbe4950.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulation des canaux. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que la triangulation avec une rivière sera très différente de la triangulation sans rivière, créons-en une méthode distincte. </font><font style="vertical-align: inherit;">Si nous avons une rivière, nous utilisons cette méthode, sinon nous laisserons un éventail de triangles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; TriangulateWithRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeFan(center, e, cell.Color); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/f0f/526/928f0f526852960fce6c37bdb480b5bc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trous dans lesquels il devrait y avoir des rivières. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour mieux voir ce qui se passe, désactivez temporairement la distorsion cellulaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 4f;</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2aa/f49/ae3/2aaf49ae366805585727f1a1ed11c2aa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pics non déformés.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation directement à travers la cellule </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour créer un canal directement à travers une partie de la cellule, nous devons étirer le centre en ligne. </font><font style="vertical-align: inherit;">Cette ligne doit avoir la même largeur que le canal. </font><font style="vertical-align: inherit;">Nous pouvons trouver le sommet gauche en déplaçant ¼ de la distance du centre au premier coin de la partie précédente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De même pour le sommet droit. </font><font style="vertical-align: inherit;">Dans ce cas, nous avons besoin du deuxième coin de la partie suivante.</font></font><br><br><pre> <code class="cs hljs"> Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; Vector3 centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La ligne médiane peut être trouvée en créant des arêtes de sommet entre le centre et l'arête. </font></font><br><br><pre> <code class="cs hljs"> EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(centerL, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(centerR, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensuite, changez le sommet moyen de la nervure centrale, ainsi que le centre, car ils deviendront les points inférieurs du canal. </font></font><br><br><pre> <code class="cs hljs"> m.v3.y = center.y = e.v3.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons utiliser </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour remplir l'espace entre la ligne médiane et la ligne de bord.</font></font><br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip(m, cell.Color, e, cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ab/050/b30/3ab050b301f8815479142c5b8feae26e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canaux compressés.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Malheureusement, les canaux semblent compressés. Cela se produit car les sommets médians de la nervure sont trop proches les uns des autres. Pourquoi est-ce arrivé? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous supposons que la longueur du bord extérieur est de 1, la longueur de la ligne médiane sera de ½. Étant donné que le bord central est au milieu entre eux, sa longueur doit être égale à ¾. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La largeur du canal est de ½ et doit rester constante. Comme la longueur du bord central est is, il ne reste que ¼, selon &amp; frac18; des deux côtés du canal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e1/25f/037/2e125f03727f078ccfd094a29ad4d596.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Longueurs relatives. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme la longueur du bord central est ¾, alors &amp; frac18; </font><font style="vertical-align: inherit;">devient par rapport à la longueur de la nervure centrale égale à &amp; frac16 ;. </font><font style="vertical-align: inherit;">Cela signifie que ses deuxième et quatrième sommets doivent être interpolés avec des sixièmes, pas des quarts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons fournir un support pour une telle interpolation alternative en ajoutant à </font></font><code>EdgeVertices</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un autre constructeur. </font><font style="vertical-align: inherit;">Au lieu d'interpolations fixes pour </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisons un paramètre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outerStep</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, outerStep); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); v4 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">1f</span></span> - outerStep); v5 = corner2; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant l'utiliser avec &amp; frac16; </font><font style="vertical-align: inherit;">c </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(centerL, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(centerR, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4a/df8/cb5/c4adf8cb5aa6b1685f6d5c592976ea3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaînes directes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir rectifié le canal, nous pouvons passer à la deuxième partie du trapèze. </font><font style="vertical-align: inherit;">Dans ce cas, nous ne pouvons pas utiliser la bande de côtes, nous devons donc le faire manuellement. </font><font style="vertical-align: inherit;">Créons d'abord des triangles sur les côtés.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(centerL, m.v1, m.v2); AddTriangleColor(cell.Color); AddTriangle(centerR, m.v4, m.v5); AddTriangleColor(cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10b/dc7/a5b/10bdc7a5b1d32d03dbc155a2d00bbfb5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangles latéraux. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble bon, remplissons donc l'espace restant avec deux quadrangles, créant la dernière partie du canal.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(centerL, m.v1, m.v2); AddTriangleColor(cell.Color); AddQuad(centerL, center, m.v2, m.v3); AddQuadColor(cell.Color); AddQuad(center, centerR, m.v3, m.v4); AddQuadColor(cell.Color); AddTriangle(centerR, m.v4, m.v5); AddTriangleColor(cell.Color);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, nous n'avons pas d'alternative </font></font><code>AddQuadColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne nécessitant qu'un seul paramètre. </font><font style="vertical-align: inherit;">Alors que nous n'en avions pas besoin. </font><font style="vertical-align: inherit;">Créons-le donc.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { colors.Add(color); colors.Add(color); colors.Add(color); colors.Add(color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af0/b62/c32/af0b62c3232b36cd0a136b1fc009b7dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaînes droites terminées.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Début et fin de la triangulation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La triangulation d'une partie qui n'a que le début ou la fin d'une rivière est assez différente, et nécessite donc sa propre méthode. </font><font style="vertical-align: inherit;">Par conséquent, nous allons vérifier cela </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et appeler la méthode appropriée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { TriangulateWithRiverBeginOrEnd(direction, cell, center, e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithRiver(direction, cell, center, e); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ce cas, nous voulons terminer le canal au centre, mais nous utilisons toujours deux étapes pour cela. </font><font style="vertical-align: inherit;">Par conséquent, nous allons à nouveau créer le bord médian entre le centre ou le bord. </font><font style="vertical-align: inherit;">Puisque nous voulons terminer le canal, nous sommes très heureux qu'il soit compressé.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afin que le canal ne devienne pas trop peu profond, nous assignerons la hauteur du lit de la rivière au pic moyen. </font><font style="vertical-align: inherit;">Mais le centre n'a pas besoin d'être changé.</font></font><br><br><pre> <code class="cs hljs"> m.v3.y = e.v3.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On peut trianguler avec une bande de côtes et un éventail. </font></font><br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip(m, cell.Color, e, cell.Color); TriangulateEdgeFan(center, m, cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16b/0c5/9e0/16b0c59e0999f2a505e709648c1e1af7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Points de départ et d'arrivée.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Virages en une étape </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, considérez les virages serrés qui zigzaguent entre les cellules adjacentes. </font><font style="vertical-align: inherit;">Nous les gérerons aussi </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Par conséquent, nous devons déterminer avec quel type de rivière nous travaillons.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/523/c03/e37/523c03e370096f804df6b84a97dbdfbf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivière Zigzag. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la cellule a une rivière qui coule dans la direction opposée, ainsi que dans la direction avec laquelle nous travaillons, alors ce devrait être une rivière droite. </font><font style="vertical-align: inherit;">Dans ce cas, nous pouvons enregistrer la ligne médiane que nous avons déjà calculée. </font><font style="vertical-align: inherit;">Sinon, il revient à un point, repliant la ligne médiane.</font></font><br><br><pre> <code class="cs hljs"> Vector3 centerL, centerR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/992/4c0/90c9924c049cf8033e7480c90b74b903.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zigzags recourbés. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons reconnaître les virages serrés en vérifiant si la cellule a une rivière traversant la partie suivante ou précédente de la cellule. </font><font style="vertical-align: inherit;">S'il y en a, alors nous devons aligner la ligne centrale avec le bord entre celui-ci et la partie voisine. </font><font style="vertical-align: inherit;">Nous pouvons le faire en plaçant le côté correspondant de la ligne au milieu entre le centre et l'angle commun. </font><font style="vertical-align: inherit;">L'autre côté de la ligne devient alors le centre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Après avoir décidé où se trouvent les points gauche et droit, nous pouvons déterminer le centre résultant en les faisant la moyenne. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { … } center = Vector3.Lerp(centerL, centerR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f14/cc6/4f9/f14cc64f953da69fb270ff2adf613b2e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Côte centrale décalée. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que le canal ait la même largeur des deux côtés, il semble assez compressé. </font><font style="vertical-align: inherit;">Cela est dû au fait de tourner la ligne médiane de 60 °. </font><font style="vertical-align: inherit;">Vous pouvez lisser cet effet en augmentant légèrement la largeur de la ligne centrale. </font><font style="vertical-align: inherit;">Au lieu d'interpoler avec ½, nous utilisons &amp; frac23 ;.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/c01/ea3/28cc01ea3d203243a1dfe49cde5e9802.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zigzag sans compression.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Virages en deux étapes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les autres cas se situent entre des zigzags et des rivières droites. </font><font style="vertical-align: inherit;">Ce sont des virages en deux étapes qui créent des rivières légèrement courbes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67d/bab/9b2/67dbab9b235833d69b3201c9b38ac653.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La rivière sinueuse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour distinguer entre deux orientations possibles, nous devons utiliser </font></font><code>direction.Next().Next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais nous allons en ajoutant le </font><font style="vertical-align: inherit;">rendre plus pratique des </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthodes d'extension </font></font><code>Next2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Previous2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Previous2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { direction -= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &gt;= HexDirection.NE ? direction : (direction + <span class="hljs-number"><span class="hljs-number">6</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { direction += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &lt;= HexDirection.NW ? direction : (direction - <span class="hljs-number"><span class="hljs-number">6</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retour à </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Maintenant, nous pouvons reconnaître la direction de notre rivière sinueuse avec </font></font><code>direction.Next2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans ces deux derniers cas, nous devons déplacer la ligne médiane vers la partie de la cellule située à l'intérieur de la courbe. </font><font style="vertical-align: inherit;">Si nous avions un vecteur au milieu d'un bord solide, nous pourrions l'utiliser pour positionner le point final. </font><font style="vertical-align: inherit;">Imaginons que nous ayons une méthode pour cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = center; centerR = center + HexMetrics.GetSolidEdgeMiddle(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = center + HexMetrics.GetSolidEdgeMiddle(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sûr, nous devons maintenant ajouter une telle méthode à </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il lui suffit de faire la moyenne de deux vecteurs d'angles adjacents et d'appliquer le coefficient d'intégrité.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSolidEdgeMiddle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * solidFactor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be1/058/429/be1058429e3d36cd25b8e1da0c1be77a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Courbes légèrement compressées. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos axes médians sont maintenant correctement tournés de 30 °. </font><font style="vertical-align: inherit;">Mais ils ne sont pas assez longs, c'est pourquoi les canaux sont un peu compressés. </font><font style="vertical-align: inherit;">Cela se produit parce que le milieu de la côte est plus proche du centre que l'angle de la côte. </font><font style="vertical-align: inherit;">Sa distance est égale au rayon intérieur, pas à l'extérieur. </font><font style="vertical-align: inherit;">Autrement dit, nous travaillons à la mauvaise échelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous convertissons déjà le rayon externe en rayon interne à </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous devons effectuer l'opération inverse. </font><font style="vertical-align: inherit;">Rendons donc les deux facteurs de conversion disponibles via </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerToInner = <span class="hljs-number"><span class="hljs-number">0.866025404f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerToOuter = <span class="hljs-number"><span class="hljs-number">1f</span></span> / outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerRadius = <span class="hljs-number"><span class="hljs-number">10f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant passer à la bonne échelle </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les chaînes resteront encore un peu serrées à cause de leur tour, mais cela est beaucoup moins prononcé que dans le cas des zigzags. </font><font style="vertical-align: inherit;">Par conséquent, nous n'avons pas besoin de compenser cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = center; centerR = center + HexMetrics.GetSolidEdgeMiddle(direction.Next()) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * HexMetrics.innerToOuter); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = center + HexMetrics.GetSolidEdgeMiddle(direction.Previous()) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * HexMetrics.innerToOuter); centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a2/849/49c/2a284949c066c558391613611b93d093.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Courbes lisses. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation au voisinage des rivières </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos rivières sont prêtes. </font><font style="vertical-align: inherit;">Mais nous n'avons pas encore triangulé d'autres parties des cellules contenant les rivières. </font><font style="vertical-align: inherit;">Nous allons maintenant fermer ces trous.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f47/5fd/74d/f475fd74d147a577e8adb72cd1ff63fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trous près des canaux. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la cellule a une rivière, mais qu'elle ne coule pas dans la direction actuelle, alors </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous appellerons une nouvelle méthode dans.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { TriangulateWithRiverBeginOrEnd(direction, cell, center, e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateAdjacentToRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeFan(center, e, cell.Color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cette méthode, nous remplissons le triangle cellulaire avec une bande et un ventilateur. </font><font style="vertical-align: inherit;">Un simple ventilateur ne nous suffira pas, car les pics doivent correspondre au bord médian des parties contenant la rivière.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); TriangulateEdgeStrip(m, cell.Color, e, cell.Color); TriangulateEdgeFan(center, m, cell.Color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/059/4df/7bb/0594df7bb3225d20852c9e0d0d708101.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Superposition dans les courbes et les rivières droites.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Faire correspondre la chaîne </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sûr, nous devons faire correspondre le centre que nous utilisons à la partie centrale utilisée par les parties de la rivière. </font><font style="vertical-align: inherit;">Avec les zigzags, tout est en ordre, et les courbes et les rivières droites nécessitent de l'attention. </font><font style="vertical-align: inherit;">Par conséquent, nous devons déterminer à la fois le type de rivière et son orientation relative. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commençons par vérifier si nous sommes à l'intérieur de la courbe. </font><font style="vertical-align: inherit;">Dans ce cas, les directions précédente et suivante contiennent la rivière. </font><font style="vertical-align: inherit;">Si c'est le cas, nous devons déplacer le centre vers le bord.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } } EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/016/620/d89/016620d89847368d487d49bb1c81cdc7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correction d'un cas où la rivière coulait des deux côtés. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si nous avons une rivière dans une direction différente, mais pas dans la précédente, alors nous vérifions si elle est droite. </font><font style="vertical-align: inherit;">Si c'est le cas, déplacez le centre vers le premier coin.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous2()) ) { center += HexMetrics.GetFirstSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1d/85a/366/a1d85a3669a55984eb69a43af5e8631f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correction d'une demi-superposition avec une rivière droite. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc résolu le problème avec la moitié des parties adjacentes aux rivières droites. </font><font style="vertical-align: inherit;">Le dernier cas - nous avons une rivière dans la direction précédente, et elle est droite. </font><font style="vertical-align: inherit;">Dans ce cas, vous devez déplacer le centre vers le coin suivant.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous2()) ) { center += HexMetrics.GetFirstSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous()) &amp;&amp; cell.HasRiverThroughEdge(direction.Next2()) ) { center += HexMetrics.GetSecondSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9d/d1a/20c/c9dd1a20c213658aeed27b9065e6bf58.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Plus de superpositions. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Généralisation HexMesh </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons terminé la triangulation des canaux. </font><font style="vertical-align: inherit;">Maintenant, nous pouvons les remplir d'eau. </font><font style="vertical-align: inherit;">Étant donné que l'eau est différente de la terre, nous devrons utiliser un maillage différent avec différentes données de sommet et différents matériaux. </font><font style="vertical-align: inherit;">Ce serait très pratique si nous pouvions utiliser à la </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fois des sushis et de l'eau. </font><font style="vertical-align: inherit;">Généralisons donc </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la transformant en une classe qui traite de ces maillages, quelle que soit leur utilisation. </font><font style="vertical-align: inherit;">Nous passerons la tâche de trianguler ses cellules </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Déplacer la méthode Perturb </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que la méthode est </font></font><code>Perturb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assez généralisée et sera utilisée à différents endroits, déplaçons-la </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tout d'abord, renommez-le en </font></font><code>HexMetrics.Perturb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il s'agit d'un nom de méthode incorrect, mais il refacture tout le code pour son utilisation appropriée. </font><font style="vertical-align: inherit;">Si votre éditeur de code possède des fonctionnalités spéciales pour déplacer des méthodes, utilisez-le. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En déplaçant la méthode vers l'intérieur </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, rendez-la générale et statique, puis corrigez son nom.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * cellPerturbStrength; position.z += (sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * cellPerturbStrength; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Déplacement des méthodes de triangulation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le changement de variables </font></font><code>hexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans la variable partagée </font></font><code>terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain; <span class="hljs-comment"><span class="hljs-comment">// HexMesh hexMesh; void Awake () { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); // hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = new HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; ShowUI(false); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous refactorisons toutes les méthodes </font></font><code>Add…</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>terrain.Add…</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Déplacez ensuite toutes les méthodes </font></font><code>Triangulate…</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vers </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Après cela, vous pouvez corriger les noms des méthodes </font></font><code>Add…</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et les rendre généraux. </font><font style="vertical-align: inherit;">En conséquence, toutes les méthodes de triangulation complexes seront trouvées </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et les méthodes simples pour ajouter des données au maillage resteront </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'avons pas encore fini. </font><font style="vertical-align: inherit;">Maintenant, il </font></font><code>HexGridChunk.LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait appeler sa propre méthode </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En outre, il ne doit plus passer de cellules en argument. </font><font style="vertical-align: inherit;">Par conséquent, il </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut perdre son paramètre. </font><font style="vertical-align: inherit;">Et il doit déléguer le nettoyage et l'application des données de maillage </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Triangulate(); <span class="hljs-comment"><span class="hljs-comment">// hexMesh.Triangulate(cells); enabled = false; } public void Triangulate () { terrain.Clear(); // hexMesh.Clear(); // vertices.Clear(); // colors.Clear(); // triangles.Clear(); for (int i = 0; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); // hexMesh.vertices = vertices.ToArray(); // hexMesh.colors = colors.ToArray(); // hexMesh.triangles = triangles.ToArray(); // hexMesh.RecalculateNormals(); // meshCollider.sharedMesh = hexMesh; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez les méthodes nécessaires </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices.Clear(); colors.Clear(); triangles.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); hexMesh.SetColors(colors); hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); hexMesh.RecalculateNormals(); meshCollider.sharedMesh = hexMesh; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'en est-il de SetVertices, SetColors et SetTriangles?</font></font></b> <div class="spoiler_text">        <code>Mesh</code> .        .  ,           . <br><br>  <code>SetTriangles</code>    integer,    .      ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, attachez manuellement l'enfant du maillage au préfabriqué de fragment. </font><font style="vertical-align: inherit;">Nous ne pouvons plus le faire automatiquement, car nous ajouterons bientôt un deuxième enfant au maillage. </font><font style="vertical-align: inherit;">Renommez-le en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrain</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour indiquer son objectif.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/614/3b4/0dc/6143b40dc88ecec6761348d9e6208944.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attribuez un relief.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renommer un enfant préfabriqué ne fonctionne pas?</font></font></b> <div class="spoiler_text">          .    ,   .  ,     <em>Apply</em> ,       .        . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Création de pools de listes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que nous ayons déplacé un peu de code, notre carte devrait toujours fonctionner de la même manière qu'auparavant. </font><font style="vertical-align: inherit;">L'ajout d'un autre maillage au fragment ne changera rien à cela. </font><font style="vertical-align: inherit;">Mais si nous faisons cela avec le présent </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, des erreurs peuvent survenir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le problème est que nous avons supposé que nous ne travaillerions qu'avec un maillage à la fois. </font><font style="vertical-align: inherit;">Cela nous a permis d'utiliser des listes statiques pour stocker des données de maillage temporaires. </font><font style="vertical-align: inherit;">Mais après avoir ajouté de l'eau, nous travaillerons simultanément avec deux mailles, nous ne pourrons donc plus utiliser de listes statiques. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, nous ne reviendrons pas sur les ensembles de listes pour chaque instance </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Au lieu de cela, nous utilisons un pool de listes statiques. </font><font style="vertical-align: inherit;">Par défaut, ce pool n'existe pas, commençons donc par créer nous-mêmes une classe de pool de liste commune.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListPool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment fonctionne ListPool &lt;T&gt;?</font></font></b> <div class="spoiler_text">     ,  <code>List&lt;int&gt;</code>    .  <code>&lt;T&gt;</code>    <code>ListPool</code> ,  ,    .      ,    <code>T</code> (  template). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour stocker une collection de listes dans un pool, nous pouvons utiliser la pile. </font><font style="vertical-align: inherit;">Je n'utilise généralement pas de listes car Unity ne les sérialise pas, mais dans ce cas, cela n'a pas d'importance.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListPool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Stack&lt;List&lt;T&gt;&gt; stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;List&lt;T&gt;&gt;(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que signifie stack &lt;list &lt;t&gt;&gt;?</font></font></b> <div class="spoiler_text">     .  ,     .      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une méthode statique commune pour obtenir la liste du pool. </font><font style="vertical-align: inherit;">Si la pile n'est pas vide, nous allons extraire la liste du haut et retourner celle-ci. </font><font style="vertical-align: inherit;">Sinon, nous créerons une nouvelle liste en place.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stack.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stack.Pop(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour réutiliser des listes, vous devez les ajouter au pool une fois que vous avez fini de travailler avec elles. </font></font><code>ListPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effacera la liste et la poussera sur la pile.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;T&gt; list</span></span></span><span class="hljs-function">)</span></span> { list.Clear(); stack.Push(list); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons utiliser les piscines dans </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Remplacez les listes statiques par des liens privés non statiques. </font><font style="vertical-align: inherit;">Marquons-les </font></font><code>NonSerialized</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour que Unity ne les conserve pas lors de la recompilation. </font><font style="vertical-align: inherit;">Ou écrivez </font></font><code>System.NonSerialized</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou ajoutez </font></font><code>using System;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au début du script.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">NonSerialized</span></span>] List&lt;Vector3&gt; vertices; [NonSerialized] List&lt;Color&gt; colors; [NonSerialized] List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles; <span class="hljs-comment"><span class="hljs-comment">// static List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;(); // static List&lt;Color&gt; colors = new List&lt;Color&gt;(); // static List&lt;int&gt; triangles = new List&lt;int&gt;();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puisque le maillage est nettoyé juste avant d'y ajouter de nouvelles données, c'est ici que vous devez obtenir les listes des pools. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); colors = ListPool&lt;Color&gt;.Get(); triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Après avoir appliqué ces maillages, nous n'en avons plus besoin, nous pouvons donc les ajouter ici aux pools. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Add(triangles); hexMesh.RecalculateNormals(); meshCollider.sharedMesh = hexMesh; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous avons donc mis en œuvre plusieurs utilisations des listes, quel que soit le nombre de mailles que nous remplissons en même temps. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Collisionneur en option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que notre terrain ait besoin d'un collisionneur, il n'est pas vraiment nécessaire pour les rivières. </font><font style="vertical-align: inherit;">Les rayons traversent simplement l'eau et se croisent avec le canal en dessous. </font><font style="vertical-align: inherit;">Faisons en sorte que nous puissions configurer la présence d'un collisionneur pour </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous le réalisons en ajoutant un champ commun </font></font><code>bool useCollider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour le terrain, nous l'activons.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/f19/a3c/4e7f19a3c7eb01a1432618a8be6903e5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation d'un collisionneur de mailles. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons créer et affecter le collisionneur uniquement lorsqu'il est activé.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCollider) { meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); } hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCollider) { meshCollider.sharedMesh = hexMesh; } … }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Couleurs en option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les couleurs des sommets peuvent également être facultatives. </font><font style="vertical-align: inherit;">Nous en avons besoin pour démontrer différents types de relief, mais l'eau ne change pas de couleur. </font><font style="vertical-align: inherit;">Nous pouvons les rendre facultatifs tout comme nous avons rendu le collisionneur facultatif.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { colors = ListPool&lt;Color&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); } … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bien sûr, le terrain doit utiliser les couleurs des sommets, alors activez-les. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/624/c01/bbd/624c01bbda8ad0250747b9c1af852590.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de couleurs.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UV en option </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendant ce temps, nous pouvons également ajouter la prise en charge des coordonnées UV facultatives. </font><font style="vertical-align: inherit;">Bien que le relief ne les utilise pas, nous en aurons besoin pour l'eau.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates; [NonSerialized] List&lt;Vector2&gt; uvs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { colors = ListPool&lt;Color&gt;.Get(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">0</span></span>, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } … }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/a99/559/b01a9955989cdc83a2e8de2582c1cbeb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous n'utilisons pas de coordonnées UV. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour utiliser cette fonction, créez des méthodes pour ajouter des coordonnées UV aux triangles et quadrangles.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(uv1); uvs.Add(uv2); uvs.Add(uv3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3, Vector3 uv4</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(uv1); uvs.Add(uv2); uvs.Add(uv3); uvs.Add(uv4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutons une méthode supplémentaire </font></font><code>AddQuadUV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour ajouter facilement une zone UV rectangulaire. </font><font style="vertical-align: inherit;">C'est le cas standard lorsque le quad et sa texture sont les mêmes, nous l'utiliserons pour l'eau de la rivière.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMax, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMax</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMin)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMin)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMax)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMax)); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivières actuelles </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enfin, il est temps de créer de l'eau! </font><font style="vertical-align: inherit;">Nous le ferons avec un quad, qui indiquera la surface de l'eau. </font><font style="vertical-align: inherit;">Et puisque nous travaillons avec les rivières, l'eau doit couler. </font><font style="vertical-align: inherit;">Pour ce faire, nous utilisons des coordonnées UV indiquant l'orientation de la rivière. </font><font style="vertical-align: inherit;">Pour visualiser cela, nous avons besoin d'un nouveau shader. </font><font style="vertical-align: inherit;">Par conséquent, créez un nouveau shader standard et appelez-le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Modifiez-le pour que les coordonnées UV soient enregistrées dans les canaux d'albédo vert et rouge.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/River" { … <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez au </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ général </font></font><code>HexMesh rivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous le nettoyons et l'appliquons de la même manière qu'en cas de relief.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aurons-nous des appels de tirage supplémentaires, même si nous n'avons pas de rivières?</font></font></b> <div class="spoiler_text">  Unity  ,        .     ,  -  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez le préfabriqué (via l'instance), dupliquez son objet terrain, renommez-le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et connectez-le.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/0d6/680/efd0d66801d78d636d07f59b34e5c615.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e46/119/b43/e46119b43f4cd398d96261715975a36a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment préfabriqué avec rivières. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez le matériau </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à l' </font><font style="vertical-align: inherit;">aide de notre nouveau shader et faites en sorte que l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers l'</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilise </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous avons également configuré le composant maillage hexagonal de l'objet afin qu'il utilise les coordonnées UV, mais pas les couleurs de sommet ni le collisionneur.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7df/db6/134/7dfdb6134b4dc27d843db92492b61708.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sous-objet Rivers.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trianguler l'eau </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avant de pouvoir trianguler l'eau, nous devons déterminer le niveau de sa surface. </font><font style="vertical-align: inherit;">Faisons un changement de hauteur </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comme nous l'avons fait avec le lit de la rivière. </font><font style="vertical-align: inherit;">Étant donné que la distorsion verticale de la cellule est égale à la moitié du décalage de hauteur, utilisons-la pour déplacer la surface de la rivière. </font><font style="vertical-align: inherit;">Nous garantissons donc que l'eau ne sera jamais au-dessus de la topographie de la cellule.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> riverSurfaceElevationOffset = <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi ne pas le faire un peu plus bas?</font></font></b> <div class="spoiler_text">          ,   . ,         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriété pour obtenir la position verticale de la surface de sa rivière.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RiverSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.riverSurfaceElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons travailler </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font><font style="vertical-align: inherit;">Puisque nous allons créer de nombreux quadrilatères de rivières, ajoutons une méthode distincte pour cela. </font><font style="vertical-align: inherit;">Donnons-lui quatre sommets et une hauteur comme paramètres. </font><font style="vertical-align: inherit;">Cela nous permettra de définir commodément la position verticale des quatre sommets simultanément avant d'ajouter un quad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = v3.y = v4.y = y; rivers.AddQuad(v1, v2, v3, v4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ajouterons ici les coordonnées UV du quadrilatère. </font><font style="vertical-align: inherit;">Il suffit de faire le tour de gauche à droite et de bas en haut.</font></font><br><br><pre> <code class="cs hljs"> rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br> <code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- C'est la première méthode à laquelle nous ajouterons les quadrangles des rivières. </font><font style="vertical-align: inherit;">Le premier quad se situe entre le centre et le milieu. </font><font style="vertical-align: inherit;">Le second est entre le milieu et la côte. </font><font style="vertical-align: inherit;">Nous utilisons simplement les sommets que nous avons déjà. </font><font style="vertical-align: inherit;">Étant donné que ces pics seront sous-estimés, l'eau sera par conséquent partiellement sous les parois inclinées du canal. </font><font style="vertical-align: inherit;">Par conséquent, nous n'avons pas à nous soucier de la position exacte du bord de l'eau.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … TriangulateRiverQuad(centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY); TriangulateRiverQuad(m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/418/a40/e9c/418a40e9c73fd3da885ce467e475ff63.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Les premiers signes d'eau. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi la largeur de l'eau change-t-elle?</font></font></b> <div class="spoiler_text">  ,     ,      — .           .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se déplacer avec le flux </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actuellement, les coordonnées UV ne sont pas cohérentes avec la direction de la rivière. </font><font style="vertical-align: inherit;">Nous devons maintenir la cohérence ici. </font><font style="vertical-align: inherit;">Supposons que la coordonnée U soit 0 sur le côté gauche de la rivière et 1 sur la droite, en regardant en aval. </font><font style="vertical-align: inherit;">Et la coordonnée V devrait varier de 0 à 1 en direction de la rivière. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En utilisant cette spécification, les UV seront corrects lors de la triangulation de la rivière sortante, mais ils se révéleront incorrects et devront être retournés lors de la triangulation de la rivière entrante. </font><font style="vertical-align: inherit;">Pour simplifier le travail, ajoutez au </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paramètre </font></font><code>bool reversed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Utilisez-le pour retourner les UV si nécessaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = v3.y = v4.y = y; rivers.AddQuad(v1, v2, v3, v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous savons que nous devons tourner la direction, lorsqu'il s'agit de rivière entrant.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, reversed ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, reversed );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/546/c86/e9d/546c86e9d2d8752caa30523098283542.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La direction convenue des rivières.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le début et la fin de la rivière </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À l'intérieur, </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous devons seulement vérifier si nous avons une rivière entrante pour déterminer la direction du débit. </font><font style="vertical-align: inherit;">Ensuite, nous pouvons insérer une autre rivière quad entre le milieu et la côte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, reversed ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La partie entre le centre et le milieu est un triangle, nous ne pouvons donc pas l'utiliser </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La seule différence significative ici est que le pic central est au milieu de la rivière. </font><font style="vertical-align: inherit;">Par conséquent, sa coordonnée U est toujours égale à ½.</font></font><br><br><pre> <code class="cs hljs"> center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c04/07f/539/c0407f539ce2ff6a91081e84062a4097.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'eau au début et à la fin.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y a-t-il des portions d'eau manquantes aux extrémités?</font></font></b> <div class="spoiler_text">       ,   quad  ,     .           .           . <br><br>      ,  .     ,      .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flux entre les cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de l'ajout d'eau entre les cellules, nous devons faire attention à la différence de hauteur. </font><font style="vertical-align: inherit;">Pour que l'eau puisse descendre les pentes et les falaises, elle </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit supporter deux paramètres de hauteur. </font><font style="vertical-align: inherit;">Ajoutons donc un deuxième.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = y1; v3.y = v4.y = y2; rivers.AddQuad(v1, v2, v3, v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aussi, pour plus de commodité, ajoutons une option qui recevra une hauteur. </font><font style="vertical-align: inherit;">Il appellera simplement une autre méthode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, reversed); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons ajouter quad river et in </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Étant entre les cellules, nous ne pouvons pas immédiatement savoir de quel type de rivière il s'agit. </font><font style="vertical-align: inherit;">Pour déterminer si un virage est nécessaire, nous devons vérifier si nous avons une rivière entrante et si elle se déplace dans notre direction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/1f2/62e/2831f262ed46e82bebabf45d0a8215f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La rivière terminée.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Étirement des coordonnées V </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à présent, dans chaque segment de la rivière, nous avons des coordonnées V allant de 0 à 1. Autrement dit, il n'y en a que quatre sur la cellule. Cinq si l'on ajoute également des connexions entre les cellules. Tout ce que nous utilisons pour texturer la rivière, il doit être répété autant de fois. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons réduire le nombre de répétitions en étirant les coordonnées V pour qu'elles passent de 0 à 1 dans toute la cellule plus une connexion. Cela peut être fait en augmentant la coordonnée V dans chaque segment de 0,2. Si nous mettons 0,4 au centre, au milieu, cela deviendra 0,6 et sur le bord, il atteindra 0,8. Ensuite, dans la connexion de cellule, la valeur sera 1.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la rivière coule dans la direction opposée, nous pouvons toujours mettre 0,4 au centre, mais au milieu, elle devient 0,2, et sur le bord - 0. Si nous continuons jusqu'à ce que la cellule se rejoigne, nous obtenons -0,2 en conséquence. </font><font style="vertical-align: inherit;">Ceci est normal car il est similaire à 0,8 pour une texture avec mode de filtrage répété, tout comme 0 équivaut à 1.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22e/4de/cd9/22e4decd99e9c2f0c9312be9eaaceb9a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changement de coordonnées V.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour créer un support pour cela, nous devons ajouter </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un paramètre supplémentaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lorsque la direction n'est pas inversée, nous utilisons simplement les coordonnées transmises au bas du quadrilatère et ajoutons 0,2 en haut. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, v, v + <span class="hljs-number"><span class="hljs-number">0.2f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous pouvons travailler avec une direction inversée en soustrayant les coordonnées de 0,8 et 0,6. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span> - v, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> - v); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous devons transmettre les coordonnées correctes, comme s'il s'agissait d'un fleuve sortant. </font><font style="vertical-align: inherit;">Commençons par </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, reversed ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modifiez ensuite </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comme suit.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et enfin </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed ); center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44e/786/63f/44e78663f2d77264660f30917a5e1a94.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordonnées V étirées.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour afficher correctement le pliage des coordonnées V, assurez-vous qu'elles restent positives dans le shader de la rivière.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y += <span class="hljs-number"><span class="hljs-number">1</span></span>; } o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/30e/a84/aec30ea849af0c8ba42cd6e0cef44635.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordonnées </font></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">réduites </font></a><i><font style="vertical-align: inherit;">V. </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">package d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Animation fluviale </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir fini avec les coordonnées UV, nous pouvons passer à l'animation des rivières. Le shader de rivière le fera pour que nous n'ayons pas à mettre à jour constamment le maillage. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne créerons pas de shader de rivière complexe dans ce tutoriel, mais nous le ferons plus tard. Pour l'instant, nous allons créer un effet simple qui permet de comprendre le fonctionnement de l'animation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'animation est créée en décalant les coordonnées V en fonction de l'heure de la partie. Unity vous permet d'obtenir sa valeur à l'aide d'une variable </font></font><code>_Time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sa composante Y contient le temps inchangé, que nous utilisons. D'autres composants contiennent des échelles de temps différentes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons nous débarrasser du pliage le long de V, car nous n'en avons plus besoin. Au lieu de cela, nous soustrayons l'heure actuelle de la coordonnée V. Cela déplace la coordonnée vers le bas, ce qui crée l'illusion du courant qui coule en aval de la rivière.</font></font><br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y += <span class="hljs-number"><span class="hljs-number">1</span></span>; // } <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y -= _Time.y; o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En une seconde, la coordonnée V à tous les points deviendra inférieure à zéro, nous ne verrons donc plus la différence. </font><font style="vertical-align: inherit;">Encore une fois, cela est normal lorsque vous utilisez le filtrage en mode de répétition de texture. </font><font style="vertical-align: inherit;">Mais pour voir ce qui se passe, nous pouvons prendre la partie fractionnaire de la coordonnée V.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y -= _Time.y; <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y = frac(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y); o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordonnées V animées.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Utilisation du bruit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, notre rivière est animée, mais dans le sens et la vitesse, il y a de fortes transitions. </font><font style="vertical-align: inherit;">Notre motif UV les rend assez évidents, mais il sera plus difficile à reconnaître si vous utilisez un motif plus aqueux. </font><font style="vertical-align: inherit;">Ainsi, au lieu d'afficher des UV bruts, échantillonnons la texture. </font><font style="vertical-align: inherit;">Nous pouvons utiliser notre texture de bruit existante. </font><font style="vertical-align: inherit;">Nous l'échantillons et multiplions la couleur du matériau par le premier canal de bruit.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.y -= _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv); fixed4 c = _Color * noise.r; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Attribuez la texture du bruit au matériau de la rivière et assurez-vous qu'elle est blanche. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/dd4/e4e/dc8dd4e4ee9b92f2f104ba3107da30ce.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3f/0ca/319/b3f0ca31928fd594a715868ebbb7265c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de la texture du bruit. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les coordonnées V étant très étirées, la texture du bruit s'étend également le long de la rivière. </font><font style="vertical-align: inherit;">Malheureusement, le parcours n'est pas très beau. </font><font style="vertical-align: inherit;">Essayons de l'étirer d'une autre manière - en réduisant considérablement l'échelle des coordonnées de U. Un seizième suffira. </font><font style="vertical-align: inherit;">Cela signifie que nous n'échantillonnerons qu'une bande étroite de texture de bruit.</font></font><br><br><pre> <code class="hljs pgsql"> float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.x *= <span class="hljs-number"><span class="hljs-number">0.0625</span></span>; uv.y -= _Time.y;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/957/2a9/aa99572a9c0ad3daaa7b5b4eb3978cc0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étirement de la coordonnée U.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ralentissons également à un quart par seconde pour que l'achèvement du cycle de texture prenne quatre secondes.</font></font><br><br><pre> <code class="hljs"> uv.y -= _Time.y * 0.25;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le bruit actuel.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mélange de bruit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout semble déjà beaucoup mieux, mais le motif reste toujours le même. L'eau ne se comporte pas comme ça. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque nous n'utilisons qu'une petite bande de bruit, nous pouvons faire varier le motif en décalant cette bande le long de la texture. Cela se fait en ajoutant du temps à la coordonnée U. Nous devons le faire lentement, sinon la rivière semblera couler latéralement. Essayons le coefficient de 0,005. Cela signifie qu'il faut 200 secondes pour terminer le motif.</font></font><br><br><pre> <code class="hljs markdown"> uv.x = uv.x <span class="hljs-bullet"><span class="hljs-bullet">* 0.0625 + _Time.y *</span></span> 0.005;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bruit en mouvement. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malheureusement, cela n'a pas l'air très beau. </font><font style="vertical-align: inherit;">L'eau semble toujours statique et le changement est clairement perceptible, bien qu'il soit très lent. </font><font style="vertical-align: inherit;">Nous pouvons masquer le décalage en combinant deux échantillons de bruit et en les décalant dans des directions opposées. </font><font style="vertical-align: inherit;">Et si nous utilisons des valeurs légèrement différentes pour déplacer le deuxième échantillon, nous créerons une animation légère du changement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De sorte que, par conséquent, nous ne chevauchons jamais le même motif de bruit, nous utilisons un canal différent pour le deuxième échantillon.</font></font><br><br><pre> <code class="hljs pgsql"> float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.x = uv.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> + _Time.y * <span class="hljs-number"><span class="hljs-number">0.005</span></span>; uv.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv); float2 uv2 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv2.x = uv2.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> - _Time.y * <span class="hljs-number"><span class="hljs-number">0.0052</span></span>; uv2.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.23</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(_MainTex, uv2); fixed4 c = _Color * (noise.r * noise2.a);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une combinaison de deux modèles de bruit changeant.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eau translucide </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notre modèle semble assez dynamique. </font><font style="vertical-align: inherit;">L'étape suivante consiste à le rendre translucide. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, assurez-vous que l'eau ne projette pas d'ombres. </font><font style="vertical-align: inherit;">Vous pouvez les désactiver via le composant de rendu de l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le préfabriqué.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a61/894/e14/a61894e14d9999315d59b5ff0c0de517.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La projection d'ombres est désactivée. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basculez maintenant le shader en mode transparent. </font><font style="vertical-align: inherit;">Pour indiquer cela, utilisez des balises shader. </font><font style="vertical-align: inherit;">Ajoutez ensuite le </font></font><code>#pragma surface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mot </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">clé </font><font style="vertical-align: inherit;">à la ligne </font></font><code>alpha</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pendant que nous sommes ici, vous pouvez supprimer le mot-clé </font></font><code>fullforwardshadows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car nous ne projetons toujours pas d'ombres.</font></font><br><br><pre> <code class="hljs cs"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard alpha // fullforwardshadows #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.0</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous allons changer la façon dont nous définissons la couleur de la rivière. </font><font style="vertical-align: inherit;">Au lieu de multiplier le bruit par la couleur, nous y ajouterons du bruit. </font><font style="vertical-align: inherit;">Ensuite, nous utilisons la fonction </font></font><code>saturate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour limiter le résultat afin qu'il ne dépasse pas 1.</font></font><br><br><pre> <code class="hljs swift"> fixed4 <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = saturate(_Color + noise.r * noise2.a);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela nous permettra d'utiliser la couleur du matériau comme couleur de base. </font><font style="vertical-align: inherit;">Le bruit augmentera sa luminosité et son opacité. </font><font style="vertical-align: inherit;">Essayons d'utiliser une couleur bleue avec une opacité assez faible. </font><font style="vertical-align: inherit;">En conséquence, nous obtenons de l'eau translucide bleue avec des éclaboussures blanches.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/3f7/5a1/af83f75a143aabdd3b83525e4114fc3b.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eau translucide colorée. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Achèvement </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que tout semble fonctionner, il est temps de déformer à nouveau les pics. </font><font style="vertical-align: inherit;">En plus de déformer les bords des cellules, cela rendra nos rivières inégales.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c8/ff5/96b/8c8ff596bc247be79a30122e49ca27f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ca/664/808/6ca66480859e94d00e2e558caa17cbf4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pics déformés et déformés. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinons le terrain pour les problèmes qui sont survenus en raison de la distorsion. </font><font style="vertical-align: inherit;">On dirait qu'ils sont! </font><font style="vertical-align: inherit;">Voyons les grandes cascades.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df1/95b/a33/df195ba33947744e97173412373f5ad4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eau tronquée par des falaises.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'eau qui tombe d'une haute cascade disparaît derrière une falaise. Lorsque cela se produit, c'est très visible, nous devons donc faire quelque chose. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beaucoup moins évident est que les chutes d'eau peuvent être en pente, plutôt que de descendre directement vers le bas. Bien qu'en réalité l'eau ne coule pas comme ça, elle n'est pas particulièrement visible. Notre cerveau va l'interpréter de telle manière qu'il nous semble normal. Alors ignorez-le. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La façon la plus simple d'éviter la perte d'eau est d'approfondir les lits des rivières. Nous allons donc créer plus d'espace entre la surface de l'eau et le lit de la rivière. Cela rendra également les parois du canal plus verticales, alors n'allez pas trop loin. Demandons</font></font><code>HexMetrics.streamBedElevationOffset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur -1,75. </font><font style="vertical-align: inherit;">Cela résoudra la majeure partie des problèmes et le lit ne deviendra pas trop profond. </font><font style="vertical-align: inherit;">Une partie de l'eau sera toujours coupée, mais pas la totalité des cascades.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> streamBedElevationOffset = <span class="hljs-number"><span class="hljs-number">-1.75f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/80c/d26/57b80cd2687ff6afb9be83176e984b7d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canaux approfondis. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 7: routes </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajoutez un support routier. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulez la route. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous combinons routes et rivières. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Amélioration de l'apparence des routes. </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f7/b24/05e/9f7b2405e5ceed9842cc1ebd7b549b0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les premiers signes de civilisation.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cellules avec routes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme les rivières, les routes vont de cellule en cellule, au milieu des bords de la cellule. </font><font style="vertical-align: inherit;">La grande différence est qu'il n'y a pas d'eau qui coule sur les routes, donc elles sont bidirectionnelles. </font><font style="vertical-align: inherit;">De plus, des intersections sont nécessaires pour un réseau routier fonctionnel, nous devons donc prendre en charge plus de deux routes par cellule. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous autorisez les routes à aller dans les six directions, la cellule peut contenir de zéro à six routes. </font><font style="vertical-align: inherit;">C'est un total de quatorze configurations de routes possibles. </font><font style="vertical-align: inherit;">Cela représente bien plus de cinq configurations de rivière possibles. </font><font style="vertical-align: inherit;">Pour gérer cela, nous devons utiliser une approche plus générale qui peut gérer toutes les configurations.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/965/5b7/d469655b7efdbab33a6cac1c42e61a7e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14 configurations de routes possibles.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suivi routier </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le moyen le plus simple de suivre les routes dans une cellule est d'utiliser un tableau de valeurs booléennes. </font><font style="vertical-align: inherit;">Ajoutez le champ privé du tableau à </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et rendez-le sérialisable pour que vous puissiez le voir dans l'inspecteur. </font><font style="vertical-align: inherit;">Définissez la taille du tableau via le préfabriqué de cellule afin qu'il prenne en charge six routes.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] roads;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/439/167/2c4/4391672c4c1de9075138eef3f1cafd73.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cellule préfabriquée à six routes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez une méthode pour vérifier si la cellule a un chemin dans une certaine direction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasRoadThroughEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il sera également pratique de savoir s'il y a au moins une route dans la cellule, nous allons donc ajouter une propriété pour cela. </font><font style="vertical-align: inherit;">Il suffit de faire le tour du tableau dans la boucle et de revenir </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dès que nous trouvons le chemin. </font><font style="vertical-align: inherit;">S'il n'y a pas de routes, revenez </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRoads { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enlèvement de route </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme pour les rivières, nous ajouterons une méthode pour supprimer toutes les routes de la cellule. </font><font style="vertical-align: inherit;">Cela peut être fait avec une boucle qui déconnecte chaque route qui était précédemment activée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRoads</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bien sûr, nous devons également désactiver les cellules coûteuses correspondantes chez les voisins. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)i).Opposite()] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après cela, nous devons mettre à jour chacune des cellules. </font><font style="vertical-align: inherit;">Étant donné que les routes sont locales aux cellules, nous devons mettre à jour uniquement les cellules elles-mêmes sans leurs voisins.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)i).Opposite()] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].RefreshSelfOnly(); RefreshSelfOnly(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ajout de routes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ajout de routes est similaire à la suppression de routes. </font><font style="vertical-align: inherit;">La seule différence est que nous attribuons une valeur à Boolean </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, non </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous pouvons créer une méthode privée qui peut effectuer les deux opérations. </font><font style="vertical-align: inherit;">Ensuite, il sera possible de l'utiliser à la fois pour ajouter et supprimer la route.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRoads</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { SetRoad(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { roads[index] = state; neighbors[index].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)index).Opposite()] = state; neighbors[index].RefreshSelfOnly(); RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne pouvons pas avoir à la fois une rivière et une route allant dans la même direction en même temps. </font><font style="vertical-align: inherit;">Par conséquent, avant d'ajouter la route, nous vérifierons s'il y a une place pour celle-ci.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction)) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus, les routes ne peuvent pas être combinées avec des falaises car elles sont trop tranchantes. </font><font style="vertical-align: inherit;">Ou peut-être qu'il vaut la peine d'ouvrir la voie à travers une falaise basse, mais pas à travers une haute? </font><font style="vertical-align: inherit;">Pour le déterminer, nous devons créer une méthode qui nous indique la différence de hauteur dans une certaine direction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetElevationDifference</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> difference = elevation - GetNeighbor(direction).elevation; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> difference &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? difference : -difference; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons ajouter des routes à une différence de hauteur suffisamment petite. </font><font style="vertical-align: inherit;">Je ne me limiterai qu'aux pentes, c'est-à-dire au maximum 1 unité.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction) &amp;&amp; GetElevationDifference(direction) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Supprimer les mauvaises routes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons ajouté des routes uniquement lorsque cela est autorisé. </font><font style="vertical-align: inherit;">Maintenant, nous devons nous assurer qu'ils sont supprimés s'ils deviennent incorrects ultérieurement, par exemple, lors de l'ajout d'une rivière. </font><font style="vertical-align: inherit;">Nous pouvons interdire le placement de rivières au-dessus des routes, mais les rivières ne sont pas interrompues par des routes. </font><font style="vertical-align: inherit;">Laissez-les nettoyer la route. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il nous suffira de demander la route </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, qu'elle soit ou non. </font><font style="vertical-align: inherit;">Il y aura toujours mis à </font><font style="vertical-align: inherit;">jour les </font><font style="vertical-align: inherit;">deux cellules, donc on n'a plus besoin d'appeler explicitement </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans </font></font><code>SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } HexCell neighbor = GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || elevation &lt; neighbor.elevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } RemoveOutgoingRiver(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasIncomingRiver &amp;&amp; incomingRiver == direction) { RemoveIncomingRiver(); } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; <span class="hljs-comment"><span class="hljs-comment">// RefreshSelfOnly(); neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = true; neighbor.incomingRiver = direction.Opposite(); // neighbor.RefreshSelfOnly(); SetRoad((int)direction, false); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre opération qui peut fausser la route est un changement de hauteur. </font><font style="vertical-align: inherit;">Dans ce cas, nous devrons vérifier les routes dans toutes les directions. </font><font style="vertical-align: inherit;">Si la différence de hauteur est trop importante, la route existante doit être supprimée.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i] &amp;&amp; GetElevationDifference((HexDirection)i) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { SetRoad(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } Refresh(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edition de route </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La modification des routes fonctionne comme la modification des rivières. </font><font style="vertical-align: inherit;">Par conséquent </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, un commutateur supplémentaire est requis, ainsi qu'une méthode pour définir son état.</font></font><br><br><pre> <code class="cs hljs"> OptionalToggle riverMode, roadMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRiverMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { riverMode = (OptionalToggle)mode; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRoadMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { roadMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La méthode </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devrait maintenant prendre en charge la suppression avec l'ajout de routes. </font><font style="vertical-align: inherit;">Cela signifie que lors d'un glisser-déposer, il peut effectuer l'une des deux actions possibles. </font><font style="vertical-align: inherit;">Nous restructurons un peu le code afin que lors de l'exécution du glisser-déposer correct, les états des deux commutateurs soient vérifiés.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.No) { cell.RemoveRoads(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag) { HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.Yes) { otherCell.SetOutgoingRiver(dragDirection); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.Yes) { otherCell.AddRoad(dragDirection); } } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons rapidement ajouter une barre de route à l'interface utilisateur en copiant la barre de la rivière et en changeant la méthode appelée par les commutateurs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En conséquence, nous obtenons une interface utilisateur assez élevée. </font><font style="vertical-align: inherit;">Pour résoudre ce problème, j'ai changé la disposition des panneaux de couleur pour l'adapter aux panneaux de route et de rivière plus compacts.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fd/de5/a8a/0fdde5a8a4abc86308b771f43b36bf4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI avec des routes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis maintenant, j'utilise deux lignes de trois options pour les couleurs, il y a de la place pour une autre couleur. </font><font style="vertical-align: inherit;">J'ai donc ajouté un élément pour l'orange.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/9c6/08d/a069c608dfe531a5e1b2a8c59fef5846.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/12a/499/e9612a49993e3a2d4cb20790186ecf02.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cinq couleurs: jaune, vert, bleu, orange et blanc. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons maintenant modifier les routes, mais jusqu'à présent, elles ne sont pas visibles. </font><font style="vertical-align: inherit;">Vous pouvez utiliser l'inspecteur pour vous assurer que tout fonctionne.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/160/c4f/0e4/160c4f0e496acec2a2a2d739152a7cfa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cellule avec routes dans l'inspecteur. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulation routière </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour afficher les routes, vous devez les trianguler. </font><font style="vertical-align: inherit;">Cela revient à créer un maillage pour les rivières, seul le lit de la rivière n'apparaîtra pas dans le relief. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, créez un nouveau shader standard qui utilisera à nouveau les coordonnées UV pour peindre la surface de la route.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/Road" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = fixed4(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Créez un matériau routier à l'aide de ce shader. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/9e3/2b8/9739e32b82ad2148c559b8f7c4caa868.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Route matérielle. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Définissez le préfabriqué du fragment afin qu'il reçoive un autre maillage enfant d'hexagones pour les routes. </font><font style="vertical-align: inherit;">Ce maillage ne doit pas projeter d'ombres et doit utiliser uniquement des coordonnées UV. </font><font style="vertical-align: inherit;">Le moyen le plus rapide de le faire consiste à utiliser une instance préfabriquée - dupliquez l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et remplacez son matériau.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/476/a9e/bf8476a9e950a13c69051a5cd43480c1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a64/4d8/776/a644d8776f3c6f0ba64cf3aef666f475.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes d'objets enfants. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après cela, ajoutez au </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champ général </font></font><code>HexMesh roads</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et incluez-le dans </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Connectez-le dans l'inspecteur avec l'objet </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roads</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a95/c0e/c2a/a95c0ec2ae59dccbb249e6a02ccdc7c5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'objet Roads est connecté.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Routes entre les cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons d'abord les segments de route entre les cellules. </font><font style="vertical-align: inherit;">Comme les rivières, les routes sont fermées par deux quadruples moyens. </font><font style="vertical-align: inherit;">Nous couvrons complètement ces quadrangles de connexion avec les quadrangles routiers afin que les positions des mêmes six pics puissent être utilisées. </font><font style="vertical-align: inherit;">Ajoutez pour cela à la </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6 </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme nous n'avons plus à nous soucier du débit d'eau, la coordonnée V n'est pas nécessaire, nous lui affectons donc la valeur 0 partout. Nous pouvons utiliser la coordonnée U pour indiquer si nous sommes au milieu de la route ou sur le côté. </font><font style="vertical-align: inherit;">Soit égal à 1 au milieu et égal à 0 des deux côtés.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6 </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26a/730/868/26a73086896099b06098de0a25eb63ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un segment de la route entre les cellules. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il serait logique d'appeler cette méthode </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais seulement s'il y a vraiment une route. </font><font style="vertical-align: inherit;">Ajoutez un paramètre booléen à la méthode pour transmettre ces informations.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sûr, nous allons maintenant recevoir des erreurs de compilation, car jusqu'à présent, ces informations n'ont pas encore été transmises. </font><font style="vertical-align: inherit;">Comme dernier argument dans tous les cas, l'appel </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut être ajouté </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cependant, nous pouvons également déclarer que la valeur par défaut de ce paramètre est égale </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour cette raison, le paramètre deviendra facultatif et les erreurs de compilation disparaîtront.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { … }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment fonctionnent les paramètres facultatifs?</font></font></b> <div class="spoiler_text">        ,   . ,  <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; }</code> </pre> <br>    <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyMethod(x, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyMethod(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; }</code> </pre> <br>   .      .    .      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour trianguler la route, il suffit d'appeler </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec les six pics du milieu, si nécessaire.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est ainsi que nous gérons les connexions à cellules plates. </font><font style="vertical-align: inherit;">Pour soutenir les routes sur les rebords, nous devons également indiquer </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">où la route doit être ajoutée. </font><font style="vertical-align: inherit;">Il peut simplement transmettre ces informations </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.Color, endCell.Color, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, beginCell.Color, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(beginCell.Color, endCell.Color, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, endCell.Color, hasRoad); }</code> </pre> <br> <code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appelé à l'intérieur </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">C'est ici que nous pouvons déterminer s'il existe réellement une route allant dans la direction actuelle, à la fois lors de la triangulation d'une arête et lors de la triangulation des rebords.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces( e1, cell, e2, neighbor, cell.HasRoadThroughEdge(direction) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip( e1, cell.Color, e2, neighbor.Color, cell.HasRoadThroughEdge(direction) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7a/67d/e7d/d7a67de7d2edeb2d23b63e9b37bc7508.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segments de route entre les cellules.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cellule sur le rendu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque vous dessinez des routes, vous verrez que des segments de route apparaissent entre les cellules. Le milieu de ces segments sera violet avec une transition vers le bleu sur les bords. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, lorsque vous déplacez la caméra, les segments peuvent scintiller et parfois disparaître complètement. En effet, les triangles des routes chevauchent exactement les triangles de terrain. Les triangles pour le rendu sont sélectionnés au hasard. Ce problème peut être résolu en deux étapes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Premièrement, nous voulons dessiner les routes après le tracé du relief. Ceci peut être réalisé en les rendant après avoir rendu la géométrie habituelle, c'est-à-dire en les plaçant dans une file d'attente de rendu ultérieure.</font></font><br><br><pre> <code class="hljs objectivec"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Geometry+1"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, nous devons nous assurer que les routes sont tracées sur des triangles de terrain dans la même position. </font><font style="vertical-align: inherit;">Cela peut être fait en ajoutant le décalage du test de profondeur. </font><font style="vertical-align: inherit;">Cela permettra au GPU de supposer que les triangles sont plus proches de la caméra qu'ils ne le sont réellement.</font></font><br><br><pre> <code class="hljs powershell"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Geometry+1"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> Offset <span class="hljs-literal"><span class="hljs-literal">-1</span></span>, <span class="hljs-literal"><span class="hljs-literal">-1</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Routes à travers les cellules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de la triangulation des rivières, nous n'avons pas eu à traiter plus de deux directions de rivière par cellule. Nous pourrions identifier cinq options possibles et les trianguler différemment pour créer les rivières qui paraissent correctes. Cependant, dans le cas des routes, il y a quatorze options possibles. Nous n'utiliserons pas d'approches distinctes pour chacune de ces options. Au lieu de cela, nous traiterons chacune des six directions de cellule de la même manière, quelle que soit la configuration de route spécifique. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsqu'une route passe le long d'une partie de la cellule, nous la tracerons directement au centre de la cellule, sans quitter la zone de triangles. Nous allons dessiner un segment de la route du bord à la moitié en direction du centre. Ensuite, nous utilisons deux triangles pour fermer le reste au centre.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df0/659/a13/df0659a13206731d401579ba8c7f3b8f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulation d'une partie de la route. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour trianguler ce schéma, nous devons connaître le centre de la cellule, les sommets du milieu gauche et droit et les sommets du bord. </font><font style="vertical-align: inherit;">Ajoutez une méthode </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec les paramètres appropriés.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour construire un segment de route, nous avons besoin d'un pic supplémentaire. </font><font style="vertical-align: inherit;">Il est situé entre les pics médians gauche et droit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, nous pouvons également ajouter les deux triangles restants. </font></font><br><br><pre> <code class="cs hljs"> TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons également ajouter les coordonnées UV des triangles. </font><font style="vertical-align: inherit;">Deux de leurs sommets sont au milieu de la route, et le reste est sur le bord.</font></font><br><br><pre> <code class="cs hljs"> roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour l'instant, confinons-nous aux cellules dans lesquelles il n'y a pas de rivières. </font><font style="vertical-align: inherit;">Dans ces cas, cela </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crée simplement un éventail de triangles. </font><font style="vertical-align: inherit;">Déplacez ce code vers une méthode distincte. </font><font style="vertical-align: inherit;">Ensuite, nous ajoutons un appel </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque la route est réellement. </font><font style="vertical-align: inherit;">Les sommets du milieu gauche et droit peuvent être trouvés par interpolation entre le centre et deux sommets d'angle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithoutRiver(direction, cell, center, e); } … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { TriangulateRoad( center, Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), e ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29d/ae4/def/29dae4def1f841ae190e64b267f6e4ea.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes traversant les cellules.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Côtes de route </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons voir les routes, mais plus près du centre des cellules, elles se rétrécissent. Comme nous ne vérifions pas laquelle des quatorze options que nous traitons, nous ne pouvons pas déplacer le centre de la route pour créer des formes plus belles. Au lieu de cela, nous pouvons ajouter des bords de route supplémentaires dans d'autres parties de la cellule. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque les routes traversent la cellule, mais pas dans la direction actuelle, nous ajouterons un triangle aux bords de la route. Ce triangle est défini par les sommets centraux central, gauche et droit. Dans ce cas, seul le pic central se situe au milieu de la route. Les deux autres se trouvent sur sa côte.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, Vector3 mL, Vector3 mR</span></span></span><span class="hljs-function">)</span></span> { roads.AddTriangle(center, mL, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/293/6ec/bd12936ec0833f7d7da4e038158bb167.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une partie du bord de la route. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous devons trianguler une route pleine ou juste un bord, nous devons la laisser pour </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pour ce faire, cette méthode doit savoir si la route passe par la direction du bord de cellule actuel. </font><font style="vertical-align: inherit;">Par conséquent, nous ajoutons un paramètre pour cela.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoadThroughCellEdge </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoadThroughCellEdge) { Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateRoadEdge(center, mL, mR); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il devra appeler </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lorsque des routes traverseront la cellule. </font><font style="vertical-align: inherit;">Et il devra transmettre des informations pour savoir si la route passe par le bord actuel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { TriangulateRoad( center, Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), e, cell.HasRoadThroughEdge(direction) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89e/f99/1a0/89ef991a0790911d140b68b1457fb9df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes avec nervures terminées.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lissage des routes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les routes sont maintenant terminées. </font><font style="vertical-align: inherit;">Malheureusement, cette approche crée des renflements au centre des cellules. </font><font style="vertical-align: inherit;">Placer les pics gauche et droit au milieu entre le centre et les coins nous convient quand il y a une route à côté d'eux. </font><font style="vertical-align: inherit;">Mais si ce n'est pas le cas, il y a un renflement. </font><font style="vertical-align: inherit;">Pour éviter cela, dans de tels cas, nous pouvons placer les sommets plus près du centre. </font><font style="vertical-align: inherit;">Plus précisément, puis interpoler avec ¼, pas avec ½. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créons une méthode distincte pour déterminer les interpolateurs à utiliser. </font><font style="vertical-align: inherit;">Puisqu'il y en a deux, nous pouvons mettre le résultat </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Son composant X sera l'interpolateur du point gauche, et le composant Y sera l'interpolateur du point droit.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S'il y a une route dans la direction actuelle, nous pouvons placer les points au milieu. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { interpolators.x = interpolators.y = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinon, les options peuvent être différentes. </font><font style="vertical-align: inherit;">Pour le point de gauche, nous pouvons utiliser ½ s'il y a une route qui va dans la direction précédente. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, nous devons utiliser ¼. </font><font style="vertical-align: inherit;">La même chose s'applique au bon point, mais en tenant compte de la direction suivante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { interpolators.x = interpolators.y = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { interpolators.x = cell.HasRoadThroughEdge(direction.Previous()) ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; interpolators.y = cell.HasRoadThroughEdge(direction.Next()) ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez maintenant utiliser cette nouvelle méthode pour déterminer quels interpolateurs sont utilisés. </font><font style="vertical-align: inherit;">Grâce à cela, les routes seront lissées.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { Vector2 interpolators = GetRoadInterpolators(direction, cell); TriangulateRoad( center, Vector3.Lerp(center, e.v1, interpolators.x), Vector3.Lerp(center, e.v5, interpolators.y), e, cell.HasRoadThroughEdge(direction) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c9/d0b/d12/3c9d0bd1262c2d47a3efc2d300212efd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84c/5fa/4f8/84c5fa4f8ef27bd4f6d294d0bf50acf6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes lisses. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La combinaison des rivières et des routes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au stade actuel, nous avons des routes fonctionnelles, mais seulement s'il n'y a pas de rivières. </font><font style="vertical-align: inherit;">S'il y a une rivière dans la cellule, les routes ne seront pas triangulées.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5e/76f/814/f5e76f814407359057d0c1bb1688988c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a pas de routes près des rivières. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créons une méthode </font></font><code>TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour gérer cette situation. </font><font style="vertical-align: inherit;">Nous le réglons sur les paramètres habituels. </font><font style="vertical-align: inherit;">Nous l'appellerons au début de la méthode </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { TriangulateRoadAdjacentToRiver(direction, cell, center, e); } … } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour commencer, nous ferons de même que pour les routes sans rivières. </font><font style="vertical-align: inherit;">Nous vérifierons si la route passe par le bord actuel, obtiendrons des interpolateurs, créerons des pics moyens et appellerons </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais comme les rivières apparaîtront sur le chemin, nous devons en éloigner les routes. </font><font style="vertical-align: inherit;">Par conséquent, le centre de la route sera dans une position différente. </font><font style="vertical-align: inherit;">Nous utilisons une variable pour stocker cette nouvelle position </font></font><code>roadCenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Initialement, il sera égal au centre de la cellule.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons donc créer des routes partielles dans des cellules avec des rivières. </font><font style="vertical-align: inherit;">Les directions par lesquelles les rivières passent couperont les lacunes des routes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/029/595/95e0295954967415965a3992ffd91882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes avec espaces.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Début ou fin de la rivière </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinons d'abord les cellules contenant le début ou la fin d'une rivière. </font><font style="vertical-align: inherit;">Pour que les routes ne se chevauchent pas avec de l'eau, éloignons le centre de la route de la rivière. </font><font style="vertical-align: inherit;">Pour obtenir la direction de la rivière entrante ou sortante, ajoutez la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriété.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection RiverBeginOrEndDirection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver ? incomingRiver : outgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons utiliser cette propriété </font></font><code>HexGridChunk.TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour déplacer le centre de la route dans la direction opposée. </font><font style="vertical-align: inherit;">Il suffira de déplacer un tiers vers la côte médiane dans cette direction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/12b/280/f1812b2807add77e4d173b85ad65e4da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes modifiées. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous devons combler les lacunes. </font><font style="vertical-align: inherit;">Nous le ferons en ajoutant des triangles supplémentaires aux bords de la route lorsque nous serons près de la rivière. </font><font style="vertical-align: inherit;">S'il y a une rivière dans la direction précédente, alors nous ajoutons un triangle entre le centre de la route, le centre de la cellule et le point central gauche. </font><font style="vertical-align: inherit;">Et si la rivière est dans la direction suivante, alors nous ajoutons un triangle entre le centre de la route, le point milieu droit et le centre de la cellule. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous le ferons quelle que soit la configuration de la rivière, alors mettez ce code à la fin de la méthode.</font></font><br><br><pre> <code class="cs hljs"> Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { TriangulateRoadEdge(roadCenter, center, mL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { TriangulateRoadEdge(roadCenter, mR, center); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous ne pouvez pas utiliser l'instruction else?</font></font></b> <div class="spoiler_text">      .   ,     . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93d/485/bc8/93d485bc8072e6fa8471fb98d084467a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes prêtes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivières droites </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cellules avec des rivières droites sont particulièrement difficiles car elles divisent essentiellement le centre de la cellule en deux. </font><font style="vertical-align: inherit;">Nous ajoutons déjà des triangles supplémentaires pour combler les lacunes entre les rivières, mais nous devons également déconnecter les routes sur les côtés opposés de la rivière.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab6/203/055/ab62030558305530ed4aed038669ba9c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes chevauchant une rivière droite. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la cellule n'a pas le début ou la fin de la rivière, nous pouvons vérifier si les rivières entrantes et sortantes vont dans des directions opposées. </font><font style="vertical-align: inherit;">Si oui, alors nous avons une rivière directe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour déterminer où la rivière est par rapport à la direction actuelle, nous devons vérifier les directions voisines. </font><font style="vertical-align: inherit;">La rivière est à gauche ou à droite. </font><font style="vertical-align: inherit;">Puisque nous le faisons à la fin de la méthode, nous mettons en cache ces requêtes dans des variables booléennes. </font><font style="vertical-align: inherit;">Cela simplifiera également la lecture de notre code.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> previousHasRiver = cell.HasRiverThroughEdge(direction.Previous()); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> nextHasRiver = cell.HasRiverThroughEdge(direction.Next()); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { } } Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { TriangulateRoadEdge(roadCenter, center, mL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { TriangulateRoadEdge(roadCenter, mR, center); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons déplacer le centre de la route vers un vecteur angulaire pointant dans la direction opposée à la rivière. </font><font style="vertical-align: inherit;">Si la rivière passe par la direction précédente, c'est le deuxième angle solide. </font><font style="vertical-align: inherit;">Sinon, c'est le premier angle solide.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { Vector3 corner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { corner = HexMetrics.GetFirstSolidCorner(direction); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour déplacer la route de manière à ce qu'elle soit adjacente à la rivière, nous devons déplacer le centre de la route de la moitié de la distance jusqu'à ce coin. </font><font style="vertical-align: inherit;">Ensuite, nous devons également déplacer le centre de la cellule d'un quart de la distance dans cette direction.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { Vector3 corner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { corner = HexMetrics.GetFirstSolidCorner(direction); } roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/6bf/85b/e4c6bf85b3120697996ad75a3256a3a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes divisées. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons partagé un réseau de routes à l'intérieur de cette cellule. </font><font style="vertical-align: inherit;">C'est normal lorsque les routes sont des deux côtés de la rivière. </font><font style="vertical-align: inherit;">Mais si d'un côté il n'y a pas de route, alors nous aurons un petit morceau de route isolée. </font><font style="vertical-align: inherit;">C'est illogique, alors débarrassons-nous de ces parties. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assurez-vous qu'il y a une route qui va dans la direction actuelle. </font><font style="vertical-align: inherit;">Si ce n'est pas le cas, vérifiez dans l'autre sens du même côté de la rivière la présence de la route. </font><font style="vertical-align: inherit;">S'il n'y a pas de route de passage là ou là, alors on quitte la méthode avant de trianguler.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !hasRoadThroughEdge &amp;&amp; !cell.HasRoadThroughEdge(direction.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !hasRoadThroughEdge &amp;&amp; !cell.HasRoadThroughEdge(direction.Previous()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } corner = HexMetrics.GetFirstSolidCorner(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/398/532/09e398532543dcd7f78987c23e012571.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes tronquées.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et les ponts?</font></font></b> <div class="spoiler_text">     .         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rivières en zigzag </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le prochain type de rivière est le zigzag. </font><font style="vertical-align: inherit;">Ces rivières ne partagent pas le réseau routier, il nous suffit donc de déplacer le centre de la route.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/851/29b/f56/85129bf56e4948296b17916094fd9d8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zigzags traversant les routes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La façon la plus simple de vérifier les zigzags est de comparer les directions des rivières entrantes et sortantes. </font><font style="vertical-align: inherit;">S'ils sont adjacents, alors nous avons un zigzag. </font><font style="vertical-align: inherit;">Cela conduit à deux options possibles, selon le sens de l'écoulement.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Previous()) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons déplacer le centre de la route en utilisant l'un des coins de la direction de la rivière entrante. </font><font style="vertical-align: inherit;">L'angle que vous sélectionnez dépend de la direction du flux. </font><font style="vertical-align: inherit;">Déplacez le centre de la route de cet angle avec un facteur de 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Previous()) { roadCenter -= HexMetrics.GetSecondCorner(cell.IncomingRiver) * <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { roadCenter -= HexMetrics.GetFirstCorner(cell.IncomingRiver) * <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/3c6/f27/1fa3c6f277079e277491027207f9398f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La route s'éloigna des zigzags.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> À l'intérieur des rivières tortueuses </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La dernière configuration de rivière est une courbe lisse. </font><font style="vertical-align: inherit;">Comme pour la rivière directe, celle-ci peut également séparer les routes. </font><font style="vertical-align: inherit;">Mais dans ce cas, les parties seront différentes. </font><font style="vertical-align: inherit;">Nous devons d'abord travailler avec l'intérieur de la courbe.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/566/b8f/3db/566b8f3dbffec4cdc91556abe0f2bf5e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une rivière incurvée avec des routes pavées. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous avons une rivière des deux côtés de la direction actuelle, nous sommes à l'intérieur de la courbe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous devons déplacer le centre de la route vers le bord actuel de la cellule, raccourcissant un peu la route. </font><font style="vertical-align: inherit;">Un coefficient de 0,7 fera l'affaire. </font><font style="vertical-align: inherit;">Le centre cellulaire devrait également se déplacer avec un coefficient de 0,5.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { Vector3 offset = HexMetrics.GetSolidEdgeMiddle(direction) * HexMetrics.innerToOuter; roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>; center += offset * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2d/64f/a82/a2d64fa828544540d43856bf94e34f9d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes raccourcies. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans le cas des rivières droites, nous devrons couper les parties isolées des routes. </font><font style="vertical-align: inherit;">Dans ce cas, il suffit de vérifier uniquement la direction actuelle.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasRoadThroughEdge) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 offset = HexMetrics.GetSolidEdgeMiddle(direction) * HexMetrics.innerToOuter; roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>; center += offset * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/6a0/d9d/30b6a0d9db5fe0960265713c62ef2ae5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coupez les routes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En dehors des rivières tortueuses </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir vérifié tous les cas précédents, la seule option restante était la partie extérieure de la rivière incurvée. </font><font style="vertical-align: inherit;">Dehors, il y a trois parties de la cellule. </font><font style="vertical-align: inherit;">Nous devons trouver la direction du milieu. </font><font style="vertical-align: inherit;">Après l'avoir reçue, nous pouvons déplacer le centre de la route vers cette nervure d'un facteur de 0,25.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { … } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } roadCenter += HexMetrics.GetSolidEdgeMiddle(middle) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b8/84c/a29/8b884ca29118c36e522674cd00ab8613.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changé l'extérieur de la route. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dernière étape, nous devons tronquer les routes de ce côté de la rivière. </font><font style="vertical-align: inherit;">Le moyen le plus simple consiste à vérifier les trois directions de la route par rapport au milieu. </font><font style="vertical-align: inherit;">S'il n'y a pas de routes, nous arrêtons de travailler.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !cell.HasRoadThroughEdge(middle) &amp;&amp; !cell.HasRoadThroughEdge(middle.Previous()) &amp;&amp; !cell.HasRoadThroughEdge(middle.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } roadCenter += HexMetrics.GetSolidEdgeMiddle(middle) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56d/69a/d1b/56d69ad1b8d6ffdf74e9adb1c4800695.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/8c3/178/a9a8c3178c8a44738b4bbd01ef5f221d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes avant et après détourage. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir traité toutes les options fluviales, nos rivières et nos routes peuvent coexister. </font><font style="vertical-align: inherit;">Les rivières ignorent les routes et les routes s'adaptent aux rivières.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b32/6e4/28b/b326e428b45df027cac2f99a336e71e9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La combinaison des rivières et des routes. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> L'apparence des routes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jusqu'à ce moment, nous utilisions leurs coordonnées UV comme couleurs de route. </font><font style="vertical-align: inherit;">Étant donné que seule la coordonnée U a changé, nous avons en fait affiché la transition entre le milieu et le bord de la route.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/cb2/8ac/084cb28ac448ddb258846c09d8b3b83a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Affichage des coordonnées UV. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que les routes sont correctement triangulées correctement, nous pouvons changer le shader de la route pour qu'il ressemble davantage à des routes. </font><font style="vertical-align: inherit;">Comme dans le cas des rivières, ce sera une visualisation simple, sans fioritures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous commencerons par utiliser la couleur unie pour les routes. </font><font style="vertical-align: inherit;">Utilisez simplement la couleur du matériau. </font><font style="vertical-align: inherit;">Je l'ai rendu rouge.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/304/2e4/ab4/3042e4ab4b01b3389822072244208cb6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes rouges. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et ça a déjà l'air beaucoup mieux! </font><font style="vertical-align: inherit;">Mais continuons et mélangeons la route avec le terrain, en utilisant la coordonnée U comme facteur de mélange.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = blend; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble que cela n'ait rien changé. </font><font style="vertical-align: inherit;">C'est arrivé parce que notre shader est opaque. </font><font style="vertical-align: inherit;">Maintenant, il a besoin d'un mélange alpha. </font><font style="vertical-align: inherit;">En particulier, nous avons besoin d'un shader pour une surface de décalcomanie d'accouplement. </font><font style="vertical-align: inherit;">Nous pouvons obtenir le shader requis en ajoutant une </font></font><code>#pragma surface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ligne </font><font style="vertical-align: inherit;">à la directive </font></font><code>decal:blend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows decal:blend</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/66c/501/7a066c5015ea14533f1b9ed881469323.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mélange des routes. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc créé un mélange linéaire lisse du milieu au bord qui n'est pas très joli. </font><font style="vertical-align: inherit;">Pour qu'elle ressemble à une route, nous avons besoin d'une zone solide, suivie d'une transition rapide vers une zone opaque. </font><font style="vertical-align: inherit;">Vous pouvez utiliser la fonction pour cela </font></font><code>smoothstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Il convertit une progression linéaire de 0 à 1 en une courbe en forme de S.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b0/030/f57/2b0030f57819183470fc7fae72ea18bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Progression linéaire et lisse. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La fonction </font></font><code>smoothstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a un paramètre minimum et maximum pour ajuster la courbe dans un intervalle arbitraire. </font><font style="vertical-align: inherit;">Les valeurs d'entrée en dehors de la plage sont limitées pour maintenir la courbe plate. </font><font style="vertical-align: inherit;">Utilisons 0,4 au début de la courbe et 0,7 à la fin. </font><font style="vertical-align: inherit;">Cela signifie que la coordonnée U de 0 à 0,4 sera complètement transparente. </font><font style="vertical-align: inherit;">Et les coordonnées U de 0,7 à 1 seront complètement opaques. </font><font style="vertical-align: inherit;">La transition se produit entre 0,4 et 0,7.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; blend = smoothstep(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/543/fe1/4b4/543fe14b4d760b820ec106626230876f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transition rapide entre les zones opaques et transparentes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Route avec bruit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que le maillage de la route sera déformé, les routes ont des largeurs variables. </font><font style="vertical-align: inherit;">Par conséquent, la largeur de la transition sur les bords sera également variable. </font><font style="vertical-align: inherit;">Parfois, c'est flou, parfois dur. </font><font style="vertical-align: inherit;">Une telle variabilité nous convient, si nous percevons les routes comme sablonneuses ou terreuses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prenons la prochaine étape et ajoutons du bruit aux bords de la route. </font><font style="vertical-align: inherit;">Cela les rendra plus inégaux et moins polygonaux. </font><font style="vertical-align: inherit;">Nous pouvons le faire en échantillonnant la texture du bruit. </font><font style="vertical-align: inherit;">Pour l'échantillonnage, vous pouvez utiliser les coordonnées du monde XZ, comme nous l'avons fait lors de la distorsion des sommets des cellules. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour accéder à la position du monde dans le shader de surface, ajoutez à la structure d'entrée </font></font><code>float3 worldPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float3 worldPos; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, nous pouvons utiliser cette position </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour échantillonner la texture principale. </font><font style="vertical-align: inherit;">Effectuez également un zoom arrière, sinon la texture se répétera trop souvent.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous déformons la transition en multipliant la coordonnée U par </font></font><code>noise.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mais comme les valeurs de bruit sont en moyenne de 0,5, la plupart des routes disparaîtront. </font><font style="vertical-align: inherit;">Pour éviter cela, ajoutez 0,5 au bruit avant multiplication.</font></font><br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blend = IN.uv_MainTex.x; blend *= <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; blend = <span class="hljs-keyword"><span class="hljs-keyword">smoothstep</span></span>(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/b7d/e28/c08b7de2879b84c816286530871b6a6f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/bdf/28f/4bebdf28fc519b3f186f119b6e501261.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bords déformés de la route. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour y mettre fin, nous dénaturerons également la couleur des routes. </font><font style="vertical-align: inherit;">Cela donnera aux routes une sensation de saleté correspondant aux bords flous. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multipliez la couleur par un autre canal de bruit, disons par </font></font><code>noise.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nous obtenons donc en moyenne la moitié de la valeur de la couleur. </font><font style="vertical-align: inherit;">Comme c'est trop, nous réduirons légèrement l'échelle de bruit et ajouterons une constante pour que la somme puisse atteindre 1.</font></font><br><br><pre> <code class="hljs swift"> fixed4 <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = _Color * (noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d2/a25/d49/6d2a25d4929cf56f7c4059352b4ed70a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Routes cahoteuses. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquet d'unité</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr424491/">https://habr.com/ru/post/fr424491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr424475/index.html">Rapport du Centre de surveillance de la sécurité des informations pour le premier semestre 2018</a></li>
<li><a href="../fr424477/index.html">La disponibilité des jeux sur pygame</a></li>
<li><a href="../fr424481/index.html">Toute la vérité sur RTOS. Article # 11. Tâches: configuration et introduction à l'API</a></li>
<li><a href="../fr424483/index.html">Accord de 38 milliards de dollars et ses implications: comment Comcast et Disney combattent Amazon et Netflix avec des investissements</a></li>
<li><a href="../fr424485/index.html">SSL Pinning Bypass dans l'application iOS</a></li>
<li><a href="../fr424495/index.html">Google Chrome ajoutera la possibilité de refuser la synchronisation automatique des profils lors de la connexion aux services de l'entreprise *</a></li>
<li><a href="../fr424497/index.html">Arrêtez de soupçonner les développeurs d'imposture. Apprenez à mieux interviewer</a></li>
<li><a href="../fr424499/index.html">Eh bien lui, ton pentest</a></li>
<li><a href="../fr424501/index.html">Terminaux de diagnostic pour les vrais soudeurs</a></li>
<li><a href="../fr424503/index.html">Démarrez-vous, le printemps arrive (partie 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>