<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛑️ 🧟 🧘🏾 Ein weiterer Schatteneroberer in Phaser oder die Verwendung von Fahrrädern 🌀 👨🏿‍🚀 😁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor zwei Jahren habe ich bereits in Phaser 2D mit Schattensubstanzen experimentiert. Beim letzten Ludum Dare beschlossen wir plötzlich, einen Horror z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein weiterer Schatteneroberer in Phaser oder die Verwendung von Fahrrädern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434370/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vor zwei Jahren habe</a> ich bereits in Phaser 2D mit Schattensubstanzen experimentiert.  Beim letzten Ludum Dare beschlossen wir plötzlich, einen Horror zu machen, und was für ein Horror ohne Schatten und Lichter!  Ich habe meine Knöchel geknackt ... <br><br>  ... und keine verdammte Sache rechtzeitig für LD.  Im Spiel gibt es natürlich ein bisschen Licht und Schatten, aber das ist ein miserabler Anschein dessen, was eigentlich sein sollte. <br><br>  Nachdem ich nach dem Absenden des Spiels zum Wettbewerb nach Hause zurückgekehrt war, beschloss ich, „die Gestalt zu schließen“ und diese unglücklichen Schatten zu beenden.  Was passiert ist - Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sich im Spiel fühlen</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Demo spielen</a> , sich das Bild ansehen und den Artikel lesen. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m3/if/35/m3if351xwaowt3lxcayun-cuzak.png"></div><br><a name="habracut"></a>  Wie immer in solchen Fällen macht es keinen Sinn, eine allgemeine Lösung zu schreiben. Sie müssen sich auf eine bestimmte Situation konzentrieren.  Die Welt des Spiels kann in Form von Segmenten dargestellt werden - zumindest jene Einheiten, die Schatten werfen.  Wände sind Rechtecke, Menschen sind Rechtecke, nur gedreht, der höllische Spoiler ist ein Kreis, aber im Cut-Off-Modell kann er auf eine Länge eines Durchmessers vereinfacht werden, der immer senkrecht zu einem Lichtstrahl steht. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dh/gq/id/dhgqidngehzo_pn9vgr9eirsgna.png"></div><br>  Es gibt mehrere Lichtquellen (20-30), und alle sind kreisförmig (Scheinwerfer) und befinden sich bedingt niedriger als die beleuchteten Objekte (so dass die Schatten unendlich sein können). <br><br>  Ich sah in meinem Kopf die folgenden Möglichkeiten, um das Problem zu lösen: <br><br><ol><li>  Für jede Lichtquelle erstellen wir eine Textur in der Größe eines Bildschirms (gut oder 2-4 mal kleiner).  Auf diese Textur zeichnen wir einfach das Trapez BCC'D ', wobei A die Lichtquelle ist, BC das Segment ist, B'C' die Projektion des Segments zum Rand der Textur ist.  Danach werden diese Texturen an den Shader gesendet, wo sie zu einem einzigen Bild gemischt werden. <br><br>  Der Autor des Celeste-Plattformspielers hat so etwas getan, was in seinem Artikel auf Medium gut geschrieben ist: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">medium.com/@NoelFB/remaking-celestes-lighting-3478d6f10bf</a> <br><br>  Probleme: 20-30 texturgroße Texturen, die fast in jedem Frame neu gezeichnet und in die GPU geladen werden müssen.  Ich erinnere mich, dass dies ein sehr, sehr nicht schneller Prozess war. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z2/ve/ya/z2veyaflrtcpobcfkkdecuqpkpa.png"></div><br></li><li>  Die in einem Beitrag auf einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com/post/272233</a> beschriebene Methode.  Für jede Lichtquelle erstellen wir eine "Tiefenkarte", d.h.  eine solche Textur, wobei x = der Winkel des "Strahls" von der Lichtquelle, y = die Nummer der Lichtquelle und Farbe == Abstand von der Quelle zum nächsten Hindernis.  Wenn wir einen Schritt von 0,7 Grad (360/512) und 32 Lichtquellen machen, erhalten wir eine 512x32-Textur, die so lange nicht aktualisiert wurde. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aq/ew/_x/aqew_xze8rbkwvhj-68t3d4glz4.png"></div>  <sup>(Beispiel Textur für einen Schritt von 45 Grad)</sup> <br></li><li>  Der geheime Weg, den ich ganz am Ende beschreiben werde </li></ol><br>  Am Ende habe ich mich für Methode 2 entschieden. Das im Artikel beschriebene hat mir jedoch nicht bis zum Ende gepasst.  Dort wurde die Textur auch mithilfe eines Rakecasts im Shader erstellt - der Shader im Zyklus ging von der Lichtquelle in Richtung des Strahls und suchte nach einem Hindernis.  In meinen früheren Experimenten habe ich auch Rakecast im Shader gemacht, und es war sehr teuer, wenn auch universell. <br><br>  „Wir haben nur Segmente im Modell“, dachte ich, „und 10 bis 20 Segmente fallen in den Radius jeder Lichtquelle.  Kann ich darauf nicht schnell eine Entfernungskarte berechnen? " <br><br>  Also habe ich mich dazu entschlossen. <br><br>  Zunächst habe ich einfach die Wände, die bedingte „Hauptfigur“ und die Lichtquellen auf dem Bildschirm angezeigt.  Um die Lichtquellen herum schnitt in der Dunkelheit ein Kreis aus reinem, klarem Licht aus.  Um dies zu bekommen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/jh/y4/yljhy4kuzvmkdqscqjuzsbqfjms.png"></div>  <sup>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> )</sup> <br><br>  Ich fing sofort an, mit dem Shader zu arbeiten, um mich nicht zu entspannen.  Es war notwendig, für jede Lichtquelle ihre Koordinaten und ihren Wirkungsradius (über den das Licht nicht hinausreicht) einzugeben, dies geschieht einfach durch eine einheitliche Anordnung.  Und dann blieb im Shader (der fragmentarisch ist und für jedes Pixel auf dem Bildschirm ausgeführt wird) zu verstehen, ob sich das aktuelle Pixel im beleuchteten Kreis befindet oder nicht. <br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleLightShader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Phaser</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Filter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(game) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(game); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lightsArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(MAX_LIGHTS*<span class="hljs-number"><span class="hljs-number">4</span></span>); lightsArray.fill(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, lightsArray.length); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uniforms.lightsCount = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'1i'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uniforms.lights = {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'4fv'</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: lightsArray}; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.fragmentSrc = <span class="hljs-string"><span class="hljs-string">` precision highp float; uniform int lightsCount; uniform vec4 lights[</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${MAX_LIGHTS}</span></span></span><span class="hljs-string">]; void main() { float lightness = 0.; for (int i = 0; i &lt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${MAX_LIGHTS}</span></span></span><span class="hljs-string">; i++) { if (i &gt;= lightsCount) break; vec4 light = lights[i]; lightness += step(length(light.xy - gl_FragCoord.xy), light.z); } lightness = clamp(0., 1., lightness); gl_FragColor = mix(vec4(0,0,0,0.5), vec4(0,0,0,0), lightness); } `</span></span>; } updateLights(lightSources) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uniforms.lightsCount.value = lightSources.length; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uniforms.lights.value; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> light <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> lightSources) { array[i++] = light.x; array[i++] = game.world.height - light.y; array[i++] = light.radius; i++; } } }</code> </pre> <br>  Jetzt müssen wir für jede Lichtquelle verstehen, welche Segmente einen Schatten werfen.  Vielmehr, welche Teile der Segmente - in der Abbildung unten interessieren uns die „roten“ Teile des Segments nicht, weil  das Licht erreicht sie immer noch nicht. <br><br>  <i>Hinweis: Die Schnittpunktdefinition ist eine Art vorläufige Optimierung.</i>  <i>Es wird benötigt, um die Zeit der weiteren Verarbeitung zu verkürzen und große Segmentstücke außerhalb des Radius der Lichtquelle zu eliminieren.</i>  <i>Dies ist sinnvoll, wenn wir viele Segmente haben, deren Länge viel größer ist als der Radius des „Glühens“.</i>  <i>Wenn dies nicht der Fall ist und wir viele kurze Segmente haben, kann es richtig sein, keine Zeit damit zu verschwenden, den Schnittpunkt zu bestimmen und die gesamten Segmente zu verarbeiten, weil</i>  <i>Zeit sparen funktioniert immer noch nicht.</i> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cb/93/mb/cb93mbs6zzyyqwvfx633ppxbtzg.png"></div><br>  Dazu habe ich die bekannte Formel verwendet, um den Schnittpunkt einer geraden Linie und eines Kreises zu finden, an die sich jeder auswendig aus einem Schulkurs in Geometrie erinnert ... in der imaginären Welt eines Menschen.  Ich konnte mich einfach nicht an sie erinnern, also musste ich es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">googeln</a> . <br><br>  Wir verschlüsseln, schauen, was passiert ist. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_0/up/go/_0upgoezkyggo7sfkntejosckg0.png"></div>  <sup>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> )</sup> <br>  Es scheint die Norm zu sein.  Jetzt wissen wir, welche Segmente einen Schatten werfen und Rakecast ausführen können. <br><br>  Hier haben wir auch Optionen: <br><br><ol><li>  Wir gehen einfach in einem Kreis in einem Kreis, werfen Strahlen und suchen nach Kreuzungen.  Der Abstand zur nächsten Kreuzung ist der Wert, den wir benötigen </li><li>  Sie können nur zu den Ecken gehen, die in Segmente fallen.  Schließlich kennen wir die Punkte bereits, es ist nicht schwierig, die Winkel zu berechnen. </li><li>  Wenn wir entlang eines Segments gehen, müssen wir keine Strahlen werfen und Schnittpunkte berechnen - wir können uns mit dem gewünschten Schritt entlang des Segments bewegen.  So funktioniert es: </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9w/db/yp/9wdbyph5wjrn9dolovyhf_5y6-w.png"></div><br>  Hier <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi><mi>B</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.507ex" height="2.057ex" viewBox="0 -780.1 1510 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-41" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-42" x="750" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi><mi>B</mi></math></span></span><script type="math/tex" id="MathJax-Element-1"> AB </script>  - Segment (Wand), <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-43" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> C </script>  Ist das Zentrum der Lichtquelle, <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>d</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.982ex" height="2.057ex" viewBox="0 -780.1 1284 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-64" x="760" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>d</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> Cd </script>  - senkrecht zum Segment. <br><br>  Lass <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>x</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.33ex" height="1.455ex" viewBox="0 -520.7 572.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-78" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi></math></span></span><script type="math/tex" id="MathJax-Element-4"> x </script>  - der Winkel zur Normalen, für den Sie den Abstand von der Quelle zum Segment ermitteln müssen, <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.979ex" height="2.298ex" viewBox="0 -780.1 1282.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-58" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMAIN-31" x="1171" y="-213"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-5"> X_1 </script>  - Zeigen Sie auf das Segment <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>A</mi><mi>B</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.507ex" height="2.057ex" viewBox="0 -780.1 1510 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-41" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-42" x="750" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi><mi>B</mi></math></span></span><script type="math/tex" id="MathJax-Element-6"> AB </script>  wo der Strahl fällt.  Dreieck <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>D</mi><msub><mi>X</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.669ex" height="2.298ex" viewBox="0 -780.1 2871.4 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-44" x="760" y="0"></use><g transform="translate(1589,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-58" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMAIN-31" x="1171" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>D</mi><msub><mi>X</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-7"> CDX_1 </script>  - rechteckig <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><mi>d</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.982ex" height="2.057ex" viewBox="0 -780.1 1284 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-64" x="760" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mi>d</mi></math></span></span><script type="math/tex" id="MathJax-Element-8"> Cd </script>  - ein Bein, dessen Länge für dieses Segment bekannt und konstant ist, <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><msub><mi>X</mi><mn>1</mn></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.745ex" height="2.298ex" viewBox="0 -780.1 2042.9 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-43" x="0" y="0"></use><g transform="translate(760,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-58" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMAIN-31" x="1171" y="-213"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><msub><mi>X</mi><mn>1</mn></msub></math></span></span><script type="math/tex" id="MathJax-Element-9"> CX_1 </script>  - gewünschte Länge. <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>C</mi><msub><mi>X</mi><mn>1</mn></msub><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>C</mi><mi>D</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="23.042ex" height="2.66ex" viewBox="0 -832 9921 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-43" x="0" y="0"></use><g transform="translate(760,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-58" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMAIN-31" x="1171" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMAIN-3D" x="2320" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-66" x="3626" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-72" x="4177" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-61" x="4628" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-63" x="5158" y="0"></use><g transform="translate(5591,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-43" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-44" x="760" y="0"></use></g><g transform="translate(7180,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-63" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-6F" x="433" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-73" x="919" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMAIN-28" x="1388" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-78" x="1778" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMAIN-29" x="2350" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><msub><mi>X</mi><mn>1</mn></msub><mo>=</mo><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mi>C</mi><mi>D</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></math></span></span><script type="math/tex" id="MathJax-Element-10"> CX_1 = \ frac {CD} {cos (x)} </script>  .  Wenn Sie den Schritt im Voraus kennen (und wir wissen es), können Sie die Tabelle der inversen Kosinusse vorberechnen und sehr schnell nach Entfernungen suchen. <br><br>  Ich werde ein Beispiel für Code für eine solche Tabelle geben.  Fast alle Arbeiten mit Ecken werden durch Arbeiten mit Indizes ersetzt, d. H.  ganze Zahlen von 0 bis N, wobei N = die Anzahl der Schritte im Kreis ist (d. h. Schrittwinkel = <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>2</mn><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>i</mi></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>N</mi></mrow></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.923ex" height="2.419ex" viewBox="0 -780.1 4703 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-66" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-72" x="800" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-61" x="1252" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-63" x="1781" y="0"></use><g transform="translate(2215,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-70" x="750" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-69" x="1254" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/434370/&amp;usg=ALkJrhjylPAjr3lLkqh__tY-U46KJGlg3A#MJMATHI-4E" x="3814" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mrow class="MJX-TeXAtom-ORD"><mn>2</mn><mtext>&nbsp;</mtext><mi>p</mi><mi>i</mi></mrow><mrow class="MJX-TeXAtom-ORD"><mi>N</mi></mrow></math></span></span><script type="math/tex" id="MathJax-Element-11"> \ frac {2 \ pi} {N} </script>  ) <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HypTable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(steps = 512, stepAngle = 2*Math.PI/steps) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.perAngleStep = [<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; steps/<span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">//   pi/2 let ang = i*stepAngle; this.perAngleStep[i] = 1/Math.cos(ang); } this.stepAngle = stepAngle; } /** * @param distancesMap -  ,    * @param angle1 -           * @param angle2 -           * @param normalFromLight - ,      */ fillDistancesForArc(distancesMap, angle1, angle2, normalFromLight) { const D = Math.hypot(normalFromLight.x, normalFromLight.y); const normalAngle = Phaser.Math.normalizeAngle(Math.atan2(normalFromLight.y, normalFromLight.x)); const normalAngleIndex = (normalAngle / this.stepAngle)|0; const index1 = (angle1 / this.stepAngle)|0; const index2 = (angle2 / this.stepAngle)|0; for (let angleIndex = index1; angleIndex &lt;= index2; angleIndex++) { let distanceForAngle = D * this.perAngleStep[normalize(angleIndex - normalAngleIndex)]; distancesMap.set(angleIndex, distanceForAngle); } } }</span></span></code> </pre><br>  Natürlich führt diese Methode einen Fehler für Fälle ein, in denen der Anfangswinkel ACD kein Vielfaches eines Schritts ist.  Aber für 512 Schritte sehe ich visuell keinen Unterschied. <br><br>  Also, was wir bereits wissen, wie es geht: <br><ol><li>  Suchen Sie Segmente im Bereich der Lichtquelle, die einen Schatten werfen können <br></li><li>  Erstellen Sie für Schritt t eine dist (Winkel) -Tabelle, die durch jedes Segment verläuft und die Abstände berechnet. </li></ol><br><br>  So sieht diese Tabelle aus, wenn Sie sie in Strahlen zeichnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kh/5m/17/kh5m17zbgdyq22dfeoys5borlbe.png"></div>  <sup>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> )</sup> <br><br>  Und so sieht es für 10 Lichtquellen aus, wenn sie in einer Textur geschrieben sind. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bg/ex/3-/bgex3-jcfuohb9_egfv_4ul-x2e.png"></div><br>  Hier entspricht jedes horizontale Pixel einem Winkel und die Farbe dem Abstand in Pixel. <br>  Es wird in js wie diesem mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">imageData geschrieben</a> <br><pre> <code class="javascript hljs"> fillBitmap(data, index) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> total = index + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.steps*<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> d1, d2; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//data[index] = Red //data[index+1] = Green //data[index+2] = Blue //data[index+3] = Alpha for (; index &lt; total; index+=4, i++) { //  512,    R     2. d1 = (this.distances[i]/2)|0; data[index] = d1; d1 = this.distances[i] - d1*2; d2 = (d1*128)|0; //   G -     2. data[index+1] = d2; //  B  A  255,     . data[index+2] = 255; data[index+3] = 255; } }</span></span></code> </pre><br><br>  Jetzt übergeben wir die Textur an unseren Shader, der bereits die Koordinaten und Radien der Lichtquellen hat.  Und verarbeite es so: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      uniform sampler2D iChannel0; #define STRENGTH 0.3 #define MAX_DARK 0.7 #define M_PI 3.141592653589793 #define M_PI2 6.283185307179586 //       float decodeDist(vec4 color) { return color.r*255.*2. + color.g*2.; } float getShadow(int i, float angle, float distance) { //   x   ==  float u = angle/M_PI2; //   y   ==     float v = float(i)/${MAX_LIGHTS}.; float shadowAfterDistance = decodeDist(texture2D(iChannel0, vec2(u, v))); //  1   ,  0  . return step(shadowAfterDistance, distance); } void main() { float lightness = 0.; for (int i = 0; i &lt; ${MAX_LIGHTS}; i++) { if (i &gt;= lightsCount) break; vec4 light = lights[i]; //       vec2 light2point = gl_FragCoord.xy - light.xy; float radius = light.z; float distance = length(light2point); float inLight = step(distance, radius); //      ,       //  . //      , //    ,          //           //     ,    if (inLight == 0.) continue; float angle = mod(-atan(light2point.y, light2point.x), M_PI2); // 1     0   float thisLightness = (1. - getShadow(i, angle, distance)); //,   “”  ,   ,  //    lightness += thisLightness*STRENGTH; } lightness = clamp(0., 1., lightness); gl_FragColor = mix(vec4(0,0,0,MAX_DARK), vec4(0,0,0,0), lightness); }</span></span></code> </pre> <br><br>  Ergebnis: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f9/0l/hj/f90lhj2yepescdli2qndmyx-xkq.png"></div>  <sup>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> )</sup> <br>  Jetzt können Sie ein wenig Schönheit bringen.  Lassen Sie das Licht mit der Entfernung verblassen, und die Schatten werden verschwommen. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1s/op/sg/1sopsggdgrpurmn0qsui8rcfhne.png"></div><br>  Für Unschärfe schaue ich auf benachbarte Ecken, + - Schritt, wie folgt: <br><br><pre> <code class="cpp hljs">thisLightness = (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle, distance)) * <span class="hljs-number"><span class="hljs-number">0.4</span></span> + (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle-SMOOTH_STEP, distance)) * <span class="hljs-number"><span class="hljs-number">0.2</span></span> + (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle+SMOOTH_STEP, distance)) * <span class="hljs-number"><span class="hljs-number">0.2</span></span> + (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle-SMOOTH_STEP*<span class="hljs-number"><span class="hljs-number">2.</span></span>, distance)) * <span class="hljs-number"><span class="hljs-number">0.1</span></span> + (<span class="hljs-number"><span class="hljs-number">1.</span></span> - getShadow(i, angle+SMOOTH_STEP*<span class="hljs-number"><span class="hljs-number">2.</span></span>, distance)) * <span class="hljs-number"><span class="hljs-number">0.1</span></span>;</code> </pre><br><br>  Wenn Sie alles zusammenfügen und die FPS messen, stellt sich Folgendes heraus: <br><br><ul><li>  Bei eingebauten Grafikkarten ist alles schlecht (&lt;30-40), auch für einfache Beispiele <br></li><li>  Alles andere ist in Ordnung, solange die Lichtquellen nicht sehr stark sind.  Das heißt, die Anzahl der Lichtquellen pro Pixel ist wichtig, nicht die Gesamtzahl. <br></li></ul><br><br>  Dieses Ergebnis hat mir sehr gut gefallen.  Sie konnten immer noch mit der Farbe der Beleuchtung spielen, aber ich tat es nicht.  Nachdem ich ein wenig gedreht und einige normale Karten hinzugefügt hatte, lud ich eine aktualisierte Version von NOPE hoch.  Sie sah jetzt so aus: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cq/nw/4o/cqnw4opdblgnm6ebys-lgbtvnt4.gif"></div><br><br>  Dann fing er an, einen Artikel vorzubereiten.  Ich sah mir so ein GIF an und dachte nach. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/de/zr/ctdezrcsaztxtgxx9jyioatirds.gif"></div><br>  „Es ist also fast ein Pseudo-3D-Look wie in Wolfenstein“, rief ich aus (ja, ich habe eine gute Vorstellungskraft).  Und tatsächlich - wenn wir davon ausgehen, dass alle Wände gleich hoch sind, reichen die Entfernungskarten aus, um die Szene zu erstellen.  Warum nicht versuchen? <br><br>  Die Szene sollte ungefähr so ​​aussehen. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lg/5v/-s/lg5v-sk8cmojfurrj_pnrg3xw0k.png"></div><br><br>  Also unsere Aufgabe: <br><br><ol><li>  Ermitteln Sie an einem Punkt auf dem Bildschirm die Weltkoordinaten für den Fall, dass keine Wände vorhanden sind. <br><br>  Wir werden dies berücksichtigen: <br><ul><li>  Zuerst normalisieren wir die Koordinaten eines Punktes auf dem Bildschirm so, dass sich in der Mitte des Bildschirms und an den Ecken (-1, -1) bzw. (1,1) ein Punkt (0,0) befindet <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l9/ki/fu/l9kifubvfwn50ust9lhtsik2f_k.png"></div></li><li>  Die x-Koordinate wird zum Winkel aus der Blickrichtung. Sie müssen sie nur mit A / 2 multiplizieren, wobei A der Betrachtungswinkel ist <br></li><li>  Die y-Koordinate bestimmt den Abstand vom Beobachter zum Punkt, im allgemeinen Fall d ~ 1 / y.  Für einen Punkt am unteren Rand des Bildschirms ist Abstand = 1, für einen Punkt in der Mitte des Bildschirms Abstand = unendlich. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8e/ua/4b/8eua4bycfatkegaiwbyu_eohxky.png"></div></li><li>  Wenn Sie also die Wände nicht berücksichtigen, befinden sich für jeden sichtbaren Punkt auf der Welt zwei Punkte auf dem Bildschirm - einer über der Mitte (an der „Decke“) und der andere unter (auf dem „Boden“). <br></li></ul></li><li>  Jetzt können wir uns die Tabelle der Entfernungen ansehen.  Wenn es eine Wand gibt, die näher als unser Punkt ist, müssen Sie eine Wand zeichnen.  Wenn nicht, bedeutet dies Boden oder Decke <br></li></ol><br>  Wir bekommen wie bestellt: <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qp/gj/lu/qpgjluavcmsuba51v0iovqdccc0.png"></div>  <sup>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> )</sup> <br>  Fügen Sie Beleuchtung hinzu - durchlaufen Sie auf die gleiche Weise die Lichtquellen und überprüfen Sie die Weltkoordinaten.  Und - der letzte Schliff - fügen Sie Texturen hinzu.  Dazu müssen Sie in einer Textur mit Abständen an dieser Stelle auch den Versatz u für die Wandtextur schreiben.  Hier hat sich Kanal b als nützlich erwiesen. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kn/ai/ay/knaiayi9epavp3cr8u6wcd4x2ss.png"></div>  <sup>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> )</sup> <br>  Perfekt. <br><br>  Nur ein Scherz. <br><br>  Natürlich unvollkommen.  Aber zum Teufel, ich habe immer noch gelesen, wie ich meinen Wolfenstein vor ungefähr 15 Jahren durch Rakecast machen kann, und ich wollte alles tun, und hier ist eine solche Gelegenheit! <br><br><h4>  Anstelle einer Schlussfolgerung </h4><br>  Am Anfang des Artikels erwähnte ich eine andere geheime Methode.  Da ist er: <br><br><blockquote>  <b>Nehmen Sie einfach den Motor, der bereits weiß wie.</b> </blockquote><br>  In der Tat, wenn Sie ein Spiel machen müssen, dann ist dies der korrekteste und schnellste Weg.  Warum müssen Sie Ihre Fahrräder umzäunen und langjährige Probleme lösen? <br><br>  Aber warum. <br><br>  In der 10. Klasse zog ich in eine andere Schule und stieß auf Probleme in Mathe.  Ich erinnere mich nicht an das genaue Beispiel, aber es war eine Gleichung mit Graden, die in jeder Hinsicht vereinfacht werden musste, aber es gelang einfach nicht.  Verzweifelt beriet ich mich mit meiner Schwester und sie sagte: "Also füge x <sup>2</sup> auf beiden Seiten hinzu, und alles wird sich zersetzen."  Und das war die Lösung: Fügen Sie hinzu, was nicht da war. <br><br>  Als ich viel später meinem Freund beim Bau meines Hauses half, musste ich einen Block auf die Schwelle setzen - um eine Nische zu füllen.  Und hier stehe ich und sortiere die Verkleidung der Stangen.  Man scheint zu passen, aber nicht ganz.  Andere sind viel kleiner.  Ich denke darüber nach, wie ich das Wort Glück hier sammeln kann, und ein Freund sagt: "Also haben sie die Rillen an einer kreisförmigen Stelle getrunken, an der es stört."  Und jetzt steht die große Bar schon still. <br><br>  Diese Geschichten sind durch einen solchen Effekt verbunden, den ich als „Inventareffekt“ bezeichnen werde.  Wenn Sie versuchen, eine Entscheidung aus vorhandenen Teilen zu treffen, ohne Material zu sehen, das in diesen Teilen verarbeitet und verfeinert werden kann.  Zahlen sind Holz, Geld oder Code. <br><br>  Oft habe ich den gleichen Effekt bei Kollegen in der Programmierung beobachtet.  Sie fühlen sich dem Material nicht sicher und geben manchmal nach, wenn es beispielsweise erforderlich ist, nicht standardmäßige Kontrollen durchzuführen.  Oder fügen Sie Unit-Tests hinzu, wo sie nicht waren.  Oder sie versuchen, beim Entwerfen einer Klasse für alles zu sorgen, und dann erhalten wir einen Dialog wie: <br>  - Das ist jetzt nicht nötig <br>  - Was ist, wenn es notwendig wird? <br>  - Dann werden wir hinzufügen.  Lassen Sie die Erweiterungspunkte, das ist alles.  Code ist kein Granit, sondern Plastilin. <br><br>  Und um zu lernen, das Material, mit dem wir arbeiten, zu sehen und zu fühlen, brauchen wir auch Fahrräder. <br><br>  Dies ist nicht nur ein Training für den Geist oder das Training.  Dies ist ein Weg, um ein qualitativ anderes Arbeitsniveau mit Code zu erreichen. <br><br>  Vielen Dank für das Lesen. <br><br>  Links, falls Sie vergessen haben, irgendwo zu klicken: <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alle Demos zusammen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Code</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eigentlich LD-Spiel mit Schatten</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434370/">https://habr.com/ru/post/de434370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434358/index.html">Importsubstitution von Betriebssystemen. Wie sehe ich ein inländisches Betriebssystem?</a></li>
<li><a href="../de434360/index.html">Erklärtes Gespräch über asynchrone Programmierung in Javascript</a></li>
<li><a href="../de434362/index.html">NICHT für 2019 prognostiziert</a></li>
<li><a href="../de434364/index.html">Hangfire Queue-Unterstützung</a></li>
<li><a href="../de434368/index.html">Maschinelles Lernen zum Auffinden von Fehlern im Code: Wie ich bei JetBrains Research interniert habe</a></li>
<li><a href="../de434374/index.html">RBAC in Kubernetes überprüfen</a></li>
<li><a href="../de434380/index.html">Grundlagen der Abhängigkeitsinjektion</a></li>
<li><a href="../de434382/index.html">Portierung von Alpine Linux auf RISC-V</a></li>
<li><a href="../de434384/index.html">Auf die Verantwortung der Darsteller</a></li>
<li><a href="../de434386/index.html">Douglas Engelbart: „Erweiterung des menschlichen Intellekts: Ein konzeptioneller Rahmen“</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>