<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì© üõÑ üë∏üèø 7 langkah untuk menggunakan Kamar. Panduan untuk memigrasi aplikasi Anda ke Kamar üêÇ üîç üè¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kamar adalah perpustakaan yang merupakan bagian dari komponen arsitektur Android. Ini memfasilitasi bekerja dengan objek SQLiteDatabase dalam aplikasi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>7 langkah untuk menggunakan Kamar. Panduan untuk memigrasi aplikasi Anda ke Kamar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441934/"><p><img src="https://habrastorage.org/getpro/habr/post_images/810/7f6/165/8107f6165672ecb492fe2ff90d693b05.png" alt="7 langkah untuk menggunakan Kamar. Panduan untuk memigrasi aplikasi Anda ke Kamar"></p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kamar</a> adalah perpustakaan yang merupakan bagian dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen arsitektur</a> Android.  Ini memfasilitasi bekerja dengan objek <code>SQLiteDatabase</code> dalam aplikasi, mengurangi jumlah kode standar dan memeriksa permintaan SQL pada waktu kompilasi. </p><br><p>  Sudah memiliki proyek Android yang menggunakan SQLite untuk menyimpan data?  Jika demikian, maka Anda dapat memindahkannya ke Kamar.  Mari kita lihat bagaimana cara mengambil proyek yang sudah ada dan refactor untuk menggunakan Room dalam 7 langkah sederhana. </p><br><blockquote>  <em><strong>TL; DR:</strong> perbarui dependensi gradle, buat entitas Anda, DAO dan basis data, ganti panggilan <code>SQLiteDatabase</code> dengan panggilan metode DAO, uji semua yang Anda buat atau modifikasi, dan hapus kelas yang tidak digunakan.</em>  <em>Itu saja!</em> </blockquote><a name="habracut"></a><br><p>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi sampel kami</a> untuk migrasi, kami bekerja dengan objek tipe <code>User</code> .  Kami menggunakan citarasa produk untuk menunjukkan berbagai implementasi tingkat data: </p><br><ol><li>  <strong>sqlite</strong> - menggunakan <code>SQLiteOpenHelper</code> dan antarmuka SQLite tradisional. </li><li>  <strong>room</strong> - menggantikan implementasinya dengan Room dan menyediakan migrasi. </li></ol><br><p>  Setiap opsi menggunakan lapisan antarmuka pengguna yang sama, yang bekerja dengan kelas <code>UserRepository</code> berkat pola MVP. </p><br><p>  Dalam varian sqlite, Anda akan melihat banyak kode yang sering diduplikasi dan menggunakan database di kelas <code>UsersDbHelper</code> dan <code>LocalUserDataSource</code> .  Kueri dibuat menggunakan <code>ContentValues</code> , dan data yang dikembalikan oleh objek <code>Cursor</code> dibaca kolom demi kolom.  Semua kode ini berkontribusi pada munculnya kesalahan implisit.  Misalnya, Anda bisa melewatkan menambahkan kolom ke kueri atau salah merakit objek dari database. </p><br><p>  Mari kita lihat bagaimana Room meningkatkan kode kita.  Awalnya, kami cukup menyalin kelas dari varian sqlite dan secara bertahap mengubahnya. </p><br><h2 id="shag-1-obnovlenie-zavisimostey-gradle">  Langkah 1. Memperbarui dependensi gradle </h2><br><p>  Ketergantungan untuk Kamar tersedia melalui repositori Google Maven yang baru.  Cukup tambahkan ke daftar repositori di file <code>build.gradle</code> utama Anda: </p><br><pre> <code class="plaintext hljs">allprojects { repositories { google() jcenter() } }</code> </pre> <br><p>  Tentukan versi perpustakaan Kamar di file yang sama.  Saat ini dalam versi alfa, tetapi tetap ikuti perkembangan untuk pembaruan versi pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman pengembang</a> : </p><br><pre> <code class="plaintext hljs">ext { roomVersion = '2.1.0-alpha03' }</code> </pre> <br><p>  Di <code>app/build.gradle</code> tambahkan dependensi untuk Kamar: </p><br><pre> <code class="plaintext hljs">dependencies { implementation ‚Äúandroid.arch.persistence.room:runtime:$rootProject.roomVersion‚Äù annotationProcessor ‚Äúandroid.arch.persistence.room:compiler:$rootProject.roomVersion‚Äù androidTestImplementation ‚Äúandroid.arch.persistence.room:testing:$rootProject.roomVersion‚Äù }</code> </pre> <br><p>  Untuk bermigrasi ke Kamar, kita perlu meningkatkan versi database, dan untuk menyimpan data pengguna, kita perlu mengimplementasikan kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Migrasi</a> .  Untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menguji migrasi</a> , kita perlu mengekspor skema.  Untuk melakukan ini, tambahkan kode berikut ke file <code>app/build.gradle</code> : </p><br><pre> <code class="plaintext hljs">android { defaultConfig { ... // used by Room, to test migrations javaCompileOptions { annotationProcessorOptions { arguments = ["room.schemaLocation": "$projectDir/schemas".toString()] } } } // used by Room, to test migrations sourceSets { androidTest.assets.srcDirs += files("$projectDir/schemas".toString()) } ...</code> </pre> <br><h2 id="shag-2-obnovlenie-klassov-modeli-do-suschnostey">  Langkah 2. Memperbarui kelas model ke entitas </h2><br><p>  Kamar membuat tabel untuk setiap kelas bertanda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@Entity</a> .  Bidang di kelas sesuai dengan kolom dalam tabel.  Akibatnya, kelas entitas, sebagai aturan, adalah kelas kecil model yang tidak mengandung logika apa pun.  Kelas <code>User</code> kami mewakili model untuk data dalam basis data.  Jadi, mari kita perbarui untuk memberi tahu Room bahwa itu harus membuat tabel berdasarkan kelas ini: </p><br><ul><li>  Beri anotasi kelas dengan <code>@Entity</code> dan gunakan properti <code>tableName</code> untuk menetapkan nama tabel. </li><li>  Tetapkan kunci utama dengan menambahkan penjelasan <code>@PrimaryKey</code> ke bidang yang benar - dalam kasus kami, ini adalah ID pengguna. </li><li>  Tentukan nama kolom untuk bidang kelas menggunakan anotasi <code>@ColumnInfo(name = "column_name")</code> .  Anda dapat melewati langkah ini jika bidang Anda sudah dinamai kolom yang harus dinamai. </li><li>  Jika ada beberapa konstruktor di kelas, tambahkan anotasi <code>@Ignore</code> untuk memberi tahu Kamar mana yang akan digunakan dan yang tidak. </li></ul><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span>(tableName = <span class="hljs-string"><span class="hljs-string">"users"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@PrimaryKey</span></span> <span class="hljs-meta"><span class="hljs-meta">@ColumnInfo</span></span>(name = <span class="hljs-string"><span class="hljs-string">"userid"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String mId; <span class="hljs-meta"><span class="hljs-meta">@ColumnInfo</span></span>(name = <span class="hljs-string"><span class="hljs-string">"username"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String mUserName; <span class="hljs-meta"><span class="hljs-meta">@ColumnInfo</span></span>(name = <span class="hljs-string"><span class="hljs-string">"last_update"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Date mDate; <span class="hljs-meta"><span class="hljs-meta">@Ignore</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String userName)</span></span></span><span class="hljs-function"> </span></span>{ mId = UUID.randomUUID().toString(); mUserName = userName; mDate = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(System.currentTimeMillis()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String id, String userName, Date date)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mId = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mUserName = userName; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mDate = date; } ... }</code> </pre> <br><p>  <strong>Catatan:</strong> untuk migrasi yang lancar, perhatikan nama-nama tabel dan kolom dalam implementasi asli dan pastikan Anda mengaturnya dengan benar di <code>@ColumnInfo</code> dan <code>@ColumnInfo</code> . </p><br><h2 id="shag-3-sozdanie-obektov-dostupa-k-dannym-dao">  Langkah 3. Membuat Objek Akses Data (DAO) </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DAO</a> bertanggung jawab untuk mendefinisikan metode akses database.  Dalam implementasi awal proyek SQLite kami, semua kueri basis data dieksekusi di kelas <code>LocalUserDataSource</code> , tempat kami bekerja dengan objek <code>Cursor</code> .  Di Kamar, kami tidak memerlukan semua kode yang terkait dengan kursor, dan kami hanya dapat mendefinisikan permintaan kami menggunakan anotasi di kelas <code>UserDao</code> . </p><br><p>  Misalnya, ketika menanyakan semua pengguna dari database, Room melakukan semua "kerja keras", dan kami hanya perlu menulis: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(‚ÄúSELECT * FROM Users‚Äù) <span class="hljs-function"><span class="hljs-function">List&lt;User&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><h2 id="shag-4-sozdanie-bazy-dannyh">  Langkah 4. Membuat database </h2><br><p>  Kami telah mendefinisikan tabel <code>Users</code> kami dan kueri yang terkait, tetapi kami belum membuat database yang akan menyatukan semua komponen Kamar ini.  Untuk melakukan ini, kita perlu mendefinisikan kelas abstrak yang memperluas <code>RoomDatabase</code> .  Kelas ini ditandai <code>@Database</code> , yang mencantumkan objek yang terkandung dalam database dan DAO yang mengaksesnya.  Versi database harus ditingkatkan 1 dibandingkan dengan nilai asli, jadi dalam kasus kami akan 2. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Database</span></span>(entities = {User.class}, version = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-meta"><span class="hljs-meta">@TypeConverters</span></span>(DateConverter.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UsersDatabase</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RoomDatabase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> UsersDatabase INSTANCE; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> UserDao </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">userDao</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>  Karena kami ingin menyimpan data pengguna, kami perlu mengimplementasikan ruang kelas <code>Migration</code> memberi tahu apa yang harus dilakukan ketika beralih dari versi 1 ke 2. Dalam kasus kami, karena skema basis data tidak berubah, kami hanya menyediakan implementasi kosong: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Migration MIGRATION_1_2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Migration(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">migrate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SupportSQLiteDatabase database)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     ,      . } };</span></span></code> </pre> <br><p>  Buat objek database di kelas <code>UsersDatabase</code> dengan mendefinisikan nama database dan migrasi: </p><br><pre> <code class="java hljs">database = Room.databaseBuilder(context.getApplicationContext(), UsersDatabase.class, <span class="hljs-string"><span class="hljs-string">"Sample.db"</span></span>) .addMigrations(MIGRATION_1_2) .build();</code> </pre> <br><p>  Untuk mempelajari lebih lanjut tentang cara menerapkan migrasi basis data dan cara kerjanya di bawah tenda, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos ini</a> . </p><br><h2 id="shag-5-obnovlenie-repozitoriya-dlya-ispolzovaniya-room">  Langkah 5. Memperbarui repositori untuk menggunakan Room </h2><br><p>  Kami membuat basis data, tabel pengguna, dan kueri kami, jadi sekarang saatnya menggunakannya.  Pada titik ini, kami akan memperbarui kelas <code>LocalUserDataSource</code> untuk menggunakan metode <code>UserDao</code> .  Untuk melakukan ini, pertama-tama kita perbarui konstruktor: hapus <code>Context</code> dan tambahkan <code>UserDao</code> .  Tentu saja, setiap kelas yang membuat turunan dari <code>LocalUserDataSource</code> juga harus diperbarui. </p><br><p>  Selanjutnya, kami akan memperbarui metode <code>LocalUserDataSource</code> yang membuat kueri dengan memanggil metode <code>UserDao</code> .  Misalnya, metode yang meminta semua pengguna sekarang terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;User&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mUserDao.getUsers(); }</code> </pre> <br><p>  Dan sekarang saatnya untuk meluncurkan apa yang kami lakukan. </p><br><p>  Salah satu fitur terbaik dari Room adalah bahwa jika Anda melakukan operasi database pada utas utama, aplikasi Anda akan macet dengan pesan kesalahan berikut: </p><br><pre> <code class="xml hljs">java.lang.IllegalStateException: Cannot access database on the main thread since it may potentially lock the UI for a long period of time.</code> </pre> <br><p>  Salah satu cara yang dapat diandalkan untuk memindahkan operasi I / O dari utas utama adalah membuat <code>Runnable</code> baru yang akan membuat utas baru untuk setiap kueri basis data.  Karena kami sudah menggunakan pendekatan ini dalam varian sqlite, tidak ada perubahan yang diperlukan. </p><br><h2 id="shag-6-testirovanie-na-ustroystve">  Langkah 6. Menguji perangkat </h2><br><p>  Kami menciptakan kelas-kelas baru - <code>UserDao</code> dan <code>UsersDatabase</code> dan mengubah <code>LocalUserDataSource</code> kami untuk menggunakan database Room.  Sekarang kita perlu mengujinya. </p><br><h3 id="testirovanie-userdao">  Menguji UserDao </h3><br><p>  Untuk menguji <code>UserDao</code> , kita perlu membuat kelas uji <code>AndroidJUnit4</code> .  Fitur menakjubkan dari Room adalah kemampuan untuk membuat basis data dalam memori.  Ini menghilangkan kebutuhan untuk membersihkan setelah setiap tes. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initDb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ mDatabase = Room.inMemoryDatabaseBuilder( InstrumentationRegistry.getContext(), UsersDatabase.class) .build(); }</code> </pre> <br><p>  Kita juga perlu memastikan bahwa kita menutup koneksi basis data setelah setiap tes. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@After</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeDb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ mDatabase.close(); }</code> </pre> <br><p>  Misalnya, untuk menguji login pengguna, kami menambahkan pengguna dan kemudian memeriksa untuk melihat apakah kami bisa mendapatkan pengguna itu dari database. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertAndGetUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      mDatabase.userDao().insertUser(USER); //        List&lt;User&gt; users = mDatabase.userDao().getUsers(); assertThat(users.size(), is(1)); User dbUser = users.get(0); assertEquals(dbUser.getId(), USER.getId()); assertEquals(dbUser.getUserName(), USER.getUserName()); }</span></span></code> </pre> <br><h3 id="testirovanie-ispolzovaniya-userdao-v-localuserdatasource">  Menguji penggunaan UserDao di LocalUserDataSource </h3><br><p>  Memastikan <code>LocalUserDataSource</code> masih berfungsi dengan benar adalah mudah, karena kami sudah memiliki tes yang menggambarkan perilaku kelas ini.  Yang perlu kita lakukan adalah membuat database di memori, mendapatkan objek <code>UserDao</code> dari itu, dan menggunakannya sebagai parameter untuk konstruktor <code>LocalUserDataSource</code> . </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initDb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ mDatabase = Room.inMemoryDatabaseBuilder( InstrumentationRegistry.getContext(), UsersDatabase.class) .build(); mDataSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LocalUserDataSource(mDatabase.userDao()); }</code> </pre> <br><p>  Sekali lagi, kita perlu memastikan bahwa kita menutup database setelah setiap tes. </p><br><h3 id="testirovanie-migracii-bazy-dannyh">  Pengujian Migrasi Basis Data </h3><br><p>  Anda dapat membaca lebih lanjut tentang cara menerapkan tes migrasi database, serta cara kerja <code>MigrationTestHelper</code> , dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting ini</a> . </p><br><p>  Anda juga dapat melihat kode dari contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi migrasi yang</a> lebih rinci. </p><br><h2 id="shag-7-udalenie-vsego-nenuzhnogo">  Langkah 7. Menghapus semua yang tidak perlu </h2><br><p>  Hapus semua kelas dan jalur kode yang tidak terpakai yang sekarang diganti oleh fungsionalitas Kamar.  Dalam proyek kami, kami hanya perlu menghapus kelas <code>UsersDbHelper</code> , yang memperpanjang kelas <code>SQLiteOpenHelper</code> . </p><br><p>  Jika Anda memiliki database yang lebih besar dan lebih kompleks, dan Anda ingin secara bertahap beralih ke Kamar, maka kami merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting ini</a> . </p><br><p>  Sekarang jumlah kode rawan kesalahan standar telah menurun, permintaan diperiksa pada waktu kompilasi, dan semuanya diuji.  Dalam 7 langkah sederhana, kami dapat memigrasi aplikasi yang ada ke Kamar.  Anda dapat melihat contoh aplikasi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441934/">https://habr.com/ru/post/id441934/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441916/index.html">Realitas kerja keras - Pusat Peluncuran Satelit Xichang - XSLC</a></li>
<li><a href="../id441918/index.html">Kami berada di UltraHD Morty! Cara menonton film apa pun dalam 4K</a></li>
<li><a href="../id441920/index.html">Strategi keamanan informasi: sudahkah Anda memutuskan cara untuk maju?</a></li>
<li><a href="../id441928/index.html">Luncurkan aplikasi di Openshift dan bandingkan alat yang ada</a></li>
<li><a href="../id441932/index.html">Cara menjadi yang terdepan dalam persaingan: SIBUR mengembangkan manufaktur aditif</a></li>
<li><a href="../id441938/index.html">Formula untuk bahasa Korea, atau mengenali Hangul dengan cepat, mudah dan tanpa kesalahan.</a></li>
<li><a href="../id441942/index.html">Melanggar - bukan membangun. Atau devolusi</a></li>
<li><a href="../id441944/index.html">Mengapa kami memilih Lexus RX450h</a></li>
<li><a href="../id441946/index.html">REST API pada Laravel dalam 100 baris kode</a></li>
<li><a href="../id441950/index.html">Eclipse Che 7 sudah ada di sini</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>