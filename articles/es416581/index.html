<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíè ü•ì üëµüèΩ Plantillas de tercer orden, o c√≥mo port√© Jinja2 a C ++ üëäüèº üßúüèæ üßñüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los "patrones" en el contexto de C ++ generalmente se refieren a construcciones de lenguaje muy espec√≠ficas. Hay plantillas simples que simplifican el...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plantillas de tercer orden, o c√≥mo port√© Jinja2 a C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416581/"><img src="https://habrastorage.org/getpro/habr/post_images/c81/fe0/548/c81fe0548837b911b9569cdf49d90ca2.jpg" alt="Logotipo de jinja2" align="left">  Los "patrones" en el contexto de C ++ generalmente se refieren a construcciones de lenguaje muy espec√≠ficas.  Hay plantillas simples que simplifican el trabajo con el mismo tipo de c√≥digo; estas son plantillas de clase y funci√≥n.  Si una plantilla tiene uno de los par√°metros por s√≠ mismo, entonces se puede decir que son plantillas de segundo orden y generan otras plantillas dependiendo de sus par√°metros.  Pero, ¬øqu√© pasa si sus capacidades no son suficientes y m√°s f√°ciles de generar de inmediato el texto fuente?  ¬øMucho c√≥digo fuente? <br>  Los fan√°ticos de Python y los dise√±os HTML est√°n familiarizados con una herramienta (motor, biblioteca) para trabajar con plantillas de texto llamada <b>Jinja2</b> .  En la entrada, este motor recibe un archivo de plantilla en el que el texto se puede mezclar con estructuras de control, la salida es texto claro en el que todas las estructuras de control se reemplazan con texto de acuerdo con los par√°metros especificados desde el exterior (o desde el interior).  En t√©rminos generales, esto es algo as√≠ como p√°ginas ASP (o C ++ - preprocesador), solo el lenguaje de marcado es diferente. <br>  Hasta ahora, la implementaci√≥n de este motor ha sido solo para Python.  Ahora es para C ++.  Sobre c√≥mo y por qu√© sucedi√≥, y ser√° discutido en el art√≠culo. <br><a name="habracut"></a><br><h2>  ¬øPor qu√© incluso tom√© esto? </h2><br>  De hecho, ¬øpor qu√©?  Despu√©s de todo, hay Python, para ello: una excelente implementaci√≥n, un mont√≥n de caracter√≠sticas, una especificaci√≥n completa para el lenguaje.  ¬°Toma y usa!  No me gusta Python: puede tomar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jinja2CppLight</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inja</a> , puertos parciales Jinja2 en C ++.  Al final, puede tomar el puerto C ++ {{ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Moustache</a> }}.  El diablo, como siempre, en los detalles.  Entonces, digamos, necesitaba la funcionalidad de los filtros de Jinja2 y las capacidades de la construcci√≥n extendida, que le permite crear plantillas extensibles (y tambi√©n macros e incluir, pero esto m√°s adelante).  Y ninguna de las implementaciones mencionadas admite esto.  ¬øPodr√≠a prescindir de todo esto?  Tambi√©n una buena pregunta.  Juzga por ti mismo.  Tengo un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto</a> cuyo objetivo es crear C ++ - a-C ++ generador de c√≥digo repetitivo.  Este generador autom√°tico recibe, por ejemplo, un archivo de encabezado escrito manualmente con estructuras o enumeraciones, y genera en funci√≥n de √©l funciones de serializaci√≥n / deserializaci√≥n o, por ejemplo, convertir elementos de enumeraci√≥n en cadenas (y viceversa).  Puede escuchar m√°s detalles sobre esta utilidad en mis informes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> (eng) o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> (rus). <br>  Entonces, una tarea t√≠pica resuelta en el proceso de trabajar en la utilidad es la creaci√≥n de archivos de encabezado, cada uno de los cuales tiene un encabezado (con ifdefs e incluye), un cuerpo con los contenidos principales y un pie de p√°gina.  Adem√°s, el contenido principal son las declaraciones generadas repletas de espacio de nombres.  En la ejecuci√≥n de C ++, el c√≥digo para crear dicho archivo de encabezado se parece a esto (y eso no es todo): <br><div class="spoiler">  <b class="spoiler_title">Mucho c√≥digo C ++</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Enum2StringGenerator::WriteHeaderContent(CppSourceStream &amp;hdrOs) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;reflection::EnumInfoPtr&gt; enums; WriteNamespaceContents(hdrOs, m_namespaces.GetRootNamespace(), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;enums](CppSourceStream &amp;os, reflection::NamespaceInfoPtr ns) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; enumInfo : ns-&gt;enums) { WriteEnumToStringConversion(os, enumInfo); WriteEnumFromStringConversion(os, enumInfo); enums.push_back(enumInfo); } }); hdrOs &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n"</span></span>; { out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flNs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\nnamespace flex_lib"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; flNs; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (reflection::EnumInfoPtr enumInfo : enums) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scopedParams = MakeScopedParams(hdrOs, enumInfo); { hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"template&lt;&gt;"</span></span>; out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"inline const char* Enum2String($enumFullQualifiedName$ e)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; body; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"return $namespaceQual$::$enumName$ToString(e);"</span></span>; } { hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"template&lt;&gt;"</span></span>; out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"inline $enumFullQualifiedName$ String2Enum&lt;$enumFullQualifiedName$&gt;(const char* itemName)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; body; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"return $namespaceQual$::StringTo$enumName$(itemName);"</span></span>; } } } { out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flNs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\nnamespace std"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; flNs; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (reflection::EnumInfoPtr enumInfo : enums) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scopedParams = MakeScopedParams(hdrOs, enumInfo); out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"inline std::string to_string($enumFullQualifiedName$ e)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; body; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"return $namespaceQual$::$enumName$ToString(e);"</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// Enum item to string conversion writer void Enum2StringGenerator::WriteEnumToStringConversion(CppSourceStream &amp;hdrOs, const reflection::EnumInfoPtr &amp;enumDescr) { auto scopedParams = MakeScopedParams(hdrOs, enumDescr); out::BracedStreamScope fnScope("inline const char* $enumName$ToString($enumScopedName$ e)", "\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; fnScope; { out::BracedStreamScope switchScope("switch (e)", "\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; switchScope; out::OutParams innerParams; for (auto&amp; i : enumDescr-&gt;items) { innerParams["itemName"] = i.itemName; hdrOs &lt;&lt; out::with_params(innerParams) &lt;&lt; out::new_line(-1) &lt;&lt; "case $prefix$$itemName$:" &lt;&lt; out::new_line(1) &lt;&lt; "return \"$itemName$\";"; } } hdrOs &lt;&lt; out::new_line(1) &lt;&lt; "return \"Unknown Item\";"; } // String to enum conversion writer void Enum2StringGenerator::WriteEnumFromStringConversion(CppSourceStream &amp;hdrOs, const reflection::EnumInfoPtr &amp;enumDescr) { auto params = MakeScopedParams(hdrOs, enumDescr); out::BracedStreamScope fnScope("inline $enumScopedName$ StringTo$enumName$(const char* itemName)", "\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; fnScope; { out::BracedStreamScope itemsScope("static std::pair&lt;const char*, $enumScopedName$&gt; items[] = ", ";\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; itemsScope; out::OutParams&amp; innerParams = params.GetParams(); auto items = enumDescr-&gt;items; std::sort(begin(items), end(items), [](auto&amp; i1, auto&amp; i2) {return i1.itemName &lt; i2.itemName;}); for (auto&amp; i : items) { innerParams["itemName"] = i.itemName; hdrOs &lt;&lt; out::with_params(innerParams) &lt;&lt; out::new_line(1) &lt;&lt; "{\"$itemName$\", $prefix$$itemName$},"; } } hdrOs &lt;&lt; out::with_params(params.GetParams()) &lt;&lt; R"( $enumScopedName$ result; if (!flex_lib::detail::String2Enum(itemName, items, result)) flex_lib::bad_enum_name::Throw(itemName, "$enumName$"); return result;)"; }</span></span></code> </pre> <br>  <a href="">Desde aqu√≠</a> <br></div></div><br>  Adem√°s, este c√≥digo cambia poco de un archivo a otro.  Por supuesto, puede usar el formato clang para formatear.  Pero esto no cancela el resto del trabajo manual sobre la generaci√≥n del texto fuente. <br>  Y luego, un buen momento, me di cuenta de que mi vida deber√≠a simplificarse.  No consider√© la opci√≥n de atornillar un lenguaje de script completo debido a la complejidad de apoyar el resultado final.  Pero para encontrar un motor de plantillas adecuado, ¬øpor qu√© no?  Me result√≥ √∫til buscar, lo encontr√©, luego encontr√© la especificaci√≥n Jinja2 y me di cuenta de que esto es exactamente lo que necesito.  De acuerdo con esta especificaci√≥n, las plantillas para generar encabezados se ver√≠an as√≠: <br><pre> <code class="cpp hljs">{% extends <span class="hljs-string"><span class="hljs-string">"header_skeleton.j2tpl"</span></span> %} {% block generator_headers %} <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;flex_lib/stringized_enum.h&gt; #include &lt;algorithm&gt; #include &lt;utility&gt; {% endblock %} {% block namespaced_decls %}{{super()}}{% endblock %} {% block namespace_content %} {% for enum in ns.enums | sort(attribute="name") %} {% set enumName = enum.name %} {% set scopeSpec = enum.scopeSpecifier %} {% set scopedName = scopeSpec ~ ('::' if scopeSpec) ~ enumName %} {% set prefix = (scopedName + '::') if not enumInfo.isScoped else (scopedName ~ '::' ~ scopeSpec ~ ('::' if scopeSpec)) %} inline const char* {{enumName}}ToString({{scopedName}} e) { switch (e) { {% for itemName in enum.items | map(attribute="itemName") | sort%} case {{prefix}}{{itemName}}: return "{{itemName}}"; {% endfor %} } return "Unknown Item"; } inline {{scopedName}} StringTo{{enumName}}(const char* itemName) { static std::pair&lt;const char*, {{scopedName}}&gt; items[] = { {% for itemName in enum.items | map(attribute="itemName") | sort %} {"{{itemName}}", {{prefix}}{{itemName}} } {{',' if not loop.last }} {% endfor %} }; {{scopedName}} result; if (!flex_lib::detail::String2Enum(itemName, items, result)) flex_lib::bad_enum_name::Throw(itemName, "{{enumName}}"); return result; } {% endfor %}{% endblock %} {% block global_decls %} {% for ns in [rootNamespace] recursive %} {% for enum in ns.enums %} template&lt;&gt; inline const char* flex_lib::Enum2String({{enum.fullQualifiedName}} e) { return {{enum.namespaceQualifier}}::{{enum.name}}ToString(e); } template&lt;&gt; inline {{enum.fullQualifiedName}} flex_lib::String2Enum&lt;{{enum.fullQualifiedName}}&gt;(const char* itemName) { return {{enum.namespaceQualifier}}::StringTo{{enum.name}}(itemName); } inline std::string to_string({{enum.fullQualifiedName}} e) { return {{enum.namespaceQualifier}}::{{enum.name}}ToString(e); } {% endfor %} {{loop(ns.namespaces)}} {% endfor %} {% endblock %}</span></span></span></span></code> </pre> <br>  <a href="">Desde aqu√≠</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c98/7d6/5da/c987d65da32b047a4eb3d2b7630fb99c.jpg" alt="imagen" align="right" width="50%">  Solo hab√≠a un problema: ninguno de los motores que encontr√© admit√≠a todo el conjunto de caracter√≠sticas que necesitaba.  Bueno, por supuesto, todos ten√≠an un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">defecto fatal</a> est√°ndar.  Pens√© un poco y decid√≠ que otro mundo no empeorar√≠a con otra implementaci√≥n del motor de plantillas.  Adem√°s, seg√∫n las estimaciones, la funcionalidad b√°sica no era tan dif√≠cil de implementar.  Despu√©s de todo, ¬°ahora en C ++ hay expresiones regulares! <br>  Y as√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">surgi√≥ el</a> proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jinja2Cpp</a> .  A expensas de la complejidad de implementar la funcionalidad b√°sica (muy b√°sica), casi adivin√©.  En general, omit√≠ exactamente el coeficiente de Pi al cuadrado: me llev√≥ un poco menos de tres meses escribir todo lo que necesitaba.  Pero cuando todo estuvo terminado, terminado e insertado en el "Programador autom√°tico", me di cuenta de que intent√© no en vano.  De hecho, la utilidad de generaci√≥n de c√≥digo recibi√≥ un poderoso lenguaje de scripting combinado con plantillas, lo que le abri√≥ nuevas oportunidades de desarrollo. <br>  NB: Tuve una idea para sujetar Python (o Lua).  Pero ninguno de los motores de secuencias de comandos existentes resuelve problemas "listos para usar" en la generaci√≥n de texto a partir de plantillas.  Es decir, Python a√∫n tendr√≠a que atornillar el mismo Jinja2, pero para Lua, busque algo diferente.  ¬øPor qu√© necesitaba este enlace adicional? <br><br><h2>  Implementaci√≥n del analizador </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/d32/570/463/d325704634011d586894096d9e09b20f.png" alt="imagen" align="left" width="60%">  La idea detr√°s de la estructura de las plantillas Jinja2 es bastante simple.  Si hay algo en el texto encerrado en un par de "{{" / "}}", entonces esto es "algo", una expresi√≥n que debe evaluarse, convertirse en una representaci√≥n de texto e insertarse en el resultado final.  Dentro del par "{%" / "%}" hay operadores como for, if, set, etc. Bueno, en "{#" / "#}" hay comentarios.  Despu√©s de estudiar la implementaci√≥n de Jinja2CppLight, decid√≠ que tratar de encontrar manualmente todas estas estructuras de control en el texto de la plantilla no era una muy buena idea.  Por lo tanto, me arm√© con una expresi√≥n regular bastante simple: (((\ {\ {) | (\} \}) | (\ {%) | (% \}) | (\ {#) | (# \}) | (\ n)), con la ayuda de la cual parti√≥ el texto en los fragmentos necesarios.  Y lo llam√≥ la fase aproximada de an√°lisis.  En la etapa inicial del trabajo, la idea mostr√≥ su efectividad (s√≠, de hecho, todav√≠a lo muestra), pero, en el buen sentido, tendr√° que ser refactorizada en el futuro, ya que ahora se imponen restricciones menores en el texto de la plantilla: escapando pares "{{" y "}}" en el texto se procesa tambi√©n "frente". <br>  En la segunda fase, solo se analiza en detalle lo que est√° dentro de los "corchetes".  Y aqu√≠ tuve que jugar.  Con inja, con Jinja2CppLight, el analizador de expresiones es bastante simple.  En el primer caso, en la misma expresi√≥n regular, en el segundo, escrito a mano, pero solo admite dise√±os muy simples.  El soporte para filtros, probadores, aritm√©tica compleja o indexaci√≥n est√° fuera de discusi√≥n.  Y era precisamente estas caracter√≠sticas de Jinja2 lo que m√°s quer√≠a.  Por lo tanto, no tuve otra opci√≥n que alterar un analizador LL (1) completo (en algunos lugares, sensible al contexto) que implementa la gram√°tica necesaria.  Hace unos diez o quince a√±os, probablemente tomar√≠a Bison o ANTLR para esto e implementar√≠a un analizador con su ayuda.  Hace unos siete a√±os, hubiera probado Boost.Spirit.  Ahora acabo de implementar el analizador que necesito, trabajando mediante el m√©todo de descenso recursivo, sin generar dependencias innecesarias y aumentar significativamente el tiempo de compilaci√≥n, como suceder√≠a si se utilizaran utilidades externas o Boost.Spirit.  En la salida del analizador, obtengo un AST (para expresiones o para operadores), que se guarda como una plantilla, listo para su posterior representaci√≥n. <br><div class="spoiler">  <b class="spoiler_title">Un ejemplo de l√≥gica de an√°lisis</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ExpressionEvaluatorPtr&lt;FullExpressionEvaluator&gt; ExpressionParser::ParseFullExpression(LexScanner &amp;lexer, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeIfPart) { ExpressionEvaluatorPtr&lt;FullExpressionEvaluator&gt; result; LexScanner::<span class="hljs-function"><span class="hljs-function">StateSaver </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lexer)</span></span></span></span>; ExpressionEvaluatorPtr&lt;FullExpressionEvaluator&gt; evaluator = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;FullExpressionEvaluator&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> value = ParseLogicalOr(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; evaluator-&gt;SetExpression(value); ExpressionEvaluatorPtr&lt;ExpressionFilter&gt; filter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.PeekNextToken() == <span class="hljs-string"><span class="hljs-string">'|'</span></span>) { lexer.EatToken(); filter = ParseFilterExpression(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!filter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; evaluator-&gt;SetFilter(filter); } ExpressionEvaluatorPtr&lt;IfExpression&gt; ifExpr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.PeekNextToken() == Token::If) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (includeIfPart) { lexer.EatToken(); ifExpr = ParseIfExpression(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ifExpr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; evaluator-&gt;SetTester(ifExpr); } } saver.Commit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluator; } ExpressionEvaluatorPtr&lt;Expression&gt; ExpressionParser::ParseLogicalOr(LexScanner&amp; lexer) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> left = ParseLogicalAnd(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.NextToken() != Token::LogicalOr) { lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> right = ParseLogicalOr(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;BinaryExpression&gt;(BinaryExpression::LogicalOr, left, right); } ExpressionEvaluatorPtr&lt;Expression&gt; ExpressionParser::ParseLogicalAnd(LexScanner&amp; lexer) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> left = ParseLogicalCompare(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.NextToken() != Token::LogicalAnd) { lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> right = ParseLogicalAnd(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;BinaryExpression&gt;(BinaryExpression::LogicalAnd, left, right); } ExpressionEvaluatorPtr&lt;Expression&gt; ExpressionParser::ParseLogicalCompare(LexScanner&amp; lexer) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> left = ParseStringConcat(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tok = lexer.NextToken(); BinaryExpression::Operation operation; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (tok.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::Equal: operation = BinaryExpression::LogicalEq; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::NotEqual: operation = BinaryExpression::LogicalNe; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>: operation = BinaryExpression::LogicalLt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>: operation = BinaryExpression::LogicalGt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::GreaterEqual: operation = BinaryExpression::LogicalGe; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::LessEqual: operation = BinaryExpression::LogicalLe; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::In: operation = BinaryExpression::In; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::Is: { Token nextTok = lexer.NextToken(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextTok != Token::Identifier) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name = AsString(nextTok.value); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> valid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; CallParams params; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.NextToken() == <span class="hljs-string"><span class="hljs-string">'('</span></span>) params = ParseCallParams(lexer, valid); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!valid) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;IsExpression&gt;(left, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(name), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(params)); } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> right = ParseStringConcat(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;BinaryExpression&gt;(operation, left, right); }</code> </pre> <br>  <a href="">Desde aqu√≠</a> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Fragmento de clases de √°rbol de expresi√≥n AST</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionFilter</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfExpression</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FullExpressionEvaluator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ExpressionEvaluatorBase { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExpressionEvaluatorPtr&lt;Expression&gt; expr)</span></span></span><span class="hljs-function"> </span></span>{ m_expression = expr; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExpressionEvaluatorPtr&lt;ExpressionFilter&gt; expr)</span></span></span><span class="hljs-function"> </span></span>{ m_filter = expr; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTester</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExpressionEvaluatorPtr&lt;IfExpression&gt; expr)</span></span></span><span class="hljs-function"> </span></span>{ m_tester = expr; } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream &amp;stream, RenderContext &amp;values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;Expression&gt; m_expression; ExpressionEvaluatorPtr&lt;ExpressionFilter&gt; m_filter; ExpressionEvaluatorPtr&lt;IfExpression&gt; m_tester; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueRefExpression</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ValueRefExpression(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> valueName) : m_valueName(valueName) { } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_valueName; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubscriptExpression</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SubscriptExpression(ExpressionEvaluatorPtr&lt;Expression&gt; value, ExpressionEvaluatorPtr&lt;Expression&gt; subscriptExpr) : m_value(value) , m_subscriptExpr(subscriptExpr) { } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;Expression&gt; m_value; ExpressionEvaluatorPtr&lt;Expression&gt; m_subscriptExpr; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantExpression</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ConstantExpression(InternalValue constant) : m_constant(constant) {} <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp;)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_constant; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: InternalValue m_constant; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TupleCreator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TupleCreator(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ExpressionEvaluatorPtr&lt;&gt;&gt; exprs) : m_exprs(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(exprs)) { } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp;)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ExpressionEvaluatorPtr&lt;&gt;&gt; m_exprs; };</code> </pre> <br>  <a href="">Desde aqu√≠</a> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Clases de ejemplo de operadores de √°rbol AST</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Statement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RendererBase { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = Statement&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> StatementPtr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CharT&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateImpl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForStatement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statement { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ForStatement(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vars, ExpressionEvaluatorPtr&lt;&gt; expr, ExpressionEvaluatorPtr&lt;&gt; ifExpr, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isRecursive) : m_vars(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(vars)) , m_value(expr) , m_ifExpr(ifExpr) , m_isRecursive(isRecursive) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMainBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_mainBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElseBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_elseBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream&amp; os, RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> InternalValue&amp; val, OutStream&amp; os, RenderContext&amp; values)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; m_vars; ExpressionEvaluatorPtr&lt;&gt; m_value; ExpressionEvaluatorPtr&lt;&gt; m_ifExpr; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_isRecursive; RendererPtr m_mainBody; RendererPtr m_elseBody; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ElseBranchStatement</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfStatement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statement { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: IfStatement(ExpressionEvaluatorPtr&lt;&gt; expr) : m_expr(expr) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMainBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_mainBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddElseBranch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatementPtr&lt;ElseBranchStatement&gt; branch)</span></span></span><span class="hljs-function"> </span></span>{ m_elseBranches.push_back(branch); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream&amp; os, RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;&gt; m_expr; RendererPtr m_mainBody; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;StatementPtr&lt;ElseBranchStatement&gt;&gt; m_elseBranches; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ElseBranchStatement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statement { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ElseBranchStatement(ExpressionEvaluatorPtr&lt;&gt; expr) : m_expr(expr) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldRender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMainBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_mainBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream&amp; os, RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;&gt; m_expr; RendererPtr m_mainBody; };</code> </pre><br>  <a href="">Desde aqu√≠</a> <br></div></div><br>  Los nodos AST se asocian solo con el texto de la plantilla y se convierten en valores totales en el momento de la representaci√≥n, teniendo en cuenta el contexto de representaci√≥n actual y sus par√°metros.  Esto nos permiti√≥ hacer patrones seguros para subprocesos.  Pero m√°s sobre esto en t√©rminos de la representaci√≥n real. <br>  Como el tokenizador principal, eleg√≠ la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lexertk</a> .  Tiene la licencia que necesito y solo encabezado.  Es cierto que tuve que cortar todas las campanas y silbatos del c√°lculo del equilibrio de los corchetes, etc., y dejar solo el tokenizador en s√≠, que (despu√©s de enderezar un poco con un archivo) aprendi√≥ a trabajar no solo con caracteres char, sino tambi√©n con caracteres wchar_t.  Adem√°s de este tokenizador, inclu√≠ otra clase que realiza tres funciones principales: a) abstrae el c√≥digo del analizador del tipo de caracteres con los que estamos trabajando, b) reconoce las palabras clave espec√≠ficas de Jinja2 yc) proporciona una interfaz conveniente para trabajar con el flujo de tokens: <br><div class="spoiler">  <b class="spoiler_title">LexScanner</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LexScanner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> Lexer::TokensList::const_iterator m_begin; Lexer::TokensList::const_iterator m_end; Lexer::TokensList::const_iterator m_cur; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateSaver</span></span></span><span class="hljs-class"> {</span></span> StateSaver(LexScanner&amp; scanner) : m_state(scanner.m_state) , m_scanner(scanner) { } ~StateSaver() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_commited) m_scanner.m_state = m_state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Commit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_commited = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } State m_state; LexScanner&amp; m_scanner; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_commited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }; LexScanner(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lexer&amp; lexer) { m_state.m_begin = lexer.GetTokens().begin(); m_state.m_end = lexer.GetTokens().end(); Reset(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_state.m_cur = m_state.m_begin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestoreState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> State&amp; state)</span></span></span><span class="hljs-function"> </span></span>{ m_state = state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur == m_state.m_end) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EofToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_state.m_cur ++; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur != m_state.m_end) ++ m_state.m_cur; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur != m_state.m_begin) -- m_state.m_cur; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PeekNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur == m_state.m_end) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EofToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_state.m_cur; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatIfEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, Token* tok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EatIfEqual(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Token::Type&gt;(type), tok); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatIfEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Token::Type type, Token* tok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur == m_state.m_end) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type == Token::Type::Eof &amp;&amp; tok) *tok = EofToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type == Token::Type::Eof; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur-&gt;type == type) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tok) *tok = *m_state.m_cur; ++ m_state.m_cur; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: State m_state; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EofToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Token eof; eof.type = Token::Eof; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> eof; } };</code> </pre> <br>  <a href="">Desde aqu√≠</a> <br></div></div><br>  Por lo tanto, a pesar de que el motor puede funcionar con char y wchar_t-templates, el c√≥digo de an√°lisis principal no depende del tipo de car√°cter.  Pero m√°s sobre esto en la secci√≥n sobre aventuras con tipos de personajes. <br>  Por separado, tuve que jugar con las estructuras de control.  En Jinja2, muchos de ellos est√°n emparejados.  Por ejemplo, for / endfor, if / endif, block / endblock, etc. Cada elemento del par va en sus propios "corchetes", y entre los elementos puede haber un mont√≥n de todo: solo texto sin formato y otros bloques de control.  Por lo tanto, el algoritmo para analizar la plantilla ten√≠a que hacerse sobre la base de la pila, al elemento superior actual del cual todas las construcciones e instrucciones reci√©n encontradas, as√≠ como fragmentos de texto simple entre ellas, "se adhieren".  Usando la misma pila, se verifica la ausencia de desequilibrio del tipo if-for-endif-endfor.  Como resultado de todo esto, el c√≥digo result√≥ no ser tan "compacto" como, por ejemplo, Jinja2CppLight (o inja), donde toda la implementaci√≥n est√° en una fuente (o encabezado).  Pero la l√≥gica de an√°lisis y, de hecho, la gram√°tica en el c√≥digo son m√°s claramente visibles, lo que simplifica su soporte y extensi√≥n.  Al menos eso es lo que buscaba.  Todav√≠a no es posible minimizar la cantidad de dependencias o la cantidad de c√≥digo, por lo que debe hacerlo m√°s comprensible. <br><br>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">siguiente parte,</a> hablaremos sobre el proceso de renderizaci√≥n de plantillas, pero por ahora - enlaces: <br>  Especificaci√≥n de Jinja2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://jinja.pocoo.org/docs/2.10/templates/</a> <br>  Implementaci√≥n de Jinja2Cpp: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/flexferrum/Jinja2Cpp</a> <br>  Implementaci√≥n de Jinja2CppLight: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/hughperkins/Jinja2CppLight</a> <br>  Implementaci√≥n lesionada: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/pantor/inja</a> <br>  Utilidad para generar c√≥digo basado en plantillas Jinja2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/flexferrum/autoprogrammer/tree/jinja2cpp_refactor</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416581/">https://habr.com/ru/post/es416581/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416569/index.html">Como Prius, pero solo en Linux: pensando en una oficina h√≠brida</a></li>
<li><a href="../es416573/index.html">Env√≠o de correo electr√≥nico desde cualquier direcci√≥n</a></li>
<li><a href="../es416575/index.html">An√°lisis de las interrupciones de la superconductividad de los imanes colisionadores de hadrones grandes en el CERN</a></li>
<li><a href="../es416577/index.html">Digest MBLT DEV: nuevo para desarrolladores de iOS</a></li>
<li><a href="../es416579/index.html">Controlamos los LED utilizando Web Bluetooth API y Arduino</a></li>
<li><a href="../es416583/index.html">¬øQu√© esc√°ner 3D comprar? Los 5 mejores esc√°neres 3D del 2018 de 3Dtool</a></li>
<li><a href="../es416585/index.html">Extensi√≥n web de navegador cruzado para scripts personalizados Parte 3</a></li>
<li><a href="../es416587/index.html">Algunas palabras sobre los subwoofers y por qu√© son adecuados para casi todos</a></li>
<li><a href="../es416589/index.html">C√©lulas muertas: uso de la canalizaci√≥n 3D para animaci√≥n 2D</a></li>
<li><a href="../es416591/index.html">"Apretar las tuercas": por qu√© todo el mundo comenz√≥ a hablar sobre endurecer la regulaci√≥n del sector de TI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>