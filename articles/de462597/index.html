<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöæ ‚ôÇÔ∏è üëÉüèø Typoskript und reagieren üìÑ üë®‚Äçüíº üôçüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Entwicklung von Javascript wird manchmal wie ein Detektiv. Wie verstehe ich den Code eines anderen? Es ist gut, wenn der Entwickler die subtile F√§...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Typoskript und reagieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462597/"><p> Die Entwicklung von Javascript wird manchmal wie ein Detektiv.  Wie verstehe ich den Code eines anderen?  Es ist gut, wenn der Entwickler die subtile F√§higkeit besitzt, Variablen zu benennen, damit andere den Punkt verstehen.  Aber was ist, wenn die Teammitglieder die Absicht ihres Kollegen immer noch nicht immer verstehen k√∂nnen?  Wie kann man verstehen, was in das Argument einer Funktion einflie√üt? </p><br><p>  Angenommen, das Funktionsargument hei√üt Fehler.  Wahrscheinlich ist in den Fehlern ein Array.  H√∂chstwahrscheinlich Linien?  Nun, dieses Array ist verst√§ndlich.  Immerhin wird seine L√§nge weiter √ºberpr√ºft.  Die Eigenschaft length hat jedoch auch eine Zeichenfolge.  Es scheint, dass Sie einen Haltepunkt setzen und das Skript ausf√ºhren m√ºssen, um es genau herauszufinden.  Gehen Sie dann das Skript auf der Benutzeroberfl√§che vollst√§ndig durch (zum Beispiel ben√∂tigen wir den letzten Schritt des Formulars).  In devtools ist nun ersichtlich, dass Fehler ein Objekt mit einer Reihe spezifischer Felder sind, einschlie√ülich des L√§ngenfelds. </p><br><p>  Eine solche Mehrdeutigkeit beim Parsen von Javascript-Code f√ºhrt zu einer Verschwendung von Entwicklerzeit.  Eine gute L√∂sung in diesem Fall k√∂nnte das Typoskript sein (im Folgenden ts).  Sie k√∂nnen es im n√§chsten Projekt verwenden oder, noch besser, die Unterst√ºtzung im vorhandenen Projekt vornehmen.  Danach wird die Zeit zum Verstehen des Codes einer anderen Person erheblich verk√ºrzt.  Um die Struktur von Daten zu verstehen, reicht ein Klick aus.  Sie k√∂nnen sich auf die Logik des Arbeitens mit Daten konzentrieren und jederzeit wissen, dass Sie den Code klar verstehen. </p><a name="habracut"></a><br><p>  Einige Vorteile von ts sollten beachtet werden.  Es ist in verschiedenen Frameworks weit verbreitet und eng mit Javascript verwandt.  Die Entwicklung von ts wird von den Bed√ºrfnissen der Frontend-Entwickler bestimmt. </p><br><p>  Dieser Artikel beschreibt die Entwicklung von Aufgabenanwendungen, aber nur eine kurze Beschreibung interessanter Punkte.  Den vollst√§ndigen Code finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Ich habe React, Typoskript und Mobx verwendet.  Mobx ist ein flexibles Tool zum Verwalten des Anwendungsstatus.  Mobx ist pr√§gnant.  Sie k√∂nnen damit synchron mit dem Status der Reaktionskomponenten arbeiten.  Kein Problem wie: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({<span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'another string'</span></span>}); alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.name);</code> </pre> <br><p>  In diesem Fall wird der alte state.name angezeigt. </p><br><p>  Dar√ºber hinaus ist mobx praktisch und beeintr√§chtigt die Arbeit mit ts-Typen nicht.  Sie k√∂nnen den Status als separate Klassen oder direkt in der Reaktionskomponente beschreiben. </p><br><p>  Der Einfachheit halber werden alle Komponenten im Komponentenordner abgelegt.  Im Ordner der Komponente wird eine Klasse mit einer Beschreibung des Status definiert, der logisch mit der Anzeige und dem Betrieb der Komponente verkn√ºpft ist. </p><br><p>  Der TodoItem-Ordner enth√§lt eine Datei mit der Reaktionskomponente TodoItem.tsx, eine Datei mit den Stilen TodoItem.module.scss und eine Statusdatei TodoItemState.ts. </p><br><p>  TodoItemState.ts beschreibt die Felder zum Speichern von Daten, den Zugriff darauf und die Regeln zum √Ñndern.  Das Spektrum der M√∂glichkeiten ist dank OOP und ts sehr gro√ü.  Ein Teil der Daten kann privat sein, ein Teil ist schreibgesch√ºtzt und so weiter.  Mit dem @ o-Dekorator werden beobachtbare Felder angegeben.  Reaktionskomponenten reagieren auf ihre Ver√§nderungen.  Die Dekoratoren @a ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Aktion</a> ) werden in Methoden zum √Ñndern des Status verwendet. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// TodoItemState.ts import { action as a, observable as o } from 'mobx'; export interface ITodoItem { id: string; name: string; completed: boolean; } export class TodoItemState { @o public readonly value: ITodoItem; @o public isEditMode: boolean = false; constructor(value: ITodoItem) { this.value = value; } @a public setIsEditMode = (value: boolean = true) =&gt; { this.isEditMode = value; }; @a public editName = (name: string) =&gt; { this.value.name = name; }; @a public editCompleted = (completed: boolean) =&gt; { this.value.completed = completed; }; }</span></span></code> </pre> <br><p>  In TodoItem.tsx werden nur zwei Eigenschaften an Requisiten √ºbergeben.  In mobx ist es f√ºr die Gesamtleistung einer Anwendung optimal, komplexe Datenstrukturen auf die Requisitenreaktionskomponente zu √ºbertragen.  Da wir ts verwenden, k√∂nnen wir den von der Komponente akzeptierten Objekttyp genau angeben. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// TodoItem.tsx import React, { ChangeEventHandler } from 'react'; import { observer } from 'mobx-react'; import { TodoItemState } from './TodoItemState'; import { EditModal } from 'components/EditModal'; import classNames from 'classnames'; import classes from './TodoItem.module.scss'; export interface ITodoItemProps { todo: TodoItemState; onDelete: (id: string) =&gt; void; } @observer export class TodoItem extends React.Component&lt;ITodoItemProps&gt; { private handleCompletedChange: ChangeEventHandler&lt;HTMLInputElement&gt; = e =&gt; { const { todo: { editCompleted }, } = this.props; editCompleted(e.target.checked); }; private handleDelete = () =&gt; { const { onDelete, todo } = this.props; onDelete(todo.value.id); }; private get editModal() { const { todo } = this.props; if (!todo.isEditMode) return null; return ( &lt;EditModal name={todo.value.name} onSubmit={this.handleSubmitEditName} onClose={this.closeEditModal} /&gt; ); } private handleSubmitEditName = (name: string) =&gt; { const { todo } = this.props; todo.editName(name); this.closeEditModal(); }; private closeEditModal = () =&gt; { const { todo } = this.props; todo.setIsEditMode(false); }; private openEditModal = () =&gt; { const { todo } = this.props; todo.setIsEditMode(); }; render() { const { todo } = this.props; const { name, completed } = todo.value; return ( &lt;div className={classes.root}&gt; &lt;input className={classes.chackbox} type="checkbox" checked={completed} onChange={this.handleCompletedChange} /&gt; &lt;div onClick={this.openEditModal} className={classNames( classes.name, completed &amp;&amp; classes.completedName )}&gt; {name} &lt;/div&gt; &lt;button onClick={this.handleDelete}&gt;del&lt;/button&gt; {this.editModal} &lt;/div&gt; ); } }</span></span></code> </pre> <br><p>  Die ITodoItemProps-Schnittstelle beschreibt die todo-Eigenschaft vom Typ TodoItemState.  Somit erhalten wir innerhalb der Reaktionskomponente Daten zur Anzeige und Methoden zu deren √Ñnderung.  Dar√ºber hinaus k√∂nnen Einschr√§nkungen beim √Ñndern von Daten je nach Aufgabenstellung sowohl in der Zustandsklasse als auch in den Methoden der Reaktionskomponente beschrieben werden. </p><br><p>  Die TodoList-Komponente √§hnelt TodoItem.  In TodoListState.ts k√∂nnen Sie Getter mit dem Dekorator @c (@computed) sehen.  Dies sind gew√∂hnliche Klassen-Getter, nur ihre Werte werden gespeichert und wiedergegeben, wenn sich ihre Abh√§ngigkeiten √§ndern.  Das vom Design berechnete Modell √§hnelt Redux-Selektoren.  Praktischerweise ist es nicht erforderlich, wie bei React.memo oder reselect, eine Liste von Abh√§ngigkeiten explizit zu √ºbergeben.  Reaktionskomponenten reagieren sowohl auf berechnete √Ñnderungen als auch auf beobachtbare √Ñnderungen.  Ein interessantes Merkmal ist, dass die Neuberechnung des Werts nicht erfolgt, wenn die Berechnung derzeit nicht am Rendering beteiligt ist (was Ressourcen spart).  Daher kann die Berechnung trotz konstanter Abh√§ngigkeitswerte neu berechnet werden (es gibt eine M√∂glichkeit, mobx explizit anzuweisen, den berechneten Wert zu speichern). </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// TodoListState.ts import { action as a, observable as o, computed as c } from 'mobx'; import { ITodoItem, TodoItemState } from 'components/TodoItem'; export enum TCurrentView { completed, active, all, } export class TodoListState { @o public currentView: TCurrentView = TCurrentView.all; @o private _todos: TodoItemState[] = []; @c public get todos(): TodoItemState[] { switch (this.currentView) { case TCurrentView.active: return this.activeTodos; case TCurrentView.completed: return this.completedTodos; default: return this._todos; } } @c public get completedTodos() { return this._todos.filter(t =&gt; t.value.completed); } @c public get activeTodos() { return this._todos.filter(t =&gt; !t.value.completed); } @a public setTodos(todos: ITodoItem[]) { this._todos = todos.map(t =&gt; new TodoItemState(t)); } @a public addTodo = (todo: ITodoItem) =&gt; { this._todos.push(new TodoItemState(todo)); }; @a public removeTodo = (id: string): boolean =&gt; { const index = this._todos.findIndex(todo =&gt; todo.value.id === id); if (index === -1) return false; this._todos.splice(index, 1); return true; }; }</span></span></code> </pre> <br><p>  Die Zugriffsliste ist nur √ºber ein berechnetes Feld ge√∂ffnet, in dem je nach Anzeigemodus der erforderliche gefilterte Datensatz zur√ºckgegeben wird (abgeschlossen, aktiv oder alle Aufgaben).  Die Aufgabenabh√§ngigkeiten geben die berechneten Felder completeTodos, activeTodos und private beobachtbare _todos an. </p><br><p>  Betrachten Sie die Hauptkomponente der App.  Es wird ein Formular zum Hinzuf√ºgen neuer Aufgaben und einer Aufgabenliste gerendert.  Eine Instanz des AppSate-Hauptstatus wird sofort erstellt. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// App.tsx import React from 'react'; import { observer } from 'mobx-react'; import { TodoList, initialTodos } from 'components/TodoList'; import { AddTodo } from 'components/AddTodo'; import { AppState } from './AppState'; import classes from './App.module.scss'; export interface IAppProps {} @observer export class App extends React.Component&lt;IAppProps&gt; { private appState = new AppState(); constructor(props: IAppProps) { super(props); this.appState.todoList.setTodos(initialTodos); } render() { const { addTodo, todoList } = this.appState; return ( &lt;div className={classes.root}&gt; &lt;div className={classes.container}&gt; &lt;AddTodo onAdd={addTodo} /&gt; &lt;TodoList todoListState={todoList} /&gt; &lt;/div&gt; &lt;/div&gt; ); } }</span></span></code> </pre> <br><p>  Das Feld appState enth√§lt eine Instanz der TodoListState-Klasse zum Anzeigen der TodoList-Komponente und der Methode zum Hinzuf√ºgen neuer Aufgaben, die an die AddTodo-Komponente √ºbergeben wird. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// AppState.ts import { action as a } from 'mobx'; import { TodoListState } from 'components/TodoList'; import { ITodoItem } from 'components/TodoItem'; export class AppState { public todoList = new TodoListState(); @a public addTodo = (value: string) =&gt; { const newTodo: ITodoItem = { id: Date.now().toString(), name: value, completed: false, }; this.todoList.addTodo(newTodo); }; }</span></span></code> </pre> <br><p>  Die AddTodo-Komponente hat einen isolierten Zustand.  Es gibt keinen Zugang vom allgemeinen Staat.  Die einzige Verbindung zu appState besteht beim Senden eines Formulars √ºber die Methode appState.addTodo. <br>  F√ºr den Status der AddTodo-Komponente wird die formstate-Bibliothek verwendet, die mit ts und mobx sehr gut befreundet ist.  Mit Formstate k√∂nnen Sie bequem mit Formularen arbeiten, Formulare validieren und vieles mehr.  Das Formular hat nur einen erforderlichen Feldnamen. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// AddTodoState.ts import { FormState, FieldState } from 'formstate'; export class AddTodoState { // Create a field public name = new FieldState('').validators( val =&gt; !val &amp;&amp; 'name is required' ); // Compose fields into a form public form = new FormState({ name: this.name, }); public onSubmit = async () =&gt; { // Validate all fields const res = await this.form.validate(); // If any errors you would know if (res.hasError) { console.error(this.form.error); return; } const name = this.name.$; this.form.reset(); return name; }; }</span></span></code> </pre> <br><p>  Im Allgemeinen ist es nicht sinnvoll, das Verhalten aller Komponenten vollst√§ndig zu beschreiben.  Den vollst√§ndigen Code finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Dieser Artikel beschreibt den Versuch des Autors, einfachen, flexiblen und strukturierten Code zu schreiben, der leicht zu pflegen ist.  React unterteilt die Benutzeroberfl√§che in Komponenten.  Die Komponenten beschreiben Zustandsklassen (jede Klasse kann separat getestet werden).  Instanzen von Zust√§nden werden je nach Aufgabe entweder in der Komponente selbst oder auf einer h√∂heren Ebene erstellt.  Praktischerweise k√∂nnen Sie dank Typoskript Klassenfeldtypen und Komponenteneigenschaftstypen angeben.  Dank mobx k√∂nnen wir, f√ºr den Entwickler fast unmerklich, Reaktionskomponenten auf Daten√§nderungen reagieren lassen. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462597/">https://habr.com/ru/post/de462597/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462585/index.html">Schnelle CRUD-Erstellung mit nest, @ nestjsx / crud und TestMace</a></li>
<li><a href="../de462587/index.html">AirTest IDE und Bilderkennung - Automatisierung des Testens von Handyspielen basierend auf Bilderkennung</a></li>
<li><a href="../de462589/index.html">Erstellen Sie eine Pipeline f√ºr die Streaming-Datenverarbeitung. Teil 2</a></li>
<li><a href="../de462593/index.html">Auf der anderen Seite des Standes</a></li>
<li><a href="../de462595/index.html">Pr√ºfung und Pr√ºfung von Briefen: Worauf Sie beim Layout achten sollten</a></li>
<li><a href="../de462601/index.html">Sichern von Windows-Servern in AWS</a></li>
<li><a href="../de462605/index.html">Italienische Spur in der Kryptographie</a></li>
<li><a href="../de462607/index.html">Wie ich eine Bibliothek f√ºr den Yandex.Music-Dienst geschrieben habe</a></li>
<li><a href="../de462615/index.html">Warum ist es so schwierig zu entscheiden, welchen Film man sich ansieht (und neuronale Netze l√∂sen dieses Problem nicht)?</a></li>
<li><a href="../de462619/index.html">Kinder, Mathe und R.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>