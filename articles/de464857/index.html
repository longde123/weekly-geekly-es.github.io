<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüîß ‚¨áÔ∏è üôáüèº Multitasking Microkernel OS Development - Scheduler ü§õüèø üë®üèæ‚Äçü§ù‚Äçüë®üèº ü§∏üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem Sie die grundlegenden Schritte zum Schreiben von Hello World-Kerneln aus der Artikelserie von Habr√© gelesen haben, ist es an der Zeit, mit der...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multitasking Microkernel OS Development - Scheduler</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464857/">  Nachdem Sie die grundlegenden Schritte zum Schreiben von Hello World-Kerneln aus der Artikelserie von Habr√© gelesen haben, ist es an der Zeit, mit der ernsthaften Entwicklung der grundlegendsten Tools zu beginnen: Heap-Allokator und Scheduler. <br><br>  <b>Wichtig</b> : <br>  1. Diese Unterrichtsreihe f√ºr Anf√§nger.  Ziel ist es, ein ganzheitliches Bild der Welt zu erstellen.  Ich hatte sehr lange die Tanenbaum-Theorie im Kopf und konnte sie nicht mit der Praxis verbinden.  F√ºr diejenigen, die das gleiche haben - ich widme diesen Artikel. <br>  2. Der Code ist der einfachste und d√ºmmste, aber so klar wie m√∂glich.  Mein Ziel ist es, Ihnen ein Verst√§ndnis zu vermitteln, damit Sie Ihren eigenen Kernel schreiben k√∂nnen, viel cooler als das. <br>  3. Ich werde das Repo ver√∂ffentlichen, sobald ich es f√ºr ein breites Spektrum bereit halte.  Ich schreibe einen kleinen Teil, debugge und drehe ein Video-Tutorial.  Ich habe kein fertiges Produkt. <br><br>  Ehrlich gesagt habe ich lange dar√ºber nachgedacht, ob ich anfangen soll, Artikel zu schreiben und Video-Tutorials zu einem so verdr√§ngten Thema zu machen.  Die Leidenschaft f√ºr die Systemprogrammierung und der Mangel an strukturierten Informationen auf Russisch haben mich dennoch zu diesem Experiment getrieben.  Wenn meine Arbeit gefragt ist, plane ich daher, Artikel mindestens einmal im Monat und h√∂chstens einmal pro Woche zu ver√∂ffentlichen. <br><a name="habracut"></a><br>  Ich tr√§umte davon, mein Betriebssystem in der zehnten Klasse zu schreiben.  Das Buch Tanenbaum hat eine erstaunliche Eigenschaft.  Jeder, der es fr√ºher oder sp√§ter ber√ºhrt, beginnt davon zu tr√§umen, sein eigenes Betriebssystem zu schreiben.  Aber ich habe damals nichts geschrieben, nachdem mir klar wurde, dass es unm√∂glich ist, an einem Masttag eine saubere Bin√§rdatei mit einem Code zu kompilieren und zu verkn√ºpfen.  Ich musste Linux studieren, zur Universit√§t gehen, zur Arbeit gehen.  Alles w√§re nichts.  Ja, erst zehn Jahre sp√§ter wurde ein Traum wahr.  Jetzt, wo ich mir bei React langweilige Formen ausgedacht habe, schaue ich zur√ºck, erinnere mich an die Leidenschaft, mit der ich Stunden f√ºr den Disassembler und Debugger verbracht, die Packer entfernt, die Crackboxen zerbrochen, nachts viele Artikel aus Schulromanen gelesen habe ... und ich verstehe, dass mein Leben anders h√§tte verlaufen k√∂nnen.  Ganz anders.  Wenn ich nur eine Person h√§tte, die mir am Anfang helfen k√∂nnte.  Aber die Zeit ist vorbei.  Programme sind schwer zu brechen.  Der Linux-Kernel ist unglaublich gro√ü geworden.  Hypervisoren erschienen.  Intel Assembler ist so gro√ü geworden, dass bei Betrachtung einer Liste von Befehlen im Handbuch jede Begeisterung f√ºr das Erlernen dieser Befehle verschwindet.  Wir mussten im Internet Brot verdienen.  Ja  Die Welt der Systemprogrammierung hat ihre goldenen Jahre √ºberlebt. <br><br>  Daher widme ich allen Studenten, deren Begeisterung noch nicht ersch√∂pft ist, ein detailliertes Tutorial, wie man den einfachsten Multitasking-Mikrokernel-Kern mit eigener Shell von Grund auf neu erstellt.  Und ich m√∂chte alle warnen, die noch nicht erschienen sind, dass dies eine undankbare und nicht hilfreiche Angelegenheit ist, wenn auch schrecklich interessant.  Und die Jugend hat, wie Sie wissen, ihre eigenen Sorgen. <br><br>  Lass uns gehen! <br><br>  Dieser <b>Artikel enth√§lt ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video-Tutorial,</a></b> das in meinem Heimstudio aufgenommen wurde.  Es ist direkt dem Code gewidmet. <br><br>  Beginnen wir mit der Entwicklung des Heap-Managers. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kmalloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kfree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *addr)</span></span></span></span>;</code> </pre> <br>  Um einen Heap-Allokator zu schreiben, m√ºssen Sie die Regionen mit freien und belegten Adressen speichern.  Dies ist am einfachsten als Richtungsliste zu implementieren.  Die Implementierung einer gerichteten Liste selbst muss √ºber ein statisches Array erfolgen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_head_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_head_t</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_head_t</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_valid; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data; } attribute(packed); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_definition_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> base; u_int slots; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> slot_size; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_head_t</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_head_t</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br>  Elemente einer solchen begrenzten Liste sind Aufzeichnungen von Speicherbereichen.  Dar√ºber hinaus k√∂nnen zwischen benachbarten Regionen keine L√∂cher vorhanden sein.  Wenn freier Speicher vorhanden ist, wird dies durch ein separates Listenelement beschrieben. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kheap_entry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_head_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* static (array placed) list */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> addr; <span class="hljs-comment"><span class="hljs-comment">/* physical address */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size; <span class="hljs-comment"><span class="hljs-comment">/* memory block size */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_buzy; <span class="hljs-comment"><span class="hljs-comment">/* whether block used */</span></span> } attribute(packed); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kheap_entry_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kheap_blocks</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KHEAP_MAX_ENTRIES</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_definition_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kheap_list</span></span></span><span class="hljs-class"> = {</span></span> .head = null, .tail = null, .slot_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">kheap_entry_t</span></span>), .slots = KHEAP_MAX_ENTRIES, .base = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)kheap_blocks };</code> </pre><br>  Am Anfang der kheap_entry_t-Struktur steht slist_head_t, mit der Sie den Heap-Datensatztyp problemlos in ein Listenelement umwandeln k√∂nnen. <br><br>  Betrachten Sie nun den einfachsten Heap-Allokator-Algorithmus (kmalloc): <br><br><ol><li>  Wenn keine freien Bl√∂cke vorhanden sind, w√§hlen Sie einen neuen Block mit der erforderlichen Gr√∂√üe aus (jedoch nicht mehr als die maximale Heap-Gr√∂√üe). </li><li>  Ansonsten schauen wir uns alle freien Bl√∂cke an.  Wenn wir einen freien Block finden, schauen Sie sich seine Gr√∂√üe an.  Wenn es reicht, nimm es.  Wenn es einen √úberschuss gibt, erstellen Sie einen neuen leeren Block mit der Gr√∂√üe des √úberschusses.  Andernfalls erweitern wir, wenn es nicht ausreicht und letzteres, die Heap-Grenze (aber nicht mehr als das Maximum). </li></ol><br>  Der speicherfreie Algorithmus ist √§hnlich (kfree): <br><br><ol><li>  Suchen Sie einen Block, dessen Adresse mit der freizugebenden Adresse beginnt.  √úberpr√ºfen Sie, ob er besch√§ftigt ist.  Als frei markieren. </li><li>  Wenn es rechts oder links einen freien Nachbarn gibt, der sich in einem Block mit ihm vereinigt. </li></ol><br>  Der n√§chste Artikel befasst sich mit der Implementierung des Heap-Algorithmus. <br><br>  Schreiben wir den einfachsten Scheduler.  Die Aufgabe sieht folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* cyclic list */</span></span> u_short tid; <span class="hljs-comment"><span class="hljs-comment">/* task id */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gp_registers_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gp_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* general purpose registers */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op_registers_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* other purpose registers */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flags_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flags</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* processor flags */</span></span> u_int time; <span class="hljs-comment"><span class="hljs-comment">/* time of task execution */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reschedule; <span class="hljs-comment"><span class="hljs-comment">/* whether task need to be rescheduled */</span></span> u_short status; <span class="hljs-comment"><span class="hljs-comment">/* task status */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> msg_count_in; <span class="hljs-comment"><span class="hljs-comment">/* count of incomming messages */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg_buff</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TASK_MSG_BUFF_SIZE</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-comment"><span class="hljs-comment">/* task message buffer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *kstack; <span class="hljs-comment"><span class="hljs-comment">/* kernel stack top */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ustack; <span class="hljs-comment"><span class="hljs-comment">/* user stack top */</span></span> } attribute(packed); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_definition_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_list</span></span></span><span class="hljs-class"> = {</span></span> .head = null, .slot_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">task_t</span></span>) };</code> </pre><br>  Wir wissen bereits, wie man Speicher zuweist und Aufgaben daher als Ringliste organisiert.  Daher ist es bequemer, die folgende Aufgabe relativ zur aktuellen Aufgabe mit dem gew√ºnschten Status zu √ºbernehmen (wir verwenden den Status TASK_RUNNING, wenn die Aufgabe ausgef√ºhrt wird).  Zun√§chst gehen wir davon aus, dass alle Aufgaben im Kernel-Schutzring ausgef√ºhrt werden (es ist einfacher, den Scheduler zu debuggen) und mit einem Stapel auskommen.  In Zukunft werden wir TSS befestigen. <br><br>  Wir haben die Aufgaben erledigt, jetzt die Planung selbst.  F√ºgen Sie dem IDT einen Timer-Handler hinzu und aktivieren Sie die Unterbrechung der gew√ºnschten IRQ-Leitung im PIC.  Durch Unterbrechen des Timers (und am Ende des Kernel-Initialisierungscodes) √ºbertragen wir die Steuerung an den Scheduler und √ºbergeben die R√ºcksprungadresse und die Adresse zuvor gespeicherter Register aus dem Timer-Interrupt: <br><br><pre> <code class="plaintext hljs">/* * Handle IRQ0 * void asm_ih_timer(unsigned long *addr) */ asm_ih_timer: cli pushal mov %esp,%ebp mov %ebp,%ebx pushl %ebx # &amp;reg add $32,%ebx pushl %ebx # &amp;ret addr call ih_timer mov %ebp,%esp popal sti iretl</code> </pre><br>  Im Scheduler pr√ºfen wir, ob zu diesem Zeitpunkt eine Aufgabe ausgef√ºhrt wurde.  In diesem Fall erh√∂hen wir den Z√§hler f√ºr die Ausf√ºhrungszeit und pr√ºfen, ob das Kontingent √ºberschritten wird.  Wenn nicht, kehren Sie ruhig zur√ºck.  Wenn dies √ºberschritten wird, m√ºssen Sie die Aufgabe neu planen.  Wir speichern seinen Status (die Adresse der gespeicherten Register und die im Stapel gespeicherte R√ºcksprungadresse durch Unterbrechen des Timers sind praktisch). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* save task state */</span></span> current_task-&gt;op_registers.eip = *ret_addr; current_task-&gt;op_registers.cs = *(u16 *)((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)ret_addr + <span class="hljs-number"><span class="hljs-number">4</span></span>); *(u32 *)(&amp;current_task-&gt;flags) = *(u32 *)((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)ret_addr + <span class="hljs-number"><span class="hljs-number">6</span></span>) | <span class="hljs-number"><span class="hljs-number">0x200</span></span>; current_task-&gt;op_registers.u_esp = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)ret_addr + <span class="hljs-number"><span class="hljs-number">12</span></span>; current_task-&gt;gp_registers.esp = current_task-&gt;op_registers.u_esp; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;current_task-&gt;gp_registers, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)reg_addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">gp_registers_t</span></span>));</code> </pre><br>  Wir nehmen die Stapeladresse der neuen Aufgabe und bilden dort einen R√ºckgaberahmen f√ºr den Befehl iret.  Dann rufen wir die Assembler-Funktion auf, um den Kontext zu wechseln. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* prepare context for the next task */</span></span> next_task-&gt;op_registers.u_esp -= <span class="hljs-number"><span class="hljs-number">4</span></span>; *(u32 *)(next_task-&gt;op_registers.u_esp) = (*(u16 *)(&amp;next_task-&gt;flags)) | <span class="hljs-number"><span class="hljs-number">0x200</span></span>; next_task-&gt;op_registers.u_esp -= <span class="hljs-number"><span class="hljs-number">4</span></span>; *(u32 *)(next_task-&gt;op_registers.u_esp) = next_task-&gt;op_registers.cs; next_task-&gt;op_registers.u_esp -= <span class="hljs-number"><span class="hljs-number">4</span></span>; *(u32 *)(next_task-&gt;op_registers.u_esp) = next_task-&gt;op_registers.eip; next_task-&gt;gp_registers.esp = next_task-&gt;op_registers.u_esp; next_task-&gt;op_registers.u_esp -= <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">gp_registers_t</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)next_task-&gt;op_registers.u_esp, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)&amp;next_task-&gt;gp_registers, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">gp_registers_t</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/* update current task pointer */</span></span> current_task = next_task; <span class="hljs-comment"><span class="hljs-comment">/* run next task */</span></span> asm_switch_context(next_task-&gt;op_registers.u_esp);</code> </pre><br>  Der Kontextwechsel selbst sieht folgenderma√üen aus: <br><br><pre> <code class="plaintext hljs"># # Switch context # void asm_switch_context(u32 esp) # asm_switch_context: mov 4(%esp),%ebp # ebp = esp mov %ebp,%esp popal sti iretl</code> </pre><br>  Der Scheduler ist bereit. <br><br>  <b>Den</b> vollst√§ndigen Code finden Sie <b>im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video-Tutorial</a></b> zum Artikel.  Es ber√ºcksichtigt nicht nur den Scheduler, sondern auch den Prozess des Ladens, Kompilierens und Konfigurierens von IDT f√ºr diejenigen, die vergessen haben: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-Uk6k_3juW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464857/">https://habr.com/ru/post/de464857/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464841/index.html">Habr Weekly # 15 / √úber die Kraft einer guten Geschichte (und ein bisschen √ºber Brath√§hnchen)</a></li>
<li><a href="../de464843/index.html">Angenehm mit n√ºtzlich oder Entwicklung f√ºr ASIO in C ++</a></li>
<li><a href="../de464847/index.html">Trainingsprojekt bei Godot - Pong (Teil 1) Erstellen und Anpassen einer Gameplay-Szene</a></li>
<li><a href="../de464849/index.html">Die Verwendung von R f√ºr Dienstprogrammaufgaben</a></li>
<li><a href="../de464853/index.html">Wo man Audioger√§te h√∂rt: eine Kultur von Themeninstitutionen f√ºr Audiofans - von Japan bis Russland</a></li>
<li><a href="../de464859/index.html">Steuerung mehrerer Nema 17-Schrittmotoren gleichzeitig oder von NemaStepper</a></li>
<li><a href="../de464861/index.html">Scrum Mini Referenz und Anleitung</a></li>
<li><a href="../de464863/index.html">Natas Web. Passage der CTF-Plattform zur Ausnutzung von Web-Schwachstellen. Teil 4</a></li>
<li><a href="../de464865/index.html">Telegramm als Data Warehouse f√ºr IT-Projekte</a></li>
<li><a href="../de464867/index.html">"Radiergummi"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>