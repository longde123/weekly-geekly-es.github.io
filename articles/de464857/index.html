<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🔧 ⬇️ 🙇🏼 Multitasking Microkernel OS Development - Scheduler 🤛🏿 👨🏾‍🤝‍👨🏼 🤸🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nachdem Sie die grundlegenden Schritte zum Schreiben von Hello World-Kerneln aus der Artikelserie von Habré gelesen haben, ist es an der Zeit, mit der...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multitasking Microkernel OS Development - Scheduler</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464857/">  Nachdem Sie die grundlegenden Schritte zum Schreiben von Hello World-Kerneln aus der Artikelserie von Habré gelesen haben, ist es an der Zeit, mit der ernsthaften Entwicklung der grundlegendsten Tools zu beginnen: Heap-Allokator und Scheduler. <br><br>  <b>Wichtig</b> : <br>  1. Diese Unterrichtsreihe für Anfänger.  Ziel ist es, ein ganzheitliches Bild der Welt zu erstellen.  Ich hatte sehr lange die Tanenbaum-Theorie im Kopf und konnte sie nicht mit der Praxis verbinden.  Für diejenigen, die das gleiche haben - ich widme diesen Artikel. <br>  2. Der Code ist der einfachste und dümmste, aber so klar wie möglich.  Mein Ziel ist es, Ihnen ein Verständnis zu vermitteln, damit Sie Ihren eigenen Kernel schreiben können, viel cooler als das. <br>  3. Ich werde das Repo veröffentlichen, sobald ich es für ein breites Spektrum bereit halte.  Ich schreibe einen kleinen Teil, debugge und drehe ein Video-Tutorial.  Ich habe kein fertiges Produkt. <br><br>  Ehrlich gesagt habe ich lange darüber nachgedacht, ob ich anfangen soll, Artikel zu schreiben und Video-Tutorials zu einem so verdrängten Thema zu machen.  Die Leidenschaft für die Systemprogrammierung und der Mangel an strukturierten Informationen auf Russisch haben mich dennoch zu diesem Experiment getrieben.  Wenn meine Arbeit gefragt ist, plane ich daher, Artikel mindestens einmal im Monat und höchstens einmal pro Woche zu veröffentlichen. <br><a name="habracut"></a><br>  Ich träumte davon, mein Betriebssystem in der zehnten Klasse zu schreiben.  Das Buch Tanenbaum hat eine erstaunliche Eigenschaft.  Jeder, der es früher oder später berührt, beginnt davon zu träumen, sein eigenes Betriebssystem zu schreiben.  Aber ich habe damals nichts geschrieben, nachdem mir klar wurde, dass es unmöglich ist, an einem Masttag eine saubere Binärdatei mit einem Code zu kompilieren und zu verknüpfen.  Ich musste Linux studieren, zur Universität gehen, zur Arbeit gehen.  Alles wäre nichts.  Ja, erst zehn Jahre später wurde ein Traum wahr.  Jetzt, wo ich mir bei React langweilige Formen ausgedacht habe, schaue ich zurück, erinnere mich an die Leidenschaft, mit der ich Stunden für den Disassembler und Debugger verbracht, die Packer entfernt, die Crackboxen zerbrochen, nachts viele Artikel aus Schulromanen gelesen habe ... und ich verstehe, dass mein Leben anders hätte verlaufen können.  Ganz anders.  Wenn ich nur eine Person hätte, die mir am Anfang helfen könnte.  Aber die Zeit ist vorbei.  Programme sind schwer zu brechen.  Der Linux-Kernel ist unglaublich groß geworden.  Hypervisoren erschienen.  Intel Assembler ist so groß geworden, dass bei Betrachtung einer Liste von Befehlen im Handbuch jede Begeisterung für das Erlernen dieser Befehle verschwindet.  Wir mussten im Internet Brot verdienen.  Ja  Die Welt der Systemprogrammierung hat ihre goldenen Jahre überlebt. <br><br>  Daher widme ich allen Studenten, deren Begeisterung noch nicht erschöpft ist, ein detailliertes Tutorial, wie man den einfachsten Multitasking-Mikrokernel-Kern mit eigener Shell von Grund auf neu erstellt.  Und ich möchte alle warnen, die noch nicht erschienen sind, dass dies eine undankbare und nicht hilfreiche Angelegenheit ist, wenn auch schrecklich interessant.  Und die Jugend hat, wie Sie wissen, ihre eigenen Sorgen. <br><br>  Lass uns gehen! <br><br>  Dieser <b>Artikel enthält ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video-Tutorial,</a></b> das in meinem Heimstudio aufgenommen wurde.  Es ist direkt dem Code gewidmet. <br><br>  Beginnen wir mit der Entwicklung des Heap-Managers. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kmalloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kfree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *addr)</span></span></span></span>;</code> </pre> <br>  Um einen Heap-Allokator zu schreiben, müssen Sie die Regionen mit freien und belegten Adressen speichern.  Dies ist am einfachsten als Richtungsliste zu implementieren.  Die Implementierung einer gerichteten Liste selbst muss über ein statisches Array erfolgen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_head_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_head_t</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_head_t</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_valid; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *data; } attribute(packed); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_definition_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> base; u_int slots; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> slot_size; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_head_t</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_head_t</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br>  Elemente einer solchen begrenzten Liste sind Aufzeichnungen von Speicherbereichen.  Darüber hinaus können zwischen benachbarten Regionen keine Löcher vorhanden sein.  Wenn freier Speicher vorhanden ist, wird dies durch ein separates Listenelement beschrieben. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kheap_entry_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_head_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* static (array placed) list */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> addr; <span class="hljs-comment"><span class="hljs-comment">/* physical address */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size; <span class="hljs-comment"><span class="hljs-comment">/* memory block size */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_buzy; <span class="hljs-comment"><span class="hljs-comment">/* whether block used */</span></span> } attribute(packed); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kheap_entry_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kheap_blocks</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KHEAP_MAX_ENTRIES</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slist_definition_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kheap_list</span></span></span><span class="hljs-class"> = {</span></span> .head = null, .tail = null, .slot_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">kheap_entry_t</span></span>), .slots = KHEAP_MAX_ENTRIES, .base = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)kheap_blocks };</code> </pre><br>  Am Anfang der kheap_entry_t-Struktur steht slist_head_t, mit der Sie den Heap-Datensatztyp problemlos in ein Listenelement umwandeln können. <br><br>  Betrachten Sie nun den einfachsten Heap-Allokator-Algorithmus (kmalloc): <br><br><ol><li>  Wenn keine freien Blöcke vorhanden sind, wählen Sie einen neuen Block mit der erforderlichen Größe aus (jedoch nicht mehr als die maximale Heap-Größe). </li><li>  Ansonsten schauen wir uns alle freien Blöcke an.  Wenn wir einen freien Block finden, schauen Sie sich seine Größe an.  Wenn es reicht, nimm es.  Wenn es einen Überschuss gibt, erstellen Sie einen neuen leeren Block mit der Größe des Überschusses.  Andernfalls erweitern wir, wenn es nicht ausreicht und letzteres, die Heap-Grenze (aber nicht mehr als das Maximum). </li></ol><br>  Der speicherfreie Algorithmus ist ähnlich (kfree): <br><br><ol><li>  Suchen Sie einen Block, dessen Adresse mit der freizugebenden Adresse beginnt.  Überprüfen Sie, ob er beschäftigt ist.  Als frei markieren. </li><li>  Wenn es rechts oder links einen freien Nachbarn gibt, der sich in einem Block mit ihm vereinigt. </li></ol><br>  Der nächste Artikel befasst sich mit der Implementierung des Heap-Algorithmus. <br><br>  Schreiben wir den einfachsten Scheduler.  Die Aufgabe sieht folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_head_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* cyclic list */</span></span> u_short tid; <span class="hljs-comment"><span class="hljs-comment">/* task id */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gp_registers_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gp_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* general purpose registers */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op_registers_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">op_registers</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* other purpose registers */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flags_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flags</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* processor flags */</span></span> u_int time; <span class="hljs-comment"><span class="hljs-comment">/* time of task execution */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reschedule; <span class="hljs-comment"><span class="hljs-comment">/* whether task need to be rescheduled */</span></span> u_short status; <span class="hljs-comment"><span class="hljs-comment">/* task status */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> msg_count_in; <span class="hljs-comment"><span class="hljs-comment">/* count of incomming messages */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg_buff</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TASK_MSG_BUFF_SIZE</span></span></span><span class="hljs-class">];</span></span> <span class="hljs-comment"><span class="hljs-comment">/* task message buffer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *kstack; <span class="hljs-comment"><span class="hljs-comment">/* kernel stack top */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ustack; <span class="hljs-comment"><span class="hljs-comment">/* user stack top */</span></span> } attribute(packed); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clist_definition_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">task_list</span></span></span><span class="hljs-class"> = {</span></span> .head = null, .slot_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">task_t</span></span>) };</code> </pre><br>  Wir wissen bereits, wie man Speicher zuweist und Aufgaben daher als Ringliste organisiert.  Daher ist es bequemer, die folgende Aufgabe relativ zur aktuellen Aufgabe mit dem gewünschten Status zu übernehmen (wir verwenden den Status TASK_RUNNING, wenn die Aufgabe ausgeführt wird).  Zunächst gehen wir davon aus, dass alle Aufgaben im Kernel-Schutzring ausgeführt werden (es ist einfacher, den Scheduler zu debuggen) und mit einem Stapel auskommen.  In Zukunft werden wir TSS befestigen. <br><br>  Wir haben die Aufgaben erledigt, jetzt die Planung selbst.  Fügen Sie dem IDT einen Timer-Handler hinzu und aktivieren Sie die Unterbrechung der gewünschten IRQ-Leitung im PIC.  Durch Unterbrechen des Timers (und am Ende des Kernel-Initialisierungscodes) übertragen wir die Steuerung an den Scheduler und übergeben die Rücksprungadresse und die Adresse zuvor gespeicherter Register aus dem Timer-Interrupt: <br><br><pre> <code class="plaintext hljs">/* * Handle IRQ0 * void asm_ih_timer(unsigned long *addr) */ asm_ih_timer: cli pushal mov %esp,%ebp mov %ebp,%ebx pushl %ebx # &amp;reg add $32,%ebx pushl %ebx # &amp;ret addr call ih_timer mov %ebp,%esp popal sti iretl</code> </pre><br>  Im Scheduler prüfen wir, ob zu diesem Zeitpunkt eine Aufgabe ausgeführt wurde.  In diesem Fall erhöhen wir den Zähler für die Ausführungszeit und prüfen, ob das Kontingent überschritten wird.  Wenn nicht, kehren Sie ruhig zurück.  Wenn dies überschritten wird, müssen Sie die Aufgabe neu planen.  Wir speichern seinen Status (die Adresse der gespeicherten Register und die im Stapel gespeicherte Rücksprungadresse durch Unterbrechen des Timers sind praktisch). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* save task state */</span></span> current_task-&gt;op_registers.eip = *ret_addr; current_task-&gt;op_registers.cs = *(u16 *)((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)ret_addr + <span class="hljs-number"><span class="hljs-number">4</span></span>); *(u32 *)(&amp;current_task-&gt;flags) = *(u32 *)((<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)ret_addr + <span class="hljs-number"><span class="hljs-number">6</span></span>) | <span class="hljs-number"><span class="hljs-number">0x200</span></span>; current_task-&gt;op_registers.u_esp = (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)ret_addr + <span class="hljs-number"><span class="hljs-number">12</span></span>; current_task-&gt;gp_registers.esp = current_task-&gt;op_registers.u_esp; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(&amp;current_task-&gt;gp_registers, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)reg_addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">gp_registers_t</span></span>));</code> </pre><br>  Wir nehmen die Stapeladresse der neuen Aufgabe und bilden dort einen Rückgaberahmen für den Befehl iret.  Dann rufen wir die Assembler-Funktion auf, um den Kontext zu wechseln. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">/* prepare context for the next task */</span></span> next_task-&gt;op_registers.u_esp -= <span class="hljs-number"><span class="hljs-number">4</span></span>; *(u32 *)(next_task-&gt;op_registers.u_esp) = (*(u16 *)(&amp;next_task-&gt;flags)) | <span class="hljs-number"><span class="hljs-number">0x200</span></span>; next_task-&gt;op_registers.u_esp -= <span class="hljs-number"><span class="hljs-number">4</span></span>; *(u32 *)(next_task-&gt;op_registers.u_esp) = next_task-&gt;op_registers.cs; next_task-&gt;op_registers.u_esp -= <span class="hljs-number"><span class="hljs-number">4</span></span>; *(u32 *)(next_task-&gt;op_registers.u_esp) = next_task-&gt;op_registers.eip; next_task-&gt;gp_registers.esp = next_task-&gt;op_registers.u_esp; next_task-&gt;op_registers.u_esp -= <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">gp_registers_t</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)next_task-&gt;op_registers.u_esp, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)&amp;next_task-&gt;gp_registers, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct <span class="hljs-keyword"><span class="hljs-keyword">gp_registers_t</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/* update current task pointer */</span></span> current_task = next_task; <span class="hljs-comment"><span class="hljs-comment">/* run next task */</span></span> asm_switch_context(next_task-&gt;op_registers.u_esp);</code> </pre><br>  Der Kontextwechsel selbst sieht folgendermaßen aus: <br><br><pre> <code class="plaintext hljs"># # Switch context # void asm_switch_context(u32 esp) # asm_switch_context: mov 4(%esp),%ebp # ebp = esp mov %ebp,%esp popal sti iretl</code> </pre><br>  Der Scheduler ist bereit. <br><br>  <b>Den</b> vollständigen Code finden Sie <b>im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video-Tutorial</a></b> zum Artikel.  Es berücksichtigt nicht nur den Scheduler, sondern auch den Prozess des Ladens, Kompilierens und Konfigurierens von IDT für diejenigen, die vergessen haben: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-Uk6k_3juW4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464857/">https://habr.com/ru/post/de464857/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464841/index.html">Habr Weekly # 15 / Über die Kraft einer guten Geschichte (und ein bisschen über Brathähnchen)</a></li>
<li><a href="../de464843/index.html">Angenehm mit nützlich oder Entwicklung für ASIO in C ++</a></li>
<li><a href="../de464847/index.html">Trainingsprojekt bei Godot - Pong (Teil 1) Erstellen und Anpassen einer Gameplay-Szene</a></li>
<li><a href="../de464849/index.html">Die Verwendung von R für Dienstprogrammaufgaben</a></li>
<li><a href="../de464853/index.html">Wo man Audiogeräte hört: eine Kultur von Themeninstitutionen für Audiofans - von Japan bis Russland</a></li>
<li><a href="../de464859/index.html">Steuerung mehrerer Nema 17-Schrittmotoren gleichzeitig oder von NemaStepper</a></li>
<li><a href="../de464861/index.html">Scrum Mini Referenz und Anleitung</a></li>
<li><a href="../de464863/index.html">Natas Web. Passage der CTF-Plattform zur Ausnutzung von Web-Schwachstellen. Teil 4</a></li>
<li><a href="../de464865/index.html">Telegramm als Data Warehouse für IT-Projekte</a></li>
<li><a href="../de464867/index.html">"Radiergummi"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>