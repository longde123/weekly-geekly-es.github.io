<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò™Ô∏è üïç üõ°Ô∏è Wir zerlegen und zeigen qualifizierte Zertifikate mit Python / Tkinter an üôÖüèø üë©üèª‚Äçüíº üë®üèø‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qualifizierte Zertifikate wurden schnell zu einem festen Bestandteil des Alltags. Und immer mehr Menschen wollen dieses "Biest" von innen sehen. Dies ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir zerlegen und zeigen qualifizierte Zertifikate mit Python / Tkinter an</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421107/"><img src="https://habrastorage.org/webt/nc/op/59/ncop592ddqui_ckgkjas77-ccuq.png" align="left">  Qualifizierte Zertifikate wurden schnell zu einem festen Bestandteil des Alltags.  Und immer mehr Menschen wollen dieses "Biest" von innen sehen.  Dies ist einerseits.  Andererseits werden immer mehr Anwendungen entwickelt, in denen Informationen aus diesen Zertifikaten verwendet werden.  Und dies sind nicht nur Attribute der TIN oder BIN des Inhabers oder Herausgebers des Zertifikats.  Dies k√∂nnen Informationen dar√ºber sein, welcher kryptografische Anbieter vom Zertifikatsinhaber (subjectSignTool-Attribut) zum Generieren eines privaten Schl√ºssels verwendet wurde oder auf dessen Grundlage zertifiziert bedeutet, dass ein Zertifizierungszentrum (CA) erstellt wurde, das ein Zertifikat ausgestellt hat.  Wenn Sie ein Programm schreiben, das die ausgestellten Zertifikate analysiert, k√∂nnen Sie interessante Statistiken dar√ºber sammeln, welche Tools zum Schutz kryptografischer Informationen von Zertifikatsinhabern verwendet werden und auf deren Grundlage (wenn auch weniger interessante) zertifizierte (oder nicht zertifizierte) Fonds-Zertifizierungsstellen bereitgestellt werden (Attribut issuerSignTools): <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/iy/l7/-z/iyl7-zghkwsdmk4zfzx9fa1azma.png"><br><br>  In den Freifl√§chen von Habr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wurde</a> bereits erfolgreich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">versucht,</a> ein qualifiziertes Zertifikat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zu</a> zerlegen.  Leider betraf die Analyse nur das Erhalten der Attribute TIN, PSRN und SNILS, die Teil des definierten Namens DN (Distinguished Name) sind.  Obwohl, warum leider?  Der Autor hatte ein spezifisches Problem und es wurde gel√∂st.  Wir m√∂chten √ºber Python auf die Attribute eines qualifizierten Zertifikats zugreifen und ein grafisches Dienstprogramm zum Anzeigen dieser Attribute bereitstellen. <br><br>  Um auf die Attribute des Zertifikats zuzugreifen, verwenden wir das Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fsb795</a> .  Das Paket ist sowohl f√ºr Pytho2 als auch f√ºr Python3 verf√ºgbar, sowohl f√ºr Linux als auch f√ºr Windows.  Um es zu installieren, f√ºhren Sie einfach den traditionellen Befehl aus: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># python -m pip install fsb795 Collecting fsb795 Requirement already satisfied: pyasn1-modules&gt;=0.2.2 in /usr/lib/python2.7/site-packages (from fsb795) (0.2.2) Collecting pyasn1&gt;=0.4.4 (from fsb795) Using cached https://files.pythonhosted.org/packages/d1/a1/7790cc85db38daa874f6a2e6308131b9953feb1367f2ae2d1123bb93a9f5/pyasn1-0.4.4-py2.py3-none-any.whl Requirement already satisfied: six in /usr/lib/python2.7/site-packages (from fsb795) (1.11.0) Installing collected packages: pyasn1, fsb795 Successfully installed fsb795-1.5.2 pyasn1-0.4.4 [root@localhost GCryptGOST]#</span></span></code> </pre> <br>  Das Paket fsb795 erfordert die Pakete pyasn1 und pyasn1-modules.  Wenn sie nicht installiert sind, wird daher versucht, sie zu installieren. <br><br>  F√ºr Python3 sieht dieser Befehl folgenderma√üen aus: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># python -m pip install fsb795 ... #</span></span></code> </pre> <br>  Sie k√∂nnen auch die Installationspakete <a href="">python3</a> und <a href="">python2</a> herunterladen und lokal <a href="">installieren</a> . <br>  Der Name des Pakets weist in Analogie zu den Modulen aus dem Paket pyasn1-modules, z. B. rfc2459 usw., darauf hin, dass es f√ºr die Verwendung mit Zertifikaten ausgelegt ist, die den Anforderungen des Ordens des Bundessicherheitsdienstes der Russischen F√∂deration vom 27. Dezember 2011 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nr. 795</a> ‚ÄûBei Genehmigung Anforderungen f√ºr die Form eines qualifizierten Zertifikats ... ". <br><br>  Der Zugriff auf das Zertifikat im Paket fsb795 wird √ºber die Zertifikatklasse implementiert: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- import os, sys import pyasn1 import binascii import six from pyasn1_modules import rfc2459, pem from pyasn1.codec.der import decoder from datetime import datetime, timedelta class Certificate: #  cert_full = '' cert = '' pyver = '' formatCert = '' def __init__ (self,fileorstr): #     if not os.path.exists(fileorstr): #  ,  ,     #    PEM- strcert = fileorstr.strip('\n') if (strcert[0:27] != '-----BEGIN CERTIFICATE-----'): return idx, substrate = pem.readPemBlocksFromFile(six.StringIO( strcert), ('-----BEGIN CERTIFICATE-----', '-----END CERTIFICATE-----') ) self.pyver = sys.version[0] try: self.cert_full, rest = decoder.decode(substrate, asn1Spec=rfc2459.Certificate()) self.cert = self.cert_full["tbsCertificate"] self.formatCert = 'PEM' except: self.pyver = '' self.formatCert = '' return #   #  self.pyver   python self.pyver = sys.version[0] filename = fileorstr if (self.pyver == '2'): if sys.platform != "win32": filename = filename.encode("UTF-8") else: filename = filename.encode("CP1251") #  DER file1 = open(filename, "rb") substrate = file1.read() if (self.pyver == '2'): b0 = ord(substrate[0]) b1 = ord(substrate[1]) else: b0 = substrate[0] b1 = substrate[1] #  PEM/DER,   0x30,       127  if (b0 == 48 and b1 &gt; 128) : self.formatCert = 'DER' else: self.formatCert = 'PEM' file1 = open(filename, "r") idx, substrate = pem.readPemBlocksFromFile( file1, ('-----BEGIN CERTIFICATE-----', '-----END CERTIFICATE-----') ) file1.close() try: self.cert_full, rest = decoder.decode(substrate, asn1Spec=rfc2459.Certificate()) self.cert = self.cert_full["tbsCertificate"] except: self.pyver = '' self.formatCert = '' #       def subjectSignTool(self): . . . #,     if __name__ == "__main__": . . .</span></span></code> </pre> <br>  Um eine Instanz eines Objekts f√ºr ein bestimmtes Zertifikat zu erstellen, reicht es aus, die folgende Anweisung auszuf√ºhren: <br><br><pre> <code class="bash hljs">$ python Python 2.7.15 (default, May 23 2018, 14:20:56) [GCC 5.4.0] on linux Type <span class="hljs-string"><span class="hljs-string">"help"</span></span>, <span class="hljs-string"><span class="hljs-string">"copyright"</span></span>, <span class="hljs-string"><span class="hljs-string">"credits"</span></span> or <span class="hljs-string"><span class="hljs-string">"license"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;import fsb795 &gt;&gt;tek_cert = fsb795.Certificate(&lt;/  &gt;) &gt;&gt;</code> </pre><br>  Als Parameter wird beim Erstellen einer Instanz der Klasse ein Zertifikat angegeben, das entweder in einer PEM- oder DER-Datei oder als Zeichenfolge im PEM-Format vorliegen kann. <br><br>  Nach der Erstellung hat jede Instanz vier Attribute: pyver, formatCert, cert_full und cert. <br>  Mit dem pyver-Attribut k√∂nnen Sie √ºberpr√ºfen, wie das Parsen des Zertifikats verlaufen ist.  Wenn pyver einer leeren Zeichenfolge entspricht, enth√§lt die Datei oder Zeichenfolge kein Zertifikat.  Andernfalls enth√§lt das Pyver-Attribut die Python-Sprachversion: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>c1=fsb795.Certificate(<span class="hljs-string"><span class="hljs-string">'     '</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c1.pyver == <span class="hljs-string"><span class="hljs-string">''</span></span>): ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (<span class="hljs-string"><span class="hljs-string">'   '</span></span>) ...     &gt;&gt;&gt; c2 = fsb795.Certificate(<span class="hljs-string"><span class="hljs-string">'/home/a513/cert_nss.der'</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c2.pyver != <span class="hljs-string"><span class="hljs-string">""</span></span>): ... print(c2.pyver) ... <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;&gt;&gt; print(c2.formatCert) DER &gt;&gt;&gt;</code> </pre> <br>  Das formatCert-Attribut enth√§lt beim erfolgreichen Erstellen einer Instanz der Certificate-Klasse den Datei- / Zeichenfolgenformattyp des Zertifikats.  Es kann PEM oder DER sein.  Warum dieses Attribut ben√∂tigt wird, wird unten klar. <br><br>  Das Paket fsb795 wurde mit dem Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">pyasn1</a> erstellt.  Zwei Attribute blieben also ungepr√ºft.  Das Attribut cert speichert das tbs-Zertifikat, das f√ºr die Verwendung mit dem Paket pyasn1 bereit ist.  Ein anderes Attribut cert_full speichert das gesamte decodierte Zertifikat in Bezug auf rfc2459.  Wir zeigen, wie Sie den Public-Key-Algorithmus mit dem Attribut cert und dem verbundenen Paket pyasn1 erhalten: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>pubkey = c2.cert[<span class="hljs-string"><span class="hljs-string">'subjectPublicKeyInfo'</span></span>] &gt;&gt;&gt; ff = pubkey[<span class="hljs-string"><span class="hljs-string">'algorithm'</span></span>] &gt;&gt;&gt; ff1 = ff[<span class="hljs-string"><span class="hljs-string">'algorithm'</span></span>] &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (ff1) <span class="hljs-number"><span class="hljs-number">1.2</span></span><span class="hljs-number"><span class="hljs-number">.643</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.19</span></span> &gt;&gt;&gt;</code> </pre> <br>  Am Ende wird es m√∂glich sein, die F√§higkeiten des fsb795-Pakets zu bewerten, um Informationen √ºber den √∂ffentlichen Schl√ºssel eines qualifizierten Zertifikats zu erhalten. <br><br>  Wenn eine Instanz der Zertifikatklasse erfolgreich erstellt wurde, stehen uns Methoden zur Verf√ºgung, mit denen die erforderlichen Daten einfach aus dem Zertifikat abgerufen werden k√∂nnen.  Alle Informationen zum √∂ffentlichen Schl√ºssel erhalten Sie wie folgt: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>c3 = fsb795.Certificate(<span class="hljs-string"><span class="hljs-string">'cert.der'</span></span>) &gt;&gt;&gt; key_info=c3.publicKey() &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> opt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> key_info.keys(): ... val = str(key_info[opt]) ... <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (opt + <span class="hljs-string"><span class="hljs-string">'='</span></span> + val) ... curve=<span class="hljs-number"><span class="hljs-number">1.2</span></span><span class="hljs-number"><span class="hljs-number">.643</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.36</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span> hash=<span class="hljs-number"><span class="hljs-number">1.2</span></span><span class="hljs-number"><span class="hljs-number">.643</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.30</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> valuepk=<span class="hljs-number"><span class="hljs-number">5</span></span>b785f86f0dd5316ba37c8440e398e83f2ec0c34478f90da9c0c8046d341ff66f9044cd00a0e25530 acefd51e6be852dbecacbaabc55e807be8e1f861658bd58 algo=<span class="hljs-number"><span class="hljs-number">1.2</span></span><span class="hljs-number"><span class="hljs-number">.643</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span><span class="hljs-number"><span class="hljs-number">.19</span></span> &gt;&gt;&gt;</code> </pre><br>  Derzeit enth√§lt die Zertifikatklasse die folgenden Methoden: <br><br><ul><li>  subjectSignTool () - gibt eine Zeichenfolge mit dem Namen des Inhabers des Zertifikats f√ºr den Schutz kryptografischer Informationen zur√ºck. </li><li>  issuerSignTool () - gibt eine Liste von vier Elementen mit kryptografischen Informationstools des Zertifikatsausstellers zur√ºck; </li><li>  classUser () - gibt eine Zeichenfolge mit den Oids der Sicherheitsklassen des kryptografischen Informationsschutzzertifikats des Zertifikatsinhabers zur√ºck, getrennt durch die Zeichen ";;"; </li><li>  issuerCert () - gibt ein W√∂rterbuch mit Feldern und Werten des unterscheidenden Namens DN des Ausstellers des Zertifikats und einer Nummer zur√ºck, die das Zertifikat identifiziert (2 - juristische Person); </li><li>  subjectCert () - gibt ein W√∂rterbuch mit den Feldern und Werten des definierten Namens DN des Zertifikatsinhabers und einer Nummer zur√ºck, die das Zertifikat identifiziert (2 - juristische Person); </li><li>  publicKey () - gibt ein W√∂rterbuch zur√ºck, das den Schl√ºsselwert ('valuepk') und die Schl√ºsselparameter ('Kurve' und 'Hash') enth√§lt. </li><li>  signatureCert - gibt zwei Werte zur√ºck: den Signaturalgorithmus und den Signaturwert; </li><li>  validityCert - gibt ein W√∂rterbuch mit zwei Schl√ºsseln 'not_after' und 'not_before' zur√ºck; </li><li>  keyUsage () - gibt eine Liste der Schl√ºsselbereiche zur√ºck; </li><li>  serialNumber () - gibt die Seriennummer des Zertifikats in Dezimalform zur√ºck; </li><li>  PrettyPrint () - Gibt eine Zeichenfolge mit einem 'Ausdruck' des Zertifikats in Form von pyasn1 (self.cert_full.prettyPrint ()) zur√ºck. </li></ul><br>  Der Spoiler enth√§lt ein Testbeispiel, das die Arbeit dieser Methoden deutlich zeigt. <br><br><div class="spoiler">  <b class="spoiler_title">Testen Sie test795.py, um das Paket fsb795 zu testen</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fsb795 certpem = <span class="hljs-string"><span class="hljs-string">""" -----BEGIN CERTIFICATE----- MIIG3DCCBougAwIBAgIKE8/KkAAAAAAC4zAIBgYqhQMCAgMwggFKMR4wHAYJKoZI hvcNAQkBFg9kaXRAbWluc3Z5YXoucnUxCzAJBgNVBAYTAlJVMRwwGgYDVQQIDBM3 NyDQsy4g0JzQvtGB0LrQstCwMRUwEwYDVQQHDAzQnNC+0YHQutCy0LAxPzA9BgNV BAkMNjEyNTM3NSDQsy4g0JzQvtGB0LrQstCwLCDRg9C7LiDQotCy0LXRgNGB0LrQ sNGPLCDQtC4gNzEsMCoGA1UECgwj0JzQuNC90LrQvtC80YHQstGP0LfRjCDQoNC+ 0YHRgdC40LgxGDAWBgUqhQNkARINMTA0NzcwMjAyNjcwMTEaMBgGCCqFAwOBAwEB EgwwMDc3MTA0NzQzNzUxQTA/BgNVBAMMONCT0L7Qu9C+0LLQvdC+0Lkg0YPQtNC+ 0YHRgtC+0LLQtdGA0Y/RjtGJ0LjQuSDRhtC10L3RgtGAMB4XDTE4MDcwOTE1MjYy NFoXDTI3MDcwOTE1MjYyNFowggFVMR4wHAYJKoZIhvcNAQkBFg9jb250YWN0QGVr ZXkucnUxITAfBgNVBAMMGNCe0J7QniDCq9CV0LrQtdC5INCj0KbCuzEwMC4GA1UE Cwwn0KPQtNC+0YHRgtC+0LLQtdGA0Y/RjtGJ0LjQuSDRhtC10L3RgtGAMSEwHwYD VQQKDBjQntCe0J4gwqvQldC60LXQuSDQo9CmwrsxCzAJBgNVBAYTAlJVMRgwFgYD VQQIDA83NyDQnNC+0YHQutCy0LAxRDBCBgNVBAkMO9Cj0JvQmNCm0JAg0JjQm9Cs 0JjQndCa0JAsINCULjQsINCQ0J3QotCgIDMg0K3Qojsg0J/QntCcLjk0MRgwFgYD VQQHDA/Qsy7QnNC+0YHQutCy0LAxGDAWBgUqhQNkARINMTE0Nzc0NjcxNDYzMTEa MBgGCCqFAwOBAwEBEgwwMDc3MTA5NjQzNDgwYzAcBgYqhQMCAhMwEgYHKoUDAgIk AAYHKoUDAgIeAQNDAARAW3hfhvDdUxa6N8hEDjmOg/LsDDRHj5DanAyARtNB/2b5 BEzQCg4lUwrO/VHmvoUtvsrLqrxV6Ae+jh+GFli9WKOCA0AwggM8MBIGA1UdEwEB /wQIMAYBAf8CAQAwHQYDVR0OBBYEFMQYnG5GfYRnj2ehEQ5tv8Fso/qBMAsGA1Ud DwQEAwIBRjAdBgNVHSAEFjAUMAgGBiqFA2RxATAIBgYqhQNkcQIwKAYFKoUDZG8E Hwwd0KHQmtCX0JggwqvQm9CY0KDQodCh0JstQ1NQwrswggGLBgNVHSMEggGCMIIB foAUi5g7iRhR6O+cAni46sjUILJVyV2hggFSpIIBTjCCAUoxHjAcBgkqhkiG9w0B CQEWD2RpdEBtaW5zdnlhei5ydTELMAkGA1UEBhMCUlUxHDAaBgNVBAgMEzc3INCz LiDQnNC+0YHQutCy0LAxFTATBgNVBAcMDNCc0L7RgdC60LLQsDE/MD0GA1UECQw2 MTI1Mzc1INCzLiDQnNC+0YHQutCy0LAsINGD0LsuINCi0LLQtdGA0YHQutCw0Y8s INC0LiA3MSwwKgYDVQQKDCPQnNC40L3QutC+0LzRgdCy0Y/Qt9GMINCg0L7RgdGB 0LjQuDEYMBYGBSqFA2QBEg0xMDQ3NzAyMDI2NzAxMRowGAYIKoUDA4EDAQESDDAw NzcxMDQ3NDM3NTFBMD8GA1UEAww40JPQvtC70L7QstC90L7QuSDRg9C00L7RgdGC 0L7QstC10YDRj9GO0YnQuNC5INGG0LXQvdGC0YCCEDRoHkDLQe8zqaC3yHaSmikw WQYDVR0fBFIwUDAmoCSgIoYgaHR0cDovL3Jvc3RlbGVjb20ucnUvY2RwL2d1Yy5j cmwwJqAkoCKGIGh0dHA6Ly9yZWVzdHItcGtpLnJ1L2NkcC9ndWMuY3JsMIHGBgUq hQNkcASBvDCBuQwj0J/QkNCa0JwgwqvQmtGA0LjQv9GC0L7Qn9GA0L4gSFNNwrsM INCf0JDQmiDCq9CT0L7Qu9C+0LLQvdC+0Lkg0KPQpsK7DDbQl9Cw0LrQu9GO0YfQ tdC90LjQtSDihJYgMTQ5LzMvMi8yLTk5OSDQvtGCIDA1LjA3LjIwMTIMONCX0LDQ utC70Y7Rh9C10L3QuNC1IOKEliAxNDkvNy8xLzQvMi02MDMg0L7RgiAwNi4wNy4y MDEyMAgGBiqFAwICAwNBALvjFGhdFE9llvlvKeQmZmkI5J+yO2jFWTh8nXPjIpiL OutUew2hIZv15pJ1QM/VgRO3BTBGDOoIrq8LvgC+3kA= -----END CERTIFICATE----- """</span></span> <span class="hljs-comment"><span class="hljs-comment">#c1 = fsb795.Certificate('OOO_VOLGA.der') #c1 = fsb795.Certificate('cert.der') c1 = fsb795.Certificate(certpem) if (c1.pyver == ''): print('Context for certificate not create') exit(-1) print('=================formatCert================================') print(c1.formatCert) res = c1.subjectSignTool() print('=================subjectSignTool================================') print (res) print('=================issuerSignTool================================') res1 = c1.issuerSignTool() print (res1[0]) print (res1[1]) print (res1[2]) print (res1[3]) print('=================prettyPrint================================') res2 = c1.prettyPrint() #print(res2) print('=================classUser================================') res3 = c1.classUser() print (res3) print('=================issuerCert================================') iss, vlad_is = c1.issuerCert() print ('vlad_is=' + str(vlad_is)) for key in iss.keys(): print (key + '=' + iss[key]) print('=================subjectCert================================') sub, vlad_sub = c1.subjectCert() print ('vlad_sub=' + str(vlad_sub)) for key in sub.keys(): print (key + '=' + sub[key]) print('================publicKey=================================') key_info = c1.publicKey() print(key_info['curve']) print(key_info['hash']) print(key_info['valuepk']) print('================serialNumber=================================') print(c1.serialNumber()) print('================validityCert=================================') valid = c1.validityCert() print(valid['not_after']) print(valid['not_before']) print('================signatureCert=================================') algosign, value = c1.signatureCert() print(algosign) print(value) print('================KeyUsage=================================') ku = c1.KeyUsage() for key in ku: print (key) # print(ku) print('================END=================================')</span></span></code> </pre><br></div></div><br>  Um ein Testbeispiel auszuf√ºhren, f√ºhren Sie einfach den folgenden Befehl aus: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$python</span></span> test795.py</code> </pre> <br>  Mit dem fsb795-Paket war es selbstverst√§ndlich, in Python ein eigenst√§ndiges, plattformunabh√§ngiges grafisches Dienstprogramm zum Anzeigen qualifizierter Zertifikate zu schreiben.  Das Tkinter-Paket wurde als grafische Unterst√ºtzung verwendet: <br><br><img src="https://habrastorage.org/webt/wb/sw/m8/wbswm8thi6y0edcmxs2osp8uw2q.png"><br><br>  Das Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viewCertFL63</a> verf√ºgt √ºber drei Registerkarten.  Auf der Registerkarte √úber Zertifikat wird unter anderem die aktuelle Uhrzeit angezeigt.  Wir werden unten darauf zur√ºckkommen.  Um ein Zertifikat auszuw√§hlen, klicken Sie einfach auf die Schaltfl√§che "Ausw√§hlen": <br><br><img src="https://habrastorage.org/webt/w_/qe/s6/w_qes6wmp_rwam1prr8-lvmam7s.png"><br><br>  Achten Sie auf die Schaltfl√§che (diejenigen, die unter Windows arbeiten, sehen diese Schaltfl√§che nicht), mit der Sie die sogenannten unsichtbaren Dateien / Verzeichnisse (ausgeblendet) ausblenden k√∂nnen.  Damit diese Schaltfl√§che angezeigt wird, m√ºssen die folgenden Befehle ausgef√ºhrt werden: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> sys.platform != <span class="hljs-string"><span class="hljs-string">"win32"</span></span>: root.tk.call(<span class="hljs-string"><span class="hljs-string">'set'</span></span>, <span class="hljs-string"><span class="hljs-string">'::tk::dialog::file::showHiddenBtn'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>) root.tk.call(<span class="hljs-string"><span class="hljs-string">'set'</span></span>, <span class="hljs-string"><span class="hljs-string">'::tk::dialog::file::showHiddenVar'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>)</code> </pre><br>  Eine sehr n√ºtzliche Schaltfl√§che.  Nach Auswahl eines Zertifikats hat die Registerkarte "√úber Zertifikat" die folgende Form: <br><br><img src="https://habrastorage.org/webt/sn/x4/cc/snx4ccjle-z5atjx-4ffg-gvb_u.png"><br><br><img src="https://habrastorage.org/webt/sj/6x/9h/sj6x9hwsr5dr1xqahzigdvitst8.gif" align="left">  Was hier bemerkenswert ist, ist, dass, wenn das Zertifikat beim Anzeigen des Zertifikats abl√§uft, das Siegel auf dem Symbol in der oberen linken Ecke in zwei H√§lften zerf√§llt.  Jeder kann davon √ºberzeugt sein, indem er die Uhr am Computer ein Jahr im Voraus neu anordnet. <br>  Auf der Registerkarte "Details" k√∂nnen Sie die Merkmale des ausgew√§hlten Attributs eines qualifizierten Zertifikats detailliert anzeigen: <br><br><img src="https://habrastorage.org/webt/jc/va/4j/jcva4j74wlkzzbqb34rdjb-etuc.png"><br><br>  Und schlie√ülich ist die dritte Registerkarte "Text".  Diese Registerkarte zeigt den Inhalt des gesamten Zertifikats an: <br><br><img src="https://habrastorage.org/webt/6z/z5/xz/6zz5xzinnpyy_qm7s5uheeqbsyu.png"><br><br>  Zum Anzeigen des Zertifikats k√∂nnen Sie nicht nur Python (die Schaltfl√§che "Python"), sondern auch die Dienstprogramme openssl und pp der Network Serurity Services (NSS) verwenden.  Wenn jemand diese Dienstprogramme nicht hat, kann das erste durch Sammeln von openssl mit Unterst√ºtzung f√ºr die russische Kryptographie erhalten werden.  Bei Verwendung des Dienstprogramms pp sieht die Zertifikatausgabe folgenderma√üen aus: <br><br><img src="https://habrastorage.org/webt/pa/bf/cn/pabfcn24oeu0katqhkdgbp_ryzg.png"><br><br>  Oben haben wir das formatCert-Attribut der Certificate-Klasse des fsb795-Pakets erw√§hnt.  Daher ben√∂tigen wir den Wert dieses Attributs, um das Format der Datei mit dem Zertifikat anzugeben, wenn dieses oder jenes Dienstprogramm ausgef√ºhrt wird.  Das Aufrufen des Dienstprogramms pp mit dem PEM-Dateiformat sieht beispielsweise folgenderma√üen aus: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$pp</span></span> ‚Äìtc ‚Äìu ‚Äìa ‚Äìi &lt; &gt;</code> </pre> <br>  Die Option -a gibt das Format der PEM-Datei an.  F√ºr das DER-Format ist es nicht angegeben. <br>  Der Parameter "‚Äìinform" f√ºr openssl wird auf die gleiche Weise eingestellt. <br>  Mit der Schaltfl√§che Dienstprogramm wird der Pfad zu den Dienstprogrammen openssl oder pp angegeben. <br>  ViewCertFL63-Dienstprogrammverteilungen finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br>  Distributionen wurden mit dem Pyinstaller-Paket erstellt: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$python</span></span> pyinstaller.py --noconsole -F viewCertFL63.py</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421107/">https://habr.com/ru/post/de421107/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421097/index.html">Zusammensetzung der UIViewController und Navigation zwischen ihnen (und nicht nur)</a></li>
<li><a href="../de421099/index.html">Ist es schwer sich zu konzentrieren? Vielleicht ist es nicht deine Schuld</a></li>
<li><a href="../de421101/index.html">"Testerkalender" f√ºr August. Lies ein Buch</a></li>
<li><a href="../de421103/index.html">Schauen Sie sich zuerst den Mavic 2 an: Fliegen Sie l√§nger, leiser, schneller</a></li>
<li><a href="../de421105/index.html">Situation: Spotify macht direkte Gesch√§fte mit Musikern - Labels sind ungl√ºcklich</a></li>
<li><a href="../de421109/index.html">(Aktualisiert) Intel verbietet die Ver√∂ffentlichung von Benchmarks f√ºr Mikrocode-Updates</a></li>
<li><a href="../de421111/index.html">Entwurfssystem in Figma. Ein Blick auf die Schnittstelle durch Komponenten</a></li>
<li><a href="../de421113/index.html">Einf√ºhrung in DJI Mavic 2 Pro / Zoom</a></li>
<li><a href="../de421115/index.html">Kontext in einer Android-Anwendung</a></li>
<li><a href="../de421119/index.html">SmartTV-Entwicklung f√ºr Unterwasserschwader</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>