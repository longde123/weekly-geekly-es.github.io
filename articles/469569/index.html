<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•ú üí† üìñ Arend: lenguaje de tipo dependiente basado en HoTT (parte 1) üêã üîÉ ‚óÄÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En esta publicaci√≥n, hablaremos sobre el lenguaje JetBrains recientemente lanzado con tipos dependientes de Arend (el idioma lleva el nombre de Gating...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arend: lenguaje de tipo dependiente basado en HoTT (parte 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/469569/"> En esta publicaci√≥n, hablaremos sobre el lenguaje JetBrains recientemente lanzado con tipos dependientes de Arend (el idioma lleva el nombre de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gating Rent</a> ).  Este lenguaje ha sido desarrollado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JetBrains Research</a> en los √∫ltimos a√±os.  Aunque los repositorios hace un a√±o se pusieron a disposici√≥n del p√∫blico en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/JetBrains</a> , el lanzamiento completo de Arend solo ocurri√≥ en julio de este a√±o. <br><br>  Intentaremos decir c√≥mo Arend difiere de los sistemas existentes de matem√°tica formalizada basados ‚Äã‚Äãen tipos dependientes, y qu√© funcionalidad est√° ahora disponible para sus usuarios.  Suponemos que el lector de este art√≠culo generalmente est√° familiarizado con los tipos dependientes y ha escuchado al menos uno de los idiomas en funci√≥n de los tipos dependientes: Agda, Idris, Coq o Lean.  Sin embargo, no esperamos que el lector tenga tipos dependientes en un nivel avanzado. <br><br>  Por simplicidad y concreci√≥n, nuestra historia sobre Arend y los tipos de homotop√≠a ir√° acompa√±ada de la implementaci√≥n en Arend del algoritmo de clasificaci√≥n de listas m√°s simple; incluso con este ejemplo, puede sentir la diferencia entre Arend y Agda y Coq.  Ya hay una serie de art√≠culos sobre Habr√© dedicados a los tipos dependientes.  Digamos sobre la implementaci√≥n de listas de clasificaci√≥n utilizando el m√©todo QuickSort en Agda, existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un art√≠culo de este tipo</a> .  Implementaremos un algoritmo m√°s simple para ordenar inserciones.  En este caso, nos centraremos en las construcciones del lenguaje Arend, y no en el algoritmo de clasificaci√≥n en s√≠. <br><a name="habracut"></a><br>  Entonces, la principal diferencia entre Arend y otros lenguajes con tipos dependientes es la teor√≠a l√≥gica en la que se basa.  Arend utiliza como tal la teor√≠a del tipo de homotop√≠a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V. Voevodsky</a> recientemente descubierta ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HoTT</a> ).  M√°s espec√≠ficamente, Arend se basa en una variaci√≥n de HoTT llamada "teor√≠a de tipos con espaciado".  Recuerde que Coq se basa en el llamado c√°lculo de construcciones inductivas (C√°lculo de construcciones inductivas), mientras que Agda e Idris se basan en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">teor√≠a intensiva de tipos de Martin-L√∂f</a> .  El hecho de que Arend se base en HoTT afecta significativamente sus construcciones sint√°cticas y la operaci√≥n del algoritmo de verificaci√≥n de tipos (Typcheker).  Vamos a discutir estas caracter√≠sticas en este art√≠culo. <br><br>  Tratemos de describir brevemente el estado de la infraestructura del lenguaje.  Para Arend hay un complemento para IntelliJ IDEA, que se puede instalar directamente desde el repositorio de complementos IDEA.  En principio, instalar el complemento es suficiente para trabajar completamente con Arend, a√∫n no necesita descargar e instalar nada.  Adem√°s de la verificaci√≥n de tipos, el complemento Arend proporciona una funcionalidad familiar para los usuarios de IDEA: hay resaltado y alineaci√≥n del c√≥digo, varias refactorizaciones y consejos.  Tambi√©n existe la opci√≥n de usar la versi√≥n de consola de Arend.  Puede encontrar una descripci√≥n m√°s detallada del proceso de instalaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Los ejemplos de c√≥digo en este art√≠culo se basan en la biblioteca est√°ndar de Arend, por lo que recomendamos descargar su c√≥digo fuente del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> .  Despu√©s de la descarga, el directorio de origen debe importarse como un proyecto IDEA utilizando el comando Importar proyecto.  En Arend, algunas secciones de la teor√≠a del tipo de homotop√≠a y la teor√≠a del anillo ya se han formalizado.  Por ejemplo, en la biblioteca est√°ndar hay una implementaci√≥n del anillo de n√∫meros racionales Q junto con pruebas de todas las propiedades te√≥ricas del anillo requeridas. <br><br>  La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> detallada del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lenguaje</a> , en la que muchos de los puntos cubiertos en este art√≠culo se explican con m√°s detalle, tambi√©n es de dominio p√∫blico.  Puede hacer preguntas directamente a los desarrolladores de Arend en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canal de telegramas</a> . <br><br><h2>  1. Descripci√≥n general de HoTT / Arend </h2><br>  La teor√≠a de tipo de homotop√≠a (o, en resumen, HoTT) es un tipo de teor√≠a de tipo intensional que difiere de la teor√≠a de tipo cl√°sica de Martin-L√∂f (MLTT, en la que se basa Agda) y el c√°lculo de construcci√≥n inductivo (CIC, en el que se basa Coq), en eso, junto con declaraciones y conjuntos contienen los llamados tipos de un nivel de homotop√≠a m√°s alto. <br><br>  En este art√≠culo, no nos fijamos el objetivo de explicar los fundamentos de HoTT en detalle: para una exposici√≥n detallada de esta teor√≠a, ser√≠a necesario volver a contar todo el libro (ver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta publicaci√≥n</a> ).  Solo notamos que una teor√≠a basada en la axiom√°tica de HoTT es, en cierto sentido, mucho m√°s elegante e interesante que la teor√≠a cl√°sica del tipo Martin-L√∂f.  Por lo tanto, una serie de axiomas que anteriormente deb√≠an postularse adicionalmente (por ejemplo, extensionalidad funcional) se prueban en HoTT como teoremas.  Adem√°s, en HoTT, uno puede definir internamente esferas de homotop√≠a multidimensionales e incluso contar algunos de sus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grupos de homotop√≠a</a> . <br><br>  Sin embargo, estos aspectos de HoTT son principalmente interesantes para los matem√°ticos, y el prop√≥sito de este art√≠culo es explicar c√≥mo el Arend basado en HoTT se compara favorablemente con Agda / MLTT y Coq / CIC con el ejemplo de representar a las entidades programadoras tan simples y familiares como las listas ordenadas.  Al leer este art√≠culo, es suficiente tratar a HoTT como una especie de teor√≠a de tipo intensional con una axiom√°tica m√°s desarrollada, lo que brinda comodidad al trabajar con universos e igualdades. <br><br><h2>  1.1 Tipos dependientes, correspondencia de Curry - Howard, universos </h2><br>  Recuerde que los lenguajes con tipos dependientes difieren de los lenguajes de programaci√≥n funcional ordinarios en que, adem√°s de los tipos de datos habituales, como listas o n√∫meros naturales, hay tipos que dependen del valor del par√°metro.  Los ejemplos m√°s simples de tales tipos son vectores de una longitud dada n o √°rboles equilibrados de una profundidad dada d.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠</a> se mencionan algunos ejemplos adicionales de tales tipos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">.</a> <br><br>  Recuerde que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">correspondencia de Curry - Howard le</a> permite a uno interpretar declaraciones de l√≥gica como tipos dependientes.  La idea principal de esta correspondencia es que un tipo vac√≠o corresponde a una declaraci√≥n falsa, y los tipos poblados corresponden a una declaraci√≥n verdadera.  Los elementos tipo pueden considerarse como pruebas de la declaraci√≥n l√≥gica correspondiente.  Por ejemplo, cualquier elemento como los enteros puede considerarse como una prueba del hecho de que existen enteros (es decir, el tipo de enteros est√° poblado). <br><br>  Las diferentes construcciones naturales sobre tipos corresponden a diferentes conectivos l√≥gicos: <br><br><ul><li>  <i>El producto de los tipos A √ó B a</i> veces se llama el tipo del par Par A B. Dado que este tipo se llena si y solo si se llenan ambos tipos A y B, esta construcci√≥n corresponde a la l√≥gica ‚Äúy‚Äù. </li><li>  <i>La suma de los tipos A + B.</i> En Haskell, este tipo se llama A B. Ya que este tipo se llena si y solo si se llena uno de los tipos A o B, esta construcci√≥n corresponde a un "o" l√≥gico. <br></li><li>  <i>Tipo funcional A ‚Üí B.</i>  Cualquier funci√≥n de este tipo convierte elementos de A en elementos de B. Por lo tanto, dicha funci√≥n existe exactamente cuando la existencia de un elemento de tipo A implica la existencia de un elemento de tipo B. Por lo tanto, esta construcci√≥n corresponde a implicaci√≥n. <br></li></ul><br>  Supongamos ahora que se nos da un cierto tipo A y una familia de tipos B parametrizados por un elemento a de tipo A. Veamos ejemplos de construcciones m√°s complejas sobre tipos dependientes. <br><br><ul><li>  <i>Tipo de funci√≥n dependiente</i> <b>Œ†</b> (a: A) (B a).  Este tipo coincide con el tipo funcional habitual A ‚Üí B si B es independiente de A. Una funci√≥n de tipo <b>Œ†</b> (a: A) (B a) convierte cualquier elemento a de tipo A en un elemento de tipo B a.  Por lo tanto, dicha funci√≥n existe si y solo si, <i>para cualquier a</i> : A, existe un elemento B a.  Por lo tanto, esta construcci√≥n corresponde al cuantificador universal ‚àÄ.  Para el tipo funcional dependiente, Arend usa la sintaxis <code><b>\Pi</b> (x : A) -&gt; B a</code> , y el t√©rmino que habita este tipo puede construirse usando la expresi√≥n lambda <code><b>\lam</b> (a : A) =&gt; f a.</code> </li><li>  <i>El tipo de pares dependientes es <b>Œ£</b> (a: A) (B a).</i>  Este tipo coincide con los tipos habituales de pares A √ó B si B es independiente de A. El tipo <b>Œ£</b> (a: A) (B a) se rellena exactamente cuando <i>existe</i> un elemento a: A y un elemento de tipo B a.  Por lo tanto, este tipo corresponde al cuantificador de existencia <code>‚àÉ</code> .  El tipo de pares dependientes en Arend se denota por <code>\Sigma (a : A) (B a)</code> , y los t√©rminos que lo habitan se construyen utilizando el constructor del par <code>(a, b)</code> <i>dependiente)</i> <code>(a, b)</code> . <br></li><li>  <i>El tipo de igualdad es</i> a = a ', donde a y a' son dos elementos de alg√∫n tipo A. Dicho tipo se rellena si a y a 'son iguales y, de lo contrario, est√° vac√≠o.  Obviamente, este tipo es un an√°logo del predicado de igualdad en la l√≥gica. </li></ul><br>  En este punto, remitimos al lector a fuentes en las que se discute la correspondencia de Curry - Howard con m√°s detalle (v√©ase, por ejemplo, un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">curso de conferencias</a> o art√≠culos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ). <br><br>  Todas las expresiones consideradas en la teor√≠a de tipos deben tener alg√∫n tipo.  Dado que las expresiones que denotan tipos tambi√©n se consideran en el marco de esta teor√≠a, tambi√©n se les debe asignar un cierto tipo.  La pregunta es, ¬øqu√© tipo de tipo deber√≠a ser? <br><br>  La primera decisi√≥n ingenua que viene a la mente es asignar a todos los tipos un tipo formal <code>\Type</code> , llamado <i>universo</i> (se llama as√≠ porque contiene todos los tipos en general).  Si usamos este universo, las construcciones de suma y los productos de tipo mencionados anteriormente recibir√°n la firma <code>\Type ‚Üí \Type ‚Üí \Type</code> , y las construcciones m√°s complejas del producto dependiente y la suma dependiente recibir√°n la firma <code><b>Œ†</b> (A : \Type) ‚Üí ((A ‚Üí \Type) ‚Üí \Type)</code> . <br><br>  En este punto, surge la pregunta, ¬øqu√© tipo deber√≠a tener el universo <code>\Type</code> ?  Un intento ingenuo de decir que el tipo de universo <code>\Type</code> , por definici√≥n, es <code>\Type</code> s√≠ mismo conduce a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la paradoja de Girard</a> , por lo que, en lugar de un solo universo <code>\Type</code> considere una <i>jerarqu√≠a</i> infinita <i>de universos</i> , es decir.  la cadena anidada de universos <code>\Type 1 &lt; \Type 2 &lt; ‚Ä¶</code> , cuyos niveles est√°n numerados por n√∫meros naturales, y el tipo de universo <code>\Type i</code> , por definici√≥n, es el universo <code>\Type (i+1)</code> .  Para las construcciones de tipo mencionadas anteriormente, tambi√©n se deben introducir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">firmas</a> m√°s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">complejas</a> . <br><br>  Por lo tanto, se necesitan universos en la teor√≠a de tipos para que cualquier expresi√≥n tenga un cierto tipo.  En algunas variedades de teor√≠a de tipos, los universos se usan para otro prop√≥sito: distinguir entre variedades de tipos.  Ya hemos visto que los conjuntos y las declaraciones son casos especiales de tipos.  Esto muestra que podr√≠a tener sentido introducir en la teor√≠a un universo Prop separado para declaraciones y una jerarqu√≠a separada de universos Set <sub>i</sub> para conjuntos.  Este es exactamente el enfoque utilizado en C√°lculo de construcciones inductivas, la teor√≠a en la que se basa el sistema Coq. <br><br><h2>  1.2 Ejemplos de tipos inductivos m√°s simples y funciones recursivas </h2><br>  Considere las definiciones en Arend de los tipos de datos inductivos m√°s simples: tipo booleano, tipo de n√∫mero natural y listas polim√≥rficas.  Arend usa la palabra clave <code>\data</code> para introducir nuevos tipos inductivos. <br><br> <code>\data Empty --  ,    <br> <br> \data Bool <br> | true <br> | false <br> <br> \data Nat <br> | zero <br> | suc Nat <br> <br> \data List (A : \Set) <br> | nil <br> | \infixr 5 :-: A (List A)</code> <br> <br>  Como puede ver en los ejemplos anteriores, despu√©s de la palabra clave <code>\data</code> , debe especificar el nombre del tipo inductivo y una lista de sus constructores.  Al mismo tiempo, el tipo de datos y los constructores pueden tener algunos par√°metros.  Digamos que en el ejemplo anterior, el tipo de <code>List</code> tiene un par√°metro <code>A</code>  El constructor de la lista <code>nil</code> no tiene par√°metros, y el constructor: -: tiene dos par√°metros (uno de los cuales es del tipo <code>A</code> y el otro es del tipo <code>List A</code> ).  El universo <code>\Set</code> consta de tipos que son conjuntos (la definici√≥n de conjuntos se dar√° en la siguiente secci√≥n).  La <code>\infixr</code> permite utilizar la notaci√≥n infija para el constructor: -: y, adem√°s, le dice al analizador Arend que el operador: -: es una operaci√≥n de asociaci√≥n correcta con prioridad 5. <br><br>  En Arend, todas las palabras clave comienzan con un car√°cter de barra diagonal inversa ("\"), una implementaci√≥n inspirada en LaTeX.  Solo tenga en cuenta que las reglas l√©xicas en Arend son muy liberales: <code>Circle_HSpace, contrFibers=&gt;Equiv, suc/=0, zro_*-left</code> e even <code>n:Nat</code> - todos estos literales son ejemplos de identificadores v√°lidos en Arend.  El √∫ltimo ejemplo muestra lo importante que es para el usuario de Arend <i>recordar poner espacios entre los identificadores y los dos puntos</i> .  Tenga en cuenta que en los identificadores Arend no est√° permitido usar caracteres Unicode (en particular, no puede usar cir√≠lico). <br><br>  Arend usa la palabra clave <code>\func</code> para definir funciones.  La sintaxis de esta construcci√≥n es la siguiente: despu√©s de la palabra clave <code>\func</code> , debe especificar el nombre de la funci√≥n, sus par√°metros y el tipo del valor de retorno.  El elemento final para definir una funci√≥n es su cuerpo. <br><br>  Si es posible especificar expl√≠citamente la expresi√≥n en la que se calcular√° la funci√≥n dada, entonces token =&gt; se usa para indicar el cuerpo de la funci√≥n.  Considere, por ejemplo, la definici√≥n de una funci√≥n de negaci√≥n de tipo. <br><br><pre> <code class="plaintext hljs">\func Not (A : \Type) : \Type =&gt; A -&gt; Empty</code> </pre> <br>  El tipo de retorno de una funci√≥n no siempre tiene que especificarse expl√≠citamente.  En el ejemplo anterior, Arend podr√≠a inferir independientemente el tipo <code>Not</code> , y podr√≠amos omitir la expresi√≥n ": <code>\Type</code> " despu√©s de los corchetes. <br><br>  Como en la mayor√≠a de los sistemas matem√°ticos formalizados, el usuario no tiene que especificar un nivel predictivo expl√≠cito para el universo <code>\Type</code> , y las definiciones en las que se usan universos sin especificar expl√≠citamente un nivel predictivo se consideran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">polim√≥rficas</a> . <br><br>  Ahora intentemos definir una funci√≥n que calcule la longitud de la lista.  Dicha funci√≥n es f√°cil de identificar mediante la coincidencia de patrones.  Arend usa la palabra clave <code>\elim</code> para esto.  Despu√©s de eso, debe especificar las variables por las cuales se realiza la comparaci√≥n (si hay m√°s de una variable, entonces deben escribirse con una coma).  Si la comparaci√≥n se realiza para todos los par√°metros expl√≠citos, entonces se puede omitir <code>\elim</code> junto con las variables.  Esto es seguido por un bloque de puntos de comparaci√≥n, separados entre s√≠ por una barra vertical "|".  Cada elemento en este bloque es una expresi√≥n de la forma <code>¬´,    ¬ª =&gt; ¬´¬ª</code> . <br><br><pre> <code class="plaintext hljs">\func length {A : \Set} (l : List A) : Nat | nil =&gt; 0 | :-: x xs =&gt; suc (length xs)</code> </pre> <br>  En el ejemplo anterior, el par√°metro A de la funci√≥n de <code>length</code> est√° rodeado de llaves.  Estos corchetes en Arend se usan para denotar argumentos impl√≠citos, es decir  argumentos que el usuario puede omitir al llamar a una funci√≥n o al usar un tipo.  Tenga en cuenta que en Arend no puede usar la notaci√≥n de infijo para designar constructores cuando coincida con un patr√≥n, por lo que la notaci√≥n de prefijo se usa en el ejemplo de muestra. <br><br>  Al igual que en Coq / Agda, en Arend se debe garantizar que todas las funciones se completen (es decir, la verificaci√≥n de terminaci√≥n est√° presente en Arend).  En la definici√≥n de la funci√≥n de longitud, esta verificaci√≥n es exitosa, ya que una llamada recursiva reduce estrictamente el primer argumento expl√≠cito.  Si tal reducci√≥n no ocurriera, Arend emitir√≠a un mensaje de error. <br><br><pre> <code class="plaintext hljs">\func bad : Nat =&gt; bad [ERROR] Termination check failed for function 'bad' In: bad</code> </pre> <br>  Arend permite dependencias circulares y funciones recursivas para las cuales tambi√©n se realizan verificaciones de finalizaci√≥n.  El algoritmo de esta verificaci√≥n se implementa en base al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo de</a> A. Abel.  En √©l encontrar√° una descripci√≥n m√°s detallada de las condiciones que deben cumplir las funciones recursivas mutuas. <br><br><h2>  1.3 ¬øC√≥mo difieren los conjuntos de las declaraciones? </h2><br>  Anteriormente escribimos que ejemplos de tipos son conjuntos y declaraciones.  Adem√°s, utilizamos las palabras clave <code>\Type</code> y <code>\Set</code> para denotar universos en Arend.  En esta secci√≥n, trataremos de explicar con m√°s detalle c√≥mo las declaraciones difieren de los conjuntos en t√©rminos de variedades de la teor√≠a de tipo intensional (MLTT, CIC, HoTT), y al mismo tiempo explicaremos en qu√© consiste el significado de las palabras clave <code>\Prop</code> , <code>\Set</code> y <code>\Type</code> en Arend. <br><br>  Recuerde que en la teor√≠a cl√°sica de Martin-L√∂f no hay separaci√≥n de tipos en conjuntos y enunciados.  En particular, en teor√≠a solo hay un universo acumulativo (que se denota ya sea por Establecer en Agda, o Escribir en Idris, o Ordenar en Lean).  Este enfoque es el m√°s simple, pero hay situaciones en las que se manifiestan sus deficiencias.  Supongamos que estamos tratando de implementar el tipo de "lista ordenada" como un par dependiente que consiste en una lista y prueba de su orden.  Resulta que, en el marco del MLTT "puro", no ser√° posible demostrar la igualdad de las listas ordenadas que consisten en elementos id√©nticos, que al mismo tiempo difieren en t√©rminos de prueba de pedido.  Tener tal igualdad ser√≠a muy natural y deseable, por lo que la imposibilidad de demostrarlo puede considerarse como un defecto te√≥rico en MLTT. <br><br>  En Agda, este problema se resuelve parcialmente con la ayuda de las llamadas anotaciones de inmaterialidad (consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuente</a> , en la que se analiza el ejemplo de la lista con m√°s detalle).  Sin embargo, estas anotaciones no son una construcci√≥n de la teor√≠a MLTT, ni son construcciones completas en los tipos (es imposible marcar con una anotaci√≥n de tipo que no se utiliza en el argumento de la funci√≥n). <br><br>  En CIC, basado en CIC, hay dos universos diferentes anidados entre s√≠: <code>Prop</code> (el universo de sentencias) y <code>Set</code> (el universo de conjuntos), que est√°n inmersos en la jerarqu√≠a integral de universos <code>Type</code> .  La principal diferencia entre <code>Prop</code> y <code>Set</code> es que hay una serie de restricciones en las variables cuyo tipo pertenece a <code>Prop</code> en Coq.  Por ejemplo, no se pueden usar en los c√°lculos, y la comparaci√≥n con la muestra para ellos solo es posible dentro de la evidencia de otras declaraciones.  Por otro lado, todos los elementos del tipo que pertenece al universo <code>Prop</code> son iguales en el axioma de evidencia intrascendente, vea la declaraci√≥n en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Coq.Logic.ProofIrrelevance</a> .  Usando este axioma, podr√≠amos probar f√°cilmente la igualdad de las listas ordenadas mencionadas anteriormente. <br><br>  Finalmente, considere el enfoque Arend / HoTT para las declaraciones y universos.  La principal diferencia es que HoTT prescinde del axioma de la evidencia intrascendente.  Es decir, no hay un axioma especial en HoTT que postule que todos los elementos de las declaraciones son iguales.  Pero en HoTT, un tipo, <i>por definici√≥n</i> , es una declaraci√≥n si se puede demostrar que todos sus elementos son iguales entre s√≠.  Podemos definir un predicado sobre tipos que sea verdadero si el tipo es una declaraci√≥n: <br><br><pre> <code class="plaintext hljs">\func isProp (A : \Type) =&gt; \Pi (aa' : A) -&gt; a = a'</code> </pre> <br>  Surge la pregunta: ¬øqu√© tipos satisfacen este predicado, es decir, son declaraciones?  Es f√°cil verificar que esto sea cierto para los tipos vac√≠o y singleton.  Para los tipos donde hay al menos dos elementos diferentes, esto ya no ser√° cierto. <br><br>  Por supuesto, queremos que todas las conexiones l√≥gicas necesarias se definan sobre las declaraciones.  En la Secci√≥n 1.1, ya discutimos c√≥mo podr√≠an determinarse utilizando construcciones te√≥ricas de tipo.  Sin embargo, existe el siguiente problema: no todas las operaciones que hemos ingresado conservan la propiedad <code>isProp</code> .  Las construcciones del producto de tipos y el tipo funcional (dependiente) conservan esta propiedad, mientras que las construcciones de la suma de tipos y pares dependientes no.  Por lo tanto, no podemos usar la disyunci√≥n y el cuantificador de la existencia. <br><br>  Este problema se puede resolver con la ayuda de una nueva construcci√≥n, que se agrega a HoTT, el llamado <i>truncamiento proposicional</i> .  Este dise√±o le permite convertir cualquier tipo en una declaraci√≥n.  Se puede considerar como una operaci√≥n formal, igualando todos los t√©rminos que habitan este tipo.  Esta operaci√≥n es algo similar a las anotaciones de inmaterialidad de Agda, sin embargo, a diferencia de ellas, es una operaci√≥n completa en los tipos con firma <code>\Type -&gt; \Prop</code> . <br><br>  El √∫ltimo ejemplo importante de declaraciones es la igualdad de dos elementos de alg√∫n tipo.  Resulta que, en el caso general, el tipo de igualdad <code>a = a'</code> no tiene que ser una declaraci√≥n.  Los tipos para los cuales es uno se llaman conjuntos: <br><br><pre> <code class="plaintext hljs">\func isSet (A : \Type) =&gt; \Pi (aa' : A) -&gt; isProp (a = a')</code> </pre> <br>  Todos los tipos que se encuentran en los lenguajes de programaci√≥n ordinarios satisfacen este predicado, es decir, la igualdad en ellos es una declaraci√≥n.  Por ejemplo, esto es cierto para n√∫meros naturales, enteros, productos de conjuntos, sumas de conjuntos, funciones sobre conjuntos, listas de conjuntos y otros tipos de datos inductivos construidos a partir de conjuntos.  Esto significa que si solo estamos interesados ‚Äã‚Äãen construcciones tan familiares, entonces no podemos pensar en tipos arbitrarios que no satisfagan este predicado.  Todos los tipos encontrados en Coq son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjuntos</a> . <br><br>  Los tipos que no son conjuntos se vuelven √∫tiles si desea abordar la teor√≠a de tipos de homotop√≠a.  Por ahora, simplemente remitimos al lector al <a href="">m√≥dulo de</a> biblioteca est√°ndar que contiene la definici√≥n de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esfera n-dimensional</a> , un ejemplo de un tipo que no es un conjunto. <br><br>  Arend tiene universos especiales <code>\Prop</code> y <code>\Set</code> , que consisten en declaraciones y conjuntos, respectivamente.  Si ya sabemos que el tipo A est√° contenido en el universo <code>\Prop</code> (o <code>\Set</code> ), entonces la prueba de la <code>isProp</code> (o <code>isSet</code> ) correspondiente en Arend puede obtenerse usando el axioma <code>Path.inProp</code> integrado en el <a href="">preludio</a> (damos un ejemplo del uso de este axioma en la secci√≥n 2.3). <br><br><pre> <code class="plaintext hljs">\func inProp {A : \Prop} : \Pi (aa' : A) -&gt; a = a'</code> </pre> <br>  Ya hemos notado que no todas las construcciones naturales en tipos retienen la propiedad <code>isProp</code> .  Por ejemplo, los tipos de datos inductivos con dos o m√°s constructores nunca lo satisfacen.  Como se se√±al√≥ anteriormente, podemos usar la construcci√≥n de <i>truncamiento proposicional</i> que convierte cualquier tipo en una declaraci√≥n. <br>  En la biblioteca Arend, la implementaci√≥n est√°ndar del truncamiento proposicional se llama <code>Logic.TruncP</code> .  Podr√≠amos definir un tipo de "o" l√≥gico en Arend como truncar la suma de tipos: <br><br><pre> <code class="plaintext hljs">\data \fixr 2 Or (AB : \Type) -- Sum of types; analogue of Coq's type "sum" | inl A | inr B \func \infixr 2 || (AB : \Type) =&gt; TruncP (sum AB) -- Logical ‚Äúor‚Äù, analogue of Coq's type "\/"</code> </pre> <br>  En Arend, hay otra forma m√°s simple y conveniente de definir un tipo inductivo truncado proposicionalmente.  Para hacer esto, simplemente agregue la palabra clave <code>\truncated</code> antes de definir el tipo de datos.  Por ejemplo, la definici√≥n de un "o" l√≥gico en la biblioteca est√°ndar de Arend se da de la siguiente manera. <br><br><pre> <code class="plaintext hljs">\truncated \data \infixr 2 || (AB : \Type) : \Prop -- Logical ‚Äúor‚Äù, analogue of Coq's type "\/" | byLeft A | byRight B</code> </pre> <br>  El trabajo adicional con tipos truncados proposicionalmente se asemeja al de los tipos asignados al universo <code>Prop</code> en Coq.  Por ejemplo, la coincidencia de patrones de una variable cuyo tipo es una declaraci√≥n solo se permite en una situaci√≥n en la que el tipo de expresi√≥n que se define es en s√≠ misma una declaraci√≥n.  Por lo tanto, siempre es f√°cil definir la funci√≥n <code>Or-to-||</code>  a trav√©s de la comparaci√≥n con la muestra, pero la funci√≥n inversa a ella, solo si el tipo A <code>`Or`</code> B es una declaraci√≥n (lo cual es bastante raro, por ejemplo, cuando los tipos <code>A</code> y <code>B</code> son declaraciones y se excluyen mutuamente). <br><br><pre> <code class="plaintext hljs">\func Or-to-|| {AB : \Prop} (a-or-b : A `Or` B) : A || B | inl a =&gt; byLeft a | inr b =&gt; byRight</code> </pre> <br>  Recuerde tambi√©n que la peculiaridad del mecanismo de universos en Coq es que si se asign√≥ alguna definici√≥n al universo <code>Prop</code> , entonces de ninguna manera ser√° posible usarlo en el c√°lculo.  Por esta raz√≥n, los desarrolladores de Coq <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">no recomiendan el</a> uso de construcciones proposicionales, pero aconsejan reemplazarlas con an√°logos del universo de conjuntos, si es posible.  El mecanismo de los universos Arend no tiene este inconveniente, es decir, en ciertas situaciones es posible usar declaraciones en los c√°lculos.  Daremos un ejemplo de tal situaci√≥n cuando discutamos la implementaci√≥n del algoritmo de clasificaci√≥n de listas. <br><br><h2>  1.4 Clases en Arend </h2><br>  Dado que nuestro objetivo es implementar el algoritmo de clasificaci√≥n m√°s simple, parece √∫til familiarizarse con la implementaci√≥n de conjuntos ordenados disponibles en la biblioteca est√°ndar de Arend. <br><br>  En Arend, las clases se usan para encapsular operaciones y axiomas que definen estructuras matem√°ticas, y tambi√©n para resaltar las relaciones entre estas estructuras usando la herencia.  Las clases tambi√©n son espacios de nombres, dentro de los cuales es conveniente colocar construcciones y teor√≠as con un significado apropiado. <br><br>  La clase base de la que se heredan todas las clases de orden en Arend es la clase <code>BaseSet</code> , que no contiene ning√∫n miembro que no sea la designaci√≥n <code>E</code> para el conjunto de hosts (es decir, el conjunto en el que las <code>BaseSet</code> descendientes de <code>BaseSet</code> ya introducen varias operaciones).  Considere la definici√≥n de esta clase de la biblioteca est√°ndar de Arend. <br><br><pre> <code class="plaintext hljs">\class BaseSet (E : \Set) -- ,    </code> </pre> <br>  En la definici√≥n anterior, el operador <code>E</code> declara un par√°metro de clase.  Uno puede preguntarse, ¬øhay alguna diferencia en la definici√≥n anterior de <code>BaseSet</code> de la siguiente definici√≥n, en la cual el operador E se define como un campo de clase? <br><br><pre> <code class="plaintext hljs">\class BaseSet' --      | E : \Set</code> </pre> <br>  Una respuesta ligeramente inesperada es que en Arend <i>no hay diferencia</i> entre las dos definiciones en el sentido de que cualquier par√°metro de clase (incluso impl√≠cito) en Arend, de hecho, <i>es</i> su campo.  Por lo tanto, para ambas implementaciones de <code>BaseSet</code> , uno podr√≠a usar la expresi√≥n <code>xE</code> para acceder al campo E. <code>BaseSet</code> una diferencia entre las variantes anteriores de la definici√≥n de <code>BaseSet</code> , pero es m√°s sutil, la examinaremos con m√°s detalle en la siguiente secci√≥n cuando analicemos las instancias de clase ( instancias de clase). <br><br>  La operaci√≥n de ordenar una lista tiene sentido solo si se especifica un orden lineal en el tipo de objetos en la lista, por lo tanto, primero consideramos las definiciones de un conjunto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estrictamente ordenado parcialmente</a> y un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conjunto ordenado linealmente.</a> <br><br><pre> <code class="plaintext hljs">\class StrictPoset \extends BaseSet { | \infix 4 &lt; : E -&gt; E -&gt; \Prop | &lt;-irreflexive (x : E) : Not (x &lt; x) | &lt;-transitive (xyz : E) : x &lt; y -&gt; y &lt; z -&gt; x &lt; z } \class LinearOrder \extends StrictPoset { | &lt;-comparison (xyz : E) : x &lt; z -&gt; x &lt; y || y &lt; z | &lt;-connectedness (xy : E) : Not (x &lt; y) -&gt; Not (y &lt; x) -&gt; x = y }</code> </pre> <br>  Desde el punto de vista de la teor√≠a de tipos, las clases en Arend pueden considerarse como an√°logos de tipos sigma con una sintaxis m√°s conveniente para proyecciones y constructores.  ,  Arend-    -,       . <br><br>     ,     <i></i> .     ,      . ,  StrictPoset  <code>&lt;-irreflexive</code>  <code>&lt;-transitive</code>  ,   <code>E</code>  <code>&lt;</code> ‚Äî .     ,     (,  ,    )    ,       . <br><br>        ,   ,    .   ,   Arend  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ,  ,      .  ,       . ,     ,        ,     ,      .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>  : <br><br><pre> <code class="plaintext hljs">\class DecSet \extends BaseSet | decideEq (xy : E) : Dec (x = y)</code> </pre> <br>  <code>Dec</code>     ,  <code>Dec E</code>     ,  <code>E</code> ,      <code>E</code> ,   <code>E</code> . <br><br><pre> <code class="plaintext hljs">\data Dec (E : \Prop) | yes E | no (Not E)</code> </pre> <br> , ,  <code>Dec</code> (  decidable)   <code>Order.LinearOrder</code> .  Dec    , ,  ,     <code>trichotomy</code> , ,      <code>E</code> ,    &lt;.  , <code>Dec</code>      Comparable  Java. <br><br><pre> <code class="plaintext hljs">\class Dec \extends LinearOrder, DecSet { | trichotomy (xy : E) : (x = y) || (x &lt; y) || (y &lt; x) | &lt;-comparison xyz x&lt;z =&gt; {?} --   | &lt;-connectedness xyx/&lt;yy/&lt;x =&gt; {?} | decideEq xy =&gt; {?} }</code> </pre> <br>   <code>Dec</code>         <code>Dec</code> ,    ,   ,  ,            .     <code>Dec</code>    ,     . <br><br>       ,          <code>Dec</code> (        ).  <code>Dec</code> ,   Arend    ( <code>Dec</code>     <code>LinearOrder,</code>  <code>DecSet</code> ),  ,     (diamond inheritance). <br><br>       :                ,     (    ,       ). <br><br>    <code>Dec</code>   <code>Order.LinearOrder</code>   IDEA    (      [Ctrl]+[H]),   ,    . <br><br><img src="https://habrastorage.org/webt/zu/sd/p3/zusdp3ojbuxbuhs11ffqppfjm04.png"><br><br>              Arend (    IDEA    <code>BaseSet</code> ).   ,      . <br><br><h2> 1.5  ,  ,     . </h2><br>        <code>StrictPoset</code>     Nat.  Arend       ,     .       -,  ,    ,   - (   ),           . <br><br>         :   .             . <br><br><pre> <code class="plaintext hljs">data \infix 4 &lt; (ab : Nat) \with | zero, suc _ =&gt; zero&lt;suc_ | suc a, suc b =&gt; suc&lt;suc (a &lt; b) \lemma irreflexivity (x : Nat) (p : x &lt; x) : Empty | suc a, suc&lt;suc a&lt;a =&gt; irreflexivity a a&lt;a \lemma transitivity (xyz : Nat) (p : x &lt; y) (q : y &lt; z) : x &lt; z | zero, suc y', suc z', zero&lt;suc_, suc&lt;suc y'&lt;z' =&gt; zero&lt;suc_ | suc x', suc y', suc z', suc&lt;suc x'&lt;y', suc&lt;suc y'&lt;z' =&gt; suc&lt;suc (transitivity x' y' z' x'&lt;y' y'&lt;z')</code> </pre> <br>       <code>\func</code>   <code>\lemma</code> .      ,       ,        ,     .      ,   <code>\lemma</code>  ,        <code>\Prop</code> . <br><br>    <code>x'&lt;y'</code> ‚Äî    -,    <code>x' &lt; y'</code> .         - (.. ,       ,     ). <br><br>      (instance)  <code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Arend tiene varias opciones de sintaxis diferentes para esto. La primera forma de crear una instancia de una clase es usar una palabra clave </font></font><code>\new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro de cualquier expresi√≥n. En este caso, se crear√° una "instancia de clase an√≥nima".</font></font><br><br><pre> <code class="plaintext hljs">\func NatOrder =&gt; \new StrictPoset { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br>  <code>StrictPoset { ‚Ä¶ }</code>       <code>\new</code> :       - <code>StrictPoset</code> .   -    , ,    ,        <code>\new</code>  .   <code>\new C { ‚Ä¶ }</code>   <code>C { ‚Ä¶ }</code> .       C,      C. ,    ,  <code>NatOrder</code>    <code>StrictPoset</code> . <br><br>    ,         .  ,       <code>StrictPoset Nat</code>      <code>StrictPoset { | E =&gt; Nat }</code> . ,        <code>NatOrder</code>  <code>StrictPoset</code> ,           (     ). <br><br>      <code>NatOrder</code>      <code>\cowith</code>    (          - ). <br><br><pre> <code class="plaintext hljs">\func NatOrder : StrictPoset \cowith { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br> , ,          <code>\instance.</code> <br><br><pre> <code class="plaintext hljs">\instance NatOrder : StrictPoset { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br>  Arend     ,     Haskell.   <code>NatOrder</code>    <code>\instance</code>    <code>\cowith</code>      ,           <code>StrictPoset</code> (    ). <br><br> ,    <code>BaseSet</code>    - E     (   ),      ,         E   .      . <br><br>  ,         Arend      .   Arend  ,            ,       (  ,  ¬´ <i> </i> ¬ª         <code>\classifying \field</code> ,    Arend      ).      : <br><br><ul><li> Arend                . ,  <code>X</code>   <code>StrictPoset</code> ,   <code>List X</code>         <code>List XE</code> . <br></li><li> Arend          . </li></ul><br>  ,    . ,         <code>\instance</code>    <code>StrictPoset</code>    ,     <code>Nat</code>    <code>Int</code> (   <code>NatOrder</code>  <code>IntOrder</code> ). <br><br> ,      <code>x &lt; y</code>      ,  x, y   ,    ,  x, y   .    Arend  ,     <code>NatOrder.&lt;</code> ,    ‚Äî <code>IntOrder.&lt;</code> . <br><br>    ,     . Arend ,   &lt;    <code>StrictPoset</code> ,       E. , Arend      <code>x&lt;y</code>          <code>StrictPoset</code> (  ),     E   .    ,    <code>&lt;</code>     . <br><br> ,                     Arend.        ,     <code>\use \coerce</code>  <i> </i>  .  Arend      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- alg√∫n espacio de nombres utilizado para colocar varias construcciones auxiliares en √©l. Para agregar cualquier otra definici√≥n al m√≥dulo de definici√≥n asociado, se usa la palabra clave </font></font><code>\where</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere el ejemplo m√°s simple de usar un mecanismo de conversi√≥n de tipo. La funci√≥n </font></font><code>fromNat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se usar√° para convertir impl√≠citamente n√∫meros naturales a enteros.</font></font><br><br><pre> <code class="plaintext hljs">\data Int | pos Nat | neg Nat \with { zero =&gt; pos zero } \where { \use \coerce fromNat (n : Nat) =&gt; pos n }</code> </pre> <br>    <code>\use \coerce</code>  <code>\func</code>   ,          .     ,         ,      (,     ,        ). <br><br>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> HoTT   </a>  JetBrains Research. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/469569/">https://habr.com/ru/post/469569/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../469551/index.html">VDS con una tarjeta de video: sabemos mucho sobre perversiones</a></li>
<li><a href="../469555/index.html">Emisi√≥n: Mosc√∫ Kubernetes Meetup # 6</a></li>
<li><a href="../469557/index.html">Vista de reciclador gen√©rico o c√≥mo no escribir c√≥digo repetitivo</a></li>
<li><a href="../469561/index.html">C√°lculo de ra√≠z cuadrada entera</a></li>
<li><a href="../469567/index.html">Antecedentes: detalles sobre el iPhone 11, 11 Pro y el nuevo Apple Watch despu√©s de dos semanas de pruebas</a></li>
<li><a href="../469573/index.html">Linux Piter 2019: lo que le espera a los invitados para una conferencia de Linux a gran escala y por qu√© no se debe perder</a></li>
<li><a href="../469575/index.html">C√≥mo reprogramar el modo de reposo: 30 d√≠as todas las ma√±anas, brillaba una luz verde brillante en mis ojos</a></li>
<li><a href="../469577/index.html">Disco forense, memoria forense y registro forense. Marco de volatilidad y autopsia. Resoluci√≥n de problemas con r0ot-mi. Parte 1</a></li>
<li><a href="../469581/index.html">An√°lisis del efecto Picabu</a></li>
<li><a href="../469583/index.html">OpenVPN y Active Directory (Kerberos sin certificados de usuario)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>