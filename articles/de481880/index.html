<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë©‚Äçüëß‚Äçüëß üßëüèº‚Äçü§ù‚Äçüßëüèª üë©üèæ‚Äçü§ù‚Äçüë®üèΩ Physik f√ºr einen mobilen PvP-Shooter und wie wir uns mit ECS angefreundet haben ‚ö±Ô∏è üë®üèæ‚Äçüîß üî≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! In diesem Artikel werden wir √ºber die pers√∂nlichen Erfahrungen bei der Arbeit mit physischen Engines f√ºr einen Multiplayer-Shooter s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Physik f√ºr einen mobilen PvP-Shooter und wie wir uns mit ECS angefreundet haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/481880/">  Hallo allerseits!  In diesem Artikel werden wir √ºber die pers√∂nlichen Erfahrungen bei der Arbeit mit physischen Engines f√ºr einen Multiplayer-Shooter sprechen und uns haupts√§chlich auf die Interaktion von Physik und <abbr title="ECS ist ein datenorientierter Ansatz, bei dem Daten von der Logik getrennt werden. Daten werden als Entit√§ten und Komponenten dargestellt, die zu Entit√§ten geh√∂ren. Die Logik wird in Systeme beschrieben, bei denen normalerweise die Komponenten von Entit√§ten durchlaufen und ge√§ndert werden, um neue Komponenten und Entit√§ten zu erstellen.">ECS konzentrieren</abbr> : Welche Art von Rechen wir w√§hrend der Arbeit eingesetzt haben, was wir gelernt haben, warum wir uns f√ºr bestimmte L√∂sungen entschieden haben. <br><br><img src="https://habrastorage.org/webt/gp/b_/2-/gpb_2-4ml1nwdsb443-f2pp6zyu.png"><br><a name="habracut"></a><br>  Lassen Sie uns zun√§chst herausfinden, warum ein physischer Motor ben√∂tigt wird.  Es gibt keine allgemeing√ºltige Antwort: In jedem Spiel erf√ºllt es seinen Zweck.  Einige Spiele verwenden physische Engines, um das Verhalten von Objekten in der Welt korrekt zu simulieren und den Effekt des Eintauchens des Spielers zu erzielen.  In anderen ist die Physik die Grundlage des Spiels - wie zum Beispiel Angry Birds und Red Faction.  Es gibt auch ‚ÄûSandk√§sten‚Äú, in denen sich die physikalischen Gesetze von den √ºblichen unterscheiden und so das Gameplay interessanter und ungew√∂hnlicher machen (Portal, A Slower of Light). <br><br>  Aus programmtechnischer Sicht erm√∂glicht es die physische Engine, den Prozess der Simulation des Verhaltens von Objekten in einem Spiel zu vereinfachen.  In der Tat ist es eine Bibliothek, die Beschreibungen der physikalischen Eigenschaften von Objekten speichert.  In Gegenwart einer physischen Engine m√ºssen wir kein System der Interaktion zwischen K√∂rpern und universellen Gesetzen entwickeln, nach dem die Spielwelt leben wird.  Dies spart eine Menge Zeit und Entwicklungsaufwand. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ef/938/61f/5ef93861ff7c4921e44bcf14902cab51.jpg" alt="Bild"><br>  <i>Das <a href="https://habr.com/ru/company/pixonic/blog/413729/">obige Diagramm</a> beschreibt das Wesentliche des Players, seiner Komponenten und deren Daten sowie die Systeme, die mit dem Player und seinen Komponenten zusammenarbeiten.</i>  <i>Das Schl√ºsselobjekt im Diagramm ist der Spieler: Er kann sich im Raum bewegen - Transformations- und Bewegungskomponenten, MoveSystem;</i>  <i>hat eine gewisse Gesundheit und kann sterben - Komponente Gesundheit, Schaden, DamageSystem;</i>  <i>Nach dem Tod erscheint am Respawn-Punkt die Transform-Komponente f√ºr die Position, das RespawnSystem.</i>  <i>kann unverwundbar sein - Komponente unbesiegbar.</i> <br><br><h2>  Was zeichnet die Implementierung der Spielphysik f√ºr Sch√ºtzen aus? </h2><br>  Es gibt keine komplexen physischen Interaktionen in unserem Spiel, aber es gibt eine Reihe von Dingen, f√ºr die noch eine physische Engine ben√∂tigt wird.  Urspr√ºnglich wollten wir damit einen Charakter in der Welt nach vorher festgelegten Gesetzen bewegen.  Dies geschieht normalerweise, indem dem K√∂rper ein bestimmter Impuls oder eine konstante Geschwindigkeit verliehen wird. Anschlie√üend werden mit der Simulate / Update-Methode der Bibliothek alle darin registrierten K√∂rper genau einen Schritt vorw√§rts simuliert. <br><br>  In Shootern wird 3D-Physik h√§ufig nicht nur verwendet, um die Bewegungen des Charakters zu simulieren, sondern auch, um die Ballistik von Kugeln und Raketen, Spr√ºngen, Interaktionen zwischen den Charakteren und der Umgebung korrekt zu verarbeiten.  Wenn der Sch√ºtze behauptet, realistisch zu sein und die wahren Empfindungen des Schie√üprozesses vermitteln zu wollen, braucht er nur einen physischen Motor.  Wenn ein Spieler eine Schrotflinte auf ein Ziel schie√üt, erwartet er eine Erfahrung und ein Ergebnis, das so nahe wie m√∂glich an dem liegt, das er bereits aus einem Langzeitschie√üspiel kennt - etwas radikal Neues wird ihn h√∂chstwahrscheinlich unangenehm √ºberraschen. <br><br>  Bei unserem Spiel gibt es jedoch eine Reihe von Einschr√§nkungen.  Da unser Sch√ºtze mobil ist, impliziert er keine komplexen Interaktionen der Charaktere untereinander und mit der umgebenden Welt. Er erfordert keine sch√∂ne Ballistik, Zerst√∂rbarkeit und kein Springen auf einer unebenen Oberfl√§che.  Gleichzeitig und aus demselben Grund gibt es sehr strenge Verkehrsanforderungen.  3D-Physik w√§re in diesem Fall √ºberfl√ºssig: Sie w√ºrde nur einen kleinen Teil ihrer Rechenressourcen verbrauchen und unn√∂tige Daten erzeugen, was in einem Mobilfunknetz und einer st√§ndigen Synchronisation des Clients mit dem Server √ºber UDP zu viel Platz beanspruchen w√ºrde.  An dieser Stelle sei daran erinnert, dass es in unserem Netzwerkmodell noch <a href="https://habr.com/ru/company/pixonic/blog/415959/">Vorhersagen und Abgleiche gibt</a> , die auch Abrechnungen auf dem Kunden beinhalten.  Als Ergebnis erhalten wir, dass unsere Physik so schnell wie m√∂glich arbeiten sollte, um mobile Ger√§te erfolgreich zu starten und zu bearbeiten, ohne das Rendern und andere Client-Subsysteme zu beeintr√§chtigen. <br><br>  3D-Physik passte also nicht zu uns.  Aber auch wenn das Spiel dreidimensional aussieht, ist es nicht so, dass die Physik darin auch dreidimensional ist: Alles bestimmt die Art der Interaktion von Objekten miteinander.  Oft werden Effekte, die von der 2D-Physik nicht abgedeckt werden k√∂nnen, entweder angepasst, dh es wird eine Logik geschrieben, die wie dreidimensionale Interaktionen aussieht, oder sie werden einfach durch visuelle Effekte ersetzt, die das Gameplay nicht beeinflussen.  In "Heroes of the Storm", "Defense of the Ancients", "League of Legends" kann die zweidimensionale Physik alle Gameplay-Funktionen des Spiels bereitstellen, ohne die Bildqualit√§t oder das von Spieldesignern und K√ºnstlern der Welt erzeugte Glaubw√ºrdigkeitsgef√ºhl zu beeintr√§chtigen.  So gibt es zum Beispiel in diesen Spielen springende Charaktere, aber es gibt keinen physikalischen Sinn f√ºr die H√∂he ihres Sprungs, so dass es sich um eine zweidimensionale Simulation handelt und eine Art Flag wie _isInTheAir gesetzt wird, wenn sich der Charakter in der Luft befindet - dies wird bei der Berechnung der Logik ber√ºcksichtigt. <br><br>  Daher wurde entschieden, 2D-Physik zu verwenden.  Wir schreiben das Spiel in Unity, aber der Server verwendet .net ohne Unity, was Unity nicht versteht.  Da der L√∂wenanteil des Simulationscodes zwischen dem Client und dem Server durchsucht wird, haben wir uns nach etwas Plattform√ºbergreifendem umgesehen, n√§mlich nach einer physischen Bibliothek, die in reinem C # geschrieben ist, ohne systemeigenen Code, um die Gefahr eines Absturzes mobiler Plattformen auszuschlie√üen.  Unter Ber√ºcksichtigung der <a href="https://habr.com/ru/company/pixonic/blog/415959/">Besonderheiten der Arbeit der Sch√ºtzen</a> , insbesondere des st√§ndigen Zur√ºckspulens auf dem Server, um festzustellen, wo der Spieler geschossen hat, war es f√ºr uns au√üerdem wichtig, dass die Bibliothek mit der Geschichte arbeiten konnte, dh, wir konnten die Position der K√∂rper N Bilder in der Zeit zur√ºckverfolgen .  Und nat√ºrlich sollte das Projekt nicht abgebrochen werden: Es ist wichtig, dass der Autor es unterst√ºtzt und Fehler, die w√§hrend des Betriebs gefunden werden, schnell beheben kann. <br><br>  Es stellte sich heraus, dass zu diesem Zeitpunkt nur sehr wenige Bibliotheken unsere Anforderungen erf√ºllen konnten.  Tats√§chlich war nur eines f√ºr uns geeignet - <a href="https://github.com/ashoulson/VolatilePhysics">VolatilePhysics</a> . <br><br>  Die Bibliothek ist insofern bemerkenswert, als sie sowohl mit Unity-L√∂sungen als auch mit L√∂sungen ohne Unity-L√∂sungen zusammenarbeitet und es Ihnen auch erm√∂glicht, Rakecasts in den vorherigen Status von Objekten zu erstellen, z.  Geeignet f√ºr Shooter-Logik.  Der Vorteil der Bibliothek besteht au√üerdem darin, dass Sie mit dem Mechanismus zur Steuerung des Simulationsstarts von Simulate () die Bibliothek jederzeit erstellen k√∂nnen, wenn der Client sie ben√∂tigt.  Und ein weiteres Merkmal - die F√§higkeit, zus√§tzliche Daten in den physischen K√∂rper zu schreiben.  Dies kann n√ºtzlich sein, wenn ein Objekt aus einer Simulation in den Ergebnissen von Reykast angesprochen wird. Dies verringert jedoch die Leistung erheblich. <br><br>  Nachdem wir einige Tests durchgef√ºhrt und sichergestellt hatten, dass der Client und der Server ohne Abst√ºrze gut mit VolatilePhysics interagieren, haben wir uns daf√ºr entschieden. <br><br><h2>  Wie wir die Bibliothek auf die √ºbliche Art und Weise betraten und wie es dazu kam </h2><br>  Der erste Schritt bei der Arbeit mit VolatilePhysics ist die Erstellung der physikalischen Welt von VoltWorld.  Es ist eine Proxy-Klasse, mit der die Hauptarbeit ausgef√ºhrt wird: Optimieren, Simulieren von Daten √ºber Objekte, Rakecasts usw. Wir haben sie in eine spezielle Fassade eingepackt, damit wir die Bibliotheksimplementierung in Zukunft auf etwas anderes umstellen k√∂nnen.  Der Fassadencode sah folgenderma√üen aus: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PhysicsWorld</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> HistoryLength = <span class="hljs-number"><span class="hljs-number">32</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> VoltWorld _voltWorld; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, VoltBody&gt; _cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, VoltBody&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PhysicsWorld</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> deltaTime</span></span></span><span class="hljs-function">)</span></span> { _voltWorld = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltWorld(HistoryLength) { DeltaTime = deltaTime }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _cache.ContainsKey(tag); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> VoltBody </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { VoltBody body; _cache.TryGetValue(tag, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> body); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> body; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> VoltRayResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RayCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, Vector2 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, VoltBodyFilter filter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltRayCast(origin, direction.normalized, distance); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltRayResult(); _voltWorld.RayCast(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ray, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> result, filter, ticksBehind); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> VoltRayResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CircleCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, Vector2 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, VoltBodyFilter filter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltRayCast(origin, direction.normalized, distance); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VoltRayResult(); _voltWorld.CircleCast(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> ray, radius, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> result, filter, ticksBehind); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _voltWorld.Update(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _cache[tag]; _voltWorld.Update(body, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag, Vector2 position, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> angle</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _cache[tag]; body.Set(position, angle); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticCircle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = _voltWorld.CreateCircleWorldSpace(origin, radius, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _voltWorld.CreateStaticBody(origin, <span class="hljs-number"><span class="hljs-number">0</span></span>, shape); body.UserData = tag; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicCircle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = _voltWorld.CreateCircleWorldSpace(origin, radius, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _voltWorld.CreateDynamicBody(origin, <span class="hljs-number"><span class="hljs-number">0</span></span>, shape); body.UserData = tag; body.CollisionFilter = StaticCollisionFilter; _cache.Add(tag, body); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticSquare</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotationAngle, Vector2 extents, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = _voltWorld.CreatePolygonBodySpace(extents.GetRectFromExtents(), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _voltWorld.CreateStaticBody(origin, rotationAngle, shape); body.UserData = tag; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicSquare</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rotationAngle, Vector2 extents, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tag</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = _voltWorld.CreatePolygonBodySpace(extents.GetRectFromExtents(), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _voltWorld.CreateDynamicBody(origin, rotationAngle, shape); body.UserData = tag; body.CollisionFilter = StaticCollisionFilter; _cache.Add(tag, body); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IEnumerable&lt;VoltBody&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBodies</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _voltWorld.Bodies; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StaticCollisionFilter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VoltBody a, VoltBody b</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.IsStatic; } }</code> </pre> <br></div></div><br>  Bei der Erstellung der Welt wird die Gr√∂√üe der Geschichte angegeben - die Anzahl der Zust√§nde der Welt, die in der Bibliothek gespeichert werden.  In unserem Fall betrug die Anzahl 32: 30 Frames pro Sekunde. Wir ben√∂tigen sie basierend auf der Anforderung, die Logik zu aktualisieren, und 2 zus√§tzliche, falls wir die Grenzen des Debugging-Prozesses √ºberschreiten.  Der Code ber√ºcksichtigt auch nach au√üen geworfene Methoden, die physische K√∂rper erzeugen, und verschiedene Arten von Reykast. <br><br>  Wie wir uns aus <a href="https://habr.com/ru/company/pixonic/blog/429312/">fr√ºheren Artikeln</a> erinnern, dreht sich die ECS-Welt im Wesentlichen um einen regelm√§√üigen Aufruf von Execute-Methoden f√ºr alle darin enthaltenen Systeme.  An den richtigen Stellen jedes Systems verwenden wir Anrufe f√ºr unsere Fassade.  Anfangs haben wir keine Chargen geschrieben, um die physische Maschine herauszufordern, obwohl es solche Gedanken gab.  Innerhalb der Fassade findet ein Aufruf von Update () der physischen Welt statt, und die Bibliothek simuliert alle Interaktionen von Objekten, die pro Frame aufgetreten sind. <br><br>  Die Arbeit mit der Physik besteht also aus zwei Komponenten: der gleichm√§√üigen Bewegung der K√∂rper im Raum in einem Bild und dem vielen Rakast, der f√ºr das Schie√üen ben√∂tigt wird, der richtigen Wirkung von Effekten und vielen anderen Dingen.  Reykasten sind besonders relevant in der Geschichte des Zustands physischer K√∂rper. <br><br>  Nach den Ergebnissen unserer Tests haben wir schnell festgestellt, dass die Bibliothek bei unterschiedlichen Geschwindigkeiten sehr schlecht funktioniert, und ab einer bestimmten Geschwindigkeit k√∂nnen K√∂rper leicht W√§nde passieren.  Mit der kontinuierlichen Kollisionserkennung sind keine Einstellungen verkn√ºpft, um dieses Problem in unserem Motor zu l√∂sen.  Zu dieser Zeit gab es jedoch keine Alternativen zu unserer L√∂sung auf dem Markt. Daher musste ich eine eigene Version von sich bewegenden Objekten auf der ganzen Welt entwickeln und Physikdaten mit ECS synchronisieren.  So lautet beispielsweise unser Code f√ºr das Bewegungssystem wie folgt: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Volatile; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovePhysicsSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ExecutableSystem</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> PhysicsWorld _physicsWorld; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> CollisionFilter _moveFilter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> VoltBodyFilter _collisionFilterDelegate; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MovePhysicsSystem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PhysicsWorld physicsWorld</span></span></span><span class="hljs-function">)</span></span> { _physicsWorld = physicsWorld; _moveFilter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CollisionFilter(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, CollisionLayer.ExplosiveBarrel); _collisionFilterDelegate = _moveFilter.Filter; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { _moveFilter.State = gs; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { ExecuteMovement(gs, pair.Key, pair.Value); } _physicsWorld.Update(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.PhysicsDynamicBody) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pair.Value.IsAlive) { ExecutePhysicsDynamicBody(gs, pair.Key); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> avatarId</span></span></span><span class="hljs-function">)</span></span> { _moveFilter.State = gs; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movement = gs.WorldState.Movement[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (movement != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ExecuteMovement(gs, avatarId, movement); _physicsWorld.Update(avatarId); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> physicsDynamicBody = gs.WorldState.PhysicsDynamicBody[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (physicsDynamicBody != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; physicsDynamicBody.IsAlive) ExecutePhysicsDynamicBody(gs, avatarId); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutePhysicsDynamicBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> entityId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _physicsWorld.GetBody(entityId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (body != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = gs.WorldState.Transform[entityId]; transform.Position = body.Position; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteMovement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> entityId, Movement movement</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _physicsWorld.GetBody(entityId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (body != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> raycastRadius; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CalculateRadius(gs, entityId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> raycastRadius)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } body.AngularVelocity = <span class="hljs-number"><span class="hljs-number">0</span></span>; body.LinearVelocity = movement.Velocity; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movPhysicInfo = gs.WorldState.MovementPhysicInfo[entityId]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collisionDirection = CircleRayCastSpeedCorrection(body, GameState.TickDurationSec, raycastRadius); CheckMoveInWall(movement, movPhysicInfo, collisionDirection, gs.WorldState.Transform[entityId]); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateRadius</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> raycastRadius</span></span></span><span class="hljs-function">)</span></span> { raycastRadius = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> circleShape = gs.WorldState.DynamicCircleCollider[id]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (circleShape != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { raycastRadius = circleShape.Radius; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boxShape = gs.WorldState.DynamicBoxCollider[id]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boxShape != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { raycastRadius = boxShape.RaycastRadius; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gs.Log.Error(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Physics body {0} doesn't contains shape!"</span></span>, id)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMoveInWall</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Movement movement, MovementPhysicInfo movPhysicInfo, Vector2 collisionDirection, Transform transform</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 60 is the max angle when player move in wall and can shoot through the wall from weapon without target. const float maxAngleToWall = 60; if (movement.Velocity.IsEqual(Vector2.zero)) { if (movPhysicInfo.LastCollisionDirection.IsEqual(Vector2.zero)) { var angleToCollision = transform.Angle.GetDirection().CalculateAbsoluteAngleInDegrees(movPhysicInfo.LastCollisionDirection); movPhysicInfo.TurnOnWall = angleToCollision &lt;= maxAngleToWall; } return; } movPhysicInfo.LastCollisionDirection = collisionDirection * -1f; if (movPhysicInfo.LastCollisionDirection.IsEqual(Vector2.zero)) { movPhysicInfo.TurnOnWall = false; movPhysicInfo.LastCollisionDirection = collisionDirection; } else { var angleToCollision = transform.Angle.GetDirection().CalculateAbsoluteAngleInDegrees(movPhysicInfo.LastCollisionDirection); movPhysicInfo.TurnOnWall = angleToCollision &lt;= maxAngleToWall; } } // I can't believe we are using a physics engine and have to write such kludges private Vector2 CircleRayCastSpeedCorrection(VoltBody targetBody, float deltaSeconds, float rayCastRadius) { if (rayCastRadius &lt;= 0) { return Vector2.zero; } var speed = targetBody.LinearVelocity; var position = targetBody.Position; var direction = speed * deltaSeconds; var rayCastResult = _physicsWorld.CircleCast(position + direction.normalized * 0.1f, direction, direction.magnitude, rayCastRadius, _collisionFilterDelegate, 0); if (rayCastResult.Body == null) { return Vector2.zero; } var magSpeed = speed.magnitude; if (rayCastResult.Distance &gt; 0) { var penetratingDistance = magSpeed * deltaSeconds - rayCastResult.Distance; var sinVelocityEdge = Vector2.Dot(-speed.normalized, rayCastResult.Normal); var biasSpeed = penetratingDistance * sinVelocityEdge / deltaSeconds; var biasVector = rayCastResult.Normal * biasSpeed * 1.1f; var resultVelocity = speed + biasVector; if (magSpeed &lt;= 0) { resultVelocity = Vector2.zero; } targetBody.LinearVelocity = resultVelocity; return rayCastResult.Normal; } var destination = rayCastResult.Body.Position; direction = destination - position; var rayCastResultToBody = _physicsWorld.RayCast(position, direction, direction.magnitude, _collisionFilterDelegate, 0); if (rayCastResultToBody.IsValid) targetBody.LinearVelocity = rayCastResultToBody.Normal * magSpeed * deltaSeconds; return rayCastResultToBody.Normal; } }</span></span></code> </pre> <br></div></div><br>  Die Idee ist, dass wir vor jeder Bewegung eines <a href="https://docs.unity3d.com/ScriptReference/Physics2D.CircleCast.html">Charakters</a> einen <a href="https://docs.unity3d.com/ScriptReference/Physics2D.CircleCast.html">CircleCast</a> in seiner Bewegungsrichtung <a href="https://docs.unity3d.com/ScriptReference/Physics2D.CircleCast.html">erstellen</a> , um festzustellen, ob sich ein Hindernis davor befindet.  CircleCast wird ben√∂tigt, da die Projektionen der Charaktere im Spiel einen Kreis darstellen und sie nicht in den Ecken zwischen verschiedenen Geometrien stecken bleiben sollen.  Dann betrachten wir das Inkrement der Geschwindigkeit und weisen dem Objekt der physischen Welt diesen Wert als seine Geschwindigkeit in einem Frame zu.  Der n√§chste Schritt ist der Aufruf der Simulationsmethode des Physical Engine Update (), die alle ben√∂tigten Objekte verschiebt und gleichzeitig den alten Zustand in der Historie aufzeichnet.  Nachdem die Simulation innerhalb der Engine abgeschlossen ist, lesen wir diese simulierten Daten, kopieren sie in die Transform-Komponente unseres ECS und senden sie dann weiter, insbesondere √ºber das Netzwerk. <br><br>  Dieser Ansatz bei der Aktualisierung der Physik mit kleinen kontrollierten Datenbl√∂cken √ºber die Bewegungsgeschwindigkeit des Charakters erwies sich als sehr effektiv bei der Beseitigung physikalischer Diskrepanzen auf dem Client und dem Server.  Und da unsere Physik nicht deterministisch ist - das hei√üt, mit denselben Eingabedaten kann das Simulationsergebnis variieren - wurde viel dar√ºber diskutiert, ob es sich √ºberhaupt lohnt, sie zu verwenden, und ob irgendjemand in der Branche etwas √Ñhnliches tut. mit einem deterministischen physischen Motor in der Hand.  Gl√ºcklicherweise haben wir auf der Game Developers Conference einen hervorragenden Bericht der Entwickler von NetherRealm Studios √ºber die Netzwerkkomponente ihrer Spiele gefunden und festgestellt, dass ein solcher Ansatz wirklich funktioniert.  Nachdem wir das System vollst√§ndig zusammengebaut und in mehreren Tests getestet haben, haben wir ungef√§hr 50 falsche Vorhersagen f√ºr 9000 Zecken erhalten, d. H. W√§hrend des f√ºnfmin√ºtigen Gefechts.  Eine solche Anzahl von verpassten Vorhersagen kann durch den Abgleichsmechanismus und die visuelle Interpolation der Position des Spielers leicht ausgeglichen werden.  Fehler, die bei h√§ufigen manuellen Aktualisierungen der Physik unter Verwendung Ihrer eigenen Daten auftreten, sind unerheblich. Daher kann eine visuelle Interpolation relativ schnell erfolgen. Sie ist nur erforderlich, damit kein visueller Sprung im Zeichenmodell erfolgt. <br><br>  Um zu √ºberpr√ºfen, ob der Client- und der Serverstatus √ºbereinstimmen, haben wir eine selbstgeschriebene Klasse der folgenden Form verwendet: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> PS.Logs.Unity; <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Compares the same avatar in two states. Compares the values potentially </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> affected by prediction. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public sealed class GameStateComparer : IGameStateComparer { public bool IsSame(GameState s1, GameState s2, uint avatarId) { if (s1 == null &amp;&amp; s2 != null || s1 != null &amp;&amp; s2 == null) { return false; } if (s1 == null &amp;&amp; s2 == null) return false; var entity1 = s1.WorldState[avatarId]; var entity2 = s2.WorldState[avatarId]; if (entity1 == null &amp;&amp; entity2 == null) { return false; } if (entity1 == null || entity2 == null) { LogManager.Debug("entity is different"); return false; } if (s1.Time != s2.Time) { LogManager.Warning(string.Format("Trying to compare states with different time! Predicted time: {0} Server time: {1}", s1.Time, s2.Time)); return false; } if (s1.WorldState.Transform[avatarId] != s2.WorldState.Transform[avatarId]) { LogManager.Debug("Transform is different"); return false; } // ... some code ... return true; } }</span></span></code> </pre> <br></div></div><br>  Bei Bedarf kann es automatisiert werden, aber wir haben dies nicht getan, obwohl wir in Zukunft dar√ºber nachgedacht haben. <br><br>  Vergleichscode transformieren: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==(Transform a, Transform b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Angle - b.Angle) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Position.x - b.Position.x) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span> || Math.Abs(a.Position.y - b.Position.y) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br><br><h2>  Erste Schwierigkeiten </h2><br>  Es gab keine Probleme mit der Bewegungssimulation, obwohl sie auf eine 2D-Ebene projiziert werden konnte - die Physik funktionierte in solchen F√§llen sehr gut, aber irgendwann kamen Spieledesigner und sagten: ‚ÄûWir wollen Granaten!‚Äú Und wir dachten, dass sich nicht viel √§ndern w√ºrde , warum nicht den 3D-Flug des physischen K√∂rpers mit nur 2D-Daten simulieren? <br><br>  Und sie f√ºhrten das Konzept der H√∂he f√ºr einige Objekte ein. <br><br>  Wie das Gesetz der H√∂hen√§nderung im Laufe der Zeit f√ºr einen verlassenen K√∂rper aussieht, durchlaufen sie den Physikunterricht in der achten Klasse, so dass sich die Entscheidung √ºber die Ballistik als trivial herausstellte.  Aber die L√∂sung mit Kollisionen war nicht mehr so ‚Äã‚Äãtrivial.  Stellen wir uns diesen Fall vor: Eine Granate sollte w√§hrend des Fluges entweder mit einer Mauer kollidieren oder dar√ºber fliegen, je nach aktueller H√∂he und H√∂he der Mauer.  Wir werden das Problem nur in der zweidimensionalen Welt l√∂sen, in der die Granate durch einen Kreis und die Wand durch ein Rechteck dargestellt wird. <br><br><img src="https://habrastorage.org/webt/ej/yr/lk/ejyrlkwa0tu9hm-3j7nobxmazpo.png"><br>  <i>Ansicht der Geometrie von Objekten zur L√∂sung des Problems</i> <br><br>  Zun√§chst haben wir die Interaktion des dynamischen K√∂rpers einer Granate mit anderen statischen und dynamischen K√∂rpern ausgeschaltet.  Dies ist notwendig, um sich auf das Ziel zu konzentrieren.  In unserer Aufgabe sollte eine Granate in der Lage sein, andere Objekte zu durchdringen und √ºber eine Wand zu fliegen, wenn sich ihre Projektionen auf einer zweidimensionalen Ebene schneiden.  In einer normalen Interaktion k√∂nnen zwei Objekte nicht durcheinander kommen. Bei einer Granate mit einer benutzerdefinierten Bewegungslogik und -h√∂he haben wir dies unter bestimmten Bedingungen zugelassen. <br><br>  Wir haben eine separate Komponente von GrenadeMovement f√ºr die Granate eingef√ºhrt, in der wir das Konzept der H√∂he eingef√ºhrt haben: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Component</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GrenadeMovement</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Height; [DontPack] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Velocity; [DontPack] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> VerticalVelocity; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrenadeMovement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, Vector2 velocity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> verticalVelocity</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br>  Jetzt hat die Granate eine H√∂henkoordinate, aber diese Information gibt dem Rest der Welt nichts.  Deshalb haben wir uns entschlossen zu schummeln und folgende Bedingung hinzugef√ºgt: Eine Granate kann √ºber Mauern fliegen, aber nur mit einer bestimmten H√∂he.  Die gesamte Definition von Kollisionen bestand also darin, Projektionskollisionen zu √ºberpr√ºfen und die H√∂he der Wand mit dem Wert des GrenadeMovement.Height-Felds zu vergleichen.  Wenn die Flugh√∂he der Granate geringer ist, st√∂√üt sie mit der Wand zusammen. Andernfalls kann sie sich ruhig weiter auf ihrem Weg bewegen, auch im 2D-Raum. <br><br>  In der ersten Iteration fiel die Granate einfach, als wir Kreuzungen fanden, aber dann f√ºgten wir elastische Kollisionen hinzu, und es begann, sich von dem Ergebnis, das wir in 3D erhalten w√ºrden, fast ununterscheidbar zu verhalten. <br><br>  Der vollst√§ndige Code zur Berechnung der Flugbahn einer Granate und der elastischen Kollisionen ist unten angegeben: <br><br><div class="spoiler">  <b class="spoiler_title">Code anzeigen</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-comment"><span class="hljs-comment">// ... some code ... using Volatile; namespace Common.WorldState { public sealed class GrenadeMovementSystem : ExecutableSystem { private struct Projection { public float Min; public float Max; } private float _r; private readonly Vector2[] _vertices = new Vector2[4]; private readonly Vector2[] _verticesV = new Vector2[4]; private Vector2 _Vunit; private Vector2 _VTunit; private Projection _wallProj1; private Projection _wallProj2; private Projection _wallProj1V; private Projection _wallProj2V; private const float CollisionPrecision = 1e-3f; private static readonly float HalfSlope = Mathf.Cos(Mathf.PI / 4.0f); private readonly ContactPointList _contactPoints = new ContactPointList(3); public override void Execute(GameState gs) { var settings = gs.RuleBook.GrenadeConfig[1]; _r = settings.R; var floorDampeningPerTick = (float)Math.Pow(settings.FloorDampening, 1.0 / GameState.Hz); foreach (var grenade in gs.WorldState.GrenadeMovement) { // Gravity must take effect before collision // because contact with walls may and will adjust vertical velocity // and penetration will even move the ball up. grenade.Value.VerticalVelocity -= settings.Gravity * GameState.TickDurationSec; grenade.Value.Height += grenade.Value.VerticalVelocity * GameState.TickDurationSec; // prevent falling through floor if (grenade.Value.Height &lt;= _r) { // slow down horizontal movement by floor friction // actually, friciton is simplified to just dampening coefficient var spdH = grenade.Value.Velocity.sqrMagnitude; var spdV = grenade.Value.VerticalVelocity; var cos = spdH / Mathf.Sqrt(spdH * spdH + spdV * spdV); grenade.Value.Velocity *= floorDampeningPerTick * cos; // slow down vertical movement grenade.Value.VerticalVelocity = settings.FloorRestitution * Math.Abs(grenade.Value.VerticalVelocity); // move up to the floor level grenade.Value.Height = _r; } // A collision will stop the ball and change its velocity. // Otherwise it will be moved by velocity PerformCollisionAndMovement(gs, grenade.Key, grenade.Value); } } private void PerformCollisionAndMovement(GameState gs, uint id, GrenadeMovement grenade) { var settings = gs.RuleBook.GrenadeConfig[1]; var velocity = grenade.Velocity * GameState.TickDurationSec; var trans = gs.WorldState.Transform[id]; var position = trans.Position; _Vunit = velocity.normalized; _VTunit = new Vector2(-_Vunit.y, _Vunit.x); _vertices[0] = position + _VTunit * _r; _vertices[1] = position - _VTunit * _r; _vertices[2] = _vertices[1] + velocity; _vertices[3] = _vertices[0] + velocity; _contactPoints.Reset(); int collisions = 0; var grenProj1V = ProjectCapsule(_Vunit, _vertices, position, velocity); var grenProj2V = ProjectCapsule(_VTunit, _vertices, position, velocity); collisions += CollideWithStaticBoxes(gs, id, position, velocity, grenade, grenProj1V, grenProj2V); collisions += CollideWithCircles(gs, gs.RuleBook.StaticCircleCollider, gs.RuleBook.Transform, id, position, velocity, grenade, grenProj1V, grenProj2V, (CollisionLayer)~0); collisions += CollideWithCircles(gs, gs.WorldState.DynamicCircleCollider, gs.WorldState.Transform, id, position, velocity, grenade, grenProj1V, grenProj2V, ~CollisionLayer.Character); if (collisions == 0) { trans.Position += velocity; } else { var contactSuperposition = CalculateContactSuperposition(); trans.Position += velocity * contactSuperposition.TravelDistance; var reflectedVelocity = grenade.Velocity - 2.0f * Vector2.Dot(grenade.Velocity, contactSuperposition.Normal) * contactSuperposition.Normal; reflectedVelocity *= settings.WallRestitution; #if DEBUG_GRENADES gs.Log.Debug("contact" + "\n\ttravel " + contactSuperposition.TravelDistance + "\n\tcontactNormal " + contactSuperposition.Normal.x + ":" + contactSuperposition.Normal.y + "\n\treflected V " + reflectedVelocity.x + ":" + reflectedVelocity.y); #endif grenade.Velocity = reflectedVelocity; } } private int CollideWithStaticBoxes( GameState gs, uint id, Vector2 position, Vector2 velocity, GrenadeMovement grenade, Projection grenProj1V, Projection grenProj2V) { var settings = gs.RuleBook.GrenadeConfig[1]; var collisions = 0; // TODO spatial query foreach (var collider in gs.RuleBook.StaticBoxCollider) { var wall = collider.Value; var transform = gs.RuleBook.Transform[collider.Key]; var colliderData = gs.RuleBook.PrecomputedColliderData[collider.Key]; // test projection to V _wallProj1V = ProjectPolygon(_Vunit, colliderData.Vertices); if (!Overlap(_wallProj1V, grenProj1V)) continue; // test projection to VT _wallProj2V = ProjectPolygon(_VTunit, colliderData.Vertices); if (!Overlap(_wallProj2V, grenProj2V)) continue; // test projection to wall axis 1 _wallProj1 = ProjectPolygon(colliderData.Axis1, colliderData.Vertices); var grenProj1 = ProjectCapsule(colliderData.Axis1, _vertices, position, velocity); if (!Overlap(_wallProj1, grenProj1)) continue; // test projection to wall axis 2 _wallProj2 = ProjectPolygon(colliderData.Axis2, colliderData.Vertices); var grenProj2 = ProjectCapsule(colliderData.Axis2, _vertices, position, velocity); if (!Overlap(_wallProj2, grenProj2)) continue; var lowWall = wall.Height &lt; settings.TallWallHeight; if (lowWall) { // the wall is too far below, ignore it completely if (grenade.Height &gt; wall.Height + _r) continue; // if grenade if falling down, it can bounce off the top of the wall if (grenade.VerticalVelocity &lt; 0f) { if (grenade.Height &gt; wall.Height - _r) { var localPV = WorldToBoxLocal(transform.Position, colliderData, position + velocity); #if DEBUG_GRENADES gs.Log.Debug("fall on wall" + "\n\tP+V " + (Px + Vx) + ":" + (Py + Vy) + "\n\tlocal " + localPV.x + ":" + localPV.y + "\n\tH w " + wall.Height + " g " + grenade.Height ); #endif if (Math.Abs(localPV.x) &lt; wall.Size.x * 0.5f || Math.Abs(localPV.y) &lt; wall.Size.y * 0.5f) { grenade.Height = wall.Height + _r; grenade.VerticalVelocity = settings.WallRestitution * Math.Abs(grenade.VerticalVelocity); continue; } } } } // collision detected // try to find minimal V before collision var scaleV = CalcTranslationScaleBeforeCollision(CheckBoxCollision, colliderData, 0, position, velocity); var contactPoint = CalcBoxContactPoint(transform.Position, wall, colliderData, position); #if DEBUG_GRENADES gs.Log.Debug("collision grenade #" + id + " with static box #" + collider.Key + "\n\tP=" + Px + ":" + Py + "\n\tV=" + Vx + ":" + Vy + " scale=" + scaleV + "\n\tP+Vs=" + (Px + Vx * scaleV) + ":" + (Py + Vy * scaleV) + "\n\twall pos " + transform.Position.x + ":" + transform.Position.y + " sz " + wall.Size.x + ":" + wall.Size.y + " angle " + transform.Angle + "\n\tproj V w " + _wallProj1V.Min + ":" + _wallProj1V.Max + " g " + grenProj1V.Min + ":" + grenProj1V.Max + " overlap=" + Overlap(_wallProj1V, grenProj1V) + "\n\tproj VT w " + _wallProj2V.Min + ":" + _wallProj2V.Max + " g " + grenProj2V.Min + ":" + grenProj2V.Max + " overlap=" + Overlap(_wallProj2V, grenProj2V) + "\n\taxis1 " + colliderData.Axis1.x + ":" + colliderData.Axis1.y + "\n\tproj 1 w " + _wallProj1.Min + ":" + _wallProj1.Max + " g " + grenProj1.Min + ":" + grenProj1.Max + " overlap=" + Overlap(_wallProj1, grenProj1) + "\n\taxis2 " + colliderData.Axis2.x + ":" + colliderData.Axis2.y + "\n\tproj 2 w " + _wallProj2.Min + ":" + _wallProj2.Max + " g " + grenProj2.Min + ":" + grenProj2.Max + " overlap=" + Overlap(_wallProj2, grenProj2) + "\n\tpoint " + contactPoint.Point.x + ":" + contactPoint.Point.y + " dotV " + Vector2.Dot(P - contactPoint.Point, V) ); #endif // ignore colliders that are behind if (Vector2.Dot(position - contactPoint.Point, velocity) &gt;= 0.0f) continue; contactPoint.TravelDistance = velocity.magnitude * scaleV; _contactPoints.Add(ref contactPoint); collisions++; } return collisions; } private bool CheckBoxCollision(PrecomputedColliderData colliderData, int x, Vector2 position, Vector2 velocity) { _verticesV[0] = _vertices[0]; _verticesV[1] = _vertices[1]; _verticesV[2] = _vertices[1] + velocity; _verticesV[3] = _vertices[0] + velocity; // test projection to V var grenProj1V = ProjectCapsule(_Vunit, _verticesV, position, velocity); if (!Overlap(_wallProj1V, grenProj1V)) return false; // testing projection to VT would be redundant // test projection to wall axis 1 var grenProj1 = ProjectCapsule(colliderData.Axis1, _verticesV, position, velocity); if (!Overlap(_wallProj1, grenProj1)) return false; // test projection to wall axis 2 var grenProj2 = ProjectCapsule(colliderData.Axis2, _verticesV, position, velocity); if (!Overlap(_wallProj2, grenProj2)) return false; return true; } private int CollideWithCircles( GameState gs, Table&lt;CircleCollider&gt; colliderTable, Table&lt;Transform&gt; transformTable, uint id, Vector2 position, Vector2 velocity, GrenadeMovement grenade, Projection grenProj1V, Projection grenProj2V, CollisionLayer collisionLayers) { var settings = gs.RuleBook.GrenadeConfig[1]; var collisions = 0; foreach (var collider in colliderTable) { if ((int)collisionLayers != ~0) { var body = gs.WorldState.PhysicsDynamicBody[collider.Key]; if (body != null &amp;&amp; (body.CollisionLayer &amp; collisionLayers) == 0) continue; } var wall = collider.Value; var transform = transformTable[collider.Key]; // test projection to V _wallProj1V = ProjectCircle(_Vunit, transform.Position, wall.Radius); if (!Overlap(_wallProj1V, grenProj1V)) continue; // test projection to VT _wallProj2V = ProjectCircle(_VTunit, transform.Position, wall.Radius); if (!Overlap(_wallProj2V, grenProj2V)) continue; // test distance from the circle wall to semicircles on capsule ends var collisionDistance = (_r + wall.Radius) * (_r + wall.Radius); if ((position - transform.Position).sqrMagnitude &gt; collisionDistance) continue; var distSqr = (position + velocity - transform.Position).sqrMagnitude; if (distSqr &gt; collisionDistance) continue; var lowWall = wall.Height &lt; settings.TallWallHeight; if (lowWall) { // the wall is too far below, ignore it completely if (grenade.Height &gt; wall.Height + _r) continue; // if grenade if falling down, it can bounce off the top of the wall if (grenade.VerticalVelocity &lt; 0f) { if (grenade.Height &gt; wall.Height - _r) { #if DEBUG_GRENADES gs.Log.Debug("grenade #" + id + " falls on wall" + "\n\tP+V " + (Px + Vx) + ":" + (Py + Vy) + "\n\tdist " + Mathf.Sqrt(distSqr) + "\n\tH w " + wall.Height + " g " + grenade.Height ); #endif if (distSqr &lt; wall.Radius * wall.Radius) { grenade.Height = wall.Height + _r; grenade.VerticalVelocity = settings.WallRestitution * Math.Abs(grenade.VerticalVelocity); continue; } } } } // collision detected // try to find minimal V before collision var scaleV = CalcTranslationScaleBeforeCollision(CheckCircleCollision, transform.Position, wall, position, velocity); var contactPoint = CalcCircleContactPoint(transform.Position, wall, position); #if DEBUG_GRENADES gs.Log.Debug("collision grenade #" + id + " with circle #" + collider.Key + "\n\tP=" + Px + ":" + Py + "\n\tV=" + Vx + ":" + Vy + " scale=" + scaleV + "\n\tP+Vs=" + (Px + Vx * scaleV) + ":" + (Py + Vy * scaleV) + "\n\tcircle pos " + transform.Position.x + ":" + transform.Position.y + " r " + wall.Radius + "\n\tdist " + (transform.Position - (P + V * scaleV)).magnitude + "\n\tproj V w " + _wallProj1V.Min + ":" + _wallProj1V.Max + " g " + grenProj1V.Min + ":" + grenProj1V.Max + " overlap=" + Overlap(_wallProj1V, grenProj1V) + "\n\tproj VT w " + _wallProj2V.Min + ":" + _wallProj2V.Max + " g " + grenProj2V.Min + ":" + grenProj2V.Max + " overlap=" + Overlap(_wallProj2V, grenProj2V) + "\n\tpoint " + contactPoint.Point.x + ":" + contactPoint.Point.y + " dotV " + Vector2.Dot(P - contactPoint.Point, V) ); #endif // ignore colliders that are behind if (Vector2.Dot(position - contactPoint.Point, velocity) &gt;= 0.0f) continue; contactPoint.TravelDistance = velocity.magnitude * scaleV; _contactPoints.Add(ref contactPoint); collisions++; } return collisions; } private bool CheckCircleCollision(Vector2 wallCentre, CircleCollider wall, Vector2 position, Vector2 velocity) { _verticesV[0] = _vertices[0]; _verticesV[1] = _vertices[1]; _verticesV[2] = _vertices[1] + velocity; _verticesV[3] = _vertices[0] + velocity; // test projection to V var grenProj1V = ProjectCapsule(_Vunit, _verticesV, position, velocity); if (!Overlap(_wallProj1V, grenProj1V)) return false; // testing projection to VT would be redundant // test distance from the circle wall to the semicircle on the second capsule end var dSqr = (_r + wall.Radius) * (_r + wall.Radius); return (position + velocity - wallCentre).sqrMagnitude &lt; dSqr; } private static float CalcTranslationScaleBeforeCollision&lt;TData1, TData2&gt;( Func&lt;TData1, TData2, Vector2, Vector2, bool&gt; collision, TData1 colliderData1, TData2 colliderData2, Vector2 position, Vector2 vector) { var min = 0.0f; var max = 1.0f; while (true) { var d = (max - min) * 0.5f; if (d &lt; CollisionPrecision) break; var scale = min + d; if (collision(colliderData1, colliderData2, position, vector * scale)) { max = scale; } else { min = scale; } } return min; } private ContactPoint CalculateContactSuperposition() { ContactPoint contactSuperposition; _contactPoints.TryPopClosest(1000f, out contactSuperposition); ContactPoint contact; while (_contactPoints.TryPopClosest(contactSuperposition.TravelDistance, out contact)) { contactSuperposition.Normal += contact.Normal; } contactSuperposition.Normal = contactSuperposition.Normal.normalized; return contactSuperposition; } private static Projection ProjectPolygon(Vector2 axisNormalised, Vector2[] vertices) { Projection proj; var d = Vector2.Dot(axisNormalised, vertices[0]); proj.Min = d; proj.Max = d; for (var i = 1; i &lt; vertices.Length; i++) { d = Vector2.Dot(axisNormalised, vertices[i]); proj.Min = Mathf.Min(proj.Min, d); proj.Max = Mathf.Max(proj.Max, d); } return proj; } private Projection ProjectCapsule(Vector2 axisNormalised, Vector2[] vertices, Vector2 p, Vector2 v) { var proj = ProjectPolygon(axisNormalised, vertices); proj = AddCircleProjection(proj, axisNormalised, p, _r); proj = AddCircleProjection(proj, axisNormalised, p + v, _r); return proj; } private static Projection AddCircleProjection(Projection proj, Vector2 axisNormalised, Vector2 centre, float r) { var c = Vector2.Dot(axisNormalised, centre); proj.Min = Mathf.Min(proj.Min, c - r); proj.Max = Mathf.Max(proj.Max, c + r); return proj; } private static Projection ProjectCircle(Vector2 axisNormalised, Vector2 centre, float r) { Projection proj; var c = Vector2.Dot(axisNormalised, centre); proj.Min = c - r; proj.Max = c + r; return proj; } private static bool Overlap(Projection p1, Projection p2) { return p1.Min &lt; p2.Min ? p1.Max &gt; p2.Min : p2.Max &gt; p1.Min; } private static Vector2 WorldToBoxLocal(Vector2 wallCentre, PrecomputedColliderData colliderData, Vector2 position) { return new Vector2( Vector2.Dot(colliderData.Axis1, position) - Vector2.Dot(colliderData.Axis1, wallCentre), Vector2.Dot(colliderData.Axis2, position) - Vector2.Dot(colliderData.Axis2, wallCentre) ); } private static ContactPoint CalcBoxContactPoint(Vector2 wallCentre, BoxCollider wall, PrecomputedColliderData colliderData, Vector2 position) { var contactPoint = CaclBoxLocalContactPoint(wall.Size * 0.5f, WorldToBoxLocal(wallCentre, colliderData, position)); var worldAxisX = new Vector2(colliderData.Axis1.x, -colliderData.Axis1.y); var worldAxisY = new Vector2(colliderData.Axis1.y, colliderData.Axis1.x); contactPoint.Point = wallCentre + new Vector2(Vector2.Dot(worldAxisX, contactPoint.Point), Vector2.Dot(worldAxisY, contactPoint.Point)); contactPoint.Normal = new Vector2(Vector2.Dot(worldAxisX, contactPoint.Normal), Vector2.Dot(worldAxisY, contactPoint.Normal)); return contactPoint; } private static ContactPoint CaclBoxLocalContactPoint(Vector2 boxHalfSize, Vector2 localPosition) { ContactPoint localContactPoint = default(ContactPoint); // cases are numbered like numpad keys // 1, 2, 3 if (localPosition.y &lt; -boxHalfSize.y) { // 1 if (localPosition.x &lt; -boxHalfSize.x) { localContactPoint.Point = new Vector2(-boxHalfSize.x, -boxHalfSize.y); localContactPoint.Normal = new Vector2(-HalfSlope, -HalfSlope); } // 2, 3 else { // 3 if (localPosition.x &gt; boxHalfSize.x) { localContactPoint.Point = new Vector2(boxHalfSize.x, -boxHalfSize.y); localContactPoint.Normal = new Vector2(HalfSlope, -HalfSlope); } // 2 else { localContactPoint.Point = new Vector2(localPosition.x, -boxHalfSize.y); localContactPoint.Normal = new Vector2(0.0f, -1.0f); } } } // 4, 6, 7, 8, 9 else { // 7, 8, 9 if (localPosition.y &gt; boxHalfSize.y) { // 7 if (localPosition.x &lt; -boxHalfSize.x) { localContactPoint.Point = new Vector2(-boxHalfSize.x, boxHalfSize.y); localContactPoint.Normal = new Vector2(-HalfSlope, HalfSlope); } // 8, 9 else { // 9 if (localPosition.x &gt; boxHalfSize.x) { localContactPoint.Point = new Vector2(boxHalfSize.x, boxHalfSize.y); localContactPoint.Normal = new Vector2(HalfSlope, HalfSlope); } // 8 else { localContactPoint.Point = new Vector2(localPosition.x, boxHalfSize.y); localContactPoint.Normal = new Vector2(0.0f, 1.0f); } } } // 4, 6 else { // 4 if (localPosition.x &lt; -boxHalfSize.x) { localContactPoint.Point = new Vector2(-boxHalfSize.x, localPosition.y); localContactPoint.Normal = new Vector2(-1.0f, 0.0f); } // 6 else { localContactPoint.Point = new Vector2(boxHalfSize.x, localPosition.y); localContactPoint.Normal = new Vector2(1.0f, 0.0f); } } } return localContactPoint; } private static ContactPoint CalcCircleContactPoint(Vector2 wallCentre, CircleCollider wall, Vector2 position) { ContactPoint contactPoint = default(ContactPoint); contactPoint.Normal = (position - wallCentre).normalized; contactPoint.Point = wallCentre + wall.Radius * contactPoint.Normal; return contactPoint; } } }</span></span></code> </pre> <br></div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie haben Physik geschrieben. </font></font> Was weiter? </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Spiel lebt, entwickelt sich und im Laufe der Zeit wurde es f√ºr uns notwendig, irgendwie zu debuggen, was mit seiner physischen Engine auf dem Server passiert. </font><font style="vertical-align: inherit;">In einem der Artikel habe ich bereits das </font></font><a href="https://habr.com/ru/company/pixonic/blog/424267/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debuggen von ECS auf dem Server</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausf√ºhrlich beschrieben </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºr die Physik haben wir einen direkten visuellen Editor, der Daten aus JSON entnimmt, deren Struktur zusammen mit dem restlichen ECS-Layout generiert wird. </font><font style="vertical-align: inherit;">Dieser Editor sieht folgenderma√üen aus:</font></font><br><br><img src="https://habrastorage.org/webt/x6/wv/1w/x6wv1w0hkb13r4rflik9hvacnk0.png"><br><br> ,       ¬´¬ª.      ECS,       ,      .   ‚Äï  ‚Äï   , ,     ECS,        ECS   . ,    API,       ,      ,  .        ,                            . <br><br> -       2D-:        ,       . ,   :      ,      opensource    ,   -    .        ECS,     ,       .  ,             ,      .   -       ,    ,        .   ‚Äï    -  . <br><br>  -          ,   3D-,  ,                . <br><br>    , ,          ,      .     ,  ,      ECS      . <br><br><h4>  N√ºtzliche Links </h4><br>      : <br><br><ul><li> <a href="https://habr.com/ru/company/pixonic/blog/429312/">      </a> </li><li> <a href="https://habr.com/ru/company/pixonic/blog/415959/">      PvP :    </a> </li><li> <a href="https://habr.com/ru/company/pixonic/blog/413729/">      ECS</a> </li><li> <a href="https://habr.com/ru/company/pixonic/blog/424267/">      ECS   </a> </li></ul><br>   : <br><br><ul><li> <a href="https://www.youtube.com/watch%3Fv%3D7jb0FOcImdg">8 Frames in 16ms: Rollback Networking in Mortal Kombat and Injustice 2</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481880/">https://habr.com/ru/post/de481880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481860/index.html">Was soll die IT im Jahr 2020 tun?</a></li>
<li><a href="../de481862/index.html">Nvidia Jetson Embedded-Systeme f√ºr maschinelles Lernen</a></li>
<li><a href="../de481866/index.html">DBA: Wenn VACUUM vorbei ist, reinigen wir den Tisch manuell</a></li>
<li><a href="../de481868/index.html">Dagaz: Ein neuer Anfang</a></li>
<li><a href="../de481874/index.html">Metriken - Indikatoren f√ºr den Projektzustand</a></li>
<li><a href="../de481882/index.html">4. Fortinet Getting Started v6.0. Firewall-Richtlinien</a></li>
<li><a href="../de481884/index.html">Seniorenkreuzung: Wohin als n√§chstes?</a></li>
<li><a href="../de481886/index.html">So erstellen Sie schnell ein Anwesenheitsjournal</a></li>
<li><a href="../de481890/index.html">Import von deutschen Uranschw√§nzen nach Russland. Teil 2. Anreicherung</a></li>
<li><a href="../de481892/index.html">Qubits statt Bits: Welche Zukunft haben Quantencomputer f√ºr uns?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>