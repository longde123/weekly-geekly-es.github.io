<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌽 🍽️ 💀 Optimisation du rendu d'une scène du dessin animé Disney "Moana". Partie 1 👨🏼‍🎓 🧖🏻 🤚🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Walt Disney Animation Studios (WDAS) a récemment fait un cadeau inestimable à la communauté de la recherche sur le rendu en libérant une scène d'île c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Optimisation du rendu d'une scène du dessin animé Disney "Moana". Partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417407/">  Walt Disney Animation Studios (WDAS) a récemment fait un cadeau inestimable à la communauté de la recherche sur le rendu en libérant une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">scène d'île complète du dessin animé <em>Moana</em></a> .  La géométrie et les textures d'une image occupent plus de 70 Go d'espace disque.  C'est un formidable exemple du degré de complexité auquel les systèmes de rendu doivent faire face aujourd'hui;  Jamais auparavant les chercheurs et développeurs impliqués dans le rendu en dehors des studios de cinéma n'ont pu travailler avec des scènes aussi réalistes. <br><br>  Voici à quoi ressemble le résultat du rendu d'une scène avec pbrt moderne: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/729/ae6/97a/729ae697af18f30723b71a7168807a3f.jpg"></div><br>  <i>Une île de Moana rendue par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pbrt-v3</a> à une résolution de 2048x858 avec 256 échantillons par pixel.</i>  <i>Le temps de rendu total sur une instance 12 cœurs / 24 threads de Google Compute Engine avec une fréquence de 2 GHz avec la dernière version de pbrt-v3 était de 1 h 44 min 45 s.</i> <br><br>  De la part de Disney, c'était un travail énorme, elle a dû extraire la scène de son propre format interne et la convertir au format habituel;  Un grand merci à elle pour le temps consacré à l'emballage et à la préparation de ces données pour une utilisation généralisée.  Je suis sûr que leur travail sera bien récompensé à l'avenir car les chercheurs utilisent cette scène pour étudier les problèmes de rendu efficace de scènes de ce niveau de complexité. <br><a name="habracut"></a><br>  Cette scène m'a déjà beaucoup appris et m'a permis d'améliorer le rendu pbrt, mais avant de commencer, je vais raconter une courte histoire pour comprendre le contexte. <br><br><h2>  Le hachage qui n'était pas </h2><br>  Il y a de nombreuses années, lors d'un stage dans l'équipe de rendu Pixar, j'ai appris une curieuse leçon: des choses «intéressantes» apparaissent presque toujours lorsque les données d'entrée sont transmises au système de programme, ce qui est sensiblement différent de tout ce qui était auparavant.  Même dans des systèmes logiciels bien écrits et matures, de nouveaux types d'entrée conduisent presque toujours à la découverte de défauts inconnus dans une implémentation existante. <br><br>  J'ai d'abord appris cette leçon lors de la production de <em>Toy Story 2</em> .  Un jour, quelqu'un a remarqué qu'un temps incroyable a été consacré à l'analyse des fichiers de description de scène RIB.  Quelqu'un d'autre de l'équipe de rendu (je suppose que c'était Craig Kolb) a lancé le profileur et a commencé à le comprendre. <br><br>  Il s'est avéré que la majeure partie du temps d'analyse était occupée par des recherches dans la table de hachage utilisée pour l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">internement de chaînes</a> .  La table de hachage était plutôt petite, probablement 256 éléments, et lorsque plusieurs valeurs étaient hachées dans une cellule, elle organisait une chaîne.  Après la première implémentation de la table de hachage, beaucoup de temps s'est écoulé et il y avait maintenant des dizaines de milliers d'objets dans les scènes, donc une si petite table s'est rapidement remplie et est devenue inefficace. <br><br>  Il était très conseillé d'augmenter simplement la taille de la table - tout cela s'est produit à la hauteur du flux de travail, donc il n'y avait pas de temps pour une sorte de solution élégante, par exemple, augmenter la taille de la table lors du remplissage.  Nous effectuons un changement sur une seule ligne, reconstruisons l'application, effectuons un test rapide avant de valider et ... aucune amélioration de la vitesse ne se produit.  La recherche d'une table de hachage prend le même temps.  Génial! <br><br>  Après une étude plus approfondie, nous avons constaté que la fonction de table de hachage utilisée était similaire à la suivante: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br>  (Pardonnez-moi, Pixar, si je révèle votre code source RenderMan top secret.) <br><br>  La fonction de «hachage» a été mise en œuvre dans les années 80.  À ce moment-là, le programmeur a probablement considéré que le coût de calcul de la vérification de l'effet de tous les caractères de la chaîne sur la valeur de hachage serait trop élevé et n'en valait pas la peine.  (Je pense que s'il n'y avait que quelques objets et 256 éléments dans la table de hachage de la scène, cela suffisait.) <br><br>  Une autre implémentation obsolète a contribué: à partir du moment où Pixar a commencé à créer ses films, les noms des objets dans les scènes ont beaucoup augmenté, par exemple, «BuzzLightyear / LeftArm / Hand / IndexFinger / Knuckle2».  Cependant, une étape initiale du pipeline a utilisé un tampon de longueur fixe pour stocker les noms des objets et raccourci tous les noms longs, en ne conservant que la fin, et avec de la chance, a ajouté des points de suspension au début, indiquant clairement qu'une partie du nom a été perdue: "... year / LeftArm / Hand / IndexFinger / Knuckle2 ". <br><br>  Par la suite, tous les noms des objets que le moteur de rendu a vu avaient cette forme, la fonction de hachage les a tous hachés dans une seule pièce de mémoire en tant que «.», Et la table de hachage était en fait une grande liste chaînée.  Bon vieux temps.  Au moins, après l'avoir compris, nous avons rapidement corrigé cette erreur. <br><br><h2>  Une innovation intrigante </h2><br>  Cette leçon m'a été rappelée l'année dernière lorsque Heather Pritchet et Rasmus Tamstorf de WDAS m'ont contacté et m'ont demandé si je serais intéressé à vérifier la qualité possible du rendu de la scène de <em>Moana</em> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pbrt</a> <sup>1</sup> .  Naturellement, j'ai accepté.  J'étais heureux d'aider et je me demandais comment tout se passerait. <br><br>  L'optimiste naïf en moi espérait qu'il n'y aurait pas de grandes surprises - au final, la première version de pbrt est sortie il y a environ 15 ans, et beaucoup de gens ont utilisé et étudié son code pendant de nombreuses années.  Vous pouvez être sûr qu'il n'y aura pas d'interférence comme l'ancienne fonction de hachage de RenderMan, non? <br><br>  Bien sûr, la réponse était non.  (Et c'est pourquoi j'écris ceci et quelques autres articles.) Bien que j'étais un peu déçu que pbrt n'ait pas été parfait "prêt à l'emploi", mais je pense que mon expérience avec la scène <em>Moana a</em> été la première confirmation de la valeur de la publication de cette scène ;  pbrt est déjà devenu un meilleur système grâce au fait que j'ai compris comment gérer cette scène. <br><br><h3>  Premiers rendus </h3><br>  Après avoir accédé à la scène, je l'ai immédiatement téléchargé (cela a pris plusieurs heures avec ma connexion Internet à domicile) et l'ai déballé de tar, recevant 29 Go de fichiers pbrt et 38 Go de cartes de texture <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ptex</a> <sup>2</sup> .  J'ai essayé allègrement de rendre la scène sur mon système domestique (avec 16 Go de RAM et un processeur à 4 cœurs).  Après être retourné à l'ordinateur après un certain temps, j'ai vu qu'il était gelé, toute la RAM était pleine et pbrt essayait toujours de terminer l'analyse de la description de la scène.  Le système d'exploitation a cherché à faire face à la tâche en utilisant la mémoire virtuelle, mais cela semblait sans espoir.  Ayant battu le processus, j'ai dû attendre encore une minute avant que le système ne commence à réagir à mes actions. <br><br>  La prochaine tentative était une instance de Google Compute Engine, qui vous permet d'utiliser plus de RAM (120 Go) et plus de CPU (32 threads sur 16 CPU).  La bonne nouvelle était que pbrt a réussi à rendre la scène avec succès (grâce au travail de Heather et Rasmus pour la convertir au format pbrt).  C'était très excitant de voir que pbrt peut générer des pixels relativement bons pour un contenu de film de haute qualité, mais la vitesse s'est avérée pas si étonnante: 34 min 58 s uniquement pour analyser la description de la scène et pendant le rendu, le système a dépensé jusqu'à 70 Go de RAM. <br><br>  Oui, il y avait 29 gigaoctets de fichiers de description de scène au format pbrt sur le disque qui devaient être épargnés, donc je ne m'attendais pas à ce que la première étape prenne quelques secondes.  Mais passer une demi-heure avant même que les rayons commencent à tracer?  Cela complique grandement le travail avec la scène. <br><br>  D'un autre côté, cette vitesse nous a indiqué que quelque chose de très nauséabond se passait probablement dans le code;  pas seulement «l'inversion de matrice peut être effectuée 10% plus rapidement»;  plutôt, quelque chose au niveau de "oh, nous parcourons une liste chaînée de 100 mille éléments".  J'étais optimiste et j'espérais qu'après l'avoir compris, je pourrais accélérer considérablement le processus. <br><br><h3>  Les statistiques n'aident pas </h3><br>  Le premier endroit où j'ai commencé à chercher des indices était les statistiques de vidage de pbrt après le rendu.  Les principales étapes de l'exécution de pbrt sont configurées de sorte que vous puissiez collecter des données de profilage approximatives en corrigeant les opérations avec des interruptions périodiques pendant le processus de rendu.  Malheureusement, les statistiques ne nous ont pas beaucoup aidés: selon les rapports, près de 35 minutes avant le début du rendu, 4 minutes 22 secondes ont été consacrées à la construction du BVH, mais aucun détail n'a été fourni sur le reste du temps. <br><br>  La construction de BVH est la seule tâche de calcul importante effectuée pendant l'analyse de scène;  tout le reste est essentiellement une désérialisation de la géométrie et des descriptions de matériaux.  Connaître le temps passé à créer le BVH a permis de comprendre à quel point le système était (peu) efficace: le temps restant, à savoir environ 30 minutes, analysait 29 Go de données, c'est-à-dire que la vitesse était de 16,5 Mo / s.  Des analyseurs JSON bien optimisés, effectuant essentiellement la même tâche, fonctionnent à une vitesse de 50-200 Mo / s.  De toute évidence, il y a encore place à amélioration. <br><br>  Pour mieux comprendre le temps perdu, j'ai lancé pbrt avec un outil de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">perf</a> Linux que je n'avais jamais utilisé auparavant.  Mais, il semble, il a fait face à la tâche.  Je lui ai demandé de rechercher des caractères DWARF pour obtenir les noms des fonctions ( <code>--call-graph dwarf</code> ), et pour ne pas obtenir les fichiers de trace de 100 Go, j'ai dû réduire le taux d'échantillonnage de 4000 à 100 échantillons par seconde ( <code>-F 100</code> ).  Mais avec ces paramètres, tout s'est bien passé, et j'ai été agréablement surpris que l'outil de <code>perf report</code> performance ait une interface avec de belles malédictions. <br><br>  Voici ce qu'il a pu me dire après avoir commencé avec pbrt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9e/d31/643/a9ed31643e22b9c5d0566c7b210f4067.png"></div><br>  <i>Je ne plaisantais pas quand je parlais de "l'interface avec de belles malédictions".</i> <br><br>  Nous voyons que plus de la moitié du temps est consacré à l'analyse de la mécanique: <code>yyparse()</code> est le <code>yyparse()</code> généré par le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bison</a> , et <code>yylex()</code> est l'analyseur lexical (lexer) généré par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flex</a> .  Plus de la moitié du temps dans <code>yylex()</code> est consacré à <code>strtod()</code> , qui convertit les chaînes en valeurs doubles.  Nous <code>yyparse()</code> attaque sur <code>yyparse()</code> et <code>yylex()</code> jusqu'au troisième article de cette série, mais nous pouvons déjà comprendre que ce pourrait être une bonne idée de réduire la quantité de données jetées dans le moteur de rendu. <br><br><h3>  Du texte au PLY </h3><br>  Une façon de passer moins de temps à analyser les données de texte consiste à convertir les données dans un format analysé plus efficacement.  La plupart des 29 Go de ces fichiers de description de scène sont des maillages triangulaires, et pbrt a déjà un support natif pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le format PLY</a> , qui est une représentation binaire efficace des maillages polygonaux.  Dans pbrt, il existe également un indicateur de ligne de commande <code>--toply</code> , qui analyse le fichier de description de scène pbrt, convertit tous les maillages triangulaires trouvés en fichiers PLY et crée un nouveau fichier pbrt qui fait référence à ces fichiers PLY. <br><br>  Le hic, c'est que les textures <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ptex</a> sont activement utilisées dans la scène Disney, qui, à son tour, nécessite qu'une valeur <code>faceIndex</code> soit associée à chaque triangle, ce qui détermine de quelle face du sous-maillage d'origine il est tiré.  Pour transférer ces valeurs, il suffisait simplement d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ajouter la prise en charge de nouveaux champs dans le fichier PLY</a> .  Des recherches supplémentaires ont révélé que dans le cas de la conversion de chaque maillage - même s'il ne comporte qu'une douzaine de triangles - en un fichier PLY, des dizaines de milliers de petits fichiers PLY sont créés dans le dossier, ce qui crée ses propres problèmes de performances;  Nous avons réussi à nous débarrasser de ce problème en ajoutant à l'implémentation la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">possibilité de laisser les petites mailles inchangées</a> . <br><br>  J'ai écrit un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">petit script de ligne de commande</a> pour convertir tous les fichiers <code>*_geometry.pbrt</code> dans un dossier pour utiliser PLY pour les grands maillages.  Notez qu'il contient des hypothèses codées en dur sur les chemins qui doivent être modifiés pour que le script fonctionne ailleurs. <br><br><h3>  Premier boost de vitesse </h3><br>  Après avoir converti tous les grands maillages en PLY, la taille de la description de scène sur le disque est passée de 29 à 22 Go: 16,9 Go de fichiers de scène pbrt et 5,1 Go de fichiers binaires PLY.  Après la conversion, le temps total de la première étape du système a diminué à 27 minutes 35 secondes, et les économies se sont élevées à 7 minutes 23 secondes, c'est-à-dire que nous avons accéléré de 1,3 fois <sup>3</sup> .  Le traitement d'un fichier PLY est beaucoup plus efficace que le traitement d'un fichier texte pbrt: seulement 40 secondes de temps de démarrage ont été consacrées à l'analyse des fichiers PLY, et nous constatons que les fichiers PLY ont été traités à une vitesse d'environ 130 Mo / s, soit environ 8 fois plus vite que le format de texte pbrt . <br><br>  Ce fut une bonne victoire facile, mais nous avions encore beaucoup à faire. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La prochaine fois,</a> nous déterminerons où toute la mémoire est réellement utilisée, corrigons quelques erreurs ici et atteignons encore plus de vitesse dans le processus. <br><br><h2>  Remarques </h2><br><ol><li>  Vous devriez maintenant avoir une meilleure compréhension de la motivation pour ajouter le support ptex de ma part et convertir Disney BSDF en pbrt l'année dernière. </li><li>  Tout le temps ici et dans les articles suivants est indiqué pour la version WIP (Work In Progress), avec laquelle j'ai travaillé avant la sortie officielle.  Il semble que la version finale soit un peu plus grande.  Nous nous en tiendrons aux résultats que j'ai enregistrés en travaillant avec la scène originale, malgré le fait qu'ils ne correspondent pas tout à fait aux résultats de la version finale.  Je soupçonne que les leçons à en tirer peuvent être les mêmes. </li><li>  Notez que l'augmentation de la vitesse est essentiellement ce à quoi vous vous attendez avec une réduction d'environ 50% du volume des données d'analyse.  Le temps que nous passons selon le profileur confirme notre idée. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417407/">https://habr.com/ru/post/fr417407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417395/index.html">Tests de bout en bout: quoi, pourquoi, pourquoi</a></li>
<li><a href="../fr417397/index.html">Quel langage de programmation apprendre en 2018 et pourquoi?</a></li>
<li><a href="../fr417399/index.html">Bienvenue à bord: présentation de nouveaux développeurs à l'équipe</a></li>
<li><a href="../fr417401/index.html">Enfin, nous choisissons un multimètre économique avec de bonnes fonctionnalités</a></li>
<li><a href="../fr417405/index.html">Encodeurs automatiques et forte intelligence artificielle</a></li>
<li><a href="../fr417409/index.html">Comment survivre à ses coéquipiers dans une scram évolutive et maintenir le contrôle de la qualité du code</a></li>
<li><a href="../fr417411/index.html">Évaluez le développeur sur la base de données objectives</a></li>
<li><a href="../fr417413/index.html">Est-ce que les problèmes de chef d'équipe diffèrent à Saint-Pétersbourg, découvrez à Saint TeamLead Conf</a></li>
<li><a href="../fr417415/index.html">Cours d'impression 3D. Impression de pièces avec différentes épaisseurs de couche à partir de 3Dtool</a></li>
<li><a href="../fr417419/index.html">[Iekaterinbourg, annonce] Alice en visite à Kontur - hackathon pour créer des compétences pour les assistants vocaux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>