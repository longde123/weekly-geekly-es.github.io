<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🏫 👩🏿‍🤝‍👨🏽 🚃 PostgreSQL Antipatterns: hit hit on heavy JOIN 🐡 👃🏾 🉑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous continuons une série d'articles consacrés à l'étude de moyens peu connus d'améliorer les performances des requêtes PostgreSQL "apparemment simple...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PostgreSQL Antipatterns: hit hit on heavy JOIN</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485398/">  Nous continuons une série d'articles consacrés à l'étude de moyens peu connus d'améliorer les performances des requêtes PostgreSQL "apparemment simples": <br><br><ul><li>  <a href="https://habr.com/post/484670/">record rare atteindra le milieu de JOIN</a> </li><li>  <a href="https://habr.com/post/479920/">sisyphus rejoindre des tableaux</a> </li><li>  <a href="https://habr.com/post/479508/">JOIN et OR nuisibles</a> </li><li>  <a href="https://habr.com/post/479298/">CTE REJOIGNEZ CTE</a> </li></ul><br>  Ne pensez pas que je n'aime pas tellement JOIN ... :) <br><br>  Mais souvent sans elle, la demande est nettement plus productive qu'avec lui.  Par conséquent, aujourd'hui, nous essaierons de <b>nous débarrasser</b> complètement <b>du JOIN gourmand en ressources</b> - à l'aide d'un dictionnaire. <br><br><img src="https://habrastorage.org/webt/uf/33/uh/uf33uhbf3ke85rlwi6o-nhaygdw.png"><br><a name="habracut"></a><br><blockquote> À partir de PostgreSQL 12, certaines des situations décrites ci-dessous peuvent être lues un peu différemment en raison de la <a href="https://www.depesz.com/2019/02/19/waiting-for-postgresql-12-allow-user-control-of-cte-materialization-and-change-the-default-behavior/" rel="nofollow">non-matérialisation de CTE par défaut</a> .  Ce comportement peut être inversé à l'aide de la clé <code>MATERIALIZED</code> . </blockquote><br><h2>  Beaucoup de "faits" sur un vocabulaire limité </h2><br>  Prenons une application très réelle - vous devez répertorier <a href="https://habr.com/ru/post/483176/">les messages entrants</a> ou les tâches actives avec les expéditeurs: <br><br><pre> <code class="plaintext hljs">25.01 |  .. |    . 22.01 |  .. |    :   JOIN. 20.01 |  .. |   . 18.01 |  .. |    : JOIN    . 16.01 |  .. |   .</code> </pre><br>  Dans le monde abstrait, les auteurs de tâches devraient être répartis également entre tous les employés de notre organisation, mais en réalité, les <b><i>tâches proviennent, en règle générale, d'un nombre assez limité de personnes</i></b> - «des supérieurs hiérarchiques» ou «des alliés» des départements voisins (analystes, concepteurs marketing ...). <br><br>  Supposons que dans notre organisation de 1000 personnes, seulement 20 auteurs (généralement encore moins) définissent des tâches pour chaque artiste spécifique et <a href="https://habr.com/ru/post/484670/">utilisent cette connaissance du sujet</a> pour accélérer la demande «traditionnelle». <br><br><div class="spoiler">  <b class="spoiler_title">Générateur de scripts</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  CREATE TABLE person AS SELECT id , repeat(chr(ascii('a') + (id % 26)), (id % 32) + 1) "name" , '2000-01-01'::date - (random() * 1e4)::integer birth_date FROM generate_series(1, 1000) id; ALTER TABLE person ADD PRIMARY KEY(id); --     CREATE TABLE task AS WITH aid AS ( SELECT id , array_agg((random() * 999)::integer + 1) aids FROM generate_series(1, 1000) id , generate_series(1, 20) GROUP BY 1 ) SELECT * FROM ( SELECT id , '2020-01-01'::date - (random() * 1e3)::integer task_date , (random() * 999)::integer + 1 owner_id FROM generate_series(1, 100000) id ) T , LATERAL( SELECT aids[(random() * (array_length(aids, 1) - 1))::integer + 1] author_id FROM aid WHERE id = T.owner_id LIMIT 1 ) a; ALTER TABLE task ADD PRIMARY KEY(id); CREATE INDEX ON task(owner_id, task_date); CREATE INDEX ON task(author_id);</span></span></code> </pre></div></div><br>  Nous montrons les 100 dernières tâches pour un artiste spécifique: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> task.* , person.name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> task <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> person <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> person.id = task.author_id <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> owner_id = <span class="hljs-number"><span class="hljs-number">777</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> task_date <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br><img src="https://habrastorage.org/webt/gt/qo/ba/gtqoba5xxrim1xd0ec98ezjuuxi.png"><br>  <a href="https://explain.tensor.ru/archive/explain/5f4f9c25197bf7c534ffe7a25b1b75a6:0:2020-01-27" rel="nofollow">[regardez expliquez.tensor.ru]</a> <br><br>  Il s'avère que <b>1/3 du temps entier et 3/4 des lectures des</b> pages de données ont été faites uniquement afin de rechercher l'auteur 100 fois - pour chaque tâche affichée.  Mais nous savons que parmi cette centaine, il n'y en a <b>que 20 différents</b> - est-il possible d'utiliser ces connaissances? <br><br><h2>  dictionnaire hstore </h2><br>  Nous utilisons <a href="https://postgrespro.ru/docs/postgresql/12/hstore" rel="nofollow">le type hstore</a> pour générer un "dictionnaire" de valeurs-clés: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> EXTENSION hstore</code> </pre> <br>  Il nous suffit de mettre l'ID de l'auteur et son nom dans le dictionnaire, pour que plus tard nous puissions extraire à l'aide de cette clé: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--    WITH T AS ( SELECT * FROM task WHERE owner_id = 777 ORDER BY task_date DESC LIMIT 100 ) --      , dict AS ( SELECT hstore( -- hstore(keys::text[], values::text[]) array_agg(id)::text[] , array_agg(name)::text[] ) FROM person WHERE id = ANY(ARRAY( SELECT DISTINCT author_id FROM T )) ) --     SELECT * , (TABLE dict) -&gt; author_id::text -- hstore -&gt; key FROM T;</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/vn/2f/ms/vn2fms1aupegpmtrwwh7l3dekoo.png"><br>  <a href="https://explain.tensor.ru/archive/explain/6ee4e4e26ded9567ac9631ceee9bb8c0:0:2020-01-27" rel="nofollow">[regardez expliquez.tensor.ru]</a> <br><br>  Il a fallu <b>2 fois moins de temps pour</b> obtenir des informations sur les personnes <b>et 7 fois moins de données lues</b> !  En plus de la «tromperie», ces résultats nous ont aidés à réaliser l' <b>extraction de masse des enregistrements</b> de la table en un seul passage en utilisant <code>= ANY(ARRAY(...))</code> . <br><br><h4>  Entrées de table: sérialisation et désérialisation </h4><br>  Mais que se passe-t-il si nous devons enregistrer dans le dictionnaire non pas un champ de texte, mais un enregistrement entier?  Dans ce cas, la capacité de PostgreSQL <b>à travailler avec l'écriture d'une table en tant que valeur unique</b> nous aidera: <br><br><pre> <code class="sql hljs">... , dict AS ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> hstore( array_agg(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>[] , array_agg(p)::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>[] <span class="hljs-comment"><span class="hljs-comment">--  #1 ) FROM person p WHERE ... ) SELECT * , (((TABLE dict) -&gt; author_id::text)::person).* --  #2 FROM T;</span></span></code> </pre> <br>  Voyons ce qui s'est passé ici: <br><br><ol><li>  Nous avons pris <b>p comme alias pour l'enregistrement complet de la table person</b> et assemblé un tableau à partir d'eux. </li><li>  Ce <b>tableau d'entrées a été refondu</b> en un tableau de chaînes de texte (person [] :: text []) pour le placer dans le dictionnaire hstore en tant que tableau de valeurs. </li><li>  Lors de la réception de l'enregistrement lié, nous l'avons <b>retiré du dictionnaire par clé</b> sous forme de chaîne de texte. </li><li>  Nous devons <b>transformer le</b> texte <b>en valeur du type de la table</b> personne (pour chaque table, le type du même nom est automatiquement créé). </li><li>  «Déployé» un enregistrement tapé dans des colonnes à l'aide de <code>(...).*</code> . </li></ol><br><h2>  dictionnaire json </h2><br>  Mais une telle astuce, comme nous l'avons appliqué ci-dessus, ne fonctionnera pas s'il n'y a pas de type de table correspondant pour faire un "détachement".  Exactement, la même situation se produira et si, en tant que source de données pour la sérialisation, nous essayons d'utiliser la <b>ligne CTE, et non la «vraie» table</b> . <br><br>  Dans ce cas, les <a href="https://postgrespro.ru/docs/postgresql/12/functions-json" rel="nofollow">fonctions de travail avec json</a> nous aideront à: <br><br><pre> <code class="sql hljs">... , p AS ( <span class="hljs-comment"><span class="hljs-comment">--   CTE SELECT * FROM person WHERE ... ) , dict AS ( SELECT json_object( --    json array_agg(id)::text[] , array_agg(row_to_json(p))::text[] --   json    ) FROM p ) SELECT * FROM T , LATERAL( SELECT * FROM json_to_record( ((TABLE dict) -&gt;&gt; author_id::text)::json --     json ) AS j(name text, birth_date date) --     ) j;</span></span></code> </pre> <br>  Il convient de noter que lors de la description de la structure cible, nous ne pouvons pas répertorier tous les champs de la chaîne source, mais uniquement ceux dont nous avons vraiment besoin.  Si nous avons une table "native", alors il vaut mieux utiliser la fonction <code>json_populate_record</code> . <br><br>  Nous avons toujours accès au dictionnaire une fois, mais les <b>coûts de sérialisation json- [de] sont assez élevés</b> , il est donc raisonnable de n'utiliser cette méthode que dans certains cas lorsque le scan CTE «honnête» se montre pire. <br><br><h2>  Test des performances </h2><br>  Nous avons donc deux façons de sérialiser les données dans un dictionnaire - <b>hstore / json_object</b> .  De plus, les tableaux de clés et de valeurs peuvent également être générés de deux manières, avec une conversion interne ou externe en texte: <b>array_agg (i :: text) / array_agg (i) :: text []</b> . <br><br>  Vérifions l'efficacité de différents types de sérialisation à l'aide d'un exemple purement synthétique - nous <b>sérialisons un nombre différent de clés</b> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> dict <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> hstore( array_agg(i::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) , array_agg(i::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, ...) i ) <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dict;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Script d'évaluation: sérialisation</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> regexp_replace(ea[array_length(ea, <span class="hljs-number"><span class="hljs-number">1</span></span>)], <span class="hljs-string"><span class="hljs-string">'^Execution Time: (\d+\.\d+) ms$'</span></span>, <span class="hljs-string"><span class="hljs-string">'\1'</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">real</span></span> et <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> array_agg(el) ea <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dblink(<span class="hljs-string"><span class="hljs-string">'port= '</span></span> || current_setting(<span class="hljs-string"><span class="hljs-string">'port'</span></span>) || <span class="hljs-string"><span class="hljs-string">' dbname='</span></span> || current_database(), $$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> dict <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> hstore( array_agg(i::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) , array_agg(i::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, $$ || (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; v) || $$) i ) <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dict $$) T(el <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) ) T ) et <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>) v , LATERAL generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) i <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> v , <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(et)::<span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> </div></div><br><img src="https://habrastorage.org/webt/le/ho/tk/lehotkorqfxuassbuqsrcexjh6k.png"><br><br>  Sur PostgreSQL 11, jusqu'à une taille de dictionnaire d'environ 2 ^ 12 clés, la <b>sérialisation en json prend moins de temps</b> .  La combinaison de json_object et de la conversion de type "interne" de <code>array_agg(i::text)</code> est la plus efficace. <br><br>  Essayons maintenant de lire la valeur de chaque clé 8 fois - car si vous n'accédez pas au dictionnaire, pourquoi est-il nécessaire? <br><br><div class="spoiler">  <b class="spoiler_title">Script d'évaluation: lecture à partir d'un dictionnaire</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * , ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> regexp_replace(ea[array_length(ea, <span class="hljs-number"><span class="hljs-number">1</span></span>)], <span class="hljs-string"><span class="hljs-string">'^Execution Time: (\d+\.\d+) ms$'</span></span>, <span class="hljs-string"><span class="hljs-string">'\1'</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">real</span></span> et <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> array_agg(el) ea <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dblink(<span class="hljs-string"><span class="hljs-string">'port= '</span></span> || current_setting(<span class="hljs-string"><span class="hljs-string">'port'</span></span>) || <span class="hljs-string"><span class="hljs-string">' dbname='</span></span> || current_database(), $$ <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> dict <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> json_object( array_agg(i::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) , array_agg(i::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, $$ || (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; v) || $$) i ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dict) -&gt; (i % ($$ || (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; v) || $$) + <span class="hljs-number"><span class="hljs-number">1</span></span>)::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, $$ || (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (v + <span class="hljs-number"><span class="hljs-number">3</span></span>)) || $$) i $$) T(el <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) ) T ) et <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>) v , LATERAL generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>) i <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> v , <span class="hljs-keyword"><span class="hljs-keyword">avg</span></span>(et)::<span class="hljs-built_in"><span class="hljs-built_in">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> </div></div><br><img src="https://habrastorage.org/webt/et/fq/vj/etfqvjlzj4qy4rjqwskzteg36aw.png"><br><br>  Et ... déjà à environ <b>2 ^ 6 touches, la lecture du dictionnaire json commence à perdre à la</b> lecture de hstore plusieurs fois, pour jsonb la même chose se produit à 2 ^ 9. <br><blockquote>  Conclusions finales: <br><br><ul><li>  si vous avez besoin de faire un <b>JOIN avec des enregistrements répétés à plusieurs reprises</b> - il est préférable d'utiliser la "correspondance de table" </li><li>  si votre dictionnaire est <b>petit et que vous en lirez un peu</b> , vous pouvez utiliser json [b] </li><li>  dans tous les autres cas, <b>hstore + array_agg (i :: text)</b> sera plus efficace </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485398/">https://habr.com/ru/post/fr485398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485388/index.html">Règle, souffre, souris</a></li>
<li><a href="../fr485390/index.html">Concours de micro-subventions open source pour des projets de données ouvertes</a></li>
<li><a href="../fr485392/index.html">Bot télégramme qui surveille le domaine</a></li>
<li><a href="../fr485394/index.html">Comment est née l'infrastructure Internet</a></li>
<li><a href="../fr485396/index.html">Bilan de santé de l'effectif: mesurer la santé de l'équipe</a></li>
<li><a href="../fr485404/index.html">Nous réalisons l'effet visuel du film "The Matrix"</a></li>
<li><a href="../fr485416/index.html">Des moyens pratiques pour cartographier les données dans Kotlin</a></li>
<li><a href="../fr485418/index.html">PHPUnit. "Comment puis-je tester mon putain de contrôleur", ou tester les sceptiques</a></li>
<li><a href="../fr485424/index.html">Comment j'enseigne aux enfants Python</a></li>
<li><a href="../fr485426/index.html">Voitures aux Pays-Bas: statistiques et informations pour 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>