<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßê üë®‚Äçüé® üåà Herstellung eines Metalldetektors auf ATtiny24A ü•ù ü§òüèº üîç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe lange Zeit mit Arduino-√§hnlichen Boards gespielt, aber die ganze Zeit wollte ich "weniger, billiger und n√§her an der Hardware!". Und hier ist...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Herstellung eines Metalldetektors auf ATtiny24A</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/383819/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe lange Zeit mit Arduino-√§hnlichen Boards gespielt, aber die ganze Zeit wollte ich "weniger, billiger und n√§her an der Hardware!". Und hier ist die erste Erfahrung mit der Programmierung von reinem ATtiny. </font><font style="vertical-align: inherit;">Der Artikel wird keine besonders effektive Metalldetektorschaltung sein. </font><font style="vertical-align: inherit;">Dies ist nur eine Demonstration dessen, wozu der Mikrocontroller f√ºr 47 Cent + den Weg des Kessels in der Lage ist. Wie sich herausstellte, ist es keineswegs kompliziert, von Arduino auf eine niedrigere Ebene zu wechseln.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eisenauswahl</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach einer kurzen Analyse fiel die Wahl auf die ATtiny24A-SSU (14-poliges SOIC-Paket). Warum? Der Grund ist einfach: Preis + AVR-Kern. Ja, ich wei√ü, dass ein noch leistungsst√§rkerer STM8S103F3P6 billiger ist ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">39,5 Cent pro St√ºck</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gegen√ºber </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">47 f√ºr ATtiny</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), aber da ich einige Erfahrungen mit AVR in Arduino habe, wollte ich AVR f√ºr die ersten Experimente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus den verf√ºgbaren AVRs w√§hlen wir ATtiny als das billigste aus, und dann m√∂chte ich, dass das DIP-Paket einfacher zu l√∂ten ist. Die Chips im DIP-Paket erwiesen sich jedoch als viel teurer ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">54 Cent f√ºr den 8-Fu√ü-ATtiny13A</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14-Fu√ü-ATtiny23A im DIP-Paket sind 95 Cent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ich mag die Idee, den ATtiny13A wegen seines Oktopus zu verwenden, nicht. 6 Beine werden vom Programmierer besetzt und nur 2 bleiben frei, was klein ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurde beschlossen, ATtiny24A-SSU f√ºr 47 Cent und einen weiteren </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adapter f√ºr 30 Cent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu kaufen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Insgesamt erhalten wir 77 Cent pro Ger√§t gegen√ºber 95 Cent f√ºr ein DIP-Paket. Als Bonus verwenden wir bei einfachen Ger√§ten einen Adapter als Platine mit L√∂tdr√§hten direkt daran, was mit einem DIP-Paket unm√∂glich w√§re. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Programmierer wird nach dem gleichen Prinzip (dem billigsten) ausgew√§hlt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USBasp f√ºr 1,86 USD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist eingetroffen!</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich muss sofort sagen, dass ich noch nie zuvor ein SOIC-Geh√§use gel√∂tet habe, daher gab es einige Bef√ºrchtungen, dass es nicht funktionieren w√ºrde ... Es stellte sich als nicht schwierig heraus, nicht einfach ... im Allgemeinen musste ich einige Anstrengungen unternehmen, aber am Ende stellte sich heraus! </font><font style="vertical-align: inherit;">Es schien ratsam, sich nicht durch eine Schlussfolgerung aufzuw√§rmen, sondern sofort durch Gruppen - dieser Weg ist schneller und einfacher.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/78b/4f2/1e9/78b4f21e967344348ffb2130de618ff5.JPG" alt="Bild"></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie programmiere ich?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ATtiny24A wird standardm√§√üig vom internen Generator getaktet und arbeitet mit einer Frequenz von 1 MHz. Nun, lass es funktionieren, es passt perfekt zu mir. Aber damit USBasp mit einer solchen Frequenz mit ihm arbeiten konnte, musste er einen zus√§tzlichen Jumper l√∂ten (Postings auf dem Foto): Es gab einen </font><font style="vertical-align: inherit;">
Platz auf der Platine, aber die Chinesen machten sich nicht die M√ºhe, den Jumper zu l√∂ten ... sie mussten es f√ºr sie tun. </font><font style="vertical-align: inherit;">
In Bezug auf die Entwicklungsumgebung fiel die Wahl auf Atmel Studio, aber es unterst√ºtzt unser USBasp nicht ... aber es spielt keine Rolle! Selbst bei der Auswahl eines Programmierger√§ts war geplant, ein Upgrade auf AVR-Doper durchzuf√ºhren, das mit dem STK500 kompatibel ist, was bedeutet, dass es von unserem Atmel Studio unterst√ºtzt wird. Im Allgemeinen habe ich es viele Male mit einer anderen Firmware geflasht, aber Atmel Studio wollte es nicht sehen ... Traurigkeit ... am Ende war ich verzweifelt, habe es zur√ºck auf USBasp geflasht und es per </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Tool gemacht</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/2ed/bc9/af0/2edbc9af064a4278a47cd7e78c724f00.JPG" alt="Bild"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach gelang es mir, mein ATtiny zu blinken, eine LED zu blinken und zu genie√üen, wie wenig Flash-Speicher im Vergleich zu Arduino ben√∂tigt wurde.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metalldetektor</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst als ich mich mit Arduino besch√§ftigte, baute ich einen Metalldetektor nach dem Prinzip der Resonanzst√∂rung. Die Empfindlichkeit ist schrecklich, aber das Funktionsprinzip ist sehr einfach und auf jedem MK leicht zu implementieren. Ein rechteckiges Signal wird √ºber einen Widerstand mit der Resonanzfrequenz dieser Schaltung an einen parallelen Schwingkreis angelegt. Wenn ein Metallgegenstand in das Magnetfeld der Spule eintritt, nimmt der Qualit√§tsfaktor der Schaltung ab, die vom ADC gemessene Signalamplitude nimmt ab, das Ger√§t gef√§llt uns optisch und akustisch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Detektor verf√ºgt √ºber zwei Modi: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Suchen Sie nach der Resonanz des Schaltkreises. Gleichzeitig sendet es rechteckige Signale mit unterschiedlichen Frequenzen an die Schaltung und merkt sich die Frequenz, bei der die Schwingungsamplitude am gr√∂√üten ist (wir erinnern uns auch an diese gr√∂√üte Amplitude).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Die Betriebsart. </font><font style="vertical-align: inherit;">Wir senden ein Signal mit einer Resonanzfrequenz an die Schaltung und vergleichen die Amplitude mit dem Maximum, das im ersten Modus war. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompliziert? </font><font style="vertical-align: inherit;">- Nein! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sollte ich viel Speicherplatz beanspruchen? </font><font style="vertical-align: inherit;">- Nein! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haben wir viel Speicher (2 KB Flash + 128 Byte RAM)? </font><font style="vertical-align: inherit;">- Auch nicht! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passt es hinein? </font><font style="vertical-align: inherit;">Versuchen wir es - wir werden es herausfinden! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Ergebnis fit.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Haupt-Firmware-Code</font></font></b><div class="spoiler_text"><pre>#include &lt;avr/io.h&gt;<font></font>
#include &lt;avr/interrupt.h&gt;<font></font>
#include "mySerial.cpp"<font></font>
<font></font>
MySerial ms(&amp;PORTB, &amp;PINB, &amp;DDRB, 0, &amp;PORTB, &amp;PINB, &amp;DDRB, 1);<font></font>
<font></font>
volatile uint16_t maxAdc = 0; //    (    )<font></font>
volatile uint8_t dispMode = 0; // 0 -  , 1 -  <font></font>
volatile uint8_t flags0 = 0; // [0] - need setRes<font></font>
volatile uint16_t adcSource = 0;<font></font>
//volatile bool needADC = false;<font></font>
#define ADC_SOURCE_ARRAY_SIZE_POWER 5<font></font>
#define ADC_SOURCE_ARRAY_SIZE (1 &lt;&lt; ADC_SOURCE_ARRAY_SIZE_POWER)<font></font>
uint16_t adcSourceArray[ADC_SOURCE_ARRAY_SIZE];<font></font>
uint8_t adcSourceArrayLastWrited = 0;<font></font>
void showVal(void);<font></font>
<font></font>
ISR(ADC_vect){<font></font>
	//adcSourceArrayLastWrited++;<font></font>
	if(++adcSourceArrayLastWrited &gt;= ADC_SOURCE_ARRAY_SIZE)<font></font>
		adcSourceArrayLastWrited = 0;<font></font>
	adcSourceArray[adcSourceArrayLastWrited] = ADCL | (ADCH &lt;&lt; 8);<font></font>
	uint16_t adcSourceTmp = 0;<font></font>
	for(uint8_t i = 0; i &lt; ADC_SOURCE_ARRAY_SIZE; i++)<font></font>
		adcSourceTmp += adcSourceArray[adcSourceArrayLastWrited];<font></font>
	adcSource = (adcSourceTmp &gt;&gt; ADC_SOURCE_ARRAY_SIZE_POWER);<font></font>
	//adcSource = ADCL | (ADCH &lt;&lt; 8);<font></font>
	//needADC = false;<font></font>
}<font></font>
<font></font>
volatile uint8_t pinaChanged = 0;<font></font>
volatile uint8_t tim0_ovf_counter = 0;<font></font>
//uint32_t ticks = 0;<font></font>
volatile uint16_t ticks10ms = 0;<font></font>
//volatile uint16_t ticks = 0;<font></font>
ISR(TIM0_OVF_vect)<font></font>
{		<font></font>
	//ticks++;<font></font>
	//if(255 == tim0_ovf_counter++){ // ticks every 65.5 ms<font></font>
	if(39 == (tim0_ovf_counter++)){ // ticks every 10 ms<font></font>
		tim0_ovf_counter = 0;<font></font>
		ticks10ms++;<font></font>
		if(pinaChanged &gt; 0)<font></font>
			pinaChanged--;<font></font>
	}<font></font>
}<font></font>
<font></font>
uint16_t dist16(uint16_t lo, uint16_t hi){<font></font>
	return (lo &lt;= hi) ? (hi - lo) : (0xFFFF - lo + hi);<font></font>
}<font></font>
/*void delayTicks(uint16_t val){<font></font>
	uint16_t tim0_ovf_counter0 = tim0_ovf_counter;<font></font>
	while(dist16(tim0_ovf_counter0, tim0_ovf_counter) &lt; val)<font></font>
		showVal();<font></font>
}*/<font></font>
void delay10ms(uint16_t val){<font></font>
	uint16_t ticks10ms0 = ticks10ms;<font></font>
	while(dist16(ticks10ms0, ticks10ms) &lt; val)<font></font>
		showVal();<font></font>
}<font></font>
<font></font>
void showVal(void){<font></font>
	ms.sendByte(adcSource &gt;&gt; 2);<font></font>
	switch(dispMode){<font></font>
		case 0:<font></font>
			OCR0A = adcSource &gt;&gt; 2;<font></font>
		break;<font></font>
		case 1:<font></font>
			uint16_t maxAdcPlus = maxAdc + 2;<font></font>
			uint16_t dispVal = (maxAdcPlus &gt; adcSource) ? ((maxAdcPlus - adcSource)) : 0;<font></font>
			dispVal &lt;&lt;= 4;<font></font>
			if(dispVal &gt; 255)<font></font>
				dispVal = 255;<font></font>
			OCR0A = dispVal;<font></font>
		break;<font></font>
	}<font></font>
}<font></font>
<font></font>
void setRes(void)<font></font>
{<font></font>
	dispMode = 0;<font></font>
	uint16_t maxOCR = 0;<font></font>
	maxAdc = 0;<font></font>
	for(uint16_t curOCR = 35; curOCR &lt; 50; curOCR++){<font></font>
		OCR1A = curOCR;<font></font>
		OCR1B = (curOCR &gt;&gt; 1);<font></font>
		//uint32_t ticks0 = ticks;<font></font>
		//uint16_t ticks0 = ticks;		<font></font>
		//while(dist16(ticks0, ticks) &lt; 20)<font></font>
		//	showVal();<font></font>
		delay10ms(30);<font></font>
		if(adcSource &gt; maxAdc){<font></font>
			maxAdc = adcSource;<font></font>
			maxOCR = curOCR;<font></font>
		}<font></font>
	}<font></font>
	OCR1A = maxOCR;<font></font>
	OCR1B = (maxOCR &gt;&gt; 1);<font></font>
	dispMode = 1;<font></font>
}<font></font>
<font></font>
ISR(PCINT0_vect)<font></font>
{	<font></font>
	if(pinaChanged &gt; 0)<font></font>
		return;<font></font>
	pinaChanged = 5;<font></font>
	if(0 == (PINA &amp; (1 &lt;&lt; 7)))<font></font>
		flags0 |= 1;<font></font>
}<font></font>
<font></font>
<font></font>
int main(void)<font></font>
{<font></font>
	// init PWM:<font></font>
	DDRB |= 4;  // OC0A as output<font></font>
	//TIMSK0 |= 7; //  TIM0_OVF_vect, TIM0_COMPA_vect, TIM0_COMPB_vect<font></font>
	TIMSK0 |= 1; //  TIM0_OVF_vect<font></font>
	TCCR0B |= 1; // no prescaling. OVF  256  (3.91 )<font></font>
	//TCCR0B |= 2; // clk/8<font></font>
	//TCCR0B |= 3; // clk/64<font></font>
	//TCCR0B |= 5; // clk/1024. OVF  262  (3.815 )<font></font>
	TCCR0A |= (3 | (1 &lt;&lt; 7)); //WGM0[2:0] = 3 - fawt PWM mode. bit7 -  <font></font>
	//OCR0A = 150;<font></font>
	//OCR0B = 100;<font></font>
	// :init PWM<font></font>
	<font></font>
	// init ADC:<font></font>
	//ADMUX |= (1 &lt;&lt; 7); // internal 1.1V reference. Comment this to use VCC as reference<font></font>
	//ADMUX |= (1 &lt;&lt; 3) | 1; // MUX[5:0] = 001001. Res = ADC0 - ADC1. Gain = 20<font></font>
	ADMUX |= (1 &lt;&lt; 3); // MUX[5:0] = 001000. Res = ADC0 - ADC1. Gain = 1<font></font>
	ADCSRA |= ((1 &lt;&lt; 7) // enable ADC<font></font>
		| (1 &lt;&lt; 5) // ADC Auto Trigger Enable.  <font></font>
		| (1 &lt;&lt; 6) //  1 <font></font>
		| (1 &lt;&lt; 3)   // ADC interrupt enable<font></font>
		| (1 &lt;&lt; 2)); // prescaller = 16 ( 50-200 kHz)<font></font>
	// :init ADC<font></font>
	<font></font>
	// init 16-bit timer: // pin7 = MOSI = PA6 = OC1A<font></font>
	//DDRA |= (1 &lt;&lt; 6); // OC1A as output<font></font>
	DDRA |= (1 &lt;&lt; 5); // OC1B as output<font></font>
	//TCCR1A |= (1 &lt;&lt; 6); // Toggle OC1A/OC1B on Compare Match<font></font>
	TCCR1A |= (1 &lt;&lt; 5) // Clear OC1B on Compare Match, set OC1B at BOTTOM (non-inverting mode)<font></font>
		| (3); // set WGM10 and WGM11 // WGM1[3:0] = 1111 - Fast PWM, TOP = OCR1A.	<font></font>
//	TCCR1A |= (1 &lt;&lt; 6) | (1 &lt;&lt; 7) // Set OC1A on Compare Match (Set output to high level).<font></font>
//			| (1 &lt;&lt; 5); // Clear OC1B on Compare Match	(Set output to low level)<font></font>
	TCCR1B |= 1 // no prescalling<font></font>
			| (1 &lt;&lt; 3) | (1 &lt;&lt; 4); // set WGM12 and WGM13<font></font>
	//TIMSK1 |= (1 &lt;&lt; 2) | (1 &lt;&lt; 1) | 1; // enable all interrupts<font></font>
	OCR1B = 21;<font></font>
	OCR1A = 42;<font></font>
	//for(;;){;};<font></font>
	// :init 16-bit timer<font></font>
	<font></font>
	// init button:<font></font>
	PORTA |= (1 &lt;&lt; 7); //     6- . PA7 = PCINT7<font></font>
	GIMSK |= (1 &lt;&lt; 4); // Pin Change Interrupt Enable 0<font></font>
	PCMSK0 |= (1 &lt;&lt; 7); //   PCINT7<font></font>
	// :init button<font></font>
	<font></font>
	sei();<font></font>
	flags0 = 1; //   22       !<font></font>
	while(1){<font></font>
		showVal();<font></font>
		//ms.sendByte(0x99);<font></font>
		if(0 != (1 &amp; flags0)){<font></font>
			setRes();<font></font>
			flags0 &amp;= ~1;<font></font>
		}<font></font>
	}<font></font>
}<font></font>
</pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und mySerial.cpp</font></font></b><div class="spoiler_text"><pre>#include &lt;avr/io.h&gt;<font></font>
#include &lt;avr/interrupt.h&gt;<font></font>
<font></font>
class MySerial{<font></font>
	public:<font></font>
	volatile uint8_t *dataPort;<font></font>
	volatile uint8_t *dataPin;<font></font>
	volatile uint8_t *dataDDR;<font></font>
	volatile uint8_t *clockPort;<font></font>
	volatile uint8_t *clockPin;<font></font>
	volatile uint8_t *clockDDR;<font></font>
	uint8_t dataPinMask, clockPinMask;<font></font>
	uint8_t rBit,<font></font>
		lastState, // (dataPin &lt;&lt; 1) | clockPin<font></font>
		inData;<font></font>
	// MySerial ms(&amp;PORTD, &amp;PIND, &amp;DDRD, 2, &amp;PORTD, &amp;PIND, &amp;DDRD, 3);<font></font>
	MySerial(<font></font>
		volatile uint8_t *_dataPort,<font></font>
		volatile uint8_t *_dataPin,<font></font>
		volatile uint8_t *_dataDDR,<font></font>
		uint8_t _dataPinN,<font></font>
		volatile uint8_t *_clockPort,<font></font>
		volatile uint8_t *_clockPin,<font></font>
		volatile uint8_t *_clockDDR,<font></font>
		uint8_t _clockPinN<font></font>
	){<font></font>
		rBit = 255;<font></font>
		lastState = 3;<font></font>
		inData = 0;<font></font>
		dataPort = _dataPort;<font></font>
		dataPin = _dataPin;<font></font>
		dataDDR = _dataDDR;<font></font>
		dataPinMask = (1 &lt;&lt; _dataPinN);<font></font>
		clockPort = _clockPort;<font></font>
		clockPin = _clockPin;<font></font>
		clockDDR = _clockDDR;<font></font>
		clockPinMask = (1 &lt;&lt; _clockPinN);<font></font>
	}<font></font>
	void dataZero() {<font></font>
		*dataPort &amp;= ~dataPinMask; //digitalWrite(pinData, 0);<font></font>
		*dataDDR |= dataPinMask;   //pinMode(pinData, OUTPUT);<font></font>
	}<font></font>
	void dataRelease() {<font></font>
		*dataDDR &amp;= ~dataPinMask; //pinMode(pinData, INPUT);<font></font>
		*dataPort |= dataPinMask; //digitalWrite(pinData, 1);<font></font>
	}<font></font>
	void clockZero() {<font></font>
		*clockPort &amp;= ~clockPinMask; //digitalWrite(pinClock, 0);<font></font>
		*clockDDR |= clockPinMask;  //pinMode(pinClock, OUTPUT);<font></font>
	}<font></font>
	void clockRelease() {<font></font>
		*clockDDR &amp;= ~clockPinMask; //pinMode(pinClock, INPUT);<font></font>
		*clockPort |= clockPinMask; //digitalWrite(pinClock, 1);<font></font>
	}<font></font>
	void pause() {<font></font>
		//delay(v * 1);<font></font>
		//unsigned long time = micros();<font></font>
		//while(v-- &gt; 0)<font></font>
		for(uint16_t i = 0; i &lt; 250; i++)<font></font>
			__asm__ __volatile__(<font></font>
				"nop"<font></font>
			);<font></font>
		//time = micros() - time;<font></font>
		//LOG("Paused "); LOG(time); LOGLN("us");<font></font>
	}<font></font>
	void sendByte(uint8_t data){<font></font>
		//LOG("Sending byte: "); LOGLN(data);<font></font>
		//   data  clock = 1:<font></font>
		dataRelease();<font></font>
		clockRelease();<font></font>
		pause();<font></font>
		dataZero();<font></font>
		pause();<font></font>
		<font></font>
		//LOGLN("Going to loop...");<font></font>
		for(uint8_t i = 0; i &lt; 8; i++){<font></font>
			clockZero();<font></font>
			pause();<font></font>
			if( 0 == (data &amp; (1 &lt;&lt; 7)) )<font></font>
				dataZero();<font></font>
			else<font></font>
				dataRelease();<font></font>
			//LOG("Sending bit "); LOGLN((data &amp; (1 &lt;&lt; 7)));<font></font>
			pause();<font></font>
			clockRelease();<font></font>
			pause();<font></font>
<font></font>
			data = data &lt;&lt; 1;<font></font>
		}<font></font>
		<font></font>
		//   data  clock = 1:<font></font>
		dataZero();<font></font>
		pause();<font></font>
		dataRelease();<font></font>
		pause();<font></font>
	}	<font></font>
	void tick(){<font></font>
		//uint8_t curState = (digitalRead(pinData) &lt;&lt; 1) | digitalRead(pinClock);<font></font>
		dataRelease();<font></font>
		clockRelease();<font></font>
		uint8_t curState = 0;<font></font>
		if(0 != (*dataPin &amp; dataPinMask))<font></font>
			curState |= 2;<font></font>
		if(0 != (*clockPin &amp; clockPinMask))<font></font>
			curState |= 1;<font></font>
<font></font>
		//LOGLN(curState);<font></font>
		if((3 == lastState) &amp;&amp; (1 == curState)) //  <font></font>
		rBit = 7;<font></font>
		if(255 != rBit)<font></font>
		if( (0 == (lastState &amp; 1)) &amp;&amp; (1 == (curState &amp; 1)) ) { //    clock<font></font>
			//LOG("Getted bit "); LOGLN((curState &gt;&gt; 1));<font></font>
			if( 0 == (curState &gt;&gt; 1) )<font></font>
				inData &amp;= ~(1 &lt;&lt; rBit);<font></font>
			else<font></font>
				inData |= (1 &lt;&lt; rBit);<font></font>
			rBit--;<font></font>
		}<font></font>
		<font></font>
		if( (1 == lastState) &amp;&amp; (3 == curState) ){ //  <font></font>
			//LOG("Recieved byte: "); LOGLN(inData);<font></font>
			rBit = 255;<font></font>
			//delay(5000);<font></font>
		}<font></font>
		lastState = curState;<font></font>
	}<font></font>
};<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und nicht nur das passt, es werden nur 1044 Byte Flash von den verf√ºgbaren 2048 ben√∂tigt! </font><font style="vertical-align: inherit;">Und das trotz der Tatsache, dass es neben der Hauptfunktion auch Debugging-Informationen (MySerial) sendet! </font><font style="vertical-align: inherit;">
Ich werde hier ein wenig erkl√§ren, warum (von links nach rechts):</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/091/e65/170/091e651703154a0ca3ec7abe8e6fa678.JPG" alt="Bild"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Drahtspule ist eine empfindliche Spule eines Metalldetektors;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Taste links auf dem Steckbrett ruft die Resonanzerkennungsfunktion auf.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Diode + Widerstand + Kondensator ist ein Amplitudendetektor;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√ºner Schal - Adapter mit ATtiny24A;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED mit einem Widerstand und einer gro√üen Blackbox (dies ist ein altes Mikroammeter) - PWM-Anzeige;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arduino Nano √ºber zwei Dr√§hte verbunden - ein Empf√§nger zum Debuggen von Informationen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Planen:</font></font><br>
<img src="https://habrastorage.org/files/13b/2ef/e39/13b2efe390ef4b298e7600f056a4b856.png" alt="Bild"><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1, C1 - Schwingkreis;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1, C2, R2 - Amplitudendetektor.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Empfindlichkeit erwies sich f√ºr den praktischen Gebrauch als zu niedrig. </font><font style="vertical-align: inherit;">Ein Gewicht von 0,5 kg ist ab 7 Zentimetern zu sp√ºren, und eine M√ºnze wird im Allgemeinen nur dann geworfen, wenn sie in die Spule geworfen wird. </font><font style="vertical-align: inherit;">Aber im Allgemeinen funktioniert das Ger√§t:</font></font><br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.youtube.com/embed/CW1kqXtIVEo%3Ffeature%3Doembed&amp;usg=ALkJrhj-8jCvnxaFcMxfr1Yd79IOGbPCxw" frameborder="0" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufzeichnung zeigt, wie beim Einsetzen eines Metallobjekts in die Spule die ADC-Messwerte (auf dem Bildschirm) fallen und der MK den Strom durch die Anzeige erh√∂ht.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was weiter?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufgabe "mit ATtiny spielen" ist abgeschlossen. </font><font style="vertical-align: inherit;">Alles funktioniert, alles ist gut. </font><font style="vertical-align: inherit;">Der Rechen auf der Stra√üe war noch geringer als erwartet. </font><font style="vertical-align: inherit;">Aufgrund der eingangs genannten Tatsache (dass sogar der leistungsst√§rkere STM8S103F3P6 billiger ist) sehe ich nur zwei Gr√ºnde, etwas am AVR zu tun: Einfachheit und gute Dokumentation. </font><font style="vertical-align: inherit;">Nun, vielleicht kann in einigen F√§llen sogar das Doppelte des maximal zul√§ssigen Ausgangsstroms ein Argument sein.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de383819/">https://habr.com/ru/post/de383819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de383803/index.html">Samsung baute eine Waschmaschine mit einer T√ºr f√ºr vergessene Kleidung</a></li>
<li><a href="../de383807/index.html">In Londons unterirdischen Bunkern wird jetzt Salat angebaut</a></li>
<li><a href="../de383811/index.html">–°–µ–≥–æ–¥–Ω—è –∏—Å–ø–æ–ª–Ω—è–µ—Ç—Å—è 38 –ª–µ—Ç —Å–æ –¥–Ω—è –∑–∞–ø—É—Å–∫–∞ –í–æ—è–¥–∂–µ—Ä–∞-1</a></li>
<li><a href="../de383815/index.html">Exklusive silberne ThinkPad Yoga 260 Fotos</a></li>
<li><a href="../de383817/index.html">Der 3D-Druck l√§utet eine neue √Ñra in der Spielzeuggeschichte ein</a></li>
<li><a href="../de383821/index.html">Alter neuer High Definition Sound</a></li>
<li><a href="../de383823/index.html">Sound, Design und Psychologie: Wie Restaurants Besucher dazu bringen, mehr zu bezahlen</a></li>
<li><a href="../de383829/index.html">Ein weiterer Motortest f√ºr den schweren SLS-Booster war erfolgreich</a></li>
<li><a href="../de383831/index.html">Chrome hat gelernt, Werbeblocker auszutricksen</a></li>
<li><a href="../de383833/index.html">In den Niederlanden wurde ein Verkaufsautomat f√ºr Pommes Frites entwickelt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>