<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧐 👨‍🎨 🌈 Herstellung eines Metalldetektors auf ATtiny24A 🥝 🤘🏼 🔍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe lange Zeit mit Arduino-ähnlichen Boards gespielt, aber die ganze Zeit wollte ich "weniger, billiger und näher an der Hardware!". Und hier ist...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Herstellung eines Metalldetektors auf ATtiny24A</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/383819/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe lange Zeit mit Arduino-ähnlichen Boards gespielt, aber die ganze Zeit wollte ich "weniger, billiger und näher an der Hardware!". Und hier ist die erste Erfahrung mit der Programmierung von reinem ATtiny. </font><font style="vertical-align: inherit;">Der Artikel wird keine besonders effektive Metalldetektorschaltung sein. </font><font style="vertical-align: inherit;">Dies ist nur eine Demonstration dessen, wozu der Mikrocontroller für 47 Cent + den Weg des Kessels in der Lage ist. Wie sich herausstellte, ist es keineswegs kompliziert, von Arduino auf eine niedrigere Ebene zu wechseln.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eisenauswahl</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach einer kurzen Analyse fiel die Wahl auf die ATtiny24A-SSU (14-poliges SOIC-Paket). Warum? Der Grund ist einfach: Preis + AVR-Kern. Ja, ich weiß, dass ein noch leistungsstärkerer STM8S103F3P6 billiger ist ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">39,5 Cent pro Stück</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gegenüber </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">47 für ATtiny</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), aber da ich einige Erfahrungen mit AVR in Arduino habe, wollte ich AVR für die ersten Experimente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus den verfügbaren AVRs wählen wir ATtiny als das billigste aus, und dann möchte ich, dass das DIP-Paket einfacher zu löten ist. Die Chips im DIP-Paket erwiesen sich jedoch als viel teurer ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">54 Cent für den 8-Fuß-ATtiny13A</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14-Fuß-ATtiny23A im DIP-Paket sind 95 Cent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ich mag die Idee, den ATtiny13A wegen seines Oktopus zu verwenden, nicht. 6 Beine werden vom Programmierer besetzt und nur 2 bleiben frei, was klein ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurde beschlossen, ATtiny24A-SSU für 47 Cent und einen weiteren </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adapter für 30 Cent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu kaufen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Insgesamt erhalten wir 77 Cent pro Gerät gegenüber 95 Cent für ein DIP-Paket. Als Bonus verwenden wir bei einfachen Geräten einen Adapter als Platine mit Lötdrähten direkt daran, was mit einem DIP-Paket unmöglich wäre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Programmierer wird nach dem gleichen Prinzip (dem billigsten) ausgewählt: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USBasp für 1,86 USD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ist eingetroffen!</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich muss sofort sagen, dass ich noch nie zuvor ein SOIC-Gehäuse gelötet habe, daher gab es einige Befürchtungen, dass es nicht funktionieren würde ... Es stellte sich als nicht schwierig heraus, nicht einfach ... im Allgemeinen musste ich einige Anstrengungen unternehmen, aber am Ende stellte sich heraus! </font><font style="vertical-align: inherit;">Es schien ratsam, sich nicht durch eine Schlussfolgerung aufzuwärmen, sondern sofort durch Gruppen - dieser Weg ist schneller und einfacher.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/78b/4f2/1e9/78b4f21e967344348ffb2130de618ff5.JPG" alt="Bild"></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie programmiere ich?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ATtiny24A wird standardmäßig vom internen Generator getaktet und arbeitet mit einer Frequenz von 1 MHz. Nun, lass es funktionieren, es passt perfekt zu mir. Aber damit USBasp mit einer solchen Frequenz mit ihm arbeiten konnte, musste er einen zusätzlichen Jumper löten (Postings auf dem Foto): Es gab einen </font><font style="vertical-align: inherit;">
Platz auf der Platine, aber die Chinesen machten sich nicht die Mühe, den Jumper zu löten ... sie mussten es für sie tun. </font><font style="vertical-align: inherit;">
In Bezug auf die Entwicklungsumgebung fiel die Wahl auf Atmel Studio, aber es unterstützt unser USBasp nicht ... aber es spielt keine Rolle! Selbst bei der Auswahl eines Programmiergeräts war geplant, ein Upgrade auf AVR-Doper durchzuführen, das mit dem STK500 kompatibel ist, was bedeutet, dass es von unserem Atmel Studio unterstützt wird. Im Allgemeinen habe ich es viele Male mit einer anderen Firmware geflasht, aber Atmel Studio wollte es nicht sehen ... Traurigkeit ... am Ende war ich verzweifelt, habe es zurück auf USBasp geflasht und es per </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Tool gemacht</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/2ed/bc9/af0/2edbc9af064a4278a47cd7e78c724f00.JPG" alt="Bild"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Danach gelang es mir, mein ATtiny zu blinken, eine LED zu blinken und zu genießen, wie wenig Flash-Speicher im Vergleich zu Arduino benötigt wurde.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metalldetektor</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst als ich mich mit Arduino beschäftigte, baute ich einen Metalldetektor nach dem Prinzip der Resonanzstörung. Die Empfindlichkeit ist schrecklich, aber das Funktionsprinzip ist sehr einfach und auf jedem MK leicht zu implementieren. Ein rechteckiges Signal wird über einen Widerstand mit der Resonanzfrequenz dieser Schaltung an einen parallelen Schwingkreis angelegt. Wenn ein Metallgegenstand in das Magnetfeld der Spule eintritt, nimmt der Qualitätsfaktor der Schaltung ab, die vom ADC gemessene Signalamplitude nimmt ab, das Gerät gefällt uns optisch und akustisch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Detektor verfügt über zwei Modi: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Suchen Sie nach der Resonanz des Schaltkreises. Gleichzeitig sendet es rechteckige Signale mit unterschiedlichen Frequenzen an die Schaltung und merkt sich die Frequenz, bei der die Schwingungsamplitude am größten ist (wir erinnern uns auch an diese größte Amplitude).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Die Betriebsart. </font><font style="vertical-align: inherit;">Wir senden ein Signal mit einer Resonanzfrequenz an die Schaltung und vergleichen die Amplitude mit dem Maximum, das im ersten Modus war. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kompliziert? </font><font style="vertical-align: inherit;">- Nein! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sollte ich viel Speicherplatz beanspruchen? </font><font style="vertical-align: inherit;">- Nein! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haben wir viel Speicher (2 KB Flash + 128 Byte RAM)? </font><font style="vertical-align: inherit;">- Auch nicht! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passt es hinein? </font><font style="vertical-align: inherit;">Versuchen wir es - wir werden es herausfinden! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Ergebnis fit.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Haupt-Firmware-Code</font></font></b><div class="spoiler_text"><pre>#include &lt;avr/io.h&gt;<font></font>
#include &lt;avr/interrupt.h&gt;<font></font>
#include "mySerial.cpp"<font></font>
<font></font>
MySerial ms(&amp;PORTB, &amp;PINB, &amp;DDRB, 0, &amp;PORTB, &amp;PINB, &amp;DDRB, 1);<font></font>
<font></font>
volatile uint16_t maxAdc = 0; //    (    )<font></font>
volatile uint8_t dispMode = 0; // 0 -  , 1 -  <font></font>
volatile uint8_t flags0 = 0; // [0] - need setRes<font></font>
volatile uint16_t adcSource = 0;<font></font>
//volatile bool needADC = false;<font></font>
#define ADC_SOURCE_ARRAY_SIZE_POWER 5<font></font>
#define ADC_SOURCE_ARRAY_SIZE (1 &lt;&lt; ADC_SOURCE_ARRAY_SIZE_POWER)<font></font>
uint16_t adcSourceArray[ADC_SOURCE_ARRAY_SIZE];<font></font>
uint8_t adcSourceArrayLastWrited = 0;<font></font>
void showVal(void);<font></font>
<font></font>
ISR(ADC_vect){<font></font>
	//adcSourceArrayLastWrited++;<font></font>
	if(++adcSourceArrayLastWrited &gt;= ADC_SOURCE_ARRAY_SIZE)<font></font>
		adcSourceArrayLastWrited = 0;<font></font>
	adcSourceArray[adcSourceArrayLastWrited] = ADCL | (ADCH &lt;&lt; 8);<font></font>
	uint16_t adcSourceTmp = 0;<font></font>
	for(uint8_t i = 0; i &lt; ADC_SOURCE_ARRAY_SIZE; i++)<font></font>
		adcSourceTmp += adcSourceArray[adcSourceArrayLastWrited];<font></font>
	adcSource = (adcSourceTmp &gt;&gt; ADC_SOURCE_ARRAY_SIZE_POWER);<font></font>
	//adcSource = ADCL | (ADCH &lt;&lt; 8);<font></font>
	//needADC = false;<font></font>
}<font></font>
<font></font>
volatile uint8_t pinaChanged = 0;<font></font>
volatile uint8_t tim0_ovf_counter = 0;<font></font>
//uint32_t ticks = 0;<font></font>
volatile uint16_t ticks10ms = 0;<font></font>
//volatile uint16_t ticks = 0;<font></font>
ISR(TIM0_OVF_vect)<font></font>
{		<font></font>
	//ticks++;<font></font>
	//if(255 == tim0_ovf_counter++){ // ticks every 65.5 ms<font></font>
	if(39 == (tim0_ovf_counter++)){ // ticks every 10 ms<font></font>
		tim0_ovf_counter = 0;<font></font>
		ticks10ms++;<font></font>
		if(pinaChanged &gt; 0)<font></font>
			pinaChanged--;<font></font>
	}<font></font>
}<font></font>
<font></font>
uint16_t dist16(uint16_t lo, uint16_t hi){<font></font>
	return (lo &lt;= hi) ? (hi - lo) : (0xFFFF - lo + hi);<font></font>
}<font></font>
/*void delayTicks(uint16_t val){<font></font>
	uint16_t tim0_ovf_counter0 = tim0_ovf_counter;<font></font>
	while(dist16(tim0_ovf_counter0, tim0_ovf_counter) &lt; val)<font></font>
		showVal();<font></font>
}*/<font></font>
void delay10ms(uint16_t val){<font></font>
	uint16_t ticks10ms0 = ticks10ms;<font></font>
	while(dist16(ticks10ms0, ticks10ms) &lt; val)<font></font>
		showVal();<font></font>
}<font></font>
<font></font>
void showVal(void){<font></font>
	ms.sendByte(adcSource &gt;&gt; 2);<font></font>
	switch(dispMode){<font></font>
		case 0:<font></font>
			OCR0A = adcSource &gt;&gt; 2;<font></font>
		break;<font></font>
		case 1:<font></font>
			uint16_t maxAdcPlus = maxAdc + 2;<font></font>
			uint16_t dispVal = (maxAdcPlus &gt; adcSource) ? ((maxAdcPlus - adcSource)) : 0;<font></font>
			dispVal &lt;&lt;= 4;<font></font>
			if(dispVal &gt; 255)<font></font>
				dispVal = 255;<font></font>
			OCR0A = dispVal;<font></font>
		break;<font></font>
	}<font></font>
}<font></font>
<font></font>
void setRes(void)<font></font>
{<font></font>
	dispMode = 0;<font></font>
	uint16_t maxOCR = 0;<font></font>
	maxAdc = 0;<font></font>
	for(uint16_t curOCR = 35; curOCR &lt; 50; curOCR++){<font></font>
		OCR1A = curOCR;<font></font>
		OCR1B = (curOCR &gt;&gt; 1);<font></font>
		//uint32_t ticks0 = ticks;<font></font>
		//uint16_t ticks0 = ticks;		<font></font>
		//while(dist16(ticks0, ticks) &lt; 20)<font></font>
		//	showVal();<font></font>
		delay10ms(30);<font></font>
		if(adcSource &gt; maxAdc){<font></font>
			maxAdc = adcSource;<font></font>
			maxOCR = curOCR;<font></font>
		}<font></font>
	}<font></font>
	OCR1A = maxOCR;<font></font>
	OCR1B = (maxOCR &gt;&gt; 1);<font></font>
	dispMode = 1;<font></font>
}<font></font>
<font></font>
ISR(PCINT0_vect)<font></font>
{	<font></font>
	if(pinaChanged &gt; 0)<font></font>
		return;<font></font>
	pinaChanged = 5;<font></font>
	if(0 == (PINA &amp; (1 &lt;&lt; 7)))<font></font>
		flags0 |= 1;<font></font>
}<font></font>
<font></font>
<font></font>
int main(void)<font></font>
{<font></font>
	// init PWM:<font></font>
	DDRB |= 4;  // OC0A as output<font></font>
	//TIMSK0 |= 7; //  TIM0_OVF_vect, TIM0_COMPA_vect, TIM0_COMPB_vect<font></font>
	TIMSK0 |= 1; //  TIM0_OVF_vect<font></font>
	TCCR0B |= 1; // no prescaling. OVF  256  (3.91 )<font></font>
	//TCCR0B |= 2; // clk/8<font></font>
	//TCCR0B |= 3; // clk/64<font></font>
	//TCCR0B |= 5; // clk/1024. OVF  262  (3.815 )<font></font>
	TCCR0A |= (3 | (1 &lt;&lt; 7)); //WGM0[2:0] = 3 - fawt PWM mode. bit7 -  <font></font>
	//OCR0A = 150;<font></font>
	//OCR0B = 100;<font></font>
	// :init PWM<font></font>
	<font></font>
	// init ADC:<font></font>
	//ADMUX |= (1 &lt;&lt; 7); // internal 1.1V reference. Comment this to use VCC as reference<font></font>
	//ADMUX |= (1 &lt;&lt; 3) | 1; // MUX[5:0] = 001001. Res = ADC0 - ADC1. Gain = 20<font></font>
	ADMUX |= (1 &lt;&lt; 3); // MUX[5:0] = 001000. Res = ADC0 - ADC1. Gain = 1<font></font>
	ADCSRA |= ((1 &lt;&lt; 7) // enable ADC<font></font>
		| (1 &lt;&lt; 5) // ADC Auto Trigger Enable.  <font></font>
		| (1 &lt;&lt; 6) //  1 <font></font>
		| (1 &lt;&lt; 3)   // ADC interrupt enable<font></font>
		| (1 &lt;&lt; 2)); // prescaller = 16 ( 50-200 kHz)<font></font>
	// :init ADC<font></font>
	<font></font>
	// init 16-bit timer: // pin7 = MOSI = PA6 = OC1A<font></font>
	//DDRA |= (1 &lt;&lt; 6); // OC1A as output<font></font>
	DDRA |= (1 &lt;&lt; 5); // OC1B as output<font></font>
	//TCCR1A |= (1 &lt;&lt; 6); // Toggle OC1A/OC1B on Compare Match<font></font>
	TCCR1A |= (1 &lt;&lt; 5) // Clear OC1B on Compare Match, set OC1B at BOTTOM (non-inverting mode)<font></font>
		| (3); // set WGM10 and WGM11 // WGM1[3:0] = 1111 - Fast PWM, TOP = OCR1A.	<font></font>
//	TCCR1A |= (1 &lt;&lt; 6) | (1 &lt;&lt; 7) // Set OC1A on Compare Match (Set output to high level).<font></font>
//			| (1 &lt;&lt; 5); // Clear OC1B on Compare Match	(Set output to low level)<font></font>
	TCCR1B |= 1 // no prescalling<font></font>
			| (1 &lt;&lt; 3) | (1 &lt;&lt; 4); // set WGM12 and WGM13<font></font>
	//TIMSK1 |= (1 &lt;&lt; 2) | (1 &lt;&lt; 1) | 1; // enable all interrupts<font></font>
	OCR1B = 21;<font></font>
	OCR1A = 42;<font></font>
	//for(;;){;};<font></font>
	// :init 16-bit timer<font></font>
	<font></font>
	// init button:<font></font>
	PORTA |= (1 &lt;&lt; 7); //     6- . PA7 = PCINT7<font></font>
	GIMSK |= (1 &lt;&lt; 4); // Pin Change Interrupt Enable 0<font></font>
	PCMSK0 |= (1 &lt;&lt; 7); //   PCINT7<font></font>
	// :init button<font></font>
	<font></font>
	sei();<font></font>
	flags0 = 1; //   22       !<font></font>
	while(1){<font></font>
		showVal();<font></font>
		//ms.sendByte(0x99);<font></font>
		if(0 != (1 &amp; flags0)){<font></font>
			setRes();<font></font>
			flags0 &amp;= ~1;<font></font>
		}<font></font>
	}<font></font>
}<font></font>
</pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und mySerial.cpp</font></font></b><div class="spoiler_text"><pre>#include &lt;avr/io.h&gt;<font></font>
#include &lt;avr/interrupt.h&gt;<font></font>
<font></font>
class MySerial{<font></font>
	public:<font></font>
	volatile uint8_t *dataPort;<font></font>
	volatile uint8_t *dataPin;<font></font>
	volatile uint8_t *dataDDR;<font></font>
	volatile uint8_t *clockPort;<font></font>
	volatile uint8_t *clockPin;<font></font>
	volatile uint8_t *clockDDR;<font></font>
	uint8_t dataPinMask, clockPinMask;<font></font>
	uint8_t rBit,<font></font>
		lastState, // (dataPin &lt;&lt; 1) | clockPin<font></font>
		inData;<font></font>
	// MySerial ms(&amp;PORTD, &amp;PIND, &amp;DDRD, 2, &amp;PORTD, &amp;PIND, &amp;DDRD, 3);<font></font>
	MySerial(<font></font>
		volatile uint8_t *_dataPort,<font></font>
		volatile uint8_t *_dataPin,<font></font>
		volatile uint8_t *_dataDDR,<font></font>
		uint8_t _dataPinN,<font></font>
		volatile uint8_t *_clockPort,<font></font>
		volatile uint8_t *_clockPin,<font></font>
		volatile uint8_t *_clockDDR,<font></font>
		uint8_t _clockPinN<font></font>
	){<font></font>
		rBit = 255;<font></font>
		lastState = 3;<font></font>
		inData = 0;<font></font>
		dataPort = _dataPort;<font></font>
		dataPin = _dataPin;<font></font>
		dataDDR = _dataDDR;<font></font>
		dataPinMask = (1 &lt;&lt; _dataPinN);<font></font>
		clockPort = _clockPort;<font></font>
		clockPin = _clockPin;<font></font>
		clockDDR = _clockDDR;<font></font>
		clockPinMask = (1 &lt;&lt; _clockPinN);<font></font>
	}<font></font>
	void dataZero() {<font></font>
		*dataPort &amp;= ~dataPinMask; //digitalWrite(pinData, 0);<font></font>
		*dataDDR |= dataPinMask;   //pinMode(pinData, OUTPUT);<font></font>
	}<font></font>
	void dataRelease() {<font></font>
		*dataDDR &amp;= ~dataPinMask; //pinMode(pinData, INPUT);<font></font>
		*dataPort |= dataPinMask; //digitalWrite(pinData, 1);<font></font>
	}<font></font>
	void clockZero() {<font></font>
		*clockPort &amp;= ~clockPinMask; //digitalWrite(pinClock, 0);<font></font>
		*clockDDR |= clockPinMask;  //pinMode(pinClock, OUTPUT);<font></font>
	}<font></font>
	void clockRelease() {<font></font>
		*clockDDR &amp;= ~clockPinMask; //pinMode(pinClock, INPUT);<font></font>
		*clockPort |= clockPinMask; //digitalWrite(pinClock, 1);<font></font>
	}<font></font>
	void pause() {<font></font>
		//delay(v * 1);<font></font>
		//unsigned long time = micros();<font></font>
		//while(v-- &gt; 0)<font></font>
		for(uint16_t i = 0; i &lt; 250; i++)<font></font>
			__asm__ __volatile__(<font></font>
				"nop"<font></font>
			);<font></font>
		//time = micros() - time;<font></font>
		//LOG("Paused "); LOG(time); LOGLN("us");<font></font>
	}<font></font>
	void sendByte(uint8_t data){<font></font>
		//LOG("Sending byte: "); LOGLN(data);<font></font>
		//   data  clock = 1:<font></font>
		dataRelease();<font></font>
		clockRelease();<font></font>
		pause();<font></font>
		dataZero();<font></font>
		pause();<font></font>
		<font></font>
		//LOGLN("Going to loop...");<font></font>
		for(uint8_t i = 0; i &lt; 8; i++){<font></font>
			clockZero();<font></font>
			pause();<font></font>
			if( 0 == (data &amp; (1 &lt;&lt; 7)) )<font></font>
				dataZero();<font></font>
			else<font></font>
				dataRelease();<font></font>
			//LOG("Sending bit "); LOGLN((data &amp; (1 &lt;&lt; 7)));<font></font>
			pause();<font></font>
			clockRelease();<font></font>
			pause();<font></font>
<font></font>
			data = data &lt;&lt; 1;<font></font>
		}<font></font>
		<font></font>
		//   data  clock = 1:<font></font>
		dataZero();<font></font>
		pause();<font></font>
		dataRelease();<font></font>
		pause();<font></font>
	}	<font></font>
	void tick(){<font></font>
		//uint8_t curState = (digitalRead(pinData) &lt;&lt; 1) | digitalRead(pinClock);<font></font>
		dataRelease();<font></font>
		clockRelease();<font></font>
		uint8_t curState = 0;<font></font>
		if(0 != (*dataPin &amp; dataPinMask))<font></font>
			curState |= 2;<font></font>
		if(0 != (*clockPin &amp; clockPinMask))<font></font>
			curState |= 1;<font></font>
<font></font>
		//LOGLN(curState);<font></font>
		if((3 == lastState) &amp;&amp; (1 == curState)) //  <font></font>
		rBit = 7;<font></font>
		if(255 != rBit)<font></font>
		if( (0 == (lastState &amp; 1)) &amp;&amp; (1 == (curState &amp; 1)) ) { //    clock<font></font>
			//LOG("Getted bit "); LOGLN((curState &gt;&gt; 1));<font></font>
			if( 0 == (curState &gt;&gt; 1) )<font></font>
				inData &amp;= ~(1 &lt;&lt; rBit);<font></font>
			else<font></font>
				inData |= (1 &lt;&lt; rBit);<font></font>
			rBit--;<font></font>
		}<font></font>
		<font></font>
		if( (1 == lastState) &amp;&amp; (3 == curState) ){ //  <font></font>
			//LOG("Recieved byte: "); LOGLN(inData);<font></font>
			rBit = 255;<font></font>
			//delay(5000);<font></font>
		}<font></font>
		lastState = curState;<font></font>
	}<font></font>
};<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und nicht nur das passt, es werden nur 1044 Byte Flash von den verfügbaren 2048 benötigt! </font><font style="vertical-align: inherit;">Und das trotz der Tatsache, dass es neben der Hauptfunktion auch Debugging-Informationen (MySerial) sendet! </font><font style="vertical-align: inherit;">
Ich werde hier ein wenig erklären, warum (von links nach rechts):</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/091/e65/170/091e651703154a0ca3ec7abe8e6fa678.JPG" alt="Bild"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Drahtspule ist eine empfindliche Spule eines Metalldetektors;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Taste links auf dem Steckbrett ruft die Resonanzerkennungsfunktion auf.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Diode + Widerstand + Kondensator ist ein Amplitudendetektor;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grüner Schal - Adapter mit ATtiny24A;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED mit einem Widerstand und einer großen Blackbox (dies ist ein altes Mikroammeter) - PWM-Anzeige;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arduino Nano über zwei Drähte verbunden - ein Empfänger zum Debuggen von Informationen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Planen:</font></font><br>
<img src="https://habrastorage.org/files/13b/2ef/e39/13b2efe390ef4b298e7600f056a4b856.png" alt="Bild"><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1, C1 - Schwingkreis;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1, C2, R2 - Amplitudendetektor.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Empfindlichkeit erwies sich für den praktischen Gebrauch als zu niedrig. </font><font style="vertical-align: inherit;">Ein Gewicht von 0,5 kg ist ab 7 Zentimetern zu spüren, und eine Münze wird im Allgemeinen nur dann geworfen, wenn sie in die Spule geworfen wird. </font><font style="vertical-align: inherit;">Aber im Allgemeinen funktioniert das Gerät:</font></font><br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://www.youtube.com/embed/CW1kqXtIVEo%3Ffeature%3Doembed&amp;usg=ALkJrhj-8jCvnxaFcMxfr1Yd79IOGbPCxw" frameborder="0" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufzeichnung zeigt, wie beim Einsetzen eines Metallobjekts in die Spule die ADC-Messwerte (auf dem Bildschirm) fallen und der MK den Strom durch die Anzeige erhöht.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was weiter?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufgabe "mit ATtiny spielen" ist abgeschlossen. </font><font style="vertical-align: inherit;">Alles funktioniert, alles ist gut. </font><font style="vertical-align: inherit;">Der Rechen auf der Straße war noch geringer als erwartet. </font><font style="vertical-align: inherit;">Aufgrund der eingangs genannten Tatsache (dass sogar der leistungsstärkere STM8S103F3P6 billiger ist) sehe ich nur zwei Gründe, etwas am AVR zu tun: Einfachheit und gute Dokumentation. </font><font style="vertical-align: inherit;">Nun, vielleicht kann in einigen Fällen sogar das Doppelte des maximal zulässigen Ausgangsstroms ein Argument sein.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de383819/">https://habr.com/ru/post/de383819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de383803/index.html">Samsung baute eine Waschmaschine mit einer Tür für vergessene Kleidung</a></li>
<li><a href="../de383807/index.html">In Londons unterirdischen Bunkern wird jetzt Salat angebaut</a></li>
<li><a href="../de383811/index.html">Сегодня исполняется 38 лет со дня запуска Вояджера-1</a></li>
<li><a href="../de383815/index.html">Exklusive silberne ThinkPad Yoga 260 Fotos</a></li>
<li><a href="../de383817/index.html">Der 3D-Druck läutet eine neue Ära in der Spielzeuggeschichte ein</a></li>
<li><a href="../de383821/index.html">Alter neuer High Definition Sound</a></li>
<li><a href="../de383823/index.html">Sound, Design und Psychologie: Wie Restaurants Besucher dazu bringen, mehr zu bezahlen</a></li>
<li><a href="../de383829/index.html">Ein weiterer Motortest für den schweren SLS-Booster war erfolgreich</a></li>
<li><a href="../de383831/index.html">Chrome hat gelernt, Werbeblocker auszutricksen</a></li>
<li><a href="../de383833/index.html">In den Niederlanden wurde ein Verkaufsautomat für Pommes Frites entwickelt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>