<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèæ üò® üéüÔ∏è Atirador de zumbis simples no Unity üëÜüèº üéõÔ∏è ü¶Ç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! Em breve, as aulas come√ßar√£o no primeiro grupo do curso Unity Games Developer . Antecipando o in√≠cio do curso, foi realizada uma li√ß√£o ab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Atirador de zumbis simples no Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/485210/">  <i>Ol√° pessoal!</i>  <i>Em breve, as aulas come√ßar√£o no primeiro grupo do curso <a href="https://otus.pw/sW0V/">Unity Games Developer</a> .</i>  <i>Antecipando o in√≠cio do curso, foi realizada <a href="https://www.youtube.com/watch%3Fv%3D6OTvr4e9PRY">uma li√ß√£o aberta</a> sobre a cria√ß√£o de um atirador de zumbis no Unity.</i>  <i>O webinar foi organizado por <a href="https://otus.pw/xfXx/">Nikolai Zapolnov</a> , desenvolvedor s√™nior de jogos da Rovio Entertainment Corporation.</i>  <i>Ele tamb√©m escreveu um artigo detalhado, que chamamos a sua aten√ß√£o.</i> <br><br><img src="https://habrastorage.org/webt/z6/pk/iv/z6pkiv4cismrguzozecv51foouk.jpeg"><br><br>  Neste artigo, gostaria de mostrar como √© f√°cil criar jogos no Unity.  Se voc√™ possui conhecimentos b√°sicos de programa√ß√£o, pode come√ßar rapidamente a trabalhar com esse mecanismo e fazer seu primeiro jogo. <br><br><hr><br>  <i>Isen√ß√£o de responsabilidade n¬∫ 1: este artigo √© para iniciantes.</i>  <i>Se voc√™ comeu um cachorro no Unity, ent√£o pode parecer chato para voc√™.</i> <br><br>  <i>Isen√ß√£o de responsabilidade n¬∫ 2: para ler este artigo, voc√™ precisa de pelo menos conhecimentos b√°sicos de programa√ß√£o.</i>  <i>No m√≠nimo, as palavras "classe" e "m√©todo" n√£o devem assust√°-lo.</i> <br><br>  <b>Cuidado, tr√°fego sob o corte!</b> <br><a name="habracut"></a><br><h2>  Introdu√ß√£o √† Unidade </h2><br>  <i>Se voc√™ j√° conhece o editor do Unity, pode pular a introdu√ß√£o e ir direto para a se√ß√£o "Criando um mundo de jogo".</i> <br><br>  A unidade estrutural b√°sica no Unity √© a "cena".  Uma cena √© geralmente um n√≠vel do jogo, embora em alguns casos possa haver v√°rios n√≠veis ao mesmo tempo em uma cena ou, inversamente, um n√≠vel grande pode ser dividido em v√°rias cenas carregadas dinamicamente.  As cenas s√£o preenchidas com objetos do jogo e, por sua vez, s√£o preenchidas com componentes.  S√£o os componentes que implementam v√°rias fun√ß√µes do jogo: objetos de desenho, anima√ß√£o, f√≠sica etc.  Este modelo permite montar a funcionalidade a partir de blocos simples, como um brinquedo do construtor Lego. <br><br>  Voc√™ pode escrever componentes voc√™ mesmo, usando a linguagem de programa√ß√£o C # para isso.  √â assim que a l√≥gica do jogo √© escrita.  Abaixo, veremos como isso √© feito, mas, por enquanto, vamos dar uma olhada no pr√≥prio mecanismo. <br><br>  Ao iniciar o mecanismo e criar um novo projeto, voc√™ ver√° uma janela √† sua frente, onde poder√° selecionar quatro elementos principais: <br><br><img src="https://habrastorage.org/webt/5m/0o/9j/5m0o9jxwps3qwz3pbmvlchxveau.png"><br><br>  No canto superior esquerdo da captura de tela est√° a janela "Hierarquia".  Aqui podemos ver a hierarquia dos objetos do jogo na cena aberta atual.  O Unity criou dois objetos de jogo para n√≥s: uma c√¢mera (‚ÄúC√¢mera principal‚Äù) atrav√©s da qual o jogador ver√° nosso mundo de jogo e uma ‚ÄúLuz direcional‚Äù que iluminar√° nossa cena.  Sem ele, ver√≠amos apenas um quadrado preto. <br><br>  No centro est√° a janela de edi√ß√£o de cena ("Cena").  Aqui vemos nosso n√≠vel e podemos edit√°-lo visualmente - mova e gire objetos com o mouse e veja o que acontece.  Nas proximidades, voc√™ pode ver a guia "Jogo", que est√° atualmente inativa;  se voc√™ mudar para ele, poder√° ver como o jogo se parece com a c√¢mera.  E se voc√™ iniciar o jogo (usando o bot√£o com o √≠cone de reprodu√ß√£o na barra de ferramentas), o Unity mudar√° para essa guia, onde jogaremos o jogo iniciado. <br><br>  Na parte superior direita est√° a janela "Inspetor".  Nesta janela, o Unity mostra os par√¢metros do objeto selecionado e podemos edit√°-los.  Em particular, podemos ver que a c√¢mera selecionada possui dois componentes - "Transform", que define a posi√ß√£o da c√¢mera no mundo do jogo e, de fato, "Camera", que implementa a funcionalidade da c√¢mera. <br><br>  A prop√≥sito, o componente Transform est√° de uma forma ou de outra em todos os objetos do jogo no Unity. <br><br>  E, finalmente, na parte inferior, h√° a guia "Projeto", onde podemos ver todos os ativos chamados que est√£o em nosso projeto.  Ativos s√£o arquivos de dados, como texturas, sprites, modelos 3D, anima√ß√µes, sons e m√∫sicas, arquivos de configura√ß√£o.  Ou seja, quaisquer dados que possamos usar para criar n√≠veis ou a interface do usu√°rio.  O Unity entende um grande n√∫mero de formatos padr√£o (por exemplo, png e jpg para fotos ou fbx para modelos 3d), para que n√£o haja problemas ao carregar dados em um projeto.  E se voc√™, como eu, n√£o sabe desenhar, os ativos podem ser baixados na Unity Asset Store, que cont√©m uma enorme cole√ß√£o de todos os tipos de recursos: gratuitos e vendidos por dinheiro. <br><br>  √Ä direita da guia "Projeto", a guia "Console" inativa √© vis√≠vel.  O Unity grava avisos e mensagens de erro no console, portanto, verifique periodicamente.  Especialmente se algo n√£o funcionar - o mais prov√°vel √© que o console indique a causa do problema.  Al√©m disso, o console pode exibir mensagens do c√≥digo do jogo, para depura√ß√£o. <br><br><h2>  Crie um mundo de jogo </h2><br>  Como sou programador e desenho pior do que a pata de galinha, para os gr√°ficos, peguei alguns ativos gratuitos na Unity Asset Store.  Voc√™ pode encontrar links para eles no final deste artigo. <br><br>  A partir desses ativos, reuni um n√≠vel simples com o qual trabalharemos: <br><br><img src="https://habrastorage.org/webt/07/y-/cr/07y-crxk0zc6zywqh8vga90qg-s.jpeg"><br><br>  N√£o √© m√°gica, eu apenas arrastei os objetos de que gostei da janela Projeto e usando o mouse os organizei da maneira que gosto: <br><br><img src="https://habrastorage.org/webt/ll/xb/ca/llxbca3cdunouswhcy2b4jgpgha.gif"><br><br>  A prop√≥sito, o Unity permite adicionar objetos padr√£o √† cena com um clique, como um cubo, esfera ou plano.  Para fazer isso, clique com o bot√£o direito do mouse na janela Hierarquia e selecione, por exemplo, 3D Object‚á®Plane.  Portanto, o asfalto no meu n√≠vel √© apenas montado a partir de um conjunto de avi√µes no qual eu "puxei" uma textura de um conjunto de ativos. <br><br>  NB: Se voc√™ est√° se perguntando por que usei muitos planos, e n√£o um com valores em grande escala, a resposta √© bastante simples: um plano com uma escala maior ter√° uma textura muito aumentada, que parecer√° antinatural em rela√ß√£o a outros objetos na cena (isso pode ser corrigido com os par√¢metros material, mas estamos tentando fazer tudo da maneira mais simples poss√≠vel, certo?) <br><br><h2>  Zumbis em busca de uma maneira </h2><br>  Portanto, temos um n√≠vel de jogo, mas nada est√° acontecendo nele ainda.  Em nosso jogo, os zumbis perseguem o jogador e o atacam, e para isso eles devem poder se mover em dire√ß√£o ao jogador e contornar obst√°culos. <br><br>  Para implementar isso, usaremos a ferramenta "Navigation Mesh".  Com base nos dados da cena, essa ferramenta calcula as √°reas em que voc√™ pode se mover e gera um conjunto de dados que podem ser usados ‚Äã‚Äãpara procurar a rota ideal de qualquer ponto do n√≠vel para outro durante o jogo.  Esses dados s√£o armazenados no ativo e n√£o podem ser alterados no futuro - esse processo √© chamado de "cozimento".  Se voc√™ precisar mudar dinamicamente os obst√°culos, poder√° usar o componente NavMeshObstacle, mas isso n√£o √© necess√°rio para o nosso jogo. <br><br>  Um ponto importante: para que o Unity saiba quais objetos devem ser inclu√≠dos no c√°lculo, no Inspetor de cada objeto (voc√™ pode selecionar tudo de uma vez na janela Hierarquia), clique na seta para baixo ao lado da op√ß√£o "Est√°tico" e marque "Navega√ß√£o est√°tica": <br><br><img src="https://habrastorage.org/webt/d9/us/wk/d9uswkd5hafxmqqxlr3ujr0ed_u.jpeg"><br><br>  Em geral, os pontos restantes tamb√©m s√£o √∫teis e ajudam o Unity a otimizar a renderiza√ß√£o da cena.  Hoje n√£o vamos insistir neles, mas quando voc√™ terminar de aprender o b√°sico do mecanismo, eu recomendo que voc√™ lide com outros par√¢metros tamb√©m.  √Äs vezes, uma √∫nica marca de sele√ß√£o pode aumentar significativamente a taxa de quadros. <br><br>  Agora vamos usar o item de menu Janela‚á®AI‚á®Navega√ß√£o e, na janela que se abre, selecione a guia ‚ÄúAssar‚Äù.  Aqui, o Unity nos oferecer√° para definir par√¢metros como a altura e o raio do personagem, o √¢ngulo m√°ximo de inclina√ß√£o da terra sobre o qual voc√™ ainda pode andar, a altura m√°xima dos degraus e assim por diante.  Ainda n√£o mudaremos nada e apenas pressione o bot√£o "Assar". <br><br><img src="https://habrastorage.org/webt/zs/my/uo/zsmyuoqaopw11zon8bua6arf9aa.gif"><br><br>  A unidade far√° os c√°lculos necess√°rios e nos mostrar√° o resultado: <br><br><img src="https://habrastorage.org/webt/3q/lg/t6/3qlgt6ze2hkj5sv8npdlr6ohkk8.jpeg"><br><br>  Aqui, azul indica a √°rea onde voc√™ pode andar.  Como voc√™ pode ver, o Unity deixou um lado pequeno em torno de obst√°culos - a largura desse lado depende do raio do personagem.  Assim, se o centro do personagem estiver na zona azul, ele n√£o "cair√°" nos obst√°culos. <br><br>  Com uma grade de navega√ß√£o calculada, podemos usar o componente NavMeshAgent para procurar a rota do movimento e controlar o movimento dos objetos do jogo em nosso n√≠vel. <br><br>  Vamos criar um objeto de jogo ‚ÄúZumbi‚Äù, adicionar um modelo 3d de zumbis a partir de ativos e tamb√©m o componente NavMeshAgent: <br><br><img src="https://habrastorage.org/webt/ij/jy/cb/ijjycbpwk8kjyyhkhter8jrbu7g.gif"><br><br>  Se voc√™ iniciar o jogo agora, nada acontecer√°.  Precisamos informar ao componente NavMeshAgent para onde ir.  Para fazer isso, criaremos nosso primeiro componente em C #. <br><br>  Na janela do projeto, selecione o diret√≥rio raiz (chamado de "Ativos") e, na lista de arquivos, clique com o bot√£o direito do mouse para criar o diret√≥rio "Scripts".  Armazenaremos todos os nossos scripts nele para que o projeto tenha ordem.  Agora, dentro do "Scripts", vamos criar um script "Zombie" e adicion√°-lo ao objeto do jogo zombie: <br><br><img src="https://habrastorage.org/webt/dz/_d/a1/dz_da1d0ybbvslw1g3tvkq8vgau.gif"><br><br>  Se voc√™ clicar duas vezes no script, ele ser√° aberto no editor.  Vamos ver o que o Unity criou para n√≥s. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Zombie</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { } // Update is called once per frame void Update() { } }</span></span></code> </pre> <br>  Este √© um componente padr√£o em branco.  Como podemos ver, o Unity conectou as bibliotecas System.Collections e System.Collections.Generic a n√≥s (agora elas n√£o s√£o necess√°rias, mas muitas vezes s√£o necess√°rias no c√≥digo dos jogos do Unity, portanto est√£o inclu√≠das no modelo padr√£o), bem como na biblioteca UnityEngine, que cont√©m todos os API do mecanismo principal. <br><br>  Al√©m disso, o Unity criou a classe Zombie para n√≥s (o nome corresponde ao nome do arquivo; isso √© importante: se eles n√£o corresponderem, o Unity n√£o poder√° combinar o script com o componente na cena).  A classe √© herdada do MonoBehaviour - essa √© a classe base dos componentes criados pelo usu√°rio. <br><br>  Dentro da classe, o Unity criou dois m√©todos para n√≥s: Iniciar e Atualizar.  O mecanismo chamar√° esses m√©todos: Iniciar - imediatamente ap√≥s o carregamento da cena e Atualizar - todos os quadros.  De fato, existem muitas dessas fun√ß√µes chamadas pelo mecanismo, mas a maioria delas n√£o ser√° necess√°ria hoje.  A lista completa, bem como a sequ√™ncia da chamada, sempre pode ser encontrada na documenta√ß√£o: <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">https://docs.unity3d.com/Manual/ExecutionOrder.html</a> <br><br>  Vamos fazer os zumbis se moverem no mapa! <br><br>  Primeiro, precisamos conectar a biblioteca UnityEngine.AI.  Ele cont√©m a classe NavMeshAgent e outras classes relacionadas √† grade de navega√ß√£o.  Para fazer isso, adicione a diretiva UnityEngine.AI usando no in√≠cio do arquivo. <br><br>  Em seguida, precisamos acessar o componente NavMeshAgent.  Para fazer isso, podemos usar o m√©todo GetComponent padr√£o.  Ele permite que voc√™ obtenha um link para qualquer componente no mesmo objeto de jogo no qual o componente do qual chamamos esse m√©todo est√° localizado (no nosso caso, √© o objeto de jogo ‚ÄúZumbi‚Äù).  Criaremos o campo NavMeshAgent navMeshAgent na classe, no m√©todo Start, obteremos um link para o NavMeshAgent e solicitaremos que ele v√° para o ponto (0, 0, 0).  Dever√≠amos obter este script: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Zombie</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); navMeshAgent.SetDestination(Vector3.zero); } // Update is called once per frame void Update() { } }</span></span></code> </pre> <br>  Come√ßando o jogo, veremos como o zumbi se move para o centro do mapa: <br><br><img src="https://habrastorage.org/webt/dx/uz/u1/dxuzu157nhtqaj85o0afxbm_s7k.gif"><br><br><h2>  Zumbis perseguindo uma v√≠tima </h2><br>  √ìtimo  Mas nossos zumbis est√£o entediados e solit√°rios, vamos adicionar a <s>v√≠tima de um</s> jogador ao jogo para ele. <br><br>  Por analogia com os zumbis, criaremos um objeto de jogo "Player" (desta vez, selecionaremos um modelo 3d de um policial), tamb√©m adicionaremos o componente NavMeshAgent e o script Player rec√©m-criado.  Ainda n√£o tocaremos no conte√∫do do script Player, mas precisaremos fazer altera√ß√µes no script Zombie.  Al√©m disso, recomendo definir o valor da propriedade Priority do jogador como 10 no componente NavMeshAgent (ou qualquer outro valor menor que o padr√£o 50, ou seja, dando ao jogador uma prioridade mais alta).  Nesse caso, se o jogador e os zumbis se encontrarem no mapa, os zumbis n√£o ser√£o capazes de mover o jogador, enquanto o jogador ser√° capaz de empurrar os zumbis para fora. <br><br>  Para perseguir um jogador, um zumbi precisa saber sua posi√ß√£o.  E para isso, precisamos obter um link para ele em nossa classe Zombie usando o m√©todo padr√£o FindObjectOfType.  Tendo lembrado o link, podemos recorrer ao componente de transforma√ß√£o do jogador e pedir a ele o valor da posi√ß√£o.  E para que o zumbi persiga o jogador sempre, e n√£o apenas no in√≠cio do jogo, definiremos uma meta para o NavMeshAgent no m√©todo Update.  Voc√™ obt√©m o seguinte script: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Zombie</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; Player player; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); player = FindObjectOfType&lt;Player&gt;(); } // Update is called once per frame void Update() { navMeshAgent.SetDestination(player.transform.position); } }</span></span></code> </pre> <br>  Execute o jogo e verifique se o zumbi encontrou sua v√≠tima: <br><br><img src="https://habrastorage.org/webt/j3/lv/vc/j3lvvcaltksjiu44tzh-rijewi4.gif"><br><br><h2>  Escape Escape </h2><br>  Nosso jogador est√° de p√© como um √≠dolo.  Isso claramente n√£o o ajudar√° a sobreviver em um mundo t√£o agressivo, ent√£o voc√™ precisa ensin√°-lo a se movimentar pelo mapa. <br><br>  Para fazer isso, precisamos obter informa√ß√µes sobre as teclas pressionadas no Unity.  O m√©todo GetKey da classe Input padr√£o fornece apenas essas informa√ß√µes! <br><br>  NB Em geral, essa maneira de obter informa√ß√µes n√£o √© totalmente can√¥nica.  √â melhor usar o Input.GetAxis e a liga√ß√£o por meio de Project Settings ProjectInput Manager.  Melhor ainda, <a href="https://blogs.unity3d.com/ru/2019/10/14/introducing-the-new-input-system/">novo sistema de entrada</a> .  Mas este artigo acabou sendo muito longo e, portanto, vamos faz√™-lo da maneira mais simples. <br><br>  Abra o script do Player e altere-o da seguinte maneira: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Player</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moveSpeed; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); } // Update is called once per frame void Update() { Vector3 dir = Vector3.zero; if (Input.GetKey(KeyCode.LeftArrow)) dir.z = -1.0f; if (Input.GetKey(KeyCode.RightArrow)) dir.z = 1.0f; if (Input.GetKey(KeyCode.UpArrow)) dir.x = -1.0f; if (Input.GetKey(KeyCode.DownArrow)) dir.x = 1.0f; navMeshAgent.velocity = dir.normalized * moveSpeed; } }</span></span></code> </pre> <br>  Como no caso de zumbis, no m√©todo Start, obtemos um link para o componente NavMeshAgent do jogador e o armazenamos no campo da classe.  Mas agora tamb√©m adicionamos o campo moveSpeed. <br>  Como esse campo √© p√∫blico, seu valor pode ser editado diretamente no Inspetor na Unity!  Se voc√™ tem um designer de jogos em sua equipe, ele ficar√° muito feliz por n√£o precisar entrar no c√≥digo para editar os par√¢metros do jogador. <br><br>  Defina 10 como velocidade: <br><br><img src="https://habrastorage.org/webt/o9/ro/cx/o9rocx0w0v3djxjgdt35ca59aug.gif"><br><br>  No m√©todo Update, usaremos Input.GetKey para verificar se alguma das setas do teclado est√° pressionada e formar um vetor de dire√ß√£o para o player.  Observe que usamos as coordenadas X e Z. Isso se deve ao fato de que no Unity o eixo Y olha para o c√©u e a Terra est√° localizada no plano XZ. <br><br>  Depois de formarmos o vetor de dire√ß√£o da dire√ß√£o do movimento dir, normalizamos-na (caso contr√°rio, se o jogador quiser se mover ao longo da diagonal, o vetor ser√° um pouco mais longo que um √∫nico e esse movimento ser√° mais r√°pido do que se mover diretamente) e multiplicar√° pela velocidade do movimento.  O resultado √© passado para navMeshAgent.velocity e o agente far√° o resto. <br><br>  Ao iniciar o jogo, podemos finalmente tentar escapar dos zumbis para um lugar seguro: <br><br><img src="https://habrastorage.org/webt/mn/gv/7w/mngv7wimzjqsdlfja2ghro-ovn8.gif"><br><br>  Para fazer a c√¢mera se mover com o player, vamos escrever outro script simples.  Vamos cham√°-lo de "PlayerCamera": <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PlayerCamera</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Player player; Vector3 offset; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { player = FindObjectOfType&lt;Player&gt;(); offset = transform.position - player.transform.position; } // Update is called once per frame void LateUpdate() { transform.position = player.transform.position + offset; } }</span></span></code> </pre> <br>  O significado desse script deve ser amplamente entendido.  A partir dos recursos - aqui, em vez do Update, usamos o LateUpdate.  Esse m√©todo √© semelhante ao Update, mas √© sempre chamado estritamente ap√≥s a atualiza√ß√£o ter sido conclu√≠da para todos os scripts em cena.  Nesse caso, usamos o LateUpdate, porque √© importante para n√≥s que o NavMeshAgent calcule a nova posi√ß√£o do player antes de mover a c√¢mera.  Caso contr√°rio, pode ocorrer um efeito desagrad√°vel de ‚Äúempurr√£o‚Äù. <br><br>  Se voc√™ agora anexar esse componente ao objeto de jogo "C√¢mera principal" e iniciar o jogo, o personagem do jogador estar√° sempre em destaque! <br><br><h2>  Momento de anima√ß√£o </h2><br>  Por um momento, nos afastamos dos problemas de sobreviv√™ncia nas condi√ß√µes de um apocalipse zumbi e pensamos sobre a arte eterna.  Nossos personagens agora parecem est√°tuas animadas, acionadas por uma for√ßa desconhecida (possivelmente √≠m√£s sob o asfalto).  E eu gostaria que eles parecessem pessoas reais e vivas (e n√£o muito) - eles moveram os bra√ßos e as pernas.  O componente Animator e uma ferramenta chamada Animator Controller nos ajudar√£o com isso. <br><br>  O Animator Controller √© uma m√°quina de estados finitos (m√°quina de estados), onde definimos certos estados (o personagem est√° em p√©, o personagem est√° ativado, o personagem est√° morrendo etc.), anexamos anima√ß√µes a eles e definimos as regras para a transi√ß√£o de um estado para outro.  O Unity mudar√° automaticamente de uma anima√ß√£o para outra assim que a regra correspondente funcionar. <br><br>  Vamos criar um Animator Controller para zumbis.  Para fazer isso, crie o diret√≥rio Animations no projeto (lembre-se da ordem no projeto) e nele - usando o bot√£o direito - Animator Controller.  E vamos cham√°-lo de "zumbi".  Clique duas vezes - e o editor aparecer√° diante de n√≥s: <br><br><img src="https://habrastorage.org/webt/t1/54/ak/t154aknnrk7f0lwdlcmvj69uxqo.png"><br><br>  At√© o momento, n√£o h√° estados aqui, mas existem dois pontos de entrada ("Entrada" e "Qualquer estado") e um ponto de sa√≠da ("Sa√≠da").  Arraste algumas anima√ß√µes dos ativos: <br><br><img src="https://habrastorage.org/webt/xg/cx/gw/xgcxgwkbtqsbqux7cj9y5qnwnk0.gif"><br><br>  Como voc√™ pode ver, assim que arrastamos a primeira anima√ß√£o, o Unity a vinculou automaticamente ao ponto de entrada de entrada.  Essa √© a chamada anima√ß√£o padr√£o.  Ser√° jogado imediatamente ap√≥s o in√≠cio do n√≠vel. <br><br>  Para mudar para um estado diferente (e reproduzir outra anima√ß√£o), precisamos criar regras de transi√ß√£o.  E para isso, em primeiro lugar, precisaremos adicionar um par√¢metro que definiremos no c√≥digo para gerenciar anima√ß√µes. <br><br>  Existem dois bot√µes no canto superior esquerdo da janela do editor: "Camadas" e "Par√¢metros".  Por padr√£o, a guia "Camadas" est√° selecionada, mas precisamos mudar para "Par√¢metros".  Agora podemos adicionar um novo par√¢metro do tipo float usando o bot√£o "+".  Vamos cham√°-lo de "velocidade": <br><br><img src="https://habrastorage.org/webt/po/is/nj/poisnjmj39qel2ofz_meiyginsw.gif"><br><br>  Agora precisamos dizer ao Unity que a anima√ß√£o ‚ÄúZ_run‚Äù deve ser executada quando a velocidade for maior que 0 e ‚ÄúZ_idle_A‚Äù quando a velocidade for zero.  Para fazer isso, precisamos criar duas transi√ß√µes: uma de ‚ÄúZ_idle_A‚Äù para ‚ÄúZ_run‚Äù e a outra na dire√ß√£o oposta. <br><br>  Vamos come√ßar com a transi√ß√£o da ociosidade para a execu√ß√£o.  Clique com o bot√£o direito do mouse no ret√¢ngulo ‚ÄúZ_idle_A‚Äù e selecione ‚ÄúMake Transition‚Äù.  Uma seta aparecer√°, clicando sobre a qual voc√™ pode configurar seus par√¢metros.  Primeiro, voc√™ precisa desmarcar a op√ß√£o "Tem hora de sa√≠da".  Se isso n√£o for feito, a anima√ß√£o mudar√° n√£o de acordo com a nossa condi√ß√£o, mas quando a anterior terminar de jogar.  Como n√£o precisamos disso, desmarcamos.  Em segundo lugar, na parte inferior, na lista de condi√ß√µes ("Condi√ß√µes"), voc√™ precisa clicar em "+" e o Unity adicionar√° uma condi√ß√£o a n√≥s.  Os valores padr√£o neste caso s√£o exatamente o que precisamos: o par√¢metro "speed" deve ser maior que zero para alternar entre ocioso e executado. <br><br><img src="https://habrastorage.org/webt/vt/rw/qy/vtrwqy-jyfhgrai9ruymphu_mwi.gif"><br><br>  Por analogia, criamos uma transi√ß√£o na dire√ß√£o oposta, mas, como condi√ß√£o, agora especificamos "velocidade" menor que 0,0001.  N√£o h√° verifica√ß√µes de igualdade para par√¢metros do tipo float, eles podem ser comparados apenas para mais / menos: <br><br><img src="https://habrastorage.org/webt/vz/ki/bu/vzkibunzaoxqfdfysekucvcqepa.png"><br><br>  Agora voc√™ precisa vincular o controlador ao objeto do jogo.  Selecionaremos o modelo 3d do zumbi na cena (esse √© um filho do objeto "Zumbi") e arrastaremos o controlador com o mouse para o campo correspondente no componente Animator: <br><br><img src="https://habrastorage.org/webt/lr/pv/pq/lrpvpqbl__neecouj3uyxdepqka.gif"><br><br>  Resta apenas escrever um script que controle o par√¢metro speed! <br><br>  Crie o script MovementAnimator com o seguinte conte√∫do: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.AI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementAnimator</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { NavMeshAgent navMeshAgent; Animator animator; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { navMeshAgent = GetComponent&lt;NavMeshAgent&gt;(); animator = GetComponentInChildren&lt;Animator&gt;(); } // Update is called once per frame void Update() { animator.SetFloat("speed", navMeshAgent.velocity.magnitude); } }</span></span></code> </pre> <br>  Aqui n√≥s, como em outros scripts, no m√©todo Start, obtemos acesso ao NavMeshAgent.  Tamb√©m temos acesso ao componente Animator, mas como anexaremos o componente ‚ÄúMovementAnimator‚Äù ao objeto de jogo ‚ÄúZombie‚Äù e o Animator estiver no objeto filho, em vez de GetComponent, precisamos usar o m√©todo padr√£o GetComponentInChildren. <br><br>  No m√©todo Update, solicitamos ao NavMeshAgent seu vetor de velocidade, calculamos seu comprimento e passamos ao animador como par√¢metro de velocidade.  Sem m√°gica, tudo na ci√™ncia! <br><br>  Agora adicione o componente MovementAnimator ao objeto do jogo Zombie e, se o jogo iniciar, vemos que os zumbis agora est√£o animados: <br><br><img src="https://habrastorage.org/webt/uz/da/yt/uzdaytgsxzstqj8rnzx11rfa8ti.gif"><br><br>  Observe que, uma vez que colocamos o c√≥digo de controle do animador em um componente separado do MovementAnimation, ele pode ser facilmente adicionado ao player.  Nem precisamos criar um controlador a partir do zero - voc√™ pode copiar um controlador zumbi (isso pode ser feito selecionando o arquivo "Zumbi" e pressionando Ctrl + D) e substituir as anima√ß√µes nos ret√¢ngulos de estado por "m_idle_" e "m_run".  Tudo o resto √© como um zumbi.  Vou deixar isso para voc√™ como um exerc√≠cio (bem, ou fa√ßa o download do c√≥digo no final do artigo). <br><br>  Uma pequena adi√ß√£o que √© √∫til fazer √© adicionar as seguintes linhas √† classe Zombie: <br><br>  No m√©todo Iniciar: <br><br><pre> <code class="cs hljs">navMeshAgent.updateRotation = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  No m√©todo Update: <br><br><pre> <code class="cs hljs">transform.rotation = Quaternion.LookRotation(navMeshAgent.velocity.normalized);</code> </pre> <br>  A primeira linha diz ao NavMeshAgent que ele n√£o deve controlar a rota√ß√£o do personagem, n√≥s faremos isso sozinhos.  A segunda linha define a vez do personagem na mesma dire√ß√£o em que seu movimento √© direcionado.  O NavMeshAgent, por padr√£o, interpola o √¢ngulo de rota√ß√£o do personagem e isso n√£o parece muito bom (o zumbi gira mais devagar do que muda a dire√ß√£o do movimento).  A adi√ß√£o dessas linhas remove esse efeito. <br><br>  NB Utilizamos o quaternion para especificar a rota√ß√£o.  Nos gr√°ficos tridimensionais, as principais maneiras de especificar a rota√ß√£o de um objeto s√£o √¢ngulos de Euler, matrizes de rota√ß√£o e quaternions.  Os dois primeiros nem sempre s√£o f√°ceis de usar e tamb√©m est√£o sujeitos a um efeito desagrad√°vel como o "Gimbal Lock".  Os quaterni√µes s√£o privados dessa desvantagem e agora s√£o usados ‚Äã‚Äãquase universalmente.  O Unity fornece ferramentas convenientes para trabalhar com quaternions (assim como com matrizes e √¢ngulos de Euler), o que permite que voc√™ n√£o entre nos detalhes do dispositivo desse aparato matem√°tico. <br><br><h2>  Eu vejo o objetivo </h2><br>  √ìtimo, agora podemos escapar dos zumbis.  Mas isso n√£o basta, mais cedo ou mais tarde um segundo zumbi aparecer√°, depois um terceiro, quinto, d√©cimo ... mas voc√™ n√£o pode simplesmente fugir da multid√£o.  Para sobreviver, voc√™ tem que matar.  Al√©m disso, o jogador j√° tem uma arma na m√£o. <br><br>  Para que o jogador possa atirar, voc√™ precisa dar a ele a oportunidade de escolher um alvo.  Para fazer isso, coloque o cursor controlado pelo mouse no ch√£o. <br><br>  Na tela, o cursor do mouse se move no espa√ßo bidimensional - a superf√≠cie do monitor.  Ao mesmo tempo, nossa cena do jogo √© tridimensional.  O observador v√™ a cena atrav√©s dos olhos, onde todos os raios de luz convergem em um ponto.  Combinando todos esses raios, obtemos uma pir√¢mide de visibilidade: <br><br><img src="https://habrastorage.org/webt/hl/bg/p5/hlbgp55snbpv2cxacycfmxbd_hw.png"><br><br>  O olho do observador v√™ apenas o que cai nesta pir√¢mide.  Al√©m disso, o mecanismo trunca especificamente essa pir√¢mide de dois lados: primeiro, do lado do observador, h√° uma tela de monitor, o chamado ‚Äúplano pr√≥ximo‚Äù (na figura √© pintado em amarelo).  O monitor n√£o pode exibir objetos fisicamente mais perto do que a tela, ent√£o o mecanismo os interrompe.  Em segundo lugar, como o computador possui uma quantidade finita de recursos, o mecanismo n√£o pode estender os raios at√© o infinito (por exemplo, um determinado intervalo de valores poss√≠veis deve ser definido para o buffer de profundidade; al√©m disso, quanto maior for, menor a precis√£o), ent√£o a pir√¢mide √© cortada atr√°s do chamado "Avi√£o distante". <br><br>  Como o cursor do mouse se move ao longo do plano pr√≥ximo, podemos liberar o raio do ponto em que ele est√° localizado profundamente na cena.  O primeiro objeto com o qual ele se cruza ser√° o objeto que o cursor do mouse aponta para o ponto de vista do observador. <br><br><img src="https://habrastorage.org/webt/rd/xf/kn/rdxfkn9vevlzr8qz5qtronl05vi.png"><br><br>  Para construir um raio e encontrar sua interse√ß√£o com objetos na cena, voc√™ pode usar o m√©todo Raycast padr√£o da classe Physics.  Mas se usarmos esse m√©todo, ele encontrar√° a interse√ß√£o com todos os objetos da cena - terra, paredes, zumbis ... Mas queremos que o cursor se mova apenas no ch√£o, por isso precisamos explicar de alguma forma √† Unity que a busca pela interse√ß√£o deve ser limitada apenas um determinado conjunto de objetos (no nosso caso, apenas os planos da terra). <br><br>  Se voc√™ selecionar qualquer objeto de jogo na cena, na parte superior do inspetor poder√° ver a lista suspensa "Camada".  Por padr√£o, haver√° um valor "Padr√£o".  Ao abrir a lista suspensa, voc√™ pode encontrar o item "Adicionar camada ...", que abrir√° a janela do editor de camadas.  No editor, voc√™ precisa adicionar uma nova camada (vamos cham√°-la de "Ground"): <br><br><img src="https://habrastorage.org/webt/3w/5g/pc/3w5gpczarjjyhhtombqxbxq68wk.gif"><br><br>  Agora voc√™ pode selecionar todos os planos de solo na cena e usar esta lista suspensa para atribuir a eles a camada de solo.  Isso nos permitir√° indicar no script para o m√©todo Physics.Raycast que √© necess√°rio verificar a interse√ß√£o da viga apenas com esses objetos. <br><br>  Agora vamos arrastar o sprite do cursor dos recursos para a cena (eu uso Spags Assets‚á®Textures‚á®Demo‚á®white_hip‚á®white_hip_14): <br><br><img src="https://habrastorage.org/webt/ha/mw/aa/hamwaarhcaodn7q-y-e5qkps5kc.gif"><br><br>  Adicionei uma rota√ß√£o de 90 graus ao redor do eixo X ao cursor para que ele ficasse horizontalmente no ch√£o, defina a escala para 0,25 para que n√£o seja t√£o grande e defina a coordenada Y para 0,01.  Este √∫ltimo √© importante para que n√£o haja efeito chamado ‚Äúcombate ao Z‚Äù.  A placa de v√≠deo usa c√°lculos de ponto flutuante para determinar quais objetos est√£o mais pr√≥ximos da c√¢mera.  Se voc√™ definir o cursor como 0 (ou seja, o mesmo do plano de terra), devido a erros nesses c√°lculos, para alguns pixels, a placa de v√≠deo decidir√° que o cursor est√° mais pr√≥ximo e, para outros, que a Terra.  Al√©m disso, em quadros diferentes, os conjuntos de pixels ser√£o diferentes, o que criar√° um efeito desagrad√°vel de partes brilhantes do cursor no ch√£o e "tremeluzir" quando ele se mover.  O valor de 0,01 √© grande o suficiente para compensar os erros no c√°lculo da placa de v√≠deo, mas n√£o t√£o grande que o olho percebeu que o cursor estava suspenso no ar. <br><br>  Agora renomeie o objeto do jogo para Cursor e crie um script com o mesmo nome e o seguinte conte√∫do: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Cursor</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { SpriteRenderer spriteRenderer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> layerMask; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { spriteRenderer = GetComponent&lt;SpriteRenderer&gt;(); layerMask = LayerMask.GetMask("Ground"); } // Update is called once per frame void Update() { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; if (!Physics.Raycast(ray, out hit, 1000, layerMask)) spriteRenderer.enabled = false; else { transform.position = new Vector3(hit.point.x, transform.position.y, hit.point.z); spriteRenderer.enabled = true; } } }</span></span></code> </pre> <br>  Como o cursor √© um sprite (desenho bidimensional), o Unity usa o componente SpriteRenderer para renderiz√°-lo.  Obtemos um link para esse componente no m√©todo Start para poder ativ√°-lo / desativ√°-lo conforme necess√°rio. <br><br>  Tamb√©m no m√©todo Start, convertemos o nome da camada "Ground" que criamos anteriormente em uma m√°scara de bit.  O Unity usa opera√ß√µes bit a bit para filtrar objetos ao procurar interse√ß√µes, e o m√©todo LayerMask.GetMask retorna a m√°scara de bit correspondente √† camada especificada. <br><br>  No m√©todo Update, acessamos a c√¢mera principal da cena usando Camera.main e solicitamos que recalcule as coordenadas bidimensionais do mouse (obtidas usando Input.mousePosition) em um raio tridimensional.  Em seguida, passamos esse raio para o m√©todo Physics.Raycast e verificamos se ele se cruza com algum objeto na cena.  Um valor de 1000 √© a dist√¢ncia m√°xima.  Em matem√°tica, os raios s√£o infinitos, mas os recursos de computa√ß√£o e a mem√≥ria de um computador n√£o s√£o.  Portanto, a Unidade nos pede para determinar uma dist√¢ncia m√°xima razo√°vel. <br><br>  Se n√£o houver interse√ß√£o, desligamos o SpriteRenderer e a imagem do cursor desaparece da tela.  Se a interse√ß√£o foi encontrada, movemos o cursor para o ponto de interse√ß√£o.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que n√£o alteramos a coordenada Y, porque o ponto de interse√ß√£o do raio com o solo ter√° Y igual a zero e, atribuindo-o ao nosso cursor, obtemos novamente o efeito Z-fighting, do qual tentamos nos livrar acima. </font><font style="vertical-align: inherit;">Portanto, tomamos apenas as coordenadas X e Z do ponto de interse√ß√£o e Y permanece o mesmo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione o componente Cursor ao objeto de jogo Cursor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, vamos finalizar o script Player: primeiro, adicione o campo do cursor Cursor. </font><font style="vertical-align: inherit;">Em seguida, no m√©todo Iniciar, adicione as seguintes linhas:</font></font><br><br><pre> <code class="cs hljs">cursor = FindObjectOfType&lt;Cursor&gt;(); navMeshAgent.updateRotation = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E, finalmente, para que o player sempre gire em dire√ß√£o ao cursor, no m√©todo Update, adicione: </font></font><br><br><pre> <code class="cs hljs">Vector3 forward = cursor.transform.position - transform.position; transform.rotation = Quaternion.LookRotation(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(forward.x, <span class="hljs-number"><span class="hljs-number">0</span></span>, forward.z));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui tamb√©m n√£o levamos em considera√ß√£o a coordenada Y. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atire para sobreviver </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O simples fato de virar para o cursor n√£o nos proteger√° de zumbis, mas apenas aliviar√° o personagem do jogador do efeito de surpresa - agora voc√™ n√£o pode se esconder atr√°s dele. Para que ele possa realmente sobreviver nas duras realidades do nosso jogo, voc√™ precisa ensin√°-lo a atirar. E que tipo de cena √© essa se n√£o estiver vis√≠vel? Todo mundo sabe que qualquer atirador respeit√°vel sempre dispara em balas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crie um objeto de jogo Shot e adicione o componente LineRenderer padr√£o. Usando o campo "Largura" no editor, forne√ßa uma largura pequena, por exemplo, 0,04. Como podemos ver, o Unity o pinta com uma cor p√∫rpura brilhante - dessa maneira objetos sem material s√£o real√ßados.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os materiais s√£o um elemento importante de qualquer mecanismo tridimensional. O uso de materiais descreve a apar√™ncia do objeto. Todos os par√¢metros de ilumina√ß√£o, texturas, shaders - tudo isso √© descrito pelo material. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos criar o diret√≥rio Materials no projeto e dentro dele o material, vamos cham√°-lo de Yellow. Como um sombreador, selecione Apagado / Cor. Esse shader padr√£o n√£o inclui ilumina√ß√£o, portanto nossa bala ficar√° vis√≠vel mesmo no escuro. Selecione a cor amarela: </font></font><br><br><img src="https://habrastorage.org/webt/en/pt/im/enptimmi5wn6-9f5ssbqzh2fxko.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora que o material foi criado, voc√™ pode atribu√≠-lo ao LineRenderer: </font></font><br><br><img src="https://habrastorage.org/webt/ow/qr/31/owqr314ai0hyyfx-hswunci5lzs.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Criar um script Shot:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Shot</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { LineRenderer lineRenderer; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> visible; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { lineRenderer = GetComponent&lt;LineRenderer&gt;(); } // Update is called once per frame void FixedUpdate() { if (visible) visible = false; else gameObject.SetActive(false); } public void Show(Vector3 from, Vector3 to) { lineRenderer.SetPositions(new Vector3[]{ from, to }); visible = true; gameObject.SetActive(true); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse script, como voc√™ provavelmente j√° adivinhou, precisa ser adicionado ao objeto do jogo Shot. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui, usei um pequeno truque para exibir uma foto na tela para exatamente um quadro com o m√≠nimo de c√≥digo. Primeiro, eu uso o FixedUpdate em vez do Update. O m√©todo FixedUpdate √© chamado na frequ√™ncia especificada (por padr√£o - 60 quadros por segundo), mesmo que a taxa de quadros real seja inst√°vel. Em segundo lugar, defino a vari√°vel vis√≠vel, que defini como verdadeira quando mostro a foto na tela. No pr√≥ximo FixedUpdate, redefino-o para false e somente no pr√≥ximo quadro desativo o objeto do jogo da foto. Essencialmente, eu uso uma vari√°vel booleana como um contador de 1 a 0.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O m√©todo gameObject.SetActive ativa ou desativa todo o objeto do jogo no qual nosso componente est√° localizado. Os objetos do jogo desativados n√£o s√£o desenhados na tela e seus componentes n√£o chamam os m√©todos Update, FixedUpdate etc. O uso desse m√©todo permite tornar a foto invis√≠vel quando o jogador n√£o est√° fotografando. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√° tamb√©m um m√©todo Show p√∫blico no script, que usaremos no script Player para realmente exibir o marcador quando disparado.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas primeiro voc√™ precisa ser capaz de obter as coordenadas do cano da arma para que o tiro saia do buraco correto. </font><font style="vertical-align: inherit;">Para fazer isso, localize o objeto Bip001‚á®Bip001 Pelvis‚á®Bip001 SpBip001R Clav√≠cula‚á®Bip001R UpperArmArBip001R Antebra√ßoipBip001R Hand‚á®R_hand_container‚á®w_handgun no modelo 3d do jogador e adicione o objeto filho GunBarrel. </font><font style="vertical-align: inherit;">Coloque-o de forma que fique ao lado do cano da arma: </font></font><br><br><img src="https://habrastorage.org/webt/kc/qc/ix/kcqcixwjeh_nf2qxqa6c7iriekk.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, no script Player, adicione os campos:</font></font><br><br><pre> <code class="cs hljs">Shot shot; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform gunBarrel;</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adicione ao m√©todo Start do script Player: </font></font><br><br><pre> <code class="cs hljs">shot = FindObjectOfType&lt;Shot&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E no m√©todo Update: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> = gunBarrel.position; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = cursor.transform.position; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> to = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(target.x, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.y, target.z); shot.Show(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, to); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como voc√™ pode imaginar, o campo p√∫blico adicionado gunBarrel, como o moveSpeed ‚Äã‚Äãanterior, estar√° dispon√≠vel no Inspetor. Vamos atribuir a ele o objeto de jogo real que criamos: </font></font><br><br><img src="https://habrastorage.org/webt/r2/3p/6g/r23p6g9wgzes9qh_fg8l41txjqs.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se agora iniciarmos o jogo, podemos finalmente atirar nos zumbis! </font></font><br><br><img src="https://habrastorage.org/webt/gj/ek/sx/gjeksxqnsbieryc_qrv07cyqm44.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algo est√° errado aqui! Parece que os tiros n√£o matam zumbis, mas simplesmente voam atrav√©s dele! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, √© claro, se voc√™ olhar para o nosso c√≥digo de tiro, n√£o rastrearemos de forma alguma se nosso tiro atingiu o inimigo ou n√£o. Basta desenhar uma linha no cursor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso √© muito f√°cil de corrigir. No c√≥digo para processar cliques do mouse na classe Player, ap√≥s a linha var para = ... e antes da linha shot.Show (...), adicione as seguintes linhas:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> direction = (to - <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>).normalized; RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(<span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, to - <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit, <span class="hljs-number"><span class="hljs-number">100</span></span>)) to = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(hit.point.x, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>.y, hit.point.z); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> to = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> + direction * <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui, usamos o familiar Physics.Raycast para deixar o feixe sair do cano de uma arma e determinar se ele se cruza com qualquer objeto do jogo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui, no entanto, h√° uma ressalva: a bala ainda voar√° pelos zumbis. O fato √© que o autor do ativo adicionou um colisor aos objetos do n√≠vel (edif√≠cios, caixas, etc.). E o autor do ativo com os personagens n√£o. Vamos consertar esse mal entendido irritante.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um colisor √© um componente com o qual o mecanismo de f√≠sica determina colis√µes entre objetos. </font><font style="vertical-align: inherit;">Geralmente, formas geom√©tricas simples s√£o usadas como colisores - cubos, esferas, etc. </font><font style="vertical-align: inherit;">Embora essa abordagem forne√ßa colis√µes menos precisas, as f√≥rmulas de interse√ß√£o entre esses objetos s√£o bastante simples e n√£o requerem grandes recursos computacionais. </font><font style="vertical-align: inherit;">Obviamente, se voc√™ precisar de precis√£o m√°xima, sempre poder√° sacrificar o desempenho e usar o MeshCollider. </font><font style="vertical-align: inherit;">Mas como n√£o precisamos de alta precis√£o, usaremos o componente CapsuleCollider: </font></font><br><br><img src="https://habrastorage.org/webt/wp/t3/qo/wpt3qo9lebty_w7hlawpe11le9u.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora a bala n√£o voar√° pelos zumbis. </font><font style="vertical-align: inherit;">No entanto, os zumbis ainda s√£o imortais.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zumbis - Morte de zumbis! </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos primeiro adicionar uma anima√ß√£o da morte ao zombie Animation Controller. </font><font style="vertical-align: inherit;">Para fazer isso, arraste a anima√ß√£o AssetPacks‚á®ToonyTinyPeople‚á®TT_demo‚á®animation‚á®zombie‚á®Z_death_A para ele. </font><font style="vertical-align: inherit;">Para ativ√°-lo, crie um novo par√¢metro que tenha morrido com o tipo de gatilho. </font><font style="vertical-align: inherit;">Ao contr√°rio de outros par√¢metros (bool, float, etc.), os gatilhos n√£o lembram seu estado e s√£o mais como uma chamada de fun√ß√£o: eles ativaram um gatilho - a transi√ß√£o funcionou e o gatilho foi redefinido. </font><font style="vertical-align: inherit;">E como um zumbi pode morrer em qualquer estado - e se ele ficar parado e estiver em execu√ß√£o, adicionaremos a transi√ß√£o do estado Qualquer Estado: </font></font><br><br><img src="https://habrastorage.org/webt/-a/je/6j/-aje6jc9oteg-glqdrtckbjhv1o.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione os seguintes campos ao script Zombie:</font></font><br><br><pre> <code class="cs hljs">CapsuleCollider capsuleCollider; Animator animator; MovementAnimator movementAnimator; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dead;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No m√©todo Iniciar da classe Zombie, insira: </font></font><br><br><pre> <code class="cs hljs">capsuleCollider = GetComponent&lt;CapsuleCollider&gt;(); animator = GetComponentInChildren&lt;Animator&gt;(); movementAnimator = GetComponent&lt;MovementAnimator&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No in√≠cio do m√©todo Update, voc√™ precisa adicionar uma verifica√ß√£o: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dead) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E, finalmente, adicione o m√©todo p√∫blico Kill √† classe Zombie: </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kill</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dead) { dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; Destroy(capsuleCollider); Destroy(movementAnimator); Destroy(navMeshAgent); animator.SetTrigger(<span class="hljs-string"><span class="hljs-string">"died"</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A atribui√ß√£o de novos campos, eu acho, √© bastante √≥bvia. Quanto ao m√©todo Kill - nele (se n√£o estamos mortos), definimos a bandeira da morte do zumbi e removemos os componentes CapsuleCollider, MovementAnimator e NavMeshAgent do nosso objeto de jogo, ap√≥s o qual ativamos a reprodu√ß√£o da anima√ß√£o da morte do controlador de anima√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que remover componentes? Para que assim que um zumbi morra, ele pare de se mover pelo mapa e n√£o seja mais um obst√°culo para as balas. Para sempre, voc√™ ainda precisa se livrar do corpo de alguma maneira bonita ap√≥s a execu√ß√£o da anima√ß√£o da morte. Caso contr√°rio, os zumbis mortos continuar√£o a corroer os recursos e, quando houver muitos cad√°veres, o jogo diminuir√° notavelmente. A maneira mais f√°cil √© adicionar a chamada Destruir (gameObject, 3) aqui. Isso far√° com que o Unity exclua esse objeto de jogo 3 segundos ap√≥s esta chamada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que tudo isso finalmente funcionasse, o √∫ltimo toque permaneceu. Na classe Player, no m√©todo Update, onde chamamos Physics.Raycast, no ramo do caso em que uma interse√ß√£o foi encontrada, adicionamos uma verifica√ß√£o:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hit.transform != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zombie = hit.transform.GetComponent&lt;Zombie&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zombie != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) zombie.Kill(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Physics.Raycast chama as informa√ß√µes de interse√ß√£o na vari√°vel de ocorr√™ncia. Em particular, no campo de transforma√ß√£o, haver√° um link para o componente Transformar do objeto de jogo com o qual o raio se cruzou. Se este objeto de jogo tiver um componente Zumbi, ele ser√° um zumbi e n√≥s o mataremos. Elementar! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, para que a morte do inimigo pare√ßa espetacular, adicionamos um sistema de part√≠culas simples aos zumbis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os sistemas de part√≠culas permitem controlar um grande n√∫mero de objetos pequenos (geralmente sprites) de acordo com algum tipo de lei f√≠sica ou f√≥rmula matem√°tica. </font><font style="vertical-align: inherit;">Por exemplo, voc√™ pode faz√™-los voar separados ou voar direto para baixo a uma certa velocidade. </font><font style="vertical-align: inherit;">Com a ajuda de sistemas de part√≠culas em jogos, todos os tipos de efeitos s√£o feitos: fogo, fuma√ßa, fa√≠scas, chuva, neve, sujeira sob as rodas, etc. </font><font style="vertical-align: inherit;">Usaremos um sistema de part√≠culas para que, no momento da morte, o sangue espirre de um zumbi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adicione um sistema de part√≠culas ao objeto do jogo Zombie (clique com o bot√£o direito do mouse e selecione Efeitos‚á®Sistema de part√≠culas): </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sugiro as seguintes op√ß√µes: </font></font><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transforma√ß√£o:</font></font></u> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posi√ß√£o: Y 0.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rota√ß√£o: X -90 </font></font></li></ul><br> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistema de part√≠culas</font></font></u> <br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dura√ß√£o: 0.2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Loop: false </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vida √∫til do in√≠cio: 0,8 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tamanho inicial: 0.5 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cor inicial: verde </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modificador de gravidade: 1 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reproduzir acordado: falso </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emiss√£o: </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Taxa ao longo do tempo: 100 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Forma: </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Raio: 0,25 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deve ser algo como isto: </font></font><br><br><img src="https://habrastorage.org/webt/nk/rz/mj/nkrzmjt9wu6gyqt6twhgfkldivo.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resta ativ√°-lo no m√©todo Kill da classe Zombie:</font></font><br><br><pre> <code class="cs hljs">GetComponentInChildren&lt;ParticleSystem&gt;().Play();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E agora uma quest√£o completamente diferente! </font></font><br><br><img src="https://habrastorage.org/webt/av/sl/mf/avslmfkniyguq6m4hxma0j4sqek.gif"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zumbis atacam no rebanho </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, lutar contra um √∫nico zumbi √© chato. </font><font style="vertical-align: inherit;">Voc√™ o matou e √© isso. </font><font style="vertical-align: inherit;">Onde est√° o drama? </font><font style="vertical-align: inherit;">Onde est√° o medo de morrer jovem? </font><font style="vertical-align: inherit;">Para criar uma verdadeira atmosfera de apocalipse e desesperan√ßa, deve haver muitos zumbis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Felizmente, isso √© bem simples. </font><font style="vertical-align: inherit;">Como voc√™ deve ter adivinhado, precisamos de outro script. </font><font style="vertical-align: inherit;">Chame-o de EnemySpawner e preencha-o com o seguinte conte√∫do:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemySpawner</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Period; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject Enemy; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> TimeUntilNextSpawn; <span class="hljs-comment"><span class="hljs-comment">// Start is called before the first frame update void Start() { TimeUntilNextSpawn = Random.Range(0, Period); } // Update is called once per frame void Update() { TimeUntilNextSpawn -= Time.deltaTime; if (TimeUntilNextSpawn &lt;= 0.0f) { TimeUntilNextSpawn = Period; Instantiate(Enemy, transform.position, transform.rotation); } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando o campo p√∫blico Per√≠odo, o designer do jogo pode definir no Inspetor quantas vezes um novo inimigo precisa ser criado. No campo Inimigo, indicamos qual inimigo criar (at√© agora temos apenas um inimigo, mas no futuro podemos adicionar mais). Bem, ent√£o tudo √© simples - usando TimeUntilNextSpawn, contamos quanto tempo resta at√© a pr√≥xima apari√ß√£o do inimigo e, assim que chega a hora, adicionamos um novo zumbi √† cena usando o m√©todo Instantiate padr√£o. Sim, no m√©todo Start, atribu√≠mos um valor aleat√≥rio ao campo TimeUntilNextSpawn, para que, se tivermos v√°rios criadores com o mesmo atraso no n√≠vel, eles n√£o adicionar√£o zumbis ao mesmo tempo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma pergunta permanece: como perguntar ao inimigo no campo Inimigo? Para fazer isso, usaremos uma ferramenta do Unity, como "Prefabs". De fato, uma pr√©-fabricada √© uma parte da cena salva em um arquivo separado. Em seguida, podemos inserir esse arquivo em outras cenas (ou na mesma) e n√£o precisamos colet√°-lo novamente em peda√ßos novamente. Por exemplo, coletamos, dos objetos de paredes, piso, teto, janelas e portas, uma bela casa e a salvamos como uma casa pr√©-fabricada. Agora voc√™ pode inserir esta casa em outros cart√µes com um movimento do pulso. Ao mesmo tempo, se voc√™ editar o arquivo pr√©-fabricado (por exemplo, adicionar uma porta traseira √† casa), o objeto ser√° alterado em todas as cenas. √Äs vezes √© muito conveniente. Tamb√©m podemos usar prefabs como modelos para o Instantiate - e usaremos essa oportunidade agora.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para criar uma pr√©-fabricada, basta arrastar o objeto do jogo da janela da hierarquia para a janela do projeto, o Unity far√° o resto. Vamos criar uma casa pr√©-fabricada a partir de zumbis e, em seguida, adicionar um criador inimigo √† cena: </font></font><br><br><img src="https://habrastorage.org/webt/4i/ka/kx/4ikakx3ollmpndbgcqco8341e8y.gif"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adicionei mais tr√™s criadores no projeto para uma mudan√ßa (ent√£o, no final, tenho quatro deles). E ent√£o, o que aconteceu: </font></font><br><br><img src="https://habrastorage.org/webt/6h/0p/_f/6h0p_fo52j6zqydyml6z9aqlcu0.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui! J√° parece um apocalipse zumbi!</font></font></b> <br><br><h2>  Conclus√£o </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Claro, isso est√° longe de ser um jogo completo. </font><font style="vertical-align: inherit;">N√£o consideramos muitos problemas, como criar uma interface de usu√°rio, sons, vidas e morte de um jogador - tudo isso √© deixado de fora do escopo deste artigo. </font><font style="vertical-align: inherit;">Mas parece-me que este artigo ser√° uma introdu√ß√£o digna ao Unity para aqueles que n√£o est√£o familiarizados com essa ferramenta. </font><font style="vertical-align: inherit;">Ou talvez algu√©m experiente consiga extrair algum truque disso? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, amigos, espero que tenham gostado do meu artigo. </font><font style="vertical-align: inherit;">Escreva suas perguntas nos coment√°rios, tentarei responder. </font><font style="vertical-align: inherit;">O c√≥digo-fonte do projeto pode ser baixado no github: </font></font><a href="https://github.com/zapolnov/otus_zombies"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/zapolnov/otus_zombies</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Voc√™ precisar√° do Unity 2019.3.0f3 ou superior, ele pode ser baixado completamente gratuitamente e sem SMS no site oficial: </font></font><a href="https://store.unity.com/download"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://store.unity.com/download</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Links para ativos usados ‚Äã‚Äãno artigo: </font></font><br><br><ul><li> <a href="https://assetstore.unity.com/packages/3d/environments/industrial/rpg-fps-game-assets-for-pc-mobile-industrial-set-v2-0-86679">https://assetstore.unity.com/packages/3d/environments/industrial/rpg-fps-game-assets-for-pc-mobile-industrial-set-v2-0-86679</a> </li><li> <a href="https://assetstore.unity.com/packages/3d/characters/toony-tiny-people-demo-113188">https://assetstore.unity.com/packages/3d/characters/toony-tiny-people-demo-113188</a> </li><li> <a href="https://assetstore.unity.com/packages/2d/gui/icons/crosshairs-plus-139902">https://assetstore.unity.com/packages/2d/gui/icons/crosshairs-plus-139902</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485210/">https://habr.com/ru/post/pt485210/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485200/index.html">Confus√£o no in√≠cio: post-mortem na velocidade de lan√ßamento de um aplicativo iOS</a></li>
<li><a href="../pt485202/index.html">Sistema de Supress√£o</a></li>
<li><a href="../pt485204/index.html">Retornar ao topo: por que a capitaliza√ß√£o da Amazon em breve exceder√° US $ 1 trilh√£o</a></li>
<li><a href="../pt485206/index.html">Como o Typecript me decepcionou e vale a pena?</a></li>
<li><a href="../pt485208/index.html">Cria√ß√£o de infraestrutura de TI tolerante a falhas. Parte 2. Instalando e configurando o cluster oVirt 4.3</a></li>
<li><a href="../pt485214/index.html">CLRium # 7: Pr√°tico. Semin√°rio, trabalhos de casa com verifica√ß√£o, orienta√ß√£o</a></li>
<li><a href="../pt485218/index.html">Reservando constantes e ganchos Git em C #</a></li>
<li><a href="../pt485220/index.html">A evolu√ß√£o do Web Application Firewall: dos firewalls aos sistemas de seguran√ßa baseados em nuvem de aprendizado de m√°quina</a></li>
<li><a href="../pt485222/index.html">Como trabalhar com l√≠deres de opini√£o na China? Cinco dicas pr√°ticas</a></li>
<li><a href="../pt485224/index.html">Como a entrega de mercadorias est√° abaixo do limite aduaneiro a partir de 1 de janeiro de 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>