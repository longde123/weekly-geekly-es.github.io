<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏾 🍿 🚯 Sebelas Mutiara Tersembunyi di Jawa 11 🧟 🧔 😼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java 11 tidak memperkenalkan fitur inovatif apa pun, tetapi berisi beberapa permata yang mungkin belum pernah Anda dengar. Sudah melihat yang terbaru ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sebelas Mutiara Tersembunyi di Jawa 11</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441154/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java 11</a> tidak memperkenalkan fitur inovatif apa pun, tetapi berisi beberapa permata yang mungkin belum pernah Anda dengar.  Sudah melihat yang terbaru di <code>String</code> , <code>Optional</code> , <code>Collection</code> , dan workhorses lainnya?  Jika tidak, maka Anda telah datang ke alamat: hari ini kita akan melihat 11 permata tersembunyi dari Jawa 11! </p><a name="habracut"></a><br><h3 id="vyvod-tipov-dlya-lyambda-parametrov">  Ketik inferensi untuk parameter lambda </h3><br><p>  Saat menulis ekspresi lambda, Anda dapat memilih di antara jenis yang secara eksplisit menentukan dan melewatkannya: </p><br><pre> <code class="java hljs">Function&lt;String, String&gt; append = string -&gt; string + <span class="hljs-string"><span class="hljs-string">" "</span></span>; Function&lt;String, String&gt; append = (String s) -&gt; s + <span class="hljs-string"><span class="hljs-string">" "</span></span>;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java 10 memperkenalkan</a> <code>var</code> , tetapi tidak bisa digunakan dalam lambdas: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    Java 10 Function&lt;String, String&gt; append = (var string) -&gt; string + " ";</span></span></code> </pre> <br><p>  Di Jawa 11 sudah dimungkinkan.  Tapi mengapa?  Sepertinya <code>var</code> memberikan lebih dari sekadar pass type.  Meskipun demikian, penggunaan <code>var</code> memiliki dua keuntungan kecil: </p><br><ul><li>  membuat penggunaan <code>var</code> lebih universal dengan menghapus pengecualian pada aturan </li><li>  memungkinkan Anda untuk menambahkan anotasi ke tipe parameter tanpa menggunakan nama lengkapnya </li></ul><br><p>  Ini adalah contoh dari kasus kedua: </p><br><pre> <code class="java hljs">List&lt;EnterpriseGradeType&lt;With, Generics&gt;&gt; types = <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>; types .stream() <span class="hljs-comment"><span class="hljs-comment">// ,     @Nonnull   .filter(type -&gt; check(type)) //  Java 10    ~&gt;  .filter((@Nonnull EnterpriseGradeType&lt;With, Generics&gt; type) -&gt; check(type)) //  Java 11    ~&gt;   .filter((@Nonnull var type) -&gt; check(type))</span></span></code> </pre> <br><p>  Meskipun mencampur tipe turunan, eksplisit dan implisit dalam ekspresi lambda dari bentuk <code>(var type, String option, index) -&gt; ...</code> dapat diimplementasikan, tetapi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam kerangka JEP-323</a> ) pekerjaan ini tidak dilakukan.  Oleh karena itu, perlu untuk memilih salah satu dari tiga pendekatan dan mematuhinya untuk semua parameter ekspresi lambda.  Kebutuhan untuk menentukan <code>var</code> untuk semua parameter untuk menambahkan anotasi untuk salah satunya dapat sedikit mengganggu, tetapi secara umum dapat ditoleransi. </p><br><h3 id="potokovaya-obrabotka-strok-s-stringlines">  Aliran pemrosesan string dengan <code>'String::lines'</code> </h3><br><p>  Punya string multi-line?  Ingin melakukan sesuatu dengan setiap barisnya?  Maka <code>String::lines</code> adalah pilihan yang tepat: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> multiline = <span class="hljs-string"><span class="hljs-string">"\r\n\r\n\r\n"</span></span>; multiline .lines() <span class="hljs-comment"><span class="hljs-comment">//Stream&lt;String&gt; .map(line -&gt; "// " + line) .forEach(System.out::println); // : //  //  //  // </span></span></code> </pre> <br><p>  Perhatikan bahwa baris asli menggunakan pembatas sekrup <code>\r\n</code> dan meskipun saya di Linux, <code>lines()</code> masih mematahkannya.  Hal ini disebabkan oleh fakta bahwa, terlepas dari OS saat ini, metode ini mengartikan <code>\r</code> , <code>\n</code> , dan <code>\r\n</code> sebagai jeda baris - bahkan jika mereka dicampur pada baris yang sama. </p><br><p>  Aliran garis tidak pernah mengandung pemisah garis itu sendiri.  Baris dapat kosong ( <code>"\n\n \n\n"</code> , yang berisi 5 baris), tetapi baris terakhir dari baris asli diabaikan jika kosong ( <code>"\n\n"</code> ; 2 baris).  <em>(Catatan oleh penerjemah: lebih mudah bagi mereka untuk memiliki <code>line</code> , tetapi untuk memiliki <code>string</code> , dan kami memiliki keduanya.)</em> </p><br><p>  Tidak seperti <code>split("\R")</code> , <code>lines()</code> malas dan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya kutip</a> , "memberikan kinerja yang lebih baik [...] dengan lebih cepat mencari jeda baris baru".  (Jika seseorang ingin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengajukan</a> tolok ukur pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JMH</a> untuk verifikasi, beri tahu saya).  Ini juga lebih baik mencerminkan algoritma pemrosesan dan menggunakan struktur data yang lebih nyaman (stream bukan array). </p><br><h3 id="udalenie-probelnyh-simvolov-s-stringstrip-i-tp">  Menghapus spasi dengan <code>'String::strip'</code> , dll. </h3><br><p>  Awalnya, <code>String</code> memiliki metode <code>trim</code> untuk menghapus spasi, yang dianggap semuanya dengan kode hingga <code>U+0020</code> .  Ya, <code>BACKSPACE</code> ( <code>U+0008)</code> adalah ruang putih seperti <code>BELL</code> ( <code>U+0007</code> ), tetapi <code>LINE SEPARATOR</code> ( <code>U+2028</code> ) tidak lagi dianggap seperti itu. </p><br><p>  Java 11 memperkenalkan metode <code>strip</code> , yang pendekatannya memiliki lebih banyak nuansa.  Ia menggunakan metode <code>Character::isWhitespace</code> dari Java 5 untuk menentukan apa yang sebenarnya perlu dihapus.  Dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasinya</a> jelas bahwa ini: </p><br><ul><li>  <code>SPACE SEPARATOR</code> , <code>LINE SEPARATOR</code> , <code>PARAGRAPH SEPARATOR</code> , tetapi bukan ruang yang tidak bisa dipisahkan </li><li>  <code>HORIZONTAL TABULATION</code> ( <code>U+0009</code> ), <code>LINE FEED</code> ( <code>U+000A</code> ), <code>VERTICAL TABULATION</code> ( <code>U+000B</code> ), <code>FORM FEED</code> ( <code>U+000C</code> ), <code>CARRIAGE RETURN</code> <code>U+000D</code> ( <code>U+000D</code> ) </li><li>  <code>FILE SEPARATOR</code> ( <code>U+001C</code> ), <code>GROUP SEPARATOR</code> ( <code>U+001D</code> ), <code>RECORD SEPARATOR</code> ( <code>U+001E</code> ), <code>UNIT SEPARATOR</code> ( <code>U+001F</code> ) </li></ul><br><p>  Dengan logika yang sama, ada dua metode pembersihan lagi, <code>stripLeading</code> dan <code>stripTailing</code> , yang melakukan apa yang diharapkan dari mereka. </p><br><p>  Dan akhirnya, jika Anda hanya perlu mencari tahu apakah garis menjadi kosong setelah menghapus spasi, maka tidak perlu untuk benar-benar menghapusnya - cukup gunakan <code>isBlank</code> : </p><br><pre> <code class="java hljs"><span class="hljs-string"><span class="hljs-string">" "</span></span>.isBlank(); <span class="hljs-comment"><span class="hljs-comment">//  ~&gt; true " ".isBlank(); //   ~&gt; false</span></span></code> </pre> <br><h3 id="povtorenie-strok-s-stringrepeat">  Mengulang string dengan <code>'String::repeat'</code> </h3><br><p>  Tangkap idenya: </p><br><h6 id="shag-1-pristalno-sledim-za-razvitiem-jdk">  Langkah 1: Menyimpan Arloji di JDK </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/874/8df/a06/8748dfa06086f57aae4b16686d9c6c04.png" alt="Mengawasi perkembangan JDK"></p><br><h6 id="shag-2-razyskivaem-na-stackoverflow-svyazannye-voprosy">  Langkah 2: Menemukan Pertanyaan Terkait StackOverflow </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/df2/3f8/7ae/df23f87ae8d723f53beb5617017de913.png" alt="Mencari pertanyaan terkait di Stackoverflow"></p><br><h6 id="shag-3-priletaem-s-novym-otvetom-osnovannym-na-buduschih-izmeneniyah">  Langkah 3: Tiba dengan jawaban baru berdasarkan perubahan di masa depan </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b68/556/748/b685567487db2b1ea3cab180b8f39089.png" alt="Masuk dengan jawaban baru berdasarkan perubahan yang akan datang"></p><br><h6 id="shag-4-">  Langkah 4: ???? </h6><br><h6 id="shag-4-profit">  Langkah 4: Untung </h6><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/695/015/36969501570588225baae6cd5dd3edb1.gif" alt="¯ \ _ (ツ) _ / ¯"></p><br><p>  Seperti yang dapat Anda bayangkan, <code>String</code> memiliki metode <code>repeat(int)</code> .  Ia bekerja persis sesuai dengan harapan, dan ada sedikit untuk didiskusikan. </p><br><h3 id="sozdanie-putey-s-pathof">  Membuat jalur dengan <code>'Path::of'</code> </h3><br><p>  Saya sangat suka <code>Path</code> API, tetapi mengubah jalur di antara tampilan yang berbeda (seperti <code>Path</code> , <code>File</code> , <code>URL</code> , <code>URI</code> dan <code>String</code> ) masih mengganggu.  Poin ini menjadi kurang membingungkan di Java 11 dengan menyalin dua <code>Paths::get</code> methods ke <code>Path::of</code> methods: </p><br><pre> <code class="java hljs">Path tmp = Path.of(<span class="hljs-string"><span class="hljs-string">"/home/nipa"</span></span>, <span class="hljs-string"><span class="hljs-string">"tmp"</span></span>); Path codefx = Path.of(URI.create(<span class="hljs-string"><span class="hljs-string">"http://codefx.org"</span></span>));</code> </pre> <br><p>  Mereka dapat dianggap kanonik, karena kedua <code>Paths::get</code> methods lama menggunakan opsi baru. </p><br><h3 id="chtenie-i-zapis-faylov-s-filesreadstring-i-fileswritestring">  Membaca dan menulis file dengan <code>'Files::readString'</code> dan <code>'Files::writeString'</code> </h3><br><p>  Jika saya perlu membaca dari file besar, saya biasanya menggunakan <code>Files::lines</code> untuk mendapatkan aliran malas dari barisnya.  Demikian pula, untuk menulis sejumlah besar data yang mungkin tidak disimpan dalam memori secara keseluruhan, saya menggunakan <code>Files::write</code> meneruskannya sebagai <code>Iterable&lt;String&gt;</code> . </p><br><p>  Tapi bagaimana dengan kasus sederhana ketika saya ingin memproses isi file sebagai satu baris?  Ini sangat tidak nyaman, karena <code>Files::readAllBytes</code> dan varian <code>Files::write</code> beroperasi pada array byte. </p><br><p>  Dan kemudian Java 11 muncul, menambahkan <code>readString</code> dan <code>writeString</code> ke <code>Files</code> : </p><br><pre> <code class="java hljs">String haiku = Files.readString(Path.of(<span class="hljs-string"><span class="hljs-string">"haiku.txt"</span></span>)); String modified = modify(haiku); Files.writeString(Path.of(<span class="hljs-string"><span class="hljs-string">"haiku-mod.txt"</span></span>), modified);</code> </pre> <br><p>  Jelas dan mudah digunakan.  Jika perlu, Anda bisa meneruskan <code>Charset</code> ke <code>readString</code> , dan di <code>writeString</code> juga sebuah array <code>OpenOptions</code> . </p><br><h3 id="pustoe-io-s-readernullreader-i-tp">  Kosong I / O dengan <code>'Reader::nullReader'</code> , dll. </h3><br><p>  Perlu <code>OutputStream</code> yang tidak menulis di mana pun?  Atau <code>InputStream</code> kosong?  Bagaimana dengan <code>Reader</code> dan <code>Writer</code> yang tidak melakukan apa-apa?  Java 11 memiliki semuanya: </p><br><pre> <code class="java hljs">InputStream input = InputStream.nullInputStream(); OutputStream output = OutputStream.nullOutputStream(); Reader reader = Reader.nullReader(); Writer writer = Writer.nullWriter();</code> </pre> <br><p>  <em>(Catatan Penerjemah: di <code>commons-io</code> kelas-kelas ini telah ada sejak sekitar 2014).</em> </p><br><p>  Namun, saya terkejut - apakah <code>null</code> benar-benar awalan terbaik?  Saya tidak suka bagaimana ini berarti "ketidakhadiran disengaja" ... Mungkin lebih baik menggunakan <code>noOp</code> ?  <em>(Catatan Penerjemah: kemungkinan besar awalan ini dipilih karena penggunaan umum <code>/dev/null</code> .)</em> </p><br><h3 id="-----s-collectiontoarray">  <code>{ } ~&gt; [ ]</code> dengan <code>'Collection::toArray'</code> </h3><br><p>  Bagaimana Anda mengonversi koleksi ke array? </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  Java 11 List&lt;String&gt; list = /*...*/; Object[] objects = list.toArray(); String[] strings_0 = list.toArray(new String[0]); String[] strings_size = list.toArray(new String[list.size()]);</span></span></code> </pre> <br><p>  Opsi pertama, <code>objects</code> , kehilangan semua informasi tentang jenis, sehingga sedang dalam penerbangan.  Bagaimana dengan yang lainnya?  Keduanya tebal, tetapi yang pertama lebih pendek.  Yang terakhir menciptakan array ukuran yang diperlukan, sehingga terlihat lebih produktif (yaitu, "tampaknya lebih produktif", lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kredibilitas</a> ).  Tetapi apakah ini benar-benar lebih produktif?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tidak, sebaliknya, itu lebih lambat</a> (saat ini). </p><br><p>  Tetapi mengapa saya harus peduli tentang ini?  Apakah tidak ada cara yang lebih baik untuk melakukan ini?  Di Jawa 11 ada: </p><br><pre> <code class="java hljs">String[] strings_fun = list.toArray(String[]::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>);</code> </pre> <br><p>  Varian baru <code>Collection::toArray</code> , yang menerima <code>IntFunction&lt;T[]&gt;</code> , yaitu.  fungsi yang menerima ukuran array dan mengembalikan array ukuran yang diperlukan.  Ini dapat secara singkat dinyatakan sebagai referensi ke konstruktor dari bentuk <code>T[]::new</code> (untuk <code>T</code> terkenal). </p><br><p>  Fakta menarik, implementasi default <code>Collection#toArray(IntFunction&lt;T[]&gt;)</code> selalu melewati <code>0</code> ke generator array.  Pada awalnya, saya memutuskan bahwa solusi ini didasarkan pada kinerja terbaik untuk array dengan panjang nol, tetapi sekarang saya berpikir bahwa alasannya mungkin karena beberapa koleksi, menghitung ukuran bisa menjadi operasi yang sangat mahal dan Anda tidak boleh menggunakan pendekatan ini dalam implementasi default <code>Collection</code> .  Namun, implementasi koleksi tertentu, seperti <code>ArrayList</code> , dapat mengubah pendekatan ini, tetapi mereka tidak berubah di Java 11.  Tidak layak, kurasa. </p><br><h3 id="proverka-otsutstviya-s-optionalisempty">  Tidak ada pemeriksaan dengan <code>'Optional::isEmpty'</code> </h3><br><p>  Dengan banyaknya penggunaan <code>Optional</code> , terutama dalam proyek-proyek besar, di mana Anda sering menghadapi pendekatan non- <code>Optional</code> , Anda sering harus memeriksa apakah itu memiliki nilai.  Ada metode <code>Optional::isPresent</code> untuk ini.  Tetapi sama sering Anda perlu tahu sebaliknya - bahwa <code>Optional</code> kosong.  Tidak masalah, cukup gunakan <code>!opt.isPresent()</code> , kan? </p><br><p>  Tentu saja, itu mungkin, tetapi hampir selalu lebih mudah untuk memahami logika <code>if</code> kondisinya tidak terbalik.  Dan kadang-kadang <code>Optional</code> muncul di akhir rantai panjang panggilan dan jika Anda perlu memeriksanya secara gratis, maka Anda harus bertaruh <code>!</code>  di awal: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needsToCompleteAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !getAddressRepository() .findAddressFor(user) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::canonicalize) .filter(Address::isComplete) .isPresent(); }</code> </pre> <br><p>  Kalau begitu, lewati saja <code>!</code>  sangat mudah.  Mulai dengan Java 11 ada opsi yang lebih baik: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">needsToCompleteAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getAddressRepository() .findAddressFor(user) .map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::canonicalize) .filter(Address::isComplete) .isEmpty(); }</code> </pre> <br><h3 id="invertirovanie-predikatov-s-predicatenot">  Menolak predikat dengan <code>'Predicate::not'</code> </h3><br><p>  Berbicara tentang pembalikan ... Antarmuka <code>Predicate</code> memiliki <code>negate</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instance</a> <code>negate</code> : mengembalikan predikat baru yang melakukan pemeriksaan yang sama, tetapi membalikkan hasilnya.  Sayangnya, saya jarang berhasil menggunakannya ... </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      Stream .of("a", "b", "", "c") // ,  ~&gt;        .filter(s -&gt; !s.isBlank()) //          ~&gt;  .filter((String::isBlank).negate()) // ,  ~&gt;       .filter(((Predicate&lt;String&gt;) String::isBlank).negate()) .forEach(System.out::println);</span></span></code> </pre> <br><p>  Masalahnya adalah saya jarang memiliki akses ke instance <code>Predicate</code> .  Lebih sering, saya ingin mendapatkan instance seperti itu melalui tautan ke suatu metode (dan membalikkannya), tetapi agar ini berfungsi, kompiler harus tahu apa yang harus dibawa ke metode referensi - tanpa itu, ia tidak dapat melakukan apa-apa.  Dan ini persis apa yang terjadi jika Anda menggunakan <code>(String::isBlank).negate()</code> : kompiler tidak lagi tahu apa yang harus <code>String::isBlank</code> pada ini dan menyerah.  Kasta yang ditentukan dengan benar memperbaikinya, tetapi berapa biayanya? </p><br><p>  Meski ada solusi sederhana.  Jangan gunakan <code>negate</code> instance <code>negate</code> , tetapi gunakan metode statis baru <code>Predicate.not(Predicate&lt;T&gt;)</code> dari Java 11: </p><br><pre> <code class="java hljs">Stream .of(<span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-string"><span class="hljs-string">"b"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   `java.util.function.Predicate.not` .filter(not(String::isBlank)) .forEach(System.out::println);</span></span></code> </pre> <br><p>  Sudah lebih baik! </p><br><h3 id="regulyarnye-vyrazheniya-kak-predikat-s-patternasmatchpredicate">  Ekspresi reguler sebagai predikat dengan <code>'Pattern::asMatchPredicate'</code> </h3><br><p>  Apakah ada ekspresi reguler?  Perlu memfilter data?  Bagaimana dengan ini: </p><br><pre> <code class="java hljs">Pattern nonWordCharacter = Pattern.compile(<span class="hljs-string"><span class="hljs-string">"\\W"</span></span>); Stream .of(<span class="hljs-string"><span class="hljs-string">"Metallica"</span></span>, <span class="hljs-string"><span class="hljs-string">"Motörhead"</span></span>) .filter(nonWordCharacter.asPredicate()) .forEach(System.out::println);</code> </pre> <br><p>  Saya sangat senang menemukan metode ini!  Perlu ditambahkan bahwa ini adalah metode dari Java 8. Ups, saya melewatkannya saat itu.  Java 11 menambahkan metode serupa lainnya: <code>Pattern::asMatchPredicate</code> .  Apa bedanya? </p><br><ul><li>  <code>asPredicate</code> memeriksa apakah string <strong>atau bagian dari string</strong> cocok dengan pola (berfungsi seperti <code>s -&gt; this.matcher(s).find()</code> ) </li><li>  <code>asMatchPredicate</code> memeriksa bahwa <strong>seluruh string</strong> cocok dengan pola (berfungsi seperti <code>s -&gt; this.matcher(s).matches()</code> ) </li></ul><br><p>  Misalnya, kami memiliki ekspresi reguler yang memeriksa nomor telepon, tetapi tidak mengandung <code>^</code> dan <code>$</code> untuk melacak awal dan akhir suatu baris.  Maka kode berikut tidak akan berfungsi seperti yang Anda harapkan: </p><br><pre> <code class="java hljs">prospectivePhoneNumbers .stream() .filter(phoneNumberPatter.asPredicate()) .forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::robocall);</code> </pre> <br><p>  Apakah Anda memperhatikan kesalahan?  Baris seperti <code>" -152 ? +1-202-456-1414"</code> akan difilter, karena berisi nomor telepon yang valid.  Di sisi lain, <code>Pattern::asMatchPredicate</code> tidak akan mengizinkan ini, karena <strong>seluruh</strong> string tidak <strong>lagi</strong> cocok dengan pola. </p><br><h3 id="samoproverka">  Tes diri </h3><br><p>  Berikut ini ikhtisar dari semua sebelas mutiara - apakah Anda masih ingat apa yang dilakukan setiap metode?  Jika demikian, Anda telah lulus ujian. </p><br><ul><li>  dalam <code>String</code> : <br><ul><li> <code>Stream&lt;String&gt; lines()</code> </li> <li> <code>String strip()</code> </li> <li> <code>String stripLeading()</code> </li> <li> <code>String stripTrailing()</code> </li> <li> <code>boolean isBlank()</code> </li> <li> <code>String repeat(int)</code> </li> </ul></li><li>  di <code>Path</code> : <br><ul><li> <code>static Path of(String, String...)</code> </li> <li> <code>static Path of(URI)</code> </li> </ul></li><li>  dalam <code>Files</code> : <br><ul><li> <code>String readString(Path) throws IOException</code> </li> <li> <code>Path writeString(Path, CharSequence, OpenOption...) throws IOException</code> </li> <li> <code>Path writeString(Path, CharSequence, Charset, OpenOption...) throws IOException</code> </li> </ul></li><li>  di <code>InputStream</code> : <code>static InputStream nullInputStream()</code> </li><li>  dalam <code>OutputStream</code> : <code>OutputStream</code> <code>static OutputStream nullOutputStream()</code> </li><li>  di <code>Reader</code> : <code>static Reader nullReader()</code> </li><li>  dalam <code>Writer</code> : <code>static Writer nullWriter()</code> </li><li>  dalam <code>Collection</code> : <code>T[] toArray(IntFunction&lt;T[]&gt;)</code> </li><li>  dalam <code>Optional</code> : <code>boolean isEmpty()</code> </li><li>  dalam <code>Predicate</code> : <code>Predicate</code> <code>static Predicate&lt;T&gt; not(Predicate&lt;T&gt;)</code> </li><li>  dalam <code>Pattern</code> : <code>Predicate&lt;String&gt; asMatchPredicate()</code> </li></ul><br><p>  Bersenang-senang dengan Java 11! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441154/">https://habr.com/ru/post/id441154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441142/index.html">12 poin pertumbuhan konversi, atau konten yang benar-benar menjual</a></li>
<li><a href="../id441146/index.html">Jaringan nirkabel industri: mana yang harus dipilih?</a></li>
<li><a href="../id441148/index.html">Cara menangani kesalahan dengan benar: diam tidak selalu baik</a></li>
<li><a href="../id441150/index.html">Pengantar protokol HTTP pertama dengan menulis server Web Java paling sederhana</a></li>
<li><a href="../id441152/index.html">Cara meminimalkan kesalahan saat berintegrasi dengan layanan eksternal: pengalaman broker online</a></li>
<li><a href="../id441158/index.html">Bagaimana etika menjadi masalah Lembah Silikon termahal, dan filsafat menjadi solusi paling praktis</a></li>
<li><a href="../id441160/index.html">Cara belajar menentukan kapan mengatakan tidak</a></li>
<li><a href="../id441166/index.html">Kami mendapatkan kata sandi utama dari pengelola kata sandi yang terkunci 1 Kata sandi 4</a></li>
<li><a href="../id441168/index.html">Saluran Data QUIC: Langkah Pertama</a></li>
<li><a href="../id441172/index.html">Bagaimana pasar pencetakan 3D tumbuh pada tahun 2018 dan apa artinya untuk bisnis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>