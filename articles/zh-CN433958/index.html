<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏽 🎈 👨🏾‍🏭 Spring Boot上的TDD应用程序：使用数据库 👩‍❤️‍💋‍👩 🤶 🤷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="系列文章“ Spring Boot上的应用程序的测试驱动开发”的第二篇文章，这次我将讨论测试数据库访问，这是集成测试的重要方面。 我将告诉您如何确定将来通过测试访问数据的服务的接口，如何使用内置的内存数据库进行测试，处理事务以及将测试数据上传到数据库。 


 我一般不会谈论TDD和测试，我邀请所有...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring Boot上的TDD应用程序：使用数据库</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433958/"><p> 系列文章“ Spring Boot上的应用程序的测试驱动开发”的第二篇文章，这次我将讨论测试数据库访问，这是集成测试的重要方面。 我将告诉您如何确定将来通过测试访问数据的服务的接口，如何使用内置的内存数据库进行测试，处理事务以及将测试数据上传到数据库。 </p><a name="habracut"></a><br><p> 我一般不会谈论TDD和测试，我邀请所有人阅读第一篇文章- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何在主干中构建金字塔或如何在Spring Boot / geek杂志上进行应用程序的测试驱动开发</a> </p><br><p> 与上次一样，我将从理论上的一小部分开始，然后继续进行端到端测试。 </p><br><h1 id="piramida-testirovaniya"> 测试金字塔 </h1><br><p> 首先，对测试中的重要实体（如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“测试金字塔”</a>或<em>“测试金字塔”）进行简短</em>但必要的描述。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6c/930/f2d/f6c930f2d4ae8a6068696ace34e9566e.png" alt="图片"></p><br><p>  （摘自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实用测试金字塔</a> ） </p><br><p> 测试金字塔是在多个级别组织测试时采用的方法。 </p><br><ul><li>  <strong>UI</strong> （或<strong>端到端E2E</strong> ）测试很少，而且很慢，但是它们测试的是真实的应用程序-无需模拟程序，也不进行对应测试。 业务经常在此级别上进行思考，所有BDD框架都存在于此处（请参阅上一篇文章中的Cucumber）。 </li><li> 它们后面是<strong>集成测试</strong> （服务，组件-每个都有其自己的术语），它们已经集中于系统的特定组件（服务），通过moki / doubles与其他组件隔离，但仍在检查与实际外部系统的集成-这些测试已连接到数据库，发送REST请求，我使用消息队列。 实际上，这些测试可验证业务逻辑与外界的集成。 </li><li> 最底层是快速的<strong>单元测试</strong> ，它可以完全隔离地测试最少的代码块（类，方法）。 </li></ul><br><p>  Spring可以帮助编写每个级别的测试- <em>甚至对于单元测试</em> ，尽管这听起来可能很奇怪，因为在单元测试的世界中，根本不存在有关框架的知识。 编写完端到端测试之后，我将展示Spring如何允许甚至像控制器这样的纯粹“集成”事物也可以单独进行测试。 </p><br><p> 但是，我将从金字塔的最高端开始-缓慢的UI测试，该测试将启动并测试完整的应用程序。 </p><br><h1 id="end-to-end-test"> 端到端测试 </h1><br><p> 因此，一个新功能： </p><br><pre><code class="plaintext hljs">Feature: A list of available cakes Background: catalogue is updated Given the following items are promoted | Title | Price | | Red Velvet | 3.95 | | Victoria Sponge | 5.50 | Scenario: a user visiting the web-site sees the list of items Given a new user, Alice When she visits Cake Factory web-site Then she sees that "Red Velvet" is available with price £3.95 And she sees that "Victoria Sponge" is available with price £5.50</code> </pre> <br><blockquote> 这是一个非常有趣的方面-与先前的测试有关主页上的问候语怎么办？ 似乎不再相关，在主页上启动网站后，将已经有目录，而不是问候语。 我会说没有一个答案-这取决于情况。 但主要建议-请勿参与测试！ 当他们失去关联时将其删除，重写以使其更易于阅读。 特别是E2E测试-实际上，这应该是一个<strong>活泼的最新规范</strong> 。 就我而言，我只是删除了旧测试，并使用前面的一些步骤并添加了不存在的测试，将它们替换为新的测试。 </blockquote><p> 现在，我谈到了重要的一点-选择用于存储数据的技术。 按照<em>精益</em>方法，我想将选择推迟到最后一刻-当我确定是否确定关系模型时，对一致性，事务性的要求是什么。 总的来说，有解决方案，例如创建<strong>测试对</strong>和各种<strong>内存</strong>存储，但是到目前为止，我不想使本文复杂化并立即选择技术-关系数据库。 但是为了保留至少某种选择数据库的可能性，我将添加一个抽象<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-Spring Data JPA</a> 。  JPA本身是用于访问关系数据库的相当抽象的规范，而Spring Data使它的使用更加容易。 </p><br><blockquote>  Spring Data JPA默认使用Hibernate作为提供程序，但也支持其他技术，例如EclipseLink和MyBatis。 对于不太熟悉Java Persistence API的人-JPA就像一个接口，而Hibernate是实现它的类。 </blockquote><p> 因此，为了添加JPA支持，我添加了两个依赖项： </p><br><pre> <code class="plaintext hljs">implementation('org.springframework.boot:spring-boot-starter-data-jpa') runtime('com.h2database:h2')</code> </pre> <br><p> 作为数据库，我将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">H2-</a>用Java编写的嵌入式数据库，并且能够在内存模式下工作。 </p><br><p> 使用Spring Data JPA，我立即定义了一个用于访问数据的接口： </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br><p> 和本质： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Builder</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"cakes"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) Long id; <span class="hljs-meta"><span class="hljs-meta">@NotBlank</span></span> String title; <span class="hljs-meta"><span class="hljs-meta">@Positive</span></span> BigDecimal price; <span class="hljs-meta"><span class="hljs-meta">@NotBlank</span></span> <span class="hljs-meta"><span class="hljs-meta">@NaturalId</span></span> String sku; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> promoted; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == o) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || getClass() != o.getClass()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; CakeEntity cakeEntity = (CakeEntity) o; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.equals(title, cakeEntity.title); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Objects.hash(title); } }</code> </pre> <br><p> 在实体的描述中有一些不太明显的事情。 </p><br><ul><li>  <code>sku</code>字段的<code>@NaturalId</code> 。 该字段用作检查实体是否相等的“自然标识符”-在<code>equals</code> / <code>hashCode</code>方法中使用所有字段或<code>@Id</code>字段是一种反模式。 关于如何正确验证实体的相等性的文章写得很好，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">here</a> 。 </li><li> 为了稍微减少样板代码，我使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Project Lombok</a> -Java的注释处理器。 它允许您添加各种有用的东西，例如<code>@Builder</code>自动为类生成一个构建器，而<code>@AllArgsConstructor</code>为所有字段创建一个构造器。 </li></ul><br><p>  Spring Data将自动提供接口实现。 </p><br><h1 id="vniz-po-piramide"> 下金字塔 </h1><br><p> 现在是时候进入金字塔的下一个层次了。 根据经验，我建议您<strong>始终从e2e测试开始</strong> ，因为这将使您确定“最终目标”和新功能的边界，但是没有更严格的规则。 在升级到单元级别之前，不必先编写集成测试。 通常，它更方便，更简单-顺理成章。 </p><br><p> 但特别是现在，我想立即打破此规则，编写一个单元测试，这将有助于确定尚不存在的新组件的接口和协定。 控制器应返回一个将从某个组件X填充的模型，我编写了以下测试： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ExtendWith</span></span>(MockitoExtension.class) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IndexControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Mock</span></span> CakeFinder cakeFinder; <span class="hljs-meta"><span class="hljs-meta">@InjectMocks</span></span> IndexController indexController; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Set&lt;Cake&gt; cakes = Set.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(<span class="hljs-string"><span class="hljs-string">"Test 1"</span></span>, <span class="hljs-string"><span class="hljs-string">"£10"</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(<span class="hljs-string"><span class="hljs-string">"Test 2"</span></span>, <span class="hljs-string"><span class="hljs-string">"£10"</span></span>)); <span class="hljs-meta"><span class="hljs-meta">@BeforeEach</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(cakeFinder.findPromotedCakes()).thenReturn(cakes); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnAListOfFoundPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ModelAndView index = indexController.index(); assertThat(index.getModel()).extracting(<span class="hljs-string"><span class="hljs-string">"cakes"</span></span>).contains(cakes); } }</code> </pre> <br><p> 这是一个纯单元测试-没有上下文，没有数据库，只有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mockito</a> for mok。 这个测试只是Spring如何帮助进行单元测试的一个很好的展示<em>-Spring MVC中</em>的<em>控制器只是一个类，其方法接受普通类型的参数并返回POJO对象-视图模型</em> 。 没有HTTP请求，没有响应，标头，JSON，XML-所有这些都将以转换器和序列化器的形式自动应用于堆栈。 是的，以<code>ModelAndView</code>的形式向Spring提供了一个小的“提示”，但这是一个常规的POJO，您甚至可以根据需要摆脱它，这是UI控制器特别需要的。 </p><br><blockquote> 我不会谈论Mockito，您可以阅读官方文档中的所有内容。 具体来说，此测试中只有一些有趣的要点-我使用<code>MockitoExtension.class</code>作为测试运行程序，它将自动为<code>@Mock</code>注释的字段生成mokas，然后将这些mokas作为依赖项注入到@InjectMocks字段中的对象的构造函数中。 您可以使用<code>Mockito.mock()</code>方法手动完成所有这些操作，然后创建一个类。 </blockquote><p> 此测试有助于确定新组件的方法<code>findPromotedCakes</code> ，这是我们要在主页上显示的蛋糕列表。 他没有确定它是什么，也不知道它如何与数据库一起使用。 管制员的唯一责任是取走转移给它的物品，并在特定领域退还模型（“蛋糕”）。 尽管如此， <code>CakeFinder</code>在我的界面中已经具有第一个方法，这意味着您可以为其编写集成测试。 </p><br><blockquote> 我故意将<code>cakes</code> <strong>包中的</strong>所有类都<code>cakes</code> <strong>私有，</strong>以便包外的任何人都不能使用它们。 从数据库获取数据的唯一方法是使用CakeFinder界面，它是我访问数据库的“组件X”。 它成为自然的“连接器”，如果我需要隔离测试而不接触底座，我可以轻松锁定它。 它的唯一实现是JpaCakeFinder。 并且，例如，如果将来数据库类型或数据源发生更改，那么您将需要添加<code>CakeFinder</code>接口的实现，而无需更改使用它的代码。 </blockquote><br><h1 id="integracionnyy-test-dlya-jpa-ispolzuya-datajpatest"> 使用@DataJpaTest对JPA进行集成测试 </h1><br><p> 集成测试是春季面包和黄油。 实际上，在其中，集成测试的所有工作都做得非常好，以至于开发人员有时不希望进入单元级别或忽略UI级别。 这既不是不好也不是好-我重申测试的主要目标是信心。 一组快速有效的集成测试可能足以提供这种信心。 但是，随着时间的流逝，这些测试可能会变得越来越慢，或者只是孤立地而不是集成地开始测试组件。 </p><br><p> 集成测试可以按原样（ <code>@SpringBootTest</code> ）或其单独的组件（JPA，Web）运行应用程序。 就我而言，我想编写针对JPA的重点测试-因此，我无需配置控制器或任何其他组件。 在Spring Boot Test中， <code>@DataJpaTest</code>批注对此负责。 这是一个<em>元</em>注释，即 它结合了几个不同的注释，这些注释配置了测试的不同方面。 </p><br><ul><li>  @AutoConfigureDataJpa </li><li>  @AutoConfigureTestDatabase </li><li>  @AutoConfigureCache </li><li>  @AutoConfigureTestEntityManager </li><li>  @交易 </li></ul><br><p> 首先，我将分别向您介绍每个测试，然后再向您展示完成的测试。 </p><br><p>  <strong>@AutoConfigureDataJpa</strong> <br> 它加载了整套配置并配置了存储库（自动生成<code>CrudRepositories</code>的实现），用于FlyWay和Liquibase数据库的迁移工具，并使用DataSource，事务管理器以及最后的Hibernate连接到数据库。 实际上，这只是与访问数据有关的一组配置-这里既不包括Web MVC的<code>DispatcherServlet</code> ，也不包括其他组件。 </p><br><p>  <strong>@AutoConfigureTestDatabase</strong> <br> 这是JPA测试最有趣的方面之一。 此配置<em>在类路径中搜索受支持的嵌入式数据库之一，然后重新配置上下文，以便DataSource指向随机创建的内存数据库</em> 。 由于我已将依存关系添加到H2基数中，因此我无需执行其他任何操作，仅在每次测试运行时自动具有此批注将提供一个空基数，这非常方便。 </p><br><p> 值得记住的是，如果没有计划，这个基础将完全是空的。 要生成电路，有两种选择。 </p><br><ol><li> 使用Hibernate中的<strong>Auto DDL</strong>功能。  Spring Boot Test会自动将此值设置为<code>create-drop</code>以便Hibernate将根据实体描述生成模式，并在会话结束时将其删除。 这是Hibernate强大的功能，对于测试非常有用。 </li><li> 使用由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Flyway</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Liquibase</a>创建的迁移。 </li></ol><br><p> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>详细了解有关初始化数据库的不同方法。 </p><br><p>  <strong>@AutoConfigureCache</strong> <br> 它只是将缓存配置为使用NoOpCacheManager-即 不要缓存任何内容。 这对于避免测试出乎意料很有用。 </p><br><p>  <strong>@AutoConfigureTestEntityManager</strong> <br> 向<code>TestEntityManager</code>添加一个特殊的<code>TestEntityManager</code>对象，它本身就是一个有趣的野兽。  <code>EntityManager</code>是JPA的主要类，负责将实体添加到会话中，删除和进行类似操作。 例如，仅当Hibernate投入运行时-向会话添加实体并不意味着将执行对数据库的请求，并且从会话加载并不意味着将执行选择请求。 由于Hibernate的内部机制，对数据库的实际操作将在适当的时间执行，而框架本身将确定适当的时间。 但是在测试中，可能有必要将某些内容强制发送到数据库，因为测试的目的是测试集成。 而且<code>TestEntityManager</code>只是一个帮助程序，它将帮助强制执行数据库中的某些操作-例如， <code>persistAndFlush()</code>将强制Hibernate执行所有请求。 </p><br><p>  <strong>@交易</strong> <br> 该注释使该类中的所有测试都具有事务性，并在测试完成后自动回滚该事务。 这只是在每次测试之前“清理”数据库的一种机制，因为否则您将不得不从每个表中手动删除数据。 </p><br><blockquote> 一个测试是否应该管理一个事务似乎并不是一个简单而明显的问题。 尽管数据库的“干净”状态很方便，但是如果“战斗”代码没有启动事务本身而是需要现有事务，则测试中<code>@Transactional</code>出现可能会令人不快。 这可能会导致集成测试通过，但是当从控制器而不是测试中执行实际代码时，该服务将没有活动的事务，并且该方法将引发异常。 尽管这看起来很危险，但是通过UI测试的高级测试，事务测试还不错。 以我的经验，当通过的集成测试使生产代码崩溃时，我只看到了一次，这显然需要现有事务的存在。 但是，如果仍然需要验证服务和组件本身是否正确管理事务，则可以使用所需的模式在测试中“阻止” <code>@Transactional</code>批注（例如，不要启动事务）。 </blockquote><br><h1 id="integracionnyy-test-so-springboottest"> 与@SpringBootTest的集成测试 </h1><br><p> 我还想指出， <code>@DataJpaTest</code>不是焦点集成测试的唯一示例，其中包括<code>@WebMvcTest</code> ， <code>@DataMongoTest</code>等。 但是，最重要的测试注释之一仍然是<code>@SpringBootTest</code> ，它以所有配置的组件和集成<em>“按原样”</em>启动测试应用程序。 出现一个逻辑问题-如果您可以运行整个应用程序，为什么要进行集中DataJpa测试？ 我要说的是，这里再也没有严格的规定了。 </p><br><p> 如果<em>可以</em>每次运行应用程序，隔离测试中的崩溃，不过载并且不使测试的设置复杂化，那么您当然可以并且应该使用@SpringBootTest。 </p><br><p> 但是，在现实生活中，应用程序可能需要许多不同的设置，连接到不同的系统，并且我不希望我的数据库访问测试失败，因为 未配置与消息队列的连接。 因此，使用常识很重要，如果要使用@SpringBootTest批注进行测试，您需要锁定一半的系统-那么在@SpringBootTest中是否有意义？ </p><br><h1 id="podgotovka-dannyh-dlya-testa"> 准备测试数据 </h1><br><p> 测试的关键点之一是数据准备。 每个测试都应单独执行，并在启动之前准备环境，以使系统进入其原始期望状态。 最简单的方法是使用<code>@BeforeEach</code> / <code>@BeforeAll</code>批注，然后使用存储库<code>EntityManager</code>或<code>TestEntityManager</code>在数据库中添加条目。 但是还有另一个选项可以让您运行准备好的脚本或执行所需的SQL查询，这是<code>@Sql</code>批注。 在运行测试之前，Spring Boot Test将自动运行指定的脚本，而无需添加<code>@BeforeAll</code>块，而<code>@Transactional</code>将负责数据<code>@Transactional</code> 。 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@DataJpaTest</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaCakeFinderTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String PROMOTED_CAKE = <span class="hljs-string"><span class="hljs-string">"Red Velvet"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String NON_PROMOTED_CAKE = <span class="hljs-string"><span class="hljs-string">"Victoria Sponge"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CakeFinder finder; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> CakeRepository cakeRepository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> TestEntityManager testEntityManager; <span class="hljs-meta"><span class="hljs-meta">@BeforeEach</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testEntityManager.persistAndFlush(CakeEntity.builder().title(PROMOTED_CAKE) .sku(<span class="hljs-string"><span class="hljs-string">"SKU1"</span></span>).price(BigDecimal.TEN).promoted(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>).build()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.testEntityManager.persistAndFlush(CakeEntity.builder().sku(<span class="hljs-string"><span class="hljs-string">"SKU2"</span></span>) .title(NON_PROMOTED_CAKE).price(BigDecimal.ONE).promoted(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).build()); finder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JpaCakeFinder(cakeRepository); } ... }</code> </pre> <br><h1 id="red-green-refactor-cikl"> 红绿重构循环 </h1><br><p> 尽管有这么多的文本，对于开发人员来说，该测试仍然看起来像是带有@DataJpaTest批注的简单类，但是我希望我能够展示在幕后正在发生的有用的事情，开发人员无法想到。 现在我们可以进入TDD周期，这次我将展示一些TDD迭代，并提供重构示例和最少的代码。 为了更清楚一点，我强烈建议您查看Git中的历史记录，其中每个提交都是一个单独的重要步骤，并描述了它的作用和方式。 </p><br><h2 id="podgotovka-dannyh"> 资料准备 </h2><br><p> 我对<code>@BeforeAll</code> / <code>@BeforeEach</code>使用此方法，并在数据库中手动创建所有记录。 带有<code>@Sql</code>注释的示例移至一个单独的类<code>JpaCakeFinderTestWithScriptSetup</code> ，它复制了测试，这些测试当然不应存在，并且仅出于演示该方法的目的而存在。 </p><br><p> 系统的初始状态-系统中有两个条目，一个蛋糕参与促销，并且必须包含在该方法返回的结果中，第二个-否。 </p><br><h2 id="pervyy-test-integracionnyy-test"> 首次测试整合测试 </h2><br><p> 第一个测试是最简单的<code>findPromotedCakes</code>应该包含参与促销的蛋糕的描述和价格。 </p><br><h3 id="red"> 红色的 </h3><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldReturnPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Iterable&lt;Cake&gt; promotedCakes = finder.findPromotedCakes(); assertThat(promotedCakes).extracting(Cake::getTitle).contains(PROMOTED_CAKE); assertThat(promotedCakes).extracting(Cake::getPrice).contains(<span class="hljs-string"><span class="hljs-string">"£10.00"</span></span>); }</code> </pre> <br><p> 测试当然会崩溃-默认实现返回一个空的Set。 </p><br><h3 id="green"> 绿色的 </h3><br><p> 自然，我们想立即编写过滤，使用<code>where</code>向数据库发出请求<code>where</code>等等。 但是，按照TDD惯例，我必须编写<em>最低代码以通过测试</em> 。 这个最少的代码是返回数据库中的所有记录。 是的，如此简单和老套。 </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findAll() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).map( cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">formatPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BigDecimal price)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"£"</span></span> + price.setScale(<span class="hljs-number"><span class="hljs-number">2</span></span>, RoundingMode.DOWN).toPlainString(); }</code> </pre> <br><blockquote> 可能有人会争辩说，即使没有基础，也可以使测试变成绿色-只需对测试预期的结果进行硬编码即可。 我偶尔会听到这样的争论，但是我想每个人都理解TDD并不是教条或宗教，因此将其带到荒谬的意义上是没有意义的。 但是，如果您确实愿意，那么您可以，例如，对安装中的数据进行随机化处理，以便不对其进行硬编码。 </blockquote><br><h3 id="refactor"> 重构 </h3><br><p> 我在这里看不到太多的重构，因此可以针对此特定测试跳过此阶段。 但是我仍然不建议忽略此阶段，最好停下来思考一下每次系统处于“绿色”状态-是否可以重构某些东西以使其变得更好，更容易？ </p><br><h2 id="vtoroy-test"> 第二次测试 </h2><br><p> 但是第二个测试将已经验证没有任何升级的蛋糕落入<code>findPromotedCakes</code>返回的结果中。 </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shouldNotReturnNonPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Iterable&lt;Cake&gt; promotedCakes = finder.findPromotedCakes(); assertThat(promotedCakes).extracting(Cake::getTitle) .doesNotContain(NON_PROMOTED_CAKE); }</code> </pre> <br><h3 id="red-1"> 红色的 </h3><br><p> 正如预期的那样，该测试崩溃了-数据库中有两条记录，并且代码简单地将它们全部返回。 </p><br><h3 id="green-1"> 绿色的 </h3><br><p> 再一次您可以考虑-通过测试您可以编写的最低代码是多少？ 由于已经有一个流及其组合，因此您只需在其中添加一个<code>filter</code>块即可。 </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findAll() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) .filter(cakeEntity -&gt; cakeEntity.promoted) .map(cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); }</code> </pre> <br><p> 我们重新启动测试-集成测试现在变为绿色。 重要的时刻已经到来-由于控制器的单元测试和与数据库一起使用的集成测试的结合，我的功能已准备就绪-UI测试现在通过！ </p><br><h3 id="refactor-1"> 重构 </h3><br><p> 而且由于所有测试都是绿色的，所以该重构了。 我认为没有必要澄清内存过滤不是一个好主意，最好在数据库中执行此操作。 为此，我在<code>CakesRepository</code>添加了一个新方法<code>CakesRepository</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CakeEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Iterable&lt;CakeEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByPromotedIsTrue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p> 对于此方法，Spring Data自动生成一个方法，该方法将执行对形式<code>select from cakes where promoted = true</code> 。 在Spring Data <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>阅读有关查询生成的更多信息。 </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Set&lt;Cake&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPromotedCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Spliterator&lt;CakeEntity&gt; cakes = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cakeRepository.findByPromotedIsTrue() .spliterator(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamSupport.stream(cakes, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>).map( cakeEntity -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cake(cakeEntity.title, formatPrice(cakeEntity.price))) .collect(Collectors.toSet()); }</code> </pre> <br><p> 这是集成测试和黑匣子方法提供的灵活性的一个很好的例子。 如果存储库被锁定，那么添加新方法而不更改测试并非没有可能。 </p><br><h1 id="podklyuchenie-k-production-baze"> 连接生产基地 </h1><br><p> 为了增加一些“真实性”并显示如何将测试配置和主应用程序分开，我将为“生产”应用程序添加数据访问配置。 </p><br><p> 传统上，所有内容都由<code>application.yml</code>的部分添加： </p><br><pre> <code class="plaintext hljs">datasource: url: jdbc:h2:./data/cake-factory</code> </pre><br><p> 这将自动将文件系统中的数据保存到<code>./data</code>文件夹中。 我注意到该文件夹​​不会在测试中创建-由于存在<code>@AutoConfigureTestDatabase</code>批注， <code>@AutoConfigureTestDatabase</code>内存中的随机数据库自动替换与文件数据库的连接。 </p><br><blockquote>   ,    —   <code>data.sql</code>  <code>schema.sql</code> .   , Spring Boot             .          ,   , ,    . </blockquote><br><h1 id="zaklyuchenie"> 结论 </h1><br><p> ,               ,    ,       TDD . </p><br><p>      Spring Security —                Spring,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433958/">https://habr.com/ru/post/zh-CN433958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433946/index.html">人工智能备忘单-丢弃多余的东西，教主要知识。 训练序列处理技术</a></li>
<li><a href="../zh-CN433948/index.html">如何使付款更方便：IaaS提供商的经验</a></li>
<li><a href="../zh-CN433952/index.html">从HPE选择SAP HANA解决方案的10个理由。 第二部分</a></li>
<li><a href="../zh-CN433954/index.html">八种音频技术和音频小工具将于2019年进入TECnology名人堂</a></li>
<li><a href="../zh-CN433956/index.html">Modders使用AI改善了游戏的质感</a></li>
<li><a href="../zh-CN433964/index.html">Node.js中的ECMAScript模块：新计划</a></li>
<li><a href="../zh-CN433966/index.html">火星的圣诞贺卡。 ESA在红色星球表面显示出大量冰</a></li>
<li><a href="../zh-CN433968/index.html">最简陋的交流游戏</a></li>
<li><a href="../zh-CN433972/index.html">参加者眼中的HolyJS 2018莫斯科</a></li>
<li><a href="../zh-CN433974/index.html">聊天机器人会听到声音，也可能是业余痛苦</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>