<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   No obligue a los oyentes a reflexionar   </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 



 Durante el proceso de desarrollo, a menudo es necesario crear una instancia de una clase cuyo nombre se almacena en el archivo de co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>No obligue a los oyentes a reflexionar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/447022/"><h2 id="vvedenie">  Introduccion </h2><br><p><img src="https://habrastorage.org/webt/c0/6s/s8/c06ss8od1zjumrcisda44pa5j0q.png"><br>  Durante el proceso de desarrollo, a menudo es necesario crear una instancia de una clase cuyo nombre se almacena en el archivo de configuraci贸n XML, o llamar a un m茅todo cuyo nombre se escribe como una cadena como el valor del atributo de anotaci贸n.  En tales casos, la respuesta es una: "隆Use la reflexi贸n!". </p><br><p>  En la nueva versi贸n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CUBA Platform,</a> una de las tareas para mejorar el marco era deshacerse de la creaci贸n expl铆cita de controladores de eventos en las clases de controlador de las pantallas de la interfaz de usuario.  En versiones anteriores, las declaraciones del controlador en el m茅todo de inicializaci贸n del controlador estaban muy desordenadas con el c贸digo, por lo que en la s茅ptima versi贸n decidimos limpiar todo. </p><a name="habracut"></a><br><p> Un detector de eventos es solo una referencia al m茅todo que debe llamarse en el momento adecuado (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la plantilla del Observador</a> ).  Dicha plantilla es bastante simple de implementar usando la clase <code>java.lang.reflect.Method</code> .  Al inicio, solo necesita escanear las clases, extraer los m茅todos anotados de ellas, guardar las referencias a ellas y usar los enlaces para llamar al m茅todo (o m茅todos) cuando ocurre el evento, como se hace en la mayor parte de los marcos.  Lo 煤nico que nos detuvo fue que muchos eventos se generan tradicionalmente en la interfaz de usuario, y cuando se usa la API de reflexi贸n, debe pagar alg煤n precio en la forma de la llamada al m茅todo.  Por lo tanto, decidimos analizar de qu茅 otra manera puede hacer manejadores de eventos sin usar la reflexi贸n. </p><br><p>  Ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicamos</a> materiales sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MethodHandles</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LambdaMetafactory en un habr</a> , y este material es una especie de continuaci贸n.  Examinaremos los pros y los contras del uso de la API de reflexi贸n, as铆 como las alternativas: generar c贸digo con la compilaci贸n AOT y LambdaMetafactory, y c贸mo se us贸 en el marco CUBA. </p><br><h2 id="reflection-staryy-dobryy-nadezhnyy">  Reflexi贸n: Viejo.  Bueno  Confiable </h2><br><p>  <em>En inform谩tica, reflexi贸n o reflexi贸n (el hol贸nimo de introspecci贸n, reflexi贸n en ingl茅s) significa un proceso durante el cual un programa puede rastrear y modificar su propia estructura y comportamiento en tiempo de ejecuci贸n.</em>  (c) Wikipedia. </p><br><p>  Para la mayor铆a de los desarrolladores de Java, la reflexi贸n nunca es algo nuevo.  Me parece que sin este mecanismo, Java no se habr铆a convertido en ese Java, que ahora ocupa una gran cuota de mercado en el desarrollo de software de aplicaciones.  Solo piense: proxying, vinculando m茅todos a eventos a trav茅s de anotaciones, inyecci贸n de dependencias, aspectos e incluso instanciando el controlador JDBC en las primeras versiones de JDK.  La reflexi贸n en todas partes es la piedra angular de todos los marcos modernos. </p><br><p>  驴Hay alg煤n problema con Reflection aplicado a nuestra tarea?  Hemos identificado tres: </p><br><p>  <em>Velocidad</em> : una llamada de m茅todo a trav茅s de la API de Reflection es m谩s lenta que una llamada directa.  En cada nueva versi贸n de JVM, los desarrolladores aceleran constantemente las llamadas a trav茅s de la reflexi贸n, el compilador JIT intenta optimizar a煤n m谩s el c贸digo, pero de todos modos, la diferencia en comparaci贸n con la llamada al m茅todo directo es notable. </p><br><p>  <em>Escribir</em> : si usa <code>java.lang.reflect.Method</code> en el c贸digo, entonces esto es solo una referencia a alg煤n m茅todo.  Y en ninguna parte est谩 escrito cu谩ntos par谩metros se pasan y de qu茅 tipo son.  Una llamada con los par谩metros incorrectos generar谩 un error en tiempo de ejecuci贸n y no en la etapa de compilaci贸n o descarga de la aplicaci贸n. </p><br><p>  <em>Transparencia</em> : si el m茅todo llamado a trav茅s de la reflexi贸n falla, tendremos que pasar por varias llamadas <code>invoke()</code> antes de llegar al fondo de la causa real del error. </p><br><p>  Pero si miramos el c贸digo de los controladores de eventos Spring o JPA en Hibernate, entonces el viejo <code>java.lang.reflect.Method</code> estar谩 dentro.  Y en el futuro cercano, creo que es poco probable que esto cambie.  Estos marcos son demasiado grandes y est谩n demasiado vinculados a ellos, y parece que el rendimiento de los controladores de eventos en el lado del servidor es suficiente para pensar en lo que puede reemplazar las llamadas a trav茅s de la reflexi贸n. </p><br><p>  驴Y qu茅 otras opciones hay? </p><br><h2 id="aot-kompilyaciya-i-kodogeneraciya---vernem-prilozheniyam-skorost">  Compilaci贸n AOT y generaci贸n de c贸digo: 隆devuelva la velocidad a las aplicaciones! </h2><br><p>  El primer candidato para reemplazar la API de reflexi贸n es la generaci贸n de c贸digo.  Ahora han comenzado a aparecer marcos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Micronaut</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quarkus</a> , que intentan resolver dos problemas: reducir la velocidad de inicio de la aplicaci贸n y reducir el consumo de memoria.  Estas dos m茅tricas son vitales en nuestra era de contenedores, microservicios y arquitecturas sin servidor, y los nuevos marcos est谩n tratando de resolver esto mediante la compilaci贸n AOT.  Usando diferentes t茅cnicas (puede leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> , por ejemplo), el c贸digo de la aplicaci贸n se modifica de tal manera que todas las llamadas reflexivas a m茅todos, constructores, etc.  reemplazado por llamadas directas.  Por lo tanto, no necesita escanear clases y crear beans en el momento del inicio de la aplicaci贸n, y JIT optimiza el c贸digo de manera m谩s eficiente en tiempo de ejecuci贸n, lo que proporciona un aumento significativo en el rendimiento de las aplicaciones creadas en dichos marcos.  驴Este enfoque tiene desventajas?  Respuesta: por supuesto que la hay. </p><br><p>  Primero, no ejecuta el c贸digo que escribi贸. El c贸digo fuente cambia durante la compilaci贸n, por lo que si algo sale mal, a veces es dif铆cil entender d贸nde est谩 el error: en su c贸digo o en el algoritmo de generaci贸n (generalmente en el suyo, por supuesto )  Y a partir de aqu铆 surge el problema de depuraci贸n: debe depurar su propio c贸digo. </p><br><p>  El segundo: para ejecutar una aplicaci贸n escrita en el marco con la compilaci贸n AOT, necesita una herramienta especial.  No puede simplemente obtener y ejecutar una aplicaci贸n escrita en Quarkus, por ejemplo.  Necesitamos un complemento especial para maven / gradle, que preprocesar谩 su c贸digo.  Y ahora, en caso de errores en el marco, debe actualizar no solo las bibliotecas, sino tambi茅n el complemento. </p><br><p>  En verdad, la generaci贸n de c贸digo tampoco es nueva en el mundo de Java; no apareci贸 con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Micronaut</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quarkus</a> .  De una forma u otra, algunos marcos lo usan.  Aqu铆 podemos recordar lombok, aspectoj con su generaci贸n preliminar de c贸digo para aspectos o eclipselink, que agrega c贸digo a las clases de entidad para una deserializaci贸n m谩s eficiente.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CUBA,</a> utilizamos la generaci贸n de c贸digo para generar eventos sobre cambios en el estado de una entidad e incluir mensajes de validaci贸n en el c贸digo de clase para simplificar el trabajo con entidades en la IU. </p><br><p>  Para los desarrolladores de CUBA, implementar la generaci贸n de c贸digo est谩tico para los controladores de eventos ser铆a un paso extremo porque se tuvieron que hacer muchos cambios en la arquitectura interna y en el complemento para la generaci贸n de c贸digo.  驴Hay algo que parezca un reflejo pero m谩s r谩pido? </p><br><h2 id="lambdametafactory---takie-zhe-vyzovy-metodov-no-bystree">  LambdaMetafactory: llamadas al mismo m茅todo, pero m谩s r谩pido </h2><br><p>  Java 7 introdujo una nueva instrucci贸n para la JVM: <code>invokedynamic</code> .  Sobre ella hay un excelente informe de Vladimir Ivanov en jug.ru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> .  Originalmente concebida para su uso en lenguajes din谩micos como Groovy, esta instrucci贸n fue un gran candidato para invocar m茅todos en Java sin usar la reflexi贸n.  Al mismo tiempo que la nueva instrucci贸n, apareci贸 una API asociada en el JDK: </p><br><ul><li>  Class <code>MethodHandle</code> : apareci贸 en Java 7, pero todav铆a no se usa con mucha frecuencia </li><li>  <code>LambdaMetafactory</code> : esta clase ya es de Java 8, se convirti贸 en un desarrollo adicional de la API para llamadas din谩micas, utiliza <code>MethodHandle</code> en <code>MethodHandle</code> interior. </li></ul><br><p>  Parec铆a que <code>MethodHandle</code> , siendo esencialmente un puntero escrito a un m茅todo (constructor, etc.), podr铆a cumplir el rol de <code>java.lang.reflect.Method</code> .  Y las llamadas ser谩n m谩s r谩pidas, porque todas las comprobaciones de tipo que se realizan en la API de Reflection con cada llamada, en este caso, se realizan solo una vez, cuando <code>MethodHandle</code> . </p><br><p>  Pero, por desgracia, el <code>MethodHandle</code> puro result贸 ser incluso m谩s lento que las llamadas a trav茅s de la API de reflexi贸n.  Se pueden lograr ganancias de rendimiento haciendo que <code>MethodHandle</code> est谩tico, pero no en todos los casos.  Hay una excelente discusi贸n sobre la velocidad de <code>MethodHandle</code> llamadas a <code>MethodHandle</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la lista de correo de OpenJDK</a> . </p><br><p>  Pero cuando <code>LambdaMetafactory</code> clase <code>LambdaMetafactory</code> , hubo una posibilidad real de acelerar las llamadas a m茅todos.  <code>LambdaMetafactory</code> permite crear un objeto lambda y envolver una llamada de m茅todo directo en 茅l, que se puede obtener a trav茅s de <code>MethodHandle</code> .  Y luego, usando el objeto generado, puede llamar al m茅todo deseado.  Aqu铆 hay un ejemplo de la generaci贸n que envuelve el m茅todo getter pasado como par谩metro a BiFunction: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BiFunction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGetHandlerLambda</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, Method method)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ MethodHandles.Lookup caller = MethodHandles.lookup(); CallSite site = LambdaMetafactory.metafactory(caller, <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, MethodType.methodType(BiFunction.class), MethodType.methodType(Object.class, Object.class, Object.class), caller.findVirtual(bean.getClass(), method.getName(), MethodType.methodType(method.getReturnType(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])), MethodType.methodType(method.getReturnType(), bean.getClass(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])); MethodHandle factory = site.getTarget(); BiFunction listenerMethod = (BiFunction) factory.invoke(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listenerMethod; }</code> </pre> <br><p>  Como resultado, obtenemos una instancia de BiFunction en lugar de Method.  Y ahora, incluso si usamos M茅todo en nuestro c贸digo, reemplazarlo con BiFunction no es dif铆cil.  Tome el c贸digo real (ligeramente simplificado, verdadero) para llamar al manejador de m茅todos, marcado <code>@EventListener</code> desde Spring Framework: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Method method; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method.invoke(bean, event); handleResult(result); } }</code> </pre> <br><p>  Y aqu铆 est谩 el mismo c贸digo, pero que utiliza una llamada de m茅todo a trav茅s de una lambda: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerLambdaAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiFunction funHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = funHandler.apply(bean, event); handleResult(result); } }</code> </pre> <br><p>  Cambios m铆nimos, la funcionalidad es la misma, pero hay ventajas: </p><br><p>  <em>Una lambda tiene un tipo</em> : se especifica en la creaci贸n, por lo que fallar谩 llamar "solo un m茅todo". </p><br><p>  <em>La pila de rastreo es m谩s corta</em> : al llamar a un m茅todo a trav茅s de una lambda, solo se agrega una llamada adicional: <code>apply()</code> .  Y eso es todo.  A continuaci贸n, se llama al m茅todo en s铆. </p><br><p>  Pero la velocidad debe ser medida. </p><br><h3 id="zameryaem-skorost">  Medir la velocidad </h3><br><p>  Para probar la hip贸tesis, creamos un microbenchmark usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JMH</a> para comparar el tiempo de ejecuci贸n y el rendimiento al llamar al mismo m茅todo de diferentes maneras: a trav茅s de la API de reflexi贸n, a trav茅s de LambdaMetafactory, y tambi茅n agregamos una llamada directa al m茅todo para comparar.  Se crearon enlaces a Method y lambdas antes de que comenzara la prueba. </p><br><p>  Par谩metros de prueba: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>({Mode.Throughput, Mode.AverageTime}) <span class="hljs-meta"><span class="hljs-meta">@Warmup</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">5</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS) <span class="hljs-meta"><span class="hljs-meta">@Measurement</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">10</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS)</code> </pre> <br><p>  La prueba en s铆 se puede descargar desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> y ejecutarla usted mismo, si est谩 interesado. </p><br><p>  Resultados de la prueba para Oracle JDK 11.0.2 y JMH 1.21 (los n煤meros pueden variar, pero la diferencia sigue siendo notable y casi la misma): </p><br><table><thead><tr><th>  <strong>Prueba - Obtenga valor</strong> </th><th>  <strong>Rendimiento (ops / us)</strong> </th><th>  <strong>Tiempo de ejecuci贸n (us / op)</strong> </th></tr></thead><tbody><tr><td>  LambdaGetTest </td><td>  72 </td><td>  0,0118 </td></tr><tr><td>  ReflectionGetTest </td><td>  65 </td><td>  0,0177 </td></tr><tr><td>  DirectMethodGetTest </td><td>  260 </td><td>  0.0048 </td></tr><tr><td>  <strong>Prueba - Establecer valor</strong> </td><td>  <strong>Rendimiento (ops / us)</strong> </td><td>  <strong>Tiempo de ejecuci贸n (us / op</strong> </td></tr><tr><td>  LambdaSetTest </td><td>  96 </td><td>  0.0092 </td></tr><tr><td>  ReflectionSetTest </td><td>  58 </td><td>  0,0173 </td></tr><tr><td>  DirectMethodSetTest </td><td>  415 </td><td>  0.0031 </td></tr></tbody></table><br><p>  En promedio, result贸 que llamar a un m茅todo a trav茅s de una lambda es aproximadamente un 30% m谩s r谩pido que a trav茅s de una API de reflexi贸n.  Hay otra gran discusi贸n sobre el rendimiento de la invocaci贸n de m茅todos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu铆</a> si alguien est谩 interesado en los detalles.  En resumen: la ganancia en velocidad se obtiene, entre otras cosas, debido al hecho de que las lambdas generadas se pueden incluir en el c贸digo del programa, y los controles de tipo a煤n no se realizan, a diferencia de lo que ocurre con la reflexi贸n. </p><br><p>  Por supuesto, este punto de referencia es bastante simple, no incluye m茅todos de llamada en una jerarqu铆a de clases o medici贸n de la velocidad de llamada a los m茅todos finales.  Pero hicimos mediciones m谩s complejas, y los resultados siempre estuvieron a favor del uso de LambdaMetafactory. </p><br><h2 id="ispolzovanie">  Uso </h2><br><p>  En el marco de trabajo de CUBA versi贸n 7, en los controladores de IU, puede usar la anotaci贸n <code>@Subscribe</code> para "firmar" un m茅todo para ciertos eventos de la interfaz de usuario.  Internamente, esto se implementa en <code>LambdaMetafactory</code> , los enlaces a los m茅todos de escucha se crean y almacenan en cach茅 en la primera llamada. </p><br><p>  Esta innovaci贸n permiti贸 borrar en gran medida el c贸digo, especialmente en el caso de formularios con una gran cantidad de elementos, interacci贸n compleja y, en consecuencia, con una gran cantidad de controladores de eventos.  Un ejemplo simple de QuickStart de CUBA: imagine que necesita volver a calcular el monto del pedido al agregar o eliminar art铆culos del producto.  Debe escribir c贸digo que ejecute el m茅todo <code>calculateAmount()</code> cuando la colecci贸n cambie en la entidad.  C贸mo se ve铆a antes: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CollectionDatasource&lt;OrderLine, UUID&gt; linesDs; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Object&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ linesDs.addCollectionChangeListener(e -&gt; calculateAmount()); } ... }</code> </pre> <br><p>  Y en CUBA 7, el c贸digo se ve as铆: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StandardEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span>(id = <span class="hljs-string"><span class="hljs-string">"linesDc"</span></span>, target = Target.DATA_CONTAINER) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOrderLinesDcCollectionChange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CollectionChangeEvent&lt;OrderLine&gt; event)</span></span></span><span class="hljs-function"> </span></span>{ calculateAmount(); } ... }</code> </pre> <br><p>  En pocas palabras: el c贸digo es m谩s limpio y no existe un m茅todo m谩gico <code>init()</code> , que tiende a crecer y llenarse de controladores de eventos con una complejidad creciente del formulario.  Y, sin embargo, ni siquiera necesitamos hacer un campo con el componente al que nos estamos suscribiendo, CUBA encontrar谩 este componente por ID. </p><br><h3 id="vyvody">  Conclusiones </h3><br><p>  A pesar de la aparici贸n de una nueva generaci贸n de marcos con compilaci贸n AOT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Micronaut</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quarkus</a> ), que tienen ventajas innegables sobre los marcos "tradicionales" (principalmente, se comparan con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Spring</a> ), todav铆a hay una gran cantidad de c贸digo escrito utilizando la API de reflexi贸n (y gracias por la misma primavera).  Y parece que Spring Framework sigue siendo el l铆der entre los marcos de desarrollo de aplicaciones y trabajaremos con c贸digo basado en la reflexi贸n durante mucho tiempo. </p><br><p>  Y si est谩 pensando en usar la API de Reflection en su c贸digo, ya sea una aplicaci贸n o un marco, piense dos veces.  Primero, sobre la generaci贸n de c贸digo, y luego sobre MethodHandles / LambdaMetafactory.  El segundo m茅todo puede resultar m谩s r谩pido, y los esfuerzos de desarrollo no se gastar谩n m谩s que en el caso de usar la API Reflection. </p><br><p>  <em>Algunos enlaces m谩s 煤tiles:</em> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una alternativa m谩s r谩pida a Java Reflection</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hackear expresiones lambda en Java</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">M茅todo maneja en Java</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reflexi贸n de Java, pero mucho m谩s r谩pido</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">驴Por qu茅 es LambdaMetafactory un 10% m谩s lento que un MethodHandle est谩tico pero un 80% m谩s r谩pido que un MethodHandle no est谩tico?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Demasiado r谩pido, demasiado megam贸rfico: 驴qu茅 influye en el rendimiento de las llamadas a m茅todos en Java?</a> <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447022/">https://habr.com/ru/post/447022/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447010/index.html">No por mucho tiempo la m煤sica son贸 ... o c贸mo el OS Elbrus nunca se volvi贸 libre</a></li>
<li><a href="../447014/index.html">Estructuras de referencia desechables en C # 8.0</a></li>
<li><a href="../447016/index.html">25 a帽os despu茅s: una entrevista con Linus Torvalds</a></li>
<li><a href="../447018/index.html">Enriquecimiento cu谩ntico en una interpretaci贸n multimundo</a></li>
<li><a href="../447020/index.html">La productividad no se trata de la gesti贸n del tiempo, sino de la gesti贸n de la atenci贸n.</a></li>
<li><a href="../447024/index.html">驴C贸mo combinar las ventajas de una computadora port谩til y una computadora de escritorio? An谩lisis del problema y soluciones.</a></li>
<li><a href="../447026/index.html">Escribimos el cargador OTA para ATmega128RFA1 (como parte del dispositivo Smart Response XE)</a></li>
<li><a href="../447028/index.html">Archivos pasados de esteganograf铆a: ocultamos datos directamente en sectores</a></li>
<li><a href="../447034/index.html">Nuevo error en Telegram Desktop le permite leer el 煤ltimo mensaje</a></li>
<li><a href="../447036/index.html">Un c贸ctel para una dieta saludable: est谩 hecho por una startup del acelerador de la Universidad ITMO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>