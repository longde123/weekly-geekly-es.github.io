<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏽 🧘🏻 🐝 No obligue a los oyentes a reflexionar 😄 🍙 🚍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 



 Durante el proceso de desarrollo, a menudo es necesario crear una instancia de una clase cuyo nombre se almacena en el archivo de co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>No obligue a los oyentes a reflexionar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/447022/"><h2 id="vvedenie">  Introduccion </h2><br><p><img src="https://habrastorage.org/webt/c0/6s/s8/c06ss8od1zjumrcisda44pa5j0q.png"><br>  Durante el proceso de desarrollo, a menudo es necesario crear una instancia de una clase cuyo nombre se almacena en el archivo de configuración XML, o llamar a un método cuyo nombre se escribe como una cadena como el valor del atributo de anotación.  En tales casos, la respuesta es una: "¡Use la reflexión!". </p><br><p>  En la nueva versión de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CUBA Platform,</a> una de las tareas para mejorar el marco era deshacerse de la creación explícita de controladores de eventos en las clases de controlador de las pantallas de la interfaz de usuario.  En versiones anteriores, las declaraciones del controlador en el método de inicialización del controlador estaban muy desordenadas con el código, por lo que en la séptima versión decidimos limpiar todo. </p><a name="habracut"></a><br><p> Un detector de eventos es solo una referencia al método que debe llamarse en el momento adecuado (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la plantilla del Observador</a> ).  Dicha plantilla es bastante simple de implementar usando la clase <code>java.lang.reflect.Method</code> .  Al inicio, solo necesita escanear las clases, extraer los métodos anotados de ellas, guardar las referencias a ellas y usar los enlaces para llamar al método (o métodos) cuando ocurre el evento, como se hace en la mayor parte de los marcos.  Lo único que nos detuvo fue que muchos eventos se generan tradicionalmente en la interfaz de usuario, y cuando se usa la API de reflexión, debe pagar algún precio en la forma de la llamada al método.  Por lo tanto, decidimos analizar de qué otra manera puede hacer manejadores de eventos sin usar la reflexión. </p><br><p>  Ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publicamos</a> materiales sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MethodHandles</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LambdaMetafactory en un habr</a> , y este material es una especie de continuación.  Examinaremos los pros y los contras del uso de la API de reflexión, así como las alternativas: generar código con la compilación AOT y LambdaMetafactory, y cómo se usó en el marco CUBA. </p><br><h2 id="reflection-staryy-dobryy-nadezhnyy">  Reflexión: Viejo.  Bueno  Confiable </h2><br><p>  <em>En informática, reflexión o reflexión (el holónimo de introspección, reflexión en inglés) significa un proceso durante el cual un programa puede rastrear y modificar su propia estructura y comportamiento en tiempo de ejecución.</em>  (c) Wikipedia. </p><br><p>  Para la mayoría de los desarrolladores de Java, la reflexión nunca es algo nuevo.  Me parece que sin este mecanismo, Java no se habría convertido en ese Java, que ahora ocupa una gran cuota de mercado en el desarrollo de software de aplicaciones.  Solo piense: proxying, vinculando métodos a eventos a través de anotaciones, inyección de dependencias, aspectos e incluso instanciando el controlador JDBC en las primeras versiones de JDK.  La reflexión en todas partes es la piedra angular de todos los marcos modernos. </p><br><p>  ¿Hay algún problema con Reflection aplicado a nuestra tarea?  Hemos identificado tres: </p><br><p>  <em>Velocidad</em> : una llamada de método a través de la API de Reflection es más lenta que una llamada directa.  En cada nueva versión de JVM, los desarrolladores aceleran constantemente las llamadas a través de la reflexión, el compilador JIT intenta optimizar aún más el código, pero de todos modos, la diferencia en comparación con la llamada al método directo es notable. </p><br><p>  <em>Escribir</em> : si usa <code>java.lang.reflect.Method</code> en el código, entonces esto es solo una referencia a algún método.  Y en ninguna parte está escrito cuántos parámetros se pasan y de qué tipo son.  Una llamada con los parámetros incorrectos generará un error en tiempo de ejecución y no en la etapa de compilación o descarga de la aplicación. </p><br><p>  <em>Transparencia</em> : si el método llamado a través de la reflexión falla, tendremos que pasar por varias llamadas <code>invoke()</code> antes de llegar al fondo de la causa real del error. </p><br><p>  Pero si miramos el código de los controladores de eventos Spring o JPA en Hibernate, entonces el viejo <code>java.lang.reflect.Method</code> estará dentro.  Y en el futuro cercano, creo que es poco probable que esto cambie.  Estos marcos son demasiado grandes y están demasiado vinculados a ellos, y parece que el rendimiento de los controladores de eventos en el lado del servidor es suficiente para pensar en lo que puede reemplazar las llamadas a través de la reflexión. </p><br><p>  ¿Y qué otras opciones hay? </p><br><h2 id="aot-kompilyaciya-i-kodogeneraciya---vernem-prilozheniyam-skorost">  Compilación AOT y generación de código: ¡devuelva la velocidad a las aplicaciones! </h2><br><p>  El primer candidato para reemplazar la API de reflexión es la generación de código.  Ahora han comenzado a aparecer marcos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Micronaut</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quarkus</a> , que intentan resolver dos problemas: reducir la velocidad de inicio de la aplicación y reducir el consumo de memoria.  Estas dos métricas son vitales en nuestra era de contenedores, microservicios y arquitecturas sin servidor, y los nuevos marcos están tratando de resolver esto mediante la compilación AOT.  Usando diferentes técnicas (puede leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> , por ejemplo), el código de la aplicación se modifica de tal manera que todas las llamadas reflexivas a métodos, constructores, etc.  reemplazado por llamadas directas.  Por lo tanto, no necesita escanear clases y crear beans en el momento del inicio de la aplicación, y JIT optimiza el código de manera más eficiente en tiempo de ejecución, lo que proporciona un aumento significativo en el rendimiento de las aplicaciones creadas en dichos marcos.  ¿Este enfoque tiene desventajas?  Respuesta: por supuesto que la hay. </p><br><p>  Primero, no ejecuta el código que escribió. El código fuente cambia durante la compilación, por lo que si algo sale mal, a veces es difícil entender dónde está el error: en su código o en el algoritmo de generación (generalmente en el suyo, por supuesto )  Y a partir de aquí surge el problema de depuración: debe depurar su propio código. </p><br><p>  El segundo: para ejecutar una aplicación escrita en el marco con la compilación AOT, necesita una herramienta especial.  No puede simplemente obtener y ejecutar una aplicación escrita en Quarkus, por ejemplo.  Necesitamos un complemento especial para maven / gradle, que preprocesará su código.  Y ahora, en caso de errores en el marco, debe actualizar no solo las bibliotecas, sino también el complemento. </p><br><p>  En verdad, la generación de código tampoco es nueva en el mundo de Java; no apareció con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Micronaut</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quarkus</a> .  De una forma u otra, algunos marcos lo usan.  Aquí podemos recordar lombok, aspectoj con su generación preliminar de código para aspectos o eclipselink, que agrega código a las clases de entidad para una deserialización más eficiente.  En <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CUBA,</a> utilizamos la generación de código para generar eventos sobre cambios en el estado de una entidad e incluir mensajes de validación en el código de clase para simplificar el trabajo con entidades en la IU. </p><br><p>  Para los desarrolladores de CUBA, implementar la generación de código estático para los controladores de eventos sería un paso extremo porque se tuvieron que hacer muchos cambios en la arquitectura interna y en el complemento para la generación de código.  ¿Hay algo que parezca un reflejo pero más rápido? </p><br><h2 id="lambdametafactory---takie-zhe-vyzovy-metodov-no-bystree">  LambdaMetafactory: llamadas al mismo método, pero más rápido </h2><br><p>  Java 7 introdujo una nueva instrucción para la JVM: <code>invokedynamic</code> .  Sobre ella hay un excelente informe de Vladimir Ivanov en jug.ru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> .  Originalmente concebida para su uso en lenguajes dinámicos como Groovy, esta instrucción fue un gran candidato para invocar métodos en Java sin usar la reflexión.  Al mismo tiempo que la nueva instrucción, apareció una API asociada en el JDK: </p><br><ul><li>  Class <code>MethodHandle</code> : apareció en Java 7, pero todavía no se usa con mucha frecuencia </li><li>  <code>LambdaMetafactory</code> : esta clase ya es de Java 8, se convirtió en un desarrollo adicional de la API para llamadas dinámicas, utiliza <code>MethodHandle</code> en <code>MethodHandle</code> interior. </li></ul><br><p>  Parecía que <code>MethodHandle</code> , siendo esencialmente un puntero escrito a un método (constructor, etc.), podría cumplir el rol de <code>java.lang.reflect.Method</code> .  Y las llamadas serán más rápidas, porque todas las comprobaciones de tipo que se realizan en la API de Reflection con cada llamada, en este caso, se realizan solo una vez, cuando <code>MethodHandle</code> . </p><br><p>  Pero, por desgracia, el <code>MethodHandle</code> puro resultó ser incluso más lento que las llamadas a través de la API de reflexión.  Se pueden lograr ganancias de rendimiento haciendo que <code>MethodHandle</code> estático, pero no en todos los casos.  Hay una excelente discusión sobre la velocidad de <code>MethodHandle</code> llamadas a <code>MethodHandle</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en la lista de correo de OpenJDK</a> . </p><br><p>  Pero cuando <code>LambdaMetafactory</code> clase <code>LambdaMetafactory</code> , hubo una posibilidad real de acelerar las llamadas a métodos.  <code>LambdaMetafactory</code> permite crear un objeto lambda y envolver una llamada de método directo en él, que se puede obtener a través de <code>MethodHandle</code> .  Y luego, usando el objeto generado, puede llamar al método deseado.  Aquí hay un ejemplo de la generación que envuelve el método getter pasado como parámetro a BiFunction: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> BiFunction </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGetHandlerLambda</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object bean, Method method)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Throwable </span></span>{ MethodHandles.Lookup caller = MethodHandles.lookup(); CallSite site = LambdaMetafactory.metafactory(caller, <span class="hljs-string"><span class="hljs-string">"apply"</span></span>, MethodType.methodType(BiFunction.class), MethodType.methodType(Object.class, Object.class, Object.class), caller.findVirtual(bean.getClass(), method.getName(), MethodType.methodType(method.getReturnType(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])), MethodType.methodType(method.getReturnType(), bean.getClass(), method.getParameterTypes()[<span class="hljs-number"><span class="hljs-number">0</span></span>])); MethodHandle factory = site.getTarget(); BiFunction listenerMethod = (BiFunction) factory.invoke(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> listenerMethod; }</code> </pre> <br><p>  Como resultado, obtenemos una instancia de BiFunction en lugar de Method.  Y ahora, incluso si usamos Método en nuestro código, reemplazarlo con BiFunction no es difícil.  Tome el código real (ligeramente simplificado, verdadero) para llamar al manejador de métodos, marcado <code>@EventListener</code> desde Spring Framework: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenericApplicationListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Method method; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method.invoke(bean, event); handleResult(result); } }</code> </pre> <br><p>  Y aquí está el mismo código, pero que utiliza una llamada de método a través de una lambda: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerLambdaAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApplicationListenerMethodAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BiFunction funHandler; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplicationEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ApplicationEvent event)</span></span></span><span class="hljs-function"> </span></span>{ Object bean = getTargetBean(); Object result = funHandler.apply(bean, event); handleResult(result); } }</code> </pre> <br><p>  Cambios mínimos, la funcionalidad es la misma, pero hay ventajas: </p><br><p>  <em>Una lambda tiene un tipo</em> : se especifica en la creación, por lo que fallará llamar "solo un método". </p><br><p>  <em>La pila de rastreo es más corta</em> : al llamar a un método a través de una lambda, solo se agrega una llamada adicional: <code>apply()</code> .  Y eso es todo.  A continuación, se llama al método en sí. </p><br><p>  Pero la velocidad debe ser medida. </p><br><h3 id="zameryaem-skorost">  Medir la velocidad </h3><br><p>  Para probar la hipótesis, creamos un microbenchmark usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JMH</a> para comparar el tiempo de ejecución y el rendimiento al llamar al mismo método de diferentes maneras: a través de la API de reflexión, a través de LambdaMetafactory, y también agregamos una llamada directa al método para comparar.  Se crearon enlaces a Method y lambdas antes de que comenzara la prueba. </p><br><p>  Parámetros de prueba: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>({Mode.Throughput, Mode.AverageTime}) <span class="hljs-meta"><span class="hljs-meta">@Warmup</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">5</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS) <span class="hljs-meta"><span class="hljs-meta">@Measurement</span></span>(iterations = <span class="hljs-number"><span class="hljs-number">10</span></span>, time = <span class="hljs-number"><span class="hljs-number">1000</span></span>, timeUnit = TimeUnit.MILLISECONDS)</code> </pre> <br><p>  La prueba en sí se puede descargar desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> y ejecutarla usted mismo, si está interesado. </p><br><p>  Resultados de la prueba para Oracle JDK 11.0.2 y JMH 1.21 (los números pueden variar, pero la diferencia sigue siendo notable y casi la misma): </p><br><table><thead><tr><th>  <strong>Prueba - Obtenga valor</strong> </th><th>  <strong>Rendimiento (ops / us)</strong> </th><th>  <strong>Tiempo de ejecución (us / op)</strong> </th></tr></thead><tbody><tr><td>  LambdaGetTest </td><td>  72 </td><td>  0,0118 </td></tr><tr><td>  ReflectionGetTest </td><td>  65 </td><td>  0,0177 </td></tr><tr><td>  DirectMethodGetTest </td><td>  260 </td><td>  0.0048 </td></tr><tr><td>  <strong>Prueba - Establecer valor</strong> </td><td>  <strong>Rendimiento (ops / us)</strong> </td><td>  <strong>Tiempo de ejecución (us / op</strong> </td></tr><tr><td>  LambdaSetTest </td><td>  96 </td><td>  0.0092 </td></tr><tr><td>  ReflectionSetTest </td><td>  58 </td><td>  0,0173 </td></tr><tr><td>  DirectMethodSetTest </td><td>  415 </td><td>  0.0031 </td></tr></tbody></table><br><p>  En promedio, resultó que llamar a un método a través de una lambda es aproximadamente un 30% más rápido que a través de una API de reflexión.  Hay otra gran discusión sobre el rendimiento de la invocación de métodos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> si alguien está interesado en los detalles.  En resumen: la ganancia en velocidad se obtiene, entre otras cosas, debido al hecho de que las lambdas generadas se pueden incluir en el código del programa, y ​​los controles de tipo aún no se realizan, a diferencia de lo que ocurre con la reflexión. </p><br><p>  Por supuesto, este punto de referencia es bastante simple, no incluye métodos de llamada en una jerarquía de clases o medición de la velocidad de llamada a los métodos finales.  Pero hicimos mediciones más complejas, y los resultados siempre estuvieron a favor del uso de LambdaMetafactory. </p><br><h2 id="ispolzovanie">  Uso </h2><br><p>  En el marco de trabajo de CUBA versión 7, en los controladores de IU, puede usar la anotación <code>@Subscribe</code> para "firmar" un método para ciertos eventos de la interfaz de usuario.  Internamente, esto se implementa en <code>LambdaMetafactory</code> , los enlaces a los métodos de escucha se crean y almacenan en caché en la primera llamada. </p><br><p>  Esta innovación permitió borrar en gran medida el código, especialmente en el caso de formularios con una gran cantidad de elementos, interacción compleja y, en consecuencia, con una gran cantidad de controladores de eventos.  Un ejemplo simple de QuickStart de CUBA: imagine que necesita volver a calcular el monto del pedido al agregar o eliminar artículos del producto.  Debe escribir código que ejecute el método <code>calculateAmount()</code> cuando la colección cambie en la entidad.  Cómo se veía antes: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CollectionDatasource&lt;OrderLine, UUID&gt; linesDs; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Map&lt;String, Object&gt; params)</span></span></span><span class="hljs-function"> </span></span>{ linesDs.addCollectionChangeListener(e -&gt; calculateAmount()); } ... }</code> </pre> <br><p>  Y en CUBA 7, el código se ve así: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderEdit</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StandardEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Subscribe</span></span>(id = <span class="hljs-string"><span class="hljs-string">"linesDc"</span></span>, target = Target.DATA_CONTAINER) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOrderLinesDcCollectionChange</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CollectionChangeEvent&lt;OrderLine&gt; event)</span></span></span><span class="hljs-function"> </span></span>{ calculateAmount(); } ... }</code> </pre> <br><p>  En pocas palabras: el código es más limpio y no existe un método mágico <code>init()</code> , que tiende a crecer y llenarse de controladores de eventos con una complejidad creciente del formulario.  Y, sin embargo, ni siquiera necesitamos hacer un campo con el componente al que nos estamos suscribiendo, CUBA encontrará este componente por ID. </p><br><h3 id="vyvody">  Conclusiones </h3><br><p>  A pesar de la aparición de una nueva generación de marcos con compilación AOT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Micronaut</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quarkus</a> ), que tienen ventajas innegables sobre los marcos "tradicionales" (principalmente, se comparan con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Spring</a> ), todavía hay una gran cantidad de código escrito utilizando la API de reflexión (y gracias por la misma primavera).  Y parece que Spring Framework sigue siendo el líder entre los marcos de desarrollo de aplicaciones y trabajaremos con código basado en la reflexión durante mucho tiempo. </p><br><p>  Y si está pensando en usar la API de Reflection en su código, ya sea una aplicación o un marco, piense dos veces.  Primero, sobre la generación de código, y luego sobre MethodHandles / LambdaMetafactory.  El segundo método puede resultar más rápido, y los esfuerzos de desarrollo no se gastarán más que en el caso de usar la API Reflection. </p><br><p>  <em>Algunos enlaces más útiles:</em> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una alternativa más rápida a Java Reflection</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hackear expresiones lambda en Java</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Método maneja en Java</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reflexión de Java, pero mucho más rápido</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Por qué es LambdaMetafactory un 10% más lento que un MethodHandle estático pero un 80% más rápido que un MethodHandle no estático?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Demasiado rápido, demasiado megamórfico: ¿qué influye en el rendimiento de las llamadas a métodos en Java?</a> <br></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447022/">https://habr.com/ru/post/447022/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447010/index.html">No por mucho tiempo la música sonó ... o cómo el OS Elbrus nunca se volvió libre</a></li>
<li><a href="../447014/index.html">Estructuras de referencia desechables en C # 8.0</a></li>
<li><a href="../447016/index.html">25 años después: una entrevista con Linus Torvalds</a></li>
<li><a href="../447018/index.html">Enriquecimiento cuántico en una interpretación multimundo</a></li>
<li><a href="../447020/index.html">La productividad no se trata de la gestión del tiempo, sino de la gestión de la atención.</a></li>
<li><a href="../447024/index.html">¿Cómo combinar las ventajas de una computadora portátil y una computadora de escritorio? Análisis del problema y soluciones.</a></li>
<li><a href="../447026/index.html">Escribimos el cargador OTA para ATmega128RFA1 (como parte del dispositivo Smart Response XE)</a></li>
<li><a href="../447028/index.html">Archivos pasados ​​de esteganografía: ocultamos datos directamente en sectores</a></li>
<li><a href="../447034/index.html">Nuevo error en Telegram Desktop le permite leer el último mensaje</a></li>
<li><a href="../447036/index.html">Un cóctel para una dieta saludable: está hecho por una startup del acelerador de la Universidad ITMO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>