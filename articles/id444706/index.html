<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ—½ âš•ï¸ ğŸ§ğŸ» Foto Facebook 3D Di Dalam: Parallax Shaders ğŸµï¸ ğŸ§™ ğŸˆ‚ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam beberapa bulan terakhir, Facebook telah membanjiri foto 3D . Jika Anda belum dapat melihatnya, maka saya akan menjelaskan: Foto 3D adalah gambar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Foto Facebook 3D Di Dalam: Parallax Shaders</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444706/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/7e9/cda/6537e9cdaff76aa8cc2716b8b53ecba9.gif" alt="gambar"></div><br>  Dalam beberapa bulan terakhir, Facebook telah membanjiri <strong>foto 3D</strong> .  Jika Anda belum dapat melihatnya, maka saya akan menjelaskan: Foto 3D adalah gambar di dalam pos yang dengan lancar mengubah sudut saat menggulir halaman atau saat Anda menggerakkan mouse di atasnya. <br><br>  Beberapa bulan sebelum fitur ini muncul, Facebook menguji fitur serupa dengan model 3D.  Meskipun Anda dapat dengan mudah memahami bagaimana Facebook dapat membuat model 3D dan memutarnya sesuai dengan posisi mouse, dengan foto 3D situasinya mungkin tidak begitu intuitif. <br><br>  Teknik yang digunakan Facebook untuk membuat tiga dimensi gambar dua dimensi kadang-kadang disebut <strong>peta ketinggian elevasi</strong> .  Ini menggunakan fenomena optik yang disebut <strong>paralaks</strong> . <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Contoh foto Facebook 3D (GIF)</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/0f6/cbd/a060f6cbde767809731fea11f26034a4.gif"></div></div></div><br><h2>  Apa itu paralaks </h2><br>  Jika Anda memainkan Super Mario, maka Anda tahu persis apa paralaksnya.  Meskipun Mario berlari dengan kecepatan yang sama, tampaknya objek yang jauh di latar bergerak lebih lambat (lihat di bawah). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33a/b4f/3b3/33ab4f3b3e14cc710feb881f935d5162.gif"></div><br>  Efek ini menciptakan ilusi bahwa beberapa elemen, seperti gunung dan awan, terletak lebih jauh.  Ini efektif karena otak kita menggunakan paralaks (bersama dengan isyarat visual lainnya) untuk memperkirakan jarak ke objek yang jauh. <br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana otak mengevaluasi jarak?</b> <div class="spoiler_text">  Diasumsikan bahwa otak manusia menggunakan beberapa mekanisme untuk memperkirakan jarak.  Pada jarak pendek dan menengah, jarak dihitung dengan membandingkan perbedaan posisi objek yang terlihat dengan mata kanan dan kiri.  Ini disebut <strong>visi stereoskopik</strong> dan tersebar luas di alam. <br><br>  Namun, untuk objek yang cukup jauh, satu penglihatan stereoskopis tidak cukup.  Pegunungan, awan, dan bintang berbeda terlalu sedikit untuk mata yang berbeda untuk melihat perbedaan yang signifikan.  Oleh karena itu, paralaks relatif ikut berperan.  Objek di latar belakang bergerak kurang dari objek di latar depan.  Ini adalah gerakan relatif mereka yang memungkinkan Anda untuk mengatur jarak relatif. <br><br>  Dalam persepsi jarak, banyak mekanisme lain digunakan.  Yang paling terkenal di antaranya adalah kabut atmosfer, yang memberi warna biru pada objek jauh.  Di dunia lain, sebagian besar petunjuk atmosfer ini tidak ada, sehingga sangat sulit untuk menilai skala objek di planet lain dan bulan.  Pengguna YouTube Alex McCulgan menjelaskan ini di saluran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Astrum-</a> nya, menunjukkan betapa sulitnya untuk menentukan ukuran objek bulan yang ditampilkan dalam video. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/5yx3O9cZ5NM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><br><h2>  Parallax sebagai pergeseran </h2><br>  Jika Anda terbiasa dengan aljabar linier, maka Anda mungkin tahu betapa rumit dan tidak sepele matematika rotasi 3D.  Oleh karena itu, ada cara yang jauh lebih sederhana untuk memahami paralaks, yang tidak membutuhkan apa pun selain perubahan. <br><br>  Mari kita bayangkan bahwa kita sedang melihat kubus (lihat di bawah).  Jika kita tepat sejajar dengan pusatnya, maka wajah depan dan belakang akan terlihat seperti dua kotak dengan ukuran berbeda untuk mata kita.  Inilah <strong>prospeknya</strong> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bac/1ac/714/bac1ac714202cd1fa2e3608646970dca.png"></div><br>  Namun, apa yang terjadi jika kita memindahkan kamera ke bawah, atau menaikkan kubus ke atas?  Dengan menerapkan prinsip yang sama, kita dapat melihat bahwa wajah depan dan belakang telah bergeser relatif terhadap posisi sebelumnya.  Yang lebih menarik adalah bahwa mereka telah bergerak relatif satu sama lain.  Wajah belakang, yang jauh dari kita, seakan bergerak kurang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d8/25a/0e1/4d825a0e105c808d87e1b5995f2faef1.png"></div><br>  Jika kita ingin menghitung posisi sebenarnya dari simpul-simpul kubus ini dalam ruang lingkup yang diproyeksikan, maka kita harus serius mengambil trigonometri.  Namun, ini tidak terlalu penting.  Jika gerakan kamera cukup kecil, maka kami dapat memperkirakan perpindahan titik, menggerakkannya sesuai dengan jaraknya. <br><br>  Satu-satunya hal yang perlu kita tentukan adalah skala.  Jika kita memindahkan X meter ke kanan, maka akan terlihat bahwa objek Y meter telah pindah Z meter.  Jika X tetap kecil, paralaks menjadi tugas <strong>interpolasi linier</strong> daripada trigonometri.  Intinya, ini berarti kita dapat mensimulasikan rotasi 3D kecil dengan menggeser piksel tergantung pada jaraknya dari kamera. <br><br><h2>  Hasilkan peta kedalaman </h2><br>  Pada prinsipnya, apa yang dilakukan Facebook tidak jauh berbeda dengan apa yang terjadi di Super Mario.  Untuk gambar yang diberikan, piksel tertentu digeser ke arah gerakan berdasarkan jarak ke kamera.  Untuk membuat foto 3D Facebook, Anda hanya perlu foto itu sendiri dan peta yang menyatakan seberapa jauh setiap piksel dari kamera.  Peta seperti itu memiliki nama yang diharapkan - <strong>"peta kedalaman"</strong> .  Ini juga disebut <strong>peta ketinggian,</strong> tergantung pada konteksnya. <br><br>  Mengambil foto cukup sederhana, tetapi menghasilkan peta kedalaman yang tepat adalah tugas yang jauh lebih sulit.  Perangkat modern menggunakan berbagai teknik.  Paling sering menggunakan dua kamera;  masing-masing mengambil gambar dari subjek yang sama, tetapi dengan perspektif yang sedikit berbeda.  Prinsip yang sama digunakan dalam <strong>penglihatan stereoskopik</strong> , yang digunakan orang untuk mengevaluasi kedalaman pada jarak pendek dan menengah.  Gambar di bawah ini menunjukkan bagaimana iPhone 7 dapat membuat peta kedalaman dari dua gambar yang sangat dekat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/903/ab0/c03/903ab0c0376f7978c771352d82b5f648.png"></div><br>  Rincian pelaksanaan rekonstruksi tersebut dijelaskan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Fotografi 3D Instan</a> , yang disajikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Peter Hedman</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Johannes Kopf</a> di SIGGRAPH2018. <br><br>  Setelah membuat peta kedalaman berkualitas tinggi, simulasi tiga dimensi menjadi tugas yang hampir sepele.  Keterbatasan sebenarnya dari teknik ini adalah bahwa bahkan jika Anda dapat membuat ulang model 3D kasar, itu tidak memiliki informasi tentang cara membuat bagian-bagian yang tidak terlihat dalam foto asli.  Saat ini, masalah ini tidak dapat diselesaikan, dan oleh karena itu, semua gerakan yang terlihat dalam foto 3D agak tidak signifikan. <br><br>  Kami berkenalan dengan konsep foto 3D dan secara singkat berbicara tentang bagaimana smartphone modern dapat membuatnya.  Pada bagian kedua, kita akan belajar bagaimana teknik yang sama dapat digunakan untuk mengimplementasikan foto 3D di Unity menggunakan shader. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/7e9/cda/6537e9cdaff76aa8cc2716b8b53ecba9.gif"></div><br><h2>  Bagian 2. Parallax shader dan peta kedalaman </h2><br><h4>  Template shader </h4><br>  Jika kita ingin membuat ulang foto 3D Facebook menggunakan shader, maka kita harus memutuskan apa yang akan kita lakukan.  Karena efek ini bekerja paling baik dengan gambar 2D, akan logis untuk mengimplementasikan solusi yang kompatibel dengan sprite Unity.  Kami akan membuat shader yang dapat digunakan dengan <strong>Sprite Renderer</strong> . <br><br>  Meskipun shader seperti itu dapat dibuat dari awal, seringkali lebih baik untuk memulai dengan template yang sudah jadi.  Yang terbaik adalah mulai bergerak maju dengan menyalin spades sprite yang ada, yang digunakan Unity secara default untuk semua sprite.  Sayangnya, mesinnya tidak dilengkapi dengan file <em>shader</em> yang dapat Anda edit sendiri. <br><br>  Untuk mendapatkannya, Anda harus pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">arsip unduhan Unity</a> dan unduh paket <em>Built in shaders</em> (lihat di bawah) untuk versi mesin yang Anda gunakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d00/1b9/da8/d001b9da891e60ef4b93f89ffb8a9fda.png"></div><br>  Setelah mengekstrak paket, Anda dapat melihat kode sumber dari semua shader yang datang dengan Unity.  Kami tertarik pada file <em>Sprite-Diffuse.shader</em> , yang digunakan secara default untuk semua sprite yang dibuat. <br><br><h2>  Gambar </h2><br>  Aspek kedua yang perlu diformalkan adalah data yang kita miliki.  Bayangkan kita memiliki gambar yang ingin kita hidupkan dan peta dalamnya.  Yang terakhir akan menjadi gambar hitam dan putih, di mana piksel hitam dan putih menunjukkan seberapa jauh atau dekat mereka dari kamera. <br><br>  Gambar-gambar yang digunakan dalam tutorial ini diambil dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">proyek</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">kucing Pickle</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="noopener">Dennis Hotson</a> , dan ini tanpa ragu adalah yang terbaik yang akan Anda lihat hari ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03c/9ee/9c0/03c9ee9c0a5f15908ea183bf0b4bea98.png"></div><br>  Peta ketinggian yang terkait dengan gambar ini mencerminkan jarak moncong kucing dari kamera. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54c/f5b/d2d/54cf5bd2d93144efb7371c3076b6541c.jpg"></div><br>  Sangat mudah untuk melihat bagaimana hasil yang baik dapat dicapai dengan peta kedalaman yang sederhana.  Ini artinya mudah untuk membuat peta kedalaman Anda sendiri untuk gambar yang ada. <br><br><h2>  Sifat-sifat </h2><br>  Sekarang setelah kita memiliki semua sumber daya, kita dapat mulai menulis kode shader paralaks.  Jika kami mengimpor gambar utama sebagai sprite, maka Unity akan secara otomatis meneruskannya ke shader melalui properti <code>_MainTex</code> .  Namun, kita perlu membuat peta kedalaman tersedia untuk shader.  Ini dapat diimplementasikan menggunakan <strong>properti shader</strong> baru yang disebut <code>_HeightTex</code> .  Saya sengaja memutuskan untuk tidak menyebutnya <code>_DepthTex</code> agar tidak membingungkannya dengan <strong>tekstur kedalaman</strong> (ini adalah konsep Unity serupa yang digunakan untuk membuat peta kedalaman adegan). <br><br>  Untuk mengubah kekuatan efek, kami juga akan menambahkan properti <code>_Scale</code> . <br><br><pre> <code class="cpp hljs">Properties { ... _HeightTex (<span class="hljs-string"><span class="hljs-string">"Heightmap (R)"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"gray"</span></span> {} _Scale (<span class="hljs-string"><span class="hljs-string">"Scale"</span></span>, Vector) = (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br>  Dua properti baru ini juga harus sesuai dengan dua variabel dengan nama yang sama yang perlu ditambahkan ke bagian <code>CGPROGRAM</code> / <code>ENDCG</code> : <br><br><pre> <code class="cpp hljs">sampler2D _HeightTex; fixed2 _Scale;</code> </pre> <br>  Sekarang semuanya sudah siap, dan kita dapat mulai menulis kode yang akan melakukan offset. <br><br>  Langkah pertama adalah sampel nilai dari peta kedalaman, yang dapat dilakukan dengan menggunakan fungsi <code>tex2D</code> .  Karena <code>_HeightTex</code> adalah tekstur hitam dan putih, kita bisa mengambil saluran merahnya dan membuang sisanya.  Nilai yang dihasilkan mengukur jarak dalam beberapa unit acak dari piksel saat ini ke kamera. <br><br>  Nilai kedalaman antara <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhjD_my0ApilZmEeJmQj6xe2LIQv-A#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhjD_my0ApilZmEeJmQj6xe2LIQv-A#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  tapi kami akan merentangkannya ke interval dari <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2212;</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhjD_my0ApilZmEeJmQj6xe2LIQv-A#MJMAIN-2212" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhjD_my0ApilZmEeJmQj6xe2LIQv-A#MJMAIN-31" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>âˆ’</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-3"> -1 </script>  sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>+</mo><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhjD_my0ApilZmEeJmQj6xe2LIQv-A#MJMAIN-2B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/444706/&amp;usg=ALkJrhjD_my0ApilZmEeJmQj6xe2LIQv-A#MJMAIN-31" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>+</mo><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-4"> + 1 </script>  .  Ini memungkinkan Anda untuk memberikan paralaks positif (warna putih) dan negatif (warna hitam). <br><br><h2>  Teori </h2><br>  Untuk mensimulasikan efek paralaks pada tahap ini, kita perlu menggunakan informasi kedalaman untuk menggeser piksel gambar.  Semakin dekat piksel, semakin kuat perlu digeser.  Proses ini dijelaskan dalam diagram di bawah ini.  Pixel merah dari <em>gambar asli,</em> sesuai dengan informasi dari peta kedalaman, harus bergeser dua piksel ke kiri.  Demikian pula, piksel biru harus menggeser dua piksel ke kanan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/457/008/e69/457008e692048d9b5ef8eb2964f35fe2.png"></div><br>  Meskipun <em>secara teoritis</em> ini harus bekerja, tidak ada cara mudah untuk menerapkan ini di shader.  Masalahnya adalah bahwa shader dengan prinsipnya hanya dapat mengubah warna piksel <em>saat ini</em> .  Saat mengeksekusi kode shader, ia harus menggambar piksel tertentu di layar;  kita tidak bisa hanya memindahkan piksel ini ke tempat lain atau mengubah warna tetangga.  <em>Pembatasan lokalitas ini</em> memberikan operasi paralel shader yang sangat efisien, tetapi tidak memungkinkan kami untuk menerapkan semua jenis efek yang sepele asalkan ada <em>akses acak untuk merekam</em> setiap piksel dalam gambar. <br><br>  Jika kita ingin akurat, maka kita perlu sampel peta kedalaman semua piksel tetangga untuk mencari tahu yang mana yang harus (jika harus) pindah ke posisi saat ini.  Jika beberapa piksel berada di tempat yang sama, maka kita dapat meratakan pengaruhnya.  Meskipun sistem seperti itu bekerja dan memberikan hasil terbaik, sistem ini sangat tidak efisien dan berpotensi ratusan kali lebih lambat daripada shader difusi asli yang kami mulai. <br><br>  Alternatif terbaik adalah solusi berikut: kami mendapatkan kedalaman piksel saat ini dari peta kedalaman;  kemudian, jika kita perlu menggesernya <em>ke kanan</em> , maka ganti warna saat ini dengan piksel <em>di sebelah kiri</em> (lihat gambar di bawah).  Di sini kita mengasumsikan bahwa jika Anda ingin memindahkan piksel ke kanan, maka piksel tetangga di sebelah kiri juga seharusnya bergerak dengan cara yang sama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/cc8/7c0/699cc87c06761842edfc77449c195b43.png"></div><br>  Mudah untuk melihat bahwa ini hanyalah perkiraan biaya rendah dari apa yang benar-benar ingin kami capai.  Namun, ini sangat efektif karena peta kedalaman biasanya menjadi halus. <br><br><h2>  Kode </h2><br>  Dengan mengikuti algoritma yang dijelaskan pada bagian sebelumnya, kita dapat mengimplementasikan paralaks shader dengan <strong>offset</strong> sederhana <strong>dari koordinat UV</strong> . <br><br>  Ini mengarah ke kode berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Displacement fixed height = tex2D(_HeightTex, IN.uv_MainTex).r; fixed2 displacement = _Scale * ((height - 0.5) * 2); fixed4 c = SampleSpriteTexture (IN.uv_MainTex - displacement) * IN.color; ... }</span></span></code> </pre> <br>  Teknik ini bekerja dengan baik pada benda yang hampir rata, seperti yang terlihat dalam animasi di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ba/0c4/b8f/8ba0c4b8fa0fc51bf86c0874139feedb.gif"></div><br>  Tapi itu benar-benar bekerja sangat baik dengan model 3D, karena sangat mudah untuk membuat tekstur kedalaman untuk adegan 3D.  Di bawah ini adalah gambar yang diberikan 3D dan peta kedalamannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/701/179/d0f/701179d0f52d53b25f9d079d60dc8ae3.jpg"></div><br>  Hasil akhir ditunjukkan di sini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/134/28c/51d13428ce1f6b84cbb6b62984f86fe4.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444706/">https://habr.com/ru/post/id444706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444692/index.html">MOSDROID # 16 Sulphur di Redmadrobot</a></li>
<li><a href="../id444694/index.html">Seperti yang kami prediksi arus keluar, mendekatinya sebagai bencana alam</a></li>
<li><a href="../id444696/index.html">Tingkatkan kepadatan kontainer pada suatu simpul menggunakan teknologi PFCACHE</a></li>
<li><a href="../id444700/index.html">Basis data acak. Kualitas Data Oracle Enterprise - Perisai dan Pedang untuk Penyimpanan Perusahaan</a></li>
<li><a href="../id444704/index.html">Peluang nanoCAD SPDS Situs konstruksi dalam proyek konstruksi dan rekonstruksi dalam kondisi sempit</a></li>
<li><a href="../id444708/index.html">Aplikasi PentQL dengan GraphQL</a></li>
<li><a href="../id444710/index.html">Memahami Protokol Konsensus Stellar</a></li>
<li><a href="../id444712/index.html">"Sikap atipikal terhadap keuangan" - bagaimana jika karyawan sendiri yang akan mengelola pendapatan. Percakapan dengan Flant</a></li>
<li><a href="../id444714/index.html">Bagaimana kami melakukan overclock CAD COMPASS-3D â†’ Bagian 1</a></li>
<li><a href="../id444716/index.html">Ponsel Samsung dengan layar lipat sebesar $ 2000 menampilkan lipatan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>