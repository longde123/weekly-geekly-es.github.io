<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🏭 ⚖️ 🙅 Parsing demo 128-byte dari arsip 1997 🌞 💫 🌩️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sangat menyenangkan untuk memenuhi keinginan saya, terutama dari masa lalu yang jauh, begitu jauh sehingga saya sudah lupa bahwa saya pernah mengingin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parsing demo 128-byte dari arsip 1997</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482826/"> Sangat menyenangkan untuk memenuhi keinginan saya, terutama dari masa lalu yang jauh, begitu jauh sehingga saya sudah lupa bahwa saya pernah menginginkannya.  Saya tahu sedikit tentang demoscene dan saya tentu saja tidak pernah mengikuti penulis atau pekerjaan mereka, saya hanya suka menonton apa yang terjadi.  Kadang-kadang saya ingin mengetahuinya, tetapi kemudian saya tidak memiliki pengetahuan dan pengalaman, kemudian ketekunan, dan kemudian saya benar-benar kehilangan minat dalam hal ini.  Tetapi baru-baru ini, teman saya, dengan siapa kami belajar pada waktu itu dan yang memasok kami dengan semua produk baru, termasuk demo, dengan BBS dan Fidonet, karena ia hampir semua memiliki telepon dan modem dan komputer pada saat yang sama, mengunjungi <a href="https://cafeparty.org.ru/2019/" rel="nofollow">CAFePARTY</a> dengan pekerjaannya yang membuat saya membuka arsip komputer pertama saya, pilih demo dan cari tahu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/yt/35/noyt35q-swsum-xmzb10a5px1rk.gif" alt="pentagra.com"></div><br>  Mengevaluasi kekuatan saya secara objektif, saya mengambil intro 128 byte yang saya sukai secara visual.  File <code>pentagra.com</code> ditandatangani oleh <b>Mcm</b> , 128 byte, terakhir diubah 9/24/1996 18:10:14, hex dump: <br><br> <code>000000: b0 13 cd 10 68 00 a0 07 06 1f ac ba c8 03 ee 42 <br> 000010: b1 40 ee 40 6e 6e e2 fa b8 3f 3f bb 40 01 bf 40 <br> 000020: 05 57 b1 78 ab 03 fb e2 fb 5f b1 60 88 01 aa 03 <br> 000030: fb 03 fb e2 f7 b1 61 88 01 aa 2b fb 2b fb e2 f7 <br> 000040: bf d1 99 57 b1 78 ab 2b fb e2 fb 5f b1 8f f3 ab <br> 000050: 81 fe 00 fa 73 12 ac 0a c0 74 0d 48 88 44 fe 88 <br> 000060: 04 88 40 ff 88 84 bf fe 03 f2 42 75 e3 e4 60 3c <br> 000070: 01 75 a5 b8 03 00 cd 10 c3 00 00 00 00 4d 63 6d <br></code> <a name="habracut"></a><br>  Dari arsip yang sama saya menarik: <br><br><ul><li>  <b>Hiew 6,11</b> ( <a href="http://www.hiew.ru/" rel="nofollow">6,50</a> dapat ditemukan di situs) - Saya menggunakannya sebagai disassembler </li><li>  Paket <b>TASM</b> - dengan mana saya mengumpulkan kode yang diterima kembali untuk memastikan bahwa saya tidak mengacaukan apa pun </li><li>  <b>Bantuan TECH Flambeaux Software!</b>  <b>6.0</b> - referensi online yang cukup terperinci dan komprehensif untuk API DOS, fungsi BIOS, perangkat keras dan assembler </li><li>  <b>Mayko G.V.</b>  <b>Assembler untuk IBM PC</b> - referensi format berukuran hampir saku untuk semua perintah dasar Intel 8086 dan aturan pemformatan teks program.  Tanpa detail arsitektur dan dengan contoh-contoh dasar, hanya hal-hal yang paling mendasar.  Ada hampir semua yang Anda butuhkan di sini, tetapi Anda tidak dapat menulis dalam assembler selain dari lingkungan. </li><li>  Oleh karena itu, buku kedua <b>Zubkov S.V.</b>  <b>Assembler.</b>  <b>Untuk DOS, Windows, dan Unix</b> - Panduan untuk Nook Hardware dan DOS </li></ul><br>  Dari implementasi minimal yang ekstrim, kita harus mengharapkan penggunaan trik dan pendekatan non-standar, tetapi terlepas dari beberapa asumsi dalam kondisi awal, saya tidak melihat trik teknis, tetapi saya melihat trik algoritmik.  Dan di sini beberapa kata harus dikatakan tentang pengalaman itu.  Apa yang bisa menjadi kesulitannya?  Baik dalam implementasi atau dalam algoritma.  Misalnya, dalam perintah <code>mov di, 099d1h</code> , Anda mungkin takut dengan konstanta sihir.  Tetapi jika Anda berada dalam konteks penggunaan, menjadi jelas bahwa ini adalah alamat untuk akses pada koordinat layar X dan Y, di mana X = 17, Y = 123, 320 adalah resolusi horizontal layar dalam piksel.  Bersama-sama, ini memberi kita 17 + 123 * 320, konversi koordinat dua dimensi menjadi satu dimensi. <br><br>  Melihat sekarang apa yang terjadi di layar, saya dapat dengan mudah membayangkan bagaimana saya bisa mengimplementasikan ini, walaupun tidak dengan 128 byte, bahkan jika tidak 100% mirip, tapi saya bisa.  Dan 20 tahun yang lalu, saya tidak bisa, walaupun saya mengeluarkan semua alat yang saya gunakan dari rak berdebu dan saya tidak perlu menjelajah Internet untuk memahami cara kerjanya.  Oleh karena itu, pertama-tama, ini adalah konteks, pemahaman tentang APA yang terjadi, dan pertanyaan tentang trik dan BAGAIMANA melakukannya adalah di tempat kedua. <br><br>  Apa yang kita lihat: <br><br><ol><li>  5 baris pentagram.  Ini bukan garis langsung yang tidak dapat dipisahkan menurut semua kanon.  Kami hanya melihat sosok umum, tanpa detail </li><li>  Efek nyala, yang terdiri dari dua bagian penting: palet yang dipilih dengan benar dan algoritma untuk secara konstan mengubah warna titik-titik pada layar dengan unsur-unsur ketidakpastian, tetapi mempertahankan urutan palet terus menerus untuk titik-titik tetangga.  Misalnya, Anda dapat menghitung seluruh layar saat ini dengan rata-rata nilai piksel tetangga dari layar sebelumnya, dan menambahkan lebih banyak titik "cerah" di tempat-tempat acak, atau tidak di tempat-tempat acak, tetapi nilainya acak, atau tidak sama sekali kebetulan, hanya menjauh dari urutan linier.  Salah satu opsi adalah <a href="https://habr.com/ru/post/435122/">bagaimana hal itu dilakukan dalam DOOM</a> .  Hasilnya harus dalam bentuk warna yang mengalir satu sama lain, dari area terang yang terus muncul hingga memudar </li></ol><br>  Masih memahami bagaimana ini dilakukan.  Deskripsi lebih lanjut tidak akan menggantikan pengetahuan tentang arsitektur komputer dan fungsi-fungsi DOS atau assembler, tetapi memiliki pengetahuan ini akan memungkinkan Anda untuk memahami dan fokus pada esensi dari apa yang terjadi.  Setelah mulai menulis, saya menyadari bahwa ternyata semuanya sama dalam detail yang cukup, tetapi saya tidak bisa menolaknya agar tidak hilang dalam arti cerita. <br><br><h3>  DOS dan memuat program .COM </h3><br>  Program dalam file <code>.com</code> adalah kode bersih, tanpa header, Anda hanya perlu meletakkannya di tempat yang tepat.  Inilah yang dilakukan DOS, atau lebih tepatnya panggilan sistem 4Bh.  Cukup banyak tindakan yang terjadi, mari kita pikirkan hasilnya: <br><br><ul><li>  Semua segmen mendaftar CS, DS, ES, SS dimuat dengan nilai tunggal </li><li>  65536 byte dicadangkan untuk seluruh program, tepat satu segmen yang ditunjukkan oleh semua register segmen.  256 byte pertama ditempati oleh header sistem - PSP (Program Segment Prefix).  Di CS: 0, bidang pertama PSP, perintah INT 20h terletak - untuk mengakhiri program saat ini dan mentransfer kontrol ke proses induk.  Program itu sendiri dimulai dengan CS: 100h address dan menempati 128 byte berikut </li><li>  Kata 0000h didorong ke tumpukan, register SP adalah FFFEh.  Ini berarti bahwa dua byte terakhir di segmen ini di alamat SS: FFFEh diatur ulang.  Bahkan, ini adalah alamat pengirim terdekat dari prosedur, yang akan membawa kita ke perintah penyelesaian di CS: 0 </li><li>  Register AL dan AH berisi flag kesalahan untuk menentukan huruf drive dari argumen pertama dan kedua ketika program dipanggil.  Jika tidak ada kesalahan, maka itu adalah 0, jika ada maka FFh </li></ul><br>  Saya dengan tulus percaya bahwa dalam kasus umum status register tidak ditentukan.  Tetapi dalam kode yang dianalisis, menurut pendapat saya, asumsi yang sangat berani dibuat tentang keadaan awal mereka, khususnya tentang CX, register SI dan bendera arah DF.  Saya tidak menemukan konfirmasi ini dalam daftar sumber yang menghasilkan di atas, jadi saya pergi untuk melihat melalui sumber <a href="" rel="nofollow">MS-DOS 2.0</a> : <br><br><ul><li>  Tentang DF, kita dapat mengasumsikan bahwa itu disetel ulang oleh perintah <code>cld</code> , karena yang terakhir menggunakan arah maju sebelum mentransfer kontrol ke <code>cld</code> baris, oleh karena itu, DF diatur ulang.  Meskipun tidak ada penggunaan eksplisit <code>cld</code> di tempat ini, perintah untuk menghapus bendera arah ditemui cukup sering sebelum banyak transfer lainnya </li><li>  SI berisi 100 jam, karena digunakan untuk menentukan offset yang akan dimuat ke dalam register oleh penghitung perintah IP </li><li>  CX sama dengan FFh, karena digunakan sebagai penghitung dengan nilai awal 80h untuk mentransfer isi dari seluruh baris perintah dan, karenanya, setelah mentransfernya adalah 0. Dan setelah itu, CL, sebagai variabel sementara, memuat FFh dan digunakan untuk mengatur bendera kesalahan huruf drive di AL dan AH </li></ul><br>  Tidak ada sumber versi yang lebih baru, tetapi ada <a href="https://sourceforge.net/projects/dosbox/files/dosbox/" rel="nofollow">sumber DOSBox</a> : <br><br><pre> <code class="cpp hljs">reg_ax=reg_bx=<span class="hljs-number"><span class="hljs-number">0</span></span>;reg_cx=<span class="hljs-number"><span class="hljs-number">0xff</span></span>; reg_dx=pspseg; reg_si=RealOff(csip); reg_di=RealOff(sssp);</code> </pre><br>  Artinya, ini bertepatan dengan apa yang saya lihat dalam kode sumber MS-DOS (versi ke-2!), Anda dapat melihat nilai awal register lain, ini dia inisialisasi khusus dan eksplisit.  Untuk MS-DOS, nilai register selain AX, segmen, dan stack adalah dasar penggunaannya untuk tujuan lain, ini bukan dogma atau standar, oleh karena itu, mereka tidak disebutkan di mana pun.  Tetapi di sisi lain, ekosistem yang telah terbentuk dan seluruh rasa sakit Microsoft dalam mendukung kompatibilitas dengan versi lama, memaksa untuk menyeret semua nilai yang dihasilkan secara acak, menjadi sedikit dimengerti, karena programmer sangat terbiasa dengannya. <br><br>  Akhirnya, bagi kami pengetahuan ini cukup, kami mulai memulihkan program dari header: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup</code> </pre><br>  Kami menentukan jenis prosesor 80186, karena kami menggunakan perintah <code>outsb</code> , yang hanya muncul dalam model ini.  Satu segmen kode dan titik masuk ke program, yang, bersama dengan definisi model memori <code>tiny</code> , akan memungkinkan kompiler menghitung dengan benar semua offset variabel dan transisi.  Saat membangun <code>tlink</code> , tombol <code>/t</code> digunakan, pada output ini akan memberikan file <code>.com</code> . <br><br><h3>  Grafis dan palet </h3><br>  Untuk beralih ke mode grafis, Anda perlu beralih ke fungsi BIOS, yang disebut gangguan 10 jam, AH = 0, di AL kami menempatkan pengenal mode yang diinginkan - 13 jam: <br><br><pre> <code class="cpp hljs">mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h ;b0 <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Harap dicatat bahwa kami tidak menyentuh AH, dengan asumsi bahwa ada nol, sesuai dengan kondisi pemuatan program.  Mode yang dipilih sesuai dengan resolusi grafis 320 kali 200 piksel dengan palet 256 warna.  Untuk menampilkan titik di layar, Anda perlu menulis ke area memori, yang dimulai dengan alamat A000h: 0, byte yang sesuai dengan warna.  Isi register data segmen dengan nilai ini: <br><br><pre> <code class="cpp hljs">push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h ;<span class="hljs-number"><span class="hljs-number">68</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> a0 pop es ;<span class="hljs-number"><span class="hljs-number">07</span></span> push es ;<span class="hljs-number"><span class="hljs-number">06</span></span> pop ds ;<span class="hljs-number"><span class="hljs-number">1f</span></span></code> </pre><br>  Logikanya, memori diatur sebagai larik dua dimensi di mana koordinat layar ditampilkan, 0: 0 sesuai dengan sudut kiri atas.  Setelah beralih mode, itu diisi dengan nol - hitam di palet default.  Rumus untuk menerjemahkan ke perpindahan linear adalah <b>X + Y * L</b> , di mana L adalah resolusi horizontal, dalam kasus kami 320. Dalam formulir ini, saya akan menulis di tempat-tempat di mana konstanta digunakan, ketika menerjemahkan teks program mereka dihitung secara otomatis. <br><br>  Untuk mengubah palet, kami langsung mengakses peralatan menggunakan port input / output: <br><br><pre> <code class="cpp hljs">lodsb ;ac mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h ;ba c8 <span class="hljs-number"><span class="hljs-number">03</span></span> out dx, al ;ee</code> </pre><br>  Perintah pertama dimuat ke AL ​​byte data yang terletak di DS: SI.  Di DS, kami telah memuat alamat segmen memori video dan kami tahu bahwa itu diisi dengan nol, di SI - dalam kasus umum, tidak diketahui bahwa setidaknya 0. Tidak masalah bagi kami di mana pun SI menunjukkan, kami hampir pasti masuk ke memori video yang menempati dengan resolusi ini 320 * 200 = 64000 byte, hampir seluruh segmen.  Dengan demikian, kami berharap bahwa setelah perintah ini AL = 0.  Unit ditambahkan atau dikurangi menjadi SI, tergantung pada pengaturan bendera arah DF.  Meskipun ini juga tidak terlalu penting bagi kami, di mana pun SI bergerak, kami masih tetap berada di area memori video yang penuh dengan nol. <br><br>  Selanjutnya, muat DX dengan nomor port 03C8h, output yang menentukan warna 256 yang akan kita timpa.  Dalam kasus kami, ini adalah 0 dari AL. <br><br>  Warna dikodekan dalam palet RGB dan untuk ini Anda harus menulis ke port 03C9h (satu lebih dari 3C8h) tiga kali berturut-turut, satu kali untuk masing-masing komponen.  Kecerahan maksimum komponen adalah 63, minimum adalah 0. <br><br><pre> <code class="cpp hljs">inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">64</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">40</span></span> PALETTE: out dx, al ;ee inc ax ;<span class="hljs-number"><span class="hljs-number">40</span></span> outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e outsb ;<span class="hljs-number"><span class="hljs-number">6</span></span>e loop PALETTE ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-6</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">,    6  </span></span></code> </pre><br>  Tambah DX satu per satu sehingga memiliki nomor port yang diinginkan.  CL adalah penghitung siklus kami dari 64, dan kami mengasumsikan bahwa CH = 0, seperti yang dijelaskan sebelumnya berdasarkan kondisi pemuatan awal.  Selanjutnya, kita output komponen pertama ke port - yang merah, kecerahan yang akan disimpan dalam AL, itu yang akan kita ubah, pada langkah pertama 0. Setelah itu kita tingkatkan kecerahannya satu per satu untuk ditampilkan pada iterasi berikutnya.  Selanjutnya, kita menjalankan dua perintah <code>outsb</code> menulis ke port, yang nomornya terdapat dalam DX, byte dari area memori DS: SI, ingat bahwa kita memiliki nol di sana.  SI setiap kali berubah satu. <br><br>  Segera setelah kami menyimpulkan ketiga komponen, sebuah unit secara otomatis ditambahkan ke nomor warna.  Dengan demikian, tidak perlu mendefinisikan ulang warna dengan keluaran ke port 3C8h jika warnanya berturut-turut, seperti yang diperlukan.  Perintah <code>loop</code> akan mengurangi CX oleh satu, jika nilai bukan nol diperoleh, itu akan pergi ke awal siklus, jika 0, lalu ke perintah berikutnya setelah siklus. <br><br>  Sebanyak 64 kali pengulangan.  Pada setiap pengulangan, kami menentukan warna, mulai dari 0 hingga 63, komponen merah dengan kecerahan bertepatan dengan nomor warna saat ini.  Kami mengatur ulang komponen hijau dan biru untuk mendapatkan palet seperti itu dari kecerahan minimum hingga maksimum merah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lz/py/jq/lzpyjqjyav0-x3qdl5easmdesvs.png" alt="palet"></div><br><br><h3>  Garis </h3><br>  Siapkan warna awal dan nilai koordinat: <br><br><pre> <code class="cpp hljs">LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh ;b8 <span class="hljs-number"><span class="hljs-number">3f</span></span> <span class="hljs-number"><span class="hljs-number">3f</span></span> mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bb <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span></code> </pre><br>  Dalam AL dan AH, kami memuat masing-masing warna 63 (3Fh), maksimum yang dimungkinkan, AX mendefinisikan dua titik sekaligus.  BX - resolusi horisontal maksimum.  Di masa depan, ini akan digunakan untuk menambah atau mengurangi satu baris dari koordinat saat ini.  DI - koordinat 64: 4, simpan di tumpukan. <br><br>  <b>Gambar garis pertama dari sudut kiri atas ke ekstrem kanan</b> : <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE1: stosw ;ab add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE1 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Konfigurasikan penghitung - ini akan menjadi jumlah baris.  Selanjutnya, simpan kata (dua byte) dari AX ke alamat ES: DI.  Tindakan ini akan menampilkan dua titik pada layar dengan warna maksimum dari palet kami, karena ES dikonfigurasi untuk memori video, dan koordinat tertentu diatur dalam DI.  Setelah tindakan ini, 2 akan ditambahkan ke DI, karena dua byte ditulis.  Kami jelas tidak mengatur bendera arah DF dan bergantung pada fakta bahwa itu diatur ulang, sekali lagi kami mengingat kondisi awal kami untuk memuat program.  Kalau tidak, keduanya akan diambil, yang tidak memungkinkan menggambar garis yang diinginkan. <br><br>  Selanjutnya, DI = DI + BX, yang setara dengan meningkatkan koordinat Y per satu.  Dengan demikian, dalam tubuh siklus, dua titik digambar dalam satu garis, koordinat X bertambah 2, dan koordinat Y sebesar 1 dan tindakan ini diulang 120 kali, gambar dengan hasilnya sedikit lebih rendah. <br><br>  <b>Baris kedua adalah dari kiri atas ke atas</b> : <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">60</span></span> LINE2: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb add di, bx ;<span class="hljs-number"><span class="hljs-number">03</span></span> fb loop LINE2 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  Kami mengembalikan koordinat awal 64: 4 dan mengatur penghitung ke 96 pengulangan.  Kami mencetak satu titik, tetapi satu baris di bawah koordinat saat ini.  Seperti sebelumnya, ini dicapai dengan menambahkan nilai dari BX, hanya tanpa menyimpan koordinat baru.  Konstruksi <code>[bx+di]</code> atau <code>[bx][di]</code> disebut pengalamatan basis dengan pengindeksan dan bekerja pada tingkat prosesor, bukan penerjemah.  Register segmen default dengan BX adalah DS.  Setelah itu kami menampilkan titik kedua, tetapi sudah di koordinat saat ini.  DI, dan karena itu X bertambah satu, karena hanya perintah transfer satu byte yang <code>stosb</code> - <code>stosb</code> .  Dua perintah terakhir dari tubuh siklus adalah peningkatan Y sebesar 2, yang kita gunakan lagi BX. <br><br>  Setelah menggambar dua garis, gambar berikut diperoleh di dekat sudut kiri atas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xv/nu/fk/xvnufkuhyvi0gwqomrquixlvti8.png" alt="baris 1,2"></div><br><br>  Koordinat kiri dan atas, di sebelah kanan alamat offset dalam memori video.  Poin 64: 4 akan ditarik dua kali. <br><br>  <b>Baris ketiga adalah dari atas ke sudut kanan atas</b> : <br><br><pre> <code class="cpp hljs">mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">61</span></span> LINE3: mov [bx+di], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> stosb ;aa sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb loop LINE3 ;<span class="hljs-function"><span class="hljs-function">e2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-9</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre><br>  DI sudah berisi nilai koordinat yang diinginkan 160: 196, kita perlu menggambar garis dari atas di mana garis sebelumnya berakhir, bergerak ke atas layar sambil mempertahankan sudut yang sama.  Dengan demikian, siklusnya hampir identik.  CX ditingkatkan sebesar 1, karena koordinat Y saat ini adalah 2 lebih (lebih rendah) daripada di mana garis sebelumnya berakhir, sudah dihitung untuk iterasi berikutnya.  Karena itu, untuk sampai ke sudut atas, Anda perlu mengambil langkah ekstra.  Pergerakan sepanjang X berlanjut ke arah yang sama - ditambah satu setelah setiap iterasi, dan sepanjang Y, alih-alih menambahkan, kita kurangi keduanya.  Poin ditampilkan dalam urutan yang sama, pertama lebih rendah lalu atas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d8/bw/3f/d8bw3fucavqttjhld9wqrlqsi_s.png" alt="baris 3"></div><br><br>  <b>Baris keempat adalah dari paling kiri ke sudut kanan atas:</b> <br><br><pre> <code class="cpp hljs">mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> ;bf d1 <span class="hljs-number"><span class="hljs-number">99</span></span> push di ;<span class="hljs-number"><span class="hljs-number">57</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">78</span></span> LINE4: stosw ;ab sub di, bx ;<span class="hljs-number"><span class="hljs-number">2b</span></span> fb(<span class="hljs-number"><span class="hljs-number">-5</span></span>) loop LINE4</code> </pre><br>  Kami lagi dalam koordinat yang diperlukan, tetapi ini tidak digunakan, tampaknya agar tidak mengubah bendera arah DF.  Oleh karena itu, koordinat baru ditempatkan di DI dan disimpan di tumpukan. <br><br>  Selanjutnya, semuanya identik dengan baris pertama, hanya koordinat Y tidak tumbuh, tetapi menurun, kita naik. <br><br>  <b>Baris kelima adalah horizontal:</b> <br><br><pre> <code class="cpp hljs">pop di ;<span class="hljs-number"><span class="hljs-number">5f</span></span> mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> ;b1 <span class="hljs-number"><span class="hljs-number">8f</span></span> rep stosw ;f3 ab</code> </pre><br>  Semuanya sederhana di sini, mekanisme transmisi mikroprosesor digunakan, karena garis horizontal berhubungan dengan peningkatan sederhana pada alamat setiap titik berikutnya.  Dalam DI, alamat yang sesuai dengan koordinat sudut ekstrem kiri, disimpan pada langkah sebelumnya, dikembalikan.  Jumlah pengulangan dalam CX diatur dan awalan pengulangan diterapkan dengan perintah transfer kata. <br><br>  Setelah tindakan ini, kami memiliki pentagram yang sepenuhnya digambar dalam warna paling cerah.  80 byte digunakan dan 48 cadangan. <br><br><h3>  Sihir api </h3><br>  <b>Kami menetapkan syarat batas untuk perhitungan:</b> <br><br><pre> <code class="cpp hljs">FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> ;<span class="hljs-number"><span class="hljs-number">81</span></span> fe <span class="hljs-number"><span class="hljs-number">00</span></span> fa jae NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">73</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> lodsb ;ac <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al ;<span class="hljs-number"><span class="hljs-number">0</span></span>a c0 jz NEXT_PIXEL ;<span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>d</code> </pre><br>  Di SI akan ada koordinat titik saat ini untuk perhitungan, jika kita melampaui batas layar, maka kita tidak melakukan perhitungan dengan titik ini, kita lanjutkan menghitung yang berikutnya. <br><br>  <code>lodsb</code> memuat byte dari area DS: SI ke dalam AL, yaitu warna titik pada koordinat saat ini.  Jika 0, maka kami juga tidak melakukan apa pun dan beralih ke poin berikutnya. <br><br>  <b>Perhitungan warna baru</b> <br><br>  Ini adalah algoritma utama untuk mengubah nilai warna pada layar, ini bukan nyala api, ini adalah dasar untuk itu.  Kami menghitung titik tetangga dan mencapai kontinuitas warna: <br><br><pre> <code class="cpp hljs">dec ax ;<span class="hljs-number"><span class="hljs-number">48</span></span> mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">44</span></span> fe mov [si], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> ff mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al ;<span class="hljs-number"><span class="hljs-number">88</span></span> <span class="hljs-number"><span class="hljs-number">84</span></span> bf fe</code> </pre><br>  Kurangi dari AX, sebenarnya dari AL, unit yang berisi nilai warna bukan nol yang diperoleh dari koordinat saat ini.  Selanjutnya, kami menuliskan nilai yang diperoleh ke semua titik tetangga, relatif terhadap koordinat saat ini, yaitu, sedikit dari mereka, berdasarkan palet kami. <br><br>  Karena setelah <code>lodsb</code> , nilai SI meningkat satu dan tidak lagi sesuai dengan titik yang warnanya kita baca dalam AL, ini harus disesuaikan.  Perhatikan bahwa perintah transfer byte <code>stosb</code> tidak lagi digunakan, sebagai gantinya, <code>mov</code> digunakan untuk menentukan alamat tempat nilai akan ditempatkan.  Jika kami menerima bahwa koordinat saat ini adalah X: Y, untuk mereka SI-1, maka: <br><br><ul><li>  <code>mov [si-2], al</code> - merekam warna baru pada titik X-1: Y, di sebelah kiri warna saat ini.  2 dikurangi dari SI karena alasan yang dijelaskan di atas, karena unit tambahan telah ditambahkan ke dalamnya </li><li>  <code>mov [si], al</code> - rekam warna baru pada titik X + 1: Y, di sebelah kanan warna saat ini.  SI sudah memiliki X +1 </li><li>  <code>mov [bx+si-1], al</code> - menulis warna baru ke titik X: Y + 1, di bawah yang sekarang.  Sekali lagi gunakan BX untuk Y + 1 </li><li>  <code>mov [si-1-1*320], al</code> - menulis warna baru ke titik X: Y-1, di atas yang sekarang.  Kami tidak akan dapat menggunakan BX, karena kami harus mengambil koordinat, arsitektur prosesor tidak memungkinkan kami melakukan ini dalam formulir ini, oleh karena itu konstanta digunakan sesuai dengan rumus reduksi koordinat </li></ul><br>  Register segmen adalah DS, yang digunakan secara default dengan SI dan BX. <br><br>  Tidak ada situasi yang diperiksa ketika titik menyentuh tepi layar.  Ini tidak dapat menyebabkan kegagalan, karena kami akan selalu berada dalam batas-batas segmen video.  Titik tetangga dapat jatuh ke area yang tidak dilaporkan dengan alamat lebih dari 64.000 atau ke jalur yang berdekatan, yang tidak membahayakan kita dan bahkan sedikit membantu, seperti yang akan dilihat dari uraian lebih lanjut. <br><br>  <b>Sihir yang sama, perhitungan koordinat titik berikutnya</b> <br><br><pre> <code class="cpp hljs">NEXT_PIXEL: add si, dx ;<span class="hljs-number"><span class="hljs-number">03</span></span> f2 inc dx ;<span class="hljs-number"><span class="hljs-number">42</span></span> jnz FLAME ;<span class="hljs-number"><span class="hljs-number">75</span></span> e3(<span class="hljs-number"><span class="hljs-number">-29</span></span>)</code> </pre><br>  Mari kita kembali sedikit, kami tidak secara khusus menetapkan nilai SI awal di mana saja, dan di DX kami masih memiliki jumlah port input output yang kami gunakan untuk palet.  Kami hanya melakukan tiga tindakan sederhana SI = SI + DX, jelas ini akan menetapkan koordinat baru, yang mana?  DX = DX + 1 dan jika DX tidak sama dengan 0, maka kembali ke algoritma dasar untuk mendapatkan dan menghitung titik tetangga, yaitu, apakah DX semacam counter? <br><br>  Kami tahu bahwa kami perlu berkeliling semua titik dan menghitung perubahan kecerahan tetangga mereka.  Jika Anda melakukan ini berturut-turut, maka kita mungkin akan mendapatkan gradien statis, mungkin tidak merata, tetapi tidak berubah di sekitar baris kami.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita tahu ukuran layar kita dan berapa banyak poin yang perlu kita lewati, tetapi di sini kita hampir mengabaikannya, lebih tepatnya, memilih nilai tutup 65536 daripada 64000 yang tepat. DX benar-benar sebuah penghitung, hanya 65536. Tetapi mengapa nilai awalnya tidak penting dan mengapa kita mengambil Apakah nilai akhir lebih besar dari total titik pada layar? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena kita berkeliling poin tidak berturut-turut dan tidak semua. Setiap koordinat linier berikutnya lebih besar dari yang sebelumnya dengan nilai DX. Artinya, dalam SI jumlah elemen DX dari perkembangan aritmatika sederhana: 0,1,2,3,4,5,6, ..., 362,363, ..., 65535. Ini sudah memberi kita non-linearitas, jika Anda mulai dengan SI = 0 dan DX = 0, maka di SI kita mendapatkan: 0,1,3,4,6,10,15,15,21, ..., 65341,65703, ..., 2147450880.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi itu tidak semua, karena dimensi SI adalah 16 bit, kita tidak bisa mendapatkan nilai lebih besar dari 65535, terjadi overflow dan modulo 65536 sisanya tetap dalam SI. Rumus perhitungan koordinat linear mengambil bentuk SI = (SI + DX) MOD 65536, yang benar-benar memecah urutan kontinu: 0,1,3,4,6,10,15,21, ..., 65341,167.530.894, ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita ingat bahwa SI tidak diinisialisasi dengan cara apa pun, yaitu, waktu berikutnya kita kembali ke siklus ini maka kita akan mulai dari koordinat tempat kami tinggalkan, dan bukan dari 0 atau beberapa yang diberikan. Ini akan menambah kekacauan pada urutan kami - memperpanjang jumlah elemen yang tidak berulang. Kalau tidak, traversal poin akan selalu sama, meskipun non-linear. Efek nyala akan muncul, tetapi tidak begitu jelas. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita membicarakan triknya, maka ini dia.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DX, selalu, kecuali untuk penggunaan pertama, secara implisit dimulai pada 0 sebagai hasil dari luapan </font></font><code>inc dx</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan sedikit lebih banyak kekacauan ditambahkan oleh nilai batas kami, karena untuk SI&gt; = 64000 tidak ada titik yang akan ditarik dan urutan output sedikit bingung. Dan melewatkan semua poin dengan nilai nol mengarah ke efek pengapian di beberapa detik pertama program. Ini karena siklus penuh berakhir lebih cepat, karena sebagian besar poin tidak diproses. Tetapi yang paling penting, karena kecerahan untuk sebagian besar poin hanya akan meningkat, mereka tidak dapat dikaburkan oleh bagian dimmer tetangga - mereka hanya belum ada, dan nilai nol tidak dihitung. Setelah area yang benar-benar hitam hilang, keseimbangan terbentuk, beberapa area akan meningkatkan kecerahan, dan beberapa akan berkurang.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akibatnya, kita tidak bisa lagi berbicara tentang urutan atau gradien apa pun, poin tidak disalurkan, setiap kali dalam urutan baru, termasuk mengulang beberapa kali atau melewatkan sama sekali. </font><font style="vertical-align: inherit;">Ini mengarah pada pembentukan daerah-daerah dengan kecerahan berbeda yang dicampur satu sama lain, berubah pada setiap iterasi baru. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi ini belum semuanya, jika Anda tidak menambahkan titik terang baru, maka pada akhirnya semuanya akan dibayar kembali. </font><font style="vertical-align: inherit;">Oleh karena itu, setelah DX mencapai nilai maksimumnya, kami kembali untuk menggambar lima garis terang lagi dan lagi menghitung semua poin di layar:</font></font><br><br><pre> <code class="cpp hljs">in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h ;e4 <span class="hljs-number"><span class="hljs-number">60</span></span> cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h ;<span class="hljs-number"><span class="hljs-number">3</span></span>c <span class="hljs-number"><span class="hljs-number">01</span></span> jne LINES ;<span class="hljs-number"><span class="hljs-number">75</span></span> a5(<span class="hljs-number"><span class="hljs-number">-91</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi sebelum itu, kita membaca dari port 60h, ini adalah keyboard, kode pindaian dari tombol terakhir ditekan. </font><font style="vertical-align: inherit;">Untuk ESC sama dengan 1. Jika demikian, tombol ESC ditekan, kami bergerak menuju pintu keluar.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penyelesaian </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu diperhatikan bahwa saat memperbarui layar saat ini, yang membutuhkan waktu, Anda tidak dapat keluar dari program, yaitu reaksi terhadap ESC akan tertunda. Jika selama menunggu dan setelah ESC beberapa tombol ditekan, kami akan tetap berada di program, hanya kode pindaian terakhir yang dapat dibaca dari port. Satu hal lagi, kita tidak mengganti atau menggunakan fungsi sistem DOS dan BIOS untuk ini, terlepas dari apa yang kita baca dari port, tombol yang ditekan ditempatkan di buffer melingkar dan mungkin akan dibaca dari sana oleh program berikutnya setelah intro kita selesai, kemungkinan besar file manajer atau </font></font><code>command.com</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini akan menyebabkan pemrosesan, misalnya, Komandan Volkov di ESC akan menyembunyikan panelnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetap kembali ke mode teks 3:</font></font><br><br><pre> <code class="cpp hljs">mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h ;b8 <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h ;cd <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diasumsikan bahwa kami berada dalam mode ini sebelum peluncuran program, tetapi dalam kasus umum ini mungkin tidak demikian. </font><font style="vertical-align: inherit;">Di sini kami memperbarui seluruh AX, karena kami tahu pasti bahwa AH tidak mengandung 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang Anda dapat keluar:</font></font><br><br><pre> <code class="cpp hljs">retn ;c3</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah perintah keluar dekat dari prosedur yang mengambil nilai kata ditempatkan di sana (dua byte) dari tumpukan dan memuatnya ke penghitung perintah IP. </font><font style="vertical-align: inherit;">Menurut kondisi awal, kita memiliki angka nol di stack, ini akan membawa kita ke alamat CS: 0, di mana seperti yang kita tahu kode perintah terletak </font></font><code>int 20h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- shutdown. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan 7 byte untuk hak cipta:</font></font><br><br><pre> <code class="cpp hljs">dd <span class="hljs-number"><span class="hljs-number">0</span></span>h ;<span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> ;<span class="hljs-number"><span class="hljs-number">4</span></span>d <span class="hljs-number"><span class="hljs-number">63</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>d end</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kita dapat mengatakan bahwa masih ada tempat yang akan saya habiskan untuk inisialisasi yang lebih ketat, tetapi karena semuanya bekerja di DOSBox modern, penulis mungkin melakukan semuanya dengan benar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita bahas sekali lagi:</font></font><br><br><ol><li>    ,        </li><li>  4    ,           :  X+1  Y+2,  X+2  Y+1.         ,       .    ,          </li><li>       SI=(SI+DX) MOD 65536,     DX ,     ,      ,     SI.         1.   65536 ,    ,     .     ,         — <code>add si, dx</code>  <code>inc dx</code> ,            ,       </li><li>     ESC  ,           </li></ol><br><div class="spoiler"> <b class="spoiler_title">  .</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">.186</span></span> .model tiny .code .startup mov al, <span class="hljs-number"><span class="hljs-number">13</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h push <span class="hljs-number"><span class="hljs-number">0</span></span>a000h pop es push es pop ds lodsb mov dx, <span class="hljs-number"><span class="hljs-number">03</span></span>c8h out dx, al inc dx mov cl, <span class="hljs-number"><span class="hljs-number">040</span></span>h PALETTE: out dx, al inc ax outsb outsb loop PALETTE LINES: mov ax, <span class="hljs-number"><span class="hljs-number">03f</span></span>3fh mov bx, <span class="hljs-number"><span class="hljs-number">0</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> mov di, <span class="hljs-number"><span class="hljs-number">64</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE1: stosw add di, bx loop LINE1 pop di mov cl, <span class="hljs-number"><span class="hljs-number">96</span></span> LINE2: mov [bx+di], al stosb add di, bx add di, bx loop LINE2 mov cl, <span class="hljs-number"><span class="hljs-number">97</span></span> LINE3: mov [bx+di], al stosb sub di, bx sub di, bx loop LINE3 mov di, <span class="hljs-number"><span class="hljs-number">17</span></span>+<span class="hljs-number"><span class="hljs-number">123</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span> push di mov cl, <span class="hljs-number"><span class="hljs-number">120</span></span> LINE4: stosw sub di, bx loop LINE4 pop di mov cl, <span class="hljs-number"><span class="hljs-number">143</span></span> rep stosw FLAME: cmp si, <span class="hljs-number"><span class="hljs-number">320</span></span>*<span class="hljs-number"><span class="hljs-number">200</span></span> jae NEXT_PIXEL lodsb <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al,al jz NEXT_PIXEL dec ax mov [si<span class="hljs-number"><span class="hljs-number">-2</span></span>], al mov [si], al mov [bx+si<span class="hljs-number"><span class="hljs-number">-1</span></span>], al mov [si<span class="hljs-number"><span class="hljs-number">-1</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>*<span class="hljs-number"><span class="hljs-number">320</span></span>], al NEXT_PIXEL: add si, dx inc dx jnz FLAME in al, <span class="hljs-number"><span class="hljs-number">60</span></span>h cmp al, <span class="hljs-number"><span class="hljs-number">01</span></span>h jne LINES mov ax, <span class="hljs-number"><span class="hljs-number">03</span></span>h <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>h retn dd <span class="hljs-number"><span class="hljs-number">0</span></span>h db <span class="hljs-string"><span class="hljs-string">'Mcm'</span></span> end</code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengkompilasi, Anda harus melakukan: </font></font><code>tasm pentagra.asm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>tlink /t pentagra.obj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak tahu apakah sudah jelas bagi Anda APA dan BAGAIMANA penerapannya, tetapi bagi saya tampaknya pendekatan yang indah dan tidak biasa digunakan untuk menciptakan efek nyala api. </font><font style="vertical-align: inherit;">Meskipun saya tidak dapat membandingkan, mungkin semua orang melakukannya, dan sekarang Anda dapat melakukan hal yang sama.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482826/">https://habr.com/ru/post/id482826/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482812/index.html">Matematikawan telah mencapai terobosan dalam mempelajari masalah "berbahaya"</a></li>
<li><a href="../id482814/index.html">Pandangan umum tentang pohon, implementasi dan tidak hanya</a></li>
<li><a href="../id482816/index.html">Arthur Khachuyan: Kecerdasan Buatan dalam Pemasaran</a></li>
<li><a href="../id482818/index.html">Hasil singkat dari membaca laporan tentang 1C DSS untuk Infostart 2019</a></li>
<li><a href="../id482822/index.html">Bagaimana tes seni untuk game dilakukan</a></li>
<li><a href="../id482832/index.html">Ekonomi Masa Depan untuk Fisikawan</a></li>
<li><a href="../id482838/index.html">Ulasan ONYX BOOX Note 2 - pembaca layar besar dengan kemampuan maksimal</a></li>
<li><a href="../id482840/index.html">Unduhan berurutan UTorrent dalam 2 klik</a></li>
<li><a href="../id482842/index.html">Mash adalah bahasa pemrograman yang mengkompilasi dirinya sendiri</a></li>
<li><a href="../id482844/index.html">Bot langsung, bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>