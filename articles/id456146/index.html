<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏾 🤖 🌖 DevOps dalam pengembangan: otomatisasi kode aplikasi web 🕸️ ↘️ 👩‍👩‍👧‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang, Habrazhiteli sayang! 

 Hari ini DevOps berada di gelombang kesuksesan. Di hampir semua konferensi yang didedikasikan untuk otomatisasi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DevOps dalam pengembangan: otomatisasi kode aplikasi web</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456146/">  Selamat siang, Habrazhiteli sayang! <br><br>  Hari ini DevOps berada di gelombang kesuksesan.  Di hampir semua konferensi yang didedikasikan untuk otomatisasi, Anda dapat mendengar dari pembicara mengatakan "kami menerapkan DevOps di sana-sini, menerapkan ini dan itu, menjadi lebih mudah untuk melakukan proyek, dll, dll.".  Dan itu patut dipuji.  Tetapi, sebagai aturan, implementasi DevOps di banyak perusahaan berakhir pada tahap otomatisasi Operasi TI, dan sangat sedikit orang yang berbicara tentang penerapan DevOps secara langsung dalam proses pengembangan itu sendiri. <br><br>  Saya ingin memperbaiki kesalahpahaman kecil ini.  DevOps dapat dikembangkan melalui formalisasi basis kode, misalnya saat menulis GUI untuk REST API. <br><br>  Pada artikel ini, saya ingin berbagi dengan Anda solusi untuk kasus non-standar yang ditemui perusahaan kami - kami dapat mengotomatisasi pembentukan antarmuka aplikasi web.  Saya akan memberi tahu Anda tentang bagaimana kami sampai pada tugas ini dan apa yang kami gunakan untuk menyelesaikannya.  Kami tidak percaya bahwa pendekatan kami adalah satu-satunya yang benar, tetapi kami benar-benar menyukainya. <br><br>  Saya berharap materi ini akan menarik dan bermanfaat bagi Anda. <br><br>  Baiklah, mari kita mulai! <br><a name="habracut"></a><br><h2>  Latar belakang </h2><br>  Kisah ini dimulai sekitar setahun yang lalu: itu adalah hari musim panas yang indah dan departemen pengembangan kami menciptakan aplikasi web berikutnya.  Dalam agenda adalah tugas memperkenalkan fitur baru ke dalam aplikasi - perlu untuk menambahkan kemampuan untuk membuat kait kustom. <br><br><img src="https://habrastorage.org/webt/qi/lf/ot/qilfotaamoa_fpuerti3np8chlm.png" alt="Proses penambahan fitur baru pada arsitektur lama"><br><br>  Pada saat itu, arsitektur aplikasi web kami dibangun sedemikian rupa sehingga untuk mengimplementasikan fitur baru, kami perlu melakukan hal berikut: <br><br><ol><li>  Di bagian belakang: buat model untuk entitas baru (kait), jelaskan bidang model ini, jelaskan seluruh logika tindakan yang dapat dilakukan model, dll. <br></li><li>  Di front-end'e: buat kelas presentasi yang sesuai dengan model baru di API, uraikan secara manual semua bidang yang dimiliki model ini, tambahkan semua jenis tindakan yang dapat dijalankan tampilan ini, dll. <br></li></ol><br>  Ternyata kita sekaligus di dua tempat secara bersamaan, itu perlu untuk membuat perubahan yang sangat mirip dalam kode, satu atau lain cara, "menduplikasi" satu sama lain.  Dan ini, seperti yang Anda tahu, tidak baik, karena dengan perubahan lebih lanjut, pengembang perlu membuat perubahan di tempat yang sama di dua tempat pada saat yang sama. <br><br>  Misalkan kita perlu mengubah jenis bidang "nama" dari "string" ke "textarea".  Untuk melakukan ini, kita perlu membuat amandemen ini dalam kode model di server, dan kemudian membuat perubahan yang mirip dengan kode presentasi pada klien. <br><br>  Apakah ini terlalu rumit? <br><br>  Sebelumnya, kami menerima kenyataan ini, karena banyak aplikasi tidak terlalu besar dan ada tempat untuk "menduplikasi" kode pada server dan pada klien.  Tetapi pada hari musim panas itu, sebelum pengenalan fitur baru, sesuatu diklik di dalam diri kami, dan kami menyadari bahwa kami tidak dapat bekerja lagi.  Pendekatan saat ini sangat tidak masuk akal dan membutuhkan banyak waktu dan tenaga.  Selain itu, "duplikasi" kode pada back-end dan front-end dapat menyebabkan bug yang tidak terduga di masa depan: pengembang dapat membuat perubahan pada server dan lupa untuk membuat perubahan serupa pada klien, dan kemudian semuanya tidak berjalan dengan baik sesuai rencana. <br><br><h2>  Bagaimana cara menghindari duplikasi kode?  Cari solusinya </h2><br>  Kami mulai bertanya-tanya bagaimana kami dapat mengoptimalkan proses memperkenalkan fitur-fitur baru. <br><br>  Kami bertanya pada diri sendiri pertanyaan: "Bisakah kita sekarang menghindari duplikasi perubahan dalam representasi model di front-end'e, setelah ada perubahan dalam strukturnya di back-end'e?" <br><br>  Kami berpikir dan menjawab: "Tidak, kami tidak bisa." <br><br>  Kemudian kami bertanya pada diri sendiri, "Oke, lalu apa alasan duplikasi kode seperti itu?" <br><br>  Dan kemudian kami sadar: masalahnya, pada kenyataannya, adalah front-end kami tidak menerima data pada struktur API saat ini.  Front-end tidak tahu apa-apa tentang model yang ada di API sampai kami sendiri yang mengetahuinya. <br><br>  Dan kemudian kita mendapat ide: bagaimana jika kita membangun arsitektur aplikasi sedemikian rupa sehingga: <br><br><ul><li>  Front-end yang diterima dari API tidak hanya data model, tetapi juga struktur model ini; </li><li>  Representasi front-end yang dibentuk secara dinamis berdasarkan pada struktur model; </li><li>  Setiap perubahan dalam struktur API secara otomatis ditampilkan di front-end. </li></ul><br>  Menerapkan fitur baru akan memakan waktu jauh lebih sedikit, karena hanya akan membutuhkan perubahan di sisi back-end, dan front-end akan secara otomatis mengambil semuanya dan menyajikannya kepada pengguna dengan benar. <br><br><h2>  Fleksibilitas arsitektur baru </h2><br>  Dan kemudian, kami memutuskan untuk berpikir sedikit lebih luas: apakah arsitektur baru hanya cocok untuk aplikasi kita saat ini, atau bisakah kita menggunakannya di tempat lain? <br><br><img src="https://habrastorage.org/webt/og/ay/ju/ogayjuenpbmvwxxlrxpm09banza.png" alt="Fitur umum untuk banyak aplikasi web"><br><br>  Memang, dengan satu atau lain cara, hampir semua aplikasi memiliki bagian dari fungsi serupa: <br><br><ul><li>  hampir semua aplikasi memiliki pengguna, dan dalam hal ini, perlu memiliki fungsi yang terkait dengan pendaftaran dan otorisasi pengguna; </li><li>  hampir semua aplikasi memiliki beberapa jenis representasi: ada tampilan untuk melihat daftar objek model, ada tampilan untuk melihat catatan terperinci dari objek model tunggal, individual, model; </li><li>  hampir semua model memiliki atribut yang serupa dalam jenis: data string, angka, dll., dan dalam hal ini, Anda harus dapat bekerja dengan mereka baik di back-end dan di front-end. </li></ul><br>  Dan karena perusahaan kami sering melakukan pengembangan aplikasi web khusus, kami berpikir: mengapa kita perlu menemukan kembali roda setiap waktu dan mengembangkan fungsionalitas yang serupa setiap kali dari awal, jika Anda dapat menulis kerangka kerja yang akan menggambarkan semua dasar, umum bagi banyak aplikasi, hal-hal, dan kemudian, membuat proyek baru, menggunakan pengembangan yang sudah jadi sebagai dependensi, dan jika perlu, secara deklaratif mengubahnya dalam proyek baru. <br><br>  Jadi, dalam diskusi panjang, kami memiliki ide untuk membuat VSTUtils - sebuah kerangka kerja yang akan: <br><br><ol><li>  Ini berisi fungsionalitas dasar, paling mirip dengan sebagian besar aplikasi; </li><li>  Diizinkan untuk membuat front-end on the fly, berdasarkan pada struktur API. </li></ol><br><h2>  Bagaimana cara mendapatkan teman back-end dan front-end? </h2><br>  Kalau begitu, harus kita lakukan, pikir kami.  Kami sudah memiliki beberapa back-end, beberapa front-end juga, tetapi server maupun klien tidak memiliki alat yang dapat melaporkan atau menerima data pada struktur API. <br><br>  Dalam mencari solusi untuk masalah ini, mata kami tertuju pada spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenAPI</a> , yang, berdasarkan deskripsi model dan hubungan di antara mereka, menghasilkan JSON besar yang berisi semua informasi ini. <br><br>  Dan kami berpikir bahwa, secara teori, ketika menginisialisasi aplikasi pada klien, front-end dapat menerima JSON ini dari API dan membangun semua pandangan yang diperlukan atas dasar.  Tinggal mengajarkan front-end kita untuk melakukan semua ini. <br><br>  Dan setelah beberapa waktu kami mengajarinya. <br><br><h2>  Versi 1.0 - apa yang keluar darinya </h2><br>  Arsitektur kerangka VSTUtils dari versi pertama terdiri dari 3 bagian bersyarat dan terlihat seperti ini: <br><br><ol><li>  <b>Ujung belakang:</b> <br><ul><li>  <u>Django dan Python</u> adalah semua model yang berhubungan dengan logika.  Berdasarkan pada basis Model Django, kami telah menciptakan beberapa kelas model inti VSTUtils.  Semua tindakan yang dapat dilakukan model ini kami terapkan menggunakan Python; <br></li><li>  <u>Django REST Framework</u> - REST API generation.  Berdasarkan uraian model, REST API dibentuk, berkat komunikasi dengan server dan klien; <br></li></ul></li><li>  <b>Interaksi antara back-end dan front-end:</b> <br><ul><li>  <u>OpenAPI</u> - Generasi JSON dengan deskripsi struktur API.  Setelah semua model dijelaskan di bagian belakang, tampilan dibuat untuknya.  Menambahkan masing-masing tampilan memperkenalkan informasi yang diperlukan ke dalam JSON yang dihasilkan: <br><div class="spoiler">  <b class="spoiler_title">Contoh JSON - Skema OpenAPI</b> <div class="spoiler_text"><pre><code class="json hljs">{ // ,     (, ), //   -  , //  -     . definitions: { //    Hook. Hook: { // ,     (, ), //   -   , //  -       (,    ..). properties: { id: { title: <span class="hljs-string"><span class="hljs-string">"Id"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"integer"</span></span>, readOnly: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, name: { title: <span class="hljs-string"><span class="hljs-string">"Name"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, minLength:<span class="hljs-number"><span class="hljs-number">1</span></span>, maxLength: <span class="hljs-number"><span class="hljs-number">512</span></span>, }, type: { title: <span class="hljs-string"><span class="hljs-string">"Type"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, enum: [<span class="hljs-string"><span class="hljs-string">"HTTP"</span></span>,<span class="hljs-string"><span class="hljs-string">"SCRIPT"</span></span>], }, when: { title: <span class="hljs-string"><span class="hljs-string">"When"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, enum: [<span class="hljs-string"><span class="hljs-string">"on_object_add"</span></span>,<span class="hljs-string"><span class="hljs-string">"on_object_upd"</span></span>,<span class="hljs-string"><span class="hljs-string">"on_object_del"</span></span>], }, enable: { title:<span class="hljs-string"><span class="hljs-string">"Enable"</span></span>, type:<span class="hljs-string"><span class="hljs-string">"boolean"</span></span>, }, recipients: { title: <span class="hljs-string"><span class="hljs-string">"Recipients"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, minLength: <span class="hljs-number"><span class="hljs-number">1</span></span>, } }, // ,     ,    . required: [<span class="hljs-string"><span class="hljs-string">"type"</span></span>,<span class="hljs-string"><span class="hljs-string">"recipients"</span></span>], } }, // ,     (, ), //   -   ( URL), //  -     . paths: { //      '/hook/'. '/hook/': { //    get    /hook/. //  ,       Hook. get: { operationId: <span class="hljs-string"><span class="hljs-string">"hook_list"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Return all hooks."</span></span>, // ,       ,     . parameters: [ { name: <span class="hljs-string"><span class="hljs-string">"id"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"query"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"A unique integer value (or comma separated list) identifying this instance."</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, }, { name: <span class="hljs-string"><span class="hljs-string">"name"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"query"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"A name string value (or comma separated list) of instance."</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, }, { name: <span class="hljs-string"><span class="hljs-string">"type"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"query"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Instance type."</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, }, ], // ,     (, ), //   -   ; //  -   . responses: { 200: { description: <span class="hljs-string"><span class="hljs-string">"Action accepted."</span></span>, schema: { properties: { results: { type: <span class="hljs-string"><span class="hljs-string">"array"</span></span>, items: { //   ,       . $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Hook"</span></span>, }, }, }, }, }, 400: { description: <span class="hljs-string"><span class="hljs-string">"Validation error or some data error."</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Error"</span></span>, }, }, 401: { // ... }, 403: { // ... }, 404: { // ... }, }, tags: [<span class="hljs-string"><span class="hljs-string">"hook"</span></span>], }, //    post    /hook/. //  ,       Hook. post: { operationId: <span class="hljs-string"><span class="hljs-string">"hook_add"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Create a new hook."</span></span>, parameters: [ { name: <span class="hljs-string"><span class="hljs-string">"data"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"body"</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Hook"</span></span>, }, }, ], responses: { 201: { description: <span class="hljs-string"><span class="hljs-string">"Action accepted."</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Hook"</span></span>, }, }, 400: { description: <span class="hljs-string"><span class="hljs-string">"Validation error or some data error."</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Error"</span></span>, }, }, 401: { // ... }, 403: { // ... }, 404: { // ... }, }, tags: [<span class="hljs-string"><span class="hljs-string">"hook"</span></span>], }, } } }</code> </pre> </div></div></li></ul></li><li>  <b>Front-end:</b> <br><ul><li>  <u>JavaScript</u> adalah mekanisme yang mem-parsing skema OpenAPI dan menghasilkan tampilan.  Mekanisme ini diluncurkan sekali, ketika aplikasi diinisialisasi pada klien.  Dengan mengirimkan permintaan ke API, ia menerima JSON yang diminta sebagai tanggapan dengan deskripsi struktur API dan, menganalisisnya, menciptakan semua objek JS yang diperlukan yang berisi parameter dari representasi model.  Permintaan API ini cukup berat, jadi kami menyimpannya dan memintanya lagi hanya saat memperbarui versi aplikasi; </li><li>  <u>JavaScript SPA libs</u> - menyajikan tampilan dan perutean di antaranya.  Perpustakaan ini ditulis oleh salah satu pengembang front-end kami.  Ketika pengguna mengakses halaman tertentu, mesin rendering menggambar halaman berdasarkan parameter yang disimpan dalam objek representasi JS. </li></ul></li></ol><br>  Jadi, apa yang kita miliki: kita memiliki back-end yang menggambarkan semua logika yang terkait dengan model.  Kemudian OpenAPI memasuki permainan, yang, berdasarkan deskripsi model, menghasilkan JSON dengan deskripsi struktur API.  Selanjutnya, tongkat ditransmisikan ke klien, yang, menganalisis OpenAPI JSON yang dihasilkan secara otomatis menghasilkan antarmuka web. <br><br><h2>  Menanamkan fitur dalam aplikasi pada arsitektur baru - cara kerjanya </h2><br>  Ingat tugas menambahkan kait kustom?  Inilah cara kami mengimplementasikannya dalam aplikasi berbasis VSTUtils: <br><br><img src="https://habrastorage.org/webt/ud/yr/af/udyrafi5o5grqlzqovkat8ursko.png" alt="Proses penambahan fitur baru ke arsitektur baru"><br><br>  Sekarang berkat VSTUtils kita tidak perlu menulis apa pun dari awal.  Inilah yang kami lakukan untuk menambah kemampuan membuat kait kustom: <br><br><ol><li>  Di back-end: kami mengambil dan mewarisi dari kelas yang paling cocok di VSTUtils, menambahkan fungsionalitas baru khusus untuk model baru; </li><li>  Di ujung depan: <br><ul><li>  jika tampilan untuk model ini tidak berbeda dari tampilan dasar VSTUtils, maka kami tidak melakukan apa pun, semuanya ditampilkan secara otomatis dengan benar; </li><li>  jika Anda perlu mengubah perilaku tampilan, menggunakan mekanisme sinyal, kami memperluas atau mendeklarasikan perilaku dasar tampilan secara total. <br></li></ul></li></ol><br>  Sebagai hasilnya, kami mendapat solusi yang cukup bagus, kami mencapai tujuan kami, front-end kami menjadi otomatis.  Proses memperkenalkan fitur-fitur baru ke dalam proyek-proyek yang ada telah terasa dipercepat: rilis mulai dirilis setiap 2 minggu, sedangkan sebelumnya kami merilis rilis setiap 2-3 bulan dengan jumlah fitur baru yang jauh lebih kecil.  Saya ingin mencatat bahwa tim pengembangan tetap sama, itu adalah arsitektur aplikasi baru yang memberi kita buah. <br><br><h2>  Versi 1.0 - hati kita menuntut perubahan </h2><br>  Tapi, seperti yang Anda tahu, tidak ada batasan untuk kesempurnaan, dan VSTUtils tidak terkecuali. <br><br>  Terlepas dari kenyataan bahwa kami dapat mengotomatisasi pembentukan front-end, hasilnya bukan solusi langsung yang kami inginkan. <br><br>  Arsitektur aplikasi sisi klien tidak dipikirkan secara menyeluruh, dan ternyata tidak sefleksibel mungkin: <br><br><ul><li>  proses memperkenalkan kelebihan fungsional tidak selalu nyaman; </li><li>  Mekanisme parsing OpenAPI tidak optimal; </li><li>  rendering representasi dan perutean di antara mereka dilakukan menggunakan perpustakaan yang ditulis sendiri, yang juga tidak cocok untuk kami karena sejumlah alasan: <br><ul><li>  Perpustakaan-perpustakaan ini tidak dicakup oleh tes; </li><li>  tidak ada dokumentasi untuk perpustakaan ini; </li><li>  mereka tidak memiliki komunitas apa pun - dalam hal mendeteksi bug di dalamnya atau kepergian karyawan yang menulisnya, dukungan untuk kode tersebut akan sangat sulit. </li></ul></li></ul><br>  Dan karena di perusahaan kami, kami mematuhi pendekatan DevOps dan mencoba untuk menstandarisasi dan memformalkan kode kami sebanyak mungkin, pada bulan Februari tahun ini kami memutuskan untuk melakukan refactoring global kerangka kerja ujung-depan VSTUtils.  Kami memiliki beberapa tugas: <br><br><ul><li>  untuk membentuk tidak hanya kelas presentasi di front-end, tetapi juga kelas model - kami menyadari bahwa akan lebih tepat untuk memisahkan data (dan strukturnya) dari presentasi mereka.  Selain itu, kehadiran beberapa abstraksi dalam bentuk representasi dan model akan sangat memudahkan penambahan kelebihan fungsionalitas dasar dalam proyek berdasarkan VSTUtils; </li><li>  menggunakan kerangka kerja teruji dengan komunitas besar (Angular, React, Vue) untuk rendering dan routing - ini akan memungkinkan kita untuk memberikan semua sakit kepala dengan dukungan untuk kode yang terkait dengan rendering dan routing di dalam aplikasi kita. </li></ul><br><h2>  Refactoring - pilihan kerangka kerja JS </h2><br>  Di antara kerangka kerja JS paling populer: Angular, React, Vue, pilihan kami jatuh pada Vue karena: <br><br><ul><li>  Basis kode Vue kurang dari React and Angular; <br><br>  <i>Bagan Perbandingan Ukuran Kerangka Kerja Gzipped</i> <br><div class="scrollable-table"><table><tbody><tr><th>  Kerangka kerja </th><th>  Ukuran, kb </th></tr><tr><td>  Sudut 2 </td><td>  111 </td></tr><tr><td>  Sudut 2 + RX </td><td>  143 </td></tr><tr><td>  Sudut 1.4.5 </td><td>  51 </td></tr><tr><td>  Bereaksi 0.14.5 + Bereaksi DOM </td><td>  40 </td></tr><tr><td>  Bereaksi 0.14.5 + Bereaksi DOM + Redux </td><td>  42 </td></tr><tr><td>  Bereaksi 15.3.0 + Bereaksi DOM </td><td>  43 </td></tr><tr><td>  Vue 2.4.2 </td><td>  21 </td></tr></tbody></table></div></li><li>  Proses rendering halaman Vue membutuhkan waktu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih sedikit</a> daripada React and Angular; <br><img src="https://habrastorage.org/webt/lo/eu/6m/loeu6mow9u1qbcz3nbanmldjmwu.png" alt="membandingkan kecepatan rendering halaman dengan kerangka kerja javascript yang berbeda relatif terhadap javascript murni"></li><li>  Ambang entri di Vue jauh lebih rendah daripada di Bereaksi dan Angular; </li><li>  Sintaks templat yang dapat dimengerti secara native; </li><li>  Dokumentasi yang elegan dan terperinci tersedia dalam beberapa bahasa, termasuk Rusia; </li><li>  Ekosistem yang dikembangkan yang menyediakan, di samping perpustakaan inti Vue, perpustakaan untuk perutean dan untuk membuat gudang data reaktif. </li></ul><br><h2>  Versi 2.0 - hasil refactoring front-end </h2><br>  Proses refactoring global front-end VSTUtils membutuhkan waktu sekitar 4 bulan dan inilah yang akhirnya kami lakukan dengan: <br><br><img src="https://habrastorage.org/webt/6a/wr/9k/6awr9kuruhmeq9gey-isefn_21u.png" alt="arsitektur VSTUtils fron-end baru"><br><br>  Kerangka front-end VSTUtils masih terdiri dari dua blok besar: yang pertama terlibat dalam penguraian skema OpenAPI, yang kedua adalah memberikan pandangan dan routing di antara mereka, tetapi kedua blok ini telah mengalami sejumlah perubahan signifikan. <br><br>  Mekanisme yang mem-parsing skema OpenAPI telah sepenuhnya ditulis ulang.  Pendekatan untuk menguraikan skema ini telah berubah.  Kami mencoba membuat arsitektur front-end semirip mungkin dengan arsitektur back-end.  Sekarang di sisi klien kami tidak hanya memiliki satu abstraksi dalam bentuk representasi, sekarang kami juga memiliki abstraksi dalam bentuk model dan QuerySets: <br><br><ul><li>  objek kelas Model dan turunannya adalah objek yang sesuai dengan abstraksi sisi-server dari Model Django.  Objek jenis ini berisi data tentang struktur model (nama model, bidang model, dll.); </li><li>  objek kelas QuerySet dan turunannya adalah objek yang sesuai dengan abstraksi Django QuerySets sisi-server.  Objek jenis ini berisi metode yang memungkinkan Anda untuk melakukan permintaan API (menambah, memodifikasi, menerima, menghapus data objek model); </li><li>  objek kelas Tampilan - objek yang menyimpan informasi tentang cara merepresentasikan model pada halaman tertentu, template mana yang akan digunakan untuk “me-render” halaman, yang mana representasi lain dari model-model halaman ini dapat ditautkan, dll. </li></ul><br>  Unit yang bertanggung jawab untuk rendering dan routing juga telah berubah secara signifikan.  Kami meninggalkan perpustakaan JS SPA yang ditulis sendiri demi Vue.js.  Kami telah mengembangkan komponen Vue kami sendiri yang membentuk semua halaman aplikasi web kami.  Perutean antar tampilan dilakukan menggunakan pustaka vue-router, dan kami menggunakan vuex sebagai penyimpanan reaktif status aplikasi. <br><br>  Saya juga ingin mencatat bahwa di sisi front-end implementasi kelas Model, QuerySet dan View tidak tergantung pada cara rendering dan routing, yaitu, jika kita tiba-tiba ingin beralih dari Vue ke beberapa framework lain, misalnya, Bereaksi atau sesuatu yang baru, maka yang perlu kita lakukan adalah menulis ulang komponen Vue ke komponen kerangka baru, menulis ulang router, repositori, dan itu saja - kerangka kerja VSTUtils akan bekerja lagi.  Implementasi kelas Model, QuerySet, dan View akan tetap sama, karena tidak bergantung pada Vue.js.  Kami percaya bahwa ini adalah bantuan yang sangat baik untuk kemungkinan perubahan di masa depan. <br><br><h2>  Untuk meringkas </h2><br>  Dengan demikian, keengganan untuk menulis kode "duplikat" mengakibatkan tugas mengotomatisasi pembentukan front-end aplikasi web, yang diselesaikan dengan membuat kerangka kerja VSTUtils.  Kami berhasil membangun arsitektur aplikasi web sehingga back-end dan front-end secara harmonis saling melengkapi dan setiap perubahan dalam struktur API secara otomatis diambil dan ditampilkan dengan benar pada klien. <br><br>  Manfaat yang kami terima dari memformalkan arsitektur aplikasi web: <br><br><ul><li>  Rilis aplikasi yang berjalan atas dasar VSTUtils mulai keluar 2 kali lebih sering.  Ini disebabkan oleh kenyataan bahwa sekarang untuk memperkenalkan fitur baru, seringkali, kita perlu menambahkan kode hanya di back-end, front-end akan secara otomatis dihasilkan - ini menghemat waktu; </li><li>  Pembaruan fungsi dasar yang disederhanakan.  Karena sekarang semua fungsionalitas dasar dirangkai dalam satu kerangka kerja, untuk memperbarui beberapa dependensi penting atau melakukan perbaikan pada fungsionalitas dasar, kita perlu melakukan koreksi hanya di satu tempat - dalam basis kode VSTUtils.  Saat memperbarui versi VSTUtils dalam proyek anak, semua inovasi akan secara otomatis diambil; </li><li>  Menemukan karyawan baru menjadi lebih mudah.  Setuju, jauh lebih mudah untuk menemukan pengembang untuk tumpukan teknologi yang diformalkan (Django, Vue) daripada mencari orang yang setuju untuk bekerja dengan perekam yang tidak dikenal.  Hasil pencarian untuk pengembang yang menyebutkan Django atau Vue di HeadHunter di CV mereka (di semua wilayah): <br><ul><li>  Django - 3.454 resume ditemukan untuk 3.136 pelamar; </li><li>  Vue - 4.092 resume ditemukan untuk 3.747 pencari kerja. </li></ul></li></ul><br>  Kerugian dari formalisasi arsitektur aplikasi web tersebut adalah sebagai berikut: <br><br><ul><li>  Karena penguraian skema OpenAPI, inisialisasi aplikasi pada klien membutuhkan waktu sedikit lebih lama dari sebelumnya (sekitar 20-30 milidetik lebih lama); </li><li>  Pengindeksan pencarian tidak penting.  Faktanya adalah bahwa saat ini kami tidak menggunakan rendering server dalam kerangka VSTUtils, dan semua konten aplikasi dibentuk dalam bentuk akhir yang sudah ada di klien.  Tetapi untuk proyek kami, seringkali hasil pencarian yang tinggi tidak diperlukan dan bagi kami itu tidak terlalu kritis. </li></ul><br>  Tentang ini, kisah saya berakhir, terima kasih atas perhatian Anda! <br><br><h2>  Tautan yang bermanfaat </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi OpenAPI</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori VSTUtils</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh proyek yang dibuat berdasarkan VSTUtils</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456146/">https://habr.com/ru/post/id456146/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456132/index.html">Tentang merekam bug, atau Cari Kucing</a></li>
<li><a href="../id456134/index.html">Percaya tapi verifikasi! Cara menguji model Anda menggunakan cloud IBM (Watson OpenScale)</a></li>
<li><a href="../id456136/index.html">Mengapa kami melakukan Enterprise Service Mesh</a></li>
<li><a href="../id456140/index.html">Temui Codeception 3.0</a></li>
<li><a href="../id456144/index.html">KubeCon EU 2019: 10 temuan kunci</a></li>
<li><a href="../id456148/index.html">Berita minggu ini: Facebook menolak Huawei dalam aplikasi, Aurora OS, bukan Android, menambang hukuman</a></li>
<li><a href="../id456150/index.html">Petty little joy # 4: Radon - kualitas kode diukur dalam angka</a></li>
<li><a href="../id456152/index.html">Pola Desain Level untuk Game 2D</a></li>
<li><a href="../id456154/index.html">Fitur Core UX & MVP saat membuat produk</a></li>
<li><a href="../id456156/index.html">Karena itulah diperlukan aljabar sekolah.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>