<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ë üò™ üßíüèΩ Gu√≠a de JavaScript Parte 9: Descripci√≥n general de los est√°ndares ES7, ES8 y ES9 ‚úãüèº üê• üëçüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy, en la novena parte de la traducci√≥n del manual de JavaScript, se ofrecer√° una descripci√≥n general de las caracter√≠sticas que han aparecido en el ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gu√≠a de JavaScript Parte 9: Descripci√≥n general de los est√°ndares ES7, ES8 y ES9</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431872/">  Hoy, en la novena parte de la traducci√≥n del manual de JavaScript, se ofrecer√° una descripci√≥n general de las caracter√≠sticas que han aparecido en el idioma gracias a los est√°ndares ES7, ES8 y ES9. <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1: primer programa, caracter√≠sticas del lenguaje, est√°ndares</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2: estilo de c√≥digo y estructura del programa</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3: variables, tipos de datos, expresiones, objetos.</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4: caracter√≠sticas</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5: matrices y bucles</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 6: excepciones, punto y coma, literales comod√≠n</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 7: modo estricto, esta palabra clave, eventos, m√≥dulos, c√°lculos matem√°ticos</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 8: Descripci√≥n general de las caracter√≠sticas de ES6</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 9: Descripci√≥n general de los est√°ndares ES7, ES8 y ES9</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Est√°ndar ES7</font> </h2><br>  El est√°ndar ES7, que, de acuerdo con la terminolog√≠a oficial, se llama ES2016, se lanz√≥ en el verano de 2016.  √âl, en comparaci√≥n con ES6, tra√≠do al lenguaje no es mucho nuevo.  En particular, estamos hablando de lo siguiente: <br><br><ul><li> <code>Array.prototype.includes()</code> m√©todo. </li><li>  Operador de exponenciaci√≥n. </li></ul><br><h3>  <font color="#3AC1EF">‚ñç M√©todo Array.prototype.includes ()</font> </h3><br>  El m√©todo <code>Array.prototype.includes()</code> est√° dise√±ado para verificar la presencia de un elemento en la matriz.  Al encontrar lo deseado en la matriz, devuelve <code>true</code> , no encontrar, <code>false</code> .  Antes de ES7, el m√©todo <code>indexOf()</code> se usaba para realizar la misma operaci√≥n, que devuelve, si se encuentra un elemento, el primer √≠ndice por el cual se puede encontrar en la matriz.  Si <code>indexOf()</code> no encuentra el elemento, devuelve el n√∫mero <code>-1</code> . <br><br>  De acuerdo con las reglas de conversi√≥n de tipo JavaScript, el n√∫mero <code>-1</code> convierte en <code>true</code> .  Como resultado, para verificar los resultados de la operaci√≥n de <code>indexOf()</code> se debe usar una construcci√≥n no particularmente conveniente del siguiente formulario. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">3</span></span>) === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Not found'</span></span>) }</code> </pre> <br>  Si en una situaci√≥n similar, suponiendo que <code>indexOf()</code> , sin encontrar un elemento, devuelve <code>false</code> , use algo como el que se muestra a continuaci√≥n, el c√≥digo no funcionar√° correctamente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">3</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// console.log('Not found') }</span></span></code> </pre> <br>  En este caso, resulta que la construcci√≥n <code>![1,2].indexOf(3)</code> da <code>false</code> . <br><br>  Usando el m√©todo <code>includes()</code> , tales comparaciones parecen mucho m√°s l√≥gicas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].includes(<span class="hljs-number"><span class="hljs-number">3</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Not found'</span></span>) }</code> </pre> <br>  En este caso, la construcci√≥n <code>[1,2].includes(3)</code> devuelve <code>false</code> , ¬°este valor es un operador <code>!</code>  se convierte en <code>true</code> y la consola recibe un mensaje que indica que no se encontr√≥ el elemento en la matriz. <br><br><h3>  <font color="#3AC1EF">‚ñç operador de exponenciaci√≥n</font> </h3><br>  El operador de exponenciaci√≥n realiza la misma funci√≥n que el m√©todo <code>Math.pow()</code> , pero es m√°s conveniente usarlo que una funci√≥n de biblioteca, ya que es parte del lenguaje. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span> ** <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br>  Este operador puede considerarse una adici√≥n agradable a JS, que es √∫til en aplicaciones que realizan ciertos c√°lculos.  Existe un operador similar en otros lenguajes de programaci√≥n. <br><br><h2>  <font color="#3AC1EF">Est√°ndar ES8</font> </h2><br>  El est√°ndar ES8 (ES2017) se lanz√≥ en 2017.  √âl, como ES7, no aport√≥ mucho al idioma.  A saber, estamos hablando de las siguientes caracter√≠sticas: <br><br><ul><li>  Agregar cadenas a una longitud determinada. </li><li>  M√©todo <code>Object.values()</code> . </li><li>  M√©todo <code>Object.entries()</code> . </li><li>  M√©todo <code>Object.getOwnPropertyDescriptors()</code> . </li><li>  Comas finales en los par√°metros de la funci√≥n. </li><li>  Funciones asincr√≥nicas. </li><li>  Trabajar con memoria compartida y operaciones at√≥micas. </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Agregar l√≠neas a una longitud dada</font> </h3><br>  ES8 introdujo dos nuevos m√©todos de objeto <code>String</code> : <code>padStart()</code> y <code>padEnd()</code> . <br><br>  El m√©todo <code>padStart()</code> llena la l√≠nea actual con otra l√≠nea hasta que la l√≠nea final alcanza la longitud deseada.  El llenado ocurre al comienzo de la l√≠nea (izquierda).  Aqu√≠ se explica c√≥mo usar este m√©todo. <br><br><pre> <code class="javascript hljs">str.padStart(targetLength [, padString])</code> </pre> <br>  Aqu√≠ <code>str</code> es la l√≠nea actual, <code>targetLength</code> es la longitud de la l√≠nea final (si es menor que la longitud de la l√≠nea actual, esta l√≠nea se devolver√° sin cambios), <code>padString</code> es un par√°metro opcional: la l√≠nea utilizada para llenar la l√≠nea actual.  Si no se especifica <code>padString</code> , se utiliza un car√°cter de espacio para <code>padString</code> l√≠nea actual a la longitud especificada. <br><br>  El m√©todo <code>padEnd()</code> es similar a <code>padStart()</code> , pero la l√≠nea se rellena a la derecha. <br><br>  Considere ejemplos de uso de estos m√©todos. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">'test'</span></span>.padStart(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str1 = <span class="hljs-string"><span class="hljs-string">'test'</span></span>.padEnd(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-string"><span class="hljs-string">'*'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">'`</span></span>) <span class="hljs-comment"><span class="hljs-comment">//'      test' console.log(`'${str1}'`) //'test******'</span></span></code> </pre> <br>  Aqu√≠, cuando se usa <code>padStart()</code> con solo la longitud deseada de la cadena resultante, se agregaron espacios al comienzo de la cadena original.  Al usar <code>padEnd()</code> con la longitud de la l√≠nea final y la l√≠nea para llenarla, los caracteres <code>*</code> se agregaron al final de la l√≠nea original. <br><br><h3>  <font color="#3AC1EF">‚ñç M√©todo Object.values ‚Äã‚Äã()</font> </h3><br>  Este m√©todo devuelve una matriz que contiene los valores de las propiedades propias del objeto, es decir, las propiedades que contiene el objeto en s√≠ y no las que son accesibles a trav√©s de la cadena de prototipos. <br><br>  Aqu√≠ se explica c√≥mo usarlo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personValues = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(personValues) <span class="hljs-comment"><span class="hljs-comment">// ['Fred', 87]</span></span></code> </pre> <br>  Este m√©todo tambi√©n se aplica a las matrices. <br><br><h3>  <font color="#3AC1EF">‚ñç M√©todo Object.entries ()</font> </h3><br>  Este m√©todo devuelve una matriz, cada elemento del cual tambi√©n es una matriz que contiene, en el formato <code>[key, value]</code> , claves y valores de las propiedades del objeto. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personValues = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(personValues) <span class="hljs-comment"><span class="hljs-comment">// [['name', 'Fred'], ['age', 87]]</span></span></code> </pre> <br>  Al aplicar este m√©todo a las matrices, los √≠ndices de los elementos se muestran como claves, y lo que se almacena en la matriz en los √≠ndices correspondientes se muestra como valores. <br><br><h3>  <font color="#3AC1EF">‚ñç m√©todo getOwnPropertyDescriptors ()</font> </h3><br>  Este m√©todo devuelve informaci√≥n sobre todas las propiedades del objeto.  Los conjuntos de atributos (descriptores) est√°n asociados con las propiedades del objeto.  En particular, estamos hablando de los siguientes atributos: <br><br><ul><li>  <code>value</code> : el valor de la propiedad del objeto. </li><li>  <code>writable</code> : contiene <code>true</code> si la propiedad se puede cambiar. </li><li>  <code>get</code> : contiene una funci√≥n getter asociada con la propiedad o, si no existe, <code>undefined</code> . </li><li>  <code>set</code> : contiene la funci√≥n setter de la propiedad o <code>undefined</code> . </li><li>  <code>configurable</code> , si es <code>false</code> , la propiedad no se puede eliminar, sus atributos no se pueden cambiar, excepto el valor. </li><li>  <code>enumerable</code> : si verdadero est√° contenido en esta propiedad, la <code></code> es enumerable. </li></ul><br>  Aqu√≠ se explica c√≥mo usar este m√©todo. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(obj)</code> </pre> <br>  Toma un objeto cuya informaci√≥n de propiedad necesita averiguar y devuelve un objeto que contiene esta informaci√≥n. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> propDescr = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(propDescr) <span class="hljs-comment"><span class="hljs-comment">/* { name:  { value: 'Fred',    writable: true,    enumerable: true,    configurable: true }, age:  { value: 87,    writable: true,    enumerable: true,    configurable: true } } */</span></span></code> </pre> <br>  ¬øPor qu√© se necesita este m√©todo?  El hecho es que le permite crear peque√±as copias de objetos, copiando, adem√°s de otras propiedades, captadores y establecedores.  Esto no se pudo hacer usando el m√©todo <code>Object.assign()</code> , que apareci√≥ en el est√°ndar ES6, para copiar objetos. <br><br>  El siguiente ejemplo tiene un objeto con un setter que muestra, usando <code>console.log()</code> , lo que est√°n tratando de escribir en su propiedad correspondiente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person1 = { set name(newName) {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(newName) } } person1.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">// x</span></span></code> </pre> <br>  Intentemos copiar este objeto usando el m√©todo <code>assign()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person2 = {} <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(person2, person1) person2.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">//     ,   </span></span></code> </pre> <br>  Como puede ver, este enfoque no funciona.  La propiedad de <code>name</code> , que fue la que establece el objeto original, ahora se representa como una propiedad normal. <br><br>  Ahora <code>Object.defineProperties()</code> el objeto utilizando los m√©todos <code>Object.defineProperties()</code> (apareci√≥ en ES5.1) y <code>Object.getOwnPropertyDescriptors()</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person3 = {} <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperties(person3, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(person1)) person3.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">//x</span></span></code> </pre> <br>  Aqu√≠, el colocador permanece en la copia del objeto. <br><br>  Cabe se√±alar que las restricciones espec√≠ficas de <code>Object.assign()</code> tambi√©n son caracter√≠sticas del m√©todo <code>Object.create()</code> cuando se utiliza para clonar objetos. <br><br><h3>  <font color="#3AC1EF">‚ñçComas de terminaci√≥n en par√°metros de funci√≥n</font> </h3><br>  Esta caracter√≠stica le permite dejar una coma al final de la lista de par√°metros o argumentos, respectivamente, al declarar y al llamar a funciones. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> var1, var2, </span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... } doSomething( 'test1', 'test2', )</span></span></code> </pre> <br>  Esto mejora la usabilidad de los sistemas de control de versiones.  Es decir, estamos hablando del hecho de que al agregar nuevos par√°metros a una funci√≥n, no tiene que cambiar el c√≥digo existente solo por insertar una coma. <br><br><h3>  <font color="#3AC1EF">‚ñçFunciones asincr√≥nicas</font> </h3><br>  La construcci√≥n <code>async/await</code> ha aparecido en el est√°ndar ES2017, que puede considerarse la innovaci√≥n m√°s importante de esta versi√≥n del lenguaje. <br><br>  Las funciones asincr√≥nicas son una combinaci√≥n de promesas y generadores; simplifican las construcciones que anteriormente requer√≠an una gran cantidad de c√≥digo de plantilla y cadenas de promesas inconvenientes para describir.  De hecho, estamos hablando de una abstracci√≥n de alto nivel sobre las promesas. <br><br>  Cuando aparecieron las promesas en el est√°ndar ES2015, fueron dise√±adas para resolver problemas existentes con c√≥digo asincr√≥nico, lo que hicieron.  Pero durante los dos a√±os que compartieron los est√°ndares ES2015 y ES2017, qued√≥ claro que las promesas no pueden considerarse la soluci√≥n final a estos problemas. <br><br>  En particular, las promesas estaban destinadas a resolver el problema del "infierno de devoluci√≥n de llamada", pero, al resolver este problema, ellos mismos no mostraron su mejor lado debido a la complejidad del c√≥digo en el que se utilizan.  De hecho, la construcci√≥n <code>async/await</code> resuelve el problema de las promesas y mejora la usabilidad del c√≥digo as√≠ncrono. <br><br>  Considera un ejemplo. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {     setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>) }) } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br>  Este c√≥digo enviar√° lo siguiente a la consola. <br><br><pre> <code class="javascript hljs">Before After I did something</code> </pre> <br>  Como puede ver, despu√©s de llamar a <code>doSomething()</code> programa contin√∫a ejecut√°ndose, despu√©s de que se muestre <code>Before</code> , <code>After</code> en la consola, y despu√©s de que hayan pasado tres segundos, <code>I did something</code> . <br><br><h4>  Llamada de funci√≥n as√≠ncrona en serie </h4><br>  Si es necesario, las funciones asincr√≥nicas pueden formar algo as√≠ como cadenas de llamadas.  Dichos dise√±os se distinguen por una mejor legibilidad que algo similar, basado √∫nicamente en promesas.  Esto se puede ver en el siguiente ejemplo. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">promiseToDoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)=&gt;</span></span>{     setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>) }) } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchOverSomeoneDoingSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchOverSomeoneWatchingSomeoneDoingSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) <span class="hljs-comment"><span class="hljs-comment">// I did something and I watched and I watched as well })</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Memoria compartida y operaciones at√≥micas</font> </h3><br>  Aqu√≠ estamos hablando del objeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SharedArrayBuffer</a> , que le permite describir √°reas de memoria compartida, y el objeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Atomics</a> , que contiene un conjunto de operaciones at√≥micas en forma de m√©todos est√°ticos.  Los detalles sobre las posibilidades que estos objetos le dan al programador se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h2>  <font color="#3AC1EF">Est√°ndar ES9</font> </h2><br>  ES9 (ES2018) es la √∫ltima versi√≥n del est√°ndar en el momento de la publicaci√≥n de este material.  Estas son sus principales caracter√≠sticas: <br><br><ul><li>  Aplicar declaraciones de propagaci√≥n y descanso a los objetos. </li><li>  Iteradores asincr√≥nicos. </li><li>  M√©todo <code>Promise.prototype.finally()</code> . </li><li>  Mejoras en la expresi√≥n regular. </li></ul><br><h3>  <font color="#3AC1EF">‚ñç Aplicaci√≥n de operadores de dispersi√≥n y descanso a objetos</font> </h3><br>  Ya hemos hablado sobre el resto y los operadores de propagaci√≥n que aparecieron en ES6 y se pueden usar para trabajar con matrices.  Ambos parecen tres puntos.  El operador rest, en el siguiente ejemplo de desestructuraci√≥n de una matriz, le permite poner sus elementos primero y segundo en las constantes <code>first</code> y <code>second</code> , y todo el resto en los <code>others</code> constantes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, ...others] = numbers <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first) <span class="hljs-comment"><span class="hljs-comment">//1 console.log(second) //2 console.log(others) //[ 3, 4, 5 ]</span></span></code> </pre> <br>  El operador de <code>spread</code> permite pasar matrices a funciones que esperan listas de par√°metros regulares. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c, d, e</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b + c + d + e <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = sum(...numbers) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) <span class="hljs-comment"><span class="hljs-comment">//15</span></span></code> </pre> <br>  Ahora, utilizando el mismo enfoque, puede trabajar con objetos.  Aqu√≠ hay un ejemplo del uso de la declaraci√≥n rest en una operaci√≥n de asignaci√≥n destructiva. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { first, second, ...others } = { <span class="hljs-attr"><span class="hljs-attr">first</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">second</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">third</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">fourth</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">fifth</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first) <span class="hljs-comment"><span class="hljs-comment">//1 console.log(second) //2 console.log(others) //{ third: 3, fourth: 4, fifth: 5 }</span></span></code> </pre> <br>  Aqu√≠ est√° la declaraci√≥n de propagaci√≥n utilizada al crear un nuevo objeto basado en uno existente.  Este ejemplo contin√∫a el anterior. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> items = { first, second, ...others } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(items) <span class="hljs-comment"><span class="hljs-comment">//{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç iteradores asincr√≥nicos</font> </h3><br>  La nueva construcci√≥n <code>for-await-of</code> permite llamar a funciones asincr√≥nicas que devuelven promesas en bucles.  Tales bucles esperan la resoluci√≥n de la promesa antes de pasar al siguiente paso.  As√≠ es como se ve. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> readLines(filePath)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(line) }</code> </pre> <br>  Al mismo tiempo, debe tenerse en cuenta que tales bucles deben usarse en funciones asincr√≥nicas, de la misma manera que cuando se trabaja con la construcci√≥n <code>async/await</code> . <br><br><h3>  <font color="#3AC1EF">Method M√©todo Promise.prototype.finally ()</font> </h3><br>  Si la promesa se resuelve con √©xito, se llama al siguiente m√©todo <code>then()</code> .  Si algo sale mal, se llama al m√©todo <code>catch()</code> .  El m√©todo <code>finally()</code> permite ejecutar algo de c√≥digo independientemente de lo que sucedi√≥ antes. <br><br><pre> <code class="javascript hljs">fetch(<span class="hljs-string"><span class="hljs-string">'file.json'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.json()) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error)) .finally(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'finished'</span></span>))</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Mejoras de expresi√≥n regular</font> </h3><br>  Las expresiones regulares tienen la capacidad de verificar retrospectivamente las cadenas ( <code>?&lt;=</code> ).  Esto le permite buscar ciertas construcciones en las l√≠neas antes de las cuales hay otras construcciones. <br><br>  La capacidad de preceder las comprobaciones utilizando el constructo <code>?=</code> Estaba presente en expresiones regulares implementadas en JavaScript antes del est√°ndar ES2018.  Dichas verificaciones le permiten saber si otro fragmento sigue a cierto fragmento de una l√≠nea. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/Roger(?= Waters)/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//false console.log(res2) //true</span></span></code> </pre> <br>  Construcci√≥n <code>?!</code>  realiza la operaci√≥n opuesta: se encontrar√° una coincidencia solo si otra l√≠nea no sigue la l√≠nea dada. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/Roger(?! Waters)/g</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//true console.log(res2) //false</span></span></code> </pre> <br>  En la verificaci√≥n retrospectiva, como ya se mencion√≥, <code>?&lt;=</code> utiliza la construcci√≥n <code>?&lt;=</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;=Roger) Waters/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Pink Waters is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//false console.log(res2) //true</span></span></code> </pre> <br>  La operaci√≥n opuesta a la descrita se puede realizar utilizando la construcci√≥n <code>?&lt;!</code>  . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;!Roger) Waters/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Pink Waters is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//true console.log(res2) //false</span></span></code> </pre> <br><h4>  Secuencias de escape de expresiones regulares Unicode </h4><br>  En las expresiones regulares, puede usar la clase <code>\d</code> que coincide con cualquier d√≠gito, la clase <code>\s</code> que coincide con cualquier car√°cter de espacio en blanco, la clase <code>\w</code> que coincide con cualquier car√°cter alfanum√©rico, etc.  La funci√≥n en cuesti√≥n ampl√≠a el conjunto de clases que se pueden usar en expresiones regulares, lo que le permite trabajar con secuencias Unicode.  Estamos hablando de la clase <code>\p{}</code> y la inversa de la clase <code>\P{}</code> . <br><br>  En Unicode, cada personaje tiene un conjunto de propiedades.  Estas propiedades se indican entre llaves del grupo <code>\p{}</code> .  Entonces, por ejemplo, la propiedad <code>Script</code> determina la familia de idiomas a la que pertenece un car√°cter, la propiedad <code>ASCII</code> , l√≥gica, toma <code>true</code> para los caracteres ASCII, y as√≠ sucesivamente.  Por ejemplo, descubriremos si algunas l√≠neas contienen solo caracteres ASCII. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('ABC@')) //true console.log(r.test('ABC')) //false</span></span></code> </pre> <br>  La propiedad <code>ASCII_Hex_Digit</code> es <code>true</code> solo para los caracteres que se pueden usar para escribir n√∫meros hexadecimales. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/^\p{ASCII_Hex_Digit}+$/u</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'0123456789ABCDEF'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('H')) //false</span></span></code> </pre> <br>  Hay muchas otras propiedades similares que se utilizan de la misma manera que se describe anteriormente.  Entre ellos se encuentran <code>Uppercase</code> , <code>Lowercase</code> , <code>White_Space</code> , <code>Alphabetic</code> , <code>Emoji</code> . <br><br>  Por ejemplo, a continuaci√≥n se explica c√≥mo usar la propiedad <code>Script</code> para determinar qu√© alfabeto se usa en una cadena.  Aqu√≠ verificamos la cadena para el uso del alfabeto griego. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/^\p{Script=Greek}+$/u</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'ŒµŒªŒªŒ∑ŒΩŒπŒ∫Œ¨'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('hey')) //false</span></span></code> </pre> <br>  Los detalles sobre estas propiedades se pueden encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h4>  Grupos nombrados </h4><br>  Los grupos de caracteres capturados en ES2018 pueden recibir nombres.  As√≠ es como se ve. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> re = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = re.exec(<span class="hljs-string"><span class="hljs-string">'2015-01-02'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">/* [ '2015-01-02', '2015', '01', '02', index: 0, input: '2015-01-02', groups: { year: '2015', month: '01', day: '02' } ] */</span></span></code> </pre> <br>  Sin el uso de grupos con nombre, los mismos datos solo estar√≠an disponibles como elementos de matriz. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> re = <span class="hljs-regexp"><span class="hljs-regexp">/(\d{4})-(\d{2})-(\d{2})/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = re.exec(<span class="hljs-string"><span class="hljs-string">'2015-01-02'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">/* [ '2015-01-02', '2015', '01', '02', index: 0, input: '2015-01-02', groups: undefined ] */</span></span></code> </pre> <br><h4>  Bandera de Regex </h4><br>  Usar la bandera <code>s</code> da como resultado un personaje <code>.</code>  (dot) coincidir√°, entre otros, con el car√°cter de nueva l√≠nea.  Sin esta bandera, un punto coincide con cualquier car√°cter, excepto una nueva l√≠nea. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/hi.welcome/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'hi\nwelcome'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// false console.log(/hi.welcome/s.test('hi\nwelcome')) // true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Con este material, estamos completando la publicaci√≥n de las traducciones de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> manual de JavaScript.  Esperamos que estas publicaciones hayan ayudado a aquellos que no hab√≠an trabajado con JavaScript antes a dar sus primeros pasos en la programaci√≥n en este lenguaje. <br><br>  <b>Estimados lectores!</b>  Si no ha escrito en JS antes y ha dominado este idioma en esta gu√≠a, comparta sus impresiones. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es431872/">https://habr.com/ru/post/es431872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es431862/index.html">Mitap Sbertekh en Ekaterimburgo</a></li>
<li><a href="../es431864/index.html">PVS-Studio ROI: c√≥mo no perder millones (versi√≥n borrador del art√≠culo)</a></li>
<li><a href="../es431866/index.html">Conceptos err√≥neos de los programadores sobre nombres, con ejemplos</a></li>
<li><a href="../es431868/index.html">Horas en l√°mparas de descarga de gas (GRI), son reloj Nixie</a></li>
<li><a href="../es431870/index.html">El desarrollador de libros interactivos con LED se queja del robo de ideas por parte de los empleados de Google</a></li>
<li><a href="../es431874/index.html">Imba: lenguaje compatible con JavaScript para un trabajo r√°pido con DOM</a></li>
<li><a href="../es431876/index.html">Optimizaci√≥n de aplicaciones angulares.</a></li>
<li><a href="../es431878/index.html">Caracter√≠sticas de JavaScript poco conocidas</a></li>
<li><a href="../es431880/index.html">Doom of SceneKit. Experiencia Yandex con gr√°ficos 3D en iOS</a></li>
<li><a href="../es431884/index.html">Microsoft super√≥ a Apple en la capitalizaci√≥n de mercado: ¬øc√≥mo sucedi√≥ esto?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>