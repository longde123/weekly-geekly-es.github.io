<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游뱧游낗 游 游뱛游낗 Reconocimiento de color y luz con APDS-9960 游녥游낕 游 游끯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente, apareci칩 un art칤culo en Habr.com que, entre otras cosas, inform칩 sobre un sensor de luz. Hace alg칰n tiempo encontr칠 y adquir칤 algo inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reconocimiento de color y luz con APDS-9960</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423847/"><p><img src="https://habrastorage.org/webt/rm/ag/5g/rmag5gl-y94uucthuku5ltafn_u.jpeg" alt="imagen"></p><br><p> Recientemente, apareci칩 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un art칤culo</a> en Habr.com que, entre otras cosas, inform칩 sobre un sensor de luz.  Hace alg칰n tiempo encontr칠 y adquir칤 algo interesante: un m칩dulo fabricado por RobotDyn basado en el sensor APDS-9960, que tambi칠n sabe c칩mo medir el nivel de iluminaci칩n.  Despu칠s de buscar y no poder encontrar referencias a este dispositivo en este recurso, decid칤 que esta era una buena raz칩n para escribir un art칤culo. </p><br><p>  En el art칤culo, me gustar칤a presentar brevemente a los lectores las posibilidades que ofrece este sensor y examinar con m치s detalle c칩mo se puede usar para determinar el color y medir el nivel de iluminaci칩n. </p><a name="habracut"></a><br><p>  APDS-9960 es un sensor de Avago, es un sensor digital combinado con varias funciones diferentes interesantes y 칰tiles. <br>  칄l sabe c칩mo reconocer los gestos, determinar la proximidad, y tambi칠n sabe c칩mo registrar la intensidad de la luz ambiental y determinar el color. <br>  Esto es exactamente lo que se discutir치 en este art칤culo: con la ayuda de los antiguos STM32VLDISCOVERY y APDS-9960, mediremos la iluminaci칩n y determinaremos el color en toda su riqueza de tonos de rojo, verde y azul. </p><br><p>  Sin embargo, antes de entrar en la parte pr치ctica, perm칤tanme escribir algunas palabras sobre las caracter칤sticas generales del APDS-9960. </p><br><p>  El diagrama funcional de APDS-9960 se muestra en la figura a continuaci칩n. <br><img src="https://habrastorage.org/webt/u9/rg/-n/u9rg-nkiqgefja-ztskmzzp6bvo.jpeg" alt="imagen"></p><br><p>  <strong>Reconocimiento de gestos</strong> </p><br><p>  La idea de c칩mo se ve el reconocimiento de gestos en el APDS-9960 se muestra muy bien en este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">video</a> . </p><br><p>  La documentaci칩n describe el principio de registro de gestos: <br>  Para reconocer el gesto, se utilizan cuatro fotodiodos direccionales que registran la luz reflejada (en el rango infrarrojo) emitida por el LED incorporado. </p><br><p><img src="https://habrastorage.org/webt/2j/mf/u_/2jmfu_8tlls330xu675wtqc5ssu.jpeg" alt="imagen"></p><br><p>  <strong>Funci칩n de detecci칩n de proximidad</strong> </p><br><p>  A juzgar por la descripci칩n de la misma documentaci칩n, el mecanismo de detecci칩n (aproximaci칩n) funciona seg칰n el mismo principio exacto que el reconocimiento de gestos. </p><br><p>  <strong>Reconocimiento de color y nivel de luz ambiental (Color / ALS)</strong> </p><br><p>  Seg칰n el diagrama funcional, el sensor determina el nivel de color / luz utilizando los fotodiodos apropiados.  Tambi칠n se afirma que el APDS-9960 tiene filtros incorporados que bloquean los rangos ultravioleta e infrarrojo. <br>  Simplificado, se ve as칤: las se침ales grabadas por los fotodiodos se miden con el ADC, se ingresan en el b칰fer y luego los datos se env칤an a trav칠s de i2c. </p><br><p><img src="https://habrastorage.org/webt/ta/zs/-8/tazs-8jfaap7pfma6yv_kv-a7ue.jpeg" alt="imagen"></p><br><p>  Los gr치ficos en la imagen de arriba est치n tomados de la documentaci칩n del sensor, la respuesta espectral de Color Sense (RGBC) se presenta en la parte superior izquierda. </p><br><p>  La se침al RGBC de los fotodiodos se acumula durante el per칤odo de tiempo establecido por el valor del registro ATIME.  Para SparkFun (en su "apds9960.h") este valor est치 determinado por la constante DEFAULT_ATIME y es igual a 219 que corresponde a 103 ms. </p><br><p>  La ganancia es ajustable de 1x a 64x y se determina configurando el par치metro CONTROL OTRA VEZ.  La constante DEFAULT_AGAIN, que, a su vez, es igual a 1, que corresponde a una ganancia de 4 veces. </p><br><p>  <strong>Parte pr치ctica</strong> </p><br><p>  Personalmente, solo estaba interesado en la funci칩n Color / ALS en APDS-9960, as칤 que decid칤 considerarlo con m치s detalle y escrib칤 un peque침o c칩digo que demostraba su funcionamiento. <br>  Intent칠 intencionalmente hacer que el c칩digo fuera lo m치s compacto, conciso y extremadamente simple de entender posible;  Todo el c칩digo se presentar치 al final del art칤culo. </p><br><p>  Por lo tanto, toda la documentaci칩n (dibujo, pinout y diagrama de circuito) para el m칩dulo est치 disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web</a> del fabricante. </p><br><p><img src="https://habrastorage.org/webt/gg/dy/3k/ggdy3kbub0kahc7rixcz02xzcgi.jpeg" alt="imagen"></p><br><p>  <strong>Conecte nuestro m칩dulo APDS-9960 a STM32VLDISCOVERY</strong> </p><br><p>  APDS9960 usa la interfaz i2c para comunicarse con el mundo exterior, por lo que para STM32VLDISCOVERY usamos el bus I2C1 conectando el pin del m칩dulo SCL al pin PB6 y el pin SDA al pin PB7, respectivamente.  No olvides conectar la alimentaci칩n y el cable com칰n.  Las interrupciones en este caso no se utilizar치n, por lo que se puede omitir la salida de Int.  En mi foto est치 conectado, pero no se usa. </p><br><p><img src="https://habrastorage.org/webt/bf/2o/ah/bf2oahfh9pfgiyvpugrsgja4voc.jpeg" alt="imagen"></p><br><p>  Y ahora un peque침o c칩digo.  Dado que toda la comunicaci칩n con el m칩dulo ocurre usando i2c, crearemos la configuraci칩n necesaria y definiremos las funciones de lectura / escritura para i2c. </p><br><p>  <u>Inicializaci칩n de I2C.</u> </p><br><div class="spoiler">  <b class="spoiler_title">Inicializaci칩n</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">I2C1_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ I2C_InitTypeDef I2C_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB| RCC_APB2Periph_AFIO , ENABLE); GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); I2C_StructInit(&amp;I2C_InitStructure); I2C_InitStructure.I2C_ClockSpeed = <span class="hljs-number"><span class="hljs-number">100000</span></span>; I2C_InitStructure.I2C_OwnAddress1 = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; I2C_InitStructure.I2C_Ack = I2C_Ack_Enable; I2C_Init(I2C1, &amp;I2C_InitStructure); I2C_Cmd(I2C1, ENABLE); }</code> </pre> </div></div><br><p>  <u>Leyendo el registro.</u> </p><br><div class="spoiler">  <b class="spoiler_title">Funci칩n para leer un valor de un registro</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> i2c1_read(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> addr) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> data; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)); I2C_GenerateSTART(I2C1, ENABLE); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, I2C_Direction_Transmitter); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); I2C_SendData(I2C1, addr); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_GenerateSTART(I2C1, ENABLE); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, I2C_Direction_Receiver); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)); data = I2C_ReceiveData(I2C1); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); I2C_AcknowledgeConfig(I2C1, DISABLE); I2C_GenerateSTOP(I2C1, ENABLE); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; }</code> </pre></div></div><br><p>  <u>Escribir un valor en un registro</u> </p><br><div class="spoiler">  <b class="spoiler_title">Funci칩n de valor de registro</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i2c1_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data)</span></span></span><span class="hljs-function"> </span></span>{ I2C_GenerateSTART(I2C1, ENABLE); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>, I2C_Direction_Transmitter); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); I2C_SendData(I2C1, addr); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_SendData(I2C1, data); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_GenerateSTOP(I2C1, ENABLE); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {}; }</code> </pre> </div></div><br><p>  Para que un m칩dulo funcione correctamente, primero debe configurarse correctamente.  Espec칤ficamente para el reconocimiento del color y la iluminaci칩n, debe hacer lo siguiente: </p><br><p>  1) Definir el registro ATIME.  De forma predeterminada, cuando se inicia el m칩dulo, el registro ATIME tiene el valor 0xFF y si no cambia nada, esto afectar치 la sensibilidad del sensor; la sensibilidad ser치 baja. </p><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_ATIME, DEFAULT_ATIME);</code> </pre> <br><p>  2) en el siguiente paso establecemos el campo de par치metro OTRA VEZ (ALS y Control de ganancia de color) del registro Control Register One (0x8F) en el valor correspondiente a la ganancia igual a x4 (DEFAULT_AGAIN es igual a AGAIN_4X). </p><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_CONTROL, DEFAULT_AGAIN);</code> </pre> <br><p>  3) active la opci칩n ALS configurando el bit AEN del registro de registro de habilitaci칩n (0x80) <br>  4) encienda la alimentaci칩n del m칩dulo configurando el bit PON del mismo registro </p><br><p>  as칤: </p><br><pre> <code class="cpp hljs">i2c1_write(APDS9960_ENABLE, (APDS9960_PON | APDS9960_AEN));</code> </pre> <br><p>  Esa es toda la configuraci칩n.  Nuestro sensor est치 listo para el trabajo y la defensa, puede comenzar a medir todos los colores. </p><br><p>  Pero primero, mida el nivel de iluminaci칩n </p><br><pre> <code class="cpp hljs">Colour_tmpL = i2c1_read(APDS9960_CDATAL); Colour_tmpH = i2c1_read(APDS9960_CDATAH); Colour_Clear = (Colour_tmpH &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + Colour_tmpL;</code> </pre> <br><p>  Y ahora nuestro negocio ha llegado a las flores tan esperadas </p><br><div class="spoiler">  <b class="spoiler_title">Obtener datos RGB</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//_________________________________________________________________________ // RED color Recognize: Colour_tmpL = i2c1_read(APDS9960_RDATAL); Colour_tmpH = i2c1_read(APDS9960_RDATAH); Colour_Red = (Colour_tmpH &lt;&lt; 8) + Colour_tmpL; //_________________________________________________________________________ // GREEN color Recognize: Colour_tmpL = i2c1_read(APDS9960_GDATAL); Colour_tmpH = i2c1_read(APDS9960_GDATAH); Colour_Green = (Colour_tmpH &lt;&lt; 8) + Colour_tmpL; //_________________________________________________________________________ // BLUE color Recognize: Colour_tmpL = i2c1_read(APDS9960_BDATAL); Colour_tmpH = i2c1_read(APDS9960_BDATAH); Colour_Blue = (Colour_tmpH &lt;&lt; 8) + Colour_tmpL;</span></span></code> </pre></div></div><br><p>  Y ahora todo el c칩digo: </p><br><div class="spoiler">  <b class="spoiler_title">main.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f10x.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_I2C_ADDR 0x39 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_ATIME 0x81 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_CONTROL 0x8F #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_ENABLE 0x80 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_CDATAL 0x94 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_CDATAH 0x95 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_RDATAL 0x96 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_RDATAH 0x97 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_GDATAL 0x98 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_GDATAH 0x99 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_BDATAL 0x9A #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_BDATAH 0x9B </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Bit fields */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_PON 0x01 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_AEN 0x02 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_PEN 0x04 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_WEN 0x08 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APSD9960_AIEN 0x10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_PIEN 0x20 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_GEN 0x40 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> APDS9960_GVALID 0x01 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ALS Gain (AGAIN) values */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AGAIN_1X 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AGAIN_4X 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AGAIN_16X 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> AGAIN_64X 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEFAULT_ATIME 219 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 103ms #define DEFAULT_AGAIN AGAIN_4X uint8_t Colour_tmpL = 0; uint8_t Colour_tmpH = 0; uint16_t Colour_Clear = 0; uint16_t Colour_Red = 0; uint16_t Colour_Green = 0; uint16_t Colour_Blue = 0; //----------------------------------------------------------------------- void I2C1_init(void) { I2C_InitTypeDef I2C_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB| RCC_APB2Periph_AFIO , ENABLE); GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); I2C_StructInit(&amp;I2C_InitStructure); I2C_InitStructure.I2C_ClockSpeed = 100000; I2C_InitStructure.I2C_OwnAddress1 = 0x01; I2C_InitStructure.I2C_Ack = I2C_Ack_Enable; I2C_Init(I2C1, &amp;I2C_InitStructure); I2C_Cmd(I2C1, ENABLE); } //----------------------------------------------------------------------- uint8_t i2c1_read(uint8_t addr) { uint8_t data; while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)); I2C_GenerateSTART(I2C1, ENABLE); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;1, I2C_Direction_Transmitter); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); I2C_SendData(I2C1, addr); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_GenerateSTART(I2C1, ENABLE); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;1, I2C_Direction_Receiver); while(!I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)); data = I2C_ReceiveData(I2C1); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)); I2C_AcknowledgeConfig(I2C1, DISABLE); I2C_GenerateSTOP(I2C1, ENABLE); while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)); return data; } //----------------------------------------------------------------------- void i2c1_write(uint8_t addr, uint8_t data) { I2C_GenerateSTART(I2C1, ENABLE); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)); I2C_Send7bitAddress(I2C1, APDS9960_I2C_ADDR&lt;&lt;1, I2C_Direction_Transmitter); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)); I2C_SendData(I2C1, addr); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_SendData(I2C1, data); while(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)); I2C_GenerateSTOP(I2C1, ENABLE); while(I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {}; } //----------------------------------------------------------------------- int main() { I2C1_init(); i2c1_write(APDS9960_ATIME, DEFAULT_ATIME); i2c1_write(APDS9960_CONTROL, DEFAULT_AGAIN); i2c1_write(APDS9960_ENABLE, (APDS9960_PON | APDS9960_AEN)); while (1) { Colour_Clear = 0; Colour_Red = 0; Colour_Green = 0; Colour_Blue = 0; //_________________________________________________________________________ // Ambient Light Recognize: Colour_tmpL = i2c1_read(APDS9960_CDATAL); Colour_tmpH = i2c1_read(APDS9960_CDATAH); Colour_Clear = (Colour_tmpH &lt;&lt; 8) + Colour_tmpL; //_________________________________________________________________________ // RED color Recognize: Colour_tmpL = i2c1_read(APDS9960_RDATAL); Colour_tmpH = i2c1_read(APDS9960_RDATAH); Colour_Red = (Colour_tmpH &lt;&lt; 8) + Colour_tmpL; //_________________________________________________________________________ // GREEN color Recognize: Colour_tmpL = i2c1_read(APDS9960_GDATAL); Colour_tmpH = i2c1_read(APDS9960_GDATAH); Colour_Green = (Colour_tmpH &lt;&lt; 8) + Colour_tmpL; //_________________________________________________________________________ // BLUE color Recognize: Colour_tmpL = i2c1_read(APDS9960_BDATAL); Colour_tmpH = i2c1_read(APDS9960_BDATAH); Colour_Blue = (Colour_tmpH &lt;&lt; 8) + Colour_tmpL; } }</span></span></span></span></code> </pre></div></div><br><p>  Deliberadamente, no hice la definici칩n de constantes en un encabezado separado por conveniencia. <br>  Las constantes, por cierto, fueron tomadas del dep칩sito oficial de SparkFun Electronics.  <a href="">Desde aqu칤</a> </p><br><p>  Realmente me gust칩 el APDS-9960, algo interesante, fue interesante investigar, fue interesante escribir un art칤culo.  Espero que alguien encuentre 칰til este material.  Gracias por su atencion </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423847/">https://habr.com/ru/post/es423847/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423835/index.html">Revelamos la f칩rmula de X - 칤ndice de calidad del sitio Yandex</a></li>
<li><a href="../es423837/index.html">쮺칩mo arruinar r치pidamente cualquier proyecto? 17 mejores consejos malos</a></li>
<li><a href="../es423839/index.html">Prueba sha256 por toothOK para red neuronal</a></li>
<li><a href="../es423843/index.html">Si est치s en Kazan o Novosibirsk y quieres dise침ar microchips, como en Cupertino</a></li>
<li><a href="../es423845/index.html">Cond칩n corporativo</a></li>
<li><a href="../es423851/index.html">Presentamos el nuevo complemento de Grafana: panel de mapa de estado</a></li>
<li><a href="../es423853/index.html">C칩mo funciona el almacenamiento S3 DataLine</a></li>
<li><a href="../es423855/index.html">Nebulosa Zyxel: facilidad de administraci칩n como base para el ahorro</a></li>
<li><a href="../es423857/index.html">6 desaf칤os que encontrar치s al aprender a programar</a></li>
<li><a href="../es423861/index.html">Linternas solares: necesitamos m치s luz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>