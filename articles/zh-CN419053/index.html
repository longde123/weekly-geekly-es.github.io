<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍✈️ 🌊 👲🏻 测试Adaptec RAID缓存技术 ♣️ 🚼 👨🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在硬盘驱动器上使用RAID阵列的解决方案已经使用了很长时间。 通常，它们在许多需要相对便宜的大容量，容错阵列的领域中继续流行。 考虑到现代硬盘驱动器的大小，它们的速度以及其他原因，最大的实际兴趣是RAID6阵列（如果有很多磁盘，则为RAID60）。 但是，这种类型的阵列在随机写入操作上的性能很低，并...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>测试Adaptec RAID缓存技术</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419053/"> 在硬盘驱动器上使用RAID阵列的解决方案已经使用了很长时间。 通常，它们在许多需要相对便宜的大容量，容错阵列的领域中继续流行。 考虑到现代硬盘驱动器的大小，它们的速度以及其他原因，最大的实际兴趣是RAID6阵列（如果有很多磁盘，则为RAID60）。 但是，这种类型的阵列在随机写入操作上的性能很低，并且对其执行任何操作都不容易。 <br><br> 当然，在这种情况下，我们谈论的是“原始音量”的速度。 在现实生活中，文件系统，操作系统，应用程序以及所有添加到其中的内容。 因此，事实上，并非一切都那么糟糕。 但是，还有独立于这些子系统的用于提高生产率的硬件和软件方法。 我们谈论的是将快得多的闪存驱动器添加到硬盘驱动器阵列时的缓存技术。 <br><a name="habracut"></a><br> 特别是，在Adaptec RAID控制器中，此技术称为maxCache，其3.0版在ASR-8885Q和ASR-81605ZQ模型中实现。 使用它时，必须考虑几个功能：每个控制器仅允许一个maxCache卷，maxCache卷的最大卷为1 TB，为了使写缓存正常工作，您必须对maxCache卷本身进行容错配置（例如，镜像）。 同时，用户可以为每个逻辑卷独立指定他将如何与maxCache一起精确使用-用于读取和/或写入以及以哪种模式进行。 <br> 为了进行测试，我们使用了基于Supermicro X10SLM-F主板的服务器，Intel Xeon处理器E3-1225 v3（4C / 8T，3.2 GHz），32 GB RAM，并在Debian 9下运行。 <br><br><img src="https://habrastorage.org/webt/dg/sb/uf/dgsbufgn7nmom7dyat2wqc3mb44.jpeg" alt="图片"><br><br> 经过测试的ASR-81605ZQ控制器具有内存保护单元，并且在处理硬盘阵列时具有活动的读取和写入缓存。 回想一下，该型号的内部存储器为1 GB。 由六个容量为10 TB的Seagate ST10000NM0086 SATA硬盘驱动器创建了一个256 KB块的RAID6阵列。 该卷的总容量约为36 TB。 <br><br> 两对设备充当maxCache卷的SSD：两个Samsung 850 EVO第二代1TB SATA接口和两个用于创建RAID1阵列的Seagate 1200 SSD（ST400FM0053）400GB SAS接口。 当然，第一个模型已经被认为是过时的，而不仅仅是在道德上。 但是为了说明预算方案，它可以做到。 第二种形式在形式上更适合“公司”类别，但也很难认为它是现代的。 在maxCache数组本身的设置中，只有“刷新和提取速率”选项，该选项保持默认值（“中”）。 无法选择操作或磁盘卷的优先级。 请注意，驱动器未处于新状态，并且在此配置中未使用TRIM。 <br><br> 创建maxCache卷后，需要在逻辑卷的属性中启用使用它的参数。 共有三个选项：启用读取缓存，启用写入缓存和写入缓存类型。 <br><br>  fio实用程序用作测试工具，脚本集包括具有不同线程数的顺序和随机操作。 值得注意的是，使用合成技术缓存技术对产品性能进行研究很难被认为是最佳选择。 最好充分评估对实际任务的影响，因为综合负载在某种程度上与缓存的思想相矛盾。 另外，在这种情况下，我们考虑的是低级操作，实际上，用户通常处理文件，并且如上所述，卷的文件系统，操作系统和软件本身都包含在它们的工作中。 因此，合成材料因其简单性和可重复性而吸引人，它本身没有任何意义，而主要是用于比较在难以缓存算法和对效果进行粗略估算的情况下的“情况如何以及它如何变成”。 <br><br> 首先，让我们看看我们的阵列本身具有的功能。 回想一下，在顺序操作中，以MB / s为单位的速度和延迟（以对数为单位）很有趣，而在随机操作中，IOPS和延迟也很有趣。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3s/19/mm/3s19mmb6cs1rao3dpq-owfkvovk.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1n/fd/-p/1nfd-phxwyyxec9whbch84diblc.jpeg" alt="图片"></div><br> 使用此配置的数组进行流操作的速度为900 MB / s。 同时，即使有大量线程，延迟也不会超过70 ms。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2b/jy/xb/2bjyxbmkl9r0qfb-zolkda7snuc.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/24/kz/t2/24kzt2cyodl7hknyw0ujgvn2nja.jpeg" alt="图片"></div><br> 从结果可以看出，对于硬盘驱动器，随机操作是最困难的负载。 如果将延迟阈值设置为100 ms，则读取和记录时可获得大约1100 IOPS，无论负载如何，该阵列可提供约300 IOPS。 请注意，在同一控制器上由36个磁盘组成的RAID60阵列中，由于配置了12个硬盘驱动器的三个块，因此可以获得更多有趣的数字。 这样，您就可以在随机读取和写入时分别增加旋转速度并将速度分别提高到3500和1200 IOPS（在这种配置下，HGST的SAS硬盘驱动器相当老，容量为2 TB）。 此选项的不利方面是卷的额外成本，因为不是“丢失”了每个卷两个磁盘，而是每个组两个磁盘。 <br><br> 因此，如果不进行缓存，我们的数组对于随机操作而言就显得很难过。 当然，这是卷的“原始”速度，程序很少提供完全随机的负载（回想一下，这里我们仍然有一个用于存储大文件的数组，而不是数据库）。 <br><br><img src="https://habrastorage.org/webt/aw/db/fa/awdbfaorgnfjipkfdtlwejc12u4.png" alt="图片"><br><br> 让我们看看SSD在这种情况下如何提供帮助。 在测试中，将使用四个可用的配置选项-仅读取，读取和写入直写，读取和写入回写，读取和写入即时回写： <br><br><ul><li>  WB-启用回写功能。 当对性能影响很小或没有影响时，maxCache会将数据存储在SSD上并将其写回到硬盘上。 这是默认策略。 </li><li>  INSTWB-启用即时回写。 除了默认策略外，如果SSD上有空间并且脏页数低于阈值，maxCache将动态创建脏页以进行全条带化写入。 </li><li>  WT-启用直写。 与即时回写相似，但全条带写入同时进入高速缓存和硬盘，并且不会即时创建脏页。 </li></ul><br> 让我们从非常大的SATA驱动器开始。 这次的图表将是分开的-四个测试方案中的每一个的速度和延迟。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/uq/c6/fxuqc6pydfis8whfyji2bwgqdes.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/l6/ly/pql6lypcnqudq_qymja9_hbp1_s.jpeg" alt="图片"></div><br> 在顺序读取操作中，无论预期使用的缓存类型如何，阵列均显示稳定的结果。 同时，它们与没有缓存的阵列的区别很小-全部相同，均为900 MB / s，延迟约为70毫秒。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/87/sl/cd/87slcdfkyy9bahurephtbevd_va.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/go/1d/xn/go1dxnn30tkp-ltqdrbeqe3qnru.jpeg" alt="图片"></div><br> 顺序写入有两组-仅用于读取和具有回写功能，它们显示的结果类似于没有缓存的阵列-大约900 MB / s，最高可达100 ms，直写式和即时回写功能最多可以拉出100 MB / s，并且写入速度大得多延误。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sj/v_/w8/sjv_w8bpjqwt1i7f8opfov1z3l8.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/tl/cn/ditlcnsltth8nbfqvfykhjtiyxy.jpeg" alt="图片"></div><br> 回想一下，在读取硬盘驱动器阵列时，最大显示约为1100 IOPS，但在此边界处，延迟已开始超过100毫秒。 使用SATA SSD缓存，您可以获得更好的结果-大约1,500 IOPS，并且延迟相同。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4x/st/bx/4xstbxk1q9rlf0zoavgk7m_lfky.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/dj/nu/txdjnuopc4qxxfkqoz6xzixbxx4.jpeg" alt="图片"></div><br> 在随机记录操作中，我们看到了最大的效果-指标增加了两倍半并同时增加了负载能力。 使用缓存时，最多可能有100毫秒的延迟，而线程的延迟是其两倍到三倍。 <br><br> 关于此配置的一般结论是：它不干扰顺序读取，在某些配置中不干扰顺序写入，在随机读取时增加大约35％，并且在随机写入时提高性能两次。 <br><br> 现在，让我们看一下第二对SSD驱动器的缓存量的变体。 请注意，在我们的案例中，它们的体积明显较小，具有12 Gb / s SAS接口和更高的速度特性（由制造商声明）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8e/xq/x3/8exqx3s3i0_hsravea2fylcoh8s.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lv/sp/rw/lvsprwwd1m1r2svgrcmjo9awbxs.jpeg" alt="图片"></div><br> 在顺序阅读时，结果与之前给出的结果没有什么不同，这是可以预期的。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gu/dl/gd/gudlgdgjmsedwol2_ybhl2tmiia.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d0/jv/pv/d0jvpv9izv19wdnz91b23kjnt7c.jpeg" alt="图片"></div><br> 在顺序记录中，我们现在分为三组-具有“直写式”写缓存的配置滞后，大约“即时回写”显示的是最大速度的一半，只有“回写”与没有缓存的阵列没有什么不同。 与等待时间相同的情况。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/el/p-/v-/elp-v-kgirb2hea_ba3vwxtdqsm.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sw/tp/v5/swtpv5z6q0yztaso_t9wpmba8cg.jpeg" alt="图片"></div><br> 但是在随机读取中，即时回写被证明是最好的，达到2500 IOPS，而其余配置只能扩展到1800 IOPS。 请注意，所有带有写缓存的选项都比“干净”的数组要快得多。 同时，即使有大量线程，等待时间也不会超过100毫秒。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/38/wi/6p/38wi6pe6ly2lkwjmemab1l3dukw.jpeg" alt="图片"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lr/qo/cu/lrqocuuewpw6hzpmnagy8ga3muq.jpeg" alt="图片"></div><br> 在随机读取操作中，即时回写再次出现，显示近2,000 IOPS。 第二组包含具有1000 IOPS的直写和回写配置。 <br><br> 最后一个不使用缓存进行写操作的参与者显示了大约IOPS以及300个IOPS。 <br><br> 此高速缓存卷中最有趣的选项也许是即时回写。 没错，流式读取操作的速度较慢。 可以使用RAID10配置的maxCache卷来解决此问题，但是在存储机柜中已经花费了四个托架。 <br><br> 通常，我们可以说使用maxCache技术对于提高硬盘驱动器阵列的性能确实很有用，尤其是在负载中存在大量随机操作的情况下。 但是，仍然不可能认为它与台式计算机或工作站中的SSD取代硬盘一样有效。 <br><br> 测试中注意到的最大效果是将随机操作的速度提高了2-3倍。 当然，没有使用最快的SSD，这在某些测试中得到了明显体现（例如，以“直写”模式进行顺序记录）。 另外，我想再次提请注意以下事实：选择缓存配置会显着影响结果。 鉴于可以“即时”更改设置而不会丢失数据，因此值得您自己检查任务中的所有选项并选择最佳选项。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN419053/">https://habr.com/ru/post/zh-CN419053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN419041/index.html">我踩过的9台Elasticsearch耙</a></li>
<li><a href="../zh-CN419043/index.html">难以捉摸的帧定时问题</a></li>
<li><a href="../zh-CN419047/index.html">Reddit在2005-2007年间使用密码和电子邮件对数据库进行了黑客入侵，泄漏</a></li>
<li><a href="../zh-CN419049/index.html">GeekBrains推出“在数字中寻找自己”免费在线教育马拉松</a></li>
<li><a href="../zh-CN419051/index.html">Flant如何帮助初学者</a></li>
<li><a href="../zh-CN419055/index.html">在弦论中，您可以使用更少的Universe来解决问题。</a></li>
<li><a href="../zh-CN419061/index.html">GoLand 2018.2的新增功能</a></li>
<li><a href="../zh-CN419063/index.html">使用Freepascal自动从USRLE获取信息</a></li>
<li><a href="../zh-CN419065/index.html">虚拟世界英特尔。 练习</a></li>
<li><a href="../zh-CN419067/index.html">如何出售个人数据，或为什么很难在信息上加上价格标签</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>