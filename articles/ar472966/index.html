<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💾 👨🏾‍🤝‍👨🏻 👨🏽‍💼 كيف يبدو أرشيف الرمز البريدي وما الذي يمكننا فعله به. الجزء 2 - واصف البيانات وضغطها 💇🏼 🏝️ 🏌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="استمرار المقال كيف يبدو أرشيف الرمز البريدي وماذا يمكننا أن نفعل به . 
 مقدمة 


 يوم جيد. 
 ومرة أخرى على الهواء لدينا برامج غير تقليدية في PHP. 


 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>كيف يبدو أرشيف الرمز البريدي وما الذي يمكننا فعله به. الجزء 2 - واصف البيانات وضغطها</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472966/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  <i>استمرار المقال <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">كيف يبدو أرشيف الرمز البريدي وماذا يمكننا أن نفعل به</a> .</i> </p><br><h3 style=";text-align:right;direction:rtl">  مقدمة </h3><br><p style=";text-align:right;direction:rtl"> يوم جيد. <br>  ومرة أخرى على الهواء لدينا برامج غير تقليدية في PHP. </p><br><p style=";text-align:right;direction:rtl">  في مقال سابق ، كان القراء المحترمون مهتمين بالضغط والرمز البريدي.  اليوم سنحاول فتح هذا الموضوع قليلاً. </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl">  دعنا نلقي نظرة على <br><br></p><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">رمز من المادة الأخيرة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//        (1.txt  2.txt)   : $entries = [ '1.txt' =&gt; 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc id ante ultrices, fermentum nibh eleifend, ullamcorper nunc. Sed dignissim ut odio et imperdiet. Nunc id felis et ligula viverra blandit a sit amet magna. Vestibulum facilisis venenatis enim sed bibendum. Duis maximus felis in suscipit bibendum. Mauris suscipit turpis eleifend nibh commodo imperdiet. Donec tincidunt porta interdum. Aenean interdum condimentum ligula, vitae ornare lorem auctor in. Suspendisse metus ipsum, porttitor et sapien id, fringilla aliquam nibh. Curabitur sem lacus, ultrices quis felis sed, blandit commodo metus. Duis tincidunt vel mauris at accumsan. Integer et ipsum fermentum leo viverra blandit.', '2.txt' =&gt; 'Mauris in purus sit amet ante tempor finibus nec sed justo. Integer ac nibh tempus, mollis sem vel, consequat diam. Pellentesque ut condimentum ex. Praesent finibus volutpat gravida. Vivamus eleifend neque sit amet diam scelerisque lacinia. Nunc imperdiet augue in suscipit lacinia. Curabitur orci diam, iaculis non ligula vitae, porta pellentesque est. Duis dolor erat, placerat a lacus eu, scelerisque egestas massa. Aliquam molestie pulvinar faucibus. Quisque consequat, dolor mattis lacinia pretium, eros eros tempor neque, volutpat consectetur elit elit non diam. In faucibus nulla justo, non dignissim erat maximus consectetur. Sed porttitor turpis nisl, elementum aliquam dui tincidunt nec. Nunc eu enim at nibh molestie porta ut ac erat. Sed tortor sem, mollis eget sodales vel, faucibus in dolor.', ]; //      Lorem.zip,      cwd (      ) $destination = 'Lorem.zip'; $handle = fopen($destination, 'w'); //      ,    ,     ,   "" Central Directory File Header $written = 0; $dictionary = []; foreach ($entries as $filename =&gt; $content) { //         Local File Header,     //        ,      . $fileInfo = [ //     'versionToExtract' =&gt; 10, //   0,        - 'generalPurposeBitFlag' =&gt; 0, //      ,    0 'compressionMethod' =&gt; 0, // -    mtime ,    ,      ? 'modificationTime' =&gt; 28021, //   , ? 'modificationDate' =&gt; 20072, //      .     ,       ,   ? 'crc32' =&gt; hexdec(hash('crc32b', $content)), //     .        . //       :) 'compressedSize' =&gt; $size = strlen($content), 'uncompressedSize' =&gt; $size, //    'filenameLength' =&gt; strlen($filename), //  .    ,   0. 'extraFieldLength' =&gt; 0, ]; //      . $LFH = pack('LSSSSSLLLSSa*', ...array_values([ 'signature' =&gt; 0x04034b50, //  Local File Header ] + $fileInfo + ['filename' =&gt; $filename])); //       ,       Central Directory File Header $dictionary[$filename] = [ 'signature' =&gt; 0x02014b50, //  Central Directory File Header 'versionMadeBy' =&gt; 798, //  .    ,  -  . ] + $fileInfo + [ 'fileCommentLength' =&gt; 0, //    . No comments 'diskNumber' =&gt; 0, //     0,        'internalFileAttributes' =&gt; 0, //    'externalFileAttributes' =&gt; 2176057344, //    'localFileHeaderOffset' =&gt; $written, //      Local File Header 'filename' =&gt; $filename, //  . ]; //      $written += fwrite($handle, $LFH); //    $written += fwrite($handle, $content); } // ,     ,    . //          End of central directory record (EOCD) $EOCD = [ //  EOCD 'signature' =&gt; 0x06054b50, //  .    ,   0 'diskNumber' =&gt; 0, //      -  0 'startDiskNumber' =&gt; 0, //       . 'numberCentralDirectoryRecord' =&gt; $records = count($dictionary), //    .    ,     'totalCentralDirectoryRecord' =&gt; $records, //   Central Directory Record. //      ,      'sizeOfCentralDirectory' =&gt; 0, // ,    Central Directory Records 'centralDirectoryOffset' =&gt; $written, //     'commentLength' =&gt; 0 ]; //     !   foreach ($dictionary as $entryInfo) { $CDFH = pack('LSSSSSSLLLSSSSSLLa*', ...array_values($entryInfo)); $written += fwrite($handle, $CDFH); } // ,   .  ,    $EOCD['sizeOfCentralDirectory'] = $written - $EOCD['centralDirectoryOffset']; //     End of central directory record $EOCD = pack('LSSSSLLS', ...array_values($EOCD)); $written += fwrite($handle, $EOCD); //  . fclose($handle); echo '  : ' . $written . ' ' . PHP_EOL; echo '     `unzip -tq ' . $destination . '`' . PHP_EOL; echo PHP_EOL;</span></span></code> </pre> <br></div></div><br><p style=";text-align:right;direction:rtl">  ما هي مشكلته؟  حسنًا ، في الإنصاف ، تجدر الإشارة إلى أن ميزته الوحيدة هي أنه يعمل ، وهناك مشاكل هناك ، ولكن لا يزال. <br><br>  في رأيي ، المشكلة الرئيسية هي أنه يجب علينا أولاً كتابة <b>"رأس الملف المحلي" (LFH)</b> مع <b>crc32</b> وطول الملف ، ثم محتويات الملف نفسه. <br>  ماذا يهدد هذا؟  أو نقوم بتحميل الملف بأكمله في الذاكرة ، والنظر في crc32 لذلك ، وكتابة <b>LFH</b> ، ثم تكون محتويات الملف اقتصادية من وجهة نظر I / O ، لكنها غير مقبولة مع الملفات الكبيرة.  أو نقرأ الملف مرتين - أولاً لحساب البعثرة ، ثم لقراءة المحتويات والكتابة إلى الأرشيف - اقتصاديًا من وجهة نظر RAM ، ولكن ، على سبيل المثال ، يضاعف الحمل على محرك الأقراص ، وهو ليس بالضرورة SSD. <br><br>  وإذا كان الملف يقع عن بعد وحجمه ، على سبيل المثال ، 1.5GB؟  حسنًا ، يجب عليك إما تحميل كل 1.5 جيجا بايت في الذاكرة ، أو الانتظار حتى يتم تنزيل كل هذه السعة 1.5 جيجا بايت وسنقوم بحساب التجزئة ، ثم ننزعها مرة أخرى لإعطاء المحتويات.  إذا كنا نريد أن نقدم على الطاير ، على سبيل المثال ، قاعدة بيانات تفريغ ، والتي ، على سبيل المثال ، نقرأها من stdout ، فإن هذا غير مقبول عمومًا - لقد تغيرت البيانات في قاعدة البيانات ، وستتغير بيانات التفريغ ، وسيكون هناك تجزئة مختلفة تمامًا وسنحصل على أرشيف غير صالح.  نعم ، الأمور سيئة ، بالطبع. </p><br><h3 style=";text-align:right;direction:rtl">  هيكل واصف البيانات لتدفق سجلات الأرشيف </h3><br><p style=";text-align:right;direction:rtl">  لكن لا يتم إحباطك ، فإن مواصفات ZIP تسمح لنا بكتابة البيانات أولاً ، ثم التمسك ببنية <b>واصف البيانات (DD)</b> بعد البيانات ، التي تحتوي بالفعل على crc32 وطول البيانات المحزومة وطول البيانات دون ضغط.  للقيام بذلك ، نحتاج <strike>فقط 3 مرات في اليوم على معدة فارغة</strike> في <b>LFH</b> حدد <b>generalPurposeBitFlag</b> تساوي <b>0x0008</b> ، وحدد <b>crc32</b> و <b>compressedSize</b> و <b>uncompressedSize</b> <b>0</b> .  بعد ذلك ، بعد البيانات ، نكتب بنية <b>DD</b> ، والتي ستبدو كما يلي: </p><br><br><pre style=";text-align:right;direction:rtl"> <code class="php hljs">pack(<span class="hljs-string"><span class="hljs-string">'LLLL'</span></span>, ...array_values([ <span class="hljs-string"><span class="hljs-string">'signature'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0x08074b50</span></span>, <span class="hljs-comment"><span class="hljs-comment">//  Data Descriptor 'crc32' =&gt; $crc32, //  crc32    'compressedSize' =&gt; $compressedSize, //    'uncompressedSize' =&gt; $uncompressedSize, //    . ]));</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  وفي <b>رأس ملف الدليل المركزي (CDFH)</b> فقط <b>generalPurposeBitFlag</b> ، يجب أن تكون بقية البيانات حقيقية.  لكن هذه ليست مشكلة ، حيث نكتب <b>CDFH</b> بعد جميع البيانات ، والتجزئة مع أطوال البيانات معروفة في أي حال. </p><br><p style=";text-align:right;direction:rtl">  هذا كل شيء ، بالطبع ، جيد.  يبقى فقط للتنفيذ في PHP. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وستساعدنا</a> مكتبة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هاش</a> القياسية.  يمكننا إنشاء سياق تجزئة سيكون فيه كافياً لتعبئة القطع بالبيانات ، وفي النهاية الحصول على قيمة التجزئة.  بالطبع ، سيكون هذا الحل أكثر تعقيدًا إلى حد ما من <i>التجزئة ('crc32b' ، المحتوى $)</i> ، ولكنه سيوفر لنا مجموعة من الموارد والوقت لا يمكن <i>تخيلهما</i> . <br><br>  يبدو شيء مثل هذا: <br><br></p><pre style=";text-align:right;direction:rtl"> <code class="php hljs">$hashCtx = hash_init(<span class="hljs-string"><span class="hljs-string">'crc32b'</span></span>); $handle = fopen($source, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { $chunk = fread($handle, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); hash_update($hashCtx, $chunk); $chunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } $hash = hash_final($hashCtx);</code> </pre> <br>  إذا تم كل شيء بشكل صحيح ، فلن تختلف القيمة على الإطلاق عن <i>hash_file ('crc32b' ،</i> أو <i>$ source)</i> أو <i>hash ('crc32b' ، file_get_content ($ source))</i> . <br><br><p style=";text-align:right;direction:rtl">  دعونا نحاول أن نلف كل هذا بطريقة أو بأخرى في وظيفة واحدة ، حتى نتمكن من قراءة الملف بطريقة مناسبة لنا ، وفي النهاية نحصل على التجزئة والطول.  وسوف تساعدنا المولدات في هذا: <br><br></p><pre style=";text-align:right;direction:rtl"> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $path)</span></span></span><span class="hljs-function">: \</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generator</span></span></span><span class="hljs-function"> </span></span>{ $length = <span class="hljs-number"><span class="hljs-number">0</span></span>; $handle = fopen($path, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); $hashCtx = hash_init(<span class="hljs-string"><span class="hljs-string">'crc32b'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { $chunk = fread($handle, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); $length += strlen($chunk); hash_update($hashCtx, $chunk); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $chunk; $chunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } fclose($handle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'length'</span></span> =&gt; $length, <span class="hljs-string"><span class="hljs-string">'crc32'</span></span> =&gt; hexdec(hash_final($hashCtx))]; }</code> </pre> <br>  والآن يمكننا فقط <br><br><pre style=";text-align:right;direction:rtl"> <code class="php hljs">$reader = read(<span class="hljs-string"><span class="hljs-string">'https://speed.hetzner.de/1GB.bin'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($reader <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $chunk) { <span class="hljs-comment"><span class="hljs-comment">// -   . } //      . ['length' =&gt; $length, 'crc32' =&gt; $crc32] = $reader-&gt;getReturn(); echo round(memory_get_peak_usage(true) / 1024 / 1024, 2) . 'MB - Memory Peak Usage' . PHP_EOL;</span></span></code> </pre> <br>  في رأيي ، الأمر بسيط ومريح للغاية.  مع ملف 1 غيغابايت ، كان الحد الأقصى لاستهلاك الذاكرة 2 ميغابايت. <br><p style=";text-align:right;direction:rtl">  الآن دعونا نحاول تعديل الشفرة من المقالة السابقة حتى نتمكن من استخدام هذه الوظيفة. <br><br></p><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">النصي النهائي</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $path)</span></span></span><span class="hljs-function">: \</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generator</span></span></span><span class="hljs-function"> </span></span>{ $length = <span class="hljs-number"><span class="hljs-number">0</span></span>; $handle = fopen($path, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); $hashCtx = hash_init(<span class="hljs-string"><span class="hljs-string">'crc32b'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { $chunk = fread($handle, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); $length += strlen($chunk); hash_update($hashCtx, $chunk); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $chunk; $chunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } fclose($handle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'length'</span></span> =&gt; $length, <span class="hljs-string"><span class="hljs-string">'crc32'</span></span> =&gt; hexdec(hash_final($hashCtx))]; } $entries = [<span class="hljs-string"><span class="hljs-string">'https://speed.hetzner.de/100MB.bin'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>]; $destination = <span class="hljs-string"><span class="hljs-string">'test.zip'</span></span>; $handle = fopen($destination, <span class="hljs-string"><span class="hljs-string">'w'</span></span>); $written = <span class="hljs-number"><span class="hljs-number">0</span></span>; $dictionary = []; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($entries <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $entry) { $filename = basename($entry); $fileInfo = [ <span class="hljs-string"><span class="hljs-string">'versionToExtract'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-comment"><span class="hljs-comment">//       Data Descriptor,     00008, //   00000    . 'generalPurposeBitFlag' =&gt; 0x0008, 'compressionMethod' =&gt; 0, 'modificationTime' =&gt; 28021, 'modificationDate' =&gt; 20072, 'crc32' =&gt; 0, 'compressedSize' =&gt; 0, 'uncompressedSize' =&gt; 0, 'filenameLength' =&gt; strlen($filename), 'extraFieldLength' =&gt; 0, ]; $LFH = pack('LSSSSSLLLSSa*', ...array_values([ 'signature' =&gt; 0x04034b50, ] + $fileInfo + ['filename' =&gt; $filename])); $fileOffset = $written; $written += fwrite($handle, $LFH); //     $reader = read($entry); foreach ($reader as $chunk) { //      $written += fwrite($handle, $chunk); $chunk = null; } //       ['length' =&gt; $length, 'crc32' =&gt; $crc32] = $reader-&gt;getReturn(); //    fileInfo,     CDFH $fileInfo['crc32'] = $crc32; $fileInfo['compressedSize'] = $length; $fileInfo['uncompressedSize'] = $length; //  Data Descriptor $DD = pack('LLLL', ...array_values([ 'signature' =&gt; 0x08074b50, 'crc32' =&gt; $fileInfo['crc32'], 'compressedSize' =&gt; $fileInfo['compressedSize'], 'uncompressedSize' =&gt; $fileInfo['uncompressedSize'], ])); $written += fwrite($handle, $DD); $dictionary[$filename] = [ 'signature' =&gt; 0x02014b50, 'versionMadeBy' =&gt; 798, ] + $fileInfo + [ 'fileCommentLength' =&gt; 0, 'diskNumber' =&gt; 0, 'internalFileAttributes' =&gt; 0, 'externalFileAttributes' =&gt; 2176057344, 'localFileHeaderOffset' =&gt; $fileOffset, 'filename' =&gt; $filename, ]; } $EOCD = [ 'signature' =&gt; 0x06054b50, 'diskNumber' =&gt; 0, 'startDiskNumber' =&gt; 0, 'numberCentralDirectoryRecord' =&gt; $records = count($dictionary), 'totalCentralDirectoryRecord' =&gt; $records, 'sizeOfCentralDirectory' =&gt; 0, 'centralDirectoryOffset' =&gt; $written, 'commentLength' =&gt; 0 ]; foreach ($dictionary as $entryInfo) { $CDFH = pack('LSSSSSSLLLSSSSSLLa*', ...array_values($entryInfo)); $written += fwrite($handle, $CDFH); } $EOCD['sizeOfCentralDirectory'] = $written - $EOCD['centralDirectoryOffset']; $EOCD = pack('LSSSSLLS', ...array_values($EOCD)); $written += fwrite($handle, $EOCD); fclose($handle); echo '  : ' . memory_get_peak_usage(true) . ' ' . PHP_EOL; echo '  : ' . $written . ' ' . PHP_EOL; echo '   `unzip -tq ' . $destination . '`: ' . PHP_EOL; echo '&gt; ' . exec('unzip -tq ' . $destination) . PHP_EOL; echo PHP_EOL;</span></span></code> </pre> <br></div></div><br>  في الخرج ، يجب أن نحصل على أرشيف مضغوط باسم test.zip ، سيكون فيه ملف به البرنامج النصي أعلاه و 100 MB.bin ، بحجم حوالي 100 ميغابايت. <br><br><h3 style=";text-align:right;direction:rtl">  ضغط في الرمز البريدي المحفوظات </h3><br><p style=";text-align:right;direction:rtl">  الآن لدينا كل شيء تقريبًا لضغط البيانات والقيام بذلك أيضًا أثناء الطيران. <br>  تمامًا كما حصلنا على علامة تجزئة عن طريق إعطاء مجموعات صغيرة للوظائف ، يمكننا أيضًا ضغط البيانات بفضل مكتبة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Zlib</a> الرائعة <i>ووظائف deflate_init</i> و <i>deflate_add الخاصة بها</i> . </p><br><p style=";text-align:right;direction:rtl">  يبدو شيء مثل هذا: <br><br></p><pre style=";text-align:right;direction:rtl"> <code class="php hljs">$deflateCtx = deflate_init(ZLIB_ENCODING_RAW, [<span class="hljs-string"><span class="hljs-string">'level'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>]); $handle = fopen($source, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { $chunk = fread($handle, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deflate_add($deflateCtx, $chunk, feof($handle) ? ZLIB_FINISH : ZLIB_SYNC_FLUSH); $chunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  <i>لقد قابلت خيارًا كهذا ، مقارنةً بالخيار السابق ، سيضيف بعض الأصفار في النهاية.</i> <div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">المفسد العنوان</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deflate_add($deflateCtx, $chunk, ZLIB_SYNC_FLUSH); } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> deflate_add($deflateCtx, <span class="hljs-string"><span class="hljs-string">''</span></span>, ZLIB_FINISH);</code> </pre> <br></div></div>  <i>ولكن بفك أقسم ، لذلك اضطررت للتخلص من هذا التبسيط.</i> <br><br><p style=";text-align:right;direction:rtl">  دعنا نصلح <i>القارئ الخاص</i> بنا حتى يقوم بضغط بياناتنا على الفور ، وفي النهاية يعيدنا التجزئة ، وطول البيانات دون ضغط وطول البيانات مع الضغط: <br><br></p><pre style=";text-align:right;direction:rtl"> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $path)</span></span></span><span class="hljs-function">: \</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generator</span></span></span><span class="hljs-function"> </span></span>{ $uncompressedSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; $compressedSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; $hashCtx = hash_init(<span class="hljs-string"><span class="hljs-string">'crc32b'</span></span>); $deflateCtx = deflate_init(ZLIB_ENCODING_RAW, [<span class="hljs-string"><span class="hljs-string">'level'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>]); $handle = fopen($path, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { $chunk = fread($handle, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); hash_update($hashCtx, $chunk); $compressedChunk = deflate_add($deflateCtx, $chunk, feof($handle) ? ZLIB_FINISH : ZLIB_SYNC_FLUSH); $uncompressedSize += strlen($chunk); $compressedSize += strlen($compressedChunk); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $compressedChunk; $chunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; $compressedChunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } fclose($handle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'uncompressedSize'</span></span> =&gt; $uncompressedSize, <span class="hljs-string"><span class="hljs-string">'compressedSize'</span></span> =&gt; $compressedSize, <span class="hljs-string"><span class="hljs-string">'crc32'</span></span> =&gt; hexdec(hash_final($hashCtx)) ]; }</code> </pre> <br>  وحاول على ملف 100 ميغابايت: <br><br><pre style=";text-align:right;direction:rtl"> <code class="php hljs">$reader = read(<span class="hljs-string"><span class="hljs-string">'https://speed.hetzner.de/100MB.bin'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($reader <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $chunk) { <span class="hljs-comment"><span class="hljs-comment">// -   . } ['uncompressedSize' =&gt; $uncompressedSize, 'compressedSize' =&gt; $compressedSize, 'crc32' =&gt; $crc32] = $reader-&gt;getReturn(); echo 'Uncompressed size: ' . $uncompressedSize . PHP_EOL; echo 'Compressed size: ' . $compressedSize . PHP_EOL; echo round(memory_get_peak_usage(true) / 1024 / 1024, 2) . 'MB - Memory Peak Usage' . PHP_EOL;</span></span></code> </pre> <br>  لا يزال استهلاك الذاكرة يدل على أننا لم نقم بتحميل الملف بأكمله في الذاكرة. <br><br><p style=";text-align:right;direction:rtl">  دعنا نجمع كل شيء معًا وأخيراً احصل على أرشيف نص حقيقي بالفعل. <br>  على عكس الإصدار السابق ، <b>سيتغير generalPurposeBitFlag</b> - الآن تبلغ قيمته <b>0x0018</b> ، وكذلك <b>compressionMethod</b> - <b>8</b> (مما يعني <b>Deflate</b> ). <br><br></p><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">النصي النهائي</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $path)</span></span></span><span class="hljs-function">: \</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generator</span></span></span><span class="hljs-function"> </span></span>{ $uncompressedSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; $compressedSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; $hashCtx = hash_init(<span class="hljs-string"><span class="hljs-string">'crc32b'</span></span>); $deflateCtx = deflate_init(ZLIB_ENCODING_RAW, [<span class="hljs-string"><span class="hljs-string">'level'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>]); $handle = fopen($path, <span class="hljs-string"><span class="hljs-string">'r'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!feof($handle)) { $chunk = fread($handle, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); hash_update($hashCtx, $chunk); $compressedChunk = deflate_add($deflateCtx, $chunk, feof($handle) ? ZLIB_FINISH : ZLIB_SYNC_FLUSH); $uncompressedSize += strlen($chunk); $compressedSize += strlen($compressedChunk); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> $compressedChunk; $chunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; $compressedChunk = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } fclose($handle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-string"><span class="hljs-string">'uncompressedSize'</span></span> =&gt; $uncompressedSize, <span class="hljs-string"><span class="hljs-string">'compressedSize'</span></span> =&gt; $compressedSize, <span class="hljs-string"><span class="hljs-string">'crc32'</span></span> =&gt; hexdec(hash_final($hashCtx)) ]; } $entries = [<span class="hljs-string"><span class="hljs-string">'https://speed.hetzner.de/100MB.bin'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">__FILE__</span></span>]; $destination = <span class="hljs-string"><span class="hljs-string">'test.zip'</span></span>; $handle = fopen($destination, <span class="hljs-string"><span class="hljs-string">'w'</span></span>); $written = <span class="hljs-number"><span class="hljs-number">0</span></span>; $dictionary = []; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($entries <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $entry) { $filename = basename($entry); $fileInfo = [ <span class="hljs-string"><span class="hljs-string">'versionToExtract'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   ,        0x0018  0x0008 'generalPurposeBitFlag' =&gt; 0x0018, 'compressionMethod' =&gt; 8, //      : 8 - Deflate 'modificationTime' =&gt; 28021, 'modificationDate' =&gt; 20072, 'crc32' =&gt; 0, 'compressedSize' =&gt; 0, 'uncompressedSize' =&gt; 0, 'filenameLength' =&gt; strlen($filename), 'extraFieldLength' =&gt; 0, ]; $LFH = pack('LSSSSSLLLSSa*', ...array_values([ 'signature' =&gt; 0x04034b50, ] + $fileInfo + ['filename' =&gt; $filename])); $fileOffset = $written; $written += fwrite($handle, $LFH); $reader = read($entry); foreach ($reader as $chunk) { $written += fwrite($handle, $chunk); $chunk = null; } [ 'uncompressedSize' =&gt; $uncompressedSize, 'compressedSize' =&gt; $compressedSize, 'crc32' =&gt; $crc32 ] = $reader-&gt;getReturn(); $fileInfo['crc32'] = $crc32; $fileInfo['compressedSize'] = $compressedSize; $fileInfo['uncompressedSize'] = $uncompressedSize; $DD = pack('LLLL', ...array_values([ 'signature' =&gt; 0x08074b50, 'crc32' =&gt; $fileInfo['crc32'], 'compressedSize' =&gt; $fileInfo['compressedSize'], 'uncompressedSize' =&gt; $fileInfo['uncompressedSize'], ])); $written += fwrite($handle, $DD); $dictionary[$filename] = [ 'signature' =&gt; 0x02014b50, 'versionMadeBy' =&gt; 798, ] + $fileInfo + [ 'fileCommentLength' =&gt; 0, 'diskNumber' =&gt; 0, 'internalFileAttributes' =&gt; 0, 'externalFileAttributes' =&gt; 2176057344, 'localFileHeaderOffset' =&gt; $fileOffset, 'filename' =&gt; $filename, ]; } $EOCD = [ 'signature' =&gt; 0x06054b50, 'diskNumber' =&gt; 0, 'startDiskNumber' =&gt; 0, 'numberCentralDirectoryRecord' =&gt; $records = count($dictionary), 'totalCentralDirectoryRecord' =&gt; $records, 'sizeOfCentralDirectory' =&gt; 0, 'centralDirectoryOffset' =&gt; $written, 'commentLength' =&gt; 0 ]; foreach ($dictionary as $entryInfo) { $CDFH = pack('LSSSSSSLLLSSSSSLLa*', ...array_values($entryInfo)); $written += fwrite($handle, $CDFH); } $EOCD['sizeOfCentralDirectory'] = $written - $EOCD['centralDirectoryOffset']; $EOCD = pack('LSSSSLLS', ...array_values($EOCD)); $written += fwrite($handle, $EOCD); fclose($handle); echo '  : ' . memory_get_peak_usage(true) . ' ' . PHP_EOL; echo '  : ' . $written . ' ' . PHP_EOL; echo '   `unzip -tq ' . $destination . '`: ' . PHP_EOL; echo '&gt; ' . exec('unzip -tq ' . $destination) . PHP_EOL; echo PHP_EOL;</span></span></code> </pre> </div></div><br>  نتيجةً لذلك ، حصلت على أرشيف بحجم 360183 بايت (تم ضغط ملفنا البالغ 100 ميجابايت بشكل جيد للغاية ، والذي على الأرجح مجرد مجموعة من وحدات البايت المتطابقة) ، وأظهر <i>unzip</i> عدم وجود أخطاء في الأرشيف. <br><br><h3 style=";text-align:right;direction:rtl">  استنتاج </h3><br><p style=";text-align:right;direction:rtl">  إذا كان لدي ما يكفي من الطاقة والوقت لمقال آخر ، فسأحاول توضيح كيف ، والأهم من ذلك ، لماذا يمكن استخدام كل هذا. <br><br>  إذا كنت مهتمًا بأي شيء آخر حول هذا الموضوع - اقترح في التعليقات ، سأحاول إعطاء إجابة لسؤالك.  على الأرجح لن نتعامل مع التشفير ، لأن البرنامج النصي قد نما بالفعل ، وفي الواقع ، لا تستخدم هذه المحفوظات في كثير من الأحيان. </p><br><br><p style=";text-align:right;direction:rtl">  شكرا لاهتمامكم وتعليقاتكم. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar472966/">https://habr.com/ru/post/ar472966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar472956/index.html">تاريخ بناء روبوت كاتربيلر</a></li>
<li><a href="../ar472958/index.html">كيفية إنشاء برامج ويندوز في اردوينو</a></li>
<li><a href="../ar472960/index.html">أفضل سعر عدسة / جودة سوني</a></li>
<li><a href="../ar472962/index.html">نشر الفيديو: التجارب كشكل من أشكال التصور العلمي</a></li>
<li><a href="../ar472964/index.html">الموقف: المزيد والمزيد من الشركات مفتوحة المصدر تقوم بتغيير التراخيص - نناقش آراء الخبراء</a></li>
<li><a href="../ar472970/index.html">نقد بروتوكول Telegram والمناهج التنظيمية. الجزء 1 ، التقنية: تجربة كتابة عميل من الصفر - TL ، MT</a></li>
<li><a href="../ar472972/index.html">نحن نعمل مع ملفات تعريف الارتباط كصف جافا سكريبت</a></li>
<li><a href="../ar472978/index.html">تأليف اردوينو بالطبع لابنه</a></li>
<li><a href="../ar472980/index.html">السراويل Belokamentseva</a></li>
<li><a href="../ar472982/index.html">"استمع لإيجاد انهيار": نشر التسجيلات الصوتية للآلات الصناعية الفاشلة</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>