<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíí ‚ùî üèóÔ∏è Futex Basics ‚ò¢Ô∏è üê± ‚ô£Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Futex (futex - abrevia√ß√£o de "Fast userspace mutex") √© um mecanismo proposto pelos desenvolvedores Linux da IBM em 2002 e entrou no kernel no final de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Futex Basics</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/418705/">  Futex (futex - abrevia√ß√£o de "Fast userspace mutex") √© um mecanismo proposto pelos desenvolvedores Linux da IBM em 2002 e entrou no kernel no final de 2003.  A id√©ia principal era fornecer uma maneira mais eficiente de sincronizar os threads do usu√°rio com um n√∫mero m√≠nimo de chamadas para o kernel do SO. <br><br>  Neste artigo, revisaremos os futexes, tentaremos entender os princ√≠pios de seu trabalho e tamb√©m us√°-los como tijolos para criar objetos de sincroniza√ß√£o de n√≠vel superior (e familiares para n√≥s). <br><br>  Um ponto importante: os futexes s√£o uma ferramenta de baixo n√≠vel; vale a pena us√°-la diretamente apenas no desenvolvimento de bibliotecas fundamentais, como a biblioteca C / C ++ padr√£o.  √â muito improv√°vel que voc√™ precise usar futex em um aplicativo regular. <br><a name="habracut"></a><br><h3>  Motiva√ß√£o </h3><br>  Antes do advento dos futexes, era necess√°rio fazer chamadas do sistema (usando, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">semop</a> ) cada vez para controlar o acesso a recursos compartilhados de v√°rios encadeamentos, o que, como voc√™ sabe, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">consome</a> muitos recursos, pois cada chamada requer a altern√¢ncia do contexto do modo de usu√°rio para o modo kernel.  Com o aumento do n√∫mero de n√∫cleos nos processadores modernos e o aumento do n√∫mero de threads no software aplicativo, isso se tornou um problema significativo.  √â ainda mais "ofensivo", uma vez que todas essas chamadas n√£o possuem nenhuma fun√ß√£o aplicada, n√£o implementam nenhuma l√≥gica comercial, mas apenas garantem a opera√ß√£o correta do restante do c√≥digo. <br><br>  A proposta de adicionar um novo conceito de "futex" ao sistema operacional foi baseada em uma observa√ß√£o simples: na maioria dos casos, uma tentativa de capturar um objeto de sincroniza√ß√£o √© bem-sucedida pela primeira vez.  Os programadores escrevem o software de maneira que o menor tempo poss√≠vel passe do bloqueio de um bloqueio para o desbloqueio, o que significa que h√° chances muito altas de que uma tentativa de capturar outro thread n√£o encontre obst√°culos.  Quando um fluxo atinge um objeto de sincroniza√ß√£o "livre", podemos captur√°-lo sem fazer uma chamada do sistema usando opera√ß√µes at√¥micas relativamente baratas.  E h√° uma chance muito grande de que a opera√ß√£o at√¥mica funcione com sucesso. <br><br>  Nesse caso raro, quando ainda tentamos acessar um recurso bloqueado por outro encadeamento, uma opera√ß√£o at√¥mica retornar√° um erro.  Nesse caso, temos duas op√ß√µes.  Podemos girar em algum bloqueio de rota√ß√£o do modo de usu√°rio, aguardando a libera√ß√£o do recurso (que consumir√° os recursos da CPU) ou pedir ao kernel que nos coloque no modo de suspens√£o, aguardando a libera√ß√£o do recurso.  √â aqui que os futexes entram em cena. <br><br><h3>  Uso simples de futexes - expectativa e despertar </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A chamada do sistema futex</a> combina uma variedade de funcionalidades.  N√£o consideraremos op√ß√µes complexas aqui (algumas delas s√£o t√£o elaboradas que nem s√£o descritas na documenta√ß√£o oficial), mas focamos nas opera√ß√µes FUTEX_WAIT e FUTEX_WAKE.  A descri√ß√£o na documenta√ß√£o oficial servir√° como uma boa base: <br><blockquote>  A chamada do sistema futex () fornece aos programas um m√©todo para aguardar que uma determinada condi√ß√£o se torne verdadeira.  Normalmente, essa chamada do sistema usa uma constru√ß√£o de bloqueio no contexto da sincroniza√ß√£o de mem√≥ria compartilhada.  Ao usar futexes, as principais opera√ß√µes de sincroniza√ß√£o s√£o executadas no espa√ßo do usu√°rio.  Os programas de espa√ßo do usu√°rio executam a chamada do sistema futex () somente quando for necess√°rio que o programa entre no modo de espera por um longo tempo at√© que a condi√ß√£o se torne verdadeira.  Al√©m disso, futex () pode ser usado para ativar processos ou threads que esperam uma condi√ß√£o espec√≠fica. </blockquote>  Simplificando, um futex √© uma constru√ß√£o do kernel que ajuda o c√≥digo do usu√°rio a sincronizar threads quando algo acontece.  Alguns processos (ou threads) podem aguardar eventos em uma chamada FUTEX_WAIT, enquanto outros podem chamar esses eventos com FUTEX_WAKE.  A espera funciona de maneira eficiente - os threads em espera s√£o suspensos pelo kernel e n√£o usam os recursos do processador at√© serem despertados quando ocorre um evento esperado. <br><br>  Aproveite o tempo para ler a documenta√ß√£o na √≠ntegra.  Bem, ou pelo menos leia as se√ß√µes sobre FUTEX_WAIT e FUTEX_WAKE. <br><br>  Vejamos um <a href="">exemplo simples</a> que demonstra o uso b√°sico de futexes para coordenar o trabalho de dois processos. <br><br>  Processo filho: <br><br><ol><li>  Aguarda 0xA no slot de mem√≥ria geral </li><li>  Grava o valor 0xB nesse slot </li></ol><br>  Processo pai no momento: <br><br><ol><li>  Grava um valor 0xA em um slot de mem√≥ria compartilhada </li><li>  Aguarda 0xB aparecer nele </li></ol><br>  Tal "aperto de m√£o" entre dois processos.  Aqui est√° o c√≥digo: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shm_id = shmget(IPC_PRIVATE, <span class="hljs-number"><span class="hljs-number">4096</span></span>, IPC_CREAT | <span class="hljs-number"><span class="hljs-number">0666</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shm_id &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"shmget"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* shared_data = shmat(shm_id, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); *shared_data = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> forkstatus = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forkstatus == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   printf("child waiting for A\n"); wait_on_futex_value(shared_data, 0xA); printf("child writing B\n"); //  0xB         *shared_data = 0xB; wake_futex_blocking(shared_data); } else { //   printf("parent writing A\n"); //  0xA         *shared_data = 0xA; wake_futex_blocking(shared_data); printf("parent waiting for B\n"); wait_on_futex_value(shared_data, 0xB); // Wait for the child to terminate. wait(NULL); shmdt(shared_data); } return 0; }</span></span></code> </pre> <br>  Preste aten√ß√£o √†s chamadas POSIX para alocar mem√≥ria compartilhada entre processos.  N√£o foi poss√≠vel usar a aloca√ß√£o de mem√≥ria usual aqui, pois mesmo o mesmo endere√ßo de ponteiros em diferentes processos apontaria para diferentes blocos de mem√≥ria (exclusivos para cada processo). <br><br>  Deve-se notar que este exemplo se desvia um pouco dos c√¢nones, porque o futex foi originalmente criado para aguardar uma mudan√ßa em um determinado significado "de algo espec√≠fico para qualquer coisa" e n√£o "de algo para algo espec√≠fico".  Dei esse exemplo para demonstrar essa possibilidade e, a seguir, consideraremos a vers√£o b√°sica (nela implementamos o mutex). <br><br>  E aqui est√° o c√≥digo da fun√ß√£o wait_on_futex_value: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait_on_futex_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAIT, val, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno != EAGAIN) { perror(<span class="hljs-string"><span class="hljs-string">"futex"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*futex_addr == val) { <span class="hljs-comment"><span class="hljs-comment">//    return; } } else { abort(); } } }</span></span></code> </pre> <br>  A principal tarefa dessa fun√ß√£o (al√©m, na verdade, da chamada do sistema futex) √© um ciclo no qual executamos quando acordamos falsos (n√£o estamos interessados ‚Äã‚Äãem n√≥s).  Isso pode acontecer quando um novo valor, mas n√£o o esperado por n√≥s, √© instalado no slot de mem√≥ria compartilhada.  Bem, ou no caso em que outro processo foi despertado antes do nosso (isso n√£o pode acontecer no nosso caso particular, mas de uma maneira mais geral √© poss√≠vel). <br><br>  A sem√¢ntica do Futex √© algo bastante complicado!  A chamada FUTEX_WAIT retornar√° imediatamente se o valor no endere√ßo futex n√£o for igual ao argumento passado val.  No nosso caso, isso pode acontecer se o processo filho for aguardar antes que o pai escreva o valor 0xA no slot.  O futex nesse caso retorna o valor EAGAIN. <br><br>  E aqui est√° o c√≥digo da fun√ß√£o wake_futex_blocking: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wake_futex_blocking</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* futex_addr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(futex_addr, FUTEX_WAKE, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"futex wake"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } }</code> </pre> <br>  Este √© um inv√≥lucro de bloqueio sobre FUTEX_WAKE que rapidamente funcionar√° e retornar√° um valor, n√£o importa quantos ouvintes esperem.  No nosso exemplo, isso √© usado como parte de um "aperto de m√£o", mas outros usos s√£o poss√≠veis. <br><br><h3>  Futex s√£o filas do kernel para c√≥digo personalizado. </h3><br>  Simplificando, um futex √© uma fila orientada por kernel para resolver tarefas de c√≥digo personalizadas.  Ele permite que o c√≥digo do usu√°rio solicite ao kernel que suspenda a execu√ß√£o de seu thread at√© que um evento ocorra, e ao outro thread ao mesmo tempo para sinalizar esse evento e ativar todos os threads que o aguardam.  Mencionamos anteriormente a capacidade de organizar um bloqueio de rota√ß√£o no modo de usu√°rio, aguardando que alguma condi√ß√£o fosse atendida.  No entanto, a fila no kernel √© uma alternativa muito melhor, pois nos salva de bilh√µes de instru√ß√µes desperdi√ßadas do processador executadas em um loop de espera. <br><br>  Aqui est√° o diagrama do artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Uma vis√£o geral e atualiza√ß√£o do futex"</a> no LWN: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/476/433/d4e/476433d4e5a9ba7dcd840a7fe5eb3d87.png" alt="imagem"><br><br>  No c√≥digo do kernel do Linux, os futexes s√£o implementados no arquivo kernel / futex.c.  O kernel armazena uma tabela de hash onde as chaves s√£o endere√ßos - para encontrar rapidamente a fila desejada e adicionar o processo de chamada a ela.  Tudo, √© claro, n√£o √© t√£o simples - afinal, o pr√≥prio kernel precisa sincronizar o acesso aos dados internos, al√©m de suportar todo tipo de op√ß√µes adicionais para o futeksov. <br><br><h3>  Espera por tempo limitado com FUTEX_WAIT </h3><br>  A chamada do sistema futex possui um par√¢metro de tempo limite que permite ao usu√°rio especificar quanto tempo est√° pronto para aguardar.  Aqui est√° um <a href="">exemplo</a> completo em que isso √© implementado, mas aqui est√° a parte principal: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child waiting for A\n"</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout</span></span></span><span class="hljs-class"> = {</span></span>.tv_sec = <span class="hljs-number"><span class="hljs-number">0</span></span>, .tv_nsec = <span class="hljs-number"><span class="hljs-number">500000000</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> t1 = time_ns(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> futex_rc = futex(shared_data, FUTEX_WAIT, <span class="hljs-number"><span class="hljs-number">0xA</span></span>, &amp;timeout, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"child woken up rc=%d errno=%s, elapsed=%llu\n"</span></span>, futex_rc, futex_rc ? strerror(errno) : <span class="hljs-string"><span class="hljs-string">""</span></span>, time_ns() - t1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (futex_rc == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; *shared_data == <span class="hljs-number"><span class="hljs-number">0xA</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br>  Se a espera for atrasada em 500 ms, a fun√ß√£o futex ser√° encerrada e, na pr√≥xima itera√ß√£o do loop, podemos responder de alguma forma a isso (exibir algo na tela, gravar no log, continuar a espera ou parar). <br><br><h3>  Usando um futex para implementar um mutex </h3><br>  Iniciamos este artigo com o fato de que futexes s√£o √∫teis na implementa√ß√£o de objetos de sincroniza√ß√£o de n√≠vel superior.  Vamos tentar us√°-los (assim como os √°tomos) para implementar o mutex cl√°ssico.  A implementa√ß√£o abaixo √© baseada no c√≥digo do artigo "Futexes s√£o complicados", escrito por Ulrich Drepper. <br><br>  Neste exemplo, eu uso o C ++, principalmente pela capacidade de usar at√¥micos do padr√£o C ++ 11.  Voc√™ pode encontrar o c√≥digo completo <a href="">aqui</a> , mas a parte mais importante √©: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() : atom_(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = cmpxchg(&amp;atom_, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// If the lock was previously unlocked, there's nothing else for us to do. // Otherwise, we'll probably have to wait. if (c != 0) { do { // If the mutex is locked, we signal that we're waiting by setting the // atom to 2. A shortcut checks is it's 2 already and avoids the atomic // operation in this case. if (c == 2 || cmpxchg(&amp;atom_, 1, 2) != 0) { // Here we have to actually sleep, because the mutex is actually // locked. Note that it's not necessary to loop around this syscall; // a spurious wakeup will do no harm since we only exit the do...while // loop when atom_ is indeed 0. syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAIT, 2, 0, 0, 0); } // We're here when either: // (a) the mutex was in fact unlocked (by an intervening thread). // (b) we slept waiting for the atom and were awoken. // // So we try to lock the atom again. We set teh state to 2 because we // can't be certain there's no other thread at this exact point. So we // prefer to err on the safe side. } while ((c = cmpxchg(&amp;atom_, 0, 2)) != 0); } } void unlock() { if (atom_.fetch_sub(1) != 1) { atom_.store(0); syscall(SYS_futex, (int*)&amp;atom_, FUTEX_WAKE, 1, 0, 0, 0); } } private: // 0 means unlocked // 1 means locked, no waiters // 2 means locked, there are waiters in lock() std::atomic&lt;int&gt; atom_; };</span></span></code> </pre><br>  Nesse c√≥digo, a fun√ß√£o cmpxhg √© um inv√≥lucro simples para um uso mais conveniente dos √°tomos: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An atomic_compare_exchange wrapper with semantics expected by the paper's // mutex - return the old value stored in the atom. int cmpxchg(std::atomic&lt;int&gt;* atom, int expected, int desired) { int* ep = &amp;expected; std::atomic_compare_exchange_strong(atom, ep, desired); return *ep; }</span></span></code> </pre> <br>  Este exemplo de c√≥digo cont√©m muitos coment√°rios explicando a l√≥gica de sua opera√ß√£o.  Isso n√£o vai doer, porque h√° um risco significativo de que voc√™ queira escrever uma vers√£o um pouco mais simples, mas completamente incorreta.  Quanto a este c√≥digo - tamb√©m n√£o √© perfeito em tudo.  Por exemplo, ele tenta fazer uma suposi√ß√£o sobre um dispositivo interno do tipo std :: atomic, convertendo seu conte√∫do em int * para passar para a chamada futex.  Geralmente n√£o √© esse o caso.  O c√≥digo compila e roda no Linux x64, mas n√£o temos garantia de compatibilidade com outras plataformas.  Para obt√™-lo, precisamos adicionar uma camada de depend√™ncia de plataforma para √°tomos.  Como esse n√£o √© o t√≥pico deste artigo (e tamb√©m porque √© muito improv√°vel que voc√™ misture futexes em um m√≥dulo C ++), omitimos essa implementa√ß√£o.  Isto √© apenas uma demonstra√ß√£o! <br><br><h3>  Mutexes Glibc e bloqueios de baixo n√≠vel </h3><br>  Ent√£o chegamos ao ponto em que o glibc implementa threads POSIX, parte do qual √© o tipo pthread_mutex_t.  Como eu disse no come√ßo deste artigo, o futex n√£o √© exatamente o que um desenvolvedor comum precisar√°.  Eles s√£o usados ‚Äã‚Äãpor bibliotecas de tempo de execu√ß√£o ou algo altamente especializado para implementar primitivas de sincroniza√ß√£o de n√≠vel superior.  Nesse contexto, √© interessante observar a implementa√ß√£o do mutex para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NPTL</a> .  No c√≥digo glibc, esse √© o arquivo nptl / pthread_mutex_lock.c. <br><br>  O c√≥digo √© bastante complicado devido √† necessidade de suportar v√°rios tipos de mutexes, mas podemos encontrar blocos bastante familiares, se desejado.  Voc√™ tamb√©m pode dar uma olhada nos arquivos sysdeps / unix / sysv / linux / x86_64 / lowlevellock.he nptl / lowlevellock.c.  O c√≥digo √© um pouco confuso, mas ainda √© f√°cil a combina√ß√£o de chamadas de compara√ß√£o e troca e de futex. <br><br>  O coment√°rio inicial do arquivo systeds / nptl / lowlevellock.h j√° deve ser bem entendido por voc√™: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Low-level locks use a combination of atomic operations (to acquire and release lock ownership) and futex operations (to block until the state of a lock changes). A lock can be in one of three states: 0: not acquired, 1: acquired with no waiters; no other threads are blocked or about to block for changes to the lock state, &gt;1: acquired, possibly with waiters; there may be other threads blocked or about to block for changes to the lock state. We expect that the common case is an uncontended lock, so we just need to transition the lock between states 0 and 1; releasing the lock does not need to wake any other blocked threads. If the lock is contended and a thread decides to block using a futex operation, then this thread needs to first change the state to &gt;1; if this state is observed during lock release, the releasing thread will wake one of the potentially blocked threads. .. */</span></span></code> </pre> <br><h3>  Ir para futexes de tempo de execu√ß√£o </h3><br>  O Rantime Go n√£o usa libc (na maioria dos casos).  Portanto, ele n√£o pode confiar na implementa√ß√£o de encadeamentos POSIX.  Em vez disso, ele chama diretamente chamadas de sistema de n√≠vel inferior.  Isso o torna um bom exemplo do uso de futexes.  Como n√£o h√° como chamar pthread_mutex_t, voc√™ deve escrever sua pr√≥pria substitui√ß√£o.  Vamos ver como isso √© feito, vamos come√ßar com o tipo sync.Mutex vis√≠vel para o usu√°rio (em src / sync / mutex.go). <br><br>  O m√©todo Lock desse tipo tenta usar a opera√ß√£o de troca at√¥mica para capturar rapidamente o bloqueio.  Se voc√™ precisar esperar, chama runtime_SemacquireMutex, que chama runtime.lock.  Essa fun√ß√£o √© definida em src / runtime / lock_futex.go e declara v√°rias constantes que podem lhe parecer familiares: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( mutex_unlocked = <span class="hljs-number"><span class="hljs-number">0</span></span> mutex_locked = <span class="hljs-number"><span class="hljs-number">1</span></span> mutex_sleeping = <span class="hljs-number"><span class="hljs-number">2</span></span> ... ) <span class="hljs-comment"><span class="hljs-comment">// Possible lock states are mutex_unlocked, mutex_locked and mutex_sleeping. // mutex_sleeping means that there is presumably at least one sleeping thread.</span></span></code> </pre><br>  O runtime.lock tamb√©m est√° tentando capturar o bloqueio usando uma fun√ß√£o at√¥mica.  Isso faz sentido, j√° que runtime.lock √© chamado em muitos locais do tempo de execu√ß√£o Go, mas parece-me que seria poss√≠vel otimizar o c√≥digo removendo duas chamadas consecutivas da fun√ß√£o at√¥mica ao chamar runtime.lock do Mutex.lock. <br><br>  Se voc√™ precisar esperar, a fun√ß√£o dependente da plataforma futexsleep ser√° chamada, definida para Linux no arquivo src / runtime / os_linux.go.  Essa fun√ß√£o faz uma chamada de sistema futex com o c√≥digo FUTEX_WAIT_PRIVATE (neste caso, isso √© adequado, pois o tempo de execu√ß√£o do Go fica em um processo). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418705/">https://habr.com/ru/post/pt418705/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418691/index.html">Rancheiro: Kubernetes em 5 minutos em bare metal</a></li>
<li><a href="../pt418693/index.html">Por que a felicidade √© t√£o dif√≠cil de detectar no c√©rebro</a></li>
<li><a href="../pt418695/index.html">Guerras antipirataria - O imp√©rio contra-ataca</a></li>
<li><a href="../pt418699/index.html">Criando uma m√°quina de arcade emulador. Parte 3</a></li>
<li><a href="../pt418701/index.html">Estudamos analisadores sint√°ticos para o idioma russo</a></li>
<li><a href="../pt418707/index.html">KDispatcher - Eventbus leve e conveniente para o uso di√°rio</a></li>
<li><a href="../pt418709/index.html">Precisa se for√ßar: drivers e barreiras de interface</a></li>
<li><a href="../pt418711/index.html">Registros gerenciados por token 1.0</a></li>
<li><a href="../pt418713/index.html">Jogo para melhorar a qualidade da Wikipedia</a></li>
<li><a href="../pt418715/index.html">Qual a efici√™ncia do sistema de arquivos virtual procfs e √© poss√≠vel otimiz√°-lo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>