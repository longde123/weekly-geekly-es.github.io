<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❇️ 👵🏻 🌹 Théorie du sharding 🌱 🤘🏿 👼🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il semble que nous soyons si profondément immergés dans la jungle du développement à haute charge que nous ne pensons tout simplement pas aux problème...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Théorie du sharding</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433370/">  Il semble que nous soyons si profondément immergés dans la jungle du développement à haute charge que nous ne pensons tout simplement pas aux problèmes de base.  Prenez, par exemple, le sharding.  Que comprendre s'il est possible d'écrire conditionnellement shards = n dans les paramètres de la base de données et que tout sera fait par lui-même.  C'est vrai, il l'est, mais si, plutôt, quand quelque chose tourne mal, les ressources commencent vraiment à être rares, j'aimerais comprendre quelle est la raison et comment y remédier. <br><br>  En bref, si vous apportiez votre implémentation alternative de hachage dans Cassandra, alors il n'y a pratiquement aucune révélation pour vous.  Mais si la charge de vos services arrive déjà et que la connaissance du système ne suit pas, vous êtes le bienvenu.  Le grand et terrible <strong>Andrei Aksyonov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">shodan</a> ) à sa manière habituelle dira que le <strong>partage est mauvais, pas le partage est également mauvais</strong> , et comment il est organisé à l'intérieur.  Et tout à fait par accident, l'une des parties de l'histoire du sharding ne concerne pas vraiment le sharding du tout, mais le diable sait quoi - comment mapper des objets sur des fragments. <br><img src="https://habrastorage.org/webt/c9/ju/s6/c9jus6tadexnz4aih4q95bl7ega.jpeg"><br>  La photo des phoques (même s'ils se sont avérés accidentellement être des chiots) semble déjà répondre à la question de savoir pourquoi c'est tout, mais commençons dans l'ordre. <br><a name="habracut"></a><br><h2>  Qu'est-ce que le sharding? <br></h2><br>  Si vous google persistante, il se trouve qu'il existe une frontière assez floue entre le soi-disant partitionnement et le soi-disant sharding.  Tout le monde appelle tout ce qu'il veut que ce qu'il veut.  Certaines personnes distinguent le partitionnement horizontal et le partitionnement.  D'autres disent que le sharding est un certain type de partitionnement horizontal. <br><br>  Je n'ai trouvé aucune norme terminologique qui serait approuvée par les pères fondateurs et certifiée ISO.  Une croyance intérieure personnelle est quelque chose comme ceci: Le <strong>partitionnement,</strong> en moyenne, «coupe la base en morceaux» de manière arbitraire. <br><br><ul><li>  Cloisonnement <strong>vertical</strong>  Par exemple, il y a un tableau géant avec quelques milliards d'entrées dans 60 colonnes.  Au lieu de tenir une telle table gigantesque, nous gardons 60 tables non moins gigantesques avec 2 milliards d'enregistrements chacune - et ce n'est pas une base de données à temps partiel, mais un partitionnement vertical (comme un exemple de terminologie). <br></li><li>  Partitionnement <strong>horizontal</strong> - nous coupons ligne par ligne, peut-être à l'intérieur du serveur. <br></li></ul><br>  Le moment gênant ici est la différence subtile entre le partitionnement horizontal et le sharding.  Vous pouvez me couper en morceaux, mais je ne vous dirai pas avec certitude de quoi il s'agit.  On a le sentiment que le partage et le partitionnement horizontal sont à peu près la même chose. <br><br>  Le sharding est en général lorsqu'une grande table en termes de bases de données ou d'une collection de documents, d'objets, si vous n'avez pas de base de données, mais un magasin de documents, est coupée spécifiquement pour les objets.  Autrement dit, des pièces de 2 milliards d'objets sont sélectionnées, quelle que soit leur taille.  Les objets eux-mêmes à l'intérieur de chaque objet ne sont pas coupés en morceaux, nous ne nous décomposons pas en colonnes distinctes, à savoir, nous disposons des faisceaux à différents endroits. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xx_Lv1P_X_I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien</a> vers la présentation pour l'exhaustivité.</i> <br><br>  De subtiles différences terminologiques ont déjà persisté.  Par exemple, relativement parlant, les développeurs de Postgres peuvent dire que le partitionnement horizontal se produit lorsque toutes les tables dans lesquelles la table principale est divisée se trouvent dans le même schéma, et lorsque sur des machines différentes, il est partitionné. <br><br>  Dans un sens général, sans être lié à la terminologie d'une base de données spécifique et d'un système de gestion de données spécifique, on a le sentiment que le sharding ne fait que trancher ligne par ligne et ainsi de suite - et c'est tout: <br><br><blockquote>  Partitionnement (~ =, \ in ...) Le partitionnement horizontal == est typique. <br></blockquote><br>  J'insiste, généralement.  En ce sens que nous faisons tout cela non seulement pour couper 2 milliards de documents en 20 tableaux, chacun étant plus facile à gérer, mais pour le distribuer dans de nombreux cœurs, de nombreux disques ou de nombreux serveurs physiques ou virtuels différents . <br><br>  Il est entendu que nous procédons de telle sorte que chaque fragment - chaque shatka de données - soit répliqué plusieurs fois.  Mais en fait, non. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> docs00 <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> documents <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>%<span class="hljs-number"><span class="hljs-number">16</span></span>)=<span class="hljs-number"><span class="hljs-number">0</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> docs15 <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> documents <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>%<span class="hljs-number"><span class="hljs-number">16</span></span>)=<span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre> <br>  En fait, si vous effectuez un tel découpage de données, et à partir d'une table SQL géante sur MySQL, vous générerez 16 petites tables sur votre vaillant ordinateur portable, sans aller au-delà d'un seul ordinateur portable, pas d'un seul schéma, pas d'une seule base de données, etc.  etc.  - tout, vous avez déjà du sharding. <br><br>  En se souvenant de l'illustration avec des chiots, cela conduit à ce qui suit: <br><br><ul><li>  La bande passante augmente. <br></li><li>  La latence ne change pas, c'est-à-dire que chacun, pour ainsi dire, travailleur ou consommateur dans ce cas, obtient le sien.  On ne sait pas ce que les chiots obtiennent sur la photo, mais les demandes sont servies à peu près en même temps, comme si le chiot était seul. </li><li>  Ou à la fois cela, et un autre, et toujours une haute disponibilité (réplication). <br></li></ul><br>  <strong>Pourquoi la bande passante?</strong>  Parfois, nous pouvons avoir de tels volumes de données qui ne correspondent pas - on ne sait pas où, mais ils ne correspondent pas - par 1 {core |  conduire |  serveur |  ...}.  Il n'y a tout simplement pas assez de ressources et c'est tout.  Pour travailler avec ce grand ensemble de données, vous devez le couper. <br><br>  <strong>Pourquoi la latence?</strong>  Sur un cœur, l'analyse d'une table de 2 milliards de lignes est 20 fois plus lente que l'analyse de 20 tables sur 20 noyaux, en parallèle.  Les données sont traitées trop lentement sur une seule ressource. <br><br>  <strong>Pourquoi une haute disponibilité?</strong>  Ou nous coupons les données afin de faire l'une et l'autre en même temps, et en même temps plusieurs copies de chaque fragment - la réplication fournit une haute disponibilité. <br><br><h2>  Un exemple simple de "comment le faire avec vos mains" <br></h2><br>  Le partitionnement conditionnel peut être découpé en utilisant la table de test test.documents pour 32 documents, et en générant à partir de cette table 16 tables de test pour environ 2 documents test.docs00, 01, 02, ..., 15 chacun. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> docs00 <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> documents <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>%<span class="hljs-number"><span class="hljs-number">16</span></span>)=<span class="hljs-number"><span class="hljs-number">0</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> docs15 <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> documents <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>%<span class="hljs-number"><span class="hljs-number">16</span></span>)=<span class="hljs-number"><span class="hljs-number">15</span></span></code> </pre><br>  Pourquoi?  Parce que a priori nous ne savons pas comment est distribué id, si de 1 à 32 inclus, alors il y aura exactement 2 documents chacun, sinon non. <br><br>  <strong>Nous faisons cela pour quoi.</strong>  Après avoir fait 16 tableaux, nous pouvons «attraper» 16 de ce dont nous avons besoin.  Indépendamment de ce sur quoi nous nous appuyions, nous pouvons paralléliser ces ressources.  Par exemple, s'il n'y a pas assez d'espace disque, il sera judicieux de décomposer ces tables en disques distincts. <br><br>  Tout cela, malheureusement, n'est pas gratuit.  Je soupçonne que dans le cas du standard SQL canonique (je n'ai pas relu le standard SQL depuis longtemps, il n'a peut-être pas été mis à jour depuis longtemps), il n'y a pas de syntaxe standardisée officielle pour dire à un serveur SQL: «Cher serveur SQL, faites-moi 32 fragments et les mettre sur 4 disques. "  Mais dans les implémentations individuelles, il existe souvent une syntaxe spécifique afin de faire la même chose en principe.  PostgreSQL a des mécanismes de partitionnement, MySQL MariaDB l'a, Oracle a probablement fait tout cela il y a longtemps. <br><br>  Néanmoins, si nous le faisons à la main, sans support de base de données et dans le cadre de la norme, nous <strong>payons conditionnellement la complexité de l'accès aux données</strong> .  Là où il y avait un simple SELECT * FROM documents WHERE id = 123, maintenant 16 x SELECT * FROM docsXX.  Et bien, si on essayait d'obtenir le record par clé.  Significativement plus intéressant si nous essayions d'obtenir une première gamme de disques.  Maintenant (si, je le souligne, comme si c'était un imbécile, et que je reste dans la norme), les résultats de ces 16 SELECT * FROM devront être combinés dans l'application. <br><br>  <strong>Quel changement de performance attendre?</strong> <br><br><ul><li>  Intuitivement linéaire. </li><li>  Théoriquement - sublinéaire, parce que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">loi d'Amdahl</a> . </li><li>  En pratique - peut-être presque linéairement, peut-être pas. </li></ul><br>  En fait, la bonne réponse est inconnue.  En appliquant intelligemment la technique de sharding, vous pouvez obtenir une détérioration super-linéaire significative des performances de votre application, et même le DBA fonctionnera avec un poker chaud. <br><br>  Voyons comment cela peut être réalisé.  Il est clair que simplement définir le paramètre sur les fragments PostgreSQL = 16, puis il s'est décollé - ce n'est pas intéressant.  Réfléchissons à la façon dont nous pourrions réaliser que <em>nous ralentirions à 32 fois après le partage</em> , ce qui est intéressant du point de vue de la façon de ne pas le faire. <br><br>  Nos tentatives d'accélération ou de ralentissement reposeront toujours contre les classiques - la bonne vieille loi d'Amdahl, qui dit qu'il n'y a pas de parallélisation parfaite de toute demande, il y a toujours une partie cohérente. <br><br><h2>  Loi d'Amdahl <br></h2><br><blockquote>  <strong><em>Il</em></strong> y a <strong><em>toujours</em></strong> une partie sérialisée. <br></blockquote><br>  Il y a toujours une partie de l'exécution de la requête qui est parallélisée, et il y a toujours une partie qui n'est pas parallèle.  Même s'il vous semble qu'une requête parfaitement parallèle, collectant au moins une ligne du résultat que vous allez envoyer au client, à partir des lignes reçues de chaque fragment, il y en a toujours, et elle est toujours cohérente. <br><br>  Il y a toujours une sorte de partie séquentielle.  Il peut être minuscule, absolument invisible dans le contexte général, il peut être gigantesque et, par conséquent, affecter fortement la parallélisation, mais il est toujours là. <br><br>  De plus, son influence est en <strong><em>train de changer</em></strong> et peut augmenter considérablement, par exemple, si nous réduisons notre table - augmentons les taux - de 64 enregistrements à 16 tables de 4 enregistrements, cette partie changera.  Bien sûr, à en juger par ces quantités gigantesques de données, nous travaillons sur un téléphone mobile et un processeur à 86 MHz, nous n'avons pas assez de fichiers qui peuvent être ouverts en même temps.  Apparemment, avec une telle entrée, nous ouvrons un fichier à la fois. <br><br><ul><li>  C'était <strong>Total =</strong> <strong>Serial +</strong> <strong>Parallel</strong> .  Par exemple, où parallèle est tout le travail à l'intérieur de la base de données et série envoie le résultat au client. <br></li><li>  Il est devenu <strong>Total2 = Serial + Parallel / N + Xserial.</strong>  Par exemple, lorsque le général ORDER BY, Xserial&gt; 0. <br></li></ul><br>  Avec cet exemple simple, j'essaie de montrer que certains Xserial apparaissent.  En plus du fait qu'il y a toujours une partie sérialisée, et du fait que nous essayons de travailler avec des données en parallèle, une partie supplémentaire apparaît pour assurer ce découpage des données.  En gros, nous pouvons avoir besoin de: <br><br><ul><li>  trouver ces 16 tables dans le dictionnaire de base de données interne; </li><li>  ouvrir des fichiers; </li><li>  allouer de la mémoire; </li><li>  déplacer la mémoire; </li><li>  tacher les résultats; </li><li>  synchroniser entre les cœurs; </li></ul><br>  Tous les effets désynchronisés apparaissent toujours.  Ils peuvent être insignifiants et occuper un milliardième du temps total, mais ils sont toujours non nuls et existent toujours.  Avec leur aide, nous pouvons considérablement perdre en productivité après le sharding. <br><br><img src="https://habrastorage.org/webt/fh/mx/yh/fhmxyh9tozfrbd4yszxj2va9a1g.jpeg"><br><br>  Ceci est une image standard de la loi d'Amdahl.  Ce n'est pas très lisible, mais il est important que les lignes, qui devraient idéalement être droites et croître linéairement, butent sur l'asymptote.  Mais comme le graphique sur Internet est illisible, j'ai fait, à mon avis, des tableaux plus visuels avec des chiffres. <br><br>  Supposons que nous ayons une partie sérialisée du traitement de la demande, ce qui ne prend que 5%: <strong>série = 0,05 = 1/20.</strong> <br><br>  Intuitivement, il semblerait qu'avec la partie sérialisée, qui ne prend que 1/20 du traitement de la demande, si nous parallélisons le traitement de la demande à 20 cœurs, elle deviendra environ 20, dans le pire des cas, 18 fois plus rapide. <br><br>  En fait, les <b>mathématiques sont une chose sans cœur</b> : <br><br> <code>wall = 0.05 + 0.95/num_cores, speedup = 1 / (0.05 + 0.95/num_cores)</code> <br> <br>  Il s'avère que si vous calculez soigneusement, avec une partie sérialisée de 5%, l'accélération sera 10 fois (10,3), et c'est 51% par rapport à l'idéal théorique. <br><br><table><tbody><tr><td>  8 noyaux </td><td>  = 5,9 </td><td>  <font color="#c45911">= 74%</font> </td></tr><tr><td>  10 cœurs </td><td>  = 6,9 </td><td>  <font color="#c45911">= 69%</font> </td></tr><tr><td>  <strong>20 noyaux</strong> </td><td>  <strong>= 10,3</strong> </td><td>  <strong><font color="#c45911">= 51%</font></strong> </td></tr><tr><td>  40 noyaux </td><td>  = 13,6 </td><td>  <font color="#ff0000">= 34%</font> </td></tr><tr><td>  128 cœurs </td><td>  = 17,4 </td><td>  <font color="#ff0000">= 14%</font> </td></tr></tbody></table><br>  En utilisant 20 cœurs (20 disques, si vous le souhaitez) pour la tâche sur laquelle on a travaillé auparavant, nous n'obtiendrons jamais théoriquement une accélération plus de 20 fois, mais pratiquement beaucoup moins.  De plus, avec une augmentation du nombre de parallèles, l'inefficacité augmente rapidement. <br><br>  Lorsqu'il ne reste que 1% du travail sérialisé et 99% en parallèle, les valeurs d'accélération sont quelque peu améliorées: <br><br><table><tbody><tr><td>  8 noyaux </td><td>  = 7,5 </td><td>  <font color="#538135">= 93%</font> </td></tr><tr><td>  16 cœurs </td><td>  = 13,9 </td><td>  <font color="#538135">= 87%</font> </td></tr><tr><td>  32 coeurs </td><td>  = 24,4 </td><td>  <font color="#c45911">= 76%</font> </td></tr><tr><td>  64 coeurs </td><td>  = 39,3 </td><td>  <font color="#c45911">= 61%</font> </td></tr></tbody></table><br>  Pour une requête complètement thermonucléaire, qui dure naturellement des heures, et les travaux préparatoires et l'assemblage du résultat prennent très peu de temps (série = 0,001), on verra déjà une bonne efficacité: <br><br><table><tbody><tr><td>  8 noyaux </td><td>  = 7,94 </td><td>  <font color="#538135">= 99%</font> </td></tr><tr><td>  16 cœurs </td><td>  = 15,76 </td><td>  <font color="#538135">= 99%</font> </td></tr><tr><td>  32 coeurs </td><td>  = 31,04 </td><td>  <font color="#538135">= 97%</font> </td></tr><tr><td>  64 coeurs </td><td>  = 60,20 </td><td>  <font color="#538135">= 94%</font> </td></tr></tbody></table><br>  Veuillez noter que <strong>nous ne verrons jamais 100%</strong> .  Dans des cas particulièrement bons, vous pouvez voir, par exemple, 99,999%, mais pas exactement 100%. <br><br><h2>  Comment mélanger et casser en N fois? <br></h2><br>  Vous pouvez mélanger et casser exactement N fois: <br><br><ol><li>  Envoyez les demandes docs00 ... docs15 de <strong>manière séquentielle</strong> , pas en parallèle. </li><li>  Dans les requêtes simples, ne sélectionnez <strong>pas</strong> <strong>par clé</strong> , O something quelque chose = 234. </li></ol><br>  Dans ce cas, la partie sérialisée (série) occupe non pas 1% et non 5%, mais environ 20% dans les bases de données modernes.  Vous pouvez obtenir 50% de la partie sérialisée si vous accédez à la base de données à l'aide d'un protocole binaire extrêmement efficace ou si vous la liez en tant que bibliothèque dynamique à un script Python. <br><br>  Le reste du temps de traitement d'une simple demande sera occupé par des opérations non parallélisées d'analyse de la demande, de préparation du plan, etc.  Autrement dit, il ralentit de ne pas lire le dossier. <br><br>  Si nous divisons les données en 16 tables et les exécutons séquentiellement, comme c'est le cas dans le langage de programmation PHP, par exemple, (il ne sait pas très bien comment exécuter les processus asynchrones), nous obtenons le ralentissement de 16 fois.  Et peut-être même davantage, car des allers-retours sur le réseau seront également ajoutés. <br><br><blockquote>  Du coup lors du sharding, le choix d'un langage de programmation est important. <br></blockquote><br>  Nous nous souvenons du choix d'un langage de programmation, car si vous envoyez des requêtes à la base de données (ou au serveur de recherche) séquentiellement, d'où vient l'accélération?  Au contraire, un ralentissement apparaîtra. <br><br><h3>  Vélo de la vie <br></h3><br>  Si vous choisissez C ++, <strong>écrivez dans les threads POSIX</strong> , pas Boost I / O.  J'ai vu une excellente bibliothèque de développeurs expérimentés d'Oracle et MySQL lui-même, qui ont écrit la communication avec le serveur MySQL sur Boost.  Apparemment, ils ont été forcés d'écrire en C pur au travail, mais ils ont ensuite réussi à faire demi-tour, à prendre Boost avec des E / S asynchrones, etc.  Un problème - cette E / S asynchrone, qui théoriquement aurait dû conduire 10 demandes en parallèle, pour une raison quelconque, avait un point de synchronisation invisible à l'intérieur.  Lors du démarrage de 10 requêtes en parallèle, elles ont été exécutées exactement 20 fois plus lentement qu'une, car 10 fois pour les requêtes elles-mêmes et une fois pour le point de synchronisation. <br><br>  <strong>Conclusion:</strong> écrivez dans des langages qui implémentent l'exécution parallèle et attendent bien les différentes requêtes.  Pour être honnête, je ne sais pas exactement quoi conseiller à part Go.  Non seulement parce que j'aime vraiment Go, mais parce que je ne sais rien de mieux. <br><br>  <strong>N'écrivez pas dans des langues inappropriées</strong> dans lesquelles vous ne pouvez pas exécuter 20 requêtes parallèles dans la base de données.  Ou à chaque occasion, ne faites pas tout avec vos mains - comprenez comment cela fonctionne, mais ne le faites pas manuellement. <br><br><h2>  Vélo d'essai A / B <br></h2><br>  Parfois, vous pouvez ralentir parce que vous êtes habitué au fait que tout fonctionne et que vous n’avez pas remarqué que la partie sérialisée, premièrement, est, deuxièmement, une grosse. <br><br><ul><li>  Immédiatement ~ 60 fragments d'index de recherche, catégories </li><li>  Ce sont des fragments corrects et corrects, sous un domaine. </li><li>  Il y avait jusqu'à 1 000 documents et 50 000 documents. </li></ul><br>  Il s'agit d'un vélo de production, lorsque les requêtes de recherche ont été légèrement modifiées et ils ont commencé à sélectionner beaucoup plus de documents parmi 60 fragments de l'index de recherche.  Tout a fonctionné rapidement et sur le principe: "ça marche - ne le touchez pas", ils l'ont tous oublié, ce qui est en fait à l'intérieur de 60 éclats.  Nous avons augmenté la limite d'échantillonnage pour chaque fragment de mille à 50 000 documents.  Soudain, il a commencé à ralentir et le parallélisme a cessé.  Les demandes elles-mêmes, qui ont été exécutées en fonction des tessons, ont plutôt bien volé et l'étape a été ralentie lorsque 50 000 documents ont été collectés auprès de 60 tessons.  Ces 3 millions de documents finaux sur un core ont fusionné, triés, le top 3 millions a été sélectionné et remis au client.  La même partie en série a ralenti, la même loi impitoyable d'Amdal a fonctionné. <br><br>  <em>Alors peut-être que tu ne devrais pas faire du sharding avec tes mains, mais juste humainement</em> <em><br></em>  <em>dites à la base de données: "Faites-le!"</em> <em><br></em> <br>  <strong>Avertissement:</strong> je ne sais pas vraiment comment faire quelque chose de bien.  Je suis du mauvais étage !!! <br><br>  J'ai fait la promotion d'une religion appelée «fondamentalisme algorithmique» tout au long de ma vie consciente.  Il est brièvement formulé très simplement: <br><br><blockquote>  Vous ne voulez vraiment rien faire avec vos mains, mais il est extrêmement utile de savoir comment cela est organisé à l'intérieur.  De sorte qu'au moment où quelque chose ne va pas dans la base de données, vous comprenez au moins ce qui s'est mal passé là-bas, comment il est organisé à l'intérieur et à peu près comment il peut être réparé. <br></blockquote><br>  Examinons les options: <br><br><ol><li>  <strong>"Mains</strong> . <strong>"</strong>  Plus tôt, nous avons fragmenté manuellement les données en 16 tables virtuelles et réécrit toutes les requêtes avec nos mains - c'est extrêmement inconfortable à faire.  <strong>S'il est possible de ne pas mélanger les mains - ne mélangez pas les mains!</strong>  Mais parfois, ce n'est pas possible, par exemple, vous avez MySQL 3.23, puis vous devez. </li><li>  <strong>"Automatique".</strong>  Il arrive que vous puissiez mélanger automatiquement ou presque automatiquement, lorsque la base de données peut distribuer les données elle-même, il vous suffit d'écrire à peu près quelque part un paramètre spécifique.  Il y a beaucoup de bases et elles ont beaucoup de réglages différents.  Je suis sûr que dans chaque base de données dans laquelle il est possible d'écrire shards = 16 (quelle que soit la syntaxe), de nombreux autres paramètres sont collés à ce cas par le moteur. </li><li>  <strong>"Semi-automatique"</strong> - un mode complètement cosmique, à mon avis, et brutal.  Autrement dit, la base elle-même ne semble pas pouvoir le faire, mais il existe des correctifs supplémentaires externes. </li></ol><br>  Il est difficile de dire quelque chose sur la machine, sauf pour l'envoyer à la documentation sur la base de données appropriée (MongoDB, Elastic, Cassandra, ... en général, le soi-disant NoSQL).  Si vous êtes chanceux, alors vous tirez simplement sur l'interrupteur «faites-moi 16 éclats» et tout fonctionnera.  À ce moment, quand cela ne fonctionne pas, le reste de l'article peut être nécessaire. <br><br><h2>  À propos du dispositif semi-automatique <br></h2><br>  Dans certains endroits, les technologies de l'information sophistiquées inspirent l'horreur chthonique.  Par exemple, MySQL prêt à l'emploi n'avait aucune implémentation de partitionnement vers certaines versions, bien sûr, néanmoins, la taille des bases utilisées au combat atteignait des valeurs indécentes. <br><br>  La souffrance de l'humanité face aux administrateurs de base de données individuels est tourmentée depuis des années et écrit plusieurs mauvaises solutions de partitionnement conçues sans raison.  Après cela, une solution de sharding plus ou moins décente est écrite appelée ProxySQL (MariaDB / Spider, PG / pg_shard / Citus, ...).  Ceci est un exemple bien connu de ce même manteau. <br><br>  ProxySQL dans son ensemble, bien sûr, est une solution complète de classe entreprise pour l'open source, pour le routage et plus encore.  Mais l'une des tâches à résoudre est le partitionnement d'une base de données, qui en elle-même ne sait pas comment fragmenter humainement.  Vous voyez, il n'y a pas de commutateur «shards = 16», soit vous devez réécrire chaque demande dans l'application, et il y en a beaucoup, soit mettre une couche intermédiaire entre l'application et la base de données qui ressemble à: «Hmm ... SELECT * FROM documents?  Oui, il doit être déchiré en 16 petits SELECT * FROM server1.document1, SELECT * FROM server2.document2 - à ce serveur avec ce nom d'utilisateur / mot de passe, à ceci avec un autre.  Si on ne répond pas, alors ... "etc. <br><br>  Cela peut être fait exactement par des correctifs intermédiaires.  Ils sont légèrement inférieurs à ceux de toutes les bases de données.  Pour PostgreSQL, si je comprends bien, il existe des solutions intégrées en même temps (PostgresForeign Data Wrappers, à mon avis, est intégré à PostgreSQL lui-même), il existe des correctifs externes. <br><br>  La configuration de chaque correctif spécifique est un sujet géant distinct qui ne rentrera pas dans un seul rapport, nous ne discuterons donc que des concepts de base. <br><br>  Mieux vaut parler un peu de la théorie du buzz. <br><br><h2>  Une automatisation parfaite absolue? <br></h2><br>  Toute la théorie du buzz dans le cas du sharding dans cette lettre F (), le principe de base est <strong>toujours</strong> le même brut: <code>shard_id = F(object).</code> <br><br>  Le sharding, c'est généralement quoi?  Nous avons 2 milliards d'enregistrements (ou 64).  Nous voulons les diviser en plusieurs morceaux.  Une question inattendue se pose - comment?  Selon quel principe dois-je répartir mes 2 milliards d'enregistrements (ou 64) sur 16 serveurs à ma disposition? <br><br>  Le mathématicien latent en nous devrait suggérer qu'à la fin il y a toujours une certaine fonction magique qui, pour chaque document (objet, ligne, etc.), déterminera dans quelle pièce le mettre. <br><br>  Si nous approfondissons les mathématiques, cette fonction dépend toujours non seulement de l'objet lui-même (la ligne elle-même), mais également de paramètres externes tels que le nombre total de fragments.  La fonction, qui pour chaque objet doit indiquer où la placer, ne peut pas renvoyer une valeur de plus qu'il n'y a de serveurs sur le système.  Et les fonctions sont un peu différentes: <br><br><ul><li>  shard_func = <strong>F1</strong> (objet); <br></li><li>  shard_id = <strong>F2</strong> (shard_func, ...); </li><li>  shard_id = <strong>F2</strong> ( <strong>F1</strong> (objet), current_num_shards, ...). </li></ul><br>  Mais plus loin nous ne creuserons pas dans ces jungles de fonctions individuelles, nous parlons juste de ce que sont les fonctions magiques F (). <br><br><h2>  Que sont F ()? <br></h2><br>  Ils peuvent proposer de nombreux mécanismes de mise en œuvre différents et très différents.  Exemple de résumé: <br><br><ul><li>  F = <strong>rand</strong> ()% nums_shards </li><li>  F = <strong>somehash</strong> ( <strong>object.id</strong> )% num_shards </li><li>  F = object.date% num_shards </li><li>  F = object.user_id% num_shards </li><li>  ... </li><li>  F = shard_table [somehash () | ... object.date | ...] </li></ul><br>  Un fait intéressant - vous pouvez naturellement disperser toutes les données au hasard - nous jetons l'enregistrement suivant sur un serveur arbitraire, sur un noyau arbitraire, dans une table arbitraire.  Il n'y aura pas beaucoup de bonheur, mais cela fonctionnera. <br><br>  Il existe des méthodes légèrement plus intelligentes d'escroquerie pour des fonctions de hachage reproductibles ou même cohérentes, ou d'escroquerie pour certains attributs.  Passons en revue chaque méthode. <br><br><h3>  F = rand () <br></h3><br>  La dispersion n'est pas une méthode très correcte.  Un problème: nous avons dispersé nos 2 milliards d'enregistrements pour mille serveurs au hasard, et nous ne savons pas où se trouve l'enregistrement.  Nous devons extraire user_1, mais nous ne savons pas où il se trouve.  Nous allons sur un millier de serveurs et trions tout - d'une manière ou d'une autre, c'est inefficace. <br><br><h3>  F = somehash () <br></h3><br>  Répartissons les utilisateurs de manière adulte: lisez la fonction de hachage reproduite de user_id, prenez le reste de la division par le nombre de serveurs et contactez immédiatement le serveur souhaité. <br><br>  <em>Pourquoi on fait ça?</em>  <em>Et puis, nous avons une charge élevée et nous n'introduisons rien dans un seul serveur.</em>  <em>Si elle s'entremêlait, la vie serait si simple.</em> <br><br>  Eh bien, la situation s'est déjà améliorée, pour obtenir un enregistrement, nous allons sur un serveur bien connu.  Mais si nous avons une plage de clés, dans toute cette plage, nous devons trier toutes les valeurs de clé et, dans la limite, aller soit à autant de fragments que nous avons de clés dans la plage, soit à chaque serveur en général.  Bien sûr, la situation s'est améliorée, mais pas pour toutes les demandes.  Certaines demandes ont été affectées. <br><br><h3>  Partage naturel (F = object.date% num_shards) <br></h3><br>  Parfois, c'est souvent 95% du trafic et 95% de la charge sont des demandes qui ont une sorte de partage naturel. , 95%  -       1 , 3 , 7 ,   5%     .  95% ,  ,    ,        . <br><br>        , ,   ,         -           . <br><br>   —        ,      .       ,    , , ,    .        5 %  . <br><br>       ,    : <br><br><ol><li>      ,  95%     . </li><li>  95%    ,       ,     .   ,           .     ,     . </li></ol><br>  ,      —    ,         - . <br><br>   ,   ,         ,     ,         .       «   -      ». <br><br> <strong>     «».</strong> ,            . <br><br><h3> 1.  :   <br></h3><br>    ,      ,  . <br><br><ul><li>    ,   ! </li><li> <strong><em></em></strong>  () . </li></ul><br>   , /  , ,  , PM    (       ,  PM   ),     .     . <br><br>  ,    .      ,       ,    100   .        . <br><br>   ,  ,   ,            ,    - . <br><br><h3> 2. «» : , join <br></h3><br>   ,             ? <br><br><ul><li>  «» … WHERE randcol BETWEEN aaa AND bbb? <br></li><li>  «» … users_32shards JOIN posts_1024 shards? </li></ul><br>  : , ! <br><br>           ,    ,       ,           .      .       (, , document store    ),     ,     . <br><br>   — <strong>-       </strong> .     .  ,          .     ,       ,    ,   .       - , ,         ,   ,         —    . <br><br>       ,             . <br><br><h3> 3. / :  <br></h3><br> :         ,          . <br><br><blockquote>    ,   . <br></blockquote><br>      ,  , ,  .     ,     ,   ,    10 , -        30,       100   .    .          —       ,  -   —  , -  . <br><br> ,      :  16 -,  32. ,   17,  23 —    .      ,  ,    -  ? <br><br>  : ,    ,     . <br><br>  ,    «»,   « ». <br><br><h4>   #1.   <br></h4><br><ul><li>     NewF(object),    . </li><li>   NewF()=OldF() . </li><li>   <strong> .</strong> </li><li>  Ouch. </li></ul><br>  ,    2       ,  ,  .   :  17 ,  6   ,  2  ,    17   23 .   10  , ,    .      . <br><br><h4>   #2.   <br></h4><br>    —       —  17    23,     16   32 !         ,        . <br><br><ul><li>     NewF(object),    . </li><li> <strong>  2^N,   2^(N+1) .</strong> </li><li>   NewF()=OldF()  0,5. </li><li>   50% . </li><li> ,   <strong>   .</strong> </li></ul><br>  ,  ,         .   ,   ,  . <br><br>  ,            .   ,  16     16,      —    . <br><br> ,        —     . <br><br><h4>  #3. Consistent hashing <br></h4><br> ,       consistent hashing <br><img src="https://habrastorage.org/webt/il/ml/rt/ilmlrt9xy-c3wuyfaafntagufay.jpeg"><br><br>   «consistent hashing»,    ,    . <br><br> :    ()   ,      .    ,     ,  ,      (  ,     ), . <br><br><ul><li>   :  <strong><em> </em></strong> ,   2 «»,    1/n. <br></li><li>   :    ,   .  . </li></ul><br>          ,         .  ,      ,      ,     :     ,          . <br><br>        .  ,        .  ,   ..,    .  ,   - , ,        . <br><br>       ,  , ,  Cassandra   .  ,         , ,      , ,  . <br><br>   ,        —     /    ,   ,    . <br><br> , :    ?       ? — ,  ! <br><br><h4>  #4. Rendezvous/HRW <br></h4><br>    (  ,   ): <strong>shard_id = arg max hash(object_id, shard_id).</strong> <br><br>    Rendezvous hashing,   ,  ,    Highest Random Weight.      : <br><img src="https://habrastorage.org/webt/0t/dt/rm/0tdtrm0iftxxb5ors5a2wxcex8s.jpeg"><br>   , , 16 .    (),   - ,  16 ,      .      -,   . <br><br>    HRW-hashing,   Rendezvous hashing.       , -,        ,   . <br><br>    ,       .  ,        - -        .      . <br><br>   ,       . <br><br><h4>  #5.   <br></h4><br> ,        Google    -   : <br><br><ul><li> Jump Hash — Google '2014. </li><li> Multi Probe —Google '2015. </li><li> Maglev — Google '2016. </li></ul><br>    ,    .      ,   ,    , -,       .      . <br><br><h4>  #6.  <br></h4><br>      —  .     ?   ,     2  ,          object_id  2  ,     . <br><br>  ,       ?    ? <br><br>     . ,   -     ,   ,  .  ,      , ,  ,     . <br><br> : <br><br><ul><li>  1  . </li><li>      /  /  /       : min/max_id =&gt; shard_id. </li><li>    8    4    (4      !) —  20    . </li><li>      -   ,        20  —     . </li><li> 20  —                 . </li></ul><br>     2     -    16  —   100   -   .       : ,         ,   —  1 .     ,  ,   . <br><br> ,    ,     ,    - ,     . <br><br><h1>  Conclusions <br></h1><br>            : «  ,   !».       ,     20 . <br><br>   ,   ,     .   ,  <strong>   </strong> —   .     100$        ,     .          -,    .     —   . <br><br> <strong>    </strong> , ,  «» (, DFS, ...)   .   ,   , highload   -   .  ,        ,     - .     — <strong> ,    </strong> . <br><br>     <strong> </strong> <strong>F()</strong> ,   , ,  ..  , ,    2   <strong>     </strong> . <br><br><h2>   <br></h2><br> ,      ,        .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> HighLoad++</a> ,  ,     —Sphinx—highload  ,   . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qpGljUyIht8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>    <br></h2><br>         Highload User Group.  ,    . <br><br>  , ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HighLoad++</a>     .         , ,  .  ,            , .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>   highload-,   . <br><br>        ,  ,     ,  . ,           , ,        . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> <strong>24   -</strong>      «», « ».  ,        .      ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br><br><blockquote>         , ,  <strong>8  9   -  </strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>HighLoad++</strong></a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> early bird . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433370/">https://habr.com/ru/post/fr433370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433360/index.html">Les scientifiques ont essayé de prédire quand les avions électriques deviendront réalité</a></li>
<li><a href="../fr433362/index.html">9 principes de beauté, de simplicité et de soins en UX</a></li>
<li><a href="../fr433364/index.html">LDraw + Unity. Comment j'ai généré Lego</a></li>
<li><a href="../fr433366/index.html">Utilisation de ressources externes dans Unity3D</a></li>
<li><a href="../fr433368/index.html">Comment appliquer la pensée épicerie au monde: un exemple de sweat-shirt</a></li>
<li><a href="../fr433372/index.html">Vélo de voiture</a></li>
<li><a href="../fr433374/index.html">Toute la vérité sur RTOS. Article # 26. Canaux: services auxiliaires et structures de données</a></li>
<li><a href="../fr433376/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 21: Suivi des données, partie 1</a></li>
<li><a href="../fr433378/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 21: Suivi des données, partie 2</a></li>
<li><a href="../fr433380/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 21: Suivi des données, partie 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>