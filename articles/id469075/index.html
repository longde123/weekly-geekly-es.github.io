<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖøÔ∏è üôçüèø ‚õ±Ô∏è DLR Grokay üôçüèø üë∏üèæ üñ≤Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kata Pengantar Penerjemah 

 Ini lebih menceritakan kembali gratis, bukan terjemahan. Saya memasukkan dalam artikel ini hanya bagian-bagian asli yang ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DLR Grokay</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469075/"> <i><b>Kata Pengantar Penerjemah</b></i> <i><br><br></i>  <i>Ini lebih menceritakan kembali gratis, bukan terjemahan.</i>  <i>Saya memasukkan dalam artikel ini hanya bagian-bagian asli yang secara langsung terkait dengan mekanisme internal DLR atau menjelaskan ide-ide penting.</i>  <i>Catatan akan dilampirkan dalam tanda kurung siku.</i> <br><br>  Banyak pengembang .NET telah mendengar tentang Dynamic Language Runtime (DLR), tetapi hampir tidak tahu apa-apa tentang itu.  Pengembang yang menulis dalam bahasa seperti C # atau Visual Basic menghindari bahasa pengetikan dinamis karena takut akan masalah skalabilitas yang terkait secara historis.  Mereka juga khawatir tentang fakta bahwa bahasa seperti Python atau Ruby tidak melakukan pengecekan tipe pada waktu kompilasi, yang dapat menyebabkan kesalahan runtime yang sulit ditemukan dan diperbaiki.  Ini adalah ketakutan yang beralasan yang dapat menjelaskan mengapa DLR tidak populer di kalangan mayoritas pengembang NET. Bahkan dua tahun setelah rilis resmi <i>[artikel ini sudah cukup tua, tetapi tidak ada yang berubah sejak itu]</i> .  Bagaimanapun, .NET <i>Runtime</i> yang berisi kata <i>Dynamic</i> dan <i>Language</i> dalam namanya harus dirancang secara ketat untuk mendukung bahasa seperti Python, bukan? <br><br>  Perlambat.  Sementara DLR benar-benar dirancang untuk mendukung implementasi Iron dari Python dan Ruby di .NET Framework, arsitekturnya menyediakan abstraksi yang jauh lebih dalam. <br><br><img src="https://habrastorage.org/webt/9p/co/0r/9pco0rjy7-sqeqb0hzgdngobjky.png"><br><a name="habracut"></a><br>  Di bawah tenda, DLR menawarkan rangkaian antarmuka yang kaya untuk komunikasi antar-proses [Inter-Process Communication (IPC)].  Selama bertahun-tahun, pengembang telah melihat banyak alat Microsoft untuk interaksi antara aplikasi: DDE, DCOM, ActiveX, .Net Remoting, WCF, OData.  Daftar ini bisa berlangsung lama.  Ini adalah parade akronim yang hampir tak ada habisnya, yang masing-masing mewakili teknologi yang menjanjikan bahwa tahun ini akan lebih mudah untuk bertukar data atau memanggil kode jarak jauh daripada sebelumnya. <br><br><h2>  Bahasa bahasa </h2><br>  Pertama kali saya mendengar Jim Hugunin berbicara tentang DLR, pidatonya mengejutkan saya.  Jim membuat implementasi Python untuk Java Virtual Machine (JVM) yang dikenal sebagai Jython.  Sesaat sebelum pertunjukan, ia bergabung dengan Microsoft untuk membuat IronPython untuk .NET.  Berdasarkan latar belakangnya, saya berharap dia fokus pada bahasa, tetapi sebaliknya, Jim berbicara hampir sepanjang waktu tentang hal-hal yang muskil seperti pohon ekspresi, pengiriman panggilan dinamis, dan mekanisme panggilan caching.  Jim menggambarkan satu set layanan kompilasi runtime yang memungkinkan dua bahasa untuk berinteraksi satu sama lain dengan hampir tidak ada kerugian dalam kinerja. <br><br>  Selama pidato ini, saya menuliskan istilah yang muncul di kepala saya ketika saya mendengar Jim menceritakan kembali arsitektur DLR: bahasa bahasa.  Empat tahun kemudian, nama panggilan ini masih menjadi ciri DLR dengan sangat akurat.  Namun, setelah mendapatkan pengalaman penggunaan di dunia nyata, saya menyadari bahwa DLR bukan hanya tentang kompatibilitas bahasa.  Berkat dukungan tipe dinamis dalam C # dan Visual Basic, DLR dapat bertindak sebagai gateway dari bahasa .NET favorit kami ke data dan kode di sistem jarak jauh apa pun, apa pun jenis peralatan atau perangkat lunak yang digunakan terakhir. <br><br><img src="https://habrastorage.org/webt/sp/l2/k3/spl2k3kcuitbvqg151r1wfx_zzc.png"><br><br>  Untuk memahami ide di balik DLR, yang merupakan mekanisme terintegrasi dalam bahasa IPC, mari kita mulai dengan contoh yang tidak ada hubungannya dengan pemrograman dinamis.  Bayangkan dua sistem komputer: satu disebut inisiator, dan yang kedua - sistem target.  Inisiator perlu menjalankan fungsi <b>foo</b> pada sistem target, melewati serangkaian parameter tertentu, dan mendapatkan hasilnya.  Setelah sistem target ditemukan, pemrakarsa harus memberikan semua informasi yang diperlukan untuk pelaksanaan fungsi dalam format yang dapat dimengerti olehnya.  Minimal, informasi ini akan mencakup nama fungsi dan parameter yang diteruskan.  Setelah membongkar permintaan dan memvalidasi parameter, sistem target akan menjalankan fungsi foo.  Setelah itu, ia harus mengemas hasilnya, termasuk kesalahan yang terjadi selama eksekusi, dan mengirimkannya kembali ke inisiator.  Akhirnya, pemrakarsa harus dapat membongkar hasil dan memberitahukan tujuan.  Pola respons permintaan ini cukup umum dan pada tingkat tinggi menggambarkan operasi hampir semua mekanisme IPC. <br><br><h3>  Objek dinamis </h3><br>  Untuk memahami bagaimana DLR mengimplementasikan pola yang disajikan, mari kita lihat salah satu kelas pusat DLR: <b>DynamicMetaObject</b> .  Kita mulai dengan mengeksplorasi tiga dari dua belas metode utama dari jenis ini: <br><br><ol><li>  BindCreateInstance - membuat atau mengaktifkan objek </li><li>  BindInvokeMember - panggil metode enkapsulasi </li><li>  BindInvoke - eksekusi objek (sebagai fungsi) </li></ol><br>  Saat Anda perlu menjalankan metode pada sistem jarak jauh, Anda harus terlebih dahulu membuat turunan dari tipe tersebut.  Tentu saja, tidak semua sistem berorientasi objek, jadi istilah "instance" bisa menjadi metafora.  Bahkan, layanan yang kita butuhkan dapat diimplementasikan sebagai kumpulan objek atau sebagai singleton, sehingga istilah "aktivasi" atau "koneksi" dapat digunakan dengan hak yang sama dengan "instance". <br><br>  Kerangka kerja lain mengikuti pola yang sama.  Sebagai contoh, COM menyediakan fungsi <b>CoCreateInstance</b> untuk membuat objek.  Di .NET Remoting, Anda bisa menggunakan metode <b>CreateInstance</b> dari kelas <b>System.Activator</b> .  DLR <b>DynamicMetaObject</b> menyediakan <b>BindCreateInstance</b> untuk tujuan yang sama. <br><br>  Setelah menggunakan metode <b>BindCreateInstance</b> , <i>sesuatu yang</i> dibuat bisa menjadi tipe yang memperlihatkan beberapa metode.  Metode <b>metaobject</b> BindInvokeMember digunakan untuk mengikat operasi yang dapat memanggil suatu fungsi.  Pada gambar di atas, string foo dapat dikirimkan sebagai parameter untuk menunjukkan kepada pengikat bahwa metode dengan nama itu harus dipanggil.  Selain itu termasuk informasi tentang jumlah argumen, nama mereka dan bendera khusus yang menunjukkan kepada pengikat apakah mungkin untuk mengabaikan kasus ketika mencari elemen bernama yang sesuai.  Lagi pula, tidak semua bahasa peka terhadap huruf besar-kecil. <br><br>  Ketika <i>sesuatu yang</i> dikembalikan dari <b>BindCreateInstance</b> hanya satu fungsi (atau mendelegasikan), metode BindInvoke digunakan.  Untuk memperjelas gambar, mari kita lihat potongan kecil kode dinamis berikut: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> Write = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntWriter(Console.WriteLine); Write(<span class="hljs-number"><span class="hljs-number">5</span></span>); }</code> </pre> <br>  Kode ini bukan cara terbaik untuk mencetak angka 5 ke konsol.  Pengembang yang baik tidak akan pernah menggunakan sesuatu yang sia-sia.  Namun, kode ini menggambarkan penggunaan variabel dinamis yang nilainya merupakan delegasi yang dapat digunakan sebagai fungsi.  Jika tipe delegasi mengimplementasikan antarmuka <b>IDynamicMetaObjectProvider</b> , maka metode <b>BindInvoke</b> dari <b>DynamicMetaObject</b> akan digunakan untuk mengikat operasi ke pekerjaan nyata.  Ini karena kompiler mengakui bahwa objek <b>Write</b> dinamis secara <i>sintaksis</i> digunakan sebagai fungsi.  Sekarang pertimbangkan potongan kode lain untuk memahami kapan kompiler akan menghasilkan <b>BindInvokeMember</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Writer</span></span> : <span class="hljs-title"><span class="hljs-title">IDynamicMetaObjectProvider</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(n); } <span class="hljs-comment"><span class="hljs-comment">//    } void Main() { dynamic Writer = new Writer(); Writer.Write(7); }</span></span></code> </pre><br>  Saya akan mengabaikan implementasi antarmuka dalam contoh kecil ini, karena akan membutuhkan banyak kode untuk menunjukkan ini dengan benar.  Dalam contoh singkat ini, kami mengimplementasikan objek meta dinamis hanya dengan beberapa baris kode. <br><br>  Satu hal penting untuk dipahami adalah bahwa kompiler mengakui bahwa <b>Writer.Write (7)</b> adalah operasi akses elemen.  Apa yang biasa kita sebut "operator titik" di C # secara resmi disebut "operator akses anggota tipe".  Kode DLR yang dihasilkan oleh kompiler dalam kasus ini pada akhirnya akan memanggil <b>BindInvokeMember</b> , di mana ia akan meneruskan string Write dan parameter nomor 7 ke operasi yang mampu melakukan panggilan.  Singkatnya, <b>BindInvoke</b> digunakan untuk memanggil objek dinamis sebagai fungsi, sedangkan <b>BindInvokeMember</b> digunakan untuk memanggil metode sebagai elemen dari objek dinamis. <br><br><h3>  Akses properti melalui DynamicMetaObject </h3><br>  Dapat dilihat dari contoh di atas bahwa kompiler menggunakan sintaks bahasa untuk menentukan operasi pengikatan DLR mana yang harus dilakukan.  Jika Anda menggunakan Visual Basic untuk bekerja dengan objek dinamis, maka semantiknya akan digunakan.  Operator akses (titik), tentu saja, diperlukan tidak hanya untuk mengakses metode.  Anda dapat menggunakannya untuk mengakses properti.  Objek meta DLR menyediakan tiga metode untuk mengakses properti objek dinamis: <br><br><ol><li>  BindGetMember - dapatkan nilai properti </li><li>  BindSetMember - tetapkan nilai properti </li><li>  BindDeleteMember - hapus item </li></ol><br>  Tujuan <b>BindGetMember</b> dan <b>BindSetMember</b> harus jelas.  Apalagi sekarang Anda tahu bagaimana mereka berhubungan dengan bagaimana .NET bekerja dengan properti.  Ketika kompiler menghitung properti <i>get</i> ("read") dari objek dinamis, ia menggunakan panggilan ke <b>BindGetMember</b> .  Ketika compiler menghitung set ("record"), ia menggunakan <b>BindSetMember</b> . <br><br><h3>  Representasi objek sebagai array </h3><br>  Beberapa kelas adalah wadah untuk instance dari jenis lain.  DLR tahu bagaimana menangani kasus-kasus seperti itu.  Setiap metode objek-meta "berorientasi-array" memiliki postfix "Indeks": <br><br><ol><li>  BindGetIndex - dapatkan nilai berdasarkan indeks </li><li>  BindSetIndex - set nilai berdasarkan indeks </li><li>  BindDeleteIndex - menghapus nilai berdasarkan indeks </li></ol><br>  Untuk memahami bagaimana <b>BindGetIndex</b> dan <b>BindSetIndex digunakan</b> , bayangkan <b>kelas</b> pembungkus <b>JavaBridge</b> yang dapat memuat file dengan kelas Java dan memungkinkan Anda untuk menggunakannya dari kode .NET tanpa kesulitan.  Wrapper semacam itu dapat digunakan untuk memuat kelas Java <b>Pelanggan</b> , yang berisi beberapa kode ORM.  Objek meta DLR dapat digunakan untuk memanggil kode ORM ini dari .NET dalam gaya C # klasik.  Di bawah ini adalah contoh kode yang menunjukkan bagaimana <b>JavaBridge</b> dapat bekerja dalam praktik: <br><br><pre> <code class="cs hljs">JavaBridge java = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JavaBridge(); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> customers = java.Load(<span class="hljs-string"><span class="hljs-string">"Customer.class"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> Jason = customers[<span class="hljs-string"><span class="hljs-string">"Bock"</span></span>]; Jason.Balance = <span class="hljs-number"><span class="hljs-number">17.34</span></span>; customers[<span class="hljs-string"><span class="hljs-string">"Wagner"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Customer(<span class="hljs-string"><span class="hljs-string">"Bill"</span></span>);</code> </pre> <br>  Karena baris ketiga dan kelima menggunakan operator akses berdasarkan indeks ([]), kompiler mengenali ini dan menggunakan metode <b>BindGetIndex</b> dan <b>BindSetIndex</b> ketika bekerja dengan objek meta yang dikembalikan dari <b>JavaBridge</b> .  Dapat dipahami bahwa implementasi metode ini pada objek yang dikembalikan akan meminta eksekusi metode dari JVM melalui Java Remote Method Invocation (RMI).  Dalam skenario ini, DLR bertindak sebagai jembatan antara C # dan bahasa lain dengan pengetikan statis.  Semoga ini menjelaskan mengapa saya menyebut DLR "bahasa bahasa". <br><br>  Metode <b>BindDeleteMember</b> , sama seperti <b>BindDeleteIndex</b> , tidak dimaksudkan untuk digunakan dari bahasa dengan pengetikan statis seperti C # dan Visual Basic, karena mereka tidak mendukung konsep itu sendiri.  Namun, Anda dapat setuju untuk mempertimbangkan "menghilangkan" beberapa operasi yang diungkapkan dengan menggunakan bahasa, jika itu berguna bagi Anda.  Misalnya, Anda dapat mengimplementasikan BindDeleteMember sebagai membatalkan elemen menurut indeks. <br><br><h3>  Transformasi dan Operator </h3><br>  Kelompok terakhir metode metaobjek DLR adalah tentang penanganan operator dan transformasi. <br><br><ol><li>  BindConvert - mengonversi objek ke tipe lain </li><li>  BindBinaryOperation - menggunakan operator biner pada dua operan </li><li>  BindUnaryOperation - menggunakan operator unary pada satu operan </li></ol><br>  Metode <b>BindConvert</b> digunakan ketika kompiler menyadari bahwa objek perlu dikonversi ke tipe lain yang dikenal.  Konversi tersirat terjadi ketika hasil panggilan dinamis ditugaskan ke variabel dengan tipe statis.  Sebagai contoh, dalam contoh C # berikut, menetapkan variabel <b>y</b> mengarah ke panggilan implisit ke <b>BindConvert</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> x = <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = x + <span class="hljs-number"><span class="hljs-number">11</span></span>;</code> </pre> <br>  Metode <b>BindBinaryOperation</b> dan <b>BindUnaryOperation</b> selalu digunakan ketika operasi aritmatika ("+") atau peningkatan ("++") ditemui.  Pada contoh di atas, menambahkan variabel dinamis <b>x</b> ke konstanta 11 akan memanggil metode <b>BindBinaryOperation</b> .  Ingat contoh kecil ini, kami menggunakannya di bagian berikutnya untuk menggedor kelas DLR kunci lain yang disebut CallSite. <br><br><h2>  Pengiriman dinamis dengan CallSite </h2><br>  Jika pengantar Anda untuk DLR tidak lebih dari menggunakan kata kunci <b>dinamis</b> , maka Anda mungkin tidak akan pernah tahu tentang keberadaan CallSite di .NET Framework.  Tipe sederhana ini, secara resmi dikenal sebagai <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> , berada di <b>System.Runtime.CompilerServices namespace</b> .  Ini adalah "sumber daya" dari metaprogramming: diisi dengan segala macam metode optimasi yang membuat kode .NET dinamis cepat dan efisien.  Saya akan menyebutkan aspek kinerja <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> di akhir artikel. <br><br>  Sebagian besar yang dilakukan CallSite dalam kode .NET dinamis melibatkan pembuatan dan kompilasi kode pada saat runtime.  Penting untuk dicatat bahwa kelas <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> terletak di namespace yang berisi kata-kata " <b>Runtime</b> " dan " <b>CompilerServices</b> ".  Jika DLR adalah "bahasa bahasa", maka <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> adalah salah satu konstruksi tata bahasa yang paling penting.  Mari kita lihat contoh kita dari bagian sebelumnya lagi untuk mengenal CallSite dan bagaimana kompiler menanamkannya dalam kode Anda. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> x = <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = x + <span class="hljs-number"><span class="hljs-number">11</span></span>;</code> </pre> <br>  Seperti yang sudah Anda ketahui, metode <b>BindBinaryOperaion</b> dan <b>BindConvert</b> akan dipanggil untuk menjalankan kode ini.  Alih-alih menunjukkan daftar panjang kode MSIL dibongkar yang dihasilkan oleh kompiler, saya membuat diagram: <br><br><img src="https://habrastorage.org/webt/c8/pw/0o/c8pw0osalzvckhg3w6b3eddlik4.png"><br><br>  Ingat bahwa kompiler menggunakan sintaks bahasa untuk menentukan metode tipe dinamis mana yang harus dijalankan.  Dalam contoh kami, dua operasi dilakukan: menambahkan variabel <b>x</b> ke nomor ( <b>Site2</b> ) dan melemparkan hasilnya ke int ( <b>Site1</b> ).  Setiap tindakan ini berubah menjadi CallSite, yang disimpan dalam wadah khusus.  Seperti yang Anda lihat dalam diagram, CallSites dibuat dalam urutan terbalik, tetapi dipanggil dengan cara yang benar. <br><br>  Pada gambar Anda dapat melihat bahwa metode <b>metaobject BindConvert</b> dan <b>BindBinaryOperation</b> dipanggil segera sebelum operasi "buat CallSite1" dan "create CallSite2".  Namun, operasi terikat hanya dilakukan pada bagian paling akhir.  Saya berharap visualisasi membantu Anda memahami bahwa metode pengikatan dan memanggil mereka adalah operasi yang berbeda dalam konteks DLR.  Selain itu, pengikatan hanya terjadi sekali, sementara panggilan terjadi sebanyak yang diperlukan, menggunakan kembali CallSites yang sudah diinisialisasi untuk mengoptimalkan kinerja. <br><br><h2>  Ikuti cara mudahnya </h2><br>  Di jantung DLR, pohon ekspresi digunakan untuk menghasilkan fungsi yang terikat pada dua belas metode pengikatan yang disajikan di atas.  Banyak pengembang terus-menerus dihadapkan dengan pohon ekspresi menggunakan LINQ, tetapi hanya beberapa yang memiliki pengalaman yang cukup dalam untuk sepenuhnya mengimplementasikan kontrak <b>IDynamicMetaObjectProvider</b> .  Untungnya, .NET Framework berisi kelas dasar yang disebut <b>DynamicObject</b> yang menangani sebagian besar pekerjaan. <br><br>  Untuk membuat kelas dinamis Anda sendiri, yang harus Anda lakukan adalah mewarisi dari <b>DynamicObject</b> dan menerapkan dua belas metode berikut: <br><br><ol><li>  TryCreateInstance </li><li>  TryInvokeMember </li><li>  Tryinvoke </li><li>  TryGetMember </li><li>  TrySetMember </li><li>  TryDeleteMember </li><li>  TryGetIndex </li><li>  TrySetIndex </li><li>  TryDeleteIndex </li><li>  Coba konversi </li><li>  TryBinaryOperation </li><li>  TryUnaryOperation </li></ol><br>  Apakah nama metode terlihat akrab?  Anda harus, karena Anda baru saja selesai mempelajari elemen-elemen dari kelas <b>DynamicMetaObject</b> Abstrak, yang mencakup metode seperti <b>BindCreateInstance</b> dan <b>BindInvoke</b> .  Kelas <b>DynamicMetaObject</b> menyediakan implementasi untuk <b>IDynamicMetaObjectProvider</b> , yang mengembalikan <b>DynamicMetaObject</b> dari satu-satunya metode.  Operasi yang terkait dengan implementasi dasar objek meta cukup mendelegasikan panggilan mereka ke metode yang dimulai dengan "Coba" pada instance <b>DynamicObject</b> .  Yang perlu Anda lakukan adalah membebani metode seperti <b>TryGetMember</b> dan <b>TrySetMember</b> di kelas yang diwarisi dari <b>DynamicObject</b> , sementara objek meta akan mengambil semua pekerjaan kotor dengan pohon ekspresi. <br><br><h2>  Caching </h2><br>  <i>[Anda dapat membaca lebih lanjut tentang caching di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya tentang DLR</a> ]</i> <br><br>  Perhatian terbesar ketika bekerja dengan bahasa dinamis untuk pengembang adalah kinerja.  DLR mengambil tindakan luar biasa untuk menghilangkan pengalaman ini.  Secara singkat saya menyebutkan fakta bahwa <b>CallSite</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> berada di namespace bernama <b>System.Runtime.CompilerServices</b> .  Di namespace yang sama terletak beberapa kelas lain yang menyediakan caching bertingkat.  Menggunakan tipe-tipe ini, DLR mengimplementasikan tiga level utama caching untuk mempercepat operasi dinamis: <br><br><ol><li>  Cache global </li><li>  Cache lokal </li><li>  Tembolok Delegasi Polimorfik </li></ol><br>  Cache digunakan untuk menghindari pemborosan sumber daya yang tidak perlu untuk membuat binding untuk CallSite tertentu.  Jika dua objek tipe <i>string</i> diteruskan ke metode dinamis yang mengembalikan <i>int</i> , maka cache global atau lokal akan menyimpan hasil pengikatan.  Ini akan sangat menyederhanakan panggilan berikutnya. <br><br>  Tembolok delegasi, yang terletak di dalam CallSite sendiri, disebut polimorfik, karena delegasi ini dapat mengambil bentuk berbeda tergantung pada kode dinamis mana yang dijalankan dan aturan mana dari cache lain yang digunakan untuk membuatnya.  Cache delegate juga kadang-kadang disebut inline cache.  Alasan untuk menggunakan istilah ini adalah bahwa ekspresi yang dihasilkan oleh DLR dan pengikatnya dikonversi ke kode MSIL yang melewati kompilasi JIT, seperti kode .NET lainnya.  Kompilasi saat runtime terjadi bersamaan dengan eksekusi "normal" program Anda.  Jelas bahwa mengubah kode dinamis on-the-fly menjadi kode MSIL yang dikompilasi selama eksekusi program dapat sangat mempengaruhi kinerja aplikasi, sehingga mekanisme caching sangat penting. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469075/">https://habr.com/ru/post/id469075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469053/index.html">Serial video baru untuk pemula yang belajar pemrograman Python</a></li>
<li><a href="../id469059/index.html">Apa yang baru di ML.NET dan Model Builder</a></li>
<li><a href="../id469061/index.html">Rilis Rust 1.38.0: kompilasi pipelined, # [usang] untuk makro dan std :: any :: type_name</a></li>
<li><a href="../id469071/index.html">Inteligensi Buatan Microsoft menguasai mahjong</a></li>
<li><a href="../id469073/index.html">Derivatif Terpisah atau Ringkasan Cara Menjumlahkan Seri</a></li>
<li><a href="../id469077/index.html">Kursus Python Baru Microsoft [dalam bahasa Inggris]</a></li>
<li><a href="../id469079/index.html">Python dalam Visual Studio Code: September Extension Extension</a></li>
<li><a href="../id469085/index.html">Kami mengeluarkan perangkat lunak dari mikrokontroler yang dilindungi kata sandi Renesas M16C</a></li>
<li><a href="../id469087/index.html">MVCC di PostgreSQL-2. Fork, file, halaman</a></li>
<li><a href="../id469093/index.html">Perbandingan perpustakaan CLI yang kurang populer dan tidak terlalu: cliff, plac, plumbum, dan lain-lain (bagian 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>