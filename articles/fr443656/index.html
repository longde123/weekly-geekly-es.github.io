<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛏️ 🏘️ 🧖🏻 Sur les traces des calculatrices: Qalculate 🤦🏾 👧🏼 🤕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Auparavant, nous avons effectué des révisions de code de grands packages mathématiques, par exemple, Scilab et Octave, où les calculatrices sont resté...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sur les traces des calculatrices: Qalculate</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/443656/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8-/gy/xn/8-gyxngfcuknt6ufomhpg4kpjry.png"></div><br>  Auparavant, nous avons effectué des révisions de code de grands packages mathématiques, par exemple, Scilab et Octave, où les calculatrices sont restées à l'écart en tant que petits utilitaires, dans lesquels il est difficile de faire des erreurs en raison de leur petite base de code.  Nous avions tort de ne pas leur avoir prêté attention.  Le cas de la publication du code source de la calculatrice Windows a montré qu'en fait, tout le monde était intéressé à discuter des types d'erreurs qui s'y cachent.  De plus, le nombre d'erreurs était largement suffisant pour écrire un article à ce sujet.  Mes collègues et moi, nous avons décidé d'explorer le code d'un certain nombre de calculatrices populaires, et il s'est avéré que le code de la calculatrice Windows n'était pas si mauvais (spoiler). <br><a name="habracut"></a><br><h2>  Présentation </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Calculez!</a>  est une calculatrice de bureau multi-plateforme multi-usages.  Il est simple à utiliser, mais offre une puissance et une polyvalence normalement réservées aux packages mathématiques complexes, ainsi que des outils utiles pour les besoins quotidiens (tels que la conversion de devises et le calcul du pourcentage).  Le projet se compose de deux composants: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">libqalculate</a> (bibliothèque et CLI) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qalculate-gtk</a> (GTK + UI).  L'étude ne portait que sur le code libqalculate. <br><br>  Pour comparer facilement le projet avec Windows Calculator, que nous avons récemment vérifié, je cite la sortie de l'utilitaire Cloc pour libqalculate: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/214/1f7/e35/2141f7e35bc5af14579e61f9bf4d907a.png"></div><br>  En le considérant subjectivement, il contient plus d'erreurs et elles sont plus critiques que dans le code de la calculatrice Windows.  Néanmoins, je recommanderais de tirer des conclusions par vous-même, après avoir lu cet aperçu du code. <br><br>  À propos, voici un lien vers un article sur la vérification de la calculatrice de Microsoft: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Counting Bugs in Windows Calculator</a> ". <br><br>  L'outil d'analyse est l'analyseur de code statique <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio</a> .  Il s'agit d'un ensemble de solutions pour le contrôle de la qualité du code, la recherche de bogues et les vulnérabilités potentielles.  Les langages pris en charge incluent: C, C ++, C # et Java.  Vous pouvez exécuter l'analyseur sur Windows, Linux et macOS. <br><br><h2>  Copiez-collez et Typos à nouveau! </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V523</a> L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">instruction</a> 'then' est équivalente à l'instruction 'else'.  Number.cc 4018 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Number::square() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mpfr_cmpabs(i_value-&gt;internalLowerFloat(), i_value-&gt;internalUpperFloat()) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { mpfr_sqr(f_tmp, i_value-&gt;internalLowerFloat(), MPFR_RNDU); mpfr_sub(f_rl, f_rl, f_tmp, MPFR_RNDD); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mpfr_sqr(f_tmp, i_value-&gt;internalLowerFloat(), MPFR_RNDU); mpfr_sub(f_rl, f_rl, f_tmp, MPFR_RNDD); } .... }</code> </pre> <br>  Le code est absolument le même dans les blocs <i>if</i> et <i>else</i> <i>.</i>  Les fragments de code adjacents sont très similaires à celui-ci, mais différentes fonctions y sont utilisées: <i>internalLowerFloat ()</i> et <i>internalUpperFloat ()</i> .  Il est sûr de supposer qu'un développeur a copié le code et oublié de corriger le nom de la fonction ici. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques '! Mtr2.number (). IsReal ()' à gauche et à droite de '||'  opérateur.  BuiltinFunctions.cc 6274 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> IntegrateFunction::calculate(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!mtr2.isNumber() || !mtr2.number().isReal() || !mtr.isNumber() || !mtr2.number().isReal()) b_unknown_precision = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... }</code> </pre> <br>  Dans ce cas, des expressions dupliquées sont apparues en raison du fait qu'à un endroit <i>mtr2 a</i> été écrit au lieu de <i>mtr.</i>  Ainsi, un appel de la fonction <i>mtr.number (). IsReal ()</i> est absent dans la condition. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V501</a> Il existe des sous-expressions identiques «vargs [1] .representNonPositive ()» à gauche et à droite de «||»  opérateur.  BuiltinFunctions.cc 5785 <br><br><br><br>  Nous n'aurions jamais trouvé de défauts dans ce code manuellement!  Mais voilà.  De plus, dans le fichier d'origine, ces fragments sont écrits sur une seule ligne.  L'analyseur a détecté une expression dupliquée <i>vargs [1] .representNonPositive ()</i> , qui peut indiquer une faute de frappe ou, par conséquent, une erreur potentielle. <br><br>  Voici la liste complète des endroits suspects, que l'on peut à peine décoder. <br><br><ul><li>  V501 Il existe des sous-expressions identiques «vargs [1] .representNonPositive ()» à gauche et à droite de «||»  opérateur.  BuiltinFunctions.cc 5788 </li><li>  V501 Il existe des sous-expressions identiques «ajouter» à gauche et à droite de l'opérateur «&amp;&amp;».  MathStructure.cc 1780 </li><li>  V501 Il existe des sous-expressions identiques «ajouter» à gauche et à droite de l'opérateur «&amp;&amp;».  MathStructure.cc 2043 </li><li>  V501 Il existe des sous-expressions identiques '(* v_subs [v_order [1]]). ReprésenteNégatif (vrai)' à gauche et à droite de l'opérateur '&amp;&amp;'.  MathStructure.cc 5569 </li></ul><br><h2>  Boucle avec condition incorrecte </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V534</a> Il est probable qu'une mauvaise variable soit comparée à l'intérieur de l'opérateur 'for'.  Pensez à revoir «i».  MathStructure.cc 28741 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> MathStructure::isolate_x_sub(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mvar-&gt;size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((*mvar)[i].contains(x_var)) { mvar2 = &amp;(*mvar)[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mvar-&gt;isMultiplication()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mvar2-&gt;size(); i2++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((*mvar2)[i2].contains(x_var)) {mvar2 = &amp;(*mvar2)[i2]; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  Dans la boucle interne, la variable <i>i2</i> représente un compteur, mais en raison d'une faute de frappe, une erreur a été commise - la variable <i>i</i> de la boucle externe est utilisée dans la condition de sortie de la boucle. <br><br><h2>  Redondance ou erreur? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V590</a> Envisagez d'inspecter cette expression.  L'expression est excessive ou contient une erreur d'impression.  Number.cc 6564 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Number::add(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Number &amp;o, MathOperation op) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i1 &gt;= COMPARISON_RESULT_UNKNOWN &amp;&amp; (i2 == COMPARISON_RESULT_UNKNOWN || i2 != COMPARISON_RESULT_LESS)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... }</code> </pre> <br>  Il y a 3 ans après avoir eu un aperçu de ce code, j'ai écrit une feuille de triche pour moi et d'autres développeurs: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Expressions logiques en C / C ++. Erreurs commises par des professionnels</a> ". Quand je tombe sur un tel code, je m'assure que la note n'est pas devenu moins pertinent.  Vous pouvez consulter l'article, trouver un modèle d'erreur correspondant au code et découvrir toutes les nuances. <br><br>  Dans le cas de cet exemple, nous irons à la section «Expression == ||  ! = "Et découvrez que l'expression <i>i2 == COMPARISON_RESULT_UNKNOWN</i> n'affecte rien. <br><br><h2>  Déréférencer les pointeurs non contrôlés </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V595</a> Le pointeur 'o_data' a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 1108, 1112. DataSet.cc 1108 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> DataObjectArgument::subprintlong() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> str = _(<span class="hljs-string"><span class="hljs-string">"an object from"</span></span>); str += <span class="hljs-string"><span class="hljs-string">" \""</span></span>; str += o_data-&gt;title(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= str += "\""; DataPropertyIter it; DataProperty *o = NULL; if(o_data) { // &lt;= o = o_data-&gt;getFirstProperty(&amp;it); } .... }</span></span></code> </pre> <br>  Dans une fonction, le pointeur <i>o_data</i> est déréférencé à la fois sans et avec une vérification.  Cela peut être du code redondant ou une erreur potentielle.  Je me penche vers ce dernier. <br><br>  Il y a deux endroits similaires: <br><br><ul><li>  V595 Le pointeur 'o_assumption' a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 229, 230. Variable.cc 229 </li><li>  V595 Le pointeur 'i_value' a été utilisé avant d'être vérifié par rapport à nullptr.  Vérifiez les lignes: 3412, 3427. Number.cc 3412 </li></ul><br><h2>  gratuit () ou supprimer []? </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V611</a> La mémoire a été allouée à l'aide de l'opérateur "nouveau" mais a été libérée à l'aide de la fonction "libre".  Pensez à inspecter les logiques d'opération derrière la variable «remcopy».  Number.cc 8123 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Number::print(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!exact &amp;&amp; precision2 &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(try_infinite_series) { remcopy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mpz_t</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// &lt;= mpz_init_set(*remcopy, remainder); } mpz_mul_si(remainder, remainder, base); mpz_tdiv_qr(remainder, remainder2, remainder, d); exact = (mpz_sgn(remainder2) == 0); if(!started) { started = (mpz_sgn(remainder) != 0); } if(started) { mpz_mul_si(num, num, base); mpz_add(num, num, remainder); } if(try_infinite_series) { if(started &amp;&amp; first_rem_check == 0) { remainders.push_back(remcopy); } else { if(started) first_rem_check--; mpz_clear(*remcopy); free(remcopy); // &lt;= } } .... } .... }</span></span></code> </pre> <br>  La mémoire du tableau <i>remcopy</i> est allouée et libérée de différentes manières, ce qui est une grave erreur. <br><br><h2>  Changements perdus </h2><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expand_partial_fractions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MathStructure &amp;m, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(b_poly &amp;&amp; !mquo.isZero()) { MathStructure m = mquo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!mrem.isZero()) { m += mrem; m.last() *= mtest[i]; m.childrenUpdated(); } expand_partial_fractions(m, eo, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  La variable <i>m</i> dans la fonction est passée par référence, ce qui signifie sa modification.  Cependant, l'analyseur a détecté que le code contient la variable avec le même nom, qui chevauche la portée du paramètre de la fonction, permettant la perte de modifications. <br><br><h2>  Pointeurs étranges </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V774</a> Le pointeur «cu» a été utilisé après la libération de la mémoire.  Calculator.cc 3595 <br><br><pre> <code class="cpp hljs">MathStructure Calculator::convertToBestUnit(....) { .... CompositeUnit *cu = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositeUnit(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"...."</span></span>); cu-&gt;add(....); Unit *u = getBestUnit(cu, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, eo.local_currency_conversion); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(u == cu) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> cu; <span class="hljs-comment"><span class="hljs-comment">// &lt;= return mstruct_new; } delete cu; // &lt;= if(eo.approximation == APPROXIMATION_EXACT &amp;&amp; cu-&gt;hasApproximateRelationTo(u, true)) { // &lt;= if(!u-&gt;isRegistered()) delete u; return mstruct_new; } .... }</span></span></code> </pre> <br>  L'analyseur avertit que le code appelle une méthode de l'objet <i>cu</i> juste après la désallocation de la mémoire.  Mais quand on essaie de s'y attaquer, le code s'avère encore plus étrange.  Premièrement, appeler <i>delete cu</i> se produit toujours - à la fois dans la condition et après cela.  Deuxièmement, le code après la condition implique que les pointeurs <i>u</i> et <i>cu</i> ne sont pas égaux, ce qui signifie qu'après la suppression de l'objet <i>cu</i> , il est tout à fait logique d'utiliser l'objet <i>u</i> .  Très probablement, une faute de frappe a été faite dans le code et l'auteur du code voulait utiliser uniquement la variable <i>u</i> . <br><br><h2>  Utilisation de la fonction de recherche </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V797</a> La fonction 'find' est utilisée comme si elle retournait un type booléen.  La valeur de retour de la fonction doit probablement être comparée à std :: string :: npos.  Unit.cc 404 <br><br><pre> <code class="cpp hljs">MathStructure &amp;AliasUnit::convertFromFirstBaseUnit(....) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i_exp != <span class="hljs-number"><span class="hljs-number">1</span></span>) mexp /= i_exp; ParseOptions po; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isApproximate() &amp;&amp; suncertainty.empty() &amp;&amp; precision() == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sinverse.find(DOT) || svalue.find(DOT)) po.read_precision = READ_PRECISION_WHEN_DECIMALS; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> po.read_precision = ALWAYS_READ_PRECISION; } .... }</code> </pre> <br>  Même si le code peut être compilé avec succès, il semble suspect, car la fonction <i>find</i> renvoie le numéro du type <i>std :: string :: size_type</i> .  La condition sera vraie si le point est trouvé dans n'importe quelle partie de la chaîne sauf si le point est au début.  C'est un étrange chèque.  Je ne suis pas sûr mais, peut-être, ce code devrait être réécrit comme suit: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sinverse.find(DOT) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos || svalue.find(DOT) != <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { po.read_precision = READ_PRECISION_WHEN_DECIMALS; }</code> </pre> <br><h2>  Fuite potentielle de mémoire </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">V701</a> realloc () fuite possible: lorsque realloc () échoue dans l'allocation de mémoire, le «tampon» du pointeur d'origine est perdu.  Pensez à affecter realloc () à un pointeur temporaire.  util.cc 703 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">utf8_strdown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *str, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> HAVE_ICU .... outlength = length + 4; buffer = (char*) realloc(buffer, outlength * sizeof(char)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= .... #else return NULL; #endif }</span></span></span></span></code> </pre> <br>  Lorsque vous travaillez avec la fonction <i>realloc ()</i> , il est recommandé d'utiliser un tampon intermédiaire, car dans le cas où il est impossible d'allouer de la mémoire, le pointeur vers l'ancienne zone de mémoire sera irrémédiablement perdu. <br><br><h2>  Conclusion </h2><br>  Le Qalculate!  Le projet arrive en tête de liste des meilleures calculatrices gratuites, alors qu'il contient de nombreuses erreurs graves.  D'un autre côté, nous n'avons pas encore vérifié ses concurrents.  Nous allons essayer de parcourir toutes les calculatrices populaires. <br><br>  En ce qui concerne la comparaison avec la qualité de la calculatrice du monde Windows, l'utilitaire de Microsoft semble jusqu'à présent plus fiable et bien travaillé. <br><br>  Vérifiez votre propre «calculatrice» - téléchargez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PVS-Studio</a> et essayez-le pour votre projet.  :-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr443656/">https://habr.com/ru/post/fr443656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr443644/index.html">Rouler les œufs avec Unity</a></li>
<li><a href="../fr443648/index.html">Documentation utilisateur: qu'est-ce qui la rend mauvaise et comment y remédier</a></li>
<li><a href="../fr443650/index.html">Pas du tout et pas de tic. Quelle est la différence entre les processeurs Intel Core de différentes générations basés sur une architecture</a></li>
<li><a href="../fr443652/index.html">Chaque jour sur Outlook j'ai juste de la farine ...</a></li>
<li><a href="../fr443654/index.html">Suivre la trace des calculatrices: Qalculate</a></li>
<li><a href="../fr443658/index.html">Configuration du cluster Kubernetes HA sur du métal nu, surveillance, journaux et exemples d'utilisation. Partie 3/3</a></li>
<li><a href="../fr443660/index.html">Experts: «Un scanner 3D coûtera 10 fois moins cher qu'une erreur avec un contrôle qualité traditionnel»</a></li>
<li><a href="../fr443662/index.html">Comprendre le code propre sur Android</a></li>
<li><a href="../fr443664/index.html">Station météo Arduino</a></li>
<li><a href="../fr443666/index.html">Notre approche de la coloration des fils</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>