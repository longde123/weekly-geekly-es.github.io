<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïì ü•ä üßëüèø‚Äçü§ù‚Äçüßëüèª Roubar: quem rouba o tempo do processador de m√°quinas virtuais üë®üèª‚ÄçüöÄ üßó ‚òùüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Quero falar em linguagem clara sobre a mec√¢nica do surgimento de roubo dentro de m√°quinas virtuais e sobre alguns artefatos n√£o √≥bvios que consegui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Roubar: quem rouba o tempo do processador de m√°quinas virtuais</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/449316/"><img src="https://habrastorage.org/getpro/habr/post_images/af7/c70/8aa/af7c708aa619490409ed5cf46d9c96fa.jpg"><br><br>  Oi  Quero falar em linguagem clara sobre a mec√¢nica do surgimento de roubo dentro de m√°quinas virtuais e sobre alguns artefatos n√£o √≥bvios que conseguimos descobrir durante sua pesquisa, nos quais tive que mergulhar como t√©cnico da plataforma de nuvem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mail.ru Cloud Solutions</a> .  A plataforma √© executada no KVM. <br><br>  Tempo de roubo de CPU √© o tempo durante o qual a m√°quina virtual n√£o recebe recursos do processador para sua execu√ß√£o.  Esse tempo √© considerado apenas em sistemas operacionais convidados em ambientes de virtualiza√ß√£o.  As raz√µes pelas quais esses recursos muito alocados v√£o, como na vida, s√£o muito vagas.  Mas decidimos descobrir e at√© montar uma s√©rie de experimentos.  N√£o que agora saibamos tudo sobre roubar, mas contaremos uma coisa interessante agora. <br><a name="habracut"></a><br><h2>  1. O que √© roubar </h2><br>  Portanto, roubar √© uma m√©trica que indica falta de tempo do processador para processos dentro de uma m√°quina virtual.  Conforme descrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no patch do kVM do KVM</a> , roubo √© o tempo durante o qual o hypervisor executa outros processos no sistema operacional host, embora tenha colocado na fila o processo da m√°quina virtual para execu√ß√£o.  Ou seja, roubar √© considerado como a diferen√ßa entre o tempo em que o processo est√° pronto para executar e o tempo em que o processador recebe o tempo do processo. <br><br>  O kernel recebe o roubo de m√©trica do hipervisor.  Ao mesmo tempo, o hipervisor n√£o especifica exatamente quais outros processos ele executa, simplesmente "enquanto estou ocupado, n√£o posso lhe dar tempo".  No KVM, o suporte √† contagem de roubo foi adicionado aos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">patches</a> .  Existem dois pontos principais aqui: <br><br><ul><li>  A m√°quina virtual aprende sobre roubar do hipervisor.  Ou seja, do ponto de vista de perdas, para processos na pr√≥pria m√°quina virtual, √© uma medida indireta que pode estar sujeita a v√°rias distor√ß√µes. <br></li><li> O hipervisor n√£o compartilha informa√ß√µes com a m√°quina virtual sobre o que est√° fazendo com outras pessoas - o principal √© que ele n√£o dedica tempo a elas.  Por esse motivo, a pr√≥pria m√°quina virtual n√£o pode detectar distor√ß√µes no √≠ndice de roubo, o que pode ser estimado pela natureza dos processos concorrentes. <br></li></ul><br><h2>  2. O que afeta roubar </h2><br><h3>  2.1  Roubo de c√°lculo </h3><br>  De fato, o roubo √© considerado aproximadamente o mesmo que o tempo normal de utiliza√ß√£o da CPU.  N√£o h√° muita informa√ß√£o sobre como o descarte √© considerado.  Provavelmente porque a maioria considera essa quest√£o √≥bvia.  Mas tamb√©m existem armadilhas aqui.  Para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">se</a> familiarizar com esse processo, voc√™ pode ler o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo de Brendann Gregg</a> : voc√™ aprender√° sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√°rias</a> nuances no c√°lculo de utiliza√ß√£o e sobre situa√ß√µes em que esse c√°lculo ser√° incorreto pelos seguintes motivos: <br><br><ul><li>  Superaquecimento do processador, durante o qual os ciclos do rel√≥gio s√£o ignorados. <br></li><li>  Ligue / desligue o turbo boost, como resultado da altera√ß√£o da frequ√™ncia do clock do processador. <br></li><li>  Uma altera√ß√£o na dura√ß√£o de um quantum de tempo que ocorre ao usar tecnologias de economia de energia do processador, como o SpeedStep. <br></li><li>  O problema de calcular a m√©dia: uma estimativa de utiliza√ß√£o dentro de um minuto a 80% pode ocultar uma explos√£o de curto prazo em 100%. <br></li><li>  O bloqueio c√≠clico (bloqueio de rota√ß√£o) leva ao fato de o processador ser descartado, mas o processo do usu√°rio n√£o v√™ progresso em sua execu√ß√£o.  Como resultado, a utiliza√ß√£o estimada do processador pelo processo ser√° de cem por cento, embora o processo n√£o consuma fisicamente o tempo do processador. <br></li></ul><br>  N√£o encontrei um artigo descrevendo um c√°lculo semelhante para roubar (se voc√™ souber, compartilhe nos coment√°rios).  Mas, a julgar pela fonte, o mecanismo de c√°lculo √© o mesmo que para o descarte.  √â apenas que outro contador √© adicionado ao kernel, diretamente para o processo KVM (processo de m√°quina virtual), que conta o tempo que o processo KVM fica no estado de espera do tempo do processador.  O contador obt√©m informa√ß√µes sobre o processador de suas especifica√ß√µes e procura verificar se todos os seus ticks foram utilizados pelo processo virtual.  Se isso √© tudo, acreditamos que o processador estava envolvido apenas no processo da m√°quina virtual.  Caso contr√°rio, informamos que o processador estava fazendo outra coisa, o roubo apareceu. <br><br>  O processo de contagem de roubo est√° sujeito aos mesmos problemas da contagem regular de reciclagem.  Para n√£o dizer que esses problemas aparecem com frequ√™ncia, mas parecem desanimadores. <br><br><h3>  2.2  Tipos de virtualiza√ß√£o no KVM </h3><br>  De um modo geral, existem tr√™s tipos de virtualiza√ß√£o, e todos eles s√£o suportados pelo KVM.  O tipo de virtualiza√ß√£o pode determinar o mecanismo pelo qual o roubo ocorre. <br><br>  <b>Difus√£o</b>  Nesse caso, a opera√ß√£o do sistema operacional da m√°quina virtual com os dispositivos f√≠sicos do hypervisor ocorre aproximadamente da seguinte maneira: <br><br><ol><li>  O sistema operacional convidado envia um comando para seu dispositivo convidado. <br></li><li>  O driver de dispositivo convidado aceita o comando, gera uma solicita√ß√£o para o BIOS do dispositivo e o envia ao hipervisor. <br></li><li>  O processo do hypervisor converte um comando em um comando para um dispositivo f√≠sico, tornando-o, entre outros, mais seguro. <br></li><li>  O driver de dispositivo f√≠sico aceita o comando modificado e o envia para o pr√≥prio dispositivo f√≠sico. <br></li><li>  Os resultados da execu√ß√£o do comando retornam pelo mesmo caminho. <br></li></ol><br>  A vantagem da tradu√ß√£o √© que ela permite emular qualquer dispositivo e n√£o requer prepara√ß√£o especial do kernel do sistema operacional.  Mas voc√™ tem que pagar por isso, antes de tudo, com rapidez. <br><br>  <b>Virtualiza√ß√£o de hardware</b> .  Nesse caso, o dispositivo no n√≠vel do hardware entende os comandos do sistema operacional.  Esta √© a maneira mais r√°pida e melhor.  Infelizmente, por√©m, ele n√£o √© suportado por todos os dispositivos f√≠sicos, hipervisores e sistemas operacionais convidados.  Atualmente, os principais dispositivos que suportam a virtualiza√ß√£o de hardware s√£o processadores. <br><br>  <b>Paravirtualiza√ß√£o (paravirtualiza√ß√£o)</b> .  A vers√£o mais comum da virtualiza√ß√£o de dispositivos no KVM e geralmente o modo de virtualiza√ß√£o mais comum para sistemas operacionais convidados.  Sua peculiaridade √© que trabalha com alguns subsistemas do hypervisor (por exemplo, com uma rede ou pilha de discos) ou a aloca√ß√£o de p√°ginas de mem√≥ria ocorre usando a API do hypervisor, sem converter comandos de baixo n√≠vel.  A desvantagem desse m√©todo de virtualiza√ß√£o √© a necessidade de modificar o kernel do sistema operacional convidado para que ele possa interagir com o hipervisor usando essa API.  Mas geralmente isso √© resolvido com a instala√ß√£o de drivers especiais no sistema operacional convidado.  No KVM, essa API √© chamada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">API virtio</a> . <br><br>  Com a paravirtualiza√ß√£o, em compara√ß√£o com a tradu√ß√£o, o caminho para o dispositivo f√≠sico √© reduzido significativamente enviando comandos diretamente da m√°quina virtual para o processo do hypervisor do host.  Isso permite acelerar a execu√ß√£o de todas as instru√ß√µes dentro da m√°quina virtual.  No KVM, a API virtio √© respons√°vel por isso, que funciona apenas para determinados dispositivos, como um adaptador de rede ou disco.  √â por isso que os drivers virtio s√£o colocados dentro de m√°quinas virtuais. <br><br>  O outro lado dessa acelera√ß√£o √© que nem todos os processos executados dentro de uma m√°quina virtual permanecem dentro dela.  Isso cria alguns efeitos especiais que podem levar ao roubo de apar√™ncias.  Eu recomendo iniciar um estudo detalhado desse problema com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma API para E / S virtual: virtio</a> . <br><br><h3>  2.3  Fair Sheduling </h3><br>  A virtualiza√ß√£o em um hipervisor √©, de fato, um processo comum que obedece √†s leis de sheduling (aloca√ß√£o de recursos entre processos) no kernel do Linux; portanto, consideraremos mais detalhadamente. <br><br>  O Linux usa o chamado CFS, Completely Fair Scheduler, que se tornou o despachante padr√£o desde o kernel 2.6.23.  Para entender esse algoritmo, voc√™ pode ler a Arquitetura ou as Fontes do Kernel do Linux.  A ess√™ncia do CFS √© a distribui√ß√£o do tempo do processador entre os processos, dependendo da dura√ß√£o de sua execu√ß√£o.  Quanto mais tempo o processador exigir, menos esse tempo receber√°.  Isso garante a execu√ß√£o "honesta" de todos os processos - para que um processo n√£o ocupe constantemente todos os processadores e outros processos tamb√©m possam ser executados. <br><br>  √Äs vezes, esse paradigma leva a artefatos interessantes.  Os usu√°rios de longa data do Linux provavelmente se lembrar√£o do desbotamento de um editor de texto de desktop comum enquanto executam aplicativos exigentes do tipo compilador.  Isso aconteceu porque tarefas de aplicativos de √°rea de trabalho que n√£o consomem muitos recursos competem com tarefas que consomem recursos ativamente, como um compilador.  O CFS considera isso desonesto, portanto periodicamente interrompe o editor de texto e permite que o processador processe as tarefas do compilador.  Isso foi corrigido usando o mecanismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sched_autogroup</a> , mas muitos outros recursos da distribui√ß√£o do tempo da CPU entre tarefas permaneceram.  Na verdade, essa hist√≥ria n√£o √© sobre como as coisas est√£o ruins no CFS, mas uma tentativa de chamar a aten√ß√£o para o fato de que uma distribui√ß√£o ‚Äúhonesta‚Äù do tempo do processador n√£o √© a tarefa mais trivial. <br><br>  Outro ponto importante no sheduler √© a preemp√ß√£o.  Isso √© necess√°rio para conduzir o processo de risonho do processador e permitir que outras pessoas funcionem.  O processo de ex√≠lio √© chamado de altern√¢ncia de contexto, altern√¢ncia de contexto do processador.  Nesse caso, todo o contexto da tarefa √© salvo: o estado da pilha, registradores, etc., ap√≥s o qual o processo espera e outro substitui.  Essa √© uma opera√ß√£o cara para o sistema operacional e raramente √© usada, mas, na verdade, n√£o h√° nada de errado com ela.  A mudan√ßa frequente de contexto pode indicar um problema no sistema operacional, mas geralmente continua continuamente e n√£o indica nada em particular. <br><br>  Uma hist√≥ria t√£o longa √© necess√°ria para explicar um fato: quanto mais recursos de processador um honesto sheduler do Linux tentar consumir, mais r√°pido ser√° interrompido para que outros processos funcionem tamb√©m.  Se isso est√° correto ou n√£o, √© um problema complexo, resolvido de maneira diferente sob diferentes cargas.  No Windows, at√© recentemente, o sheduler estava focado no processamento priorit√°rio de aplicativos de desktop, por causa dos quais os processos em segundo plano podiam travar.  A Sun Solaris tinha cinco classes diferentes de shedulers.  Quando eles come√ßaram a virtualiza√ß√£o, adicionaram o sexto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">agendador de compartilhamento justo</a> , porque os cinco anteriores trabalhavam inadequadamente com a virtualiza√ß√£o do Solaris Zones.  Eu recomendo iniciar um estudo detalhado desse problema com livros como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Solaris Internals: Solaris 10 e OpenSolaris Kernel Architecture</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Entendendo o kernel do Linux</a> . <br><br><h3>  2.4  Como monitorar o roubo? </h3><br>  O monitoramento de roubo dentro de uma m√°quina virtual, como qualquer outra m√©trica do processador, √© simples: voc√™ pode usar qualquer meio de remover as m√©tricas do processador.  O principal √© que a m√°quina virtual est√° no Linux.  Por alguma raz√£o, o Windows n√£o fornece essas informa√ß√µes aos seus usu√°rios.  :( <br><br><img src="https://habrastorage.org/getpro/habr/post_images/804/731/75c/80473175cd23f0ba8721ca61c65fe111.png"><br>  <i>A sa√≠da do comando top: detalhes da carga do processador, na coluna da direita - steal</i> <br><br>  A dificuldade surge ao tentar obter essas informa√ß√µes do hipervisor.  Voc√™ pode tentar prever o roubo na m√°quina host, por exemplo, pelo par√¢metro Load Average (LA) - o valor m√©dio do n√∫mero de processos aguardando na fila para execu√ß√£o.  A metodologia para calcular esse par√¢metro n√£o √© simples, mas, em geral, se LA, normalizada pelo n√∫mero de threads do processador, for maior que 1, isso indica que o servidor Linux est√° um pouco sobrecarregado. <br><br>  Quais s√£o todos esses processos aguardando?  A resposta √≥bvia √© o processador.  Mas a resposta n√£o est√° totalmente correta, porque √†s vezes o processador √© gratuito e LA √© transferida.  Lembre-se de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como o NFS cai e como LA cresce</a> .  Pode ser aproximadamente o mesmo com um disco e com outros dispositivos de entrada / sa√≠da.  Mas, na verdade, os processos podem esperar o fim de qualquer bloqueio, tanto f√≠sico, associado a um dispositivo de E / S, quanto l√≥gico, como um mutex.  Isso tamb√©m inclui bloqueios no n√≠vel do hardware (a mesma resposta do disco) ou l√≥gica (as chamadas primitivas de bloqueio, que incluem v√°rias entidades, adaptabilidade e rota√ß√£o mutex, sem√°foros, vari√°veis ‚Äã‚Äãde condi√ß√£o, bloqueios rw, bloqueios ipc ...). <br><br>  Outra caracter√≠stica do LA √© que ele √© considerado como o valor m√©dio para o sistema operacional.  Por exemplo, 100 processos competem por um arquivo e, em seguida, LA = 50.  Um valor t√£o grande, ao que parece, sugere que o sistema operacional √© ruim.  Mas para outro c√≥digo torto, este pode ser um estado normal, apesar de ser ruim apenas para ele, e outros processos no sistema operacional n√£o sofrerem. <br><br>  Devido a essa m√©dia (e n√£o menos de um minuto), determinar algo pelo indicador de AL n√£o √© a tarefa mais grata, com resultados muito incertos em casos espec√≠ficos.  Se voc√™ tentar descobrir, descobrir√° que apenas os casos mais simples s√£o descritos nos artigos da Wikipedia e em outros recursos dispon√≠veis, sem uma explica√ß√£o profunda do processo.  Eu mando todos os interessados, novamente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui, para Brendann Gregg</a> - mais nos links.  Para quem a pregui√ßa em ingl√™s √© uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradu√ß√£o de seu popular artigo sobre LA</a> . <br><br><h2>  3. efeitos especiais </h2><br>  Agora vamos nos debru√ßar nos principais casos de roubo que encontramos.  Vou lhe contar como eles seguem o que foi dito acima e como eles se relacionam com os indicadores no hipervisor. <br><br>  <b>Reciclagem</b> .  O mais simples e mais frequente: o hipervisor √© reutilizado.  De fato, existem muitas m√°quinas virtuais em execu√ß√£o, um grande consumo de processador dentro delas, muita concorr√™ncia, a utiliza√ß√£o de LA √© superior a 1 (normalizada pelos encadeamentos do processador).  Dentro de todos os virtualoks, tudo diminui.  O roubo transmitido a partir do hipervisor tamb√©m est√° crescendo, √© necess√°rio redistribuir a carga ou desligar algu√©m.  Em geral, tudo √© l√≥gico e compreens√≠vel. <br><br>  <b>Paravirtualiza√ß√£o versus inst√¢ncias √∫nicas</b> .  H√° uma √∫nica m√°quina virtual no hipervisor, que consome uma pequena parte dela, mas fornece uma grande carga na entrada / sa√≠da, por exemplo, em um disco.  E de algum lugar, um pequeno roubo aparece, at√© 10% (como mostrado por v√°rias experi√™ncias). <br><br>  O caso √© interessante.  O roubo aparece aqui apenas por causa dos bloqueios no n√≠vel dos drivers paravirtualizados.  Uma interrup√ß√£o √© criada dentro da m√°quina virtual, processada pelo driver e vai para o hipervisor.  Devido ao processamento de interrup√ß√£o no hypervisor da m√°quina virtual, parece uma solicita√ß√£o enviada, est√° pronta para execu√ß√£o e aguardando o processador, mas eles n√£o concedem tempo ao processador.  Virtualka acha que desta vez foi roubado. <br><br>  Isso acontece quando o buffer √© enviado, ele vai para o espa√ßo do kernel do hypervisor e come√ßamos a esperar por ele.  Embora, do ponto de vista do virtualka, ele deva retornar imediatamente.  Portanto, de acordo com o algoritmo de c√°lculo de roubo, esse tempo √© considerado roubado.  Provavelmente, nessa situa√ß√£o, pode haver outros mecanismos (por exemplo, processamento de outras chamadas do sistema), mas eles n√£o devem ser muito diferentes. <br><br>  <b>Sheduler contra virtualoks muito carregados</b> .  Quando uma m√°quina virtual sofre mais roubos do que outras, ela √© conectada precisamente ao sheduler.  Quanto mais forte o processo carregar o processador, mais cedo o sheduler o expulsar√°, para que os outros tamb√©m possam trabalhar.  Se a m√°quina virtual consome um pouco, ela quase n√£o v√™ roubo: seu processo honestamente ficou parado e aguardou, √© necess√°rio dar mais tempo a ele.  Se a m√°quina virtual produz a carga m√°xima em todos os seus n√∫cleos, ela geralmente √© expulsa do processador e tenta n√£o dar muito tempo. <br><br>  Pior ainda, quando os processos dentro da m√°quina virtual tentam obter mais processador, porque eles n√£o conseguem lidar com o processamento de dados.  Em seguida, o sistema operacional no hipervisor, devido √† otimiza√ß√£o honesta, fornecer√° cada vez menos tempo ao processador.  Esse processo ocorre como uma avalanche e o roubo salta para o c√©u, embora outras m√°quinas virtuais quase n√£o notem.  E quanto mais n√∫cleos, pior a m√°quina caiu sob a distribui√ß√£o.  Em resumo, as m√°quinas virtuais pesadamente carregadas e com muitos n√∫cleos sofrem mais. <br><br>  <b>Baixa LA, mas h√° um roubo</b> .  Se LA for de cerca de 0,7 (ou seja, o hipervisor parece estar sobrecarregado), mas o roubo √© observado em m√°quinas virtuais individuais: <br><br><ul><li>  A op√ß√£o descrita acima com paravirtualiza√ß√£o.  Uma m√°quina virtual pode receber m√©tricas que apontam para roubar, embora tudo esteja bem com o hipervisor.  De acordo com os resultados de nossas experi√™ncias, essa op√ß√£o de roubo n√£o excede 10% e n√£o deve ter um impacto significativo no desempenho do aplicativo dentro da m√°quina virtual. <br></li><li>  O par√¢metro LA √© considerado incorretamente.  Mais precisamente, a cada momento em particular √© considerado verdadeiro, mas, em m√©dia por um minuto, acaba sendo subestimado.  Por exemplo, se uma m√°quina virtual consome todos os seus processadores por exatamente meio minuto por ter√ßo do hypervisor, ent√£o LA por minuto ser√° de 0,15 no hypervisor;  quatro dessas m√°quinas virtuais trabalhando simultaneamente fornecer√£o 0,6.  E o fato de que por meio minuto em cada um deles houve um roubo de 25% em Los Angeles, n√£o pode mais ser retirado. <br></li><li>  Mais uma vez, por causa do comerciante que decidiu que algu√©m estava comendo demais e deixou este esperar.  Enquanto isso, estou mudando o contexto, processando interrup√ß√µes e fazendo outras coisas importantes no sistema.  Como resultado, algumas m√°quinas virtuais n√£o apresentam problemas, enquanto outras experimentam uma grave degrada√ß√£o do desempenho. <br></li></ul><br><h2>  4. Outras distor√ß√µes </h2><br>  H√° mais um milh√£o de raz√µes para distorcer o retorno honesto do tempo do processador na m√°quina virtual.  Por exemplo, hypertreading e NUMA adicionam complexidade aos c√°lculos.  Eles confundem completamente a escolha do kernel para executar o processo, porque o sheduler usa coeficientes - pesos, que ao trocar de contexto tornam o c√°lculo ainda mais dif√≠cil. <br><br>  Existem distor√ß√µes devido a tecnologias como o turbo boost ou, inversamente, o modo de economia de energia, que ao calcular a utiliza√ß√£o pode aumentar ou diminuir artificialmente a frequ√™ncia ou mesmo o tempo no servidor.  A ativa√ß√£o do turbo boost reduz o desempenho de um segmento do processador devido ao aumento do desempenho de outro.  Nesse momento, as informa√ß√µes sobre a frequ√™ncia atual do processador n√£o s√£o transmitidas para a m√°quina virtual e ela acredita que algu√©m est√° gastando seu tempo (por exemplo, ela solicitou 2 GHz, mas recebeu metade disso). <br><br>  Em geral, pode haver muitas causas de distor√ß√£o.  Em um sistema espec√≠fico, voc√™ pode encontrar outra coisa.  √â melhor come√ßar com os livros aos quais forneci os links acima e obter estat√≠sticas do hypervisor com utilit√°rios como perf, sysdig, systemtap, dos quais existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dezenas</a> . <br><br><h2>  5. Conclus√µes </h2><br><ol><li>  Uma certa quantidade de roubo pode ocorrer devido √† paravirtualiza√ß√£o e pode ser considerada normal.  Na Internet, eles escrevem que esse valor pode ser de 5 a 10%.  Depende dos aplicativos dentro da m√°quina virtual e do tipo de carga que ela coloca em seus dispositivos f√≠sicos.  √â importante prestar aten√ß√£o em como os aplicativos nas m√°quinas virtuais se sentem. <br></li><li>  A propor√ß√£o da carga no hipervisor e o roubo dentro da m√°quina virtual nem sempre √© interconectada de maneira inequ√≠voca, ambas as estimativas de roubo podem ser err√¥neas em situa√ß√µes espec√≠ficas com cargas diferentes. <br></li><li>  O Agendador n√£o gosta de processos que exigem muito.  Ele tenta dar menos para quem pede mais.  Grandes m√°quinas virtuais s√£o m√°s. <br></li><li>  Um pequeno roubo pode ser a norma sem paravirtualiza√ß√£o (levando em considera√ß√£o a carga dentro da m√°quina virtual, os recursos de carga dos vizinhos, a distribui√ß√£o de carga entre threads e outros fatores). <br></li><li>  Se voc√™ deseja descobrir roubo em um sistema espec√≠fico, √© necess√°rio pesquisar v√°rias op√ß√µes, coletar m√©tricas, analis√°-las cuidadosamente e pensar em como distribuir uniformemente a carga.  Desvios s√£o poss√≠veis em qualquer caso, que deve ser confirmado experimentalmente ou visualizado no depurador do kernel. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt449316/">https://habr.com/ru/post/pt449316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt449306/index.html">12 palavras em ingl√™s que s√£o frequentemente escritas e faladas incorretamente</a></li>
<li><a href="../pt449308/index.html">Apresentando o Microsoft Azure DevTest Labs</a></li>
<li><a href="../pt449310/index.html">Citymobil - um manual para melhorar a disponibilidade em meio ao crescimento dos neg√≥cios para startups. Parte 2</a></li>
<li><a href="../pt449312/index.html">RAID de hardware: Recursos de uso</a></li>
<li><a href="../pt449314/index.html">Imigra√ß√£o freelancer: o que voc√™ precisa saber</a></li>
<li><a href="../pt449318/index.html">Como o sucesso do Fortnite levou a meses de intensa crise na Epic Games</a></li>
<li><a href="../pt449320/index.html">Como a seguran√ßa da informa√ß√£o mudou nos √∫ltimos 20 anos</a></li>
<li><a href="../pt449322/index.html">Redes de TV a cabo para os menores. Parte 1: Arquitetura geral da rede KTV</a></li>
<li><a href="../pt449324/index.html">Cargas, smartphones, empresas gigantes: programa Heisenbug 2019 Piter</a></li>
<li><a href="../pt449326/index.html">WebRTC e vigil√¢ncia por v√≠deo: como derrotamos o atraso do v√≠deo das c√¢meras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>