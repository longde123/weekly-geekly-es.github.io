<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚒 🏮 🧑🏽 Perlindungan tanpa rasa takut. Keamanan Memori dalam Karat 🥧 🧙 🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mozilla merilis Quantum CSS untuk Firefox tahun lalu, yang memuncak dalam delapan tahun pengembangan Rust, bahasa pemrograman sistem yang ramah memori...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perlindungan tanpa rasa takut. Keamanan Memori dalam Karat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438288/"> Mozilla merilis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Quantum CSS</a> untuk Firefox tahun lalu, yang memuncak dalam delapan tahun pengembangan Rust, bahasa pemrograman sistem yang ramah memori.  Butuh lebih dari setahun untuk menulis ulang komponen browser utama di Rust. <br><br>  Sampai sekarang, semua mesin browser utama ditulis dalam C ++, terutama karena alasan efisiensi.  Tetapi dengan kinerja luar biasa muncul tanggung jawab besar: programmer C ++ harus mengelola memori secara manual, yang membuka kotak kerentanan Pandora.  Rust tidak hanya memperbaiki kesalahan seperti itu, tetapi metodenya juga mencegah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perlombaan data</a> , yang memungkinkan programmer untuk lebih efisien mengimplementasikan kode paralel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8bb/3c1/378/8bb3c13783ff1502b161e92f5818c2aa.jpg"></div><a name="habracut"></a><br><h1>  Apa itu keamanan memori? </h1><br>  Ketika kita berbicara tentang membuat aplikasi yang aman, kita sering menyebutkan keamanan memori.  Secara tidak resmi, kami bermaksud bahwa dalam keadaan apa pun program tidak dapat mengakses memori yang tidak valid.  Penyebab pelanggaran keamanan: <br><br><ul><li>  menyimpan pointer setelah membebaskan memori (gunakan-setelah-gratis); <br></li><li>  mendereferensi pointer nol; <br></li><li>  penggunaan memori yang tidak diinisialisasi; <br></li><li>  upaya program untuk membebaskan sel yang sama dua kali (bebas ganda); <br></li><li>  buffer overflow. </li></ul><br>  Untuk definisi yang lebih formal, lihat Michael Hicks <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">'Apa itu Keamanan Memori</a> , serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ilmiah</a> tentang topik ini. <br><br>  Pelanggaran semacam itu dapat menyebabkan crash yang tak terduga atau perubahan perilaku yang diharapkan dari program.  Konsekuensi potensial: kebocoran informasi, eksekusi kode arbitrer dan eksekusi kode jarak jauh. <br><br><h1>  Manajemen memori </h1><br>  Manajemen memori sangat penting untuk kinerja dan keamanan aplikasi.  Pada bagian ini, kami akan mempertimbangkan model memori dasar.  Salah satu konsep utama adalah <i>pointer</i> .  Ini adalah variabel di mana alamat memori disimpan.  Jika kita pergi ke alamat ini, kita akan melihat beberapa data di sana.  Oleh karena itu, kami mengatakan bahwa pointer adalah referensi ke data ini (atau menunjuk ke mereka).  Sama seperti alamat rumah memberi tahu orang-orang di mana menemukan Anda, alamat memori menunjukkan program tempat menemukan data. <br><br>  Segala sesuatu dalam program ini terletak di alamat memori tertentu, termasuk instruksi kode.  Penggunaan pointer yang tidak tepat dapat menyebabkan kerentanan serius, termasuk kebocoran informasi dan eksekusi kode arbitrer. <br><br><h3>  Alokasi / Rilis </h3><br>  Ketika kita membuat variabel, program harus mengalokasikan ruang yang cukup dalam memori untuk menyimpan data variabel ini.  Karena setiap proses memiliki jumlah memori yang terbatas, tentu saja, Anda memerlukan cara untuk <i>membebaskan</i> sumber daya.  Ketika memori dibebaskan, itu menjadi tersedia untuk menyimpan data baru, tetapi data lama tinggal di sana sampai sel ditimpa. <br><br><h3>  Buffer </h3><br>  <i>Buffer</i> adalah area memori yang berdekatan di mana beberapa instance dari tipe data yang sama disimpan.  Misalnya, frasa "Kucing saya adalah batman" akan disimpan dalam buffer 16 byte.  Buffer ditentukan oleh alamat awal dan panjangnya.  Agar tidak merusak data di memori tetangga, penting untuk memastikan bahwa kami tidak membaca atau menulis di luar buffer. <br><br><h3>  Mengontrol aliran </h3><br>  Program terdiri dari rutinitas yang dijalankan dalam urutan tertentu.  Di akhir subrutin, komputer pergi ke pointer yang disimpan ke bagian kode selanjutnya (disebut <i>alamat pengirim</i> ).  Ketika Anda pergi ke alamat pengirim, satu dari tiga hal terjadi: <br><br><ol><li>  Proses berlanjut secara normal (alamat pengirim tidak diubah). <br></li><li>  Proses macet (alamat telah diubah dan menunjuk ke memori yang tidak dapat dieksekusi). <br></li><li>  Proses berlanjut, tetapi tidak seperti yang diharapkan (alamat pengirim telah berubah dan aliran kontrol telah berubah). </li></ol><br><h1>  Bagaimana bahasa memberikan keamanan memori </h1><br>  Semua bahasa pemrograman milik bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spektrum yang berbeda</a> .  Di satu sisi spektrum adalah bahasa seperti C / C ++.  Mereka efektif, tetapi membutuhkan manajemen memori manual.  Di sisi lain, bahasa yang ditafsirkan dengan manajemen memori otomatis (misalnya, penghitungan referensi dan pengumpulan sampah), tetapi mereka terbayar dengan kinerja.  Bahkan bahasa dengan pengumpulan sampah yang dioptimalkan dengan baik tidak dapat dibandingkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kinerja</a> dengan bahasa tanpa GC. <br><br><h3>  Manajemen memori manual </h3><br>  Beberapa bahasa (misalnya, C) memerlukan programmer untuk mengelola memori secara manual: kapan dan berapa banyak memori yang dialokasikan, kapan harus membebaskannya.  Ini memberi programmer kontrol penuh atas bagaimana program menggunakan sumber daya, menyediakan kode yang cepat dan efisien.  Tetapi pendekatan ini rentan kesalahan, terutama dalam basis kode yang kompleks. <br><br>  Kesalahan yang mudah dilakukan: <br><br><ul><li>  lupakan bahwa sumber dayanya gratis dan cobalah untuk menggunakannya; <br></li><li>  jangan mengalokasikan ruang yang cukup untuk penyimpanan data; <br></li><li>  baca memori di luar buffer. </li></ul><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/657/0a0/242/6570a02427a2d03632cb41c73aa5a48d.jpg"></a> </div><br>  <i><font color="gray">Instruksi keselamatan yang cocok untuk mereka yang mengelola memori secara manual</font></i> <br><br><h3>  Pointer pintar </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pointer pintar</a> memberikan informasi tambahan untuk mencegah manajemen memori yang tidak tepat.  Mereka digunakan untuk manajemen memori otomatis dan pemeriksaan perbatasan.  Tidak seperti pointer biasa, pointer pintar dapat merusak diri sendiri dan tidak akan menunggu programmer untuk menghapusnya secara manual. <br><br>  Ada berbagai opsi untuk konstruksi seperti itu, yang membungkus pointer asli dalam beberapa abstraksi yang berguna.  Beberapa pointer cerdas <i>menghitung referensi</i> ke setiap objek, sementara yang lain menerapkan kebijakan pelingkupan untuk membatasi masa pakai pointer ke kondisi tertentu. <br><br>  Saat menghitung tautan, sumber daya dibebaskan ketika referensi terakhir ke objek dihapus.  Implementasi penghitungan referensi dasar mengalami kinerja yang buruk, peningkatan konsumsi memori, dan sulit digunakan di lingkungan multi-utas.  Jika objek merujuk satu sama lain (tautan sirkuler), maka jumlah referensi untuk setiap objek tidak akan pernah mencapai nol, sehingga diperlukan metode yang lebih kompleks. <br><br><h1>  Pengumpulan sampah </h1><br>  Beberapa bahasa (mis. Java, Go, Python) menerapkan <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengumpulan sampah</a></i> .  Bagian dari lingkungan runtime, yang disebut pengumpul sampah (GC), melacak variabel dan mengidentifikasi sumber daya yang tidak dapat diakses dalam grafik tautan antar objek.  Segera setelah objek menjadi tidak tersedia, GC membebaskan memori dasar untuk digunakan kembali di masa depan.  Setiap alokasi dan pembebasan memori terjadi tanpa perintah programmer eksplisit. <br><br>  Meskipun GC memastikan bahwa memori selalu digunakan dengan benar, itu tidak membebaskan memori dengan cara yang paling efisien - kadang-kadang penggunaan terakhir suatu objek terjadi jauh lebih awal daripada pengumpul sampah akan membebaskan memori.  Biaya kinerja adalah penghalang untuk aplikasi mission-critical: kadang-kadang Anda perlu menggunakan memori 5 kali lebih banyak untuk menghindari penurunan kinerja. <br><br><h3>  Kepemilikan </h3><br>  Rust menggunakan kepemilikan untuk memastikan kinerja tinggi dan keamanan memori.  Secara lebih formal, ini adalah contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengetikan afinitas</a> .  Semua kode Rust mengikuti aturan tertentu yang memungkinkan kompiler mengelola memori tanpa kehilangan waktu eksekusi: <br><br><ol><li>  Setiap nilai memiliki variabel yang disebut pemilik. <br></li><li>  Hanya satu pemilik yang dapat melakukannya sekaligus. <br></li><li>  Ketika pemilik bergerak keluar dari ruang lingkup, nilainya dihapus. </li></ol><br>  Nilai dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditransfer</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dipinjam</a> dari satu variabel ke variabel lainnya.  Aturan-aturan ini berlaku untuk bagian dari kompiler yang disebut peminjam pinjaman. <br><br>  Ketika sebuah variabel keluar dari ruang lingkup, Rust membebaskan memori ini.  Dalam contoh berikut, variabel <code>s1</code> dan <code>s2</code> melampaui ruang lingkup, keduanya mencoba membebaskan memori yang sama, yang mengarah ke kesalahan bebas-ganda.  Untuk mencegah hal ini, saat mentransfer nilai dari variabel, pemilik sebelumnya menjadi tidak valid.  Jika programmer kemudian mencoba menggunakan variabel yang tidak valid, kompiler akan menolak kode tersebut.  Ini dapat dihindari dengan membuat salinan data yang mendalam atau menggunakan tautan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh 1</a> : Transfer kepemilikan <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s1 = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s2 = s1; <span class="hljs-comment"><span class="hljs-comment">//won't compile because s1 is now invalid println!("{}, world!", s1);</span></span></code> </pre> <br>  Seperangkat aturan pemeriksa pinjaman terkait dengan masa pakai variabel.  Rust melarang penggunaan variabel tidak diinisialisasi dan menggantung pointer ke objek yang tidak ada.  Jika Anda mengkompilasi kode dari contoh di bawah ini, <code>r</code> akan merujuk ke memori yang dibebaskan ketika <code>x</code> keluar dari ruang lingkup: terjadi penunjuk menggantung.  Compiler memonitor semua area dan memeriksa validitas semua transfer, kadang-kadang membutuhkan programmer untuk secara eksplisit menunjukkan umur variabel. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh 2</a> : Hanging Pointer <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> r; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; r = &amp;x; } <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"r: {}"</span></span>, r);</code> </pre> <br>  Model kepemilikan memberikan dasar yang kuat untuk akses yang benar ke memori, mencegah perilaku yang tidak terdefinisi. <br><br><h1>  Kerentanan memori </h1><br>  Konsekuensi utama dari memori yang rentan: <br><br><ol><li>  <b>Kecelakaan</b> : Mengakses memori yang tidak valid dapat menyebabkan aplikasi berhenti tiba-tiba. <br></li><li>  <b>Kebocoran informasi</b> : penyediaan data pribadi yang tidak disengaja, termasuk informasi rahasia, seperti kata sandi. <br></li><li>  <b>Eksekusi Kode Sewenang-wenang (ACE)</b> : Memungkinkan penyerang untuk mengeksekusi perintah sewenang-wenang pada mesin target.  Jika ini terjadi melalui jaringan, kami menyebutnya Remote Code Execution (RCE). </li></ol><br>  Masalah lain adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kebocoran memori</a> ketika memori yang dialokasikan tidak dibebaskan setelah program berakhir.  Jadi, Anda dapat menggunakan semua memori yang tersedia: kemudian permintaan sumber daya diblokir, yang akan mengarah pada penolakan layanan.  Ini adalah masalah memori yang tidak dapat diselesaikan pada level PL. <br><br>  Dalam kasus terbaik, dengan kesalahan memori, aplikasi akan macet.  Dalam skenario terburuk, seorang penyerang mendapatkan kendali atas suatu program melalui kerentanan (yang dapat menyebabkan serangan lebih lanjut). <br><br><h3>  Pelanggaran memori yang dibebaskan (bebas digunakan, bebas ganda) </h3><br>  Subkelas kerentanan ini terjadi saat sumber daya dibebaskan, tetapi tautan ke alamatnya tetap dipertahankan.  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode hacker yang kuat</a> yang dapat menyebabkan akses di luar jangkauan, kebocoran informasi, eksekusi kode, dan banyak lagi. <br><br>  Bahasa dengan pengumpulan sampah dan penghitungan referensi mencegah penggunaan pointer yang tidak valid, menghancurkan hanya objek yang tidak dapat diakses (yang dapat menyebabkan penurunan kinerja), dan bahasa yang dikontrol secara manual rentan terhadap kerentanan ini (terutama di basis kode yang kompleks).  Alat pemeriksa pinjaman di Rust tidak memungkinkan benda untuk dihancurkan saat direferensikan, sehingga bug ini dihapus pada tahap kompilasi. <br><br><h3>  Variabel tidak diinisialisasi </h3><br>  Jika variabel digunakan sebelum inisialisasi, maka data ini dapat berisi data apa pun, termasuk sampah acak atau data yang sebelumnya dibuang, yang mengarah ke kebocoran informasi (kadang-kadang disebut <i>pointer tidak valid</i> ).  Untuk mencegah masalah ini, bahasa manajemen memori sering menggunakan prosedur inisialisasi otomatis setelah mengalokasikan memori. <br><br>  Seperti dalam C, sebagian besar variabel di Rust pada awalnya tidak diinisialisasi.  Tetapi tidak seperti C, Anda tidak dapat membacanya sebelum inisialisasi.  Kode berikut tidak dikompilasi: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh 3</a> : Menggunakan variabel yang tidak diinisialisasi <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, x); }</code> </pre> <br><h3>  Pointer kosong </h3><br>  Ketika sebuah aplikasi mereferensi pointer yang ternyata menjadi null, biasanya hanya mengakses sampah dan menyebabkan crash.  Dalam beberapa kasus, kerentanan ini dapat menyebabkan eksekusi kode arbitrer ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> ).  Rust memiliki dua jenis pointer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> dan pointer mentah.  Tautan aman, tetapi pointer mentah bisa menjadi masalah. <br><br>  Rust mencegah penereferensian pointer nol dengan dua cara: <br><br><ol><li>  Hindari petunjuk yang dapat dibatalkan. <br></li><li>  Hindari referensi mentah dereferencing. </li></ol><br>  Rust menghindari pointer nol dengan menggantinya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code> Option</code></a> khusus.  Untuk mengubah nilai null-mungkin dalam jenis <code>Option</code> , bahasa mengharuskan programmer untuk secara eksplisit menangani kasus dengan nilai nol, jika tidak program tidak akan dikompilasi. <br><br>  Apa yang harus dilakukan jika pointer yang memungkinkan nilai nol tidak dapat dihindari (misalnya, ketika berinteraksi dengan kode dalam bahasa lain)?  Cobalah untuk mengisolasi kerusakannya.  Dereferencing pointer mentah harus terjadi di blok yang tidak aman terisolasi.  Ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melonggarkan aturan Rust</a> dan menyelesaikan beberapa operasi yang dapat menyebabkan perilaku tidak terdefinisi (misalnya, penereferensi pointer mentah). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e58/bd7/b69/e58bd7b69e8f2f399e431bdb4f6d151f.jpg"></div><br>  <i><font color="gray">"Segala sesuatu tentang peminjam pinjaman ... bagaimana dengan tempat gelap itu?"</font></i> <i><font color="gray"><br></font></i>  <i><font color="gray">- Ini adalah blok yang tidak aman.</font></i>  <i><font color="gray">Jangan pernah ke sana, Simba</font></i> <br><br><h3>  Buffer overflow </h3><br>  Kami membahas kerentanan yang dapat dihindari dengan membatasi akses ke memori yang tidak ditentukan.  Tetapi masalahnya adalah buffer overflow tidak mengakses dengan benar undefined, tetapi mengalokasikan memori secara legal.  Seperti bug yang digunakan setelah bebas, akses tersebut dapat menjadi masalah karena mengakses memori yang dibebaskan, yang masih mengandung informasi rahasia yang seharusnya tidak ada lagi. <br><br>  Buffer overflows berarti akses di luar batas.  Karena cara buffer disimpan dalam memori, mereka sering membocorkan informasi yang mungkin berisi data sensitif, termasuk kata sandi.  Dalam kasus yang lebih serius, kerentanan ACE / RCE dimungkinkan dengan menimpa penunjuk instruksi. <br><br>  Contoh 4: Buffer Overflow (Kode C) <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buf[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// print out of bounds printf("Out of bounds: %d\n", buf[10]); // write out of bounds buf[10] = 10; printf("Out of bounds: %d\n", buf[10]); return 0; }</span></span></code> </pre> <br>  Perlindungan paling sederhana terhadap buffer overflows adalah untuk selalu memerlukan pemeriksaan perbatasan ketika mengakses elemen, tetapi ini menyebabkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kinerja yang buruk</a> . <br><br>  Apa yang dilakukan karat?  Tipe buffer bawaan di pustaka standar memerlukan pemeriksaan perbatasan untuk akses acak apa pun, tetapi juga menyediakan API iterator untuk mempercepat panggilan berurutan.  Ini memastikan bahwa membaca dan menulis batas luar tidak dimungkinkan untuk jenis ini.  Karat mempromosikan pola yang memerlukan pemeriksaan perbatasan hanya di tempat-tempat di mana Anda hampir pasti harus menempatkannya secara manual di C / C ++. <br><br><h1>  Keamanan memori hanya setengah pertempuran </h1><br>  Pelanggaran keamanan menyebabkan kerentanan seperti kebocoran data dan eksekusi kode jarak jauh.  Ada berbagai cara untuk melindungi memori, termasuk smart pointer dan pengumpulan sampah.  Anda bahkan dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">secara resmi membuktikan keamanan memori</a> .  Sementara beberapa bahasa telah sepakat dengan penurunan kinerja demi keamanan memori, konsep kepemilikan Rust memberikan keamanan dan meminimalkan overhead. <br><br>  Sayangnya, kesalahan memori hanya bagian dari cerita ketika kita berbicara tentang menulis kode aman.  Pada artikel selanjutnya, kami akan mempertimbangkan keamanan utas dan serangan pada kode paralel. <br><br><h1>  Memanfaatkan Kerentanan Memori: Sumber Daya Tambahan </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tumpukan ingatan dan eksploitasi</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penghancuran tumpukan dari posisi seorang hacker</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Analogi Keamanan Informasi</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar kerentanan penggunaan-setelah-gratis</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438288/">https://habr.com/ru/post/id438288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438272/index.html">Bagaimana kami mengirim SMS dari gua</a></li>
<li><a href="../id438274/index.html">Definisi "kepribadian beracun" di TI</a></li>
<li><a href="../id438278/index.html">Mengajar anak-anak ke program</a></li>
<li><a href="../id438280/index.html">"Menghapus" objek di Django</a></li>
<li><a href="../id438286/index.html">Bekerja dengan zona waktu dalam JavaScript</a></li>
<li><a href="../id438290/index.html">Post-mortem dengan GGJ-2019: bagaimana cara mendapatkan gundukan, tetapi tetap membuat game</a></li>
<li><a href="../id438292/index.html">Otomasi Apartemen dengan HomePod, Raspberry Pi dan Node.js</a></li>
<li><a href="../id438294/index.html">Menemukan Stream Twitch dalam Pertandingan PUBG</a></li>
<li><a href="../id438296/index.html">OpenSceneGraph: Sistem Plugin</a></li>
<li><a href="../id438298/index.html">Mengapa mengajar jika berkembang lebih menguntungkan. Percakapan dengan GeekBrains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>