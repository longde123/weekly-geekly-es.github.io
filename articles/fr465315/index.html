<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😊 👩🏽‍🏫 🍏 Kafka et microservices: un aperçu 🐔 👪 👐🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous. Dans cet article, je vais vous expliquer pourquoi nous avons choisi Kafka il y a neuf mois à Avito, et ce que c'est. Je vais partager ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kafka et microservices: un aperçu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/465315/"><p><img src="https://habrastorage.org/webt/ds/35/lj/ds35ljzkot_2jqkr7tnjuf8ynwg.png"></p><br><p>  Bonjour à tous.  Dans cet article, je vais vous expliquer pourquoi nous avons choisi Kafka il y a neuf mois à Avito, et ce que c'est.  Je vais partager l'un des cas d'utilisation - un courtier de messages.  Et enfin, parlons des avantages que nous avons retirés de l'application de l'approche Kafka as a Service. </p><a name="habracut"></a><br><h1 id="problema">  Le problème </h1><br><p><img src="https://habrastorage.org/webt/xd/gl/fu/xdglfupecap80heoegvpab_iy74.png"></p><br><p>  Tout d'abord, un peu de contexte.  Il y a quelque temps, nous avons commencé à nous éloigner de l'architecture monolithique, et maintenant, à Avito, il existe déjà plusieurs centaines de services différents.  Ils ont leurs propres référentiels, leur propre pile technologique et sont responsables de leur part de la logique métier. </p><br><p>  Un des problèmes avec un grand nombre de services est la communication.  Le service A souhaite souvent connaître les informations du service B. Dans ce cas, le service A accède au service B via une API synchrone.  Le service B veut savoir ce qui se passe avec les services G et D, et ceux-ci, à leur tour, sont intéressés par les services A et B. Lorsqu'il existe de nombreux services «curieux», les connexions entre eux se transforment en une boule emmêlée. </p><br><p>  De plus, à tout moment, le service A peut devenir indisponible.  Et que faire dans ce cas, le service B et tous les autres services qui lui sont liés?  Et si vous devez effectuer une chaîne d'appels synchrones consécutifs pour terminer une opération commerciale, la probabilité d'échec de l'ensemble de l'opération devient encore plus élevée (et elle est d'autant plus élevée que cette chaîne est longue). </p><br><h1 id="vybor-tehnologii">  Sélection de technologies </h1><br><p><img src="https://habrastorage.org/webt/pr/t4/xo/prt4xoqz2xianmupqbdqk1unc8i.png" width="300" alt="image" align="left"></p><br><p>  OK, les problèmes sont clairs.  Vous pouvez les éliminer en créant un système de messagerie centralisé entre les services.  Désormais, chacun des services suffit pour connaître uniquement ce système de messagerie.  De plus, le système lui-même doit être tolérant aux pannes et évolutif horizontalement, ainsi qu'en cas d'accident, accumuler un tampon d'appel pour leur traitement ultérieur. </p><br><p>  Choisissons maintenant la technologie sur laquelle la remise des messages sera mise en œuvre.  Pour ce faire, comprenez d'abord ce que nous attendons d'elle: </p><br><ul><li>  Les messages entre services ne doivent pas être perdus; </li><li>  Les messages peuvent être dupliqués </li><li>  les messages peuvent être stockés et lus sur une profondeur de plusieurs jours (tampon persistant); </li><li>  les services peuvent souscrire aux données qui les intéressent; </li><li>  plusieurs services peuvent lire les mêmes données; </li><li>  Les messages peuvent contenir une charge utile détaillée et en masse (transfert d'état transporté par événement); </li><li>  Parfois, vous avez besoin d'une garantie de commande de message. </li></ul><br><p>  Il était également essentiel pour nous de choisir le système le plus évolutif et le plus fiable à haut débit (au moins 100 000 messages à quelques kilo-octets par seconde). </p><br><p>  À ce stade, nous avons dit au revoir à RabbitMQ (difficile à maintenir stable à des vitesses élevées), PGT de SkyTools (pas assez rapide et mal évolutif) et NSQ (non persistant).  Toutes ces technologies sont utilisées dans notre entreprise, mais elles ne convenaient pas à la tâche à accomplir. </p><br><p>  Ensuite, nous avons commencé à chercher de nouvelles technologies pour nous - Apache Kafka, Apache Pulsar et NATS Streaming. </p><br><p>  Le premier à laisser tomber Pulsar.  Nous avons décidé que Kafka et Pulsar sont des solutions assez similaires.  Et malgré le fait que Pulsar soit testé par de grandes entreprises, il est plus récent et offre une latence plus faible (en théorie), nous avons décidé de laisser Kafka parmi les deux, comme standard de facto pour de telles tâches.  Nous reviendrons probablement à Apache Pulsar à l'avenir. </p><br><p>  Et il restait deux candidats: NATS Streaming et Apache Kafka.  Nous avons étudié les deux solutions en détail, et les deux se sont montrées à la hauteur.  Mais à la fin, nous avions peur de la jeunesse relative de NATS Streaming (et du fait que l'un des principaux développeurs, Tyler Treat, ait décidé de quitter le projet et de démarrer le sien - Liftbridge).  Dans le même temps, le mode de clustering de NATS Streaming ne permettait pas une forte mise à l'échelle horizontale (ce n'est probablement plus un problème après l'ajout du mode de partitionnement en 2017). </p><br><p>  Cependant, NATS Streaming est une technologie intéressante écrite en Go et prise en charge par la Cloud Native Computing Foundation.  Contrairement à Apache Kafka, il n'a pas besoin de Zookeeper pour fonctionner (il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sera peut-être possible de dire la même chose à propos de Kafka bientôt</a> ), car à l'intérieur il implémente RAFT.  Dans le même temps, NATS Streaming est plus facile à administrer.  Nous n'excluons pas qu'à l'avenir, nous reviendrons sur cette technologie. </p><br><p>  Néanmoins, Apache Kafka est devenu notre gagnant aujourd'hui.  Lors de nos tests, il s'est avéré assez rapide (plus d'un million de messages par seconde pour la lecture et l'écriture avec un volume de messages de 1 kilo-octet), suffisamment fiable, bien évolutif et une expérience éprouvée dans la vente par les grandes entreprises.  De plus, Kafka soutient au moins plusieurs grandes sociétés commerciales (par exemple, nous utilisons la version Confluent), et Kafka a un écosystème développé. <br><br clear="left"></p><br><h1 id="obzor-kafka">  Donnez votre avis sur Kafka </h1><br><p>  Avant de commencer, je recommande immédiatement un excellent livre - <em>"Kafka: Le guide définitif"</em> (il est également dans la traduction russe, mais les termes brisent un peu le cerveau).  Vous y trouverez les informations nécessaires à une compréhension de base de Kafka et même un peu plus.  La documentation Apache elle-même et le blog Confluent sont également bien écrits et faciles à lire. </p><br><p>  Alors, regardons comment Kafka est une vue à vol d'oiseau.  La topologie de base de Kafka se compose de producteur, consommateur, courtier et gardien de zoo. </p><br><h3 id="broker">  Courtier </h3><br><p><img src="https://habrastorage.org/webt/ng/o6/l2/ngo6l2ngibz7krlckw0mpdy2x88.png"></p><br><p>  Un courtier est responsable du stockage de vos données.  Toutes les données sont stockées sous forme binaire, et le courtier sait peu de choses sur ce qu'elles sont et quelle est leur structure. </p><br><p>  Chaque type d'événement logique est généralement situé dans son propre sujet distinct (sujet).  Par exemple, un événement de création d'annonce peut tomber dans le sujet item.created et un événement de sa modification peut tomber dans item.changed.  Les sujets peuvent être considérés comme des classificateurs d'événements.  Au niveau de la rubrique, vous pouvez définir des paramètres de configuration tels que: </p><br><ul><li>  le volume de données stockées et / ou leur âge (retention.bytes, retention.ms); </li><li>  facteur de redondance des données (facteur de réplication); </li><li>  taille maximale d'un message (max.message.bytes); </li><li>  le nombre minimum de répliques cohérentes auxquelles les données peuvent être écrites sur le sujet (min.insync.replicas); </li><li>  la possibilité de basculement vers une réplique en retard non synchrone avec perte potentielle de données (unclean.leader.election.enable); </li><li>  et bien d'autres ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://kafka.apache.org/documentation/#topicconfigs</a> ). </li></ul><br><p>  À son tour, chaque sujet est divisé en une ou plusieurs partitions (partition).  C'est dans la partition que les événements finissent par tomber.  S'il y a plus d'un courtier dans le cluster, les partitions seront réparties également entre tous les courtiers (autant que possible), ce qui vous permettra de faire évoluer la charge d'écriture et de lecture dans un sujet sur plusieurs courtiers à la fois. </p><br><p>  Sur disque, les données de chaque partition sont stockées sous forme de fichiers de segments, par défaut égaux à un gigaoctet (contrôlés via log.segment.bytes).  Une caractéristique importante est que les données sont supprimées des partitions (lorsque la rétention est déclenchée) uniquement par segments (vous ne pouvez pas supprimer un événement d'une partition, vous pouvez supprimer uniquement le segment entier et uniquement inactif). </p><br><h3 id="zookeeper">  Zookeeper </h3><br><p> Zookeeper agit en tant que référentiel de métadonnées et coordinateur.  C'est lui qui peut dire si les courtiers sont vivants (vous pouvez le regarder à travers les yeux d'un gardien grâce à la commande zookeeper-shell <code>ls /brokers/ids</code> ), lequel des courtiers est le contrôleur ( <code>get /controller</code> ), si les partitions sont en état synchrone avec leurs répliques ( <code>get /brokers/topics/topic_name/partitions/partition_number/state</code> ).  De plus, le producteur et le consommateur se rendront d'abord auprès du gardien de zoo pour savoir sur quel courtier quels sujets et quelles partitions sont stockés.  Dans les cas où un facteur de réplication supérieur à 1 est spécifié pour le sujet, le gardien de zoo indiquera quelles partitions sont des leaders (ils seront écrits et lus à partir de).  En cas de panne d'un courtier, c'est dans le gardien de zoo que les informations sur les nouvelles partitions de leader seront enregistrées (à partir de la version 1.1.0 de manière asynchrone, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce qui est important</a> ). </p><br><p>  Dans les anciennes versions de Kafka, zookeeper était également responsable du stockage des décalages, mais maintenant ils sont stockés dans une rubrique spéciale <code>__consumer_offsets</code> sur le courtier (bien que vous puissiez toujours utiliser zookeeper à ces fins). </p><br><p>  La façon la plus simple de transformer vos données en citrouille est simplement la perte d'informations avec zookeeper.  Dans un tel scénario, il sera très difficile de comprendre quoi et où lire. </p><br><h3 id="producer">  Producteur </h3><br><p>  Le producteur est le plus souvent un service qui écrit directement des données dans Apache Kafka.  Le producteur sélectionne un sujet dans lequel ses messages thématiques seront stockés et commence à y écrire des informations.  Par exemple, un producteur peut être un service publicitaire.  Dans ce cas, il enverra des événements tels que «annonce créée», «annonce mise à jour», «annonce supprimée», etc. à des sujets thématiques.  Chaque événement est une paire clé-valeur. </p><br><p>  Par défaut, tous les événements sont distribués par les partitions de partition avec round-robin si la clé n'est pas définie (ordre perdu), et via MurmurHash (clé) si la clé est présente (commande dans la même partition). </p><br><p>  Il convient immédiatement de noter ici que Kafka garantit l'ordre des événements dans une seule partition.  Mais en fait, ce n'est souvent pas un problème.  Par exemple, vous pouvez à coup sûr ajouter toutes les modifications d'une même annonce à une partition (préservant ainsi l'ordre de ces modifications dans l'annonce).  Vous pouvez également transmettre un numéro de séquence dans l'un des champs d'événement. </p><br><h3 id="consumer">  Consommateur </h3><br><p><img src="https://habrastorage.org/webt/z_/ab/oo/z_abooprhxbjgwpaqmjcdplsalc.png"></p><br><p>  Le consommateur est responsable de la récupération des données d'Apache Kafka.  Si vous revenez à l'exemple ci-dessus, le consommateur peut être un service de modération.  Ce service sera abonné au sujet du service d'annonce et lorsqu'une nouvelle publicité apparaîtra, il la recevra et analysera sa conformité avec certaines politiques spécifiées. </p><br><p>  Apache Kafka se souvient des événements récents que le consommateur a reçus (la <code>__consumer__offsets</code> service <code>__consumer__offsets</code> est utilisée pour cela), garantissant ainsi qu'en cas de lecture réussie, le consommateur ne recevra pas le même message deux fois.  Néanmoins, si vous utilisez l'option enable.auto.commit = true et donnez entièrement le travail de suivi de la position du consommateur dans le sujet à Kafka, vous pouvez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">perdre des données</a> .  Dans le code de production, la position du consommateur est le plus souvent contrôlée manuellement (le développeur contrôle le moment où la validation de l'événement de lecture doit se produire). </p><br><p>  Dans les cas où un consommateur ne suffit pas (par exemple, le flux de nouveaux événements est très important), vous pouvez ajouter quelques consommateurs supplémentaires en les reliant dans le groupe de consommateurs.  Le groupe de consommateurs est logiquement exactement le même consommateur, mais avec la distribution des données entre les membres du groupe.  Cela permet à chacun des participants de prendre leur part de messages, augmentant ainsi la vitesse de lecture. </p><br><h1 id="rezultaty-testirovaniya">  Résultats des tests </h1><br><p><img src="https://habrastorage.org/webt/9w/fg/vy/9wfgvyrgh5ms1uhd8iutqqvu11k.png" width="300" alt="image" align="left"></p><br><p>  Ici, je n'écrirai pas beaucoup de texte explicatif, je partage juste les résultats.  Les tests ont été effectués sur 3 machines physiques (12 CPU, 384GB RAM, 15k SAS DISK, 10GBit / s Net), des brokers et zookeeper ont été déployés dans lxc. </p><br><p>  <strong>Test de performance</strong> </p><br><p>  Au cours des tests, les résultats suivants ont été obtenus. </p><br><ul><li>  La vitesse d'enregistrement de messages de 1 Ko en même temps par 9 producteurs - 1 300 000 événements par seconde. </li><li>  Vitesse de lecture de messages de 1 Ko en même temps par 9 consommateurs - 1 500 000 événements par seconde. </li></ul><br><p>  <strong>Test de tolérance aux pannes</strong> </p><br><p>  Lors des tests, les résultats suivants ont été obtenus (3 courtiers, 3 gardiens). </p><br><ul><li>  Une résiliation anormale de l'un des courtiers n'entraîne pas la suspension ou l'inaccessibilité du cluster.  Le travail se poursuit comme d'habitude, mais les autres courtiers ont une grosse charge. </li><li>  La terminaison anormale de deux courtiers dans le cas d'un cluster de trois courtiers et min.isr = 2 conduit à l'inaccessibilité du cluster pour l'écriture, mais pour la lisibilité.  Si min.isr = 1, le cluster reste disponible pour la lecture et l'écriture.  Cependant, ce mode contredit l'exigence d'une haute sécurité des données. </li><li>  L'arrêt anormal de l'un des serveurs Zookeeper n'entraîne pas l'arrêt ou l'inaccessibilité du cluster.  Le travail se poursuit normalement. </li><li>  Une interruption anormale de deux serveurs Zookeeper conduit à une inaccessibilité du cluster jusqu'à ce qu'au moins l'un des serveurs Zookeeper soit restauré.  Cette affirmation est vraie pour un cluster Zookeeper de 3 serveurs.  En conséquence, après des recherches, il a été décidé d'augmenter le cluster Zookeeper à 5 serveurs pour augmenter la tolérance aux pannes. <br clear="left"></li></ul><br><h1 id="kafka-as-a-service">  Kafka en tant que service </h1><br><p><img src="https://habrastorage.org/webt/cc/hg/y_/cchgy_e8d7-cztjd5ltu97kfs2o.jpeg" width="300" alt="image" align="left"></p><br><p>  Nous nous sommes assurés que Kafka est une excellente technologie qui nous permet de résoudre l'ensemble de tâches pour nous (implémenter un courtier de messages).  Néanmoins, nous avons décidé d'interdire aux services d'accéder directement à Kafka et de le fermer par-dessus avec le service de bus de données.  Pourquoi avons-nous fait ça?  Il y a en fait plusieurs raisons. </p><br><ul><li><p>  Data-bus a pris en charge toutes les tâches liées à l'intégration avec Kafka (implémentation et configuration des consommateurs et des producteurs, surveillance, alerte, journalisation, mise à l'échelle, etc.).  Ainsi, l'intégration avec le courtier de messages est aussi simple que possible. </p><br></li><li><p>  Le bus de données a permis d'abstraire d'une langue ou d'une bibliothèque spécifique pour travailler avec Kafka. </p><br></li><li><p>  Le bus de données a permis à d'autres services de s'abstraire de la couche de stockage.  Peut-être qu'à un moment donné, nous changerons Kafka en Pulsar, et personne ne remarquera rien (tous les services ne connaissent que l'API du bus de données). </p><br></li><li><p>  Le bus de données a pris en charge la validation des schémas d'événements. </p><br></li><li><p>  L'utilisation de l'authentification par bus de données est implémentée. </p><br></li><li><p>  Sous le couvert du bus de données, nous pouvons, sans temps d'arrêt, mettre à jour discrètement les versions de Kafka, conduire de manière centralisée les configurations des producteurs, consommateurs, courtiers, etc. </p><br></li><li><p>  Le bus de données nous a permis d'ajouter des fonctionnalités dont nous avons besoin qui ne sont pas dans Kafka (comme l'audit de sujet, la surveillance des anomalies dans le cluster, la création de DLQ, etc.). </p><br></li><li><p>  Le bus de données permet une mise en œuvre centralisée du basculement pour tous les services. </p><br></li></ul><br><p>  Pour le moment, pour commencer à envoyer des événements au courtier de messages, connectez simplement une petite bibliothèque à votre code de service.  C’est tout.  Vous avez la possibilité d'écrire, de lire et de mettre à l'échelle avec une seule ligne de code.  L'implémentation entière vous est cachée, seuls quelques bâtons comme la taille du lot ressortent.  Sous le capot, le service de bus de données augmente le nombre nécessaire d'instances de producteurs et de consommateurs dans Kubernetes et leur ajoute la configuration nécessaire, mais tout cela est transparent pour votre service. </p><br><p>  Bien sûr, il n'y a pas de solution miracle, et cette approche a ses limites. </p><br><ul><li>  Le bus de données doit être pris en charge seul, contrairement aux bibliothèques tierces. </li><li>  Le bus de données augmente le nombre d'interactions entre les services et le courtier de messages, ce qui entraîne une baisse des performances par rapport à Kafka nu. </li><li>  Tout ne peut pas être caché si simplement aux services, nous ne voulons pas dupliquer les fonctionnalités de KSQL ou de Kafka Streams dans le bus de données, vous devez donc parfois autoriser les services à aller directement. </li></ul><br><p>  Dans notre cas, les avantages l'emportaient sur les inconvénients, et la décision de couvrir le courtier de messages avec un service distinct était justifiée.  Au cours de l'année de fonctionnement, nous n'avons eu aucun accident ni problème grave. </p><br><p>  PS Merci à ma petite amie, Ekaterina Oblyalyaeva, pour les photos sympas de cet article.  Si vous les avez aimés, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">il</a> y a encore plus d'illustrations. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465315/">https://habr.com/ru/post/fr465315/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465299/index.html">Apache NIFI - Un bref aperçu des fonctionnalités dans la pratique</a></li>
<li><a href="../fr465301/index.html">Comment créer un processus de mise en page de commerce électronique pour obtenir toutes les données dont vous avez besoin</a></li>
<li><a href="../fr465303/index.html">Trains de Moscou (et pas seulement): ce qui a changé et merci à ceux qui ont aidé</a></li>
<li><a href="../fr465309/index.html">Je suis le plus gros méchant du développement de jeux indépendants</a></li>
<li><a href="../fr465311/index.html">Système de surveillance de véhicules bricolage</a></li>
<li><a href="../fr465319/index.html">Malentendus du passé</a></li>
<li><a href="../fr465321/index.html">À l'avenir, les scientifiques pourront apprendre à prédire exactement ce dont vous vous souviendrez.</a></li>
<li><a href="../fr465323/index.html">Quelle sera la cryptographie post-quantique?</a></li>
<li><a href="../fr465325/index.html">Objets spéciaux difficiles à saisir pour les robots</a></li>
<li><a href="../fr465329/index.html">Modèle d'apprentissage automatique interprété. 2e partie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>