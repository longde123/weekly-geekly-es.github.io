<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¨ üí° üßïüèΩ Strukturen gegen Klassen üåé ü§ôüèª ‚õπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von Anfang an, als ich mit dem Programmieren anfing, stellte sich die Frage, was zur Verbesserung der Leistung verwendet werden sollte: Struktur oder ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Strukturen gegen Klassen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472290/">  Von Anfang an, als ich mit dem Programmieren anfing, stellte sich die Frage, was zur Verbesserung der Leistung verwendet werden sollte: Struktur oder Klasse;  Welche Arrays sind besser zu verwenden und wie.  In Bezug auf Strukturen begr√º√üt Apple ihre Verwendung und erkl√§rt, dass sie besser optimiert werden k√∂nnen und die gesamte Essenz der Swift-Sprache Strukturen sind.  Es gibt jedoch diejenigen, die damit nicht einverstanden sind, da Sie den Code auf wunderbare Weise vereinfachen k√∂nnen, indem Sie eine Klasse von einer anderen erben und mit einer solchen Klasse arbeiten.  Um die Arbeit mit Klassen zu beschleunigen, haben wir verschiedene Modifikatoren und Objekte erstellt, die speziell f√ºr Klassen optimiert wurden. Es ist bereits schwierig zu sagen, was in welchem ‚Äã‚ÄãFall schneller sein wird. <br><br>  Um alle Punkte auf dem ‚Äûe‚Äú anzuordnen, habe ich mehrere Tests geschrieben, die die √ºblichen Ans√§tze f√ºr die Datenverarbeitung verwenden: √úbergabe an eine Methode, Kopieren, Arbeiten mit Arrays usw.  Ich habe beschlossen, keine gro√üen Schlussfolgerungen zu ziehen. Jeder wird selbst entscheiden, ob es sich lohnt, an die Tests zu glauben, das Projekt herunterladen und sehen, wie es f√ºr Sie funktioniert, und versuchen, den Betrieb eines bestimmten Tests zu optimieren.  Vielleicht kommen sogar neue Chips heraus, die ich nicht erw√§hnt habe, oder sie werden so selten verwendet, dass ich einfach nichts davon geh√∂rt habe. <br><a name="habracut"></a><br>  PS Ich habe angefangen, an einem Artikel √ºber Xcode 10.3 zu arbeiten, und ich habe dar√ºber nachgedacht, die Geschwindigkeit mit Xcode 11 zu vergleichen. In diesem Artikel geht es jedoch nicht um den Vergleich zweier Anwendungen, sondern um die Geschwindigkeit unserer Anwendungen.  Ich habe keinen Zweifel daran, dass die Laufzeit von Funktionen abnimmt und die schlecht optimierte schneller wird.  Infolgedessen wartete ich auf den neuen Swift 5.1 und beschloss, die Hypothesen in der Praxis zu testen.  Viel Spa√ü beim Lesen. <br><br><h4>  Test 1: Vergleichen Sie Arrays auf Strukturen und Klassen </h4><br>  Angenommen, wir haben eine Klasse und m√∂chten die Objekte dieser Klasse in ein Array einf√ºgen. Die √ºbliche Aktion f√ºr ein Array besteht darin, sie zu durchlaufen. <br><br>  Wenn in einem Array Klassen verwendet werden und versucht wird, durch das Array zu gehen, erh√∂ht sich die Anzahl der Verkn√ºpfungen. Nach Abschluss verringert sich die Anzahl der Verkn√ºpfungen zum Objekt. <br><br>  Wenn wir die Struktur durchgehen, wird zum Zeitpunkt des Aufrufs des Objekts durch den Index eine Kopie des Objekts erstellt, die denselben Speicherbereich betrachtet, jedoch als unver√§nderlich markiert ist.  Es ist schwer zu sagen, was schneller ist: Erh√∂hen Sie die Anzahl der Verkn√ºpfungen zu einem Objekt oder erstellen Sie eine Verkn√ºpfung zu einem Bereich im Speicher, da diese nicht ge√§ndert werden kann.  Lassen Sie es uns in der Praxis √ºberpr√ºfen: <br><br><img src="https://habrastorage.org/webt/me/i5/2g/mei52ghwjxv_pg3c1toaoqachty.png"><br>  <i>Abb.</i>  <i>1: Vergleich des Abrufens einer Variablen aus Arrays basierend auf Strukturen und Klassen</i> <br><br><h4>  Test 2. Vergleichen Sie ContiguousArray mit Array </h4><br>  Interessanter ist es, die Leistung eines Arrays (Arrays) mit einem Referenzarray (ContiguousArray) zu vergleichen, das speziell f√ºr die Arbeit mit im Array gespeicherten Klassen ben√∂tigt wird. <br><br>  Lassen Sie uns die Leistung f√ºr die folgenden F√§lle √ºberpr√ºfen: <br><br>  ContiguousArray speichert eine Struktur mit dem Werttyp <br>  ContiguousArray speichert Struktur mit String <br>  ContiguousArray-Speicherklasse mit Werttyp <br>  ContiguousArray-Speicherklasse mit String <br>  Array-Speicherstruktur mit Werttyp <br>  Array-Speicherstruktur mit String <br>  Array-Speicherklasse mit Werttyp <br>  Array-Speicherklasse mit String <br><br>  Da die Testergebnisse (Tests: √úbergabe an eine Funktion mit deaktivierter Inline-Optimierung, √úbergabe an eine Funktion mit aktivierter Inline-Optimierung, L√∂schen von Elementen, Hinzuf√ºgen von Elementen, sequentieller Zugriff auf ein Element in einer Schleife) eine gro√üe Anzahl von Tests enthalten (f√ºr 8 Arrays mit jeweils 5 Tests) Ich werde die wichtigsten Ergebnisse geben: <br><br><ol><li>  Wenn Sie eine Funktion aufrufen und ein Array √ºbergeben und sie inline deaktivieren, ist ein solcher Aufruf sehr teuer (f√ºr Klassen, die auf der Referenzzeichenfolge basieren, ist er 20.000-mal langsamer, f√ºr Klassen, die auf Value basieren, ist der Typ 60.000-mal langsamer, schlechter, wenn der Inline-Optimierer deaktiviert ist). . </li><li>  Wenn die Optimierung (Inline) f√ºr Sie funktioniert, sollte eine Verschlechterung nur zweimal erwartet werden, je nachdem, welcher Datentyp zu welchem ‚Äã‚ÄãArray hinzugef√ºgt wird.  Die einzige Ausnahme war der Werttyp, der in eine im ContiguousArray liegende Struktur eingebunden war - ohne zeitliche Verschlechterung. </li><li>  Entfernung - Die Streuung zwischen dem Referenzarray und dem √ºblichen Array betrug etwa 20% (zugunsten des √ºblichen Arrays). </li><li>  Anh√§ngen - Bei Verwendung von in Klassen eingeschlossenen Objekten war ContiguousArray mit denselben Objekten etwa 20% schneller als Array, w√§hrend Array bei der Arbeit mit Strukturen schneller war als ContiguousArray mit Strukturen. </li><li>  Der Zugriff auf Array-Elemente bei Verwendung von Wrappern aus Strukturen erwies sich als schneller als alle Wrapper √ºber Klassen, einschlie√ülich ContiguousArray (etwa 500-mal schneller). </li></ol><br>  In den meisten F√§llen ist die Verwendung regul√§rer Arrays f√ºr die Arbeit mit Objekten effizienter.  Vorher verwendet, verwenden wir weiter. <br><br>  Die Schleifenoptimierung f√ºr Arrays wird vom Lazy Collection-Initialisierer bereitgestellt, mit dem Sie nur einmal √ºber das gesamte Array laufen k√∂nnen, selbst wenn mehrere Filter oder Maps f√ºr Array-Elemente verwendet werden. <br><br>  Bei der Verwendung von Strukturen als Optimierungswerkzeug gibt es Fallstricke, z. B. die Verwendung von Typen, auf die intern verwiesen wird: Zeichenfolgen, W√∂rterb√ºcher, Referenzarrays.  Wenn dann eine Variable, die einen Referenztyp in sich speichert, in eine Funktion eingegeben wird, wird f√ºr jedes Element, das eine Klasse ist, eine zus√§tzliche Referenz erstellt.  Dies hat eine andere Seite, etwas weiter.  Sie k√∂nnen versuchen, eine Wrapper-Klasse √ºber einer Variablen zu verwenden.  Dann erh√∂ht sich die Anzahl der Verkn√ºpfungen beim √úbergeben an die Funktion nur f√ºr diese, und die Anzahl der Verkn√ºpfungen zu den Werten innerhalb der Struktur bleibt gleich.  Im Allgemeinen m√∂chte ich sehen, wie viele Variablen eines Referenztyps in der Struktur enthalten sein m√ºssen, damit seine Leistung geringer abnimmt als die Leistung von Klassen mit denselben Parametern.  Im Internet gibt es einen Artikel mit dem Titel ‚ÄûStop Using Structs!‚Äú, In dem dieselbe Frage gestellt und beantwortet wird.  Ich habe das Projekt heruntergeladen und beschlossen herauszufinden, was wo passiert und in welchen F√§llen wir langsame Strukturen bekommen.  Der Autor zeigt die geringe Leistung von Strukturen im Vergleich zu Klassen und argumentiert, dass das Erstellen eines neuen Objekts viel langsamer ist als das Erh√∂hen des Verweises auf das Objekt absurd (daher habe ich die Zeile entfernt, in der jedes Mal ein neues Objekt in der Schleife erstellt wird).  Wenn wir jedoch keine Verkn√ºpfung zum Objekt erstellen, sondern es einfach an eine Funktion √ºbergeben, um damit zu arbeiten, ist der Leistungsunterschied sehr unbedeutend.  Jedes Mal, wenn wir eine Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">inline</a> (nie) setzen, muss unsere Anwendung sie ausf√ºhren und darf keinen Code in einer Zeichenfolge erstellen.  Nach den Tests hat Apple daf√ºr gesorgt, dass das an die Funktion √ºbergebene Objekt geringf√ºgig ge√§ndert wird. Bei Strukturen √§ndert der Compiler die Ver√§nderbarkeit und macht den Zugriff auf nicht ver√§nderbare Eigenschaften des Objekts verz√∂gert.  √Ñhnliches passiert in der Klasse, erh√∂ht aber gleichzeitig die Anzahl der Verweise auf das Objekt.  Und jetzt haben wir ein faules Objekt, alle seine Felder sind auch faul und jedes Mal, wenn wir eine Objektvariable aufrufen, wird sie initialisiert.  Dabei sind Strukturen nicht gleich: Wenn eine Funktion zwei Variablen aufruft, ist die Struktur des Objekts der Geschwindigkeitsklasse nur geringf√ºgig unterlegen;  Wenn Sie drei oder mehr aufrufen, ist die Struktur immer schneller. <br><br><h4>  Test 3: Vergleichen Sie die Leistung von Strukturen und Klassen, in denen gro√üe Klassen gespeichert sind </h4><br>  Au√üerdem bin ich ein wenig ver√§ndert sich Methode, die aufgerufen wird, wenn Sie eine weitere Variable hinzu (und somit in dem Verfahren initialisiert drei Variablen, und nicht zwei wie in dem Artikel), und dass es kein √úberlauf Int Ersetzen Operationen auf Variablen in der Summe und Subtraktion.  Verst√§ndlichere Zeitmetriken hinzugef√ºgt (im Screenshot sind es Sekunden, aber es ist nicht so wichtig f√ºr uns, das Verst√§ndnis der resultierenden Proportionen ist wichtig), Entfernen des Darwin-Frameworks (ich verwende es nicht in Projekten, m√∂glicherweise vergeblich, es gibt keine Unterschiede in den Tests vor / nach dem Hinzuf√ºgen des Frameworks in meinem Test). die Einbeziehung maximaler Optimierung und Aufbau auf dem Release-Build (es scheint, dass dies ehrlicher sein wird), und hier ist das Ergebnis: <br><br><img src="https://habrastorage.org/webt/zv/q_/en/zvq_ens-bwgnuetcl53shkecjd0.png"><br>  <i>Abb.</i>  <i>2: Leistung von Strukturen und Klassen aus dem Artikel ‚ÄûStop Using Structs‚Äú</i> <br><br>  Die Unterschiede in den Testergebnissen sind vernachl√§ssigbar. <br><br><h4>  Test 4: Funktion, die Generika, Protokolle und Funktionen ohne Generika akzeptiert </h4><br>  Wenn wir eine generische Funktion √ºbernehmen und dort zwei Werte √ºbergeben, die nur durch die M√∂glichkeit zum Vergleichen dieser Werte (func min) vereint sind, wird der Code aus drei Zeilen in einen Code aus acht (wie Apple sagt).  Dies ist jedoch nicht immer der Fall. Xcode verf√ºgt √ºber Optimierungsmethoden, bei denen beim Aufrufen einer Funktion, wenn zwei Strukturwerte an Xcode √ºbergeben werden, automatisch eine Funktion generiert wird, die zwei Strukturen akzeptiert und die Werte nicht mehr kopiert. <br><br><img src="https://habrastorage.org/webt/zo/fd/2v/zofd2v5qz7q3dkhzdcp_srpspyg.png"><br>  <i>Abb.</i>  <i>3: Typische generische Funktion</i> <br><br>  Ich habe beschlossen, zwei Funktionen zu testen: In der ersten wird der generische Datentyp deklariert, in der zweiten wird nur das Protokoll akzeptiert.  In der neuen Version des Swift 5.1-Protokolls ist es sogar etwas schneller als Generic (vor Swift 5.1 waren die Protokolle zweimal langsamer), obwohl es laut Apple umgekehrt sein sollte, aber wenn es um das Durchlaufen eines Arrays geht, m√ºssen wir bereits tippen, was langsamer wird Generisch (aber sie sind immer noch gro√üartig, weil sie schneller als Protokolle sind): <br><br><img src="https://habrastorage.org/webt/k-/ox/vr/k-oxvrhsx5mbw_osj7azkzu9x7y.png"><br>  <i>Abb.</i>  <i>4: Vergleich der generischen und Protokoll-Hostfunktionen.</i> <br><br><h4>  Test 5: Vergleichen Sie den Aufruf der √ºbergeordneten Methode mit der nativen und √ºberpr√ºfen Sie gleichzeitig die letzte Klasse auf einen solchen Aufruf </h4><br>  Was mich immer interessiert hat, ist, wie langsam Klassen mit einer gro√üen Anzahl von Eltern arbeiten, wie schnell eine Klasse ihre Funktionen und die eines Elternteils aufruft.  In F√§llen, in denen wir versuchen, eine Methode aufzurufen, die eine Klasse akzeptiert, kommt der dynamische Versand ins Spiel.  Was ist das?  Jedes Mal, wenn eine Methode oder Variable in unserer Funktion aufgerufen wird, wird eine Nachricht generiert, in der das Objekt nach dieser Variablen oder Methode gefragt wird.  Das Objekt, das eine solche Anforderung empf√§ngt, beginnt die Suche nach der Methode in der Versandtabelle seiner Klasse. Wenn eine √úberschreibung der Methode oder Variablen aufgerufen wurde, nimmt es diese und gibt sie zur√ºck oder erreicht rekursiv die Basisklasse. <br><br><img src="https://habrastorage.org/webt/tr/wz/i-/trwzi-l8v51yv4oftdl33a-30z4.png"><br>  <i>Abb.</i>  <i>5: Klassenmethodenaufrufe f√ºr Versandtests</i> <br><br>  Aus dem obigen Test k√∂nnen mehrere Schlussfolgerungen gezogen werden: Je gr√∂√üer die Klasse der √ºbergeordneten Klassen ist, desto langsamer arbeitet sie und der Geschwindigkeitsunterschied ist so gering, dass er sicher vernachl√§ssigt werden kann. Die Codeoptimierung f√ºhrt h√∂chstwahrscheinlich dazu, dass es keinen Geschwindigkeitsunterschied gibt.  In diesem Beispiel hat der endg√ºltige Klassenmodifikator keinen Vorteil, im Gegenteil, die Arbeit der Klasse ist noch langsamer, m√∂glicherweise aufgrund der Tatsache, dass sie keine wirklich schnelle Funktion wird. <br><br><h4>  Test 6: Aufrufen einer Variablen mit dem letzten Modifikator gegen eine regul√§re Klassenvariable </h4><br>  Auch sehr interessante Ergebnisse beim Zuweisen des endg√ºltigen Modifikators zu einer Variablen k√∂nnen Sie verwenden, wenn Sie sicher sind, dass die Variable nirgendwo in den Erben der Klasse neu geschrieben wird.  Versuchen wir, den endg√ºltigen Modifikator einer Variablen zuzuweisen.  Wenn wir in unserem Test nur eine Variable erstellt und eine Eigenschaft darauf aufgerufen haben, wird sie einmal initialisiert (das Ergebnis ist von unten).  Wenn wir jedes Mal ehrlich ein neues Objekt erstellen und dessen Variable anfordern, verlangsamt sich die Geschwindigkeit merklich (das Ergebnis ist oben): <br><br><img src="https://habrastorage.org/webt/ef/t7/d7/eft7d7u2wpc4htxcas5tiffnari.png"><br>  <i>Abb.</i>  <i>6: Letzte Variable aufrufen</i> <br><br>  Offensichtlich hat sich der Modifikator nicht f√ºr die Variable entschieden, und er ist immer langsamer als sein Konkurrent. <br><br><h4>  Test 7: Problem des Polymorphismus und Protokolle f√ºr Strukturen.  Oder die Leistung eines existentiellen Containers </h4><br>  Problem: Wenn wir ein Protokoll verwenden, das eine bestimmte Methode und mehrere von diesem Protokoll geerbte Strukturen unterst√ºtzt, was wird unser Compiler denken, wenn wir Strukturen mit unterschiedlichen Volumina gespeicherter Werte in ein Array einf√ºgen, das durch das urspr√ºngliche Protokoll vereint wird? <br><br>  Um das Problem des Aufrufs einer in den Erben vordefinierten Methode zu l√∂sen, wird der Mechanismus der Protokollzeugen-Tabelle verwendet.  Es werden Shell-Strukturen erstellt, die auf die erforderlichen Methoden verweisen. <br><br>  Um das Problem der Datenspeicherung zu l√∂sen, wird ein Existenzcontainer verwendet.  Es speichert in sich 5 Informationszellen mit jeweils 8 Bytes.  In den ersten drei F√§llen wird Speicherplatz f√ºr die in der Struktur gespeicherten Daten zugewiesen (wenn sie nicht passen, wird eine Verkn√ºpfung zu dem Heap hergestellt, in dem die Daten gespeichert sind), in der vierten werden Informationen zu den in der Struktur verwendeten Datentypen gespeichert und die Verwaltung dieser Daten erl√§utert Der f√ºnfte enth√§lt Verweise auf die Methoden des Objekts. <br><br><img src="https://habrastorage.org/webt/jh/tu/6c/jhtu6cgi7hcnllrybgfphk9gx-i.png"><br>  <i>Abbildung 7. Vergleich der Leistung eines Arrays, das eine Verkn√ºpfung zu einem Objekt erstellt und dieses enth√§lt</i> <br><br>  Zwischen dem ersten und dem zweiten Ergebnis hat sich die Anzahl der Variablen verdreifacht.  Theoretisch sollten sie in einen Beh√§lter gegeben werden, sie werden in diesem Beh√§lter aufbewahrt, und der Geschwindigkeitsunterschied ist auf das Volumen der Struktur zur√ºckzuf√ºhren.  Interessanterweise √§ndert sich die Betriebszeit nicht, wenn Sie die Anzahl der Variablen in der zweiten Struktur reduzieren, dh der Container speichert tats√§chlich 3 oder 2 Variablen. Es scheint jedoch spezielle Bedingungen f√ºr eine Variable zu geben, die die Geschwindigkeit erheblich erh√∂hen.  Die zweite Struktur passt perfekt in den Beh√§lter und unterscheidet sich im Volumen von der dritten um die H√§lfte, was zu einer starken Verschlechterung der Laufzeit im Vergleich zu anderen Strukturen f√ºhrt. <br><br><h4>  Ein bisschen Theorie zur Optimierung Ihrer Projekte </h4><br>  Folgende Faktoren k√∂nnen die Leistung von Strukturen beeinflussen: <br><br><ul><li>  wo seine Variablen gespeichert sind (Heap / Stack); </li><li>  die Notwendigkeit der Referenzz√§hlung f√ºr Eigenschaften; </li><li>  Planungsmethoden (statisch / dynamisch); </li><li>  Copy-On-Write wird nur von Datenstrukturen verwendet, bei denen es sich um Referenztypen handelt, die vorgeben, Strukturen (String, Array, Set, Dictionary) unter der Haube zu sein. </li></ul><br>  Es sollte sofort klargestellt werden, dass das schnellste Objekt Objekte sind, die Eigenschaften im Stapel speichern. Verwenden Sie bei der statischen Methode der medizinischen Untersuchung keine Referenzz√§hlung. <br><h4>  Dann sind Klassen im Vergleich zu Strukturen schlecht und gef√§hrlich </h4><br><br>  Wir kontrollieren nicht immer das Kopieren unserer Objekte, und wenn wir dies tun, k√∂nnen wir zu viele Kopien erhalten, die schwierig zu verwalten sind (wir haben im Projekt Objekte erstellt, die beispielsweise f√ºr die Erstellung der Ansicht verantwortlich sind). <br><br>  Sie sind nicht so schnell wie Strukturen. <br><br>  Wenn wir einen Link zu einem Objekt haben und versuchen, unsere Anwendung in einem Multithread-Stil zu steuern, k√∂nnen wir die Race-Bedingung erhalten, wenn unser Objekt von zwei verschiedenen Stellen aus verwendet wird (und dies ist nicht so schwierig, da ein mit Xcode erstelltes Projekt immer etwas langsamer ist). als Store-Version). <br><br>  Wenn wir versuchen, die Race-Bedingung zu vermeiden, geben wir eine Menge Ressourcen f√ºr Lock und unsere Daten aus, was anf√§ngt, Ressourcen zu verbrauchen und Zeit zu verschwenden, anstatt schnell zu verarbeiten, und wir erhalten noch langsamere Objekte als dieselben, die auf Strukturen basieren. <br><br>  Wenn wir alle oben genannten Aktionen an unseren Objekten (Links) ausf√ºhren, ist die Wahrscheinlichkeit unvorhergesehener Deadlocks hoch. <br><br>  Die Komplexit√§t des Codes nimmt dadurch zu. <br><br>  Immer mehr Code = mehr Bugs! <br><br><h4>  Schlussfolgerungen </h4><br>  Ich dachte, dass die Schlussfolgerungen in diesem Artikel einfach notwendig sind, weil ich den Artikel nicht von Zeit zu Zeit lesen m√∂chte und eine konsolidierte Liste von Punkten einfach notwendig ist.  Ich m√∂chte die Zeilen unter den Tests zusammenfassen und Folgendes hervorheben: <br><br><ol><li>  Arrays werden am besten in einem Array platziert. </li><li>  Wenn Sie ein Array aus Klassen erstellen m√∂chten, ist es besser, ein regul√§res Array auszuw√§hlen, da ContiguousArray selten Vorteile bietet und diese nicht sehr hoch sind. </li><li>  Inline-Optimierung beschleunigt die Arbeit, schalten Sie sie nicht aus. </li><li>  Der Zugriff auf Array-Elemente ist immer schneller als der Zugriff auf ContiguousArray-Elemente. </li><li>  Strukturen sind immer schneller als Klassen (es sei denn, Sie aktivieren nat√ºrlich die Optimierung des gesamten Moduls oder eine √§hnliche Optimierung). </li><li>  Wenn ein Objekt an die Funktion √ºbergeben und rufen Sie die Eigenschaften aus der dritten, die Struktur schneller Klassen. </li><li>  Wenn Sie einen Wert an eine f√ºr Generic und Protocol geschriebene Funktion √ºbergeben, ist Generic schneller. </li><li>  Bei der Vererbung mehrerer Klassen nimmt die Geschwindigkeit des Funktionsaufrufs ab. </li><li>  Variablen kennzeichnen die endg√ºltige Arbeit langsamer als normale Paprikaschoten. </li><li>  Wenn eine Funktion ein Objekt akzeptiert, das mehrere Objekte mit dem Protokoll kombiniert, funktioniert es schnell, wenn nur eine Eigenschaft darin gespeichert ist, und wird beim Hinzuf√ºgen weiterer Eigenschaften erheblich beeintr√§chtigt. </li></ol><br>  Referenzen: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">medium.com/@vhart/protocols-generics-and-existential-containers-wait-what-e2e698262ab1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">developer.apple.com/videos/play/wwdc2016/416</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">developer.apple.com/videos/play/wwdc2015/409</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">developer.apple.com/videos/play/wwdc2016/419</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">medium.com/commencis/stop-using-structs-e1be9a86376f</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode testen</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472290/">https://habr.com/ru/post/de472290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472272/index.html">Ein neues Spiel mit einer alten Atmosph√§re auf Three.js. Teil 2</a></li>
<li><a href="../de472274/index.html">Remote SSH: Tipps und Hacks</a></li>
<li><a href="../de472278/index.html">Mein Lieblingsgit Commit</a></li>
<li><a href="../de472280/index.html">Die Aufgabe, das Vorhandensein einer Handfl√§che auf einem Venenscanner festzustellen</a></li>
<li><a href="../de472288/index.html">9 n√ºtzliche Browser-Erweiterungen f√ºr Entwickler (Liste f√ºr 2020)</a></li>
<li><a href="../de472292/index.html">Blockieren von Inhalten: Die Weltb√ºhne</a></li>
<li><a href="../de472294/index.html">Erstelle Spiele und Videos auf YouTube. Mein Interaktionsexperiment und die Einnahmen daraus</a></li>
<li><a href="../de472296/index.html">Auslaufschutzsystem f√ºr eine Waschmaschine</a></li>
<li><a href="../de472298/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 385 (14. - 20. Oktober 2019)</a></li>
<li><a href="../de472300/index.html">Stochastischer Gradientenabstieg (SGD) f√ºr die logarithmische Verlustfunktion (LogLoss) in einem bin√§ren Klassifizierungsproblem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>