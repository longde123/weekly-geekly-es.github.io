<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐬 💡 🧕🏽 Strukturen gegen Klassen 🌎 🤙🏻 ⛹️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von Anfang an, als ich mit dem Programmieren anfing, stellte sich die Frage, was zur Verbesserung der Leistung verwendet werden sollte: Struktur oder ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Strukturen gegen Klassen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472290/">  Von Anfang an, als ich mit dem Programmieren anfing, stellte sich die Frage, was zur Verbesserung der Leistung verwendet werden sollte: Struktur oder Klasse;  Welche Arrays sind besser zu verwenden und wie.  In Bezug auf Strukturen begrüßt Apple ihre Verwendung und erklärt, dass sie besser optimiert werden können und die gesamte Essenz der Swift-Sprache Strukturen sind.  Es gibt jedoch diejenigen, die damit nicht einverstanden sind, da Sie den Code auf wunderbare Weise vereinfachen können, indem Sie eine Klasse von einer anderen erben und mit einer solchen Klasse arbeiten.  Um die Arbeit mit Klassen zu beschleunigen, haben wir verschiedene Modifikatoren und Objekte erstellt, die speziell für Klassen optimiert wurden. Es ist bereits schwierig zu sagen, was in welchem ​​Fall schneller sein wird. <br><br>  Um alle Punkte auf dem „e“ anzuordnen, habe ich mehrere Tests geschrieben, die die üblichen Ansätze für die Datenverarbeitung verwenden: Übergabe an eine Methode, Kopieren, Arbeiten mit Arrays usw.  Ich habe beschlossen, keine großen Schlussfolgerungen zu ziehen. Jeder wird selbst entscheiden, ob es sich lohnt, an die Tests zu glauben, das Projekt herunterladen und sehen, wie es für Sie funktioniert, und versuchen, den Betrieb eines bestimmten Tests zu optimieren.  Vielleicht kommen sogar neue Chips heraus, die ich nicht erwähnt habe, oder sie werden so selten verwendet, dass ich einfach nichts davon gehört habe. <br><a name="habracut"></a><br>  PS Ich habe angefangen, an einem Artikel über Xcode 10.3 zu arbeiten, und ich habe darüber nachgedacht, die Geschwindigkeit mit Xcode 11 zu vergleichen. In diesem Artikel geht es jedoch nicht um den Vergleich zweier Anwendungen, sondern um die Geschwindigkeit unserer Anwendungen.  Ich habe keinen Zweifel daran, dass die Laufzeit von Funktionen abnimmt und die schlecht optimierte schneller wird.  Infolgedessen wartete ich auf den neuen Swift 5.1 und beschloss, die Hypothesen in der Praxis zu testen.  Viel Spaß beim Lesen. <br><br><h4>  Test 1: Vergleichen Sie Arrays auf Strukturen und Klassen </h4><br>  Angenommen, wir haben eine Klasse und möchten die Objekte dieser Klasse in ein Array einfügen. Die übliche Aktion für ein Array besteht darin, sie zu durchlaufen. <br><br>  Wenn in einem Array Klassen verwendet werden und versucht wird, durch das Array zu gehen, erhöht sich die Anzahl der Verknüpfungen. Nach Abschluss verringert sich die Anzahl der Verknüpfungen zum Objekt. <br><br>  Wenn wir die Struktur durchgehen, wird zum Zeitpunkt des Aufrufs des Objekts durch den Index eine Kopie des Objekts erstellt, die denselben Speicherbereich betrachtet, jedoch als unveränderlich markiert ist.  Es ist schwer zu sagen, was schneller ist: Erhöhen Sie die Anzahl der Verknüpfungen zu einem Objekt oder erstellen Sie eine Verknüpfung zu einem Bereich im Speicher, da diese nicht geändert werden kann.  Lassen Sie es uns in der Praxis überprüfen: <br><br><img src="https://habrastorage.org/webt/me/i5/2g/mei52ghwjxv_pg3c1toaoqachty.png"><br>  <i>Abb.</i>  <i>1: Vergleich des Abrufens einer Variablen aus Arrays basierend auf Strukturen und Klassen</i> <br><br><h4>  Test 2. Vergleichen Sie ContiguousArray mit Array </h4><br>  Interessanter ist es, die Leistung eines Arrays (Arrays) mit einem Referenzarray (ContiguousArray) zu vergleichen, das speziell für die Arbeit mit im Array gespeicherten Klassen benötigt wird. <br><br>  Lassen Sie uns die Leistung für die folgenden Fälle überprüfen: <br><br>  ContiguousArray speichert eine Struktur mit dem Werttyp <br>  ContiguousArray speichert Struktur mit String <br>  ContiguousArray-Speicherklasse mit Werttyp <br>  ContiguousArray-Speicherklasse mit String <br>  Array-Speicherstruktur mit Werttyp <br>  Array-Speicherstruktur mit String <br>  Array-Speicherklasse mit Werttyp <br>  Array-Speicherklasse mit String <br><br>  Da die Testergebnisse (Tests: Übergabe an eine Funktion mit deaktivierter Inline-Optimierung, Übergabe an eine Funktion mit aktivierter Inline-Optimierung, Löschen von Elementen, Hinzufügen von Elementen, sequentieller Zugriff auf ein Element in einer Schleife) eine große Anzahl von Tests enthalten (für 8 Arrays mit jeweils 5 Tests) Ich werde die wichtigsten Ergebnisse geben: <br><br><ol><li>  Wenn Sie eine Funktion aufrufen und ein Array übergeben und sie inline deaktivieren, ist ein solcher Aufruf sehr teuer (für Klassen, die auf der Referenzzeichenfolge basieren, ist er 20.000-mal langsamer, für Klassen, die auf Value basieren, ist der Typ 60.000-mal langsamer, schlechter, wenn der Inline-Optimierer deaktiviert ist). . </li><li>  Wenn die Optimierung (Inline) für Sie funktioniert, sollte eine Verschlechterung nur zweimal erwartet werden, je nachdem, welcher Datentyp zu welchem ​​Array hinzugefügt wird.  Die einzige Ausnahme war der Werttyp, der in eine im ContiguousArray liegende Struktur eingebunden war - ohne zeitliche Verschlechterung. </li><li>  Entfernung - Die Streuung zwischen dem Referenzarray und dem üblichen Array betrug etwa 20% (zugunsten des üblichen Arrays). </li><li>  Anhängen - Bei Verwendung von in Klassen eingeschlossenen Objekten war ContiguousArray mit denselben Objekten etwa 20% schneller als Array, während Array bei der Arbeit mit Strukturen schneller war als ContiguousArray mit Strukturen. </li><li>  Der Zugriff auf Array-Elemente bei Verwendung von Wrappern aus Strukturen erwies sich als schneller als alle Wrapper über Klassen, einschließlich ContiguousArray (etwa 500-mal schneller). </li></ol><br>  In den meisten Fällen ist die Verwendung regulärer Arrays für die Arbeit mit Objekten effizienter.  Vorher verwendet, verwenden wir weiter. <br><br>  Die Schleifenoptimierung für Arrays wird vom Lazy Collection-Initialisierer bereitgestellt, mit dem Sie nur einmal über das gesamte Array laufen können, selbst wenn mehrere Filter oder Maps für Array-Elemente verwendet werden. <br><br>  Bei der Verwendung von Strukturen als Optimierungswerkzeug gibt es Fallstricke, z. B. die Verwendung von Typen, auf die intern verwiesen wird: Zeichenfolgen, Wörterbücher, Referenzarrays.  Wenn dann eine Variable, die einen Referenztyp in sich speichert, in eine Funktion eingegeben wird, wird für jedes Element, das eine Klasse ist, eine zusätzliche Referenz erstellt.  Dies hat eine andere Seite, etwas weiter.  Sie können versuchen, eine Wrapper-Klasse über einer Variablen zu verwenden.  Dann erhöht sich die Anzahl der Verknüpfungen beim Übergeben an die Funktion nur für diese, und die Anzahl der Verknüpfungen zu den Werten innerhalb der Struktur bleibt gleich.  Im Allgemeinen möchte ich sehen, wie viele Variablen eines Referenztyps in der Struktur enthalten sein müssen, damit seine Leistung geringer abnimmt als die Leistung von Klassen mit denselben Parametern.  Im Internet gibt es einen Artikel mit dem Titel „Stop Using Structs!“, In dem dieselbe Frage gestellt und beantwortet wird.  Ich habe das Projekt heruntergeladen und beschlossen herauszufinden, was wo passiert und in welchen Fällen wir langsame Strukturen bekommen.  Der Autor zeigt die geringe Leistung von Strukturen im Vergleich zu Klassen und argumentiert, dass das Erstellen eines neuen Objekts viel langsamer ist als das Erhöhen des Verweises auf das Objekt absurd (daher habe ich die Zeile entfernt, in der jedes Mal ein neues Objekt in der Schleife erstellt wird).  Wenn wir jedoch keine Verknüpfung zum Objekt erstellen, sondern es einfach an eine Funktion übergeben, um damit zu arbeiten, ist der Leistungsunterschied sehr unbedeutend.  Jedes Mal, wenn wir eine Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">inline</a> (nie) setzen, muss unsere Anwendung sie ausführen und darf keinen Code in einer Zeichenfolge erstellen.  Nach den Tests hat Apple dafür gesorgt, dass das an die Funktion übergebene Objekt geringfügig geändert wird. Bei Strukturen ändert der Compiler die Veränderbarkeit und macht den Zugriff auf nicht veränderbare Eigenschaften des Objekts verzögert.  Ähnliches passiert in der Klasse, erhöht aber gleichzeitig die Anzahl der Verweise auf das Objekt.  Und jetzt haben wir ein faules Objekt, alle seine Felder sind auch faul und jedes Mal, wenn wir eine Objektvariable aufrufen, wird sie initialisiert.  Dabei sind Strukturen nicht gleich: Wenn eine Funktion zwei Variablen aufruft, ist die Struktur des Objekts der Geschwindigkeitsklasse nur geringfügig unterlegen;  Wenn Sie drei oder mehr aufrufen, ist die Struktur immer schneller. <br><br><h4>  Test 3: Vergleichen Sie die Leistung von Strukturen und Klassen, in denen große Klassen gespeichert sind </h4><br>  Außerdem bin ich ein wenig verändert sich Methode, die aufgerufen wird, wenn Sie eine weitere Variable hinzu (und somit in dem Verfahren initialisiert drei Variablen, und nicht zwei wie in dem Artikel), und dass es kein Überlauf Int Ersetzen Operationen auf Variablen in der Summe und Subtraktion.  Verständlichere Zeitmetriken hinzugefügt (im Screenshot sind es Sekunden, aber es ist nicht so wichtig für uns, das Verständnis der resultierenden Proportionen ist wichtig), Entfernen des Darwin-Frameworks (ich verwende es nicht in Projekten, möglicherweise vergeblich, es gibt keine Unterschiede in den Tests vor / nach dem Hinzufügen des Frameworks in meinem Test). die Einbeziehung maximaler Optimierung und Aufbau auf dem Release-Build (es scheint, dass dies ehrlicher sein wird), und hier ist das Ergebnis: <br><br><img src="https://habrastorage.org/webt/zv/q_/en/zvq_ens-bwgnuetcl53shkecjd0.png"><br>  <i>Abb.</i>  <i>2: Leistung von Strukturen und Klassen aus dem Artikel „Stop Using Structs“</i> <br><br>  Die Unterschiede in den Testergebnissen sind vernachlässigbar. <br><br><h4>  Test 4: Funktion, die Generika, Protokolle und Funktionen ohne Generika akzeptiert </h4><br>  Wenn wir eine generische Funktion übernehmen und dort zwei Werte übergeben, die nur durch die Möglichkeit zum Vergleichen dieser Werte (func min) vereint sind, wird der Code aus drei Zeilen in einen Code aus acht (wie Apple sagt).  Dies ist jedoch nicht immer der Fall. Xcode verfügt über Optimierungsmethoden, bei denen beim Aufrufen einer Funktion, wenn zwei Strukturwerte an Xcode übergeben werden, automatisch eine Funktion generiert wird, die zwei Strukturen akzeptiert und die Werte nicht mehr kopiert. <br><br><img src="https://habrastorage.org/webt/zo/fd/2v/zofd2v5qz7q3dkhzdcp_srpspyg.png"><br>  <i>Abb.</i>  <i>3: Typische generische Funktion</i> <br><br>  Ich habe beschlossen, zwei Funktionen zu testen: In der ersten wird der generische Datentyp deklariert, in der zweiten wird nur das Protokoll akzeptiert.  In der neuen Version des Swift 5.1-Protokolls ist es sogar etwas schneller als Generic (vor Swift 5.1 waren die Protokolle zweimal langsamer), obwohl es laut Apple umgekehrt sein sollte, aber wenn es um das Durchlaufen eines Arrays geht, müssen wir bereits tippen, was langsamer wird Generisch (aber sie sind immer noch großartig, weil sie schneller als Protokolle sind): <br><br><img src="https://habrastorage.org/webt/k-/ox/vr/k-oxvrhsx5mbw_osj7azkzu9x7y.png"><br>  <i>Abb.</i>  <i>4: Vergleich der generischen und Protokoll-Hostfunktionen.</i> <br><br><h4>  Test 5: Vergleichen Sie den Aufruf der übergeordneten Methode mit der nativen und überprüfen Sie gleichzeitig die letzte Klasse auf einen solchen Aufruf </h4><br>  Was mich immer interessiert hat, ist, wie langsam Klassen mit einer großen Anzahl von Eltern arbeiten, wie schnell eine Klasse ihre Funktionen und die eines Elternteils aufruft.  In Fällen, in denen wir versuchen, eine Methode aufzurufen, die eine Klasse akzeptiert, kommt der dynamische Versand ins Spiel.  Was ist das?  Jedes Mal, wenn eine Methode oder Variable in unserer Funktion aufgerufen wird, wird eine Nachricht generiert, in der das Objekt nach dieser Variablen oder Methode gefragt wird.  Das Objekt, das eine solche Anforderung empfängt, beginnt die Suche nach der Methode in der Versandtabelle seiner Klasse. Wenn eine Überschreibung der Methode oder Variablen aufgerufen wurde, nimmt es diese und gibt sie zurück oder erreicht rekursiv die Basisklasse. <br><br><img src="https://habrastorage.org/webt/tr/wz/i-/trwzi-l8v51yv4oftdl33a-30z4.png"><br>  <i>Abb.</i>  <i>5: Klassenmethodenaufrufe für Versandtests</i> <br><br>  Aus dem obigen Test können mehrere Schlussfolgerungen gezogen werden: Je größer die Klasse der übergeordneten Klassen ist, desto langsamer arbeitet sie und der Geschwindigkeitsunterschied ist so gering, dass er sicher vernachlässigt werden kann. Die Codeoptimierung führt höchstwahrscheinlich dazu, dass es keinen Geschwindigkeitsunterschied gibt.  In diesem Beispiel hat der endgültige Klassenmodifikator keinen Vorteil, im Gegenteil, die Arbeit der Klasse ist noch langsamer, möglicherweise aufgrund der Tatsache, dass sie keine wirklich schnelle Funktion wird. <br><br><h4>  Test 6: Aufrufen einer Variablen mit dem letzten Modifikator gegen eine reguläre Klassenvariable </h4><br>  Auch sehr interessante Ergebnisse beim Zuweisen des endgültigen Modifikators zu einer Variablen können Sie verwenden, wenn Sie sicher sind, dass die Variable nirgendwo in den Erben der Klasse neu geschrieben wird.  Versuchen wir, den endgültigen Modifikator einer Variablen zuzuweisen.  Wenn wir in unserem Test nur eine Variable erstellt und eine Eigenschaft darauf aufgerufen haben, wird sie einmal initialisiert (das Ergebnis ist von unten).  Wenn wir jedes Mal ehrlich ein neues Objekt erstellen und dessen Variable anfordern, verlangsamt sich die Geschwindigkeit merklich (das Ergebnis ist oben): <br><br><img src="https://habrastorage.org/webt/ef/t7/d7/eft7d7u2wpc4htxcas5tiffnari.png"><br>  <i>Abb.</i>  <i>6: Letzte Variable aufrufen</i> <br><br>  Offensichtlich hat sich der Modifikator nicht für die Variable entschieden, und er ist immer langsamer als sein Konkurrent. <br><br><h4>  Test 7: Problem des Polymorphismus und Protokolle für Strukturen.  Oder die Leistung eines existentiellen Containers </h4><br>  Problem: Wenn wir ein Protokoll verwenden, das eine bestimmte Methode und mehrere von diesem Protokoll geerbte Strukturen unterstützt, was wird unser Compiler denken, wenn wir Strukturen mit unterschiedlichen Volumina gespeicherter Werte in ein Array einfügen, das durch das ursprüngliche Protokoll vereint wird? <br><br>  Um das Problem des Aufrufs einer in den Erben vordefinierten Methode zu lösen, wird der Mechanismus der Protokollzeugen-Tabelle verwendet.  Es werden Shell-Strukturen erstellt, die auf die erforderlichen Methoden verweisen. <br><br>  Um das Problem der Datenspeicherung zu lösen, wird ein Existenzcontainer verwendet.  Es speichert in sich 5 Informationszellen mit jeweils 8 Bytes.  In den ersten drei Fällen wird Speicherplatz für die in der Struktur gespeicherten Daten zugewiesen (wenn sie nicht passen, wird eine Verknüpfung zu dem Heap hergestellt, in dem die Daten gespeichert sind), in der vierten werden Informationen zu den in der Struktur verwendeten Datentypen gespeichert und die Verwaltung dieser Daten erläutert Der fünfte enthält Verweise auf die Methoden des Objekts. <br><br><img src="https://habrastorage.org/webt/jh/tu/6c/jhtu6cgi7hcnllrybgfphk9gx-i.png"><br>  <i>Abbildung 7. Vergleich der Leistung eines Arrays, das eine Verknüpfung zu einem Objekt erstellt und dieses enthält</i> <br><br>  Zwischen dem ersten und dem zweiten Ergebnis hat sich die Anzahl der Variablen verdreifacht.  Theoretisch sollten sie in einen Behälter gegeben werden, sie werden in diesem Behälter aufbewahrt, und der Geschwindigkeitsunterschied ist auf das Volumen der Struktur zurückzuführen.  Interessanterweise ändert sich die Betriebszeit nicht, wenn Sie die Anzahl der Variablen in der zweiten Struktur reduzieren, dh der Container speichert tatsächlich 3 oder 2 Variablen. Es scheint jedoch spezielle Bedingungen für eine Variable zu geben, die die Geschwindigkeit erheblich erhöhen.  Die zweite Struktur passt perfekt in den Behälter und unterscheidet sich im Volumen von der dritten um die Hälfte, was zu einer starken Verschlechterung der Laufzeit im Vergleich zu anderen Strukturen führt. <br><br><h4>  Ein bisschen Theorie zur Optimierung Ihrer Projekte </h4><br>  Folgende Faktoren können die Leistung von Strukturen beeinflussen: <br><br><ul><li>  wo seine Variablen gespeichert sind (Heap / Stack); </li><li>  die Notwendigkeit der Referenzzählung für Eigenschaften; </li><li>  Planungsmethoden (statisch / dynamisch); </li><li>  Copy-On-Write wird nur von Datenstrukturen verwendet, bei denen es sich um Referenztypen handelt, die vorgeben, Strukturen (String, Array, Set, Dictionary) unter der Haube zu sein. </li></ul><br>  Es sollte sofort klargestellt werden, dass das schnellste Objekt Objekte sind, die Eigenschaften im Stapel speichern. Verwenden Sie bei der statischen Methode der medizinischen Untersuchung keine Referenzzählung. <br><h4>  Dann sind Klassen im Vergleich zu Strukturen schlecht und gefährlich </h4><br><br>  Wir kontrollieren nicht immer das Kopieren unserer Objekte, und wenn wir dies tun, können wir zu viele Kopien erhalten, die schwierig zu verwalten sind (wir haben im Projekt Objekte erstellt, die beispielsweise für die Erstellung der Ansicht verantwortlich sind). <br><br>  Sie sind nicht so schnell wie Strukturen. <br><br>  Wenn wir einen Link zu einem Objekt haben und versuchen, unsere Anwendung in einem Multithread-Stil zu steuern, können wir die Race-Bedingung erhalten, wenn unser Objekt von zwei verschiedenen Stellen aus verwendet wird (und dies ist nicht so schwierig, da ein mit Xcode erstelltes Projekt immer etwas langsamer ist). als Store-Version). <br><br>  Wenn wir versuchen, die Race-Bedingung zu vermeiden, geben wir eine Menge Ressourcen für Lock und unsere Daten aus, was anfängt, Ressourcen zu verbrauchen und Zeit zu verschwenden, anstatt schnell zu verarbeiten, und wir erhalten noch langsamere Objekte als dieselben, die auf Strukturen basieren. <br><br>  Wenn wir alle oben genannten Aktionen an unseren Objekten (Links) ausführen, ist die Wahrscheinlichkeit unvorhergesehener Deadlocks hoch. <br><br>  Die Komplexität des Codes nimmt dadurch zu. <br><br>  Immer mehr Code = mehr Bugs! <br><br><h4>  Schlussfolgerungen </h4><br>  Ich dachte, dass die Schlussfolgerungen in diesem Artikel einfach notwendig sind, weil ich den Artikel nicht von Zeit zu Zeit lesen möchte und eine konsolidierte Liste von Punkten einfach notwendig ist.  Ich möchte die Zeilen unter den Tests zusammenfassen und Folgendes hervorheben: <br><br><ol><li>  Arrays werden am besten in einem Array platziert. </li><li>  Wenn Sie ein Array aus Klassen erstellen möchten, ist es besser, ein reguläres Array auszuwählen, da ContiguousArray selten Vorteile bietet und diese nicht sehr hoch sind. </li><li>  Inline-Optimierung beschleunigt die Arbeit, schalten Sie sie nicht aus. </li><li>  Der Zugriff auf Array-Elemente ist immer schneller als der Zugriff auf ContiguousArray-Elemente. </li><li>  Strukturen sind immer schneller als Klassen (es sei denn, Sie aktivieren natürlich die Optimierung des gesamten Moduls oder eine ähnliche Optimierung). </li><li>  Wenn ein Objekt an die Funktion übergeben und rufen Sie die Eigenschaften aus der dritten, die Struktur schneller Klassen. </li><li>  Wenn Sie einen Wert an eine für Generic und Protocol geschriebene Funktion übergeben, ist Generic schneller. </li><li>  Bei der Vererbung mehrerer Klassen nimmt die Geschwindigkeit des Funktionsaufrufs ab. </li><li>  Variablen kennzeichnen die endgültige Arbeit langsamer als normale Paprikaschoten. </li><li>  Wenn eine Funktion ein Objekt akzeptiert, das mehrere Objekte mit dem Protokoll kombiniert, funktioniert es schnell, wenn nur eine Eigenschaft darin gespeichert ist, und wird beim Hinzufügen weiterer Eigenschaften erheblich beeinträchtigt. </li></ol><br>  Referenzen: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">medium.com/@vhart/protocols-generics-and-existential-containers-wait-what-e2e698262ab1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">developer.apple.com/videos/play/wwdc2016/416</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">developer.apple.com/videos/play/wwdc2015/409</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">developer.apple.com/videos/play/wwdc2016/419</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">medium.com/commencis/stop-using-structs-e1be9a86376f</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellcode testen</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472290/">https://habr.com/ru/post/de472290/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472272/index.html">Ein neues Spiel mit einer alten Atmosphäre auf Three.js. Teil 2</a></li>
<li><a href="../de472274/index.html">Remote SSH: Tipps und Hacks</a></li>
<li><a href="../de472278/index.html">Mein Lieblingsgit Commit</a></li>
<li><a href="../de472280/index.html">Die Aufgabe, das Vorhandensein einer Handfläche auf einem Venenscanner festzustellen</a></li>
<li><a href="../de472288/index.html">9 nützliche Browser-Erweiterungen für Entwickler (Liste für 2020)</a></li>
<li><a href="../de472292/index.html">Blockieren von Inhalten: Die Weltbühne</a></li>
<li><a href="../de472294/index.html">Erstelle Spiele und Videos auf YouTube. Mein Interaktionsexperiment und die Einnahmen daraus</a></li>
<li><a href="../de472296/index.html">Auslaufschutzsystem für eine Waschmaschine</a></li>
<li><a href="../de472298/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 385 (14. - 20. Oktober 2019)</a></li>
<li><a href="../de472300/index.html">Stochastischer Gradientenabstieg (SGD) für die logarithmische Verlustfunktion (LogLoss) in einem binären Klassifizierungsproblem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>