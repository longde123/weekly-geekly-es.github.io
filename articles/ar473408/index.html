<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏾 🧔🏻 📕 تصحيح أخطاء الذاكرة المخفية في روبي ✡️ 🍀 🚠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="في عام 2015 ، كتبت عن الأدوات التي يوفرها روبي للكشف عن تسرب الذاكرة المدارة . في الغالب ، تحدث المقال عن تسريبات يمكن التحكم فيها بسهولة. هذه المرة س...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>تصحيح أخطاء الذاكرة المخفية في روبي</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/473408/" style=";text-align:right;direction:rtl"><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/vx/sf/qs/vxsfqsmdrslng_xf3oslr5os3ge.jpeg"></div><br>  في عام 2015 ، كتبت عن الأدوات التي يوفرها روبي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">للكشف عن تسرب الذاكرة المدارة</a> .  في الغالب ، تحدث المقال عن تسريبات يمكن التحكم فيها بسهولة.  هذه المرة سأتحدث عن الأدوات والحيل التي يمكنك استخدامها للقضاء على التسريبات التي ليس من السهل تحليلها في روبي.  على وجه الخصوص ، سأتحدث عن mwrap و heaptrack و iseq_collector و chap. <br><a name="habracut"></a><br><div style="text-align:center;;text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/5cd/bda/07b/5cdbda07b31678a618b6f6205f5f9722.png"></div><br><h1 style=";text-align:right;direction:rtl">  تسرب الذاكرة غير المدارة </h1><br>  هذا البرنامج الصغير يثير تسربًا مع دعوة مباشرة إلى malloc.  يبدأ باستهلاك 16 ميغابايت من RSS ، وينتهي بـ 118 ميغابايت.  يضع الكود في الذاكرة 100 ألف كتلة من 1024 بايت ويحذف 50 ألف منهم. <br><br><pre style=";text-align:right;direction:rtl"><code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'fiddle'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'objspace'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rss</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">`</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ps</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">-</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#{Process.pid} -o rss -h`.strip.to_i * 1024 puts "RSS: #{rss / 1024} ObjectSpace size #{ObjectSpace.memsize_of_all / 1024}" end def leak_memory pointers = [] 100_000.times do i = Fiddle.malloc(1024) pointers &lt;&lt; i end 50_000.times do Fiddle.free(pointers.pop) end end usage # RSS: 16044 ObjectSpace size 2817 leak_memory usage # RSS: 118296 ObjectSpace size 3374</span></span></span></span></code> </pre> <br>  على الرغم من أن RSS يبلغ 118 ميجابايت ، إلا أن كائن Ruby الخاص بنا لا يعرف سوى ثلاثة ميغابايت.  في التحليل ، نرى جزءًا صغيرًا جدًا من تسرب الذاكرة الكبير جدًا. <br><br>  مثال حقيقي على مثل هذا التسرب <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">وصفه أوليغ داشفسكي</a> ، أوصي بقراءة هذا المقال الرائع. <br><br><h1 style=";text-align:right;direction:rtl">  تطبيق Mwrap </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Mwrap</a> هو ملف تعريف للذاكرة لـ Ruby يقوم بمراقبة جميع عمليات تخصيص البيانات في الذاكرة عن طريق اعتراض malloc والوظائف الأخرى لهذه العائلة.  يعترض المكالمات ذلك المكان والذاكرة الخالية باستخدام <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">LD_PRELOAD</a> .  يستخدم <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">liburcu</a> للعد ويمكنه تتبع عدادات التخصيص والحذف لكل نقطة اتصال في كود C و Ruby.  Mwrap صغير الحجم ، أي حوالي ضعف حجم RSS لبرنامج مخصَّص ، وحوالي بطئ. <br><br>  إنه يختلف عن العديد من المكتبات الأخرى في حجمها الصغير جدًا ودعمها لروبي.  يتتبع المواقع في ملفات Ruby ولا يقتصر على التراجع عن مستوى c + masif التراجع والملفات التعريف مماثلة.  هذا يبسط إلى حد كبير عزل مصادر المشاكل. <br><br>  لاستخدام ملف التعريف ، تحتاج إلى تشغيل التطبيق من خلال Mwrap shell ، وسوف تنفذ بيئة LD_PRELOAD وتشغيل ثنائي روبي. <br><br>  دعنا نضيف Mwrap إلى نصنا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'mwrap'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">report_leaks</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">results</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">[]</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mwrap</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">location</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">total</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">allocations</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frees</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">age_total</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max_lifespan</span></span></span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">|</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">results</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">&lt;&lt;</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">location</span></span></span><span class="hljs-function">, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">((total / allocations.to_f)</span></span></span></span> * (allocations - frees)), allocations, frees] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> results.sort! <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|(_, growth_a), (_, growth_b)|</span></span> growth_b &lt;=&gt; growth_a <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> results[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">20</span></span>].each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|location, growth, allocations, frees|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> growth == <span class="hljs-number"><span class="hljs-number">0</span></span> puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{location}</span></span></span><span class="hljs-string"> growth: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{growth.to_i}</span></span></span><span class="hljs-string"> allocs/frees (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{allocations}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{frees}</span></span></span><span class="hljs-string">)"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> GC.start Mwrap.clear leak_memory GC.start <span class="hljs-comment"><span class="hljs-comment"># Don't track allocations for this block Mwrap.quiet do report_leaks end</span></span></code> </pre> <br>  الآن قم بتشغيل البرنامج النصي باستخدام برنامج Mwrap: <br><br><pre style=";text-align:right;direction:rtl"> <code class="ruby hljs">% gem install mwrap % mwrap ruby leak.rb leak.<span class="hljs-symbol"><span class="hljs-symbol">rb:</span></span><span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-symbol"><span class="hljs-symbol">growth:</span></span> <span class="hljs-number"><span class="hljs-number">51200000</span></span> allocs/frees (<span class="hljs-number"><span class="hljs-number">100000</span></span>/<span class="hljs-number"><span class="hljs-number">50000</span></span>) leak.<span class="hljs-symbol"><span class="hljs-symbol">rb:</span></span><span class="hljs-number"><span class="hljs-number">51</span></span> <span class="hljs-symbol"><span class="hljs-symbol">growth:</span></span> <span class="hljs-number"><span class="hljs-number">4008</span></span> allocs/frees (<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  اكتشف Mwrap تسربًا صحيحًا في البرنامج النصي (50000 * 1024).  وليس فقط تحديد ، ولكن أيضا عزل خط معين ( <code>i = Fiddle.malloc(1024)</code> ) ، مما أدى إلى تسرب.  يرتبط منشئ ملفات التعريف بشكل صحيح إلى المكالمات إلى <code>Fiddle.free</code> . <br><br>  من المهم الإشارة إلى أننا نتعامل مع التقييم.  تراقب Mwrap الذاكرة المشتركة المخصصة من قِبل نظير الطلب ، ثم تراقب تحرير الذاكرة.  ولكن إذا كان لديك نقطة اتصال واحدة تخصص كتل ذاكرة بأحجام مختلفة ، فستكون النتيجة غير دقيقة.  لدينا إمكانية الوصول إلى التقييم: <code>((total / allocations) * (allocations - frees))</code> <br><br>  بالإضافة إلى ذلك ، لتبسيط تتبع التسرب ، يقوم Mwrap بتتبع <code>age_total</code> ، وهو مجموع عمر كل عنصر تم تحريره ، ويتتبع أيضًا <code>max_lifespan</code> ، عمر العنصر الأقدم في نقطة الاتصال.  إذا كان <code>age_total / frees</code> كبيرًا ، فإن استهلاك الذاكرة يتزايد على الرغم من العديد من مجموعات البيانات المهملة. <br><br>  Mwrap لديه العديد من المساعدين للحد من الضوضاء.  سوف <code>Mwrap.clear</code> مسح جميع التخزين الداخلية.  <code>Mwrap.quiet {}</code> Mwrap لتتبع كتلة التعليمات البرمجية. <br><br>  ميزة أخرى مميزة في Mwrap هي تتبع العدد الإجمالي للبايتات المخصصة والمحررة.  إزالة <code>clear</code> من البرنامج النصي وتشغيله: <br><br><pre style=";text-align:right;direction:rtl"> <code class="ruby hljs">usage puts <span class="hljs-string"><span class="hljs-string">"Tracked size: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{(Mwrap.total_bytes_allocated - Mwrap.total_bytes_freed) / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1024</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment"># RSS: 130804 ObjectSpace size 3032 # Tracked size: 91691</span></span></code> </pre> <br>  النتيجة مثيرة جدًا للاهتمام ، لأنه على الرغم من حجم RSS الذي يبلغ 130 ميغابايت ، فإن Mwrap لا ترى سوى 91 ميغابايت.  هذا يشير إلى أننا قمنا بتضخيم عمليتنا.  يظهر التنفيذ بدون Mwrap أن العملية في الوضع الطبيعي تستغرق 118 ميجابايت ، وفي هذه الحالة البسيطة كان الفرق 12 ميجابايت.  أدى تخصيص / تحرير نمط إلى تجزئة.  يمكن أن تكون هذه المعرفة مفيدة للغاية ، في بعض الحالات ، يعالج glibc malloc غير المُصنَّع جزءًا كبيرًا بحيث تكون المساحة الكبيرة جدًا من الذاكرة المستخدمة في RSS مجانية. <br><br><h1 style=";text-align:right;direction:rtl">  يمكن Mwrap عزل تسرب redcarpet القديم؟ </h1><br>  في <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقالته ،</a> يناقش أوليغ طريقة شاملة للغاية لعزل تسرب ضئيل للغاية في السجادة الحمراء.  هناك العديد من التفاصيل.  من المهم جدا أن تأخذ القياسات.  إذا كنت لا تبني جدولًا زمنيًا لعملية RSS ، فمن غير المرجح أن تكون قادرًا على التخلص من أي تسربات. <br><br>  دعنا ندخل في آلة الزمن ونوضح مدى سهولة استخدام Mwrap لمثل هذه التسريبات. <br><br><pre style=";text-align:right;direction:rtl"> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">red_carpet_leak</span></span></span><span class="hljs-function"> 100</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_000</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">markdown</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Redcarpet</span></span></span><span class="hljs-function">::</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Markdown</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Redcarpet::Render::HTML, extensions = {})</span></span></span></span> markdown.render(<span class="hljs-string"><span class="hljs-string">"hi"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> GC.start Mwrap.clear red_carpet_leak GC.start <span class="hljs-comment"><span class="hljs-comment"># Don't track allocations for this block Mwrap.quiet do report_leaks end</span></span></code> </pre> <br>  Redcarpet 3.3.2: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">redcarpet.rb:51 growth: 22724224 allocs/frees (500048/400028) redcarpet.rb:62 growth: 4008 allocs/frees (1/0) redcarpet.rb:52 growth: 634 allocs/frees (600007/600000)</code> </pre> <br>  Redcarpet 3.5.0: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">redcarpet.rb:51 growth: 4433 allocs/frees (600045/600022) redcarpet.rb:52 growth: 453 allocs/frees (600005/600000)</code> </pre> <br>  إذا كنت تستطيع تشغيل العملية بنصف السرعة عن طريق إعادة تشغيلها ببساطة في منتج Mwrap مع تسجيل النتيجة إلى ملف ، فيمكنك تحديد نطاق واسع من تسرب الذاكرة. <br><br><h1 style=";text-align:right;direction:rtl">  تسرب غامض </h1><br>  في الآونة الأخيرة ، تم تحديث Rails إلى الإصدار 6. بشكل عام ، كانت التجربة إيجابية للغاية ، وظل الأداء على حاله تقريبًا.  يحتوي Rails 6 على بعض الميزات الجيدة جدًا التي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">سنستخدمها</a> (على سبيل المثال <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Zeitwerk</a> ).  غيّرت القضبان طريقة عرض القوالب ، مما تطلب بعض التغييرات من أجل التوافق.  بعد أيام قليلة من التحديث ، لاحظنا زيادة في أداء مهام تطبيق Sidekiq لـ RSS. <br><br>  ذكرت Mwrap زيادة حادة في استهلاك الذاكرة بسبب تخصيصها ( <a href="">الرابط</a> ): <br><br><pre style=";text-align:right;direction:rtl"> <code class="ruby hljs"> source.encode! <span class="hljs-comment"><span class="hljs-comment"># Now, validate that the source we got back from the template # handler is valid in the default_internal. This is for handlers # that handle encoding but screw up unless source.valid_encoding? raise WrongEncodingError.new(source, Encoding.default_internal) end begin mod.module_eval(source, identifier, 0) rescue SyntaxError # Account for when code in the template is not syntactically valid; eg if we're using # ERB and the user writes &lt;%= foo( %&gt;, attempting to call a helper `foo` and interpolate # the result into the template, but missing an end parenthesis. raise SyntaxErrorInTemplate.new(self, original_source) end end def handle_render_error(view, e) if e.is_a?(Template::Error)</span></span></code> </pre> <br>  في البداية كنا في حيرة للغاية.  كنا نحاول أن نفهم لماذا غير راضين عن Mwrap؟  ربما كسر؟  كما نما استهلاك الذاكرة ، ظلت أكوام في روبي دون تغيير. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d0/79b/b60/7d079bb600f7d072515d081bb584c500.png"><br><br>  استهلك مليوني فتحات في الكومة 78 ميغابايت فقط (40 بايت لكل فتحة).  يمكن أن تشغل الخطوط والمصفوفات مساحة أكبر ، لكنها لم تفسر استهلاك الذاكرة غير الطبيعي الذي لاحظناه.  تم تأكيد ذلك عندما قمت <code>rbtrace -p SIDEKIQ_PID -e ObjectSpace.memsize_of_all</code> . <br><br>  أين ذهبت الذاكرة؟ <br><br><h1 style=";text-align:right;direction:rtl">  Heaptrack </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Heaptrack</a> هو ملف تعريف ذاكرة كومة لنظام التشغيل Linux. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أوضحت</a> ميليان وولف تمامًا كيف يعمل المحلل وتحدثت عنه في عدة خطب ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">1</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">2</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">3</a> ).  في الواقع ، إنه ملف تعريف كومة أصلي فعال للغاية يقوم ، بمساعدة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">libunwind ،</a> بجمع backtraces من التطبيقات <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">المحمية</a> .  إنه يعمل بشكل أسرع بشكل ملحوظ من <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">Valgrind / Massif</a> ولديه القدرة على جعله أكثر ملاءمة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">للتوصيف</a> المؤقت في المنتج.  يمكن إرفاقه بعملية قيد التشغيل بالفعل! <br><br>  كما هو الحال مع معظم محبي كومة الذاكرة المؤقتة ، عند استدعاء كل وظيفة في عائلة malloc ، يجب على Heaptrack الاعتماد.  هذا الإجراء بالتأكيد يبطئ العملية قليلاً. <br><br>  في رأيي ، الهندسة المعمارية هنا هي الأفضل للجميع.  يتم تنفيذ اعتراض باستخدام <code>LD_PRELOAD</code> أو <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">GDB</a> لتحميل منشئ ملفات التعريف.  باستخدام <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ملف FIFO خاص ،</a> يقوم بنقل البيانات من عملية التشكيل الجانبي في أسرع وقت ممكن.  إن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أداة</a> التفاف <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">heaptrack</a> عبارة عن برنامج نصي بسيط يسهل العثور على مشكلة.  تقرأ العملية الثانية معلومات من FIFO وضغطات تتبع بيانات التتبع.  نظرًا لأن Heaptrack يعمل مع "قطع" ، يمكنك تحليل الملف الشخصي بعد ثوانٍ قليلة من بداية التوصيف ، في منتصف الجلسة مباشرة.  ما عليك سوى نسخ ملف التعريف إلى موقع آخر وإطلاق واجهة المستخدم الرسومية Heaptrack. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">أخبرتني تذكرة GitLab</a> هذه عن إمكانية إطلاق Heaptrack.  إذا تمكنوا من تشغيله ، فيمكنني ذلك. <br><br>  يتم تشغيل <code>--cap-add=SYS_PTRACE</code> ، <code>--cap-add=SYS_PTRACE</code> إلى إعادة تشغيله باستخدام <code>--cap-add=SYS_PTRACE</code> ، مما يسمح لـ GDB باستخدام <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ptrace</a> ، وهو أمر ضروري لـ Heaptrack لحقن نفسه.  أحتاج أيضًا إلى <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اختراق صغير</a> لملف shell لتطبيق <code>root</code> على ملف تعريف العملية غير <code>root</code> (أطلقنا تطبيق Discourse لدينا في الحاوية تحت حساب محدود). <br><br>  بعد الانتهاء من كل شيء ، يبقى فقط تنفيذ <code>heaptrack -p PID</code> وانتظار ظهور النتائج.  تبين أن Heaptrack أداة ممتازة ، فقد كان من السهل جدًا تتبع كل ما يحدث مع تسرب الذاكرة. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72c/9ad/a55/72c9ada55ca01cb02e06d1b433fab705.png"><br><br>  على الرسم البياني ، ترى قفزتين ، واحدة بسبب <code>cppjieba</code> ، والأخرى بسبب <code>objspace_xmalloc0</code> في روبي. <br><br>  كنت أعرف عن <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">cppjieba</a> .  تقسيم اللغة الصينية غالي الثمن ، فأنت بحاجة إلى قواميس كبيرة ، لذلك هذا ليس تسربًا.  ولكن ماذا عن تخصيص الذاكرة في روبي ، والتي ما زالت لا تخبرني بذلك؟ <br><br><img src="https://habrastorage.org/getpro/habr/post_images/340/72a/c57/34072ac5776eea391854dabe54f18056.png"><br><br>  يرتبط الربح الرئيسي بـ <code>iseq_set_sequence</code> في <code>compile.c</code> .  اتضح أن التسرب يرجع إلى تسلسل التعليمات.  هذا تطهير تسرب اكتشفها Mwrap.  كان السبب هو <code>mod.module_eval(source, identifier, 0)</code> ، مما أدى إلى إنشاء تسلسل للتعليمات التي لم يتم حذفها من الذاكرة. <br><br>  إذا ، في تحليل بأثر رجعي ، فكرت بعناية في تفريغ كومة من روبي ، ثم كنت قد لاحظت كل هذه IMEMOs ، لأنها مدرجة في هذا التفريغ.  إنها ببساطة غير مرئية أثناء عمليات التشخيص. <br><br>  من هذه النقطة ، كان تصحيح الأخطاء بسيطًا جدًا.  لقد تتبعت جميع المكالمات إلى وحدة eval وألقيت ما قيمته.  لقد وجدنا أننا نضيف طرقًا إلى فصل كبير مرارًا وتكرارًا.  فيما يلي عرض مبسط للأخطاء التي واجهناها: <br><br><pre style=";text-align:right;direction:rtl"> <code class="python hljs">require <span class="hljs-string"><span class="hljs-string">'securerandom'</span></span> module BigModule; end <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak_methods</span></span></span><span class="hljs-function"> 10</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_000</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">times</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function"> = "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_</span></span></span><span class="hljs-function">#{</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SecureRandom</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hex</span></span></span><span class="hljs-function">}; #{"</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function">;" * 100}; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function">" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BigModule</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">module_eval</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(method)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usage</span></span></span><span class="hljs-function"> # </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RSS</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-number"><span class="hljs-number">16164</span></span> ObjectSpace size <span class="hljs-number"><span class="hljs-number">2869</span></span> leak_methods usage <span class="hljs-comment"><span class="hljs-comment"># RSS: 123096 ObjectSpace size 5583</span></span></code> </pre> <br>  يحتوي روبي على فئة لتخزين تسلسلات <code>RubyVM::InstructionSequence</code> من التعليمات: <code>RubyVM::InstructionSequence</code> .  ومع ذلك ، يعتبر Ruby كسولًا جدًا في إنشاء هذه الكائنات المجمعة ، لأن تخزينها دون داعٍ يكون غير فعال.  أنشأ كويتشي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">ساسادا</a> تبعية <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">iseq_collector</a> .  إذا أضفنا هذا الرمز ، يمكننا أن نجد ذاكرتنا المخفية: <br><br><pre style=";text-align:right;direction:rtl"> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'iseq_collector'</span></span> puts <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{ObjectSpace.memsize_of_all_iseq / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1024</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-comment"><span class="hljs-comment"># 98747 ObjectSpace.memsize_of_all_iseq</span></span></code> </pre> <br>  يجسد كل سلسلة من التعليمات ، والتي يمكن أن تزيد بشكل طفيف من استهلاك الذاكرة للعملية وتجعل جامع البيانات المهملة أكثر من ذلك بقليل. <br><br>  على سبيل المثال ، إذا قمنا بحساب عدد ISEQs قبل وبعد بدء المجمع ، فسنرى أنه بعد بدء تشغيل <code>ObjectSpace.memsize_of_all_iseq</code> ، <code>RubyVM::InstructionSequence</code> من 0 إلى 11128 (في هذا المثال): <br><br><pre style=";text-align:right;direction:rtl"> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_iseqs</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ObjectSpace</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each_object</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RubyVM::InstructionSequence)</span></span></span></span>.count <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  ستبقى هذه الأغلفة طوال عمر الطريقة ، وستحتاج إلى زيارتها مع التشغيل الكامل لجامع البيانات المهملة.  تم حل مشكلتنا من خلال إعادة استخدام الفئة المسؤولة عن تقديم قوالب البريد الإلكتروني ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الإصلاح 1</a> ، <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الإصلاح العاجل 2</a> ). <br><br><h1 style=";text-align:right;direction:rtl">  الفصل </h1><br>  أثناء تصحيح الأخطاء ، استخدمت أداة مثيرة جدًا للاهتمام.  قبل بضع سنوات ، قام Tim Boddy بسحب أداة داخلية يستخدمها VMWare لتحليل تسرب الذاكرة وجعل كودها مفتوحًا.  هنا هو الفيديو الوحيد الذي تمكنت من العثور عليه: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://www.youtube.com/watch؟v=EZ2n3kGtVDk</a> .  على عكس معظم الأدوات المشابهة ، لا تؤثر هذه الأداة على العملية القابلة للتنفيذ.  يمكن تطبيقه ببساطة على ملفات التفريغ الرئيسي ، بينما يتم استخدام glibc كمخصص (لا يوجد دعم jemalloc / tcmalloc ، إلخ). <br><br>  مع الفصل ، من السهل جدًا اكتشاف التسرب الذي أصابته.  قليل من التوزيعات تحتوي على الفصل الثنائي ، ولكن يمكنك <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">تجميعه</a> بسهولة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">من الكود المصدري</a> .  وهو مدعوم بنشاط كبير. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"># 444098 is the `Process.pid` of the leaking process I had sudo gcore -p 444098 chap core.444098 chap&gt; summarize leaked Unsigned allocations have 49974 instances taking 0x312f1b0(51,573,168) bytes. Unsigned allocations of size 0x408 have 49974 instances taking 0x312f1b0(51,573,168) bytes. 49974 allocations use 0x312f1b0 (51,573,168) bytes. chap&gt; list leaked ... Used allocation at 562ca267cdb0 of size 408 Used allocation at 562ca267d1c0 of size 408 Used allocation at 562ca267d5d0 of size 408 ... chap&gt; summarize anchored .... Signature 7fbe5caa0500 has 1 instances taking 0xc8(200) bytes. 23916 allocations use 0x2ad7500 (44,922,112) bytes.</code> </pre> <br>  بإمكان الفصل استخدام التواقيع للبحث عن مواقع ذاكرة مختلفة ، ويمكن أن يكمل GDB.  عند تصحيح الأخطاء في Ruby ، ​​قد يكون ذلك مفيدًا للغاية في تحديد الذاكرة التي تستخدمها العملية.  يُظهر إجمالي الذاكرة المستخدمة ، في بعض الأحيان يمكن أن يتجزئ glibc malloc كثيرًا بحيث يمكن أن يكون مستوى الصوت المستخدم مختلفًا تمامًا عن RSS الفعلي.  يمكنك قراءة المناقشة: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">الميزة رقم 14759: [PATCH] اضبط M_ARENA_MAX لنظام glibc malloc - Ruby master - نظام تتبع المشكلات في Ruby</a> .  تشاب قادر على حساب جميع الذاكرة المستخدمة بشكل صحيح وتقديم تحليل متعمق لتخصيصها. <br><br>  بالإضافة إلى ذلك ، يمكن دمج الفصل في سير العمل لاكتشاف التسريبات تلقائيًا ووضع علامات على هذه التجميعات. <br><br><h1 style=";text-align:right;direction:rtl">  متابعة العمل </h1><br>  جعلتني جولة التصحيح هذه أطرح بعض الأسئلة المتعلقة بمجموعات أدوات المساعدة الخاصة بنا: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  أود الحصول على دعم لالتقاط إطارات مكدس الاتصال من Ruby في Heaptrack.  ميليان مهتم أيضًا بهذا: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">412929 - هل يمكننا الاستيلاء على إطار من أرض روبي؟</a> <br></li><li style=";text-align:right;direction:rtl">  أود من روبي دعم القدرات التشخيصية الأوسع: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://bugs.ruby-lang.org/issues/16245</a> <br></li><li style=";text-align:right;direction:rtl">  أود أن يكون Mwrap أسهل قليلاً في الاستخدام في المنتج.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">اقرأ هنا</a> . </li></ul><br><h1 style=";text-align:right;direction:rtl">  ملخص </h1><br>  مجموعة أدوات اليوم لتصحيح أخطاء الذاكرة المعقدة للغاية أفضل بكثير مما كانت عليه قبل 4 سنوات!  أدوات Mwrap و Heaptrack و chap هي أدوات قوية للغاية لحل مشاكل الذاكرة التي تنشأ أثناء التطوير والتشغيل. <br><br>  إذا كنت تبحث عن تسرب بسيط للذاكرة في روبي ، فإنني أوصي بقراءة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مقالتي لعام 2015</a> ، وهو في معظمه وثيق الصلة. <br><br>  أتمنى أن تجد الأمر أسهل في المرة التالية التي تبدأ فيها تصحيح أخطاء تسرب ذاكرة أصلية معقدة. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar473408/">https://habr.com/ru/post/ar473408/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar473392/index.html">كيف نطلق موقع بنك جديد؟ الجزء 2</a></li>
<li><a href="../ar473394/index.html">جميعكم يكذبون! حول CRM الإعلان</a></li>
<li><a href="../ar473396/index.html">نحن بحاجة إلى bitrix آخر</a></li>
<li><a href="../ar473400/index.html">تقنية تحويل النص إلى كلام عالية الجودة وخفيفة الوزن وقابلة للتكيف باستخدام LPCNet</a></li>
<li><a href="../ar473406/index.html">ماراثون مجاني "علوم البيانات و الذكاء الاصطناعي: تعليم الآلة كتابة السيناريو للمسلسل"</a></li>
<li><a href="../ar473412/index.html">إنشاء مكون إضافي لكلانج محلل ثابت للبحث عن الفيض عدد صحيح</a></li>
<li><a href="../ar473416/index.html">برنامج مؤتمر ZeroNights 2019</a></li>
<li><a href="../ar473418/index.html">OSCP - الأمن الهجومي</a></li>
<li><a href="../ar473420/index.html">نفتتح موسم لقاءات PHP في نيجني نوفغورود في 2 نوفمبر</a></li>
<li><a href="../ar473424/index.html">أعلنت ARM عن حلول رسومات Mali-G57 Valhall و Mali-D37 والمعالجين العصبيين Ethos-N57 و N37</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>