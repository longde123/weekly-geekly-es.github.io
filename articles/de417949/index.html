<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😝 👩🏿‍🔬 👤 Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so beängstigend? Kapitel 4.2 🐟 😶 🎿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zusammenfassung der vorherigen Teile 
 Aufgrund von Einschränkungen bei der Verwendung von C ++ 11-Compilern und mangelnder Alternativen wollte boost ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so beängstigend? Kapitel 4.2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417949/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="Wir setzen das Abenteuer fort." width="300" height="350" align="left"><h3>  Zusammenfassung der vorherigen Teile </h3><br>  Aufgrund von Einschränkungen bei der Verwendung von C ++ 11-Compilern und mangelnder Alternativen wollte boost seine eigene Implementierung der Standard-C ++ 11-Bibliothek über die mit dem Compiler gelieferte C ++ 98 / C ++ 03-Bibliothek schreiben. <br><br>  <b>Static_assert</b> , <b>noexcept</b> , <b>countof</b> wurden implementiert, und nach Berücksichtigung aller nicht standardmäßigen <b>Definitionen</b> und Compilerfunktionen wurden Informationen zu den vom aktuellen Compiler unterstützten Funktionen <b>angezeigt</b> .  Eine eigene Implementierung von <b>nullptr ist enthalten</b> , die bei der Kompilierung ausgewählt wird. <br><br>  Es ist Zeit für <b>type_traits</b> und all diese "besondere Vorlagenmagie".  Im ersten Teil haben wir meine Implementierung der einfachsten Vorlagen der Standardbibliothek untersucht, aber jetzt werden wir uns eingehender mit den Vorlagen befassen. <br><br>  Link zu GitHub mit dem Ergebnis für heute für ungeduldige und Nichtleser: <br><br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Engagements und konstruktive Kritik sind willkommen</a></b> </blockquote><br>  Fortsetzung des Eintauchens in die Welt der "Template Magic" C ++. <br><a name="habracut"></a><br><h4>  Inhaltsverzeichnis </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 1. Viam Supervadet Vadens</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 3. Finden der perfekten nullptr-Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 4. C ++ Template Magic</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.1 Wir fangen klein an</a> <br>  .... <b>4.2 Über wie viele wundersame Fehler das Protokoll für uns kompiliert</b> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.3 Zeiger und alles in allem</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">4.4 Was wird sonst noch für die Vorlagenbibliothek benötigt?</a> <br>  Kapitel 5 <br>  ... <br><br><h3>  Kapitel 4. Vorlage "magic" C ++.  Fortsetzung </h3><br><h4>  4.2 Über wie viele wundersame Fehler das Protokoll kompiliert </h4><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Teil</a> dieses Kapitels wurden die grundlegenden Vorlagen für <b>type_traits</b> vorgestellt, aber einige weitere fehlten für den gesamten Satz. <br><br>  Zum Beispiel wurden einfach die Vorlagen <i>is_integral</i> und <i>is_floating_point</i> benötigt, die eigentlich sehr trivial definiert sind - durch die Vorlagenspezialisierung für jeden eingebauten Typ.  Die Frage stellte sich hier nur bei den "großen" Arten von <b>Long Long</b> .  Tatsache ist, dass dieser integrierte Typ im C ++ - Sprachstandard erst ab Version 11 angezeigt wird.  Und es wäre logisch anzunehmen, dass es darauf ankommt, die Version des C ++ - Standards zu überprüfen (die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ohnehin einzigartig schwer zu bestimmen ist</a> ), aber sie war nicht vorhanden. <br><br><img src="https://habrastorage.org/webt/dx/16/xq/dx16xqz_rvfqcoffnocx80dae_w.jpeg" alt="Bild" width="320" height="190" align="left">  Denn seit 1999 gibt es den Sprachstandard C99 C, in dem die Typen <b>long long int</b> und <b>unsigned long long int</b> bereits vorhanden sind (seit 1999!), Und seit die C ++ - Sprache versucht hat, die Abwärtskompatibilität mit reinem C aufrechtzuerhalten, gibt es viele Compiler (die normalerweise gemischtes C / C ++) hat es gerade als grundlegenden Typ hinzugefügt, noch bevor der C ++ 03-Standard veröffentlicht wurde.  Das heißt, die Situation war, dass der eingebaute Typ tatsächlich (von C) ist, aber er ist nicht im C ++ - Standard beschrieben und sollte nicht vorhanden sein.  Und das bringt etwas mehr Verwirrung in die Implementierung der Standardbibliothek.  Aber schauen wir uns den Code an: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class">&lt;float&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class">&lt;double&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class">&lt;long double&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_floating_point</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> detail::_is_floating_point&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove_cv&lt;_Tp&gt;::type&gt; { };</code> </pre> <br>  Mit dem obigen Code ist alles klar - wir spezialisieren die Vorlage auf die erforderlichen Gleitkommatypen und sagen nach dem „Löschen“ der Typmodifikatoren „Ja“ oder „Nein“ zu dem an uns übergebenen Typ.  Als nächstes folgen ganzzahlige Typen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;bool&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;char&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;wchar_t&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;unsigned char&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;unsigned short int&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;unsigned int&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_integral_impl</span></span></span><span class="hljs-class">&lt;unsigned long int&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type {}; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> LLONG_MAX template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt; struct _is_integral_impl&lt;unsigned long long int&gt; : public true_type {}; #endif template&lt;&gt; struct _is_integral_impl&lt;signed char&gt; : public true_type {}; template&lt;&gt; struct _is_integral_impl&lt;short int&gt; : public true_type {}; template&lt;&gt; struct _is_integral_impl&lt;int&gt; : public true_type {}; template&lt;&gt; struct _is_integral_impl&lt;long int&gt; : public true_type {}; #ifdef LLONG_MAX template&lt;&gt; struct _is_integral_impl&lt;long long int&gt; : public true_type {}; #endif template &lt;class _Tp&gt; struct _is_integral : public _is_integral_impl&lt;_Tp&gt; {}; template&lt;&gt; struct _is_integral&lt;char16_t&gt; : public true_type {}; template&lt;&gt; struct _is_integral&lt;char32_t&gt; : public true_type {}; template&lt;&gt; struct _is_integral&lt;int64_t&gt; : public true_type {}; template&lt;&gt; struct _is_integral&lt;uint64_t&gt; : public true_type {}; } template &lt;class _Tp&gt; struct is_integral : public detail::_is_integral&lt;typename remove_cv&lt;_Tp&gt;::type&gt; { };</span></span></span></span></code> </pre><br>  Hier muss man ein wenig innehalten und nachdenken.  Für "alte" Ganzzahltypen wie <b>int</b> , <b>bool</b> usw.  Wir machen die gleichen Spezialisierungen wie mit <i>is_floating_point</i> .  Für die "neuen" Typen <b>long long int</b> und ihr vorzeichenloses Gegenstück definieren wir Überladungen nur, wenn es eine LLONG_MAX- <b>Definition gibt</b> , die in C ++ 11 definiert wurde (als erster C ++ - Standard, der mit C99 kompatibel ist) und in der Header-Datei für die <b>Klimazonen</b> als Maximum definiert werden sollte eine große Zahl, die in ein Objekt vom Typ <b>long long int</b> passt.  <b>Climits</b> hat auch einige weitere Makrodefinitionen (für die kleinstmögliche Anzahl und vorzeichenlose Äquivalente), aber ich habe mich für dieses Makro entschieden, was nicht wichtig ist.  Wichtig ist, dass im Gegensatz zu boost in dieser Implementierung die "großen" Typen von C nicht als ganzzahlige Konstanten definiert werden, obwohl sie (möglicherweise) im Compiler vorhanden sind.  Was wichtiger ist, sind die Typen <b>char16_t</b> und <b>char32_t</b> , die ebenfalls in C ++ 11 eingeführt wurden, aber nicht bereits in C99 ausgeliefert wurden (sie erschienen bereits gleichzeitig mit C ++ im C11-Standard), und daher kann ihre Definition in den alten Standards <b>Seien</b> <i>Sie</i> nur über einen Typ-Alias ​​(zum Beispiel <b>typedef</b> <i>short char16_t</i> , aber dazu später mehr).  In diesem <b>Fall</b> ist eine weitere Ebene mit <i>Details</i> zur Vorlagenspezialisierung <i>erforderlich: _ is_integral</i> , damit die Vorlagenspezialisierung Situationen korrekt <b>handhabt</b> , in denen diese Typen getrennt (integriert) und durch <b>typedef</b> definiert sind. <br><br><blockquote>  Eine interessante Tatsache ist, dass in einigen alten Compilern diese C-schüchternen "großen" Typen keine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">integrale Konstante sind</a> .  Was kann verstanden und sogar vergeben werden, da diese Typen für C ++ bis zu 11 Standards nicht Standard sind und im Allgemeinen nicht vorhanden sein sollten.  Schwer zu verstehen ist jedoch, dass diese Typen im neuesten C ++ - Compiler der Embarcadero-Kreativität (Embarcadero C ++ Builder), den C ++ 11 angeblich unterstützt, in ihren 32-Bit-Assemblys (wie vor 20 Jahren) immer noch keine <b>integrale Konstante</b> sind dann war es Borland noch wahr).  Anscheinend fehlt aus diesem Grund der größte Teil der Standard-C ++ 11-Bibliothek in diesen 32-Bit-Assemblys (# include-Verhältnis? Chrono? Wird kosten).  Embarcadero scheint beschlossen zu haben, die 64-Bit-Ära mit dem Motto zu erzwingen: „Möchten Sie C ++ 11 oder einen neueren Standard?  Erstellen Sie ein 64-Bit-Programm (und nur Clang, unser Compiler kann nicht)! ” <br></blockquote><br>  Nachdem wir das Verfahren mit den grundlegenden Sprachtypen abgeschlossen haben, führen wir einige einfachere Muster ein: <br><br><div class="spoiler">  <b class="spoiler_title">Einfache Muster</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">detail</span></span></span><span class="hljs-class">:</span></span>:void_type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_if</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">enable_if</span></span></span><span class="hljs-class">&lt;true, _Tp&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> _Tp type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_same</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_same</span></span></span><span class="hljs-class">&lt;_Tp, _Tp&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type<span class="hljs-comment"><span class="hljs-comment">//specialization { }; template &lt;class _Tp&gt; struct is_const : public false_type { }; template &lt;class _Tp&gt; struct is_const&lt;const _Tp&gt; : public true_type { }; template &lt;class _Tp&gt; struct is_const&lt;const volatile _Tp&gt; : public true_type { }; /// is_volatile template&lt;class&gt; struct is_volatile : public false_type { }; template&lt;class _Tp&gt; struct is_volatile&lt;volatile _Tp&gt; : public true_type { }; template&lt;class _Tp&gt; struct is_volatile&lt;const volatile _Tp&gt; : public true_type { };</span></span></code> </pre><br></div></div><br>  Nur die Tatsache, dass sich Vorlagen auf alle Modifikatoren des Typs spezialisieren (z. B. <b>flüchtig</b> und <b>const flüchtig</b> ), ist hier bemerkenswert, weil  Einige Compiler neigen dazu, einen der Modifikatoren zu verlieren, wenn sie die Vorlage erweitern. <br><br>  Separat hebe ich die Implementierung von <i>is_signed</i> und <i>is_unsigned hervor</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sign_unsign_chooser</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">signed_comparer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _Tp(<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt; _Tp(<span class="hljs-number"><span class="hljs-number">0</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unsigned_comparer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _Tp(<span class="hljs-number"><span class="hljs-number">0</span></span>) &lt; _Tp(<span class="hljs-number"><span class="hljs-number">-1</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Val&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cat_base</span></span></span><span class="hljs-class"> :</span></span> integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, Val&gt; { <span class="hljs-comment"><span class="hljs-comment">// base class for type predicates }; template&lt;&gt; struct _sign_unsign_chooser&lt;true&gt;//integral { template&lt;class _Tp&gt; struct _signed : public _cat_base&lt;_signed_comparer&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::value&gt; { }; template&lt;class _Tp&gt; struct _unsigned : public _cat_base&lt;_unsigned_comparer&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::value&gt; { }; }; template&lt;&gt; struct _sign_unsign_chooser&lt;false&gt;//floating point { template&lt;class _Tp&gt; struct _signed : public is_floating_point&lt;_Tp&gt; { }; template&lt;class _Tp&gt; struct _unsigned : public false_type { }; }; } template&lt;class T&gt; struct is_signed { // determine whether T is a signed type static const bool value = detail::_sign_unsign_chooser&lt;is_integral&lt;T&gt;::value&gt;::template _signed&lt;T&gt;::value; typedef const bool value_type; typedef integral_constant&lt;bool, is_signed::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } }; template&lt;class T&gt; struct is_unsigned { // determine whether T is an unsigned type static const bool value = detail::_sign_unsign_chooser&lt;is_integral&lt;T&gt;::value&gt;::template _unsigned&lt;T&gt;::value; typedef const bool value_type; typedef integral_constant&lt;bool, is_unsigned::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } };</span></span></code> </pre><br>  Bei der Implementierung dieses Teils trat ich in einen ungleichen Kampf mit Borland C ++ Builder 6.0 ein, der diese beiden Vorlagen nicht zu Erben von <i>Integral_Constant machen wollte</i> , was schließlich dazu führte, dass Dutzende interner Compilerfehler das <i>Integral_Konstanten-</i> Verhalten für diese Vorlagen „imitierten“.  Hier lohnt es sich vielleicht, noch zu kämpfen und eine knifflige Ableitung des Typs <i>is_ * un * signiert: Integral_Konstante</i> durch Vorlagen zu finden, aber bisher habe ich diese Aufgabe als keine Priorität verschoben.  Interessant im obigen Codeabschnitt ist, wie beim Kompilieren festgestellt wird, dass der Typ nicht signiert / signiert ist.  Zunächst werden alle nicht ganzzahligen Typen <i>markiert,</i> und für sie wird die Vorlage mit dem Vorlagenargument <b>false</b> an einen separaten spezialisierten Zweig <i>_sign_unsign_chooser gesendet</i> , der wiederum für alle Typen außer Standard-Gleitkommatypen immer den <i>Wert ==</i> <b>false</b> zurückgibt (sie sind aus offensichtlichen Gründen immer signiert). also wird <i>_signed :: value</i> <b>wahr sein</b> ).  Für ganzzahlige Typen werden einfache, aber unterhaltsame Überprüfungen durchgeführt.  Hier verwenden wir die Tatsache, dass bei vorzeichenlosen Ganzzahltypen, wenn die Zahl abnimmt und dann ein Minimum durchläuft (offensichtlich 0), ein Überlauf auftritt und die Zahl ihren maximal möglichen Wert erhält. <br><br>  Diese Tatsache ist bekannt, ebenso wie die Tatsache, dass ein Überlauf für signierte Typen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein undefiniertes Verhalten ist</a> und Sie darauf <b>achten</b> müssen (gemäß dem Standard können Sie eine <b>int-</b> Variable nicht kleiner als <b>INT_MIN reduzieren</b> und hoffen, dass Sie aufgrund des Überlaufs <b>INT_MAX erhalten</b> , nicht 42 oder eine formatierte Festplatte ) <br><br>  Wir schreiben <i>_Tp (-1) &lt;_Tp (0)</i> , um anhand dieser Tatsache nach dem Typ "Vorzeichen" zu <i>suchen</i> , und dann nach vorzeichenlosen Typen -1 "Transformationen" durch Überlauf auf die maximale Anzahl dieses Typs, während bei vorzeichenbehafteten Typen ein solcher Vergleich ohne Überlauf durchgeführt wird. und -1 werden mit 0 verglichen. <br><br>  Und der letzte für heute, aber weit entfernt vom letzten "Trick" in meiner Bibliothek ist die Implementierung von <i>align_of</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_of_trick</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; _Tp t; _alignment_of_trick(); }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> A, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_logic_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> value = A &lt; S ? A : S; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> A&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_logic_helper</span></span></span><span class="hljs-class">&lt;A, 0&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> value = A; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> S&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_logic_helper</span></span></span><span class="hljs-class">&lt;0, S&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> value = S; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alignment_of_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> _MSC_VER &gt; 1400 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// // With MSVC both the build in __alignof operator // and following logic gets things wrong from time to time // Using a combination of the two seems to make the most of a bad job: // static const std::size_t value = (_alignment_logic_helper&lt; sizeof(_alignment_of_trick&lt;_Tp&gt;) - sizeof(_Tp), __alignof(_Tp) &gt;::value); #else static const std::size_t value = (_alignment_logic_helper&lt; sizeof(_alignment_of_trick&lt;_Tp&gt;) - sizeof(_Tp), sizeof(_Tp) &gt;::value); #endif typedef integral_constant&lt;std::size_t, std::size_t(_alignment_of_impl::value)&gt; type; private: typedef intern::type_traits_asserts check; typedef typename check::alignment_of_type_can_not_be_zero_assert&lt; _alignment_of_impl::value != 0 &gt;:: alignment_of_type_can_not_be_zero_assert_failed check1; // if you are there means aligment of type passed can not be calculated or compiler can not handle this situation (sorry, nothing can be done there) }; // borland compilers seem to be unable to handle long double correctly, so this will do the trick: struct _long_double_wrapper{ long double value; }; } template &lt;class _Tp&gt; struct alignment_of: public detail::_alignment_of_impl&lt;_Tp&gt;::type {}; template &lt;class _Tp&gt; struct alignment_of&lt;_Tp&amp;&gt;: public alignment_of&lt;_Tp*&gt; {}; template&lt;&gt; struct alignment_of&lt;long double&gt;: public alignment_of&lt;detail::_long_double_wrapper&gt; {};</span></span></span></span></code> </pre><br><blockquote>  Microsoft hat sich hier erneut durch sein Visual Studio hervorgetan, das selbst mit einem eingebauten nicht standardmäßigen <b>__alignof eingebauten</b> Makro immer noch falsche Ergebnisse liefert, wenn es verwendet wird. <br><br><div class="spoiler">  <b class="spoiler_title">Erklärung von Boost</b> <div class="spoiler_text">  Benutzer von Visual C ++ sollten beachten, dass MSVC unterschiedliche Definitionen von "Ausrichtung" hat.  Betrachten Sie beispielsweise den folgenden Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">align_t</span></span>; assert(boost::alignment_of&lt;<span class="hljs-keyword"><span class="hljs-keyword">align_t</span></span>&gt;::value % <span class="hljs-number"><span class="hljs-number">8</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">align_t</span></span> a; assert(((<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;a % <span class="hljs-number"><span class="hljs-number">8</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">align_t</span></span> a1; assert(((<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span>)&amp;a1 % <span class="hljs-number"><span class="hljs-number">8</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  In diesem Code schlägt die endgültige Bestätigung für einen 32-Bit-Build fehl, obwohl a1 nicht an einer 8-Byte-Grenze ausgerichtet ist, obwohl boost :: align_of &lt;align_t&gt; meldet, dass align_t eine 8-Byte-Ausrichtung aufweist.  Beachten Sie, dass wir immer noch das gleiche Ergebnis erhalten würden, wenn wir anstelle von boost :: align_of das MSVC intrinsic __alignof verwendet hätten.  Tatsächlich gelten die Anforderungen (und Versprechen) für die MSVC-Ausrichtung nur für den dynamischen Speicher und nicht für den Stapel. <br></div></div><br></blockquote><br>  Ich möchte Sie daran erinnern, was die Vorlage <i>std :: align_of</i> tun soll. <i>Geben</i> Sie einen Wert zurück, der die Anforderungen für die Platzierung eines Elements dieses Typs im Speicher darstellt.  Ein wenig Ablenkung, dann hat ein Element jedes Typs eine Art Speicherzuordnung, und wenn es für ein Array von Elementen kontinuierlich ist, können Klassen beispielsweise durchaus "Löcher" zwischen den Elementelementen der Klasse haben ( <b>sizeof</b> class <b>struct</b> <i>{</i> <b>char</b> <i>a;}</i> wird höchstwahrscheinlich nicht gleich 1 sein, obwohl 1 Byte von allem darin enthalten ist, da der Compiler es während des Optimierungsprozesses auf 1 + 3 Bytes ausrichtet. <br><br>  Schauen wir uns jetzt den Code noch einmal an.  Wir deklarieren die <i>_alignment_of_trick-</i> Struktur, in der wir ein Element des zu <i>prüfenden</i> Typs mit einem Einzug im Speicher von 1 Byte platzieren.  Überprüfen Sie die Ausrichtung, indem Sie einfach die Größe des zu überprüfenden Typs von der Größe der resultierenden Struktur subtrahieren.  Das heißt, wenn der Compiler beschließt, ein Leerzeichen zwischen dem Element des zu überprüfenden Typs und dem vorherigen <b>Zeichen</b> zu "kleben", erhalten wir den Typausrichtungswert in der Struktur. <br><br>  Auch hier wird zunächst statische Zusicherung als Typ angetroffen.  Sie werden deklariert als: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> intern { <span class="hljs-comment"><span class="hljs-comment">// since we have no static_assert in pre-C++11 we just compile-time assert this way: struct type_traits_asserts { template&lt;bool&gt; struct make_signed_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert; template&lt;bool&gt; struct make_unsigned_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert; template&lt;bool&gt; struct not_allowed_arithmetic_type_assert; template&lt;bool&gt; struct alignment_of_type_can_not_be_zero_assert; }; template&lt;&gt; struct type_traits_asserts::make_signed_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert&lt;true&gt; { typedef bool make_signed_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert_failed; }; template&lt;&gt; struct type_traits_asserts::make_unsigned_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert&lt;true&gt; { typedef bool make_unsigned_template_require_that_type_shall_be_a_possibly_cv_qualified_but_integral_type_assert_failed; }; template&lt;&gt; struct type_traits_asserts::not_allowed_arithmetic_type_assert&lt;true&gt; { typedef bool not_allowed_arithmetic_type_assert_failed; }; template&lt;&gt; struct type_traits_asserts::alignment_of_type_can_not_be_zero_assert&lt;true&gt; { typedef bool alignment_of_type_can_not_be_zero_assert_failed; }; }</span></span></code> </pre><br>  Tatsächlich werden diese speziellen Vorlagen benötigt, um den <b>static_assert</b> aus C ++ 11 zu ersetzen, der sich in der Klassendefinition befindet.  Solche Assert sind leichter und hochspezialisierter als die allgemeine Implementierung von <b>STATIC_ASSERT</b> aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 2</a> und ermöglichen es Ihnen, die Header-Datei <b>core.h nicht</b> in <b>type_traits</b> zu <b>ziehen</b> . <br><br><img src="https://habrastorage.org/webt/ky/ra/ey/kyraeyyd384lkegmbcap1xfwday.jpeg" alt="Bild" width="330" height="200" align="left">  Viele Muster?  Es wird mehr geben!  Wir werden vorerst darauf eingehen, da die faszinierende Geschichte über die Kombination von Vorlagenprogrammierung mit SFINAE-Technologie sowie darüber, warum ich einen kleinen Codegenerator schreiben musste, weitergehen wird. <br><br>  Danke für die Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417949/">https://habr.com/ru/post/de417949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417939/index.html">Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teile 4 und 5</a></li>
<li><a href="../de417941/index.html">Wo verschwindet das Wasser im Wasserkocher?</a></li>
<li><a href="../de417943/index.html">Serverless and React 2: Handfertigkeit und kein Betrug</a></li>
<li><a href="../de417945/index.html">Welche Werkzeuge hat die Parker-Sonde?</a></li>
<li><a href="../de417947/index.html">Datenvisualisierung für Ihr Webprojekt</a></li>
<li><a href="../de417951/index.html">Schreiben von Java-freundlichem Kotlin-Code</a></li>
<li><a href="../de417953/index.html">Trends beim Design von FPGAs. Übersetzung</a></li>
<li><a href="../de417955/index.html">So werden Sie Interface-Designer. Notwendige Fähigkeiten und leistungsstarke Werkzeuge, über die wir nicht informiert sind</a></li>
<li><a href="../de417957/index.html">Öffnen Sie das Webinar Linux Containerization Mechanisms</a></li>
<li><a href="../de417959/index.html">10 Tipps zum Interface-Design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>