<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè∏ üçß üí§ O desempenho incompreens√≠vel da programa√ß√£o m√∫ltipla üåà ü§öüèø üõê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sob a cena, √© proposta uma descriptografia do relat√≥rio de Stefan Karpinsky, um dos principais desenvolvedores da linguagem Julia. No relat√≥rio, ele d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>O desempenho incompreens√≠vel da programa√ß√£o m√∫ltipla</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468609/"><p>  Sob a cena, √© proposta uma descriptografia do relat√≥rio de Stefan Karpinsky, um dos principais desenvolvedores da linguagem Julia.  No relat√≥rio, ele discute os resultados inesperados do envio m√∫ltiplo conveniente e eficiente, considerado o principal paradigma de Julia. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/kc9HwsxE1OY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>De um tradutor</em> : o t√≠tulo do relat√≥rio refere-se a um artigo de Eugene Wigner, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"A incompreens√≠vel efic√°cia da matem√°tica nas ci√™ncias naturais"</a> . </p><br><p> A programa√ß√£o m√∫ltipla √© um paradigma fundamental da linguagem Julia e, durante sua exist√™ncia, n√≥s, os desenvolvedores da linguagem, percebemos algo esperado, mas ao mesmo tempo intrigante.  Pelo menos n√£o esper√°vamos isso na medida em que vimos.  Isso √© algo - um n√≠vel impressionante de reutiliza√ß√£o de c√≥digo no ecossistema Julia, que √© muito maior do que em qualquer outro idioma que eu conhe√ßa. </p><br><p>  Vimos constantemente que algumas pessoas escrevem c√≥digo generalizado, outras pessoas definem um novo tipo de dados, essas pessoas n√£o est√£o familiarizadas e, em seguida, algu√©m aplica esse c√≥digo a esse tipo de dados incomum ... E tudo simplesmente funciona.  E isso acontece <em>surpreendentemente com frequ√™ncia</em> . <br>  Eu sempre pensei que esse comportamento deveria ser esperado da programa√ß√£o orientada a objetos, mas usei muitas linguagens orientadas a objetos, e acontece que geralmente tudo n√£o funciona nelas.  Portanto, em algum momento pensei: por que Julia √© uma linguagem t√£o eficaz nesse sentido?  Por que o n√≠vel de reutiliza√ß√£o de c√≥digo √© t√£o alto l√°?  E tamb√©m - que li√ß√µes podem ser aprendidas disso que outras l√≠nguas poderiam emprestar de Julia para se tornarem melhores? </p><br><p>  √Äs vezes, quando digo isso, o p√∫blico n√£o acredita em mim, mas voc√™ j√° est√° no JuliaCon, ent√£o voc√™ est√° ciente do que est√° acontecendo, ent√£o vou me concentrar no por que, na minha opini√£o, isso acontece. </p><br><p>  Mas para iniciantes - um dos meus exemplos favoritos. </p><br><p><img src="https://habrastorage.org/webt/mv/o0/i8/mvo0i8xjflhnxxuurnshmsfolbi.png"></p><br><p> No slide est√° o resultado do trabalho de Chris Rakaukas.  Ele escreve todos os tipos de pacotes <em>muito generalizados</em> para resolver equa√ß√µes diferenciais.  Voc√™ pode alimentar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√∫meros duplos</a> , ou BigFloat, o que quiser.  E de alguma maneira ele decidiu que quer ver o erro do resultado da integra√ß√£o.  E havia um pacote Measurements que pode rastrear o valor de uma quantidade f√≠sica e a propaga√ß√£o de um erro atrav√©s de uma sequ√™ncia de f√≥rmulas.  Este pacote tamb√©m suporta sintaxe elegante para valores de incerteza usando o caractere Unicode <code>¬±</code> .  Aqui no slide √© mostrado que a acelera√ß√£o da gravidade, o comprimento do p√™ndulo, a velocidade inicial, o √¢ngulo de desvio s√£o todos conhecidos com algum tipo de erro.  Ent√£o, voc√™ define um p√™ndulo simples, passa suas equa√ß√µes de movimento atrav√©s do solucionador ODE e - <strong>bam!</strong>  <em>tudo funciona</em> .  E voc√™ v√™ um gr√°fico com imprecis√µes de bigode.  E ainda n√£o mostro que o c√≥digo para desenhar um gr√°fico tamb√©m √© generalizado, e voc√™ apenas insere o valor com um erro de Measurements.jl e obt√©m um gr√°fico com erros. </p><br><p>  O n√≠vel de compatibilidade de diferentes pacotes e a generaliza√ß√£o do c√≥digo s√£o simplesmente empolgantes.  <em>Como isso <strong>funciona</strong> ?</em>  Acontece que sim. </p><br><p>  Bem, n√£o que n√£o esper√°ssemos isso.  Afinal, inclu√≠mos o conceito de despacho m√∫ltiplo na linguagem <em>precisamente</em> porque nos permite expressar algoritmos generalizados.  Portanto, todas as op√ß√µes acima n√£o s√£o t√£o loucas.  Mas uma coisa √© saber isso na teoria e outra √© ver na pr√°tica que a abordagem realmente funciona.  Afinal, despacho √∫nico e sobrecarga de operador em C ++ tamb√©m devem fornecer um resultado semelhante - mas, na realidade, eles geralmente n√£o funcionam como gostariam. </p><br><p>  Al√©m disso, estamos testemunhando algo mais do que hav√≠amos previsto no desenvolvimento da linguagem: n√£o apenas o c√≥digo generalizado est√° sendo escrito.  Em seguida, tentarei dizer o que, na minha opini√£o, √© mais. </p><br><p>  Portanto, existem dois tipos de reutiliza√ß√£o de c√≥digo e s√£o bem diferentes.  Um √© algoritmos generalizados, e esta √© a primeira coisa que eles lembram.  O segundo aspecto, menos √≥bvio, mas parece ser mais importante, √© a simplicidade com a qual Julia usa os mesmos tipos de dados em uma ampla variedade de pacotes.  At√© certo ponto, isso acontece porque os m√©todos de tipo n√£o se tornam um obst√°culo ao seu uso: voc√™ n√£o precisa concordar com o autor do tipo sobre as interfaces e m√©todos que ele herda;  voc√™ pode simplesmente dizer: "Ah, eu gosto desse tipo de RGB. Vou criar minhas pr√≥prias opera√ß√µes, mas gosto da estrutura". </p><br><h3 id="predislovie-mnozhestvennaya-dispetcherizaciya-protiv-peregruzki-funkciy">  Pref√°cio  Programa√ß√£o m√∫ltipla versus sobrecarga de fun√ß√£o </h3><br><p>  Agora, tenho que mencionar a sobrecarga de fun√ß√µes em C ++ ou Java, pois sempre s√£o feitas perguntas sobre eles.  √Ä primeira vista, n√£o √© diferente do agendamento m√∫ltiplo.  Qual √© a diferen√ßa e por que a sobrecarga de fun√ß√£o √© pior? </p><br><p>  Vou come√ßar com um exemplo em Julia: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract type</span></span> Pet <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Dog &lt;: Pet; name::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Cat &lt;: Pet; name::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> encounter(a::Pet, b::Pet) verb = meets(a, b) println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(a.name)</span></span></span><span class="hljs-string"> meets </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(b.name)</span></span></span><span class="hljs-string"> and </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$verb</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> meets(a::Dog, b::Dog) = <span class="hljs-string"><span class="hljs-string">"sniffs"</span></span> meets(a::Dog, b::Cat) = <span class="hljs-string"><span class="hljs-string">"chases"</span></span> meets(a::Cat, b::Dog) = <span class="hljs-string"><span class="hljs-string">"hisses"</span></span> meets(a::Cat, b::Cat) = <span class="hljs-string"><span class="hljs-string">"slinks"</span></span></code> </pre> <br><p>  Definimos o tipo abstrato de <code>Pet</code> , apresentamos os subtipos de <code>Dog</code> e <code>Cat</code> para ele, eles t√™m um campo de nome (o c√≥digo se repete um pouco, mas √© toler√°vel) e define uma fun√ß√£o generalizada de "reuni√£o" que aceita dois objetos do tipo <code>Pet</code> argumentos.  Nele, primeiro calculamos a ‚Äúa√ß√£o‚Äù determinada pelo resultado da chamada da fun√ß√£o <code>meet()</code> generalizada e, em seguida, imprimimos a frase que descreve a reuni√£o.  Na fun√ß√£o <code>meets()</code> , usamos v√°rios despachos para determinar a a√ß√£o que um animal executa quando encontra outro. </p><br><p>  Adicione alguns c√£es e gatos e veja os resultados da reuni√£o: </p><br><pre> <code class="julia hljs">fido = Dog(<span class="hljs-string"><span class="hljs-string">"Fido"</span></span>) rex = Dog(<span class="hljs-string"><span class="hljs-string">"Rex"</span></span>) whiskers = Cat(<span class="hljs-string"><span class="hljs-string">"Whiskers"</span></span>) spots = Cat(<span class="hljs-string"><span class="hljs-string">"Spots"</span></span>) encounter(fido, rex) encounter(rex, whiskers) encounter(spots, fido) encounter(whiskers, spots)</code> </pre> <br><p>  Agora vamos "traduzir" o mesmo para C ++ o mais literalmente poss√≠vel.  Defina a classe <code>Pet</code> com o campo <code>name</code> - em C ++, podemos fazer isso (a prop√≥sito, uma das vantagens do C ++ √© que os campos de dados podem at√© ser adicionados a tipos abstratos. Depois, definimos a fun√ß√£o base <code>meets()</code> , definimos a fun√ß√£o <code>encounter()</code> para dois objetos do tipo <code>Pet</code> e, finalmente, defina as classes derivadas <code>Dog</code> e <code>Cat</code> e sobrecarregue o <code>meets()</code> para elas: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; }; <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pet a, Pet b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"FALLBACK"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pet a, Pet b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> verb = meets(a, b); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; a.name &lt;&lt; <span class="hljs-string"><span class="hljs-string">" meets "</span></span> &lt;&lt; b. name &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and "</span></span> &lt;&lt; verb &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Pet {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Pet {}; <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dog a, Dog b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"sniffs"</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dog a, Cat b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"chases"</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cat a, Dog b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hisses"</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cat a, Cat b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"slinks"</span></span>; }</code> </pre> <br><p>  A fun√ß√£o <code>main()</code> , como no c√≥digo Julia, cria c√£es e gatos e os faz conhecer: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Dog fido; fido.name = <span class="hljs-string"><span class="hljs-string">"Fido"</span></span>; Dog rex; rex.name = <span class="hljs-string"><span class="hljs-string">"Rex"</span></span>; Cat whiskers; whiskers.name = <span class="hljs-string"><span class="hljs-string">"Whiskers"</span></span>; Cat spots; spots.name = <span class="hljs-string"><span class="hljs-string">"Spots"</span></span>; encounter(fido, rex); encounter(rex, whiskers); encounter(spots, fido); encounter(whiskers, spots); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Portanto, despacho m√∫ltiplo contra sobrecarga de fun√ß√£o.  Gong! </p><br><p><img src="https://habrastorage.org/webt/sj/6u/ob/sj6uobzsl8adbgqxjlxuibpcnpc.png"></p><br><p>  O que voc√™ acha que retornar√° c√≥digo com v√°rios despachos? </p><br><div class="spoiler">  <b class="spoiler_title">$ julia pets.jl</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Fido meets Rex and sniffs Rex meets Whiskers and chases Spots meets Fido and hisses Whiskers meets Spots and slinks</code> </pre> <br><p>  Os animais se encontram, cheiram, assobiam e brincam - como foi planejado. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">$ g ++ -o pets pets.cpp &amp;&amp; ./pets</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Fido meets Rex and FALLBACK Rex meets Whiskers and FALLBACK Spots meets Fido and FALLBACK Whiskers meets Spots and FALLBACK</code> </pre> <br><p>  Em todos os casos, a op√ß√£o "fallback" √© retornada. </p><br><p>  Porque  Porque √© assim que a sobrecarga de fun√ß√µes funciona.  Se o envio m√∫ltiplo funcionasse, os <code>meets(a, b)</code> dentro do <code>encounter()</code> seriam chamados com os tipos espec√≠ficos que <code>a</code> e <code>b</code> tinham no momento da chamada.  Mas a sobrecarga √© aplicada; portanto, <code>meets()</code> √© chamado para os tipos <em>est√°ticos</em> <code>b</code> , que nesse caso s√£o <code>Pet</code> . </p></div></div><br><p>  Portanto, na abordagem C ++, a "tradu√ß√£o" direta do c√≥digo Julia gen√©rico n√£o fornece o comportamento desejado devido ao fato de o compilador usar tipos derivados estaticamente no est√°gio de compila√ß√£o.  E o ponto principal √© que queremos chamar uma fun√ß√£o baseada em tipos concretos reais que as vari√°veis ‚Äã‚Äãpossuem em tempo de execu√ß√£o.  As fun√ß√µes de modelo, embora melhorem um pouco a situa√ß√£o, ainda exigem conhecimento de todos os tipos inclu√≠dos estaticamente na express√£o em tempo de compila√ß√£o, e √© f√°cil criar um exemplo em que isso seria imposs√≠vel. </p><br><p>  Para mim, esses exemplos mostram que o despacho m√∫ltiplo faz a coisa certa, e todas as outras abordagens simplesmente n√£o s√£o uma aproxima√ß√£o muito boa ao resultado correto. </p><br><p>  Agora vamos ver essa tabela.  Espero que voc√™ ache significativo: </p><br><div class="scrollable-table"><table><thead><tr><th>  Tipo de agendamento </th><th>  Sintaxe </th><th>  Argumentos de distribui√ß√£o </th><th>  Grau de expressividade </th><th>  Oportunidade expressiva </th></tr></thead><tbody><tr><td>  n√£o </td><td>  f (x <sub>1</sub> , x <sub>2</sub> , ...) </td><td>  {} </td><td>  O (1) </td><td>  constante </td></tr><tr><td>  solit√°rio </td><td>  x <sub>1</sub> .f (x <sub>2</sub> , ...) </td><td>  {x <sub>1</sub> } </td><td>  O (| X <sub>1</sub> |) </td><td>  linear </td></tr><tr><td>  m√∫ltiplo </td><td>  f (x <sub>1</sub> , x <sub>2</sub> , ...) </td><td>  {x <sub>1</sub> , x <sub>2</sub> , ...} </td><td>  O (| X <sub>1</sub> | | X <sub>2</sub> | ...) </td><td>  exponencial </td></tr></tbody></table></div><br><p>  Em idiomas sem despacho, basta escrever <code>f(x, y, ...)</code> , os tipos de todos os argumentos s√£o fixos, ou seja,  uma chamada para <code>f()</code> √© uma chamada para uma √∫nica fun√ß√£o <code>f()</code> , que pode estar no programa.  O grau de expressividade √© constante: chamar <code>f()</code> sempre faz uma e apenas uma coisa.  O envio √∫nico foi um grande avan√ßo na transi√ß√£o para a OOP nas d√©cadas de 1990 e 2000.  A sintaxe do ponto √© geralmente usada, da qual as pessoas realmente gostam.  E uma oportunidade expressiva adicional aparece: a chamada √© despachada de acordo com o tipo de objeto x <sub>1</sub> .  Uma oportunidade expressiva √© caracterizada pelo poder do conjunto | X <sub>1</sub> |  tipos com o m√©todo <code>f()</code> .  No despacho m√∫ltiplo, no entanto, o n√∫mero de op√ß√µes poss√≠veis para a fun√ß√£o <code>f()</code> √© igual ao poder do produto cartesiano de conjuntos de tipos aos quais os argumentos podem pertencer.  Na realidade, √© claro, quase ningu√©m precisa de tantas fun√ß√µes diferentes em um programa.  Mas o ponto chave aqui √© que o programador recebe uma maneira simples e natural de usar qualquer elemento dessa variedade, e isso leva a um crescimento exponencial de oportunidades. </p><br><h3 id="chast-1-obobschyonnoe-programmirovanie">  Parte 1. Programa√ß√£o geral </h3><br><p>  Vamos falar sobre c√≥digo generalizado - a principal caracter√≠stica do envio m√∫ltiplo. </p><br><p>  Aqui est√° um exemplo (completamente artificial) de c√≥digo gen√©rico: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> LinearAlgebra <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> inner_sum(A, vs) t = zero(eltype(A)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vs t += inner(v, A, v) <span class="hljs-comment"><span class="hljs-comment">#  ! end return t end inner(v, A, w) = dot(v, A * w) #   </span></span></code> </pre> <br><p>  Aqui <code>A</code> √© algo parecido com matriz (embora eu n√£o tenha indicado os tipos e posso adivinhar algo pelo nome), <code>vs</code> √© o vetor de alguns elementos semelhantes a vetores e, em seguida, o produto escalar √© considerado por meio dessa "matriz", para o qual √© dada uma defini√ß√£o generalizada sem especificar nenhum tipo.  A programa√ß√£o generalizada aqui consiste nessa mesma chamada da fun√ß√£o <code>inner()</code> em um loop (conselho profissional: se voc√™ deseja escrever c√≥digo generalizado - basta remover quaisquer restri√ß√µes de tipo). </p><br><p>  Ent√£o, "olha, m√£e, funciona": </p><br><pre> <code class="julia hljs">julia&gt; A = rand(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>√ó<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: <span class="hljs-number"><span class="hljs-number">0.934255</span></span> <span class="hljs-number"><span class="hljs-number">0.712883</span></span> <span class="hljs-number"><span class="hljs-number">0.734033</span></span> <span class="hljs-number"><span class="hljs-number">0.145575</span></span> <span class="hljs-number"><span class="hljs-number">0.148775</span></span> <span class="hljs-number"><span class="hljs-number">0.131786</span></span> <span class="hljs-number"><span class="hljs-number">0.631839</span></span> <span class="hljs-number"><span class="hljs-number">0.688701</span></span> <span class="hljs-number"><span class="hljs-number">0.632088</span></span> julia&gt; vs = [rand(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>},<span class="hljs-number"><span class="hljs-number">1</span></span>}: [<span class="hljs-number"><span class="hljs-number">0.424535</span></span>, <span class="hljs-number"><span class="hljs-number">0.536761</span></span>, <span class="hljs-number"><span class="hljs-number">0.854301</span></span>] [<span class="hljs-number"><span class="hljs-number">0.715483</span></span>, <span class="hljs-number"><span class="hljs-number">0.986452</span></span>, <span class="hljs-number"><span class="hljs-number">0.82681</span></span>] [<span class="hljs-number"><span class="hljs-number">0.487955</span></span>, <span class="hljs-number"><span class="hljs-number">0.43354</span></span>, <span class="hljs-number"><span class="hljs-number">0.634452</span></span>] [<span class="hljs-number"><span class="hljs-number">0.100029</span></span>, <span class="hljs-number"><span class="hljs-number">0.448316</span></span>, <span class="hljs-number"><span class="hljs-number">0.603441</span></span>] julia&gt; inner_sum(A, vs) <span class="hljs-number"><span class="hljs-number">6.825340887556694</span></span></code> </pre> <br><p>  Nada de especial, ele calcula algum valor.  <em>Mas</em> - o c√≥digo √© escrito em um estilo generalizado e funcionar√° para todos os <code>A</code> e <code>vs</code> , se ao menos for poss√≠vel executar as opera√ß√µes correspondentes neles. </p><br><p>  Quanto √† efici√™ncia em tipos de dados espec√≠ficos - que sorte.  Quero dizer que, para vetores e matrizes densos, esse c√≥digo o far√° "como deveria" - ele gerar√° c√≥digo de m√°quina com a invoca√ß√£o de opera√ß√µes BLAS, etc.  etc.  Se voc√™ passar matrizes est√°ticas, o compilador levar√° isso em conta, expandir√° os ciclos, aplicar√° a vetoriza√ß√£o - tudo est√° como deveria. </p><br><p>  Mais importante, por√©m, o c√≥digo funcionar√° para novos tipos, e voc√™ pode torn√°-lo n√£o apenas supereficiente, mas super eficiente!  Vamos definir um novo tipo (este √© o tipo de dados real usado no aprendizado de m√°quina), um vetor unit√°rio (vetor quente).  Este √© um vetor em que um dos componentes √© 1 e todos os outros s√£o zero.  Voc√™ pode imaginar isso de maneira muito compacta: tudo o que precisa ser armazenado √© o comprimento do vetor e o n√∫mero do componente diferente de zero. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Base: size, getindex, * <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> OneHotVector &lt;: <span class="hljs-built_in"><span class="hljs-built_in">AbstractVector</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>} len :: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ind :: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> size(v::OneHotVector) = (v.len,) getindex(v::OneHotVector, i::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>) = <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>(i == v.ind)</code> </pre> <br><p>  De fato, esta √© realmente a defini√ß√£o de tipo completa do pacote que a adiciona.  E com esta defini√ß√£o, <code>inner_sum()</code> tamb√©m funciona: </p><br><pre> <code class="julia hljs">julia&gt; vs = [OneHotVector(<span class="hljs-number"><span class="hljs-number">3</span></span>, rand(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{OneHotVector,<span class="hljs-number"><span class="hljs-number">1</span></span>}: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] julia&gt; inner_sum(A, vs) <span class="hljs-number"><span class="hljs-number">2.6493739294755123</span></span></code> </pre> <br><p>  Mas para um produto escalar, uma defini√ß√£o geral √© usada aqui - para esse tipo de dados √© lento, n√£o √© legal! </p><br><p>  Portanto, as defini√ß√µes gerais funcionam, mas nem sempre da maneira ideal, e voc√™ pode ocasionalmente encontrar isso ao usar Julia: "bem, uma defini√ß√£o geral √© chamada, √© por isso que esse c√≥digo da GPU est√° funcionando pela quinta hora ..." </p><br><p>  Em <code>inner()</code> por padr√£o, √© chamada a defini√ß√£o geral do produto da matriz por um vetor, que quando multiplicado por um vetor unit√°rio retorna uma c√≥pia de uma das colunas do tipo <code>Vector{Float64}</code> .  Em seguida, a defini√ß√£o geral do produto escalar <code>dot()</code> √© chamada com o vetor unit√°rio e esta coluna, que faz muito trabalho desnecess√°rio.  De fato, para cada componente √© verificado "voc√™ √© igual a um? E voc√™?"  etc. </p><br><p>  Podemos otimizar bastante esse procedimento.  Por exemplo, substituindo a multiplica√ß√£o de matrizes por <code>OneHotVector</code> simplesmente selecionando uma coluna.  Tudo bem, defina esse m√©todo, e √© isso. </p><br><pre> <code class="julia hljs">*(A::<span class="hljs-built_in"><span class="hljs-built_in">AbstractMatrix</span></span>, v::OneHotVector) = A[:, v.ind]</code> </pre> <br><p>  E aqui est√° o <strong>poder</strong> : dizemos "queremos despachar <em>o segundo argumento</em> " <em>,</em> n√£o importa o que esteja no primeiro.  Essa defini√ß√£o simplesmente puxa a linha para fora da matriz e ser√° muito mais r√°pida que o m√©todo geral - a itera√ß√£o e a soma das colunas s√£o removidas. </p><br><p>  Mas voc√™ pode ir al√©m e otimizar diretamente <code>inner()</code> , porque multiplicar dois vetores unit√°rios por meio de uma matriz simplesmente extrai um elemento dessa matriz: </p><br><pre> <code class="julia hljs">inner(v::OneHotVector, A, w::OneHotVector) = A[v.ind, w.ind]</code> </pre> <br><p>  Essa √© a prometida efici√™ncia do super-duper.  E tudo o que √© necess√°rio √© definir esse m√©todo <code>inner()</code> . </p><br><p>  Este exemplo mostra um dos aplicativos de agendamento m√∫ltiplo: existe uma defini√ß√£o geral de uma fun√ß√£o, mas para alguns tipos de dados ela n√£o funciona da melhor maneira.  E, em seguida, adicionamos um m√©todo que preserva o <em>comportamento</em> da fun√ß√£o para esses tipos, mas funciona com muito <em>mais efici√™ncia</em> . </p><br><p>  Mas h√° outra √°rea - quando n√£o h√° defini√ß√£o geral de uma fun√ß√£o, mas quero adicionar funcionalidade para alguns tipos.  Em seguida, voc√™ pode adicion√°-lo com o m√≠nimo esfor√ßo. </p><br><p>  E a terceira op√ß√£o - voc√™ s√≥ quer ter o mesmo nome de fun√ß√£o, mas com comportamento diferente para diferentes tipos de dados - por exemplo, para que uma fun√ß√£o se comporte de maneira diferente ao trabalhar com dicion√°rios e matrizes. </p><br><p>  Como obter comportamento semelhante em idiomas de despacho √∫nico?  √â poss√≠vel, mas dif√≠cil.  Problema: ao sobrecarregar a fun√ß√£o <code>*</code> era necess√°rio despachar no segundo argumento, e n√£o no primeiro.  Voc√™ pode fazer o despacho duplo: primeiro, despache pelo primeiro argumento e chame o m√©todo <code>AbstractMatrix.*(v)</code> .  E esse m√©todo, por sua vez, chama algo como <code>v.__rmul__(A)</code> , ou seja,  o segundo argumento na chamada original agora se tornou o objeto cujo m√©todo est√° realmente sendo chamado.  <code>__rmul__</code> aqui retirado do Python, onde esse comportamento √© um padr√£o padr√£o, mas parece funcionar apenas para adi√ß√£o e multiplica√ß√£o.  I.e.  o problema do envio duplo ser√° resolvido se quisermos chamar uma fun√ß√£o chamada <code>+</code> ou <code>*</code> , caso contr√°rio - infelizmente, n√£o nos dias de hoje.  Em C ++ e outras l√≠nguas - voc√™ precisa construir sua bicicleta. </p><br><p>  OK, e quanto a <code>inner()</code> ?  Agora existem tr√™s argumentos, e o envio continua no primeiro e no terceiro.  O que fazer em idiomas com envio √∫nico n√£o est√° claro.  "Expedi√ß√£o tripla" eu nunca conheci ao vivo.  N√£o h√° boas solu√ß√µes.  Geralmente, quando surge uma necessidade semelhante (e em c√≥digos num√©ricos aparece com muita frequ√™ncia), as pessoas acabam implementando seu sistema de envio m√∫ltiplo.  Se voc√™ olhar para grandes projetos para c√°lculos num√©ricos em Python, ficar√° surpreso com quantos deles s√£o assim.  Naturalmente, essas implementa√ß√µes funcionam situacionalmente, mal projetadas, cheias de bugs e lentas ( <em>refer√™ncia √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">d√©cima regra de Greenspan</a> - aprox. Transl.</em> ), Porque Jeff Besancon n√£o trabalhou em nenhum desses projetos (o <em>autor e o principal desenvolvedor do sistema de envio de tipos em Julia - aprox. tradu√ß√£o</em> ). </p><br><h3 id="chast-2-obschie-tipy">  Parte 2. Tipos Gerais </h3><br><p>  Vou passar para o lado oposto do paradigma de Julia - os tipos gerais.  Este, na minha opini√£o, √© o principal "cavalo de batalha" da linguagem, porque √© nessa √°rea que observo um alto n√≠vel de reutiliza√ß√£o de c√≥digo. </p><br><p>  Por exemplo, suponha que voc√™ tenha um tipo RGB, como o ColorTypes.jl.  N√£o h√° nada complicado, apenas tr√™s valores s√£o reunidos.  Por uma quest√£o de simplicidade, assumimos que o tipo n√£o √© param√©trico (mas poderia ter sido), e o autor definiu v√°rias opera√ß√µes b√°sicas para ele que achou √∫teis.  Voc√™ pega esse tipo e pensa: "Hmm, eu gostaria de adicionar mais opera√ß√µes nesse tipo".  Por exemplo, imagine RGB como um espa√ßo vetorial (que, estritamente falando, est√° incorreto, mas se resume a uma primeira aproxima√ß√£o).  Em Julia, voc√™ simplesmente pega e adiciona no seu c√≥digo todas as opera√ß√µes que est√£o faltando. </p><br><p>  A quest√£o surge - <em>e cho?</em>  Por que estou me concentrando tanto nisso?  Acontece que em linguagens orientadas a objetos baseadas em classes, essa abordagem √© surpreendentemente dif√≠cil de implementar.  Como as defini√ß√µes de m√©todo nessas linguagens est√£o dentro da defini√ß√£o de classe, existem apenas duas maneiras de adicionar um m√©todo: edite o c√≥digo da classe para adicionar o comportamento desejado ou crie uma classe herdada com os m√©todos necess√°rios. </p><br><p>  A primeira op√ß√£o aumenta a defini√ß√£o da classe base e tamb√©m for√ßa o desenvolvedor da classe base a cuidar do suporte de todos os m√©todos adicionados ao alterar o c√≥digo.  O que um dia poderia tornar essa classe sem suporte? </p><br><p>  A heran√ßa √© uma op√ß√£o cl√°ssica "recomendada", mas tamb√©m n√£o sem falhas.  Primeiro, voc√™ precisa alterar o nome da classe - deixe que agora n√£o seja <code>RGB</code> , mas <code>MyRGB</code> .  Al√©m disso, novos m√©todos n√£o funcionar√£o mais para a classe <code>RGB</code> original;  se quiser aplicar meu novo m√©todo a um objeto <code>RGB</code> criado no c√≥digo de outra pessoa, preciso convert√™-lo ou quebr√°-lo no <code>MyRGB</code> .  Mas isso n√£o √© o pior.  Se eu fiz uma aula <code>MyRGB</code> com algumas funcionalidades adicionais, outra pessoa <code>OurRGB</code> , etc.  - ent√£o, se algu√©m quiser uma classe com todas as novas funcionalidades, ser√° necess√°rio usar heran√ßa m√∫ltipla (e isso √© apenas se a linguagem de programa√ß√£o permitir!). </p><br><p>  Ent√£o, ambas as op√ß√µes s√£o mais ou menos.  Existem, no entanto, outras solu√ß√µes: </p><br><ul><li>  Coloque o funcional em uma fun√ß√£o externa em vez do m√©todo de classe - v√° para <code>f(x, y)</code> vez de <code>xf(y)</code> .  Mas ent√£o o comportamento generalizado √© perdido. </li><li>  Cuspir na reutiliza√ß√£o de c√≥digo (e, parece-me, em muitos casos, isso acontece).  Apenas copie uma classe <code>RGB</code> alien√≠gena e adicione o que est√° faltando. </li></ul><br><p>  O principal recurso de Julia em termos de reutiliza√ß√£o de c√≥digo √© quase completamente reduzido ao fato de o <em>m√©todo ser definido fora do tipo</em> .  S√≥ isso.  Fa√ßa o mesmo em idiomas de envio √∫nico - e os tipos podem ser reutilizados com a mesma facilidade.  A hist√≥ria toda com ‚Äúvamos fazer parte dos m√©todos da classe‚Äù √© uma id√©ia mais ou menos, na verdade.  √â verdade que h√° um bom argumento - o uso de classes como namespaces.  Se eu escrever que <code>xf(y)</code> - <code>f()</code> n√£o precisa estar no espa√ßo para nome atual, ele dever√° ser pesquisado no espa√ßo para nome <code>x</code> .  Sim, isso √© uma coisa boa - mas vale a pena todos os outros problemas?  Eu n√£o sei  Na minha opini√£o, n√£o (embora minha opini√£o, como voc√™ possa imaginar, seja um pouco tendenciosa). </p><br><h3 id="epilog-problema-vyrazheniya">  Ep√≠logo.  O problema da express√£o </h3><br><p>  H√° um problema de programa√ß√£o que foi notado nos anos 70.  Est√° amplamente relacionado √† verifica√ß√£o de tipo est√°tico, porque apareceu nesses idiomas.  √â verdade que acho que isso n√£o tem nada a ver com a verifica√ß√£o de tipo est√°tico.  A ess√™ncia do problema √© a seguinte: √© poss√≠vel alterar o modelo de dados e o conjunto de opera√ß√µes nos dados ao mesmo tempo, sem recorrer a t√©cnicas duvidosas. </p><br><p>  O problema pode ser mais ou menos reduzido ao seguinte: </p><br><ol><li>  √© poss√≠vel adicionar <strong>novos tipos de dados</strong> com facilidade e sem erros aos quais <strong>os m√©todos existentes s√£o aplic√°veis</strong> e </li><li>  √â poss√≠vel <strong>adicionar novas opera√ß√µes</strong> em <strong>tipos existentes</strong> . </li></ol><br><p>  (1) facilmente realizado em linguagens orientadas a objetos e dif√≠cil em funcional, (2) - vice-versa.  Nesse sentido, podemos apenas falar sobre o dualismo das abordagens OOP e FP. </p><br><p>  Nos idiomas de despacho m√∫ltiplo, as duas opera√ß√µes s√£o f√°ceis. (1)         , (2) ‚Äî      . <em>   </em> ,    .         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://en.wikipedia.org/wiki/Expression_problem</a> ),           .     ?  ,   ,     .   , "  ,     " ‚Äî   "    "  .  "  ,     " ,       ,   . </p><br><p>            ,   .  ,  ,   ‚Äî      . </p><br><p>  ,   Julia    (     ),      .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468609/">https://habr.com/ru/post/pt468609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468597/index.html">O hex√°gono de Saturno ou como em casa reproduzir o experimento de cientistas da Universidade de Oxford</a></li>
<li><a href="../pt468601/index.html">Estimativa do prazo do projeto. Por que quase sempre √© muito discreto e o que fazer sobre isso</a></li>
<li><a href="../pt468603/index.html">O Rutracker incluiu o eSNI. Fim da era do DPI e fim dos bloqueios</a></li>
<li><a href="../pt468605/index.html">Ponteiros constantes para ponteiros para ponteiros ...</a></li>
<li><a href="../pt468607/index.html">Android para o engenheiro de r√°dio (parte dois)</a></li>
<li><a href="../pt468611/index.html">Multithreading .NET: quando o desempenho est√° ausente</a></li>
<li><a href="../pt468615/index.html">Os 10 principais idiomas para localiza√ß√£o de aplicativos</a></li>
<li><a href="../pt468621/index.html">Traduzimos a rede dom√©stica para DoH, ou outro clique no nariz do filtro</a></li>
<li><a href="../pt468623/index.html">Quero resenhas sobre Habr</a></li>
<li><a href="../pt468625/index.html">Sem servidor: 15% mais lento e oito vezes mais caro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>