<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏾 😠 🙌🏿 Cómo degradar el rendimiento al mejorarlo 👩🏼‍✈️ 🧑🏼‍🤝‍🧑🏼 👯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Queríamos lo mejor, pero resultó como siempre. 
 Victor Chernomyrdin, 
 Estadista ruso 


 Hay momentos en la vida en los que pareces estar haciendo t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo degradar el rendimiento al mejorarlo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436746/"><p> <em>Queríamos lo mejor, pero resultó como siempre.</em> <br>  Victor Chernomyrdin, <br>  Estadista ruso </p><br><p>  Hay momentos en la vida en los que pareces estar haciendo todo bien, pero algo sale mal. <br>  Esta historia es sobre uno de esos casos. </p><a name="habracut"></a><br><p>  Una vez que miré este código y pensé en acelerarlo: </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(data.str, beginIndex, endIndex) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); }</code> </pre> <br><p>  Primero, quería calcular la longitud total de la cadena usando las variables <code>beginIndex</code> y <code>endIndex</code> (así como el hecho de que, además de la cadena truncada, se agregarán 2 caracteres más a <code>StringBuilder</code> ) y pasar este valor al constructor <code>StringBuilder</code> para seleccionar inmediatamente la matriz del tamaño requerido .  Este pensamiento me pareció demasiado obvio, así que decidí probar otra cosa.  El hecho de que este código no haya sido resaltado por la "Idea" me llevó a la idea correcta, aunque esta chica inteligente generalmente sugiere reemplazar la cadena corta de <code>StringBuilder::append</code> con la adición de cadenas, que es más corta y más fácil de leer. </p><br><p>  Un obstáculo para esta simplificación es el uso del método <code>StringBuilder.append(CharSequence, int, int)</code> .  Dado que el campo <code>data.str</code> es una cadena, con <code>String.substring(beginIndex, endIndex)</code> puede seleccionar una subcadena y pasarla a <code>StringBuilder.append(String)</code> . </p><br><p>  Código después de la conversión: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String subString = data.str.substring(beginIndex, endIndex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(subString) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); }</code> </pre> <br><p>  Y ahora la Idea ofrece una simplificación: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'L'</span></span> + data.str.substring(beginIndex, endIndex) + <span class="hljs-string"><span class="hljs-string">';'</span></span>; }</code> </pre> <br><p>  Sin embargo, nuestro objetivo en este caso no es tanto la legibilidad como la productividad.  Compare ambos métodos: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@Fork</span></span>(jvmArgsAppend = {<span class="hljs-string"><span class="hljs-string">"-Xms2g"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xmx2g"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilderAppendBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendSubString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ String latinStr = data.latinStr; String nonLatinStr = data.nonLatinStr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String substring = data.nonLatin ? nonLatinStr.substring(beginIndex, endIndex) : latinStr.substring(beginIndex, endIndex); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(substring) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Data data)</span></span></span><span class="hljs-function"> </span></span>{ String latinStr = data.latinStr; String nonLatinStr = data.nonLatinStr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex = data.beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex = data.endIndex; String appended = data.nonLatin ? nonLatinStr : latinStr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder() .append(<span class="hljs-string"><span class="hljs-string">'L'</span></span>) .append(appended, beginIndex, endIndex) .append(<span class="hljs-string"><span class="hljs-string">';'</span></span>) .toString(); } <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ String latinStr; String nonLatinStr; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-string"><span class="hljs-string">"false"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> nonLatin; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"5"</span></span>, <span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-string"><span class="hljs-string">"50"</span></span>, <span class="hljs-string"><span class="hljs-string">"100"</span></span>, <span class="hljs-string"><span class="hljs-string">"500"</span></span>, <span class="hljs-string"><span class="hljs-string">"1000"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beginIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> endIndex; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ThreadLocalRandom random = ThreadLocalRandom.current(); <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ latinStr = randomString(<span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span></span>); nonLatinStr = randomString(<span class="hljs-string"><span class="hljs-string">""</span></span>); beginIndex = <span class="hljs-number"><span class="hljs-number">1</span></span>; endIndex = length + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String alphabet)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] chars = alphabet.toCharArray(); StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(length + <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; length + <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = chars[random.nextInt(chars.length)]; sb.append(c); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sb.toString(); } } }</code> </pre> <br><p>  El punto de referencia es tan simple como dos centavos: se agrega una cadena aleatoria al <code>StringBuilder</code> , cuyo tamaño está determinado por el campo de <code>length</code> , y dado que el patio es 2019, debe verificarlo como una cadena que contiene solo los caracteres del alfabeto latino principal (la llamada línea comprimida, en la que cada carácter corresponde a 1 byte) y una cadena con caracteres no latinos (cada carácter está representado por 2 bytes). </p><br><p>  En un examen superficial, el método <code>appendSubString</code> nos <code>appendSubString</code> más lento, porque la cantidad de datos a pegar coincide con la del método <code>appendBounds</code> , sin embargo, en el método <code>appendSubString</code> hay una creación explícita de una subcadena, es decir, asignar memoria para un nuevo objeto y copiar el contenido de <code>data.latinStr</code> en él / <code>data.nonLatinStr</code> . </p><br><p>  Aún más sorprendente (pero solo a primera vista) los resultados de la medición realizada por mí usando JDK11 en una máquina doméstica (Intel Core i5-4690, 3.50 GHz) parecen ser: </p><br><pre> <code class="plaintext hljs">Benchmark nonLatin length Score Error Units appendBounds true 5 44,6 ± 0,4 ns/op appendBounds true 10 45,7 ± 0,7 ns/op appendBounds true 50 129,0 ± 0,5 ns/op appendBounds true 100 218,7 ± 0,8 ns/op appendBounds true 500 907,1 ± 5,5 ns/op appendBounds true 1000 1626,4 ± 13,0 ns/op appendSubString true 5 28,6 ± 0,2 ns/op appendSubString true 10 30,8 ± 0,2 ns/op appendSubString true 50 65,6 ± 0,4 ns/op appendSubString true 100 106,6 ± 0,6 ns/op appendSubString true 500 430,1 ± 2,4 ns/op appendSubString true 1000 839,1 ± 8,6 ns/op appendBounds:·gc.alloc.rate.norm true 5 184,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 10 200,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 50 688,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 100 1192,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 500 5192,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm true 1000 10200,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 5 136,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 10 160,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 50 360,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 100 608,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 500 2608,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm true 1000 5104,0 ± 0,0 B/op appendBounds false 5 20,8 ± 0,1 ns/op appendBounds false 10 24,0 ± 0,2 ns/op appendBounds false 50 66,4 ± 0,4 ns/op appendBounds false 100 111,0 ± 0,8 ns/op appendBounds false 500 419,2 ± 2,7 ns/op appendBounds false 1000 840,4 ± 7,8 ns/op appendSubString false 5 25,3 ± 0,3 ns/op appendSubString false 10 25,7 ± 0,2 ns/op appendSubString false 50 36,0 ± 0,1 ns/op appendSubString false 100 52,8 ± 0,4 ns/op appendSubString false 500 206,1 ± 6,1 ns/op appendSubString false 1000 388,1 ± 1,6 ns/op appendBounds:·gc.alloc.rate.norm false 5 80,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 10 88,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 50 320,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 100 544,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 500 2144,0 ± 0,0 B/op appendBounds:·gc.alloc.rate.norm false 1000 4152,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 5 96,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 10 112,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 50 192,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 100 288,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 500 1088,0 ± 0,0 B/op appendSubString:·gc.alloc.rate.norm false 1000 2088,0 ± 0,0 B/op</code> </pre> <br><p>  Refutando nuestra suposición, el método <code>appendSubString</code> en la gran mayoría de los casos (incluso siempre para cadenas no latinas) resultó ser más rápido y menos glotón (aunque <code>String::substring</code> devuelve un nuevo objeto).  Como sucedio </p><br><h2 id="smotryu-v-knigu-vizhu-figu">  Miro en el libro, veo un higo </h2><br><p>  Estudiar el código fuente de <code>StringBuilder</code> ayudará a <code>StringBuilder</code> velo del secreto.  Ambos métodos utilizados pasan la llamada a los mismos métodos de <code>AbstractStringBuilder</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractStringBuilder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Comparable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharSequence</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(s, start, end); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p>  Vaya a <code>AbstractStringBuilder.append(String)</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AbstractStringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> appendNull(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = str.length(); ensureCapacityInternal(count + len); putStringAt(count, str); count += len; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putStringAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getCoder() != str.coder()) { inflate(); } str.getBytes(value, index, coder); }</code> </pre> <br><p>  ¿Qué es interesante aquí?  El <code>AbstractStringBuilder::inflate</code> , como su nombre lo indica, expande la matriz <code>AbstractStringBuilder.value</code> al combinar cadenas diferentes.  Los datos se <code>String::getBytes</code> en el <code>String::getBytes</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dstBegin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> coder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (coder() == coder) { System.arraycopy(value, <span class="hljs-number"><span class="hljs-number">0</span></span>, dst, dstBegin &lt;&lt; coder, value.length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// this.coder == LATIN &amp;&amp; coder == UTF16 StringLatin1.inflate(value, 0, dst, dstBegin, value.length); } }</span></span></code> </pre> <br><p>  Que es importante  Si las cadenas son homogéneas, entonces el <code>System::arraycopy</code> intrínseco <code>System::arraycopy</code> se usa para mover los datos, de lo contrario <code>StringLatin1::inflate</code> , que por delegación nos lleva al <code>StringUTF16::inflate</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// inflatedCopy byte[] -&gt; byte[] @HotSpotIntrinsicCandidate public static void inflate(byte[] src, int srcOff, byte[] dst, int dstOff, int len) { // We need a range check here because 'putChar' has no checks checkBoundsOffCount(dstOff, len, dst); for (int i = 0; i &lt; len; i++) { putChar(dst, dstOff++, src[srcOff++] &amp; 0xff); } } @HotSpotIntrinsicCandidate static void putChar(byte[] val, int index, int c) { assert index &gt;= 0 &amp;&amp; index &lt; length(val) : "Trusted caller missed bounds check"; index &lt;&lt;= 1; val[index++] = (byte)(c &gt;&gt; HI_BYTE_SHIFT); val[index] = (byte)(c &gt;&gt; LO_BYTE_SHIFT); }</span></span></code> </pre> <br><p>  Por lo tanto, si las filas son homogéneas, entonces el método dependiente de la plataforma <code>System::arraycopy</code> se usa para mover los datos, de lo contrario se usa un bucle (también intrínseco).  Esto significa que cuando se pegan dos líneas, donde todos los caracteres están en el conjunto del alfabeto latino principal (en otras palabras, caben en 1 byte), el rendimiento debería ser mucho mejor que cuando se pegan líneas heterogéneas.  El punto de referencia confirma esto (ver salida para <code>nonLatin = false</code> ). </p><br><p>  Ahora el método <code>AbstractStringBuilder.append(CharSequence, int, int)</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AbstractStringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { s = <span class="hljs-string"><span class="hljs-string">"null"</span></span>; } checkRange(start, end, s.length()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = end - start; ensureCapacityInternal(count + len); appendChars(s, start, end); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">appendChars</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> off, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLatin1()) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] val = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = off, j = count; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = s.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StringLatin1.canEncode(c)) { val[j++] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)c; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { count = j; inflate(); StringUTF16.putCharsSB(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value, j, s, i, end); count += end - i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { StringUTF16.putCharsSB(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.value, count, s, off, end); } count += end - off; }</code> </pre> <br><p>  Aquí, el enfoque es similar al del ejemplo anterior: para cadenas homogéneas, se usa un mecanismo más simple (aquí, copia de signos en un bucle), para cadenas heterogéneas usamos <code>StringUTF16</code> , sin embargo, tenga en cuenta que el <code>StringUTF16::putCharsSB</code> llamado <code>StringUTF16::putCharsSB</code> no <code>StringUTF16::putCharsSB</code> intrinsificado. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putCharsSB</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, CharSequence s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> off, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end)</span></span></span><span class="hljs-function"> </span></span>{ checkBoundsBeginEnd(index, index + end - off, val); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = off; i &lt; end; i++) { putChar(val, index++, s.charAt(i)); } }</code> </pre> <br><p>  Por lo tanto, la estructura interna de ambos métodos y la razón de su desempeño diferente son más o menos claros para nosotros.  La pregunta surge naturalmente: ¿qué hacer con el conocimiento adquirido a continuación?  Hay varias opciones a la vez: </p><br><p>  1) tenga esto en cuenta y cuando detecte un código sospechoso, cámbielo con las manos <br>  2) ve a Tagir y pídele que presente un cheque que hará el trabajo en lugar de nosotros <br>  3) realice cambios en el JDK para que el código no cambie en absoluto. </p><br><p>  Por supuesto, comenzamos con el tercero.  ¿Listo para arriesgarse? </p><br><h2 id="pogruzhenie-v-puchinu">  Abismo </h2><br><p>  Nosotros entrenaremos <del>  en gatos </del>  en el código fuente del undécimo Java, puede descargarlo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><p>  La forma más simple y obvia de mejorar es seleccionar una subcadena que ya se encuentre dentro del <code>AbstractStringBuilder.append(CharSequence, int, int)</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  public AbstractStringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); int len = end - start; ensureCapacityInternal(count + len); appendChars(s, start, end); return this; } //  public AbstractStringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); return append(s.subSequence(start, end).toString()); }</span></span></code> </pre> <br><p>  Ahora necesita construir el JDK, ejecutar las pruebas y ejecutar el benchmark <code>StringBuilderAppendBenchmark::appendBounds</code> en él, cuyos resultados deben compararse con los resultados del mismo benchmark en el JDK original: </p><br><pre> <code class="plaintext hljs">#   before      JDK, # after -   Benchmark nonLatin length before after Units avgt true 5 44,6 64,4 ns/op avgt true 10 45,7 66,3 ns/op avgt true 50 129,0 168,9 ns/op avgt true 100 218,7 281,9 ns/op avgt true 500 907,1 1116,2 ns/op avgt true 1000 1626,4 2002,5 ns/op gc.alloc.rate.norm true 5 184,0 264,0 B/op gc.alloc.rate.norm true 10 200,0 296,0 B/op gc.alloc.rate.norm true 50 688,0 904,0 B/op gc.alloc.rate.norm true 100 1192,0 1552,0 B/op gc.alloc.rate.norm true 500 5192,0 6752,0 B/op gc.alloc.rate.norm true 1000 10200,0 13256,0 B/op avgt false 5 20,8 38,0 ns/op avgt false 10 24,0 37,8 ns/op avgt false 50 66,4 82,9 ns/op avgt false 100 111,0 138,8 ns/op avgt false 500 419,2 531,9 ns/op avgt false 1000 840,4 1002,7 ns/op gc.alloc.rate.norm false 5 80,0 152,0 B/op gc.alloc.rate.norm false 10 88,0 168,0 B/op gc.alloc.rate.norm false 50 320,0 440,0 B/op gc.alloc.rate.norm false 100 544,0 688,0 B/op gc.alloc.rate.norm false 500 2144,0 2688,0 B/op gc.alloc.rate.norm false 1000 4152,0 5192,0 B/op</code> </pre> <br><p>  Lo que se llama, de repente!  No solo no se produjeron mejoras, sino que se produjo un deterioro.  Maldición, pero ¿cómo? </p><br><p>  El hecho es que al principio, en la descripción del método <code>StringBuilder::append</code> hice una pequeña omisión, pero de importancia crítica.  El método fue descrito así: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p>  Y aquí está su vista completa: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p>  El código Java que examinamos anteriormente, que se calienta y compila en el nivel C2, no importa, porque no se ejecuta, sino que es intrínseco.  Esto es fácil de probar eliminando el perfil utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">async-profiler</a> .  En lo sucesivo, el perfil se elimina para <code>length = 1000</code> y <code>nonLatin = true</code> : </p><br><pre> <code class="plaintext hljs">#   `appendSubString`, JDK    ns percent samples top ---------- ------- ------- --- 19096340914 43.57% 1897673 jbyte_disjoint_arraycopy &lt;--------- 13500185356 30.80% 1343343 jshort_disjoint_arraycopy &lt;--------- 4124818581 9.41% 409533 java.lang.String.&lt;init&gt; #   2177311938 4.97% 216375 java.lang.StringUTF16.compress #   1557269661 3.55% 154253 java.util.Arrays.copyOfRange #   349344451 0.80% 34823 appendSubString_avgt_jmhStub 279803769 0.64% 27862 java.lang.StringUTF16.newString 274388920 0.63% 27312 org.openjdk.jmh.infra.Blackhole.consume 160962540 0.37% 15946 SpinPause 122418222 0.28% 11795 __memset_avx2</code> </pre> <br><p>  El código de <code>StringBuilder</code> (y <code>AbstractStringBuilder</code> ) ni siquiera huele aquí, casi 3/4 del perfil está ocupado por un intrínseco.  Me gustaría observar la misma imagen en el perfil de nuestro <code>StringBuilder.append(CharSequence, int, int)</code> "mejorado" <code>StringBuilder.append(CharSequence, int, int)</code> . </p><br><p>  De hecho, tenemos esto: </p><br><pre> <code class="plaintext hljs"> ns percent samples top ---------- ------- ------- --- 19071221451 43.78% 1897827 jbyte_disjoint_arraycopy 6409223440 14.71% 638348 jlong_disjoint_arraycopy 3933622128 9.03% 387403 java.lang.StringUTF16.newBytesFor 2067248311 4.75% 204193 java.lang.AbstractStringBuilder.ensureCapacityInternal 1929218737 4.43% 194751 java.lang.StringUTF16.compress 1678321343 3.85% 166458 java.util.Arrays.copyOfRange 1621470408 3.72% 160849 java.lang.String.checkIndex 969180099 2.22% 96018 java.util.Arrays.copyOf 581600786 1.34% 57818 java.lang.AbstractStringBuilder.&lt;init&gt; 417818533 0.96% 41611 appendBounds_jmhTest 406565329 0.93% 40479 java.lang.String.&lt;init&gt; 340972882 0.78% 33727 java.lang.AbstractStringBuilder.append 299895915 0.69% 29982 java.lang.StringBuilder.toString 183885595 0.42% 18136 SpinPause 168666033 0.39% 16755 org.openjdk.jmh.infra.Blackhole.consume</code> </pre> <br><p>  Dirás: "¡Aquí están, intrínsecos, en la cima!"  De hecho, solo estos no son los mismos intrínsecos (incl. Compare el nombre del segundo desde arriba).  Recordar: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@HotSpotIntrinsicCandidate</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> StringBuilder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.append(str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }</code> </pre> <br><p>  Aquí lo intrínseco reemplaza la llamada a <code>StringBuilder.append(String)</code> , pero en nuestro parche esta llamada no lo es.  Llamado <code>AbstractStringBuilder.append(String)</code> .  La llamada <code>jbyte_disjoint_arraycopy</code> que <code>jbyte_disjoint_arraycopy</code> es intrínseca para <code>StringLatin1::inflate</code> , llamada desde <code>AbstractStringBuider::putStringAt</code> través de <code>String::getBytes</code> .  Es decir, a diferencia de <code>StringBuilder::append</code> procesa no solo código de plataforma específico, sino también código Java, </p><br><p>  Entendido la causa del fracaso, trate de tener éxito de lo contrario.  Es fácil adivinar que necesitamos referirnos de alguna manera a <code>StringBuilder::append</code> .  Puede hacerlo arrancando el parche anterior y realizando cambios en el propio <code>StringBuilder</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  @Override public StringBuilder append(CharSequence s, int start, int end) { super.append(s, start, end); return this; } //  @Override public StringBuilder append(CharSequence s, int start, int end) { if (s == null) { s = "null"; } checkRange(start, end, s.length()); return this.append(s.subSequence(start, end).toString()); } }</span></span></code> </pre> <br><p>  Ahora todo se hace sabiamente: se llama al StringBuilder :: append intrínseco. <br>  Reconstruir, ejecutar, comparar: </p><br><pre> <code class="plaintext hljs">#   before      JDK, # after -   Benchmark nonLatin length before after Units avgt true 5 44,6 60,2 ns/op avgt true 10 45,7 59,1 ns/op avgt true 50 129,0 164,6 ns/op avgt true 100 218,7 276,2 ns/op avgt true 500 907,1 1088,8 ns/op avgt true 1000 1626,4 1959,4 ns/op gc.alloc.rate.norm true 5 184,0 264,0 B/op gc.alloc.rate.norm true 10 200,0 296,0 B/op gc.alloc.rate.norm true 50 688,0 904,0 B/op gc.alloc.rate.norm true 100 1192,0 1552,0 B/op gc.alloc.rate.norm true 500 5192,0 6752,0 B/op gc.alloc.rate.norm true 1000 10200,0 13256,0 B/op avgt false 5 20,8 37,9 ns/op avgt false 10 24,0 37,9 ns/op avgt false 50 66,4 80,9 ns/op avgt false 100 111,0 125,6 ns/op avgt false 500 419,2 483,6 ns/op avgt false 1000 840,4 893,8 ns/op gc.alloc.rate.norm false 5 80,0 152,0 B/op gc.alloc.rate.norm false 10 88,0 168,0 B/op gc.alloc.rate.norm false 50 320,0 440,0 B/op gc.alloc.rate.norm false 100 544,0 688,0 B/op gc.alloc.rate.norm false 500 2144,0 2688,0 B/op gc.alloc.rate.norm false 1000 4152,0 5187,2 B/op</code> </pre><br><p>  Realmente me siento muy triste, pero no mejoró.  Ahora un nuevo perfil: </p><br><pre> <code class="plaintext hljs"> ns percent samples top ---------- ------- ------- --- 19614374885 44.12% 1953620 jbyte_disjoint_arraycopy 6645299702 14.95% 662146 jlong_disjoint_arraycopy 4065789919 9.15% 400167 java.lang.StringUTF16.newBytesFor 2374627822 5.34% 234746 java.lang.AbstractStringBuilder.ensureCapacityInternal 1837858014 4.13% 183822 java.lang.StringUTF16.compress 1472039604 3.31% 145956 java.util.Arrays.copyOfRange 1316397864 2.96% 130747 appendBounds_jmhTest 956823151 2.15% 94959 java.util.Arrays.copyOf 573091712 1.29% 56933 java.lang.AbstractStringBuilder.&lt;init&gt; 434454076 0.98% 43202 java.lang.String.&lt;init&gt; 368480388 0.83% 36439 java.lang.AbstractStringBuilder.append 304409057 0.68% 30442 java.lang.StringBuilder.toString 272437989 0.61% 26833 SpinPause 201051696 0.45% 19985 java.lang.StringBuilder.&lt;init&gt; 198934052 0.45% 19810 appendBounds_avgt_jmhStub</code> </pre> <br><p>  Poco ha cambiado.  Para mí, no está claro por qué el intrínseco no funcionó al acceder a <code>StringBuilder.append(String)</code> desde <code>StringBuilder</code> .  Existe la sospecha de que pegar (en línea) el cuerpo del método <code>StringBuilder.append(String)</code> en el cuerpo de <code>StringBuilder.append(CharSequence, int, int)</code> cambia algo en el procesamiento de las llamadas al método VM. </p><br><p>  De todos modos, este es un fiasco, hermano.  No fue posible parchear el JDK, pero aún podemos hacer el reemplazo manualmente donde tenga sentido. </p><br><div class="spoiler">  <b class="spoiler_title">Retiro literario de fracaso</b> <div class="spoiler_text"><blockquote>  El cifrado de respuesta llegó en dos días.  El navegador no quiere separarse de Oto Velara, con una compañía que construye buques de guerra sorprendentemente rápidos y poderosos.  El navegador no quiere leerme el cifrado.  Simplemente repite la respuesta del puesto de comando: "No."  El cifrado no explica por qué "no".  "No" en cualquier caso significa que es una persona conocida por una computadora grande.  Si no se supiera nada de él, la respuesta sería sí: pruébelo.  Que mal.  Es una pena perder a una persona tan interesante.  Y el comandante debe sentir pena por mí.  Quizás la primera vez es una pena.  Me ve destrozando a los vikingos.  Y no quiere empujarme de nuevo a los galgos. <br>  El calla.  Pero sé que al proporcionar una escasez salvaje de trabajadores: <br>  - Yo, camarada general, trabajo mañana para proporcionar.  Dejame ir <br>  - Adelante  - Y de repente ella sonríe.  "Ya sabes, cada nube tiene un lado positivo". <br>  "Yo, camarada general, siempre estoy enfermo sin bien". <br>  "Y aquí está".  Se te prohibió conocerlo, eso es malo.  <strong>Pero a los tesoros de nuestra experiencia, agregamos otro grano.</strong> </blockquote></div></div><br><p>  Conclusiones: </p><br><ul><li>  El código de los métodos JDK en algunos casos no está relacionado con la ejecución real, porque en lugar del cuerpo del método se puede ejecutar un intrínseco, que está oculto en las entrañas de la VM. </li><li>  tales métodos se pueden reconocer, en particular, la etiqueta <code>@HotSpotIntrinsicCandidate</code> señala, aunque algunos métodos están intrinsificados sin ninguna pista, por ejemplo <code>String::equals</code> (y <a href="">muchos, muchos otros</a> ). </li><li>  La conclusión que se desprende de los dos primeros es que nuestra discusión sobre cómo funciona el código JDK puede ser contraria a la realidad.  C'est la vie </li></ul><br><p>  PS <br>  Otro posible reemplazo: </p><br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(str, <span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex); <span class="hljs-comment"><span class="hljs-comment">// --&gt; StringBuilder sb = new StringBuilder(str.substring(o, endIndex));</span></span></code> </pre> <br><p>  PPS <br>  Los desarrolladores de Oracle señalan con razón que </p><br><blockquote>  Me parece bastante extraño y sorprendente introducir una ruta de código en <br>  sb.append (cs, int, int) que asigna memoria para llegar a un intrínseco que <br>  solo a veces hace que las cosas funcionen más rápido.  Como observaste, el rendimiento <br>  las compensaciones no son obvias. <br><br>  En cambio, si queremos optimizar sb.append (cs, int, int) tal vez deberíamos ir <br>  adelante y haga eso, posiblemente agregando o reorganizando los intrínsecos. </blockquote><p>  La solución propuesta es la intrinsificación de <code>StringBuilder.append(CharSequence, int, int)</code> . </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tarea</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Discusión</a> </p><br><p>  <strong>PPS</strong> <br>  Curiosamente, en este momento, al escribir algo como </p><br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(str.substring(<span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex));</code> </pre> <br><p>  "Idea" sugiere simplificar el código para </p><br><pre> <code class="java hljs">StringBuilder sb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); sb.append(s, <span class="hljs-number"><span class="hljs-number">0</span></span>, endIndex);</code> </pre> <br><p>  Si el rendimiento en este lugar no es muy importante para usted, probablemente sea más correcto usar la segunda versión simplificada.  Aún así, la mayor parte del código que escribimos es para nuestros camaradas, no para las máquinas. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es436746/">https://habr.com/ru/post/es436746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es436728/index.html">Guía de ML.NET: primera aplicación en 10 minutos</a></li>
<li><a href="../es436730/index.html">Salón de la fama de la electrónica de consumo: las historias de los mejores artilugios de los últimos 50 años, parte 5</a></li>
<li><a href="../es436740/index.html">Investigación propia, ¿qué nos pueden decir las fuentes abiertas?</a></li>
<li><a href="../es436742/index.html">Android Robotics hasta 2019: la historia real; en 5 partes; parte 1</a></li>
<li><a href="../es436744/index.html">Inicie su detector de red neuronal en la Raspberry Pi usando Neural Compute Stick y OpenVINO</a></li>
<li><a href="../es436748/index.html">Desarrollar hexapod desde cero (parte 3) - cinemática</a></li>
<li><a href="../es436750/index.html">Análisis de tendencias de YouTube ruso para 2018</a></li>
<li><a href="../es436752/index.html">El pastel es una mentira</a></li>
<li><a href="../es436754/index.html">Q2VKPT: Quake II completamente reescrito con iluminación realista</a></li>
<li><a href="../es436756/index.html">El isomorfismo se apresura al rescate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>