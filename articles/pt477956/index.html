<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐭 🥌 🚌 JavaScript em 3D: uma introdução ao Three.js 💕 🙌 📦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! Apresento a você a tradução do artigo "JavaScript in 3D: a Introduction to Three.js", de Bret Cameron. 

 1. Introdução  
 Three.js é uma fe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript em 3D: uma introdução ao Three.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477956/">  <i>Olá Habr!</i>  <i>Apresento a você a tradução do <a href="https://medium.com/javascript-in-plain-english/javascript-in-3d-an-introduction-to-three-js-780f1e4a2e6d">artigo</a> "JavaScript in 3D: a Introduction to Three.js", de Bret Cameron.</i> <br><br><h2>  1. Introdução </h2> <br>  Three.js é uma ferramenta poderosa.  Ajuda a usar o design 3D em um navegador com desempenho aceitável.  Introdução O Three.js pode ser complicado, especialmente se você nunca mergulhou no mundo da programação 3D antes. <br><br>  Eu tenho alguma experiência básica com o Unity e o mecanismo de jogo em C #, mas ainda assim, muitos dos conceitos são novos para mim.  Cheguei à conclusão de que agora existem muito poucos recursos para desenvolvedores iniciantes, por isso decidi escrever este artigo.  Nele, consideraremos os elementos básicos das cenas Three.js, desde malhas e materiais poligonais até geometria, carregadeiras e muito mais. <br><a name="habracut"></a><br>  No final deste artigo, você terá uma sólida compreensão dos aspectos básicos necessários para adicionar uma dimensão extra ao seu futuro projeto da web. <br><br>  Exemplos de Three.js de <a href="https://threejs.org/examples/">Ben Houston</a> , <a href="https://threejs.org/examples/">Thomas Diewald</a> e <a href="https://threejs.org/examples/">StrykerDoesAnimation</a> . <br><br><h3>  Vetores e contêineres - blocos de construção básicos </h3><br>  Geralmente, existem duas classes principais no Three.js - <i>Vector3</i> e <i>Box3</i> .  Se você é novo no 3D, isso pode parecer um pouco abstrato, mas você os encontrará muitas vezes. <br><br><h3>  Vector3 </h3><br>  A classe 3D mais básica que contém três números: <i>x, ye z</i> .  Os números são as coordenadas de um ponto no espaço 3D ou a direção e o comprimento.  Por exemplo: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Vector3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  A maioria dos construtores no Three.js aceita objetos do tipo <i>Vector3</i> como argumentos de entrada, por exemplo, <i>Box3</i> <br><br><h3>  Box3 </h3><br>  Esta classe representa cuboide (contêiner 3D).  Sua principal tarefa é criar um contêiner em torno de outros objetos - e isso é tudo, o menor cubóide no qual um objeto 3D se ajustará.  Cada <i>Box3 está</i> alinhado sobre os eixos <i>x, ye z.</i>  Um exemplo de como criar um contêiner usando <i>Vector3</i> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vect = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Vector3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> box = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Box3(vect);</code> </pre> <br>  Um exemplo de como criar um contêiner em torno de um objeto 3D existente: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> box = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Box3(); box.setFromObject(object);</code> </pre> <br>  Você pode criar grades sem esse conhecimento aprofundado, mas assim que começar a criar ou alterar seus modelos, essas classes definitivamente serão úteis.  Agora vamos nos afastar das abstrações para coisas mais visíveis. <br><br><h3>  Malha de polígono </h3><br>  No Three.js, o principal elemento visual no palco é o <i>Mesh</i> .  Este é um objeto 3D composto por retângulos triangulares (malha poligonal).  É construído usando dois objetos: <br>  <i>Geometria</i> - determina sua forma, <i>Material</i> - determina a aparência. <br><br>  Suas definições podem parecer um pouco confusas (por exemplo, a classe <i>Geometry</i> pode conter informações sobre cores), mas a principal diferença é exatamente isso. <br><br><h3>  Geometria </h3><br>  Com base na tarefa que você deseja realizar, você pode definir a geometria dentro do Three.js ou importar outra de um arquivo. <br><br>  Usando funções como <i>THREE.TorusKnotGeometry</i> , podemos criar objetos complexos com uma única linha de código.  Chegaremos a isso em breve, mas primeiro considere formas mais simples. <br>  A figura 3D mais simples, cubóide ou contêiner, pode ser especificada pelos parâmetros de <i>largura</i> , <i>altura</i> e <i>profundidade</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.BoxGeometry( <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span> );</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/BretCameron/embed/preview/eYOxYZL" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Para uma esfera, o valor dos parâmetros <i>radius</i> , <i>widthSegments</i> e <i>heightSegments</i> é <i>mínimo</i> .  As duas últimas variáveis ​​indicam quantos triângulos o modelo deve usar para representar a esfera: quanto maior o número, mais suave ele será. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.SphereGeometry( <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span> );</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/BretCameron/embed/preview/KKPJKgQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Se queremos fazer formas nítidas ou triangulares, podemos usar um cone.  Seus argumentos são uma combinação dos argumentos das duas figuras anteriores.  Abaixo, prescrevemos <i>radius</i> , <i>widthSegments</i> e <i>radialSegments</i> . <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.ConeBufferGeometry( <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span> );</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/BretCameron/embed/preview/MWgLWJB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Isso é apenas parte das figuras mais comuns.  O Three.js possui muitas formas dentro da caixa, que podem ser encontradas na documentação.  Neste artigo, veremos formas mais interessantes criadas com base no método <i>TorusKnotGeometry</i> . <br><br>  Por que essas formas têm exatamente a aparência?  Esta questão está além do escopo deste artigo, mas peço que você experimente os valores dos parâmetros, porque você pode obter formas muito interessantes com uma linha de código! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.TorusKnotGeometry(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1.3</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>);</code> </pre> <br>  <a href="https://codepen.io/BretCameron/pen/gOYqORg">https://codepen.io/BretCameron/pen/gOYqORg</a> <br><br><h3>  Materiais </h3><br>  A geometria define a forma dos nossos objetos 3D, mas não a aparência.  Para consertar isso, precisamos de materiais. <br><br>  O Three.js oferece 10 materiais prontos para uso, cada um com suas próprias vantagens e parâmetros personalizáveis.  Consideraremos apenas parte dos mais úteis. <br><br><img src="https://habrastorage.org/webt/7o/1r/av/7o1rav-we2n9_hn6e74l-6ivo6q.png"><br><br><h4>  MalhaNormalMaterial </h4><br>  <i>Útil para início e início rápidos.</i> <br><br>  Começaremos com <i>MeshNormalMaterial</i> , o material multicolorido que usamos nos exemplos acima.  Corresponde aos vetores normais no painel RGB, ou seja, as cores são usadas para determinar a posição do vetor no espaço 3D. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshNormalMaterial();</code> </pre> <br>  Observe que se você deseja alterar a cor do material, pode usar o filtro CSS e alterar a saturação: <pre> <code class="javascript hljs"> filter: hue-rotate(<span class="hljs-number"><span class="hljs-number">90</span></span>deg) .</code> </pre> <br><br>  Na minha experiência, esse material é mais útil para um estrato e lançamento rápidos.  Para maior controle de seus objetos, é melhor usar outra coisa. <br><br><h4>  Meshbasicmaterial </h4><br>  <i>Útil ao exibir apenas o esqueleto.</i> <br><br>  Se você quiser dar uma cor à figura, poderá usar o <i>MeshBasicMaterial</i> apenas se a iluminação não for aplicada.  Achei útil usar esse material para renderizar o esqueleto do modelo.  Para desenhar apenas o esqueleto, você precisa passar <i>{wireframe: true}</i> como parâmetro. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshBasicMaterial({ <span class="hljs-attr"><span class="hljs-attr">wireframe</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-number"><span class="hljs-number">0xdaa520</span></span> });</code> </pre> <br>  A principal desvantagem deste material é que as informações sobre a profundidade do material são completamente perdidas.  Cada material tem a opção de exibir apenas o esqueleto, mas apenas um material resolve o problema de falta de profundidade - <i>MeshDepthMaterial</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/BretCameron/embed/preview/ZEzwERw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h4>  Meshhambertmaterial </h4><br>  <i>Útil para alto desempenho, mas baixa precisão.</i> <br><br>  Este é o primeiro material que leva em consideração a luz, então você precisa adicionar um pouco de luz à nossa cena.  No código abaixo, adicionamos holofotes com uma tonalidade amarela para criar um efeito mais quente. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> scene = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Scene(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> frontSpot = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.SpotLight(<span class="hljs-number"><span class="hljs-number">0xeeeece</span></span>); frontSpot.position.set(<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); scene.add(frontSpot); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> frontSpot2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.SpotLight(<span class="hljs-number"><span class="hljs-number">0xddddce</span></span>); frontSpot2.position.set(<span class="hljs-number"><span class="hljs-number">-500</span></span>, <span class="hljs-number"><span class="hljs-number">-500</span></span>, <span class="hljs-number"><span class="hljs-number">-500</span></span>); scene.add(frontSpot2);</code> </pre> <br>  Agora adicione material para a nossa figura.  Como nossa figura é como uma decoração, sugiro adicionar uma cor mais dourada.  Outro parâmetro, <i>emissivo</i> , é a cor do objeto proveniente do próprio objeto (sem fonte de luz).  Geralmente isso funciona melhor como uma cor escura - por exemplo, como tons escuros de cinza, como no exemplo abaixo <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshLambertMaterial({ <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-number"><span class="hljs-number">0xdaa520</span></span>, <span class="hljs-attr"><span class="hljs-attr">emissive</span></span>: <span class="hljs-number"><span class="hljs-number">0x111111</span></span>, });</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/BretCameron/embed/preview/OJLdJGz" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Como você pode ver no exemplo abaixo, a cor é mais ou menos correta, mas a maneira como interage com a luz não adiciona realismo.  Para corrigir isso, precisamos usar o <i>MeshPhongMaterial</i> ou o <i>MeshStandardMaterial.</i> <br><br><h4>  MeshPhongMaterial </h4><br>  <i>Útil para desempenho médio e precisão média.</i> <br><br>  Esse material oferece uma troca entre desempenho e precisão de renderização, portanto, este material é uma boa opção para um aplicativo que precisa ser produtivo junto com uma renderização mais precisa do que com o <i>MeshLambertMaterial.</i> <br><br>  Agora podemos alterar a propriedade <i>especular</i> que afeta o brilho e a cor da reflexão da superfície.  Se a propriedade emissiva é geralmente escura, o <i>especular</i> funciona melhor para cores claras.  Abaixo usamos cinza claro. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshPhongMaterial({ <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-number"><span class="hljs-number">0xdaa520</span></span>, <span class="hljs-attr"><span class="hljs-attr">emissive</span></span>: <span class="hljs-number"><span class="hljs-number">0x000000</span></span>, <span class="hljs-attr"><span class="hljs-attr">specular</span></span>: <span class="hljs-number"><span class="hljs-number">0xbcbcbc</span></span>, });</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/BretCameron/embed/preview/YzKBwwQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Visualmente, a imagem de cima reflete a luz de forma mais convincente, mas ainda não perfeita.  A luz branca é muito brilhante e o material parece mais estriado do que metálico (e nos esforçamos para isso).  Podemos obter um resultado melhor usando o <i>MeshStandardMaterial.</i> <br><br><h4>  MeshStandartMaterial </h4><br>  <i>Útil para alta precisão, mas baixa produtividade.</i> <br><br>  Este é o material mais preciso de todos, embora seu uso acarrete os custos do uso de mais energia.  <i>MeshStandartMaterial é</i> usado com parâmetros adicionais de <i>metalicidade</i> e <i>rugosidade</i> , cada um com valor entre 0 e 1. <br><br>  O parâmetro <i>metalness</i> afeta como o objeto reflete, aproximando-se da natureza do metal.  Isso ocorre porque materiais condutores como metais têm diferentes propriedades refletivas, diferentemente dos dielétricos, como a cerâmica. <br><br>  <i>A rugosidade</i> adiciona uma camada extra para personalização.  Você pode imaginar isso como o oposto do brilho: 0 - muito brilhante, 1 - muito fosco. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshStandardMaterial({ <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-number"><span class="hljs-number">0xfcc742</span></span>, <span class="hljs-attr"><span class="hljs-attr">emissive</span></span>: <span class="hljs-number"><span class="hljs-number">0x111111</span></span>, <span class="hljs-attr"><span class="hljs-attr">specular</span></span>: <span class="hljs-number"><span class="hljs-number">0xffffff</span></span>, <span class="hljs-attr"><span class="hljs-attr">metalness</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">roughness</span></span>: <span class="hljs-number"><span class="hljs-number">0.55</span></span>, });</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://codepen.io/BretCameron/embed/preview/gOYqPMv" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Este é o material mais realista de todos os apresentados em Three.js, mas também o que consome mais recursos <br><br>  Os materiais que discutimos abaixo são os que encontrei com mais frequência e você pode ver todas as opções no banco dos réus. <br><br><h3>  Carregadeiras </h3><br>  Como discutimos acima, você pode definir manualmente malhas de geometria e polígono.  Na prática, as pessoas frequentemente carregam suas geometrias a partir de arquivos.  Felizmente, o Three.js possui poucos downloads que suportam muitos formatos 3D. <br><br>  O <i>ObjectLoader</i> principal carrega o arquivo JSON usando o formato <i>JSON Object / Scene</i> .  A maioria dos gerenciadores de inicialização precisa ser importada manualmente.  Você pode encontrar uma lista completa dos gerenciadores de inicialização suportados aqui e importá-los.  Abaixo está uma pequena lista do que você pode importar. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// GLTF import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'; // OBJ import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js'; // STL import { STLLoader } from 'three/examples/jsm/loaders/STLLoader.js'; // FBX import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js'; // 3MF import { 3MFLoader } from 'three/examples/jsm/loaders/3MFLoader.js';</span></span></code> </pre> <br>  O formato recomendado para visualização on-line é GLTF, porque o formato é "destinado a fornecer ativos em tempo de execução, compacto para transferência e rápido para download". <br><br>  Obviamente, pode haver muitos motivos para preferir um determinado tipo de arquivo (por exemplo, se a qualidade for uma prioridade ou se for necessária uma precisão para a impressão 3D).  O melhor desempenho online será ao importar o GLTF. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { GLTFLoader } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'three/examples/jsm/loaders/GLTFLoader.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> model <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../models/sample.gltf'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> loader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GLTFLoader(); loader.load(model, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">geometry</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// if the model is loaded successfully, add it to your scene here }, undefined, function (err) { console.error(err); });</span></span></code> </pre> <br><h3>  Juntando tudo </h3><br>  Uma das razões pelas quais o Three.js pode parecer intimidador é que você pode criar algo do zero com apenas algumas linhas de código.  Em cada exemplo acima, precisávamos criar uma cena e uma câmera.  Para simplificar, mantive esse código fora do escopo da revisão, mas, por enquanto, veremos como ele ficará juntos. <br><br>  A maneira como você organiza seu código é com você.  Em exemplos mais simples, como neste artigo, faz sentido escrever todo o código em um só lugar.  Mas, na prática, é útil separar os elementos individuais para a possibilidade de expandir a base de código e seu gerenciamento. <br><br>  Para simplificar, consideraremos os elementos que são desenhados como um único objeto, portanto, colocaremos todo o código em um arquivo. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Import dependencies import * as THREE from 'three'; import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'; //   const scene = new THREE.Scene(); scene.background = new THREE.Color(0x282c34); //  ,       const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000); camera.position.z = 5; //  ""      const renderer = new THREE.WebGLRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); //   DOM   renderer.domElement   document.getElementById('threejs').appendChild(renderer.domElement); //  ,      DOM  let controls = new OrbitControls(camera, document.getElementById('threejs')); controls.target.set(0, 0, 0); controls.rotateSpeed = 0.5; controls.update(); //  ( )   const geometry = new THREE.TorusKnotGeometry(10, 1.3, 500, 6, 6, 20); //    const material = new THREE.MeshStandardMaterial({ color: 0xfcc742, emissive: 0x111111, specular: 0xffffff, metalness: 1, roughness: 0.55, }); //   ,       const mesh = new THREE.Mesh(geometry, material); mesh.scale.x = 0.1; mesh.scale.y = 0.1; mesh.scale.z = 0.1; scene.add(mesh); //  ,       const frontSpot = new THREE.SpotLight(0xeeeece); const frontSpot2 = new THREE.SpotLight(0xddddce); frontSpot.position.set(1000, 1000, 1000); frontSpot2.position.set(-500, -500, -500); scene.add(frontSpot); scene.add(frontSpot2); //   ,           const animate = function () { requestAnimationFrame(animate); mesh.rotation.x += 0.005; mesh.rotation.y += 0.005; mesh.rotation.z += 0.005; renderer.render(scene, camera); }; //    animate();</span></span></code> </pre> <br><h3>  Preciso usar uma estrutura? </h3><br>  Finalmente, é hora de discutir se o Three.js deve ser usado com sua estrutura favorita?  No momento, há um bom pacote react <i>-three-fiber</i> para o React.  Para usuários do React, há vantagens óbvias em usar um pacote como este - você mantém uma estrutura para trabalhar com componentes que permite reutilizar o código. <br><br>  Para iniciantes, aconselho você a começar com o <i>Vanila JS</i> usual, porque a maioria dos materiais on-line escritos sobre o Three.js se relacionam ao Three.js no Vanila JS.  Com base na minha experiência de aprendizado, isso pode ser confuso e difícil de aprender por meio de um pacote - por exemplo, você terá que converter objetos e métodos Three.js. em componentes e acessórios.  (assim que você aprender o Three.js, poderá usar qualquer pacote). <br><br><h3>  Como adicionar o Three.js à estrutura </h3><br>  O Three.js fornece um objeto HTML (geralmente chamado <i>renderer.domElement</i> ) que pode ser adicionado a qualquer objeto HTML no seu aplicativo.  Por exemplo, se você tem uma <i>div</i> com <i>id = ”threejs”,</i> pode simplesmente incluir o seguinte código no seu código Three.js. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'threejs'</span></span>).appendChild(renderer.domElement);</code> </pre> <br>  Algumas estruturas têm caminhos preferenciais para acessar os nós DOM da árvore.  Por exemplo, <i>ref</i> em React, <i>$ ref</i> em Vue ou <i>ngRef</i> em Angular e parece uma enorme vantagem no contexto do acesso direto aos elementos DOM.  Como exemplo, vejamos uma implementação rápida do React. <br><br><h3>  Estratégia para reagir </h3><br>  Se você usa o React, existe uma maneira de incorporar os arquivos Three.js. em um de seus componentes.  No arquivo <i>ThreeEntryPoint.js</i> , escreveremos o seguinte código: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ThreeEntryPoint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sceneRef</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> renderer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.WebGLRenderer(); <span class="hljs-comment"><span class="hljs-comment">// ... sceneRef.appendChild(renderer.domElement); }</span></span></code> </pre><br>  Exportamos isso como uma função que recebe um argumento: uma referência a um elemento em nosso componente.  Agora podemos criar nosso componente <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ThreeEntryPoint <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./threejs/ThreeEntryPoint'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThreeContainer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ componentDidMount() { ThreeEntryPoint(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;div ref={element =&gt; this.scene = element} /&gt; &lt;/&gt; ); } }</code> </pre> <br>  A função <i>ThreeEntryPoint</i> importada <i>deve</i> ser chamada no método <i>componentDidMount</i> e passar a nova <i>div</i> como argumento usando referências <br>  Como exemplo dessa abordagem em ação, você pode clonar o repositório e tentar você mesmo: <a href="https://github.com/BretCameron/three-js-sample">https://github.com/BretCameron/three-js-sample</a> . <br><br><h2>  Conclusão </h2><br>  Ainda posso falar muito sobre o Three.js, mas espero que este artigo tenha lhe dado informações suficientes para começar a usar essa poderosa tecnologia.  Quando comecei a aprender o Three.js, não consegui encontrar um único recurso como este artigo, por isso espero ter ajudado a tornar essa tecnologia mais acessível para iniciantes. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt477956/">https://habr.com/ru/post/pt477956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt477938/index.html">O mercado de servidores usados ​​na Rússia: tudo começou com a Habr</a></li>
<li><a href="../pt477940/index.html">ORM de benchmarking usado ao criar aplicativos Android</a></li>
<li><a href="../pt477946/index.html">“Cubra suas trilhas e saia para o fim de semana”: como se retirar dos serviços mais populares</a></li>
<li><a href="../pt477950/index.html">A primeira regra do antifraude é não contar a ninguém sobre antifraude</a></li>
<li><a href="../pt477954/index.html">Como as postagens de resposta tornarão a Internet mais inteligente</a></li>
<li><a href="../pt477958/index.html">As 10 principais tendências do novo relatório de tendências de crimes de alta tecnologia e tecnologia 2019/2020 Group-IB</a></li>
<li><a href="../pt477964/index.html">Dois meses desde a ideia até a primeira venda: experiência em equipe Genesis</a></li>
<li><a href="../pt477966/index.html">HolyJS 2019 Moscow através dos olhos do participante</a></li>
<li><a href="../pt477968/index.html">Cair em uma toca de coelho: uma história sobre um erro de reinicialização de um verniz - Parte 1</a></li>
<li><a href="../pt477974/index.html">Vivado: modo Picasso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>