<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëí üë©üèº‚Äçüç≥ üë®üèº‚Äçüíº iOS Mise en r√©seau lorsque l'application n'est pas en cours d'ex√©cution üë¢ üî¶ üë©üèº‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les utilisateurs s'attendent √† ce que le r√©seau fonctionne ¬´comme par magie¬ª et passe inaper√ßu. Cette magie d√©pend des d√©veloppeurs du syst√®me et des ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS Mise en r√©seau lorsque l'application n'est pas en cours d'ex√©cution</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redmadrobot/blog/478566/"><p><img src="https://habrastorage.org/webt/ok/hf/in/okhfincdajhwvcffenwaoaj6wcs.png" alt="image"></p><br><p>  Les utilisateurs s'attendent √† ce que le r√©seau fonctionne ¬´comme par magie¬ª et passe inaper√ßu.  Cette magie d√©pend des d√©veloppeurs du syst√®me et des applications.  Il est difficile d'influencer le syst√®me, nous nous limiterons donc √† l'application. </p><br><p>  Ce sujet est complexe et il existe d'innombrables probl√®mes.  Nous discuterons de ceux que nous avons rencontr√©s au cours des derniers mois.  Je m'excuse tout de suite pour le volume.  Bref, pas du tout, trop de petites choses qui m√©ritent qu'on y pr√™te attention. </p><a name="habracut"></a><br><p>  Pour commencer, parlons de la terminologie. </p><br><p>  Le transfert de donn√©es se produit dans deux directions: </p><br><ul><li>  <em>t√©l√©chargement</em> (t√©l√©chargement, t√©l√©chargement de donn√©es depuis le serveur), </li><li>  <em>t√©l√©chargement</em> (envoi de donn√©es au serveur). </li></ul><br><p>  L'application peut √™tre active, mais peut fonctionner en arri√®re-plan.  Formellement, il a d' <a href="https://developer.apple.com/documentation/uikit/app_and_environment/managing_your_app_s_life_cycle">autres √©tats</a> , mais nous ne sommes int√©ress√©s que par ceux-ci: </p><br><ul><li>  <em>fond</em> (lorsque l'application est minimis√©e), </li><li>  <em>active</em> (lorsque l'application est active, √† l'√©cran). </li></ul><br><p> Mod√®les utiles: <em>rappel</em> , <em>d√©l√©gu√©</em> ( <a href="https://developer.apple.com/documentation/swift/cocoa_design_patterns">Cocoa Design Patterns</a> , √† <a href="https://en.wikipedia.org/wiki/Callback_(computer_programming)">propos du rappel sur Wikipedia</a> ).  Vous devez √©galement savoir <a href="https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started"><code>  URLSession</code></a> (dans l'article, le lien mentionne √©galement le travail en arri√®re-plan avec le r√©seau, mais en passant). </p><br><p>  Tous les exemples sont √©crits dans <a href="https://docs.swift.org/swift-book/">Swift 5</a> , fonctionnent sur iOS 11 et plus r√©cent (test√© sur iOS 11 et 12) et supposent l'utilisation de requ√™tes HTTP r√©guli√®res.  Pour la plupart, tout cela fonctionnera, √† commencer par iOS 9, mais il y a des "nuances". </p><br><h2 id="obschaya-shema-raboty-s-setyu-urlsession">  Le sch√©ma g√©n√©ral de travail avec le r√©seau.  URLSession </h2><br><p>  Travailler avec le r√©seau n'est pas particuli√®rement difficile: </p><br><ul><li>  cr√©er la configuration <a href="https://developer.apple.com/documentation/foundation/urlsessionconfiguration"><code>URLSessionConfiguration</code></a> ; </li><li>  cr√©er une instance de configuration de <a href="https://developer.apple.com/documentation/foundation/urlsession"><code>URLSession</code></a> ; </li><li>  cr√©er une t√¢che (en utilisant <a href="https://developer.apple.com/documentation/foundation/urlsession/1411554-datatask"><code>session.dataTask(‚Ä¶)</code></a> et des m√©thodes similaires); </li><li>  abonnez-vous aux mises √† jour des t√¢ches.  Les mises √† jour viennent de mani√®re asynchrone, elles peuvent venir au <em>d√©l√©gu√©,</em> qui est enregistr√© lors de la cr√©ation de la session, ou elles peuvent venir dans le <em>rappel,</em> qui est cr√©√© lorsque la t√¢che est cr√©√©e; </li><li>  lorsque nous avons vu que la t√¢che est termin√©e, nous revenons √† la logique d'application. </li></ul><br><p>  Un exemple simple ressemble √† ceci: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> session = <span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: .<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> dataTask = session.dataTask(with: url) { data, response, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//     //  callback,    }</span></span></code> </pre> <br><p>  Ce sch√©ma est similaire pour diverses t√¢ches, seules les petites choses changent.  Et tant que nous n'avons pas besoin de continuer √† travailler avec le r√©seau apr√®s que l'utilisateur a ferm√© l'application, tout est relativement simple. </p><br><blockquote>  Je constate tout de suite que m√™me dans ce sc√©nario, il y a beaucoup de choses int√©ressantes.  Parfois, vous devez travailler avec des redirections d√©licates, parfois vous avez besoin d'une autorisation, d'un √©pinglage SSL ou d'un seul coup.  Vous pouvez en lire beaucoup √† ce sujet.  Pour une raison quelconque, travailler avec le r√©seau en arri√®re-plan est beaucoup moins d√©crit. </blockquote><br><h2 id="sozdanie-sessii-dlya-raboty-v-background">  Cr√©ation d'une session pour travailler en arri√®re-plan </h2><br><p>  Quelle est la diff√©rence entre la <em>session URL en</em> arri√®re- <em>plan</em> et la <em>session</em> habituelle?  Il fonctionne en dehors du processus de demande, quelque part √† l'int√©rieur du syst√®me.  Par cons√©quent, il ne "meurt" pas lorsque le processus de demande est termin√©.  Cela s'appelle une session d'arri√®re-plan (ainsi que l'√©tat de l'application, ce qui est un peu d√©routant) et n√©cessite des param√®tres sp√©cifiques.  Par exemple, ceci: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> configuration = <span class="hljs-type"><span class="hljs-type">URLSessionConfiguration</span></span>.background(withIdentifier: <span class="hljs-string"><span class="hljs-string">"com.my.app"</span></span>) configuration.sessionSendsLaunchEvents = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.isDiscretionary = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.allowsCellularAccess = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.shouldUseExtendedBackgroundIdleMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span> configuration.waitsForConnectivity = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: configuration, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><p>  La configuration a de nombreux autres param√®tres, mais ceux-ci se rapportent directement aux sessions d'arri√®re-plan: </p><br><ul><li>  <em>l'identifiant</em> (pass√© dans l'initialiseur) est une cha√Æne utilis√©e pour faire correspondre les sessions d'arri√®re-plan au red√©marrage de l'application.  Si l'application red√©marre et que vous cr√©ez une session d'arri√®re-plan avec un identifiant d√©j√† utilis√© dans une autre session d'arri√®re-plan, la nouvelle aura acc√®s aux t√¢ches de la pr√©c√©dente.  La conclusion de cela est simple.  Pour un fonctionnement correct, vous avez besoin que cet identifiant soit unique pour votre application et permanent (vous pouvez utiliser, par exemple, un d√©riv√© des applications <em>bundleId</em> ); </li><li>  <em>sessionSendsLaunchEvents</em> indique si la session d'arri√®re-plan doit d√©marrer l'application une fois le transfert de donn√©es termin√©.  Si ce param√®tre est d√©fini sur <code>false,</code> le d√©clencheur ne se produira pas et l'application recevra tous les √©v√©nements la prochaine fois qu'elle se lancera.  Si le param√®tre est <code>true</code> , une fois le transfert de donn√©es termin√©, le syst√®me lance l'application et appelle la m√©thode <code>AppDelegate: application(_:handleEventsForBackgroundURLSession:completionHandler:)</code> correspondante <code>AppDelegate: application(_:handleEventsForBackgroundURLSession:completionHandler:)</code> ; </li><li>  <em>isDiscretionary</em> permet au syst√®me de planifier des t√¢ches plus rarement.  Cela, d'une part, am√©liore la dur√©e de vie de la batterie et, d'autre part, cela peut ralentir la t√¢che.  Ou peut-√™tre l'acc√©l√©rer.  Par exemple, si un grand volume est t√©l√©charg√©, le syst√®me pourra suspendre la t√¢che jusqu'√† ce qu'il se connecte au WiFi, puis t√©l√©charger rapidement tout sans d√©penser Internet mobile lent (si cela est autoris√©, quelle est la prochaine).  Si la t√¢che est cr√©√©e alors que l'application est d√©j√† en arri√®re-plan, ce param√®tre est automatiquement d√©fini sur <code>true</code> ; </li><li>  <em>permetCellularAccess</em> - un param√®tre qui montre que vous pouvez utiliser la communication cellulaire pour travailler avec le r√©seau.  Je n'ai pas jou√© avec lui avec soin, mais selon les critiques, il y a (avec un commutateur de syst√®me similaire) un grand nombre de r√¢teaux; </li><li>  <em>shouldUseExtendedBackgroundIdleMode.</em>  Un param√®tre utile qui montre que le syst√®me doit maintenir une connexion avec le serveur plus longtemps lorsque l'application passe en arri√®re-plan.  Sinon, la connexion sera rompue. </li><li>  <em>waitsForConnectivity</em> Dans un appareil mobile, les communications peuvent dispara√Ætre pendant de courtes p√©riodes.  Les t√¢ches cr√©√©es √† ce moment peuvent soit √™tre suspendues jusqu'√† ce qu'une connexion apparaisse, soit renvoyer imm√©diatement une erreur ¬´pas de connexion¬ª.  Le param√®tre vous permet de contr√¥ler ce comportement.  Si elle est <code>false,</code> en l'absence de communication, la t√¢che s'arr√™tera imm√©diatement avec une erreur.  Si <code>true</code> , attendez qu'un lien apparaisse. </li><li>  la derni√®re ligne (initialiseur de session) contient un param√®tre important, <em>delegate.</em>  √Ä propos de lui - un peu plus. </li></ul><br><h3 id="delegate-vs-callbacks">  D√©l√©gu√© vs rappels </h3><br><p>  Comme je l'ai dit ci-dessus, il existe deux fa√ßons d'obtenir des √©v√©nements √† partir d'une t√¢che / d'une session.  Le premier est le <em>rappel:</em> </p><br><pre> <code class="swift hljs">session.dataTask(with: request) { data, response, error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ...   }</code> </pre> <br><p>  Dans ce cas, l'√©v√©nement de fin de t√¢che sera envoy√© √† la fermeture, o√π vous devez v√©rifier s'il y a une erreur, ce qui est dans la r√©ponse et quelles donn√©es sont arriv√©es. </p><br><p>  La deuxi√®me option pour travailler avec une session consiste √† <em>d√©l√©guer.</em>  Dans ce cas, nous devons cr√©er une classe qui impl√©mente les protocoles <a href="https://developer.apple.com/documentation/foundation/urlsessiondatadelegate"><code>URLSessionDataDelegate</code></a> et (ou) d'autres √† proximit√© (pour diff√©rents types de t√¢ches, les protocoles sont l√©g√®rement diff√©rents).  Une r√©f√©rence √† une instance de cette classe se trouve dans une session et ses m√©thodes sont appel√©es lorsque des √©v√©nements sont transmis au d√©l√©gu√©.  Le lien peut √™tre enregistr√© dans la session par l'initialiseur.  Dans l'exemple, <code>self.</code> </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">URLSession</span></span>(configuration: configuration, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, delegateQueue: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br><p>  Pour les sessions r√©guli√®res, les deux m√©thodes sont disponibles.  Les sessions d'arri√®re-plan ne peuvent √™tre utilis√©es que par un d√©l√©gu√©. </p><br><p>  Donc, nous avons configur√© la session, l'avons cr√©√©e, regardons comment t√©l√©charger quelque chose. </p><br><h2 id="obschaya-shema-skachivaniya-dannyh-v-fone">  Sch√©ma g√©n√©ral de t√©l√©chargement des donn√©es en arri√®re-plan </h2><br><p>  Pour t√©l√©charger des donn√©es, vous devez g√©n√©ralement former une <a href="https://developer.apple.com/documentation/foundation/urlrequest"><code> (URLRequest)</code></a> , y enregistrer les param√®tres / en-t√™tes / donn√©es n√©cessaires, cr√©er une <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask"><code>URLSessionDownloadTask</code></a> et l'ex√©cuter pour ex√©cution.  Quelque chose comme √ßa: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">//  request,   let task = session.downloadTask(with: request) if #available(iOS 11, *) { task.countOfBytesClientExpectsToSend = [approximate size of request] task.countOfBytesClientExpectsToReceive = [approximate size of response] } task.resume()</span></span></code> </pre> <br><p>  √Ä ce stade, rien n'est tr√®s diff√©rent de la t√¢che de t√©l√©chargement habituelle.  Certes, deux param√®tres <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1411534-countofbytesexpectedtosend">sont apparus countOfBytesClientExpectsToSend</a> / <a href="https://developer.apple.com/documentation/foundation/urlsessiontask/1410663-countofbytesexpectedtoreceive">countOfBytesClientExpectsToReceive</a> , ils montrent la quantit√© de donn√©es que nous pr√©voyons d'envoyer dans la demande et de revenir dans la r√©ponse.  Cela est n√©cessaire pour que le syst√®me puisse mieux planifier le travail avec la t√¢che, le t√©l√©charger plus rapidement, sans surcharger.  Ces valeurs n'ont pas besoin d'√™tre pr√©cises. </p><br><p>  Apr√®s <code>resume()</code> t√¢che ira √† l'ex√©cution.  Pendant le transfert de donn√©es, les progr√®s seront transmis (√† ce sujet - lire ci-dessous, il y a aussi des options l√†-bas), et apr√®s l'ach√®vement, plusieurs m√©thodes de d√©l√©gu√© seront ex√©cut√©es.  Parmi eux, il y en a un tr√®s important: </p><br><pre> <code class="swift hljs">urlSession(<span class="hljs-number"><span class="hljs-number">_</span></span>:downloadTask:didFinishDownloadingTo:)</code> </pre> <br><p>  Le fait est que le t√©l√©chargement a lieu dans un fichier temporaire, apr√®s quoi l'application a la possibilit√© de d√©placer ce fichier quelque part ou de faire autre chose avec.  Ce fichier temporaire n'est disponible qu'√† l'int√©rieur de cette m√©thode, apr√®s en √™tre sorti, le fichier est supprim√© et rien ne peut √™tre fait avec. </p><br><p>  Apr√®s cette m√©thode importante, une autre m√©thode sera appel√©e o√π l'erreur tombera si elle se produit.  S'il n'y a pas d' <code>error</code> , l' <code>error</code> sera <code>nil.</code> </p><br><pre> <code class="swift hljs">urlSession(<span class="hljs-number"><span class="hljs-number">_</span></span>:task:didCompleteWithError:)</code> </pre> <br><p>  Et que se passe-t-il √† la fin, si la demande est pass√©e en arri√®re-plan ou a √©t√© compl√©t√©e?  Comment appeler des m√©thodes de d√©l√©gu√©?  Ce n'est pas facile ici. </p><br><p>  Si le t√©l√©chargement de quelque chose qui a √©t√© lanc√© par l'application est termin√© et que l'indicateur <code>sessionSendsLaunchEvents</code> dans la configuration de la session, le syst√®me lancera l'application (en arri√®re-plan) et appellera l' <a href="https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622941-application%3Flanguage%3Dobjc">application (_: handleEventsForBackgroundURLSession: ach√®vementHandler :)</a> dans <code>AppDelegate,</code> . </p><br><p>  Dans cette m√©thode, l'application doit: </p><br><ul><li>  save <code>completionHandler</code> (il devra √™tre appel√© apr√®s un certain temps, de mani√®re asynchrone et dans le thread principal); </li><li>  recr√©er une session d'arri√®re-plan avec le m√™me identifiant que pr√©c√©demment (et qui est pass√©e √† cette m√©thode en cas de plusieurs sessions d'arri√®re-plan); </li><li>  dans une session nouvellement cr√©√©e, les √©v√©nements arriveront au d√©l√©gu√© (en particulier, la tr√®s importante <code>urlSession(_:downloadTask:didFinishDownloadingTo:)</code> ), vous devez les traiter, copier les fichiers o√π vous voulez; </li><li>  Une fois toutes les m√©thodes appel√©es, une autre m√©thode d√©l√©gu√©e est appel√©e, appel√©e <code>urlSessionDidFinishEvents(forBackgroundURLSession:)</code> et dans laquelle vous devrez appeler le <code>completionHandler.</code> stock√© pr√©c√©demment <code>completionHandler.</code> </li></ul><br><blockquote>  C'est important.  Il est n√©cessaire d'appeler <code>completionHandler</code> dans le thread principal √† l'aide de <a href="https://developer.apple.com/documentation/dispatch/dispatchqueue/1781006-main"><code>DispatchQueue.main.async(...)</code></a> . </blockquote><p>  Dans le m√™me temps, vous devez vous rappeler que tout cela se produit dans une application qui fonctionne en arri√®re-plan.  Et cela signifie que les ressources (temps d'ex√©cution) sont limit√©es.  Enregistrez rapidement les fichiers l√† o√π vous en avez besoin, modifiez les √©tats n√©cessaires dans l'application et arr√™tez - c'est √† peu pr√®s tout ce qui peut √™tre fait.  Si vous voulez en faire plus, vous pouvez utiliser <a href="https://developer.apple.com/documentation/uikit/uiapplication/1623031-beginbackgroundtask"><code>UIApplication.beginBackgroundTask()</code></a> ou les nouveaux <a href="https://developer.apple.com/documentation/backgroundtasks">BackgroundTasks</a> . </p><br><h2 id="obschaya-shema-fonovoy-otpravki-dannyh">  Sch√©ma g√©n√©ral d'envoi des donn√©es de base </h2><br><p>  Le t√©l√©chargement de fichiers sur le serveur fonctionne √©galement avec des restrictions.  Cependant, tout commence de la m√™me mani√®re: nous <a href="https://developer.apple.com/documentation/foundation/urlsessionuploadtask"><code>URLSessionUploadTask)</code></a> une demande, cr√©ons une t√¢che (maintenant ce sera <a href="https://developer.apple.com/documentation/foundation/urlsessionuploadtask"><code>URLSessionUploadTask)</code></a> , <a href="https://developer.apple.com/documentation/foundation/urlsessionuploadtask"><code>URLSessionUploadTask)</code></a> la t√¢che.  Quel est le probl√®me? </p><br><p>  Le probl√®me est de savoir comment nous cr√©ons la demande.  Habituellement, nous formons les donn√©es envoy√©es en tant que <code>Data</code> .  <code>URLSession,</code> arri√®re- <code>URLSession,</code> ne sait pas comment travailler avec cela.  Et avec une demande de streaming ( <code>uploadTask(withStreamedRequest:)</code> ) ne sait pas non plus comment.  Il est n√©cessaire d'√©crire tout ce qui doit √™tre envoy√© dans un fichier et de cr√©er une t√¢che d'envoi √† partir du fichier.  Cela se r√©v√®le en quelque sorte comme ceci: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileUrl = methodThatSavesFileAndRetursItsUrl(...) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = session.uploadTask(with: request, fromFile: fileUrl) task.resume()</code> </pre> <br><p>  Mais il n'est pas n√©cessaire d'enregistrer la taille, <code>URLSession</code> peut la consulter elle-m√™me.  Apr√®s l'envoi, la m√™me m√©thode d√©l√©gu√©e <code>urlSession(_:task:didCompleteWithError:)</code> comme lors du t√©l√©chargement.  Et tout comme cela, si l'application a √©t√© supprim√©e ou est pass√©e en arri√®re-plan pendant le processus d'envoi, l' <code>application(_:handleEventsForBackgroundURLSession:completionHandler:),</code> arrivera <code>application(_:handleEventsForBackgroundURLSession:completionHandler:),</code> qui doit √™tre trait√©e exactement selon les m√™mes r√®gles que lors du t√©l√©chargement des donn√©es. </p><br><h2 id="chto-takoe-prilozhenie-zaversheno">  Qu'est-ce qu'une demande compl√®te? </h2><br><p>  Pour tester les t√©l√©chargements et les envois en arri√®re-plan, vous devez simuler l'ach√®vement de l'application (le travail en arri√®re-plan avec le r√©seau est sp√©cialement con√ßu pour y survivre).  Comment faire  Initialement - aucun moyen.  Autrement dit, il n'y a pas de m√©thode r√©guli√®re (autoris√©e, publique) qui permettrait cela.  Voyons o√π est le r√¢teau. </p><br><ul><li>  Tout d'abord, la fermeture de l'application (en appuyant sur le bouton Accueil ou en faisant un geste appropri√©) ne fonctionnera pas.  Cela ne tuera pas l'application, mais l'enverra uniquement en arri√®re-plan.  Le fait de travailler avec une session en arri√®re-plan signifie que cela fonctionne m√™me si l'application est "compl√®tement, compl√®tement" supprim√©e; </li><li>  deuxi√®mement, il est impossible qu'un d√©bogueur (AppCode, Xcode ou simplement LLDB) soit connect√©, il ne laissera pas l'application mourir m√™me un certain temps apr√®s sa "fermeture"; </li><li>  troisi√®mement, vous ne pouvez pas tuer l'application depuis la barre des t√¢ches (gestionnaire de t√¢ches, double accueil ou balayage lent "vers le haut").  Ainsi, une application supprim√©e est consid√©r√©e comme √©tant supprim√©e ¬´en permanence¬ª et le syst√®me arr√™te, avec une telle action, les sessions d'arri√®re-plan associ√©es √† l'application; </li><li>  quatri√®mement, vous devez tester ce processus sur un appareil r√©el.  Il n'y a aucun probl√®me de journalisation (voir ci-dessous) et il est plus d√©bogu√©.  On fait valoir que le simulateur devrait √©galement fonctionner comme il se doit.  Mais j'ai remarqu√© des bizarreries inexplicables que je ne peux expliquer qu'avec autre chose que le simulateur.  En g√©n√©ral, testez sur l'appareil; </li><li>  la seule fa√ßon raisonnable de faire ce que vous voulez est avec la fonction <code>exit(int)</code> .  Comme tout le monde le sait, vous ne pouvez pas le t√©l√©charger sur le serveur ( <a href="https://developer.apple.com/library/archive/qa/qa1561">cela contredit directement les exigences</a> ), mais pour l'instant nous ne faisons que tester - ce n'est pas effrayant.  Je connais deux options raisonnables pour utiliser cette fonction: <br><ul><li>  l'appeler automatiquement dans la <code>AppDelegate.applicationDidEnterBackground(_:)</code> afin que l'application soit <code>AppDelegate.applicationDidEnterBackground(_:)</code> imm√©diatement apr√®s sa sortie dans le Springboard; </li><li>  cr√©er un composant dans l'interface (par exemple un bouton, ou accrocher une action sur un geste), en cliquant sur lequel, la <code>exit(...).</code> <br>  Dans ce cas, l'application sera supprim√©e et le travail en arri√®re-plan avec le r√©seau devrait se poursuivre.  Et, apr√®s un certain temps, nous devrions obtenir un appel √† l' <code>application(_:handleEventsForBackgroundURLSession:completionHandler:).</code> </li></ul></li></ul><br><h2 id="kak-protokolirovat-rabotu-prilozheniya-esli-nelzya-polzovatsya-otladochnoy-konsolyu-xcode">  Comment enregistrer l'application si vous ne pouvez pas utiliser la console de d√©bogage Xcode? </h2><br><p>  Eh bien, c'est impossible.  Vous pouvez, si vous le voulez vraiment.  Vous ne pouvez pas d√©marrer √† partir de Xcode, et si l'application, par exemple, a d√©j√† red√©marr√© en raison d'un √©v√©nement syst√®me, vous pouvez attacher (attacher au processus) √† l'application et retirer la file d'attente.  Mais cette solution est moyenne, vous devez en quelque sorte tester le processus de red√©marrage lui-m√™me. </p><br><p>  Vous pouvez utiliser des <a href="https://en.wikipedia.org/wiki/Log_file">protocoles (journaux, journaux)</a> .  Il existe plusieurs options pour leur mise en ≈ìuvre: </p><br><ul><li> <a href="https://developer.apple.com/documentation/swift/1541053-print"><code>print.</code></a>  Il est souvent utilis√© comme ¬´sortons quelque chose rapidement¬ª.  Dans notre cas, il est impossible √† utiliser, puisque nous n'avons pas acc√®s √† la console sur l'appareil, l'application est tu√©e. </li><li> <a href="https://developer.apple.com/documentation/foundation/1409759-nslog"><code>NSLog.</code></a>  Cela fonctionnera, car il utilise la troisi√®me m√©thode. </li><li> <a href="https://developer.apple.com/documentation/os/logging"><code>os_log.</code></a>  La m√©thode la plus correcte qui vous permet de configurer correctement les journaux, de les fixer avec le type souhait√©, de les d√©sactiver apr√®s le d√©bogage, sans couper le code lui-m√™me, etc. </li></ul><br><blockquote>  Attention!  Avec <code>os_log</code> il y a des probl√®mes (par exemple, le manque de journaux de d√©bogage) qui sont lus uniquement dans le simulateur, mais pas lus sur cet appareil.  Utilisez l'appareil. </blockquote><p>  Comment utiliser <code>os_log,</code> lisez comment le configurer correctement dans la <a href="https://developer.apple.com/documentation/os/logging">documentation Apple</a> .  En particulier, vous devez activer les journaux de <code>debug</code> et d' <code>info</code> , par d√©faut, ils sont masqu√©s. </p><br><h2 id="otslezhivanie-progressa-skachivaniya-ili-otpravki-dannyh">  Suivi de la progression du t√©l√©chargement ou de l'envoi de donn√©es </h2><br><p>  Dans le processus de transfert de donn√©es, je veux comprendre combien a d√©j√† √©t√© envoy√©, combien il en reste.  Il y a deux fa√ßons de proc√©der.  La premi√®re consiste √† utiliser des m√©thodes d√©l√©gu√©es: </p><br><ul><li>  pour envoyer, vous devez utiliser <code>urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:)</code> </li><li>  il existe une m√©thode <code>urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)</code> similaire pour le t√©l√©chargement <code>urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)</code> </li></ul><br><p>  Ces m√©thodes sont appel√©es chaque fois que la prochaine donn√©e est t√©l√©charg√©e ou envoy√©e.  Ils ne sont pas n√©cessairement coh√©rents avec les m√©thodes d'ach√®vement du processus, ils peuvent √©galement √™tre appel√©s apr√®s que les donn√©es ont √©t√© compl√®tement t√©l√©charg√©es ou envoy√©es, il est donc impossible de d√©terminer que ¬´tout est termin√©¬ª. </p><br><p>  La deuxi√®me m√©thode est plus int√©ressante.  Le fait est que chaque t√¢che fournit un objet de type <a href="https://developer.apple.com/documentation/foundation/progress"><code>Progress</code></a> (il se trouve dans le champ <code>task.progress</code> ), qui permet de surveiller un processus arbitraire, y compris le processus de transfert de donn√©es.  En quoi est-il int√©ressant?  Deux choses: </p><br><ul><li>  √† partir des objets <code>Progress</code> , vous pouvez cr√©er une arborescence d'ex√©cution des t√¢ches, dont chaque n≈ìud montrera √† quel point toutes les t√¢ches qu'il contient sont avanc√©es.  Par exemple, si vous devez envoyer cinq fichiers, vous pouvez prendre la progression pour chacun, faire des progr√®s g√©n√©raux, en ajouter cinq autres et surveiller la progression d'un parent, en liant ses mises √† jour √† un √©l√©ment d'interface; </li><li>  vous pouvez ajouter votre progression √† cette arborescence et vous pouvez √©galement suspendre et annuler les actions associ√©es √† la progression ajout√©e. </li></ul><br><p>  Quel est le lien avec le t√©l√©chargement ou l'envoi de donn√©es en arri√®re-plan?  Pas question.  Les m√©thodes d√©l√©gu√©es ne sont pas appel√©es et les objets progress meurent √† la fin de l'application.  Pour les sessions d'arri√®re-plan, cette m√©thode ne convient pas. </p><br><h2 id="peredacha-zadach-iz-obychnoy-sessii-v-background-sessiyu">  "Transf√©rer" des t√¢ches d'une session ordinaire √† une session d'arri√®re-plan </h2><br><p>  Eh bien, il est plus difficile de travailler avec une session d'arri√®re-plan.  Mais c'est pratique!  Aucune t√¢che ne sera perdue, obtiendrons-nous jamais toutes les donn√©es demand√©es, pourquoi ne pas toujours utiliser la session d'arri√®re-plan? </p><br><p>  Malheureusement, elle a des d√©fauts et des d√©fauts graves.  Par exemple, une session d'arri√®re-plan est plus lente.  Dans mes exp√©riences, la vitesse a vari√© plusieurs fois.  Deuxi√®mement, l'ex√©cution en arri√®re-plan d'une t√¢che peut √™tre retard√©e (surtout si le param√®tre <code>isDiscretionary</code> est <code>isDiscretionary</code> , ce qui, comme je l'ai mentionn√©, est toujours <code>true</code> pour les t√¢ches cr√©√©es pendant que l'application s'ex√©cute en arri√®re-plan. </p><br><p>  Par cons√©quent, chaque fois que vous cr√©ez une t√¢che, vous devez comprendre exactement quels crit√®res pour son travail, o√π l'ajouter, √† une session r√©guli√®re ou d'arri√®re-plan.  Normal fonctionne plus vite, d√©marre imm√©diatement.  Contexte - plus long, pas imm√©diatement, mais ne sera pas tu√© si l'utilisateur ferme l'application. </p><br><p>  S'il n'y a pas de compr√©hension √©vidente que la t√¢che doit √™tre effectu√©e dans la session d'arri√®re-plan (par exemple, le transfert non critique d'une tr√®s grande quantit√© de donn√©es, comme la synchronisation ou la sauvegarde), alors cela vaut la peine de proc√©der comme suit: </p><br><ul><li>  d√©marrer la t√¢che dans une session r√©guli√®re.  Dans ce cas, ex√©cutez <em>backgroundTask</em> pour que le syst√®me comprenne que nous avons besoin de temps pour terminer la t√¢che.  Cela donne un certain temps (jusqu'√† plusieurs minutes, mais quelque chose a √©t√© cass√© dans iOS 13 et on ne sait pas ce qui se passe avec) pour que la t√¢che puisse √™tre termin√©e. </li><li>  s'il n'a pas le temps, √† la fin de <em>backgroundTask, nous</em> transf√©rons la t√¢che d'une session ordinaire √† une session en arri√®re-plan, o√π elle continue de fonctionner et se termine quand elle le peut. </li></ul><br><p>  Comment transf√©rer?  Pas question.  Il suffit de tuer (annuler) la t√¢che habituelle et de cr√©er un arri√®re-plan similaire (avec la m√™me demande).  Pourquoi cela s'appelle-t-il un ¬´transfert¬ª?  Et pourquoi entre guillemets? </p><br><p>  Il n'y a pas de transfert pour envoyer des donn√©es.  Il y a exactement ce qui est d√©crit.  Ils ont tu√© une t√¢che, lanc√© une autre, toutes les donn√©es envoy√©es pour la premi√®re fois ont √©t√© perdues. </p><br><p>  Pour le t√©l√©chargement, la situation est diff√©rente.  Le syst√®me sait dans quel fichier la demande est t√©l√©charg√©e.  Si vous ex√©cutez plusieurs t√¢ches pour t√©l√©charger la m√™me URL, par exemple, il n'ex√©cutera pas la demande plusieurs fois.  Les donn√©es sont t√©l√©charg√©es une fois, apr√®s quoi la derni√®re m√©thode d√©l√©gu√©e (ou rappel) sera ex√©cut√©e plusieurs fois.  <a href="https://medium.com/%40sdrzn/handling-multiple-urlsession-tasks-efficiently-91c0957a7d77">Une exp√©rience est d√©crite ici</a> qui confirme cela.  Tr√®s probablement, la mise en cache HTTP standard est utilis√©e √† l'int√©rieur, la m√™me que dans les navigateurs. </p><br><p>  Voici un exemple de code qui fait cela: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = foregroundSession.downloadTask(with: request) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> backgroundId = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.beginBackgroundTask { task.cancel() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = backgroundSession.downloadTask(with: request) task.resume() } task.resume()</code> </pre> <br><p>  Si la t√¢che se termine avant l' <code>expirationHandler</code> fonctionne, vous devez vous rappeler d'appeler <code>UIApplication.shared.endBackgroundTask(backgroundId)</code> .  Ceci est d√©crit plus en d√©tail dans la <a href="https://developer.apple.com/documentation/uikit/uiapplication/1623031-beginbackgroundtask">documentation</a> . </p><br><p>  Pour aider le syst√®me √† continuer le t√©l√©chargement (par exemple, l'annulation peut entra√Æner la suppression du fichier temporaire avant la reprise du t√©l√©chargement en arri√®re-plan), il existe des m√©thodes sp√©ciales: </p><br><ul><li>  pour obtenir les donn√©es n√©cessaires au renouvellement, vous devez annuler la t√¢che pr√©c√©dente √† l'aide de la m√©thode d' <a href="https://developer.apple.com/documentation/foundation/urlsessiondownloadtask/1411634-cancel">annulation (byProducingResumeData :)</a> ; </li><li>   ,    : <a href="https://developer.apple.com/documentation/foundation/urlsession/1409226-downloadtask">downloadTask(withResumeData:) -&gt; URLSessionDownloadTask</a> ,   - : </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">URLRequest</span></span>(url: url) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task = foregroundSession.downloadTask(with: request) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> backgroundId = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.beginBackgroundTask { task.cancel { data <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> task: <span class="hljs-type"><span class="hljs-type">URLSessionDownloadTask</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = data { task = backgroundSession.downloadTask(withResumeData: data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { task = backgroundSession.downloadTask(with: request) } task.resume() } }</code> </pre> <br><h2 id="grabli-na-kotorye-ya-nastupil"> ,     </h2><br><h3 id="logi">  Journaux </h3><br><p>       ‚Äî  ,  .   ‚Äî  ,    .  background    ,    . </p><br><p> ,  ,  background     -,       ,      ,          (   UI,      ). , ,    ‚Äî .     ,   ‚Äî ,  ,  <code>os_log.</code> ( <code>NSLog)</code> </p><br><h3 id="priostanovka-biznes-logiki">  - </h3><br><p>        -  ,         .         ,     -  .    ,      ,   ,      ( )     . ,    ,      -,  ,  .     ‚Äî       ‚Äî ,    .   ‚Äî  ,       -  ( ),       ,      . </p><br><h3 id="testirovanie-na-ustroystve">    </h3><br><p>     .            (  ),    .  ,      ,    ,       . </p><br><h3 id="ogranicheniya">  Limitations </h3><br><p>    : </p><br><ul><li>   ,  ; </li><li>  ‚Äî  ,    ; </li><li>        ,     (,    ‚Ä¶); </li></ul><br><h3 id="melochi">  </h3><br><ul><li>        ,    <code>(task.taskIdentifier)</code>  ,     (Dictionary).    ,          1,   . </li><li>   , <code>URLSession.getAllTasks</code> .    ,        background .  ,    .   ,    . ¬Ø\_(„ÉÑ)_/¬Ø </li><li>   ,  ,         ,    ,     . </li></ul><br><p>       ,      background ,      .      ,      -    .      : <a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html">https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW1</a> .   , : </p><br><blockquote> If your app extension initiates a background NSURLSession task, you must also set up a shared container that both the extension and its containing app can access. Use the sharedContainerIdentifier property of the NSURLSessionConfiguration class to specify an identifier for the shared container so that you can access it later. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr478566/">https://habr.com/ru/post/fr478566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr478550/index.html">Comment g√©rer une montre? Analyse de la piste front-end du deuxi√®me championnat de programmation</a></li>
<li><a href="../fr478552/index.html">Deuxi√®me applet, fermeture et boutons transparents dans Processing 3</a></li>
<li><a href="../fr478554/index.html">Webinaire "SRE - battage m√©diatique ou l'avenir?" 12 d√©cembre √† 11h00</a></li>
<li><a href="../fr478560/index.html">Les messageries instantan√©es gratuites sont-elles anonymes?</a></li>
<li><a href="../fr478564/index.html">Comment nous, chez TsIAN, avons dompt√© des t√©raoctets de journaux</a></li>
<li><a href="../fr478572/index.html">Bot sur les r√©seaux de neurones: comment fonctionne et apprend un assistant virtuel</a></li>
<li><a href="../fr478574/index.html">La v√©rit√© sur les freins ferroviaires: Partie 4 - Freins pour passagers</a></li>
<li><a href="../fr478580/index.html">Comment la puce graphique Super Nintendo a fonctionn√©: Guide Super PPU</a></li>
<li><a href="../fr478582/index.html">Rapport VPN mondial sur les appareils mobiles en 2019</a></li>
<li><a href="../fr478584/index.html">JVM Internals, Part 2 - Class File Structure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>