<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔄 🧤 🧗🏾 功能思维。 第三部分 🧝 🔅 💅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="有关函数式编程的系列文章的第三部分已经提出。 今天，我们将讨论这种范例的所有类型，并展示其用法示例。 有关原始类型，广义类型的更多信息，以及更多内容！ 





- 第一部分 
- 第二部分 
- 第三部分 
- 第四部分 


 现在我们对功能有了一些了解，我们将看到类型如何与功能（例如域和范围...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>功能思维。 第三部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/422115/"><p> 有关函数式编程的系列文章的第三部分已经提出。 今天，我们将讨论这种范例的所有类型，并展示其用法示例。 有关原始类型，广义类型的更多信息，以及更多内容！ </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"><a name="habracut"></a></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第三部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第四部分</a></strong> </li></ul><br><p> 现在我们对功能有了一些了解，我们将看到类型如何与功能（例如域和范围）交互。 本文只是一篇评论。 为了更深入地浸入类型，有一系列<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“了解F＃类型”</a> 。 </p><br><p>首先，我们需要更好地了解类型符号。 我们看到箭头符号“ <code>-&gt;</code> ”将域和范围分开。 因此，函数签名始终如下所示： </p><br><pre> <code class="plaintext hljs">val functionName : domain -&gt; range</code> </pre> <br><p> 其他一些功能示例： </p><br><pre> <code class="plaintext hljs">let intToString x = sprintf "x is %i" x //  int  string let stringToInt x = System.Int32.Parse(x)</code> </pre> <br><p> 如果在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">交互式窗口中</a>执行此代码，则可以看到以下签名： </p><br><pre> <code class="plaintext hljs">val intToString : int -&gt; string val stringToInt : string -&gt; int</code> </pre> <br><p> 他们的意思是： </p><br><ul><li>  <code>intToString</code>具有类型为<code>int</code>的域，该域映射到<code>string</code>类型的范围。 </li><li>  <code>stringToInt</code>具有<code>string</code>类型的域，该域映射到<code>int</code>类型的范围。 </li></ul><br><h2> 原始类型 </h2><br><p> 预期的基本类型为：字符串，整数，浮点型，布尔型，字符型，字节型，以及.NET类型系统的许多其他派生类。 </p><br><p> 带有基本类型的函数的更多示例： </p><br><pre> <code class="plaintext hljs">let intToFloat x = float x // "float" -  int  float let intToBool x = (x = 2) // true  x  2 let stringToString x = x + " world"</code> </pre> <br><p> 及其签名： </p><br><pre> <code class="plaintext hljs">val intToFloat : int -&gt; float val intToBool : int -&gt; bool val stringToString : string -&gt; string</code> </pre> <br><h2> 类型注释 </h2><br><p> 在前面的示例中，F＃编译器正确定义了参数和结果的类型。 但这并不总是会发生。 如果尝试执行以下代码，则会出现编译错误： </p><br><pre> <code class="plaintext hljs">let stringLength x = x.Length =&gt; error FS0072: Lookup on object of indeterminate type</code> </pre> <br><p> 编译器不知道参数“ x”的类型，因此，它不知道“ Length”是否是有效方法。 在大多数情况下，可以通过将“类型注释”传递给F＃编译器来解决。 然后，他将知道要使用哪种类型。 在固定版本中，我们指示类型“ x”为字符串。 </p><br><pre> <code class="plaintext hljs">let stringLength (x:string) = x.Length</code> </pre> <br><p>  <code>x:string</code>参数周围的花括号很重要。 如果跳过它们，编译器将确定该字符串为返回值！ 也就是说，如下面的示例所示，使用冒号表示返回值的类型。 </p><br><pre> <code class="plaintext hljs">let stringLengthAsInt (x:string) :int = x.Length</code> </pre> <br><p> 我们指出参数<code>x</code>是一个字符串，返回值是一个整数。 </p><br><h2> 函数类型作为参数 </h2><br><p> 以其他函数为参数或返回一个函数的函数称为<strong>高阶函数</strong> （ <strong>高阶函数</strong>有时缩写为HOF）。 它们被用作抽象来尽可能地设置一般行为。 这种功能在F＃中非常常见，大多数标准库都使用它们。 </p><br><p> 考虑函数<code>evalWith5ThenAdd2</code> ，该函数将一个函数作为参数，然后从5计算该函数并将2加到结果中： </p><br><pre> <code class="plaintext hljs">let evalWith5ThenAdd2 fn = fn 5 + 2 //   ,   fn(5) + 2</code> </pre> <br><p> 该函数的签名如下所示： </p><br><pre> <code class="plaintext hljs">val evalWith5ThenAdd2 : (int -&gt; int) -&gt; int</code> </pre> <br><p> 您可以看到domain是<code>(int-&gt;int)</code> ，range是<code>int</code> 。 这是什么意思？ 这意味着输入参数不是一个简单的值，而是从<code>int</code>到<code>int</code>许多函数中的一个函数。 输出值不是函数，而只是<code>int</code> 。 </p><br><p> 让我们尝试： </p><br><pre> <code class="plaintext hljs">let add1 x = x + 1 //  -  (int -&gt; int) evalWith5ThenAdd2 add1 //  </code> </pre> <br><p> 并获得： </p><br><pre> <code class="plaintext hljs">val add1 : int -&gt; int val it : int = 8</code> </pre> <br><p> 正如我们从签名中看到的，“ <code>add1</code> ”是一个将<code>int</code>映射到<code>int</code>的函数。 它是<code>evalWith5ThenAdd2</code>的有效参数，其结果是8。 </p><br><p> 顺便说一句，特殊词“ <code>it</code> ”用于表示最后的计算值，在这种情况下，这是我们等待的结果。 这不是关键字，只是命名约定。 </p><br><p> 另一种情况： </p><br><pre> <code class="plaintext hljs">let times3 x = x * 3 // -  (int -&gt; int) evalWith5ThenAdd2 times3 //  </code> </pre> <br><p> 给出： </p><br><pre> <code class="plaintext hljs">val times3 : int -&gt; int val it : int = 17</code> </pre> <br><p> 从签名可以看出，“ <code>times3</code> ”也是一个将<code>int</code>映射到<code>int</code>的函数。 这也是<code>evalWith5ThenAdd2</code>的有效参数。 计算结果为17。 </p><br><p> 请注意，输入数据是类型敏感的。 如果传递的函数使用<code>float</code>而不是<code>int</code> ，则将无济于事。 例如，如果我们有： </p><br><pre> <code class="plaintext hljs">let times3float x = x * 3.0 // -  (float-&gt;float) evalWith5ThenAdd2 times3float</code> </pre> <br><p> 尝试进行编译时，编译器将返回错误： </p><br><pre> <code class="plaintext hljs">error FS0001: Type mismatch. Expecting a int -&gt; int but given a float -&gt; float</code> </pre> <br><p> 报告输入函数必须是<code>int-&gt;int</code>类型的函数。 </p><br><h3> 用作输出 </h3><br><p> 值函数也可以是函数的结果。 例如，以下函数将生成一个“加法器”函数，该函数将添加一个输入值。 </p><br><pre> <code class="plaintext hljs">let adderGenerator numberToAdd = (+) numberToAdd</code> </pre> <br><p> 她的签名： </p><br><pre> <code class="plaintext hljs">val adderGenerator : int -&gt; (int -&gt; int)</code> </pre> <br><p> 表示生成器采用一个<code>int</code>并创建一个将<code>ints</code>映射到<code>ints</code>的函数（“加法器”）。 让我们看看它是如何工作的： </p><br><pre> <code class="plaintext hljs">let add1 = adderGenerator 1 let add2 = adderGenerator 2</code> </pre> <br><p> 创建了两个加法器功能。 第一个创建一个将输入加1的函数，第二个创建一个加2的函数。请注意，签名正是我们所期望的。 </p><br><pre> <code class="plaintext hljs">val add1 : (int -&gt; int) val add2 : (int -&gt; int)</code> </pre> <br><p> 现在您可以照常使用生成的函数，它们与显式定义的函数没有什么不同： </p><br><pre> <code class="plaintext hljs">add1 5 // val it : int = 6 add2 5 // val it : int = 7</code> </pre> <br><h3> 使用类型注释来限制函数类型 </h3><br><p> 在第一个示例中，我们看了一个函数： </p><br><pre> <code class="plaintext hljs">let evalWith5ThenAdd2 fn = fn 5 +2 &gt; val evalWith5ThenAdd2 : (int -&gt; int) -&gt; int</code> </pre> <br><p> 在此示例中，F＃可以得出结论，“ <code>fn</code> ”将<code>int</code>转换为<code>int</code> ，因此其签名为<code>int-&gt;int</code> 。 </p><br><p> 但是在以下情况下“ fn”的签名是什么？ </p><br><pre> <code class="plaintext hljs">let evalWith5 fn = fn 5</code> </pre> <br><p> 显然，“ <code>fn</code> ”是一种需要<code>int</code>的函数，但是它返回什么呢？ 编译器无法回答此问题。 在这种情况下，如果有必要指示函数的类型，则可以为函数参数以及原始类型添​​加注释类型。 </p><br><pre> <code class="plaintext hljs">let evalWith5AsInt (fn:int-&gt;int) = fn 5 let evalWith5AsFloat (fn:int-&gt;float) = fn 5</code> </pre> <br><p> 此外，您可以确定返回类型。 </p><br><pre> <code class="plaintext hljs">let evalWith5AsString fn :string = fn 5</code> </pre> <br><p> 因为 主函数返回<code>string</code> ，函数“ <code>fn</code> ”也被强制返回<code>string</code> 。 因此，没有必要明确指定类型“ <code>fn</code> ”。 </p><br><h2> 输入“单位” </h2><br><p> 在编程过程中，有时我们希望函数执行某些操作而不返回任何内容。 考虑函数“ <code>printInt</code> ”。 该函数实际上什么也不返回。 它只是将字符串打印到控制台，这是执行的副作用。 </p><br><pre> <code class="plaintext hljs">let printInt x = printf "x is %i" x //   </code> </pre> <br><p> 她的签名是什么？ </p><br><pre> <code class="plaintext hljs">val printInt : int -&gt; unit</code> </pre> <br><p> 什么是“ <code>unit</code> ”？ </p><br><p> 即使该函数不返回值，它仍然需要范围。 在数学世界中没有“无效”函数。 每个函数必须返回某些内容，因为该函数是一个映射，并且该映射必须显示某些内容！ </p><br><p><img src="https://habrastorage.org/webt/3_/vt/vz/3_vtvz11kud3aikskqhciwc_q1a.png"></p><br><p> 因此，在F＃中，像这样的函数会返回一种特殊的结果，称为“ <code>unit</code> ”。 它仅包含一个值，用“ <code>()</code> ”表示。 您可能会认为<code>unit</code>和<code>()</code>分别类似于C＃中的“ void”和“ null”。 但是与它们不同的是， <code>unit</code>是实际类型，而<code>()</code>实际值。 要验证这一点，只需执行以下操作： </p><br><pre> <code class="plaintext hljs">let whatIsThis = ()</code> </pre> <br><p> 将收到以下签名： </p><br><pre> <code class="plaintext hljs">val whatIsThis : unit = ()</code> </pre> <br><p> 表示标签“ <code>whatIsThis</code> ”的类型为<code>unit</code>并与值<code>()</code>关联。 </p><br><p> 现在，回到“ <code>printInt</code> ”签名，我们可以理解该条目的含义： </p><br><pre> <code class="plaintext hljs">val printInt : int -&gt; unit</code> </pre> <br><p> 此签名表明<code>printInt</code>具有<code>int</code>的域，这意味着我们不感兴趣。 </p><br><h3> 没有参数的功能 </h3><br><p> 现在我们了解了<code>unit</code> ，是否可以预测它在不同上下文中的出现？ 例如，尝试创建可重用的函数“ hello world”。 由于没有输入或输出，因此可以期望签名<code>unit -&gt; unit</code> 。 让我们看看： </p><br><pre> <code class="plaintext hljs">let printHello = printf "hello world" //   </code> </pre> <br><p> 结果： </p><br><pre> <code class="plaintext hljs">hello world val printHello : unit = ()</code> </pre> <br><p>  <em>不完全</em>符合我们的预期。 立即输出“ Hello world”，结果不是函数，而是类型unit的简单值。 我们可以说这是一个简单的值，因为正如我们前面所看到的，它具有以下形式的签名： </p><br><pre> <code class="plaintext hljs">val aName: type = constant</code> </pre> <br><p> 在此示例中，我们看到<code>printHello</code>一个<em>简单的value</em> <code>()</code> 。 这不是我们以后可以调用的函数。 </p><br><p>  <code>printInt</code>和<code>printHello</code>什么<code>printHello</code> ？ 在<code>printInt</code>的情况下，直到我们知道参数<code>x</code> <code>printInt</code>值才能确定该值，因此定义是一个函数。 对于<code>printHello</code> ，没有参数，因此可以在右侧定义右侧。 并且它等于<code>()</code>并且具有向控制台输出的形式的副作用。 </p><br><p> 您可以创建一个没有参数的真正的可重用函数，从而强制定义具有一个<code>unit</code>参数： </p><br><pre> <code class="plaintext hljs">let printHelloFn () = printf "hello world" //   </code> </pre> <br><p> 现在她的签名等于： </p><br><pre> <code class="plaintext hljs">val printHelloFn : unit -&gt; unit</code> </pre> <br><p> 并调用它，我们必须将<code>()</code>作为参数传递： </p><br><pre> <code class="plaintext hljs">printHelloFn ()</code> </pre> <br><h3> 使用忽略功能加强单位类型 </h3><br><p> 在某些情况下，编译器需要<code>unit</code>类型并抱怨。 例如，以下两种情况都将导致编译器错误： </p><br><pre> <code class="plaintext hljs">do 1+1 // =&gt; FS0020: This expression should have type 'unit' let something = 2+2 // =&gt; FS0020: This expression should have type 'unit' "hello"</code> </pre> <br><p> 为了在这些情况下提供帮助，有一个特殊的<code>ignore</code>函数，该函数接受任何内容并返回<code>unit</code> 。 该代码的正确版本可能是这样的： </p><br><pre> <code class="plaintext hljs">do (1+1 |&gt; ignore) // ok let something = 2+2 |&gt; ignore // ok "hello"</code> </pre> <br><h2> 通用类型 </h2><br><p> 在大多数情况下，如果函数参数的类型可以是任何类型，则需要对它进行一些说明。  F＃在这种情况下使用.NET泛型。 </p><br><p> 例如，以下函数通过添加一些文本将参数转换为字符串： </p><br><pre> <code class="plaintext hljs">let onAStick x = x.ToString() + " on a stick"</code> </pre> <br><p> 无论什么类型的参数，所有对象都可以在<code>ToString()</code> 。 </p><br><p> 签名： </p><br><pre> <code class="plaintext hljs">val onAStick : 'a -&gt; string</code> </pre> <br><p>  <code>'a</code>是什么类型？ 在F＃中，这是一种指示在编译时未知的泛型类型的方法。  “ a”之前的撇号表示类型是通用的。 等效于C＃中的此签名： </p><br><pre> <code class="plaintext hljs">string onAStick&lt;a&gt;(); //   string OnAStick&lt;TObject&gt;(); // F#-   'a    // C#'-   "TObject"  </code> </pre> <br><p> 应该理解，即使使用泛型类型，此F＃函数仍具有强类型。 它<em>不</em>接受<code>Object</code>类型的参数。 强类型输入是好的，因为它使您可以在编写函数时保持其类型安全。 </p><br><p> 相同的函数用于<code>int</code> ， <code>float</code>和<code>string</code> 。 </p><br><pre> <code class="plaintext hljs">onAStick 22 onAStick 3.14159 onAStick "hello"</code> </pre> <br><p> 如果有两个通用参数，则编译器将为它们提供两个不同的名称： <code>'a</code>代表第一个， <code>'b</code>代表第二个，依此类推。” 例如： </p><br><pre> <code class="plaintext hljs">let concatString xy = x.ToString() + y.ToString()</code> </pre> <br><p> 此签名中将有两种通用类型： <code>'a</code>和<code>'b</code> ： </p><br><pre> <code class="plaintext hljs">val concatString : 'a -&gt; 'b -&gt; string</code> </pre> <br><p> 另一方面，编译器识别何时仅需要一个通用类型。 在以下示例中， <code>x</code>和<code>y</code>必须具有相同的类型： </p><br><pre> <code class="plaintext hljs">let isEqual xy = (x=y)</code> </pre> <br><p> 因此，函数签名对于两个参数具有相同的通用类型： </p><br><pre> <code class="plaintext hljs">val isEqual : 'a -&gt; 'a -&gt; bool</code> </pre> <br><p> 当涉及到列表和其他抽象结构时，通用参数也非常重要，在以下示例中我们将看到很多。 </p><br><h2> 其他种类 </h2><br><p> 到目前为止，仅讨论了基本类型。 这些类型可以通过各种方式组合为更复杂的类型。 它们的完整分析将在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">另一个系列的</a>后面部分中，但与此同时，在这里我们将对其进行简要分析，以便您可以在函数签名中识别它们。 </p><br><ul><li>  <strong>元组</strong> 这是由其他类型组成的一对，三重等。 例如， <code>("hello", 1)</code>是一个基于<code>string</code>和<code>int</code>的元组。 逗号是元组的标志；如果在F＃中的某个地方看到逗号，则几乎可以保证它是元组的一部分。 <br> 在函数签名中，元组被写为所涉及的两种类型的“产品”。 在这种情况下，元组将是以下类型： </li></ul><br><pre> <code class="plaintext hljs">string * int // ("hello", 1)</code> </pre> <br><ul><li>  <strong>集合</strong> 。 最常见的是列表（列表），序列（序列）和数组。 列表和数组的大小是固定的，而序列可能是无限的（在幕后，序列是相同的<code>IEnumrable</code> ）。 在函数签名中，它们具有自己的关键字：“ <code>list</code> ”，“ <code>seq</code> ”和“ <code>[]</code> ”表示数组。 </li></ul><br><pre> <code class="plaintext hljs">int list // List type  [1;2;3] string list // List type  ["a";"b";"c"] seq&lt;int&gt; // Seq type  seq{1..10} int [] // Array type  [|1;2;3|]</code> </pre> <br><ul><li>  <strong>选项（可选类型）</strong> 。 这是对可能丢失的对象的简单包装。 有两个选项：“ <code>Some</code> （当值存在时）和“ <code>None</code> （当值不存在时）。 在函数签名中，它们具有自己的关键字“ <code>option</code> ”： </li></ul><br><pre> <code class="plaintext hljs">int option // Some 1</code> </pre> <br><ul><li>  <strong>标记的协会（有区别的工会）</strong> 。 它们由其他类型的许多变体构建而成。 我们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“为什么使用F＃？”中</a>看到了一些示例。  。 在函数签名中，它们由类型名称引用；它们没有特殊的关键字。 </li><li>  <strong>记录类型（记录）</strong> 。 类型，如数据库结构或行，一组命名值。 我们还在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“为什么使用F＃？”中</a>看到了一些示例。  。 在函数签名中，它们由类型名称调用，也没有自己的关键字。 </li></ul><br><h2> 测试您对类型的理解 </h2><br><p> 以下是一些表达式，用于测试您对函数签名的理解。 要进行检查，只需在交互式窗口中运行它们即可！ </p><br><pre> <code class="plaintext hljs">let testA = float 2 let testB x = float 2 let testC x = float 2 + x let testD x = x.ToString().Length let testE (x:float) = x.ToString().Length let testF x = printfn "%s" x let testG x = printfn "%f" x let testH = 2 * 2 |&gt; ignore let testI x = 2 * 2 |&gt; ignore let testJ (x:int) = 2 * 2 |&gt; ignore let testK = "hello" let testL() = "hello" let testM x = x=x let testN x = x 1 // :     x? let testO x:string = x 1 // :    :string ?</code> </pre> <br><h1> 其他资源 </h1><br><p>  F＃的教程很多，包括那些具有C＃或Java经验的人的材料。 当您深入了解F＃时，以下链接可能会很有用： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃指南</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃娱乐与利润</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃维基</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Y分钟内学习X：F＃</a> </li></ul><br><p> 还介绍了其他几种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开始学习F＃的方法</a> 。 </p><br><p> 最后，F＃社区非常适合初学者。 在Slack上，由F＃Software Foundation支持的聊天非常活跃，您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以自由加入</a>初学者室。 我们强烈建议您这样做！ </p><br><p> 不要忘记访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语社区F＃的网站</a> ！ 如果您对学习语言有任何疑问，我们将很乐意在聊天室中讨论这些问题： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃软件基金会Slack聊天</a>室中的<code>#ru_general</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">室</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在电报中聊天</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聊天聊天</a> </li></ul><br><h2> 关于翻译作者 </h2><br><p> 由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@kleidemos</em></a>翻译 <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在F＃开发人员</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语社区</a>的努力下进行了翻译和编辑更改。 我们也感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@schvepsss</em></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@shwars</em></a>为本文准备发表。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN422115/">https://habr.com/ru/post/zh-CN422115/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN422099/index.html">大型运营商将通过为小型运营商提供托管服务来赚取“春季法”</a></li>
<li><a href="../zh-CN422103/index.html">为什么程序员应该能够写得很好</a></li>
<li><a href="../zh-CN422107/index.html">扩大开发：从启动到数百名工程师</a></li>
<li><a href="../zh-CN422109/index.html">Firefox默认会阻止用户跟踪</a></li>
<li><a href="../zh-CN422113/index.html">《金融科技摘要》：中央银行将追踪黑客的受害者，俄罗斯人将获得信用等级，雅虎金融和加密交易</a></li>
<li><a href="../zh-CN422119/index.html">独立游戏开发者工具包</a></li>
<li><a href="../zh-CN422121/index.html">如何前往德国学习和研究我的移民实例</a></li>
<li><a href="../zh-CN422123/index.html">如何停止故障并开始进行正常的闪回</a></li>
<li><a href="../zh-CN422125/index.html">SENS诊断。 蛋白质聚集生物标志物</a></li>
<li><a href="../zh-CN422127/index.html">地狱有道理。 有时候</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>