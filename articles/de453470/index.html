<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧🏻 ◀️ 👩🏾‍🚒 Ihre verteilten Monolithen zeichnen hinter Ihnen ❣️ 🚮 🤓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 

 Die heutige Übersetzung berührt nicht nur und nicht so sehr Microservices - ein Thema, das heute jeder auf den Lippen hat -, sondern er...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ihre verteilten Monolithen zeichnen hinter Ihnen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/453470/">  Hallo Habr! <br><br>  Die heutige Übersetzung berührt nicht nur und nicht so sehr Microservices - ein Thema, das heute jeder auf den Lippen hat -, sondern erinnert auch daran, wie wichtig es ist, einen Spaten einen Spaten zu nennen.  Der Übergang zur Microservice-Architektur ist manchmal notwendig, erfordert jedoch, wie der Autor noch einmal betont, eine sorgfältige Abwägung der Folgen.  Viel Spaß und fruchtbares Lesen! <br><br><img src="https://habrastorage.org/webt/im/q8/dr/imq8drim-mkatdxhbytwowus1ik.jpeg"><br><a name="habracut"></a><br>  Von Zeit zu Zeit stelle ich die gleiche Frage. <br><blockquote>  Gibt es eine so wichtige Wahrheit, dass nur wenige mit Ihnen übereinstimmen?  - Peter Thiel </blockquote>  Bevor ich mich für diesen Beitrag hinsetzte, habe ich mich lange mit diesem Thema zu einem Thema beschäftigt, das heute einen ernsthaften Trend aufweist - es geht um Microservices.  Ich denke jetzt habe ich etwas zu erzählen;  Einige Ergebnisse basieren auf Reflexion, andere auf praktischen Erfahrungen.  Also, ich sage es dir. <br>  Beginnen wir mit einer wichtigen Wahrheit, die uns auf dem Weg wie ein Polarstern als Bezugspunkt dienen wird. <br><br>  Die meisten Microservice-Implementierungen sind nichts anderes als verteilte Monolithen. <br><br><h4>  Ära der Monolithen </h4><br>  Jedes System begann als monolithische Anwendung.  Ich werde hier nicht auf Details dieses Themas eingehen - viele haben bereits über viele geschrieben.  Der Löwenanteil der Informationen über Monolithen ist jedoch Themen wie Entwicklerproduktivität und Skalierbarkeit gewidmet, während das wertvollste Kapital eines Internetunternehmens in den Klammern bleibt: Daten. <br><br><img src="https://habrastorage.org/webt/83/75/yh/8375yhxrmoq8jmhfl-wz97u7slg.png"><br><br>  <i>Typische monolithische Anwendungsarchitektur</i> <br><br>  Wenn Daten so wichtig sind, warum wird dann allen anderen Themen alle Aufmerksamkeit geschenkt, aber nicht ihnen?  Die Antwort ist im Allgemeinen einfach: Weil sie nicht so schmerzhaft sind wie die Datenfrage. <br>  Vielleicht ist der Monolith die einzige Phase im Lebenszyklus des Systems, in der Sie: <br><br><ul><li>  Verstehen Sie Ihr Datenmodell vollständig. </li><li>  Sie können mit Daten zusammenarbeiten (es wird davon ausgegangen, dass Ihre Datenbank für Ihre Anwendung korrekt ausgewählt ist). </li></ul><br>  In Bezug auf die Daten ist der Monolith ideal.  Und da Daten das wertvollste Kapital eines Unternehmens sind, ist es besser, den Monolithen nicht zu zerbrechen, es sei denn, Sie haben einen sehr guten Grund oder eine Kombination solcher Gründe.  In den meisten Fällen ist der entscheidende Grund für diese Art die Notwendigkeit der Skalierung (da wir in der realen Welt mit ihren inhärenten physischen Einschränkungen leben). <br><br>  Wenn dieser Moment eintrifft, geht Ihr System höchstwahrscheinlich in eine neue Hypostase über: Es <b>verwandelt sich in einen verteilten Monolithen</b> . <br><br><h4>  Die Ära der verteilten Monolithen </h4><br>  Nehmen wir an, in Ihrem Unternehmen läuft es gut und die Anwendung muss wachsen.  Sie haben immer mehr große Kunden, und Ihre Anforderungen an die Abrechnung und Berichterstellung haben sich sowohl hinsichtlich einer Reihe von Möglichkeiten als auch hinsichtlich ihres Volumens geändert. <br><br>  Wenn Sie sich ernsthaft mit dem Abriss des Monolithen befassen, werden Sie versuchen, zwei kleine Dienste zu implementieren, von denen einer die Berichterstattung und der zweite die Abrechnung ermöglicht.  Diese neuen Dienste werden höchstwahrscheinlich eine HTTP-API bereitstellen und über eine dedizierte Datenbank für die langfristige Speicherung des Status verfügen.  Nach vielen Commits erhalten Sie, wie wir bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unbabel</a> , möglicherweise etwas, das der folgenden Abbildung ähnelt. <br><br><img src="https://habrastorage.org/webt/lg/js/9g/lgjs9grnmyupckoplo0to5q-kjm.png"><br><br>  <i>Eine allgemeine Ansicht der Systemarchitektur nach dem Trennen von Abrechnungs- und Berichterstellungsdiensten von der monolithischen Hauptanwendung</i> <br><br>  Alles läuft nach Plan. <br><br><ul><li>  Das Team teilt den Monolithen weiterhin in kleinere Systeme auf. </li><li>  Kontinuierliche Integrations- / Lieferförderer arbeiten wie am Schnürchen. </li><li>  Kubernetes Cluster ist gesund, Ingenieure sind produktiv und mit allem zufrieden. </li></ul><br>  Das Leben ist schön. <br><br>  Aber was ist, wenn ich sage, dass gerade abscheuliche Verschwörungen gegen Sie weben? <br><br>  Wenn Sie sich nun Ihr System ansehen, werden Sie feststellen, dass die Daten auf viele verschiedene Systeme verteilt wurden.  Sie haben mit der Phase begonnen, in der Sie eine eindeutige Datenbank hatten, in der alle Datenobjekte gespeichert waren, und jetzt haben sich Ihre Datenobjekte an verschiedenen Orten ausgebreitet.  Vielleicht denken Sie, dass es kein Problem gibt, da Microservices erforderlich sind, um Abstraktionen zu erstellen und Daten zu versiegeln, wodurch die interne Komplexität des Systems verborgen bleibt. <br><br>  Du hast absolut recht.  Mit zunehmender Größe treten jedoch komplexere Probleme auf: Jetzt müssen Sie zu jedem Zeitpunkt die Geschäftsanforderungen erfüllen (z. B. um eine Metrik zu verfolgen) und müssen auf Daten zugreifen, die sich in mehr als einem System befinden. <br><br>  Was tun?  In der Tat gibt es viele Möglichkeiten.  Aber in Eile müssen Sie auch eine große Anzahl von Kunden bedienen, die sich kürzlich bei Ihnen registriert haben, damit Sie ein Gleichgewicht zwischen „schnell“ und „gut“ finden können.  Nachdem Sie die Details besprochen haben, beschließen Sie, ein zusätzliches System zu erstellen, das eine bestimmte ETL-Arbeit ausführt und zur Lösung der endgültigen Aufgaben beiträgt.  Dieses System muss Zugriff auf alle gelesenen Replikate haben, die die benötigten Informationen enthalten.  Die folgende Abbildung zeigt, wie ein solches System funktionieren könnte. <br><br><img src="https://habrastorage.org/webt/76/op/x0/76opx0yinpcv5fbxh9x8sais2hm.png"><br><br>  <i>Ein verallgemeinertes Beispiel für ein analytisches ETL-System (in Unbabel haben wir es Automatic Translation Analytics genannt)</i> <br><br>  Bei Unbabel haben wir diesen Ansatz verwendet, da: <br><br><ul><li>  Die Leistung jedes Mikrodienstes wird dadurch nicht zu stark beeinträchtigt. </li><li>  Es sind keine größeren Infrastrukturänderungen erforderlich (fügen Sie einfach einen neuen Microservice hinzu). </li><li>  Wir konnten unsere Geschäftsanforderungen schnell genug erfüllen. </li></ul><br>  Die Erfahrung zeigt, dass dieser Ansatz für einige Zeit funktionieren wird - bis ein bestimmtes Ausmaß erreicht ist.  Bei Unbabel hat er uns bis vor kurzem sehr gute Dienste geleistet, als wir uns immer ernsteren Herausforderungen stellten.  Hier sind einige Dinge, die uns Kopfschmerzen bereiteten: <br><br>  <b>1. Datenänderungen</b> <br><br>  Einer der Hauptvorteile von Microservices ist die Einkapselung.  Die interne Darstellung der Daten kann sich ändern, hat jedoch keine Auswirkungen auf die Clients des Systems, da diese über eine externe API kommunizieren.  Unsere Strategie erforderte jedoch einen direkten Zugriff auf die interne Darstellung der Daten. Sobald das Team nur einige Änderungen an der Darstellung der Daten vorgenommen hat (z. B. ein Feld umbenennen oder den Typ von <code>text</code> in UUID ändern), mussten wir auch unsere ETL- ändern und erneut bereitstellen. Service. <br><br>  <b>2. Die Notwendigkeit, viele verschiedene Datenschemata zu verarbeiten</b> <br><br>  Da die Anzahl der Systeme, mit denen wir uns verbinden mussten, zunahm, mussten wir uns mit immer heterogeneren Darstellungsweisen für Daten befassen.  Es war offensichtlich, dass wir nicht alle diese Schemata, die Beziehungen zwischen ihnen und ihren Darstellungen skalieren konnten. <br><br>  <i><b>Die Wurzel allen Übels</b></i> <br><br>  Um ein vollständiges Bild davon zu bekommen, was im System passiert, mussten wir bei einem Ansatz anhalten, der einem Monolithen ähnelt.  Der ganze Unterschied bestand darin, dass wir nicht ein System und eine Datenbank hatten, sondern Dutzende solcher Paare, jedes mit seiner eigenen Datendarstellung;  Darüber hinaus wurden in einigen Fällen dieselben Daten auf mehreren Systemen repliziert. <br><br>  Ich nenne ein solches System lieber einen verteilten Monolithen.  Warum?  Da es für die Verfolgung von Änderungen im System völlig ungeeignet ist, besteht die einzige Möglichkeit, den Status des Systems anzuzeigen, darin, einen Dienst zu erfassen, der eine direkte Verbindung zu den Data Warehouses aller Microservices herstellt.  Es ist interessant zu sehen, wie viele Kolosse des Internets zu einem bestimmten Zeitpunkt ihrer Entwicklung ebenfalls vor ähnlichen Herausforderungen standen.  Ein gutes Beispiel in diesem Fall, das ich immer gerne gebe, ist das LinkedIn-Netzwerk. <br><br><img src="https://habrastorage.org/webt/bx/zv/l8/bxzvl8oaw7htdnldzu7fr3toxdm.png"><br><br>  <i>Dies ist die Art von Datenunglück, das die Informationsflüsse von Linkedin um 2011 herum darstellten - Quelle</i> <br><br>  Im Moment wundern Sie sich vielleicht: "Was werdet ihr mit all dem machen?"  Die Antwort ist einfach: Sie müssen Änderungen verfolgen und wichtige Aktionen verfolgen, sobald sie stattfinden. <br><br>  <b>Brechen Sie einen verteilten Monolithen mithilfe von Event Sourcing</b> <br><br>  Wie praktisch der Rest der Welt reagieren Systeme im Internet.  Eine Anforderung an die API kann daher zum Einfügen eines neuen Datensatzes in die Datenbank führen.  Derzeit stören uns solche Details in den meisten Fällen nicht, da wir hauptsächlich daran interessiert sind, den Status der Datenbank zu aktualisieren.  Das Aktualisieren des Status einer Datenbank ist eine bedingte Folge eines Ereignisses (in diesem Fall einer API-Anforderung).  Das Ereignisphänomen ist einfach und dennoch ist das Potenzial von Ereignissen sehr groß - sie können sogar zur Zerstörung eines verteilten Monolithen verwendet werden. <br><br>  <b>Ein Ereignis ist nichts anderes als eine unveränderliche Tatsache einer Änderung, die in Ihrem System aufgetreten ist</b> .  In der Microservice-Architektur werden Ereignisse kritisch und helfen, Datenströme zu verstehen und auf ihrer Grundlage den Gesamtzustand mehrerer Systeme abzuleiten.  Jeder Mikrodienst, der eine Aktion ausführt, die aus Sicht des gesamten Systems interessant ist, sollte ein Ereignis zusammen mit allen wesentlichen Informationen generieren, die sich auf die Tatsache beziehen, dass dieses Ereignis darstellt. <br><br>  Vielleicht haben Sie eine Frage: <br>  "Wie können Microservices, die Ereignisse erzeugen, mir helfen, das Problem des verteilten Monolithen zu lösen?" <br><br>  Wenn Sie Systeme haben, die Ereignisse generieren, gibt es möglicherweise ein Faktenprotokoll mit den folgenden Eigenschaften: <br><br><ul><li>  Keine Bindung an ein Data Warehouse: Ereignisse werden normalerweise in Binärformaten wie JSON, Avro oder Protobufs serialisiert. </li><li>  Unveränderlichkeit: Sobald ein Ereignis generiert wird, kann es nicht mehr geändert werden. </li><li>  Reproduzierbarkeit: Der Zustand des Systems zu einem bestimmten Zeitpunkt kann wiederhergestellt werden.  Dazu reicht es aus, das Ereignisprotokoll erneut abzuspielen. </li></ul><br>  Mit diesem Protokoll können Sie den Status mithilfe einer beliebigen Logik auf Anwendungsebene anzeigen.  Sie sind nicht mehr mit einer Reihe von Mikrodiensten und <i>N</i> Arten der Darstellung der Daten verknüpft.  Die einzige Quelle der Wahrheit und Ihr einziges Data Warehouse ist jetzt das Repository, in dem Ihre Ereignisse gespeichert sind. <br><br>  Hier sind einige Gründe, warum das Ereignisprotokoll für mich der Weg zu sein scheint, um den verteilten Monolithen zu zerstören: <br><br>  <b>1. Die eine Quelle der Wahrheit</b> <br><br>  Anstatt N Datenquellen zu verwalten, die möglicherweise für die Verbindung mit (mehreren) heterogenen Datenbanken erforderlich sind, wird in diesem neuen Szenario die endgültige Wahrheit in genau einem Repository gespeichert: dem Ereignisprotokoll. <br><br>  <b>2. Universelles Datenformat</b> <br><br>  In der vorherigen Version des Systems mussten wir uns mit vielen Datenformaten befassen, da wir direkt mit der Datenbank verbunden waren.  Im neuen Layout können wir viel flexibler handeln. <br><br>  Angenommen, Ihnen hat ein Instagram-Foto gefallen, das von einem Ihrer Freunde gepostet wurde.  Eine solche Aktion kann beschrieben werden: " <i>Benutzer X mochte Bild P</i> ".  Und hier ist eine Veranstaltung, die diese Tatsache darstellt: <br><br><img src="https://habrastorage.org/webt/ff/sp/2x/ffsp2xttqkwolrptkfa3bw66mdc.png"><br><br>  <i>Ein Ereignis, das dem AVO-Ansatz (Actor, Verb, Object) entspricht und die Tatsache simuliert, dass der Benutzer das gewünschte Bild auswählt.</i> <br><br>  <b>3. Schwächung der Kommunikation zwischen Produzenten und Konsumenten</b> <br><br>  Nicht zuletzt ist einer der größten Vorteile des Veranstaltungsbetriebs die effektive Schwächung der Kommunikation zwischen Datenproduzenten und -konsumenten.  Diese Situation vereinfacht nicht nur die Skalierung, sondern verringert auch die Anzahl der Abhängigkeiten zwischen ihnen.  Der einzige Vertrag, der in diesem Fall zwischen den Systemen verbleibt, ist das Ereignisdiagramm. <br><br><hr><br>  Zu Beginn dieses Artikels wurde die Frage gestellt: Gibt es eine so wichtige Wahrheit, in der nur wenige mit Ihnen übereinstimmen? <br><br>  Lassen Sie mich zum Abschluss dieser Exkursion darauf zurückkommen.  Ich glaube, dass die meisten Unternehmen Daten nicht als „erstklassige Entitäten“ betrachten, wenn sie mit der Migration zur Microservice-Architektur beginnen.  Es wird argumentiert, dass alle Datenänderungen weiterhin über die API vorgenommen werden können, aber dieser Ansatz führt letztendlich zu einer ständigen Komplikation des Dienstes selbst. <br><br>  Ich glaube, dass der einzig wahre Ansatz zur Erfassung von Datenänderungen in einer Microservice-Architektur darin besteht, Systeme dazu zu bringen, Ereignisse gemäß einem streng definierten Vertrag zu emittieren.  Mit einem korrekt kompilierten Ereignisprotokoll können Sie viele Daten basierend auf beliebigen Geschäftsanforderungen anzeigen.  In diesem Fall müssen Sie nur unterschiedliche Regeln auf dieselben Fakten anwenden.  In einigen Fällen kann eine solche Datenfragmentierung vermieden werden, wenn Ihr Unternehmen (insbesondere Ihre Produktmanager) die Daten als Produkt behandelt.  Dies ist jedoch ein Thema für einen anderen Artikel. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453470/">https://habr.com/ru/post/de453470/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453458/index.html">Echte reaktive Programmierung in Svelte 3.0</a></li>
<li><a href="../de453460/index.html">Wenn ich das Virtuelle satt habe</a></li>
<li><a href="../de453464/index.html">Quantum Future (Fortsetzung)</a></li>
<li><a href="../de453466/index.html">HolyJS 2019: Nachbesprechung von SEMrush (Teil 2)</a></li>
<li><a href="../de453468/index.html">Die Entwicklung von Java-Webanwendungen</a></li>
<li><a href="../de453472/index.html">Fahrrad vom Energiemonitor PZEM004T und ESP8266 mit People's Monitoring</a></li>
<li><a href="../de453474/index.html">Computersteuerung über Fernbedienung von einem Verstärker mit Arduino und Node.js.</a></li>
<li><a href="../de453478/index.html">Wir untersuchen die Gesundheit der Starlink-Satelliten Ilona Mask</a></li>
<li><a href="../de453482/index.html">Einführung in das Deep Learning mit TensorFlow</a></li>
<li><a href="../de453484/index.html">4-Bit-BCD-Zähler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>