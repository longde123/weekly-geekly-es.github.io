<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌿 🚧 🐶 Bagaimana cara mengajar UITextView agar tampil cantik ☂️ 🗽 👌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pernyataan masalah 
 Diberikan: teks multi-baris. 
 Temukan: latar belakang yang dirancang dengan indah. 

 Ya, satu jam, pikirku. "Anda hanya perlu m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara mengajar UITextView agar tampil cantik</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479992/"><h4>  Pernyataan masalah </h4><br>  Diberikan: teks multi-baris. <br>  Temukan: latar belakang yang dirancang dengan indah. <br><br>  Ya, satu jam, pikirku.  "Anda hanya perlu meletakkan backgroundColor di attributedText."  Tapi itu tidak cukup.  Faktanya adalah bahwa pemilihan standar adalah persegi panjang yang diisi.  Jelek.  Solusinya - Anda perlu kustom!  Jalan berduri penciptaannya mendorong saya untuk menggambarkan proses sehingga generasi masa depan tidak harus terlalu menderita.  Tertarik, saya minta kucing. <a name="habracut"></a><br><br><h4>  Penerimaan </h4><br>  Tindakan pertama adalah panggilan Internet klasik dengan pertanyaan implementasi yang tepat.  Sebagai tanggapan, ada beberapa saran.  Yang paling memadai, semuanya sampai pada metode fillBackgroundRectArray.  Dalam kehidupan normal, ia bertanggung jawab untuk mewarnai teks dengan menggunakan properti attributedText yang disebutkan di atas.  Untuk melihat hewan seperti apa itu, saya mencoba solusi yang sudah jadi dengan harapan tugas itu masih akan berlangsung selama beberapa jam.  Itu tidak berhasil.  Keputusan itu bekerja dengan sangat buruk. <br><br><h4>  Dokumentasi adalah segalanya. </h4><br>  Memutuskan untuk tidak melakukan ini lagi, saya beralih ke dokumentasi.  Dari sini menjadi jelas bahwa UITextView adalah turunan sederhana dari UIScrollView untuk teks yang digerakkan oleh tiga teman: <br><br><ul><li>  NSTextStorage - pada dasarnya pembungkus NSMutableAtributedString, diperlukan untuk menyimpan teks dan atributnya; </li><li>  NSTextContainer - NSObject, bertanggung jawab atas bentuk geometris di mana teks disajikan.  Secara default itu adalah persegi panjang, Anda dapat menyesuaikan apa pun; </li><li>  NSLayoutManager - mengelola dua yang pertama: mengambil teks, indentasi, dibagi menjadi paragraf, dan juga bertanggung jawab atas isi yang kita butuhkan. </li></ul><br><h4>  Algoritma itu keren </h4><br>  Akibatnya, tugas bermuara pada membuat NSLayoutManadger kustom dan mengganti metode yang diinginkan di dalamnya. <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SelectionLayoutManager</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSLayoutManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillBackgroundRectArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rectArray: UnsafePointer&lt;CGRect&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">count</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rectCount: Int, forCharacterRange charRange: NSRange, color: UIColor)</span></span></span></span> { }</code> </pre> <br>  Dalam implementasi utama, fillBackgroundRectArray mendapatkan segi empat kata dan melukisnya.  Karena angka-angka yang disediakan, sebagai suatu peraturan, adalah bagian yang terpisah dari satu garis dengan persimpangan di mana saja, mereka harus ditinggalkan.  Oleh karena itu subtugas kali: tentukan persegi panjang yang benar yang dimulai pada awal baris dan tidak dapat dipisahkan sampai akhir. <br><br>  Metode yang memecahkan masalah ini adalah algoritma berikut: ia berjalan dalam satu lingkaran sesuai dengan paragraf dan memeriksa apakah baris tersebut akan cocok dalam satu baris jika kata berikutnya ditambahkan ke dalamnya?  Jika tidak, maka ini adalah baris penuh yang terpisah, pergi ke yang berikutnya.  Jika demikian, ambil kata berikutnya dan periksa kembali kondisinya.  Ya, implementasinya sangat sederhana, ada ide untuk membuat metode rekursif, tetapi tangan belum mencapai.  Dalam komentar, saya meminta opsi yang dioptimalkan. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detectLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from string: String, width: CGFloat, font: UIFont)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">String</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> strings: [<span class="hljs-type"><span class="hljs-type">String</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cumulativeString = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> words = string.components(separatedBy: <span class="hljs-type"><span class="hljs-type">CharacterSet</span></span>.whitespaces) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> checkingString = cumulativeString + word <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> checkingString.size(withFont: font).width &lt; width { cumulativeString.append(word) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cumulativeString.isNotEmpty { strings.append(cumulativeString) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> word.size(withFont: font).width &lt; width { cumulativeString = word } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stringsFromWord: [<span class="hljs-type"><span class="hljs-type">String</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handlingWord = word <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> handlingWord.isNotEmpty { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fullFillString = detectFullFillString(from: handlingWord, width: width, font: font) stringsFromWord.append(fullFillString) handlingWord = word.replacingOccurrences(of: stringsFromWord.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) { $<span class="hljs-number"><span class="hljs-number">0</span></span> + $<span class="hljs-number"><span class="hljs-number">1</span></span> }, with: <span class="hljs-string"><span class="hljs-string">""</span></span>) } stringsFromWord.removeLast() strings.append(contentsOf: stringsFromWord) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> remainString = word.replacingOccurrences(of: stringsFromWord.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>) { $<span class="hljs-number"><span class="hljs-number">0</span></span> + $<span class="hljs-number"><span class="hljs-number">1</span></span> }, with: <span class="hljs-string"><span class="hljs-string">""</span></span>) cumulativeString = remainString } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cumulativeString.isNotEmpty { strings.append(cumulativeString) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strings }</code> </pre> <br>  Perlu dicatat kasus kata-kata khusus yang dengan sendirinya tidak cocok dalam satu baris.  UITextView bekerja dengan sangat sederhana - mentransfer ke baris berikutnya dari bagian yang tidak termasuk.  Kami menduplikasi logika ini dalam metode terpisah dengan pendekatan yang sama dari bagian berurutan, tetapi dalam hal ini dengan simbol.  Apa yang dikandungnya: baris penuh, sisanya - baik baris penuh, dalam kasus kata yang sangat panjang, atau hanya kata baru di baris baru. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detectFullFillString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from word: String, width: CGFloat, font: UIFont)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> string = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> character <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> word { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> checkingString = string.appending(<span class="hljs-type"><span class="hljs-type">String</span></span>(character)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> checkingString.size(withFont: font).width &gt; width { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { string.append(contentsOf: <span class="hljs-type"><span class="hljs-type">String</span></span>(character)) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> string }</code> </pre> <br>  Sebagai hasil dari metode detectLines (dari: width: font :), kami mendapatkan array string yang dibagi dengan benar di sepanjang baris.  Selanjutnya, dari metode bingkai (untuk garis: lebar: font), kita mendapatkan larik koordinat dan ukuran garis. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frames</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lines: [String], width: CGFloat, font: UIFont)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">CGRect</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rects: [<span class="hljs-type"><span class="hljs-type">CGRect</span></span>] = [] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> stringsSizes = lines.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.size(withFont: font) } stringsSizes.forEach { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rect = <span class="hljs-type"><span class="hljs-type">CGRect</span></span>(origin: <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: (width - $<span class="hljs-number"><span class="hljs-number">0</span></span>.width) / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: $<span class="hljs-number"><span class="hljs-number">0</span></span>.height * <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(rects.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>)), size: $<span class="hljs-number"><span class="hljs-number">0</span></span>) rects.append(rect) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rects }</code> </pre> <br><h4>  Membawa kecantikan </h4><br>  Subtask nomor dua: cat di atas persegi panjang.  Di bawah konsep "indah" seharusnya mengisi warna persegi panjang yang dipilih dengan sudut bulat.  Solusi: menggambar lapisan tambahan pada koordinat yang ditentukan dalam konteks menggunakan UIBezierPath.  Untuk membuat sambungan terlihat lebih baik, kami tidak akan membulatkan tepi persegi panjang, yang lebarnya lebih kecil.  Metodenya sederhana: kita mengikuti koordinat masing-masing persegi panjang dan menggambar kontur. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from rects: [CGRect], cornerRadius: CGFloat, horizontalInset: CGFloat)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">CGPath</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> path = <span class="hljs-type"><span class="hljs-type">CGMutablePath</span></span>() rects.enumerated().forEach { (index, rect) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasPrevious = index &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isPreviousWider = hasPrevious ? rects[index - <span class="hljs-number"><span class="hljs-number">1</span></span>].width &gt;= rect.width || <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(rects[index - <span class="hljs-number"><span class="hljs-number">1</span></span>].width - rect.width) &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasNext = index != rects.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isNextWider = hasNext ? rects[index + <span class="hljs-number"><span class="hljs-number">1</span></span>].width &gt;= rect.width || <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(rects[index + <span class="hljs-number"><span class="hljs-number">1</span></span>].width - rect.width) &lt; <span class="hljs-number"><span class="hljs-number">5</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span> path.move(to: <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: rect.minX - horizontalInset + (isPreviousWider ? <span class="hljs-number"><span class="hljs-number">0</span></span> : cornerRadius), y: rect.minY)) <span class="hljs-comment"><span class="hljs-comment">// top path.addLine(to: CGPoint(x: rect.maxX + horizontalInset - (isPreviousWider ? 0 : cornerRadius), y: rect.minY)) if isPreviousWider == false { path.addQuadCurve(to: CGPoint(x: rect.maxX + horizontalInset, y: rect.minY + cornerRadius), control: CGPoint(x: rect.maxX + horizontalInset, y: rect.minY)) } // right path.addLine(to: CGPoint(x: rect.maxX + horizontalInset, y: rect.maxY - (isNextWider ? 0 : cornerRadius))) if isNextWider == false { path.addQuadCurve(to: CGPoint(x: rect.maxX + horizontalInset - cornerRadius, y: rect.maxY), control: CGPoint(x: rect.maxX + horizontalInset, y: rect.maxY)) } // bottom path.addLine(to: CGPoint(x: rect.minX - horizontalInset + (isNextWider ? 0 : cornerRadius), y: rect.maxY)) if isNextWider == false { path.addQuadCurve(to: CGPoint(x: rect.minX - horizontalInset, y: rect.maxY - cornerRadius), control: CGPoint(x: rect.minX - horizontalInset, y: rect.maxY)) } // left path.addLine(to: CGPoint(x: rect.minX - horizontalInset, y: rect.minY + (isPreviousWider ? 0 : cornerRadius))) if isPreviousWider == false { path.addQuadCurve(to: CGPoint(x: rect.minX - horizontalInset + cornerRadius, y: rect.minY), control: CGPoint(x: rect.minX - horizontalInset, y: rect.minY)) } path.closeSubpath() } return path }</span></span></code> </pre> <br>  Selanjutnya, dalam metode draw (_: color :), isi path. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path: CGPath, color: UIColor)</span></span></span></span> { color.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ctx = <span class="hljs-type"><span class="hljs-type">UIGraphicsGetCurrentContext</span></span>() { ctx.setAllowsAntialiasing(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) ctx.setShouldAntialias(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) ctx.addPath(path) ctx.drawPath(using: .fillStroke) } }</code> </pre> <br>  Kode lengkap metode fillBackgroundRectArray (_: count: forCharacterRange: color :) <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillBackgroundRectArray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rectArray: UnsafePointer&lt;CGRect&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">count</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rectCount: Int, forCharacterRange charRange: NSRange, color: UIColor)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cornerRadius: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> horizontalInset: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> font = (textStorage?.attributes(at: <span class="hljs-number"><span class="hljs-number">0</span></span>, effectiveRange: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).first { $<span class="hljs-number"><span class="hljs-number">0</span></span>.key == .font })?.value <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UIFont</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> textContainerWidth = textContainers.first?.size.width <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">/// Divide the text into paragraphs let lines = paragraphs(from: textStorage?.string ?? "") /// Divide the paragraphs into separate lines let strings = detectLines(from: lines, width: textContainerWidth, font: font) /// Get rects from the lines let rects = frames(for: strings, width: textContainerWidth, font: font) /// Get a contour by rects let rectsPath = path(from: rects, cornerRadius: cornerRadius, horizontalInset: horizontalInset) /// Fill it draw(rectsPath, color: color) }</span></span></code> </pre> <br>  Kita mulai.  Kami periksa.  Bagus sekali. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zi/k3/2p/zik32p4lq1wi3u8hg-my0qzfqfi.gif"></div><br>  Kesimpulannya: adat kadang-kadang sulit dan memuakkan, tetapi betapa indahnya ketika itu berfungsi sebagaimana mestinya.  Cast, ini bagus. <br><br>  Kode lengkap dapat ditemukan di sini <a href="https://github.com/MikhailZimin/SelectionLayoutManager/blob/master/SelectionLayoutManager">SelectionLayoutManager</a> . <br><br><h4>  Referensi </h4><br><ol><li>  <a href="https://developer.apple.com/documentation/uikit/nslayoutmanager">NSLayoutManager</a> </li><li>  <a href="https://developer.apple.com/documentation/uikit/nstextcontainer">NSTextContainer</a> </li><li>  <a href="https://developer.apple.com/documentation/appkit/nstextview">NSTextView</a> </li><li>  <a href="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/CustomTextProcessing/CustomTextProcessing.html">Menggunakan Text Kit untuk Menggambar dan Mengelola Teks</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id479992/">https://habr.com/ru/post/id479992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id479972/index.html">Sejarah Patch Apple</a></li>
<li><a href="../id479974/index.html">Serangan klik-nol: Ketika keamanan Anda tidak sampai pada Anda</a></li>
<li><a href="../id479978/index.html">Seperti tanpa rasa sakit, tanpa captcha dan gratis untuk membawa ekstrak dari Dana Properti Negara Federal dari Daftar Negara Hak Asasi Manusia ke bentuk (*) yang dapat dibaca manusia.</a></li>
<li><a href="../id479982/index.html">Vidos dan serangga</a></li>
<li><a href="../id479988/index.html">Kompetisi teknologi Radiofest-2019. Ringkasan</a></li>
<li><a href="../id479996/index.html">2 nm transistor: apakah Anda memotong atau memotong?</a></li>
<li><a href="../id479998/index.html">Trik Turki dengan cacing, tikus ... dan freelancer</a></li>
<li><a href="../id480000/index.html">Indikator kualitas saluran Server WebRTC melalui TCP</a></li>
<li><a href="../id480002/index.html">Tinjau DevOpsDays Moscow: wawasan dari 6 laporan</a></li>
<li><a href="../id480006/index.html">Indikator kualitas saluran untuk server WebRTC melalui TCP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>