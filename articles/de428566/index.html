<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤰🏿 🥞 🧐 JavaScript-Pfeilfunktionen: Warum werden sie benötigt, wie werden sie behandelt, wann werden sie verwendet und wann nicht? 🧥 ✅ 🏟️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine der bemerkenswertesten Neuerungen des modernen JavaScript ist das Auftreten von Pfeilfunktionen, die manchmal als "fette" Pfeilfunktionen bezeich...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Pfeilfunktionen: Warum werden sie benötigt, wie werden sie behandelt, wann werden sie verwendet und wann nicht?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/428566/"> Eine der bemerkenswertesten Neuerungen des modernen JavaScript ist das Auftreten von Pfeilfunktionen, die manchmal als "fette" Pfeilfunktionen bezeichnet werden.  Bei der Deklaration solcher Funktionen verwenden sie eine spezielle Zeichenkombination - <code>=&gt;</code> . <br><br>  Pfeilfunktionen haben zwei Hauptvorteile gegenüber herkömmlichen Funktionen.  Die erste ist eine sehr praktische und kompakte Syntax.  Das zweite ist, dass der Ansatz, in Pfeilfunktionen damit zu arbeiten, intuitiver aussieht als in normalen Funktionen. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/b1a/09a/721/b1a09a721fe985d3700f4f74305e68d6.jpg" alt="Bild"></a> </div><br>  Manchmal führen diese und andere Vorteile dazu, dass der Pfeilsyntax eine bedingungslose Präferenz gegenüber anderen Arten der Deklaration von Funktionen eingeräumt wird.  Beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erzwingt</a> die beliebte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eslint-Konfiguration</a> von Airbnb, dass eine solche Funktion bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jeder Erstellung</a> einer anonymen Funktion pfeilartig ist. <br><br>  Wie andere Konzepte und Mechanismen, die in der Programmierung verwendet werden, haben Pfeilfunktionen jedoch ihre Vor- und Nachteile.  Ihre Verwendung kann negative Nebenwirkungen verursachen.  Um die Pfeilfunktionen korrekt verwenden zu können, müssen Sie die damit verbundenen möglichen Probleme kennen. <br><br>  Das Material, dessen Übersetzung wir heute veröffentlichen, wird sich auf die Funktionsweise von Pfeilfunktionen konzentrieren.  Hier werden Situationen betrachtet, in denen ihre Verwendung den Code verbessern kann, und Situationen, in denen sie nicht verwendet werden sollten. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Verfügt über Pfeilfunktionen in JavaScript</font> </h2><br>  Pfeilfunktionen in JavaScript sind so etwas wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lambda-Funktionen</a> in Python und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blöcke</a> in Ruby. <br><br>  Dies sind anonyme Funktionen mit einer speziellen Syntax, die eine feste Anzahl von Argumenten annehmen und im Kontext des Bereichs arbeiten, in dem sie enthalten sind, dh im Kontext der Funktion oder des anderen Codes, in dem sie deklariert sind. <br><br>  Lassen Sie uns näher darauf eingehen. <br><br><h3>  <font color="#3AC1EF">▍ Syntaxpfeilfunktionen</font> </h3><br>  Pfeilfunktionen werden nach einem einzigen Schema erstellt, während die Struktur von Funktionen in besonderen Fällen vereinfacht werden kann.  Die Grundstruktur der Pfeilfunktion sieht folgendermaßen aus: <br><br><pre> <code class="hljs php">(argument1, argument2, ... argumentN) =&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br>  Die Liste der Funktionsargumente steht in Klammern, gefolgt von einem Pfeil aus <code>=</code> und <code>&gt;</code> Zeichen. Anschließend wird der Hauptteil der Funktion in geschweiften Klammern angegeben. <br><br>  Dies ist der Funktionsweise gewöhnlicher Funktionen sehr ähnlich. Die Hauptunterschiede bestehen darin, dass das <code>function</code> hier weggelassen wird und nach der Argumentliste ein Pfeil hinzugefügt wird. <br><br>  In bestimmten Fällen können jedoch einfache Pfeilfunktionen mit viel kompakteren Konstruktionen deklariert werden. <br><br>  Berücksichtigen Sie die Syntax, die verwendet wird, wenn der Hauptteil der Funktion durch einen einzelnen Ausdruck dargestellt wird.  Sie können auf geschweifte Klammern verzichten, die den Funktionskörper umrahmen, und müssen die Ergebnisse der Auswertung eines Ausdrucks nicht mehr explizit zurückgeben, da dieses Ergebnis automatisch zurückgegeben wird.  Zum Beispiel könnte es so aussehen: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b;</code> </pre> <br>  Hier ist eine andere Variante der Kurzschreibweise der Funktion, die verwendet wird, wenn die Funktion nur ein Argument hat. <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFirst = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  Wie Sie sehen können, werden die Klammern um die Argumentliste hier weggelassen.  Darüber hinaus wird der Hauptteil der Funktion, der in diesem Beispiel durch einen einzelnen Befehl dargestellt wird, auch ohne Klammern geschrieben.  Später werden wir mehr über die Vorteile solcher Designs sprechen. <br><br><h3>  <font color="#3AC1EF">▍Rückgabe von Objekten und Kurzaufzeichnungspfeilfunktionen</font> </h3><br>  Bei der Arbeit mit Pfeilfunktionen werden auch einige komplexere Syntaxkonstrukte verwendet, die Sie beachten sollten. <br><br>  Versuchen Sie beispielsweise, einen einzeiligen Ausdruck zu verwenden, um von einer Objektliteralfunktion zurückzukehren.  Angesichts dessen, was wir bereits über Pfeilfunktionen wissen, scheint eine Funktionsdeklaration folgendermaßen auszusehen: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-type"><span class="hljs-type">name</span></span>, description) =&gt; {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>, description: description};</code> </pre> <br>  Das Problem mit diesem Code ist seine Mehrdeutigkeit.  Die geschweiften Klammern, mit denen wir das Objektliteral beschreiben möchten, sehen nämlich so aus, als würden wir versuchen, den Körper einer Funktion in sie einzuschließen. <br><br>  Um dem System anzuzeigen, dass wir das Objektliteral meinen, müssen wir es in Klammern setzen: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-type"><span class="hljs-type">name</span></span>, description) =&gt; ({<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>, description: description});</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Pfeilfunktionen und deren Ausführungskontext</font> </h3><br>  Im Gegensatz zu anderen Funktionen haben Pfeilfunktionen keinen eigenen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ausführungskontext</a> . <br><br>  In der Praxis bedeutet dies, dass sie die Entitäten <code>this</code> und die <code>arguments</code> von der übergeordneten Funktion erben. <br><br>  Vergleichen Sie beispielsweise die beiden im folgenden Code dargestellten Funktionen.  Einer von ihnen ist gewöhnlich, der zweite ist Pfeil. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'test object'</span></span>, <span class="hljs-attr"><span class="hljs-attr">createAnonFunction</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name);     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>);   }; }, <span class="hljs-attr"><span class="hljs-attr">createArrowFunction</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name);     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>);   }; } };</code> </pre> <br>  Es gibt ein <code>test</code> mit zwei Methoden.  Jede von ihnen ist eine Funktion, die eine anonyme Funktion erstellt und zurückgibt.  Der Unterschied zwischen diesen Methoden besteht nur darin, dass in der ersten der traditionelle funktionale Ausdruck und in der zweiten Pfeilfunktion verwendet wird. <br><br>  Wenn wir mit diesem Code in der Konsole experimentieren und dieselben Argumente an die Methoden des Objekts übergeben, erhalten wir unterschiedliche Ergebnisse, obwohl die Methoden sehr ähnlich aussehen: <br><br><pre> <code class="hljs cs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anon = test.createAnonFunction(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>); &gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrow = test.createArrowFunction(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>); &gt; anon(); undefined {} &gt; arrow(); test <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-string"><span class="hljs-string">'0'</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-string"><span class="hljs-string">'world'</span></span> }</code> </pre> <br>  Eine anonyme Funktion hat einen eigenen Kontext. Wenn sie aufgerufen wird und <code>test.name</code> , wird der Wert der Eigenschaft <code>name</code> des Objekts nicht <code>test.name</code> . Wenn Sie <code>arguments</code> aufrufen, wird die Liste der Argumente für die Funktion, die zum Erstellen und Zurückgeben der zu untersuchenden Funktion verwendet wurde, nicht angezeigt. <br><br>  Im Fall einer Pfeilfunktion stellt sich heraus, dass ihr Kontext mit dem Kontext der Funktion übereinstimmt, die sie erstellt hat, wodurch sie sowohl auf die Liste der von dieser Funktion übergebenen Argumente als auch auf die <code>name</code> Eigenschaft des Objekts zugreifen kann, für das diese Funktion eine Methode ist. <br><br><h2>  <font color="#3AC1EF">Situationen, in denen Pfeilfunktionen den Code verbessern</font> </h2><br><h3>  <font color="#3AC1EF">▍Verarbeitungslisten von Werten</font> </h3><br>  Herkömmliche Lambda-Funktionen sowie Pfeilfunktionen, nachdem sie in JavaScript angezeigt wurden, werden normalerweise in Situationen verwendet, in denen eine bestimmte Funktion auf jedes Element einer bestimmten Liste angewendet wird. <br><br>  Wenn beispielsweise ein Array von Werten vorhanden ist, die mit der <code>map</code> Arrays-Methode konvertiert werden müssen, ist eine Pfeilfunktion ideal, um eine solche Konvertierung zu beschreiben: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> words = [<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'WORLD'</span></span>, <span class="hljs-string"><span class="hljs-string">'Whatever'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> downcasedWords = words.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word</span></span></span><span class="hljs-function"> =&gt;</span></span> word.toLowerCase());</code> </pre> <br>  Hier ist ein äußerst häufiges Beispiel für die ähnliche Verwendung von Pfeilfunktionen, die darin besteht, mit den Eigenschaften von Objekten zu arbeiten: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names = objects.map(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>);</code> </pre> <br>  Wenn sie anstelle herkömmlicher <code>for</code> Schleifen moderne iteratorbasierte <code>forEach</code> Schleifen verwenden, wird diese Verwendung durch die <code>forEach</code> <code>this</code> übergeordneten Entität intuitiv: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.examples.forEach(example =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.runExample(example); });</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Versprechen und Versprechen Ketten</font> </h3><br>  Eine andere Situation, in der Sie mit Pfeilfunktionen saubereren und verständlicheren Code schreiben können, sind asynchrone Softwarekonstrukte. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Versprechen</a> vereinfachen die Arbeit mit asynchronem Code erheblich.  Selbst wenn Sie das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konstrukt</a> async / await bevorzugen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">, können</a> Sie nicht auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verständnis der Versprechen verzichten</a> , da dieses Konstrukt auf diesen basiert. <br><br>  Wenn Sie jedoch Versprechen verwenden, müssen Sie Funktionen deklarieren, die nach Abschluss des asynchronen Codes oder nach Abschluss des asynchronen Aufrufs einer bestimmten API aufgerufen werden. <br><br>  Dies ist ein idealer Ort, um Pfeilfunktionen zu verwenden, insbesondere wenn die resultierende Funktion einen bestimmten Zustand hat und sich auf etwas im Objekt bezieht.  Zum Beispiel könnte es so aussehen: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomethingAsync().<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storeResult(result); });</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Objekttransformation</font> </h3><br>  Ein weiterer häufiger Anwendungsfall für Pfeilfunktionen ist das Einkapseln von Objekttransformationen. <br><br>  In Vue.js gibt es beispielsweise ein allgemeines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Muster für das</a> direkte Einfügen von Vuex-Speicherfragmenten in eine Vue-Komponente mithilfe von <code>mapState</code> . <br><br>  Diese Operation enthält Deklarationen einer Reihe von "Konvertern", die genau auswählen, was für eine bestimmte Komponente aus dem anfänglichen vollständigen Zustand benötigt wird. <br><br>  Diese einfachen Transformationen sind der perfekte Ort, um Pfeilfunktionen zu verwenden.  Zum Beispiel: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">export</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">computed</span></span>: {   ...<span class="hljs-built_in"><span class="hljs-built_in">mapState</span></span>({     results: state =&gt; state.results,     users: state =&gt; state.users,   }); } }</code> </pre> <br><h2>  <font color="#3AC1EF">Situationen, in denen Pfeilfunktionen nicht verwendet werden sollten</font> </h2><br><h3>  <font color="#3AC1EF">▍ Objektmethoden</font> </h3><br>  Es gibt eine Reihe von Situationen, in denen die Verwendung von Pfeilfunktionen keine gute Idee ist.  Pfeilfunktionen helfen bei geringer Verwendung nicht nur Programmierern, sondern werden auch zu einer Quelle von Problemen. <br><br>  Die erste solche Situation besteht darin, Pfeilfunktionen als Objektmethoden zu verwenden.  Der Ausführungskontext und das <code>this</code> , die für traditionelle Funktionen spezifisch sind, sind hier wichtig. <br><br>  Früher war es beliebt, eine Kombination aus Klasseneigenschaften und Pfeilfunktionen zu verwenden, um Methoden mit "automatischer Bindung" zu erstellen, dh solche, die von Ereignishandlern verwendet werden können, aber an die Klasse gebunden bleiben.  Es sah ungefähr so ​​aus: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span></span>{ counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter++; } }</code> </pre> <br>  Mit einer ähnlichen Konstruktion hatte diese Funktion Zugriff auf die Daten dieser Instanz, auch wenn die <code>handleClick</code> Funktion vom Ereignishandler aufgerufen wurde und nicht im Kontext einer Instanz der <code>Counter</code> Klasse. <br><br>  Dieser Ansatz hat jedoch viele Nachteile, denen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Material</a> gewidmet ist. <br><br>  Obwohl die Verwendung einer Pfeilfunktion hier natürlich eine bequeme Möglichkeit zum Binden einer Funktion darstellt, ist das Verhalten dieser Funktion in vielerlei Hinsicht alles andere als intuitiv und beeinträchtigt das Testen und das Erstellen von Problemen in Situationen, in denen beispielsweise versucht wird, das entsprechende Objekt als Prototyp zu verwenden. <br><br>  Verwenden Sie in solchen Fällen anstelle von Pfeilfunktionen normale Funktionen und binden Sie gegebenenfalls eine Instanz des Objekts im Konstruktor an diese: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Counter <span class="hljs-comment"><span class="hljs-comment">{ counter = 0; handleClick() {   this.counter++; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{   this.handleClick = this.handleClick.bind(this); }</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍Lange Anrufketten</font> </h3><br>  Pfeilfunktionen können zu Problemen führen, wenn sie in vielen verschiedenen Kombinationen verwendet werden sollen, insbesondere in langen Ketten von Funktionsaufrufen. <br><br>  Der Hauptgrund für solche Probleme, wie bei der Verwendung anonymer Funktionen, ist, dass sie äußerst uninformative Ergebnisse der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufrufstapelverfolgung</a> liefern. <br><br>  Dies ist nicht so schlimm, wenn es beispielsweise nur eine Verschachtelungsebene von Funktionsaufrufen gibt, beispielsweise wenn es sich um die im Iterator verwendete Funktion handelt.  Wenn jedoch alle verwendeten Funktionen deklarierte Pfeilfunktionen sind und sich diese Funktionen gegenseitig aufrufen, ist es im Fehlerfall nicht einfach herauszufinden, was passiert.  Die Fehlermeldungen sehen ungefähr so ​​aus: <br><br><pre> <code class="hljs">{anonymous}() {anonymous}() {anonymous}() {anonymous}() {anonymous}()</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Funktionen mit dynamischem Kontext</font> </h3><br>  Die letzte der Situationen, in denen Pfeilfunktionen zu Problemen führen können, besteht darin, sie dort zu verwenden, wo Sie eine dynamische Bindung benötigen. <br><br>  Wenn in solchen Situationen Pfeilfunktionen verwendet werden, funktioniert die Dynamik <code>this</code> Bindung nicht.  Diese unangenehme Überraschung kann dazu führen, dass man sich über die Gründe Gedanken macht, was mit denen passiert, die mit Code arbeiten müssen, in dem die Pfeilfunktionen falsch verwendet werden. <br><br>  Hier sind einige Dinge zu beachten, wenn Sie die Verwendung von Pfeilfunktionen in Betracht ziehen: <br><br><ul><li>  Ereignishandler werden mit <code>this</code> Bindung an das Ereignisattribut <code>currentTarget</code> . </li><li>  Wenn Sie noch jQuery verwenden, beachten Sie, dass die meisten jQuery-Methoden <code>this</code> an das ausgewählte DOM-Element binden. </li><li>  Wenn Sie Vue.js verwenden, binden Methoden und berechnete Funktionen dies normalerweise an die Vue-Komponente. </li></ul><br>  Natürlich können Pfeilfunktionen absichtlich verwendet werden, um das Standardverhalten von Softwaremechanismen zu ändern.  Insbesondere in Fällen mit jQuery und Vue steht dies jedoch häufig im Widerspruch zur normalen Funktionsweise des Systems, was dazu führt, dass der Programmierer nicht verstehen kann, warum ein völlig normaler Code plötzlich nicht mehr funktioniert. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Pfeilfunktionen sind eine wunderbare neue JavaScript-Funktion.  Sie ermöglichen in vielen Situationen das Schreiben von bequemerem Code als zuvor.  Aber wie bei anderen Merkmalen haben sie sowohl Vor- als auch Nachteile.  Daher müssen Sie Pfeilfunktionen verwenden, wenn sie nützlich sein können, ohne sie als vollständigen Ersatz für normale Funktionen zu betrachten. <br><br>  <b>Liebe Leser!</b>  Sind Sie auf Situationen gestoßen, in denen die Verwendung von Pfeilfunktionen zu Fehlern, Unannehmlichkeiten oder unerwartetem Verhalten von Programmen führt? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428566/">https://habr.com/ru/post/de428566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428556/index.html">„Die Produktionsumgebung liegt außerhalb Ihrer Kontrolle“: Rian Lewis beim Testen von Blockchain-Projekten</a></li>
<li><a href="../de428558/index.html">Wie ich aus meiner tiefen Faulheit einen Assistenten für WordPress erstellt habe</a></li>
<li><a href="../de428560/index.html">Außerplanmäßige Ankündigung am Freitag</a></li>
<li><a href="../de428562/index.html">Droidcon London. Wie war es</a></li>
<li><a href="../de428564/index.html">MapKit-Suche: Tipps und Tricks</a></li>
<li><a href="../de428568/index.html">Reagieren Sie auf das Entwicklungshandbuch für native Webanwendungen</a></li>
<li><a href="../de428570/index.html">Funktionen höherer Ordnung in JavaScript</a></li>
<li><a href="../de428572/index.html">Komponenten höherer Ordnung reagieren</a></li>
<li><a href="../de428574/index.html">Bringen Sie die Unternehmenskommunikation mit Zextras Chat auf die nächste Ebene</a></li>
<li><a href="../de428576/index.html">[Lesezeichen] PDF-Version des Node.js-Tutorials und neuer JavaScript-Anleitung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>