<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👍🏻 🤒 🧑🏽‍🤝‍🧑🏽 Kotlin: dua sendok tar dalam satu tong madu 🚽 🛠️ ◀️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Munculnya Kotlin adalah bonus penting bagi pengembang. Bahasa tingkat tinggi yang berintegrasi mulus dengan Java sangat memperluas kemampuan programme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin: dua sendok tar dalam satu tong madu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/acronis/blog/418377/">  Munculnya Kotlin adalah bonus penting bagi pengembang.  Bahasa tingkat tinggi yang berintegrasi mulus dengan Java sangat memperluas kemampuan programmer.  Namun, dalam bahasa apa pun kita terus-menerus menghadapi beberapa masalah, yang, sebaliknya, membuat batasan, dan Kotlin, tentu saja, tidak terkecuali.  Kami akan membicarakannya hari ini. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/_q/pf/p8/_qpfp83zobmgxndjyyeafmloojy.png"></a> <br><a name="habracut"></a><br>  Kotlin sangat antusias tentang komunitas, karena bahasa pemrograman baru sangat menyederhanakan penulisan kode, menggantikan Java.  Ini terutama terlihat pada Android, di mana versi baru Java muncul, dengan kata lain, "dengan derit".  Banyak perangkat diperbarui dengan penundaan lama, bahkan lebih - mereka tidak menerima pembaruan firmware sama sekali.  Dalam kasus terbaik, dukungan untuk perangkat berakhir sekitar 2 tahun setelah dirilis, yang menjanjikan satu, maksimum dua pembaruan sistem.  Namun, orang terus menggunakan perangkat, yang berarti pengembang harus bergantung pada (sejauh ini) Android 8 terbaru, dan Android 5, atau bahkan versi sebelumnya, di mana tentu saja tidak hanya yang terbaru, tetapi bahkan implementasi Java saat ini.  Sebagai referensi, sekarang total pangsa Android 7 dan 8 - versi di mana Java 8 didukung oleh pustaka sistem - adalah 42,9%, sisanya adalah Java 7. <br><br>  Beberapa orang mungkin mengatakan bahwa Java sudah usang.  Namun ada juga yang berpendapat bahwa Java adalah bahasa yang “baik” dan tidak boleh disentuh.  Ini seperti GCD (faktor umum terbesar) dalam matematika.  Ini berisi serangkaian fungsi pria, dan bagi mereka yang membutuhkan fitur tambahan hari ini, tersedia bahasa khusus yang sudah berfungsi di atas JVM.  Cukup banyak dari bahasa-bahasa ini yang telah dikembangbiakkan: Scala, Clojure, JRuby, Jython, Groovy, dan lainnya, kurang dikenal.  Namun, Kotlin memiliki sejumlah keunggulan.  Bahasa ini membuat programmer lebih bebas: ini memungkinkan Anda untuk menggunakan fragmen yang sudah jadi di Jawa secara bersamaan, menggabungkan kode lama dan baru. <br><br>  Tetapi dengan semua kelebihan dari bahasa baru, yang kami tidak pernah sangkal, selama proses pengembangan beberapa kelemahan ditemukan di dalamnya.  Dan hari ini akan menarik untuk mendengar pendapat rekan kerja tentang apakah mereka mengganggu pekerjaan dengan cara yang sama seperti kita. <br><br><h2>  Tidak bisa menyembunyikan pertunjukan? </h2><br>  Paket, seperti biasa, adalah cara yang cukup umum untuk mengatur kelas berdasarkan namespace.  Tetapi nilai tambah mereka tidak hanya ini, di Jawa mereka juga bertindak sebagai sarana untuk membatasi visibilitas kelas dan anggota mereka. <br><br>  Biarkan saya mengingatkan Anda bahwa di Jawa ada 4 kategori berbeda yang memungkinkan Anda untuk membedakan antara visibilitas.  Hanya ada dua dari mereka untuk kelas - mereka terlihat baik di dalam paket (paket pribadi) atau benar-benar terbuka (umum).  Tetapi metode atau bidang sudah dapat dibuat pribadi (tidak akan dapat diakses di luar kelas) hanya terlihat oleh paket (paket pribadi), dapat dibuat sehingga metode ini juga terlihat oleh ahli waris, baik dalam paketnya dan di luar paket (dilindungi), dan Anda juga dapat membuatnya terlihat oleh semua orang (publik). <br><br>  Java 9 memperkenalkan kemampuan untuk memecah kode menjadi modul, dan sekarang dimungkinkan untuk membuat beberapa bagian dari kode terlihat di mana-mana di dalam modul, tetapi tidak dari luar.  Dan ternyata sangat berguna untuk membangun API yang masuk akal. <br><br>  Singkatnya, opsi di Jawa lebih dari cukup.  Tetapi di Kotlin karena alasan tertentu mereka membatasi diri untuk memperkenalkan visibilitas publik dan pribadi, serta visibilitas bagi ahli waris.  Selain itu, mereka memperkenalkan perbedaan dengan modul, tetapi menjadi tidak mungkin untuk membedakan akses ke metode dan kelas dengan paket.  Modul tidak lagi merupakan konstruksi bahasa itu sendiri, dan cukup sering orang memahami hal-hal yang sangat berbeda dengan istilah ini.  Kotlin secara resmi mendefinisikan modul sebagai "satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">set file Kotlin yang dikompilasi bersama</a> ." <br><br>  Tangkapannya adalah bahwa modul, sebagai suatu peraturan, mengarah pada biaya sumber daya tambahan.  Pada saat yang sama, jika Anda membuat paket terpisah dan menempatkan kelas di dalamnya dengan fungsi yang hanya terlihat dalam paket ini, tidak ada masalah, karena semua paket akan dikompilasi bersama dan tidak ada sumber daya tambahan yang diperlukan. <br><br>  Ini terutama diucapkan jika, misalnya, Anda mengumpulkan proyek di Gradle, seperti biasa, aplikasi Android dirakit.  Modul biasanya dibuat relatif besar sehingga merupakan unit fungsional yang lengkap.  Dalam satu modul, metode tidak dapat dibuat terlihat oleh satu dan tidak terlihat oleh kelas lain.  Dan jika kita ingin membuat penampilan metode lebih terperinci, masalah muncul. <br><br>  Di sini, saya langsung ingin mengingat kembali paket-paket itu, karena di Kotlin esensi ini belum hilang, tetapi sayangnya, itu tidak mempengaruhi visibilitas.  Tentu saja, Anda selalu dapat membuat lebih banyak modul, tetapi, mengingat fitur Gradle, ini tidak rasional: kecepatan build akan berkurang.  Ya, dimungkinkan untuk menempatkan kelas dalam satu file, tetapi dalam kasus proyek besar, file tersebut akan menjadi sangat “berat”.  Oleh karena itu, saya ingin mendapatkan cara lain untuk menyembunyikan metode, misalnya, dimodelkan di Jawa. <br><br><h2>  Jangan memprosesnya ... bahkan jika itu perlu </h2><br>  Yang kedua agak kontroversial (karena beberapa menganggap penggunaannya sebagai berita buruk), namun minusnya adalah tidak adanya pengecualian yang diperiksa.  Alat-alat ini ada di Jawa, tetapi Kotlin memutuskan untuk tidak mengimplementasikannya.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi resmi</a> memiliki contoh tentang antarmuka yang dapat ditambahkan.  Anda dapat melampirkan string ke Appendable, dan karena string dapat terhubung ke objek yang terkait dengan I / O, misalnya, saat menulis ke file atau ke jaringan, Anda berpotensi mendapatkan IOException saat memanggil metode antarmuka.  Dan kasus-kasus seperti itu membuat penggunaan pengecualian yang diperiksa tidak nyaman. <br><br>  Pembuat bahasa menjelaskan argumen mereka sebagai berikut: jika kita menggunakan StringBuilder, mengaksesnya melalui Appendable, ternyata kita perlu menangani IOException, bahkan jika Anda yakin itu tidak dapat terjadi pada prinsipnya: <br><br><pre><code class="hljs cpp">Appendable <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {    <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.append(message); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) {    <span class="hljs-comment"><span class="hljs-comment">// Must be safe }</span></span></code> </pre> <br>  Jalan keluar dari situasi: pengecualiannya adalah "tertangkap", tetapi mereka tidak melakukan apa-apa dengannya, yang tentu saja tidak baik.  Namun, muncul pertanyaan: jika kita jelas bekerja dengan StringBuilder melalui antarmuka Appendable - mengapa tidak berinteraksi langsung dengan StringBuilder?  Ada perbedaan penting: ketika bekerja dengan Appendable, jika kita tidak tahu implementasi spesifik apa yang ada di bawahnya, pengecualian input / output menjadi sangat mungkin, tetapi StringBuilder tidak akan memberikannya secara tepat, dan metode yang sesuai dinyatakan di dalamnya, meskipun mereka mengimplementasikan antarmuka.  Jadi contohnya cukup ketat ... <br><br>  Sangat menarik bahwa penulis dokumentasi merujuk pada Bab 77 di Java Efektif, yang menyatakan bahwa pengecualian tidak dapat ditangkap dan diabaikan.  Tetapi hanya dalam bab-bab selanjutnya tertulis bahwa pengecualian yang diperiksa dapat dan harus digunakan jika dilakukan dengan bijak.  Jika dikutip secara selektif, sudut pandang apa pun dapat dibenarkan. <br><br>  Akibatnya, pengembang Kotlin membuatnya sehingga, pada dasarnya, semua metode berpotensi membuang semacam pengecualian.  Tapi lalu di mana alat untuk menangani kesalahan dalam bahasa baru?  Bagaimana sekarang memahami di mana pengecualian mungkin muncul?  Pada tingkat bahasa, sayangnya, kami tidak menemukan bantuan dalam masalah ini, dan bahkan dengan kode sumber (yang jauh dari selalu tersedia tanpa mempertimbangkan berbagai trik), sulit untuk memahami apa yang harus dilakukan dalam setiap situasi tertentu. <br><br>  Jika Anda mengajukan pertanyaan kepada pengembang, mereka hanya mengangkat bahu dan mengatakan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam bahasa lain tidak ada pengecualian yang diperiksa dan tidak ada</a> , mereka juga membuat program yang besar dan andal.  Tetapi mereka juga berhasil ditulis dalam bahasa yang tidak berhasil, ini bukan argumen.  Di StackOverflow, mereka mengatakan kepada pertanyaan serupa bahwa " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda perlu membaca dokumentasi</a> " - jawaban yang bagus, sangat nyaman dalam situasi seperti itu.  Hanya dokumentasi yang mungkin tidak ada, mungkin tidak lengkap atau ketinggalan jaman - kompiler tidak memeriksanya.  Akhirnya, Anda mungkin tidak menemukan jawabannya. <br><br>  Ya, memang benar bahwa mengecek pengecualian dapat menyebabkan API tidak nyaman.  Ketika memeriksa pengecualian jelas-jelas berlebihan sehingga kompiler "puas", Anda harus menulis coba ... tangkap dan sebenarnya hanya membuat kode sampah, karena tidak ada yang dilakukan saat memproses pengecualian ini.  Dan fakta bahwa tidak nyaman untuk menggunakannya dalam kode fungsional juga benar.  Tetapi pengecualian yang diperiksa hanyalah alat yang dapat digunakan dengan kompeten, jika perlu. <br><br>  Tidak jelas mengapa bahasa mengambil kesempatan ini, jika filosofi Kotlin adalah untuk mempercayai lebih banyak alat kepada programmer (setidaknya, menurut kami), dan jika pembuat kode dapat dengan tepat menggambarkan di mana akan ada pengecualian, mengapa tidak percaya padanya?  Ambil operator kelebihan beban yang sama yang dihapus dari Jawa, karena mereka dapat menyebabkan munculnya API dengan tindakan yang tidak jelas - ini untuk melindungi programmer dari diri mereka sendiri.  Sebaliknya, Kotlin memiliki kemampuan untuk membebani operator dan melakukan banyak hal lainnya - jadi mengapa tidak ada pengecualian yang diperiksa?  Mungkinkah pencipta melakukannya karena memang tidak seperti di Jawa? <br><br><h2>  Kami sedang menunggu perubahan ... </h2><br>  Maksimum yang dapat kita andalkan di Android adalah Java 7 atau Java 8 (tetapi dengan beberapa batasan dan peringatan), sementara Java 11 sudah mendekati. Menggunakan Kotlin, pemrograman pada Android jauh lebih mudah, jumlah baris teks berkurang . <br><br>  Orang hanya bisa berharap bahwa pengembang akan melengkapi bahasa yang sangat berguna ini dengan fitur-fitur yang tidak tersedia saat ini karena alasan yang jelas.  Mungkin di versi mendatang akan ada alat baru untuk menganalisis pengecualian di IDE, serta kategori privasi baru.  Tapi, ternyata, inilah kasus terbaik di masa depan yang jauh, karena pengembang bahasa bahkan belum menyuarakan janji. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418377/">https://habr.com/ru/post/id418377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418363/index.html">Tiga tanda pasti bahwa sudah waktunya untuk memotong kerangka Anda</a></li>
<li><a href="../id418365/index.html">Lambat tapi Benar: Lautan dan Lautan Mengancam Infrastruktur Internet Global</a></li>
<li><a href="../id418369/index.html">angular-ngrx-data - manajemen negara dan CRUD dalam lima menit</a></li>
<li><a href="../id418371/index.html">Microtask untuk programmer dan metode pembayaran cryptocurrency alternatif</a></li>
<li><a href="../id418375/index.html">Tinjauan umum Uniz Slash + 3D Photo-Printer</a></li>
<li><a href="../id418379/index.html">Prostesis bioelektrik anak-anak. Bagian 2</a></li>
<li><a href="../id418381/index.html">Apa yang Baru di DevTools di Versi Chrome 68</a></li>
<li><a href="../id418383/index.html">Animasi Android berdasarkan Kotlin dan RxJava</a></li>
<li><a href="../id418385/index.html">Bagaimana Saya Merakit Komputer untuk Game Lama</a></li>
<li><a href="../id418387/index.html">Fisikawan berdialog tentang jiwa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>