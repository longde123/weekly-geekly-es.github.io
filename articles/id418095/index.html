<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍶 🆓 👩🏻‍🏫 Tentang perangkat fungsionalitas pengujian bawaan di Rust (terjemahan) 🚇 🐲 😈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan kepada Anda terjemahan dari entri "# [test] pada tahun 2018" di blog John Renner, yang dapat ditemukan di sini . 

 B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang perangkat fungsionalitas pengujian bawaan di Rust (terjemahan)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418095/">  Halo, Habr!  Saya mempersembahkan kepada Anda terjemahan dari entri "# [test] pada tahun 2018" di blog John Renner, yang dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br>  Baru-baru ini, saya telah mengerjakan implementasi <a href="">eRFC untuk kerangka pengujian khusus</a> untuk Rust.  Mempelajari basis kode kompiler, saya mempelajari internal pengujian di Rust dan menyadari bahwa akan menarik untuk membagikan ini. <br><a name="habracut"></a><br><h3>  Atribut # [tes] </h3><br>  Saat ini, programmer Rust mengandalkan atribut <code>#[test]</code> .  Yang harus Anda lakukan adalah menandai fungsi sebagai tes dan mengaktifkan beberapa pemeriksaan: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre><br>  Ketika program ini dikompilasi menggunakan perintah <code>cargo test</code> <code>rustc --test</code> atau <code>cargo test</code> , itu akan membuat file yang dapat dieksekusi yang dapat menjalankan ini dan fungsi pengujian lainnya.  Metode pengujian ini memungkinkan Anda untuk menjaga tes dekat dengan kode secara organik.  Anda bahkan dapat memasukkan tes ke dalam modul pribadi: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> my_priv_mod { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_priv_func</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> {} <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_priv_func</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(my_priv_func()); } }</code> </pre><br>  Dengan demikian, entitas swasta dapat dengan mudah diuji tanpa menggunakan alat pengujian eksternal.  Ini adalah kunci untuk pengujian ergonomis di Rust.  Namun, secara semantik, ini agak aneh.  Bagaimana fungsi <code>main</code> memanggil tes ini jika tidak terlihat ( <b>catatan penerjemah</b> : Saya ingatkan Anda, pribadi - dideklarasikan tanpa menggunakan kata kunci <code>pub</code> - dilindungi oleh enkapsulasi dari akses luar)?  Apa sebenarnya yang dilakukan <code>rustc --test</code> ? <br><br>  <code>#[test]</code> diimplementasikan sebagai konversi sintaksis di dalam <code>libsyntax</code> compiler libsyntax.  Ini pada dasarnya adalah makro mewah yang menulis ulang peti kami dalam 3 langkah: <br><br><h3>  Langkah 1: Ekspor Kembali </h3><br>  Seperti yang disebutkan sebelumnya, tes dapat ada di dalam modul pribadi, jadi kita perlu cara untuk mengeksposnya ke fungsi <code>main</code> tanpa melanggar kode yang ada.  Untuk tujuan ini, <code>libsyntax</code> <i>membuat modul lokal yang disebut <code>__test_reexports</code> yang secara <code>__test_reexports</code> - <code>__test_reexports</code> tes</i> .  Pengungkapan ini menerjemahkan contoh di atas ke dalam: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> my_priv_mod { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_priv_func</span></span></span></span>() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_priv_func</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(my_priv_func()); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> __test_reexports { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::test_priv_func; } }</code> </pre><br>  Sekarang pengujian kami tersedia sebagai <code>my_priv_mod::__test_reexports::test_priv_func</code> .  Untuk modul bersarang, <code>__test_reexports</code> akan <code>__test_reexports</code> modul yang berisi tes, sehingga tes <code>a::b::my_test</code> menjadi <code>a::__test_reexports::b::__test_reexports::my_test</code> .  Sejauh ini proses ini tampaknya cukup aman, tetapi apa yang terjadi jika ada modul <code>__test_reexports</code> ada?  Jawab: <b>tidak ada</b> . <br><br>  Untuk menjelaskan, kita perlu memahami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagaimana AST mewakili pengidentifikasi</a> .  Nama setiap fungsi, variabel, modul, dll.  disimpan bukan sebagai string, melainkan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Simbol</a> buram, yang pada dasarnya adalah nomor identifikasi untuk setiap pengidentifikasi.  Compiler menyimpan tabel hash yang terpisah, yang memungkinkan kita untuk mengembalikan nama simbol yang dapat dibaca jika perlu (misalnya, ketika mencetak kesalahan sintaks).  Ketika kompiler membuat modul <code>__test_reexports</code> , ia menghasilkan Simbol baru untuk pengenal, oleh karena itu, meskipun <code>__test_reexports</code> dihasilkan oleh kompiler mungkin memiliki nama yang sama dengan modul generik Anda, ia tidak akan menggunakan Simbolnya.  Teknik ini mencegah tabrakan nama selama pembuatan kode dan merupakan dasar dari kebersihan sistem makro Rust. <br><br><h3>  Langkah 2: Menghasilkan Strapping </h3><br>  Sekarang tes kami dapat diakses dari akar peti kami, kami perlu melakukan sesuatu dengan mereka.  <code>libsyntax</code> menghasilkan modul seperti itu: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> __test { <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> test; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TESTS: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> [self::test::TestDescAndFn] = &amp;[<span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>]; <span class="hljs-meta"><span class="hljs-meta">#[main]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { self::test::test_static_main(TESTS); } }</code> </pre><br>  Meskipun konversi ini sederhana, ini memberi kami banyak informasi tentang bagaimana tes sebenarnya dilakukan.  Tes dikumpulkan ke dalam array dan diteruskan ke <code>test_static_main</code> uji, disebut <code>test_static_main</code> .  Kami akan kembali ke apa itu <code>TestDescAndFn</code> , tetapi saat ini kesimpulan kuncinya adalah bahwa ada kotak yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes</a> , yang merupakan bagian dari kernel Rust dan mengimplementasikan seluruh runtime untuk pengujian.  Antarmuka <code>test</code> tidak stabil, oleh karena itu satu-satunya cara stabil untuk berinteraksi dengannya adalah <code>#[test]</code> makro <code>#[test]</code> . <br><br><h3>  Langkah 3: Membuat Objek Tes </h3><br>  Jika sebelumnya Anda menulis tes di Rust, Anda mungkin terbiasa dengan beberapa atribut opsional yang tersedia untuk fungsi tes.  Misalnya, tes dapat dijelaskan dengan <code>#[should_panic]</code> jika kita mengharapkan tes menyebabkan kepanikan.  Itu terlihat seperti ini: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[should_panic]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">panic!</span></span>(<span class="hljs-string"><span class="hljs-string">"intentional"</span></span>); }</code> </pre><br>  Ini berarti bahwa pengujian kami lebih dari fungsi sederhana dan memiliki informasi konfigurasi.  <code>test</code> mengkodekan data konfigurasi ini ke dalam struktur yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">TestDesc</a> .  Untuk setiap fungsi tes dalam peti, <code>libsyntax</code> akan menganalisis atributnya dan menghasilkan turunan <code>TestDesc</code> .  Kemudian menggabungkan <code>TestDesc</code> dan fungsi tes ke dalam struktur logis <code>TestDescAndFn</code> , yang bekerja <code>test_static_main</code> .  Untuk tes ini, instance <code>TestDescAndFn</code> dihasilkan terlihat seperti ini: <br><br><pre> <code class="rust hljs">self::test::TestDescAndFn { desc: self::test::TestDesc { name: self::test::StaticTestName(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>), ignore: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, should_panic: self::test::ShouldPanic::Yes, allow_fail: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, testfn: self::test::StaticTestFn(|| self::test::assert_test_result(::crate::__test_reexports::foo())), }</code> </pre><br>  Setelah kami membuat larik objek uji ini, mereka akan diteruskan ke pelari uji melalui pengikatan yang dihasilkan pada langkah 2. Meskipun langkah ini dapat dianggap sebagai bagian dari langkah kedua, saya ingin menarik perhatian padanya sebagai konsep terpisah, karena ini akan menjadi kunci untuk menerapkan uji kustom kerangka kerja, tetapi ini akan menjadi posting blog lain. <br><br><h3>  Kata Penutup: Metode Penelitian </h3><br>  Walaupun saya mendapat banyak informasi langsung dari sumber kompiler, saya bisa mengetahui bahwa ada cara yang sangat sederhana untuk melihat apa yang dikerjakan kompiler.  Kompilator nightly build memiliki tanda tidak stabil yang disebut <code>unpretty</code> , yang dapat Anda gunakan untuk mencetak kode sumber modul setelah memperluas makro: <br><br><pre> <code class="rust hljs">$ rustc my_mod.rs -Z unpretty=hir</code> </pre><br><h4>  Catatan Penerjemah </h4><br>  Menarik untuk kepentingan, saya akan mengilustrasikan kode kasus uji setelah pengungkapan makro: <br><br>  Kode Sumber Kustom: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">4</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() {}</code> </pre><br>  Kode setelah memperluas makro: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[prelude_import]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::prelude::v1::*; <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> std <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> std; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_test</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !(<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">4</span></span>) { { ::rt::begin_panic(<span class="hljs-string"><span class="hljs-string">"assertion failed: 2 + 2 == 4"</span></span>, &amp;(<span class="hljs-string"><span class="hljs-string">"test_test.rs"</span></span>, <span class="hljs-number"><span class="hljs-number">3u32</span></span>, <span class="hljs-number"><span class="hljs-number">3u32</span></span>)) } }; } <span class="hljs-meta"><span class="hljs-meta">#[allow(dead_code)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> __test_reexports { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::my_test; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> __test { <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> test; <span class="hljs-meta"><span class="hljs-meta">#[main]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() -&gt; () { test::test_main_static(TESTS) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TESTS: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> [self::test::TestDescAndFn] = &amp;[self::test::TestDescAndFn { desc: self::test::TestDesc { name: self::test::StaticTestName(<span class="hljs-string"><span class="hljs-string">"my_test"</span></span>), ignore: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, should_panic: self::test::ShouldPanic::No, allow_fail: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, }, testfn: self::test::StaticTestFn(::__test_reexports::my_test), }]; }</code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418095/">https://habr.com/ru/post/id418095/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418085/index.html">Menggunakan Janji dalam JavaScript</a></li>
<li><a href="../id418087/index.html">80% dari checkout mandiri memiliki risiko</a></li>
<li><a href="../id418089/index.html">Ikhtisar Mesin Penggilingan SolidCraft CNC</a></li>
<li><a href="../id418091/index.html">Daftar artikel dan literatur tentang NAS</a></li>
<li><a href="../id418093/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 3: Buffer Overflows: Eksploitasi dan Perlindungan, Bagian 2</a></li>
<li><a href="../id418099/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 3: Buffer Overflows: Eksploitasi dan Perlindungan, Bagian 3</a></li>
<li><a href="../id418101/index.html">Etimologi Istilah TI</a></li>
<li><a href="../id418103/index.html">Kepala Roscosmos ingat roket pertamanya dan berbagi rencana untuk masa depan</a></li>
<li><a href="../id418105/index.html">Mengapa membuka YouTube di Firefox atau Edge dapat memakan waktu 5 kali lebih lama daripada di Google Chrome</a></li>
<li><a href="../id418107/index.html">Mengatur awalan untuk pemindai MINDEO CS2190 untuk bekerja dengan 1C dalam mode istirahat keyboard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>