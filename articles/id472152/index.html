<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌖 🎂 ❎ Menguji kode multithreaded dan asynchronous 🌅 🥟 🏧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Minggu ini tugasnya adalah menulis tes integrasi untuk aplikasi Spring Boot menggunakan interaksi asinkron dengan sistem eksternal. Menyegarkan ba...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menguji kode multithreaded dan asynchronous</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472152/"> Hai  Minggu ini tugasnya adalah menulis tes integrasi untuk aplikasi Spring Boot menggunakan interaksi asinkron dengan sistem eksternal.  Menyegarkan banyak materi tentang debugging kode multithreaded.  Artikel "Menguji Multi-Threaded dan Asynchronous Code" oleh Jonathan Halterman, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan saya</a> yang diberikan di bawah ini, menarik perhatian. <br><a name="habracut"></a><br>  Terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">shalomman</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">schroeder</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">FTOH</a> untuk komentar kode paling penting dari artikel aslinya. <br><br>  Jika Anda menulis kode cukup lama atau mungkin tidak, maka Anda mungkin menemukan skrip di mana Anda perlu menguji kode multi-utas.  Secara umum diyakini bahwa ulir dan pengujian tidak boleh dicampur.  Ini biasanya terjadi karena  apa yang akan diuji baru diluncurkan di dalam sistem multi-ulir dan dapat diuji secara individual tanpa menggunakan utas.  Tetapi bagaimana jika Anda tidak dapat memisahkannya, atau lebih, jika multithreading adalah aspek dari kode yang Anda uji? <br><br>  Saya di sini untuk memberi tahu Anda bahwa meskipun utas dalam tes tidak terlalu umum, mereka cukup digunakan.  Polisi perangkat lunak tidak akan menangkap Anda karena memulai utas dalam unit test, meskipun bagaimana sebenarnya menguji kode multi-utas adalah masalah lain.  Beberapa teknologi asinkron yang sangat baik, seperti Akka dan Vert.x, menyediakan ruang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uji</a> untuk meringankan beban ini.  Namun di luar itu, pengujian kode multi-ulir biasanya memerlukan pendekatan yang berbeda dari tes unit sinkron biasa. <br><br><h2>  Kami berjalan paralel </h2><br>  Langkah pertama adalah meluncurkan tindakan multithreaded yang ingin Anda periksa hasilnya.  Sebagai contoh, mari kita gunakan API hipotetis untuk mendaftarkan penangan pesan di bus pesan dan menerbitkan pesan di bus, yang akan dikirimkan ke penangan kami secara tidak sinkron di utas terpisah: <br><br><pre><code class="java hljs">messageBus.registerHandler(message - &gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); }); messageBus.publish(<span class="hljs-string"><span class="hljs-string">"test"</span></span>);</code> </pre> <br>  Itu terlihat bagus.  Ketika tes dimulai, bus harus mengirimkan pesan kami ke pawang di utas lain, tetapi ini tidak terlalu berguna, karena kami tidak memeriksa apa pun.  Mari perbarui pengujian kami untuk mengonfirmasi bahwa bus pesan mengirimkan pesan kami seperti yang diharapkan: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); }; messageBus.publish(msg);</code> </pre> <br>  Terlihat lebih baik.  Kami menjalankan tes kami dan itu hijau.  Keren!  Tetapi pesan yang Diterima tidak dicetak di mana pun, ada sesuatu yang salah di suatu tempat. <br><br><h2>  Tunggu sebentar </h2><br>  Dalam tes di atas, ketika sebuah pesan dipublikasikan di bus pesan, pesan tersebut dikirim oleh bus ke pawang di utas lainnya.  Tetapi ketika alat pengujian unit seperti JUnit menjalankan tes, ia tidak tahu apa-apa tentang aliran bus pesan.  JUnit hanya tahu tentang utas utama di mana ia menjalankan tes.  Dengan demikian, ketika bus pesan sedang sibuk mencoba untuk menyampaikan pesan, tes menyelesaikan eksekusi di utas uji utama dan JUnit melaporkan keberhasilan.  Bagaimana cara mengatasinya?  Kami membutuhkan utas uji utama untuk menunggu bus pesan untuk mengirimkan pesan kami.  Jadi mari kita tambahkan pernyataan tidur: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); }; messageBus.publish(msg); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br>  Tes kami berwarna hijau dan ekspresi Diterima dicetak seperti yang diharapkan.  Keren!  Tapi satu detik tidur berarti tes kami dilakukan setidaknya selama satu detik, dan tidak ada yang baik di dalamnya.  Kita dapat mengurangi waktu tidur, tetapi kemudian kita berisiko menyelesaikan tes sebelum menerima pesan.  Kami membutuhkan cara untuk mengoordinasikan antara utas uji utama dan utas penangan pesan.  Melihat paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">java.util.concurrent</a> , kami yakin dapat menemukan apa yang dapat kami gunakan.  Bagaimana dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CountDownLatch</a> ? <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); messageBus.registerHandler(message -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Received "</span></span> + message); assertEquals(message, msg); latch.countDown(); }; messageBus.publish(msg); latch.await();</code> </pre> <br>  Dalam pendekatan ini, kami membagikan CountDownLatch antara utas uji utama dan utas penangan pesan.  Utas utama terpaksa menunggu di pemblokir.  Utas uji melepaskan utas utama yang tertunda dengan memanggil countDown () pada pemblokir setelah menerima pesan.  Kita tidak perlu lagi tidur selama satu detik.  Tes kami memakan waktu persis seperti yang dibutuhkan. <br><br><h2>  Sangat bahagia? </h2><br>  Dengan pesona baru kami, CountDownLatch, kami mulai menulis tes multithreaded, seperti fashionista terbaru.  Tetapi cukup cepat, kami melihat bahwa salah satu kasus pengujian kami diblokir selamanya dan tidak berakhir.  Apa yang sedang terjadi  Pertimbangkan skenario bus pesan: pemblokir membuat Anda menunggu, tetapi itu dirilis hanya setelah menerima pesan.  Jika bus tidak berfungsi dan pesan tidak pernah terkirim, tes tidak akan pernah berakhir.  Jadi mari kita tambahkan batas waktu ke pemblokir: <br><br><pre> <code class="java hljs">latch.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS);</code> </pre> <br>  Tes yang diblokir gagal setelah 1 detik dengan pengecualian TimeoutException.  Pada akhirnya, kami akan menemukan masalah dan memperbaiki tes, tetapi memutuskan untuk meninggalkan batas waktu di tempat.  Jika ini pernah terjadi lagi, kami lebih suka pengujian kami untuk mengunci sesaat dan crash, daripada memblokir selamanya dan tidak selesai sama sekali. <br>  Masalah lain yang kami perhatikan ketika menulis tes adalah bahwa semuanya sepertinya lulus bahkan ketika seharusnya tidak.  Bagaimana ini mungkin?  Pertimbangkan tes pemrosesan pesan lagi: <br><br><pre> <code class="java hljs">messageBus.registerHandler(message -&gt; { assertEquals(message, msg); latch.countDown(); };</code> </pre> <br>  Kita seharusnya menggunakan CountDownLatch untuk mengoordinasikan penyelesaian pengujian kami dengan utas uji utama, tetapi bagaimana dengan menegaskan?  Jika validasi gagal, akankah JUnit mengetahuinya?  Ternyata karena kami tidak melakukan validasi di utas uji utama, setiap cacat check tetap tidak diperhatikan oleh JUnit.  Mari kita coba skrip kecil untuk menguji ini: <br><br><pre> <code class="java hljs">CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); latch.countDown(); }).start(); latch.await();</code> </pre> <br>  Tesnya hijau!  Jadi apa yang kita lakukan sekarang?  Kami membutuhkan cara untuk mengirim kesalahan pengujian dari aliran penanganan pesan kembali ke aliran pengujian utama.  Jika kegagalan terjadi di utas penangan pesan, kami membutuhkannya untuk muncul kembali di utas utama sehingga pengujian membalik, seperti yang diharapkan.  Mari kita coba lakukan ini: <br><br><pre> <code class="java hljs">CountDownLatch latch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CountDownLatch(<span class="hljs-number"><span class="hljs-number">1</span></span>); AtomicReference&lt;AssertionError&gt; failure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AtomicReference&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (AssertionError e) { failure.set(e); } latch.countDown(); }).start(); latch.await(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (failure.get() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> failure.get();</code> </pre> <br>  Mulai cepat dan ya, tes gagal, sebagaimana mestinya!  Sekarang kita dapat kembali dan menambahkan CountDownLatches, coba / tangkap dan AtomicReference blok untuk semua kasus pengujian kami.  Keren!  Sebenarnya, tidak keren, sepertinya seperti boilerplate. <br><br><h2>  Hentikan sampah </h2><br>  Idealnya, kita membutuhkan API yang memungkinkan kita untuk mengoordinasikan menunggu, memeriksa, dan melanjutkan eksekusi antara utas, sehingga pengujian unit dapat lulus atau gagal seperti yang diharapkan, di mana pun validasi gagal.  Untungnya, ConcurrentUnit menyediakan kerangka kerja ringan yang tidak hanya itu: Pelayan.  Mari kita adaptasi tes pemrosesan pesan di atas untuk yang terakhir kalinya dan lihat apa yang dapat dilakukan Pelayan dari ConcurrentUnit bagi kita: <br><br><pre> <code class="java hljs">String msg = <span class="hljs-string"><span class="hljs-string">"test"</span></span>; Waiter waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Waiter(); messageBus.registerHandler(message -&gt; { waiter.assertEquals(message, msg); waiter.resume(); }; messageBus.publish(msg); waiter.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS);</code> </pre> <br>  Dalam tes ini, kita melihat bahwa Pelayan telah menggantikan CountDownLatch dan AtomicReference kita.  Dengan Waiter, kami memblokir utas tes utama, melakukan tes, lalu melanjutkan utas tes utama sehingga tes dapat diselesaikan.  Jika cek gagal, maka memanggil wait.await akan secara otomatis melepaskan kunci dan melempar kegagalan, yang akan menyebabkan tes lulus atau gagal, sebagaimana mestinya, bahkan jika pemeriksaan dilakukan dari utas lainnya. <br><br><h2>  Bahkan lebih paralel </h2><br>  Sekarang kami telah menjadi penguji multi-utas bersertifikasi, kami mungkin ingin mengonfirmasi bahwa beberapa tindakan asinkron sedang terjadi.  ConcurrentUnit's Waiter membuat ini mudah: <br><br><pre> <code class="java hljs">Waiter waiter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Waiter(); messageBus.registerHandler(message -&gt; { waiter.resume(); }; messageBus.publish(<span class="hljs-string"><span class="hljs-string">"one"</span></span>); messageBus.publish(<span class="hljs-string"><span class="hljs-string">"two"</span></span>); waiter.await(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Di sini kami menerbitkan dua pesan di bus dan memverifikasi bahwa kedua pesan dikirim, membuat Pelayan menunggu resume () dipanggil 2 kali.  Jika pesan tidak terkirim dan resume tidak dipanggil dua kali dalam 1 detik, maka pengujian akan gagal dengan kesalahan TimeoutException. <br>  Satu tip umum dengan pendekatan ini adalah untuk memastikan waktu tunggu Anda cukup lama untuk menyelesaikan setiap tindakan bersamaan.  Dalam kondisi normal, ketika sistem yang diuji berfungsi seperti yang diharapkan, batas waktu tidak menjadi masalah dan hanya berlaku jika terjadi kegagalan sistem karena alasan apa pun. <br><br><h2>  Ringkasan </h2><br>  Dalam artikel ini, kami belajar bahwa pengujian unit multithread tidak jahat dan cukup mudah dilakukan.  Kami belajar tentang pendekatan umum ketika kami memblokir utas tes utama, melakukan pemeriksaan dari beberapa utas lainnya, dan kemudian melanjutkan utas utama.  Dan kami belajar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ConcurrentUnit</a> , yang dapat memfasilitasi tugas ini. <br>  Selamat mencoba! <br><br>  <b>Diterjemahkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472152/">https://habr.com/ru/post/id472152/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472128/index.html">Kenapa saya suka PHP?</a></li>
<li><a href="../id472130/index.html">Bagaimana mencegah perusahaan mengamuk?</a></li>
<li><a href="../id472138/index.html">Digitalisasi pendidikan</a></li>
<li><a href="../id472144/index.html">Bersiul semua orang di Linux, guntur dan kilat</a></li>
<li><a href="../id472148/index.html">Retrogaming: PAL vs NTSC. Atau mengapa PAL tidak diperlukan</a></li>
<li><a href="../id472154/index.html">Bagaimana tidak ketinggalan anggaran untuk produksi serial bangunan-2: harga untuk cetakan plastik skala kecil</a></li>
<li><a href="../id472156/index.html">Menerapkan pola Objek Halaman dalam Python + pytest</a></li>
<li><a href="../id472158/index.html">"Proses pendidikan di bidang TI dan bukan hanya": kontes teknologi dan acara Universitas ITMO</a></li>
<li><a href="../id472160/index.html">Phantom OS: jendela subsistem - lakukan kontrol</a></li>
<li><a href="../id472162/index.html">Pemasaran Email Outsourced: Cara Membangun dan Apa yang Diharapkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>