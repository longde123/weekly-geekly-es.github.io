<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛱️ 🌻 💏 Quantenmechanik von Berechnungen in JS 💄 💆🏿 🤞🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, mein Name ist Dmitry Karlovsky und ich ... arbeitslos. Daher habe ich viel Freizeit, um Musik, Sport, Kreativität, Sprachen, JS-Konferenzen und...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quantenmechanik von Berechnungen in JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413791/"><p> Hallo, mein Name ist Dmitry Karlovsky und ich ... arbeitslos.  Daher habe ich viel Freizeit, um Musik, Sport, Kreativität, Sprachen, JS-Konferenzen und Informatik zu spielen.  Ich erzähle Ihnen von den neuesten Forschungsergebnissen auf dem Gebiet der halbautomatischen Aufteilung langer Berechnungen in kleine Quanten von mehreren Millisekunden, die zu einer Miniaturbibliothek <code>$mol_fiber</code> .  Aber lassen Sie uns zuerst die Probleme skizzieren, die wir lösen werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/787/033/fb0/787033fb0e7d49cad98ce046a4e2380a.gif" alt="Quanta!"></p><br><p>  Dies ist eine Textversion der gleichnamigen Aufführung bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HolyJS 2018 Piter</a> .  Sie können es entweder <a href="">als Artikel lesen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Präsentationsoberfläche öffnen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Video ansehen</a> . </p><a name="habracut"></a><br><h1 id="issue-low-responsiveness">  Problem: Geringe Reaktionsfähigkeit </h1><br><p>  Wenn wir stabile 60 Bilder pro Sekunde haben möchten, haben wir nur 16 mit einer Kleinigkeit von Millisekunden, um die ganze Arbeit zu erledigen, einschließlich dessen, was der Browser tut, um die Ergebnisse auf dem Bildschirm anzuzeigen. </p><br><p>  Aber was ist, wenn wir länger fließen?  Dann wird der Benutzer eine verzögerte Oberfläche beobachten, die die Animation und dergleichen der UX-Verschlechterung verhindert. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9f8/b6f/431/9f8b6f43150f6aa318daf6bd7bde9e56.gif" alt="Geringe reaktionsfähigkeit"></p><br><h1 id="issue-no-escape">  Problem: Kein Entkommen </h1><br><p>  Es kommt vor, dass das Ergebnis für uns nicht mehr interessant ist, während wir die Berechnungen durchführen.  Zum Beispiel haben wir eine virtuelle Schriftrolle, die der Benutzer aktiv zieht, aber wir können nicht mithalten und den tatsächlichen Bereich nicht rendern, bis das vorherige Rendering die Kontrolle über die Verarbeitung von Benutzerereignissen zurückgibt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/28d/4d9/12f/28d4d912fb979ddb97ac61f3bb314756.jpg" alt="Kann nicht rückgängig gemacht werden"></p><br><p>  Unabhängig davon, wie lange wir arbeiten, sollten wir im Idealfall weiterhin Ereignisse verarbeiten und jederzeit in der Lage sein, die begonnenen, aber noch nicht abgeschlossenen Arbeiten abzubrechen. </p><br><h1 id="im-fast-and-i-know-it">  Ich bin schnell und ich weiß es </h1><br><p>  Aber was ist, wenn unsere Arbeit nicht eine, sondern mehrere, sondern ein Strom ist?  Stellen Sie sich vor, Sie fahren mit Ihrem frisch gekauften gelben Lotus und fahren bis zum Bahnübergang.  Wenn es kostenlos ist, können Sie es in Sekundenbruchteilen verschieben.  Aber .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fcc/078/f2b/fcc078f2b90d03703c61d42ffe53701f.jpg" alt="Kühlt automatisch ab"></p><br><h1 id="issue-no-concurrency">  Problem: Keine Parallelität </h1><br><p>  Wenn die Kreuzung von einem Kilometerzug besetzt ist, müssen Sie stehen und zehn Minuten warten, bis sie vorbeifährt.  Nicht dafür hast du einen Sportwagen gekauft, oder? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0fe/ed1/d50/0feed1d50bc38d61f26f11d28f80a87c.gif" alt="Schnell warten langsam"></p><br><p>  Und wie cool wäre es, wenn dieser Zug in 10 Züge zu je 100 Metern aufgeteilt würde und zwischen ihnen mehrere Minuten Zeit wären, um durchzukommen!  Sie würden dann nicht so spät sein. </p><br><p>  Was sind nun die Lösungen für diese Probleme in der JS-Welt? </p><br><h1 id="solution-workers">  Lösung: Arbeiter </h1><br><p>  Das erste, was mir in den Sinn kommt: Lassen Sie uns einfach alle komplexen Berechnungen in einem separaten Thread zusammenfassen.  Dazu haben wir einen Mechanismus für WebWorker. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6b/005/e78/f6b005e7836243e1434af86e1cc337cc.png" alt="Arbeiterlogik"></p><br><p>  Ereignisse aus dem UI-Stream werden an den Worker übergeben.  Dort werden sie verarbeitet und Anweisungen, was und wie auf der Seite geändert werden soll, werden bereits zurückgegeben.  Auf diese Weise speichern wir den UI-Stream vor einer großen Rechenschicht, aber nicht alle Probleme werden auf diese Weise gelöst, und zusätzlich werden neue hinzugefügt. </p><br><h1 id="workers-issues-deserialization">  Arbeiter: Probleme: (De) Serialisierung </h1><br><p>  Die Kommunikation zwischen Streams erfolgt durch Senden von Nachrichten, die in einen Byte-Stream serialisiert, in einen anderen Stream übertragen und dort in Objekte analysiert werden.  All dies ist viel langsamer als ein direkter Methodenaufruf innerhalb eines einzelnen Threads. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9f/c76/7db/e9fc767db4a76ac2079610a2df590eaa.jpg" alt="(De) Serialisierung"></p><br><h1 id="workers-issues-asynchronous-only">  Arbeiter: Probleme: Nur asynchron </h1><br><p>  Nachrichten werden streng asynchron übertragen.  Und dies bedeutet, dass einige Funktionen, die ich Sie bitte, nicht verfügbar sind.  Beispielsweise können Sie den Aufstieg eines UI-Ereignisses von einem Worker nicht stoppen, da das Ereignis im UI-Thread zum Zeitpunkt des Starts des Handlers bereits seinen Lebenszyklus abschließt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/083/1c9/d42/0831c9d4270c8a64e17febb2d509ec56.png" alt="Nachrichtenwarteschlangen"></p><br><h1 id="workers-issues-limited-apis">  Arbeiter: Probleme: Begrenzte APIs </h1><br><p>  Die folgenden APIs stehen uns in den Workern nicht zur Verfügung. </p><br><ul><li>  DOM, CSSOM </li><li>  Leinwand </li><li>  GeoLocation </li><li>  Geschichte &amp; Ort </li><li>  HTTP-Anforderungen synchronisieren </li><li>  XMLHttpRequest.responseXML </li><li>  Fenster </li></ul><br><h1 id="workers-issues-cant-cancel">  Arbeiter: Probleme: Kann nicht storniert werden </h1><br><p>  Und wieder haben wir keine Möglichkeit, die Berechnungen im Woker zu stoppen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/059/e49/064059e49ab01b803d84001dc2111da8.jpg" alt="Hör auf!"></p><br><p>  Ja, wir können den gesamten Arbeiter stoppen, aber das wird alle darin enthaltenen Aufgaben stoppen. <br>  Ja, Sie können jede Aufgabe in einem separaten Worker ausführen, dies ist jedoch sehr ressourcenintensiv. </p><br><h1 id="solution-react-fiber">  Lösung: Faser reagieren </h1><br><p>  Sicherlich haben viele gehört, dass FaceBook React heldenhaft umschreibt und alle darin enthaltenen Berechnungen in eine Reihe kleiner Funktionen aufteilt, die von einem speziellen Scheduler gestartet werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/079/4f3/de4/0794f3de41b63342f7298e82f7d6bdb2.png" alt="Tricky React Fiber Logic"></p><br><p>  Ich werde nicht auf Details seiner Implementierung eingehen, da dies ein separates großes Thema ist.  Ich werde nur einige Funktionen erwähnen, aufgrund derer es möglicherweise nicht zu Ihnen passt. </p><br><h1 id="react-fiber-react-required">  Faser reagieren: Reaktion erforderlich </h1><br><p>  Wenn Sie Angular, Vue oder ein anderes Framework als React verwenden, ist React Fibre natürlich für Sie nutzlos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/015/01e/1fa/01501e1fa047ab219dbaf0cd140e7002.jpg" alt="Reagieren Sie genießen!"></p><br><h1 id="react-fiber-only-rendering">  React Fibre: Nur Rendern </h1><br><p>  Reagieren - deckt nur die Rendering-Ebene ab.  Alle anderen Schichten der Anwendung bleiben ohne Quantisierung. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a82/3f5/c3e/a823f5c3e063d3961f64b0c18b25aa1b.gif" alt="Nicht so schnell!"></p><br><p>  React Fibre speichert Sie nicht, wenn Sie beispielsweise einen großen Datenblock nach schwierigen Bedingungen filtern müssen. </p><br><h1 id="react-fiber-quantization-is-disabled">  React Fibre: Quantisierung ist deaktiviert </h1><br><p>  Trotz der behaupteten Unterstützung für die Quantisierung ist sie standardmäßig immer noch deaktiviert, da sie die Abwärtskompatibilität beeinträchtigt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/498/f7b/4be/498f7b4be46edbbbf0884a71bccc89a8.jpg" alt="Marketingfalle"></p><br><p>  Die Quantisierung in React ist immer noch eine experimentelle Sache.  Seid vorsichtig! </p><br><h1 id="react-fiber-debug-is-pain">  React Fibre: Debug ist Schmerz </h1><br><p>  Wenn Sie die Quantisierung aktivieren, stimmt Callstack nicht mehr mit Ihrem Code überein, was das Debuggen erheblich erschwert.  Aber wir werden auf dieses Thema zurückkommen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3dd/725/bd5/3dd725bd5c728f4ecc43f167f2724f63.jpg" alt="Der ganze Schmerz des Debuggens"></p><br><h1 id="solution-quantization">  Lösung: Quantisierung </h1><br><p>  Versuchen wir, den React Fibre-Ansatz zu verallgemeinern, um die genannten Nachteile zu beseitigen.  Wir möchten im Rahmen eines Streams bleiben, aber lange Berechnungen in kleine Quanten aufteilen, zwischen denen der Browser die bereits an der Seite vorgenommenen Änderungen rendern kann, und auf Ereignisse reagieren. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a98/9c5/e9e/a989c5e9e41bc35a36a656a7ce19d610.png" alt="Flammendiagramme"></p><br><p>  Oben sehen Sie eine lange Berechnung, die die ganze Welt um mehr als 100 ms gestoppt hat.  Und von unten - die gleiche Berechnung, jedoch in Zeitscheiben von etwa 16 ms unterteilt, was durchschnittlich 60 Bilder pro Sekunde ergab.  Da wir normalerweise nicht wissen, wie viel Zeit die Berechnungen in Anspruch nehmen werden, können wir sie nicht manuell im Voraus in 16 ms aufteilen.  Daher benötigen wir eine Art Laufzeitmechanismus, der die Zeit misst, die zum Abschließen der Aufgabe benötigt wird, und wenn das Quantum überschritten wird, wodurch die Ausführung bis zum nächsten Animationsframe angehalten wird.  Lassen Sie uns darüber nachdenken, welche Mechanismen wir haben, um solche angehaltenen Aufgaben hier zu implementieren. </p><br><h1 id="concurrency-fibers--stackfull-coroutines">  Parallelität: Fasern - stapelbare Coroutinen </h1><br><p>  In Sprachen wie Go und D gibt es eine Redewendung wie "Coroutine mit Stapel", es ist auch eine "Faser" oder "Faser". </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Future } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'node-fibers'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> Future.wait( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">future</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( future.return ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> Future.task( four ).detach()</code> </pre> <br><p>  Im Codebeispiel sehen Sie die <code>one</code> Funktion, die die aktuelle Glasfaser anhalten kann, aber selbst eine vollständig synchrone Schnittstelle hat.  Die <code>two</code> , <code>three</code> und <code>four</code> Funktionen sind reguläre synchrone Funktionen, die nichts über Glasfaser wissen.  In ihnen können Sie alle Funktionen von Javascript vollständig nutzen.  Und schließlich führen wir in der letzten Zeile einfach die <code>four</code> Funktionen in einer separaten Faser aus. </p><br><p>  Die Verwendung von Fasern ist recht praktisch, aber um sie zu unterstützen, benötigen Sie Laufzeitunterstützung, die die meisten JS-Interpreter nicht haben.  Für NodeJS gibt es jedoch eine native <code>node-fibers</code> Erweiterung, die diese Unterstützung hinzufügt.  Leider sind in keinem Browser Browser verfügbar. </p><br><h1 id="concurrency-fsm--stackless-coroutines">  Parallelität: FSM - stapellose Coroutinen </h1><br><p>  In Sprachen wie C # und jetzt JS werden "stapellose Coroutinen" oder "asynchrone Funktionen" unterstützt.  Solche Funktionen sind eine Zustandsmaschine unter der Haube und wissen nichts über den Stapel. Daher müssen sie mit dem speziellen Schlüsselwort "async" gekennzeichnet werden, und Orte, an denen sie angehalten werden können, werden "erwartet". </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( done ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">await</span></span></span></span><span class="hljs-function"><span class="hljs-params"> one(</span></span></span><span class="hljs-function">) ) + 1 </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">three</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> two() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> three() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> four()</code> </pre> <br><p>  Da wir die Berechnung möglicherweise jederzeit verschieben müssen, müssen fast alle Funktionen in der Anwendung asynchron ausgeführt werden.  Dies ist nicht nur die Komplexität des Codes, sondern wirkt sich auch stark auf die Leistung aus.  Darüber hinaus unterstützen viele APIs, die Rückrufe akzeptieren, immer noch keine asynchronen Rückrufe.  Ein auffälliges Beispiel ist die <code>reduce</code> eines Arrays. </p><br><h1 id="concurrency-semi-fibers---restarts">  Parallelität: Halbfasern - Neustart </h1><br><p>  Versuchen wir, etwas Ähnliches wie Glasfaser zu tun, indem wir nur die Funktionen verwenden, die uns in jedem modernen Browser zur Verfügung stehen. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async , $mol_fiber_start } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> $mol_fiber_async( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( back ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> $mol_fiber_start( four )</code> </pre> <br><p>  Wie Sie sehen können, wissen die Zwischenfunktionen nichts über Unterbrechungen - dies ist reguläres JS.  Nur die <code>one</code> Funktion kennt die Möglichkeit der Federung.  Um die Berechnung abzubrechen, wirft sie einfach <code>Promise</code> als Ausnahme.  In der letzten Zeile führen wir die <code>four</code> Funktionen in einer separaten Pseudofaser aus, die die darin ausgelösten Ausnahmen überwacht. Wenn <code>Promise</code> eintrifft, abonniert es seine <code>resolve</code> und startet die Faser neu. </p><br><h1 id="figures">  Zahlen </h1><br><p>  Um zu zeigen, wie Pseudofasern funktionieren, schreiben wir einen kniffligen Code. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dce/e56/26a/dcee5626ad6c81048ca43a54a2825fe4.svg" alt="Typisches Ausführungsdiagramm"></p><br><p>  Stellen wir uns vor, dass die <code>step</code> hier etwas in die Konsole schreibt und 20 ms lang andere harte Arbeit leistet.  Die <code>walk</code> Funktion ruft <code>step</code> zweimal auf und protokolliert den gesamten Prozess.  In der Mitte wird angezeigt, was jetzt in der Konsole angezeigt wird.  Und rechts ist der Zustand des Pseudofaserbaums. </p><br><h1 id="mol_fiber-no-quantization">  $ mol_fiber: keine Quantisierung </h1><br><p>  Lassen Sie uns diesen Code ausführen und sehen, was passiert. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aa0/8aa/d4e/aa08aad4e3770368fd787aba5e8fcf81.svg" alt="Ausführung ohne Quantisierung"></p><br><p>  Bisher ist alles einfach und offensichtlich.  Der Pseudofaserbaum ist natürlich nicht beteiligt.  Und alles wäre in Ordnung, aber dieser Code wird länger als 40 ms ausgeführt, was wertlos ist. </p><br><h1 id="mol_fiber-cache-first">  $ mol_fiber: zuerst zwischenspeichern </h1><br><p>  Lassen Sie uns beide Funktionen in einen speziellen Wrapper einwickeln, der sie in einer Pseudofaser ausführt, und sehen, was passiert. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1f2/7e3/2f9/1f27e32f982035e32f59c4100aac3dd0.svg" alt="Caches ausführen"></p><br><p>  Hierbei ist zu beachten, dass für jeden Ort, an dem die <code>one</code> Funktion innerhalb der <code>walk</code> Faser aufgerufen wird, eine separate Faser erstellt wurde.  Das Ergebnis des ersten Aufrufs wurde zwischengespeichert, aber anstelle des zweiten wurde <code>Promise</code> geworfen, da wir unsere Zeitscheibe erschöpft hatten. </p><br><h1 id="mol_fiber-cache-second">  $ mol_fiber: Cache Sekunde </h1><br><p>  Im ersten Frame wird das <code>Promise</code> im nächsten automatisch aufgelöst, was zu einem Neustart der <code>walk</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2ec/d06/80b/2ecd0680bb11b2b425c2464e8d119362.svg" alt="Cache-wiederverwendung"></p><br><p>  Wie Sie sehen können, geben wir aufgrund des Neustarts erneut "start" und "first done" an die Konsole aus, aber "first begin" ist bereits weg, da es sich in der Glasfaser befindet und der Cache früher gefüllt wurde, weshalb der Handler mehr ist nicht angerufen.  Wenn der Cache der <code>walk</code> Faser gefüllt ist, werden alle eingebetteten Fasern zerstört, da die Ausführung sie niemals erreichen wird. </p><br><p>  Warum wurde <code>first begin</code> Drucken begonnen und <code>first done</code> <code>first begin</code> Drucken?  Es geht nur um Idempotenz.  <code>console.log</code> - nicht idempotenter Vorgang, wie oft Sie ihn aufrufen, so oft wird der Konsole ein Eintrag hinzugefügt.  Die Faser, die in einer anderen Faser ausgeführt wird, ist jedoch idempotent. Sie führt das Handle nur beim ersten Aufruf aus und gibt bei nachfolgenden Aufrufen sofort das Ergebnis aus dem Cache zurück, ohne dass zusätzliche Nebenwirkungen auftreten. </p><br><h1 id="mol_fiber-idempotence-first">  $ mol_fiber: Idempotenz zuerst </h1><br><p>  Lassen Sie uns <code>console.log</code> in eine Glasfaser einwickeln, um sie idempotent zu machen, und sehen, wie sich das Programm verhält. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/340/552/c63/340552c63f8356ee7b680ae76558ec90.svg" alt="idempotente caches ausführen"></p><br><p>  Wie Sie sehen können, haben wir jetzt im Faserbaum Einträge für jeden Aufruf der <code>log</code> . </p><br><h1 id="mol_fiber-idempotence-second">  $ mol_fiber: zweite Idempotenz </h1><br><p>  Beim nächsten Neustart der <code>walk</code> Fiber führen wiederholte Aufrufe der <code>log</code> nicht mehr zu Aufrufen der realen <code>console.log</code> , aber sobald wir zur Ausführung der Fibers mit einem leeren Cache gelangen, werden die Aufrufe der <code>console.log</code> fortgesetzt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b32/2ac/e0b/b322ace0b34b91d3db8c52cbf78599f5.svg" alt="Wiederverwendung idempotenter Caches"></p><br><p>  Bitte beachten Sie, dass in der Konsole jetzt nichts Überflüssiges angezeigt wird - genau das, was im synchronen Code ohne Faser und Quantifizierung angezeigt würde. </p><br><h1 id="mol_fiber-break">  $ mol_fiber: Pause </h1><br><p>  Wie unterbricht die Berechnung?  Zu Beginn des Quantums wird eine Frist festgelegt.  Und bevor jede Faser gestartet wird, wird geprüft, ob wir sie erreicht haben.  Und wenn Sie erreichen, dann eilt <code>Promise</code> , das im nächsten Frame aufgelöst wird und ein neues Quantum startet. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) }</code> </pre> <br><h1 id="mol_fiber-deadline">  $ mol_fiber: Frist </h1><br><p>  Die Frist für das Quantum ist einfach festzulegen.  Zur aktuellen Zeit werden 8 Millisekunden hinzugefügt.  Warum genau 8, weil es bis zu 16 gibt, um den Schuss vorzubereiten?  Tatsache ist, dass wir nicht im Voraus wissen, wie lange der Browser rendern muss, sodass wir etwas Zeit einplanen müssen, damit er funktioniert.  Aber manchmal kommt es vor, dass der Browser nichts rendern muss, und dann können wir mit 8-ms-Quanten ein weiteres Quantum in denselben Frame einfügen, was eine dichte Packung von Quanten mit minimalen Prozessorausfallzeiten ergibt. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> now = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quant = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> elapsed = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max( <span class="hljs-number"><span class="hljs-number">0</span></span> , now - $mol_fiber.deadline ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resistance = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( elapsed , <span class="hljs-number"><span class="hljs-number">1000</span></span> ) / <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 .. 100 ms $mol_fiber.deadline = now + quant + resistence</span></span></code> </pre> <br><p>  Wenn wir jedoch alle 8 ms eine Ausnahme auslösen, wird das Debuggen mit aktiviertem Ausnahmestopp zu einem kleinen Zweig der Hölle.  Wir brauchen einen Mechanismus, um diesen Debugger-Modus zu erkennen.  Leider kann dies nur indirekt verstanden werden: Eine Person braucht ungefähr eine Sekunde, um zu verstehen, ob sie die Ausführung fortsetzen soll oder nicht.  Dies bedeutet, dass entweder das Debugger gestoppt wurde oder eine umfangreiche Berechnung durchgeführt wurde, wenn das Steuerelement längere Zeit nicht zum Skript zurückkehrte.  Um auf beiden Stühlen zu sitzen, addieren wir 10% der verstrichenen Zeit zum Quantum, jedoch nicht mehr als 100 ms.  Dies hat keinen großen Einfluss auf die FPS, verringert jedoch die Stoppfrequenz des Debuggers aufgrund der Quantisierung um eine Größenordnung. </p><br><h1 id="debug-trycatch">  Debug: versuchen / fangen </h1><br><p>  Was denken Sie, an welcher Stelle dieses Codes stoppt der Debugger, da wir über das Debuggen sprechen? </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> new Error( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) // [<span class="hljs-number"><span class="hljs-number">1</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { foo() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ) { handle( error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error // [<span class="hljs-number"><span class="hljs-number">2</span></span>] }</code> </pre> <br><p>  In der Regel muss er dort anhalten, wo die Ausnahme zum ersten Mal ausgelöst wird. In Wirklichkeit stoppt er jedoch nur dort, wo sie das letzte Mal ausgelöst wurde, was normalerweise sehr weit von dem Ort entfernt ist, an dem sie aufgetreten ist.  Um das Debuggen nicht zu erschweren, sollten Ausnahmen daher niemals durch Try-Catch abgefangen werden.  Aber auch ohne Ausnahmebehandlung ist es unmöglich. </p><br><h1 id="debug-unhandled-events">  Debug: nicht behandelte Ereignisse </h1><br><p>  In der Regel stellt eine Laufzeit ein globales Ereignis bereit, das für jede nicht erfasste Ausnahme auftritt. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener( <span class="hljs-string"><span class="hljs-string">'error'</span></span> , event =&gt; handle( event.error ) ) foo()</code> </pre> <br><p>  Zusätzlich zur Umständlichkeit hat diese Lösung einen solchen Nachteil, dass alle Ausnahmen hier fallen und es ziemlich schwierig ist zu verstehen, von welcher Faser und Faser das Ereignis aufgetreten ist. </p><br><h1 id="debug-promise">  Debug: Versprechen </h1><br><p>  Versprechen sind der beste Weg, um mit Ausnahmen umzugehen. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { foo() } ).catch( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> handle( error ) )</code> </pre> <br><p>  Die an Promise übergebene Funktion wird sofort synchron aufgerufen, aber die Ausnahme wird nicht abgefangen und stoppt den Debugger sicher an der Stelle seines Auftretens.  Wenig später wird asynchron bereits der Fehlerhandler aufgerufen, in dem wir genau wissen, welche Glasfaser den Fehler verursacht hat und welcher Fehler.  Dies ist genau der Mechanismus, der in $ mol_fiber verwendet wird. </p><br><h1 id="stack-trace-react-fiber">  Stapelspur: Faser reagieren </h1><br><p>  Werfen wir einen Blick auf die Stapelverfolgung, die Sie in React Fibre erhalten. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/074/97d/d53/07497dd53b67863fe121c9cc7d314f96.png" alt="Leerer Grundnahrungsmittel"></p><br><p>  Wie Sie sehen können, bekommen wir viel Darmreaktion.  Von dem hier nützlichen sind nur der Punkt des Auftretens der Ausnahme und die Namen der Komponenten in der Hierarchie höher.  Nicht viel. </p><br><h1 id="stack-trace-mol_fiber">  Stapelverfolgung: $ mol_fiber </h1><br><p>  In $ mol_fiber erhalten wir eine viel nützlichere Stapelverfolgung: keine Eingeweide, nur bestimmte Punkte im Anwendungscode, durch die es zu einer Ausnahme kam. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b8/99d/8cc/5b899d8ccd70b5489cf87fea439beb5a.png" alt="Inhalt strace"></p><br><p>  Dies wird durch die Verwendung des nativen Stapels, Versprechen und die automatische Entfernung des Darms erreicht.  Wenn Sie möchten, können Sie den Fehler in der Konsole wie im Screenshot erweitern und die Eingeweide sehen, aber es gibt nichts Interessantes. </p><br><h1 id="mol_fiber-handle">  $ mol_fiber: behandeln </h1><br><p>  Um ein Quantum zu unterbrechen, wird Promise geworfen. </p><br><pre> <code class="hljs javascript">limit() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Aber wie Sie sich vorstellen können, kann Promise absolut alles sein - für eine Glasfaser spielt es im Allgemeinen keine Rolle, was zu erwarten ist: der nächste Frame, der Abschluss des Datenladens oder etwas anderes. </p><br><pre> <code class="hljs javascript">fail( error : <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listener = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> self.start() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.then( listener , listener ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Fibre abonniert einfach, um Versprechen zu lösen und neu zu starten.  Das manuelle Werfen und Fangen von Versprechungen ist jedoch nicht erforderlich, da das Paket mehrere nützliche Wrapper enthält. </p><br><h1 id="mol_fiber-functions">  $ mol_fiber: Funktionen </h1><br><p>  Um eine synchrone Funktion in eine idempotente Faser zu verwandeln, wickeln Sie sie einfach in <code>$mol_fiber_func</code> . </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = fiberize( <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log ) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> main = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { log( getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ).data ) } )</code> </pre> <br><p>  Hier haben wir <code>console.log</code> idempotent gemacht und <code>main</code> gelernt zu unterbrechen, während wir auf den Download warten. </p><br><h1 id="mol_fiber-error-handling">  $ mol_fiber: Fehlerbehandlung </h1><br><p>  Aber wie soll man auf Ausnahmen reagieren, wenn wir <code>try-catch</code> nicht verwenden wollen?  Dann können wir den Fehlerhandler mit <code>$mol_fiber_catch</code> ... </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize , $mol_fiber_catch <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> onError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getConfig = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { onError( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">user</span></span> : <span class="hljs-string"><span class="hljs-string">'Anonymous'</span></span> }) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getData( <span class="hljs-string"><span class="hljs-string">'/config'</span></span> ).data } )</code> </pre> <br><p>  Wenn wir etwas anderes als den darin enthaltenen Fehler zurückgeben, ist dies das Ergebnis der aktuellen Faser.  In diesem Beispiel gibt die Funktion <code>getConfig</code> die Konfiguration standardmäßig zurück, wenn es nicht möglich ist, die Konfiguration vom Server herunterzuladen. </p><br><h1 id="mol_fiber-methods">  $ mol_fiber: Methoden </h1><br><p>  Natürlich können Sie nicht nur Funktionen, sondern auch Methoden mit einem Dekorateur umschließen. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_method <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> action } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mover</span></span></span><span class="hljs-class"> </span></span>{ @action move() { sendData( <span class="hljs-string"><span class="hljs-string">'ya.ru'</span></span> , getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ) ) } }</code> </pre> <br><p>  Hier haben wir beispielsweise Daten von Google hochgeladen und auf Yandex hochgeladen. </p><br><h1 id="mol_fiber-promises">  $ mol_fiber: verspricht </h1><br><p>  Um Daten vom Server herunterzuladen, reicht es beispielsweise aus, die asynchrone Funktion <code>fetch</code> und mit einem Handgriff synchron zu machen. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_sync <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sync } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getData = sync( fetch )</code> </pre> <br><p>  Diese Implementierung ist für alle gut, unterstützt jedoch nicht das Abbrechen einer Anforderung, wenn ein Faserbaum zerstört wird. Daher müssen wir eine verwirrendere <code>API</code> . </p><br><h1 id="mol_fiber-cancel-request">  $ mol_fiber: Anfrage abbrechen </h1><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> uri : string </span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AbortController(); fetch( uri , { <span class="hljs-attr"><span class="hljs-attr">signal</span></span> : controller.signal } ).then( back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> res ) , back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error } ) , ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> controller.abort() } ) }</code> </pre> <br><p>  Die an den <code>async</code> Wrapper übergebene Funktion wird nur einmal aufgerufen, und der <code>back</code> Wrapper wird an ihn übergeben, in dem Sie die Rückrufe umbrechen müssen.  Dementsprechend müssen Sie in diesen Rückrufen entweder den Wert zurückgeben oder eine Ausnahme auslösen.  Was auch immer das Ergebnis des Rückrufs ist, es wird auch das Ergebnis der Faser sein.  Bitte beachten Sie, dass wir am Ende eine Funktion zurückgeben, die bei vorzeitiger Zerstörung der Faser aufgerufen wird. </p><br><h1 id="mol_fiber-cancel-response">  $ mol_fiber: Antwort abbrechen </h1><br><p>  Auf der Serverseite kann es auch nützlich sein, die Berechnung abzubrechen, wenn der Client heruntergefallen ist.  Implementieren wir einen Wrapper über <code>midleware</code> , der eine Faser erstellt, in der die ursprüngliche <code>midleware</code> wird.     ,    ,       ,      . </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_make <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Fiber } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> const middle_fiber = middleware =&gt; ( req , res ) =&gt; { const fiber = Fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> middleware( req , res ) ) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>( <span class="hljs-string"><span class="hljs-string">'close'</span></span> , <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> fiber.destructor() ) fiber.start() } app.get( <span class="hljs-string"><span class="hljs-string">'/foo'</span></span> , middle_fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( req , res )</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something } ) )</code> </pre> <br><h1 id="mol_fiber-concurrency"> $mol_fiber: concurrency </h1><br><p>       ,         .  ,    3 :    ,     ,   - .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/257/b87/a50/257b87a5095cecaf0e53da2234666a62.png" alt="Schnelle und langsame Anfragen"></p><br><p>      :      ,    .       .       ,       ,   . </p><br><h1 id="mol_fiber-properties"> $mol_fiber: properties </h1><br><p>  ,    .. </p><br><blockquote> <strong>Pros:</strong> <br><ul><li> Runtime support isn't required </li><li> Can be cancelled at any time </li><li> High FPS </li><li> Concurrent execution </li><li> Debug friendly </li><li> ~ 3KB gzipped </li></ul><br><br> <strong>Cons:</strong> <br><ul><li> Instrumentation is required </li><li> All code should be idempotent </li><li> Longer total execution </li></ul><br></blockquote><p> $mol_fiber —   ,         .  — ,            .      , ,    .  ,   ,     ,     ,      .  ,          .        . </p><br><h1 id="links">  Links </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nin-jin.github.io/slides/fibers/</a> — this slides </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mol.js.org/fiber</a> — $mol_fiber online demo </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/eigenmethod/mol/tree/master/fiber</a> — $mol_fiber documentation </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">t.me/mam_mol</a> — lovely $mol chat </li></ul><br><h1 id="call-back"> Call back </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d35/cd4/554/d35cd4554553fa35a7d756cbf9737949.jpg" alt="Ruckkopplung"></p><br><p> <strong></strong> :   , ,        ) </p><br><p> <strong></strong> :  ,       . </p><br><p> <strong></strong> :  .    ,        . </p><br><p> <strong></strong> :    .   ,        .   ,    . </p><br><p> <strong></strong> :   ,            .     ,      ) </p><br><p> <strong></strong> :    ,     . </p><br><p> <strong></strong> :    -      .   ,        ,     . </p><br><p> <strong></strong> :       .  ,  ,     . </p><br><p> <strong></strong> :  ,     .     16ms,     ?  16  8 ,      8,   .      ,       .            ,    «». </p><br><p> <strong></strong> :      —       .  Vielen Dank! </p><br><p> <strong></strong> :    .    ,   .  Liebte es! </p><br><p> <strong></strong> :  ,         .        . </p><br><p> <strong></strong> :  ,     ,            ,      ,     ,     / ,            . </p><br><p> <strong></strong> :  ,     . </p><br><p> <strong></strong> :  . </p><br><p> <strong></strong> :         ,     .      mol. </p><br><p> <strong></strong> :    ,     ,    . ,  ,  ,   . </p><br><p> <strong></strong> :   . </p><br><p> <strong></strong> :       ,     .   ,     $mol,    ,  . </p><br><p> <strong></strong> :  ,  ,      .            — .  . </p><br><p> <strong></strong> :  -   ,         . </p><br><p> <strong></strong> :       $mol    ,        .  (pdf,  )  ,      . </p><br><p> <strong></strong> :     ,   .   ,     . </p><br><p> <strong></strong> :   ,    )       . </p><br><p> <strong></strong> :   .  . </p><br><p> <strong></strong> : In some places I missed what the reporter was saying. The conversation was about how to use the "Mola" library and "why?". But how it works remains a mystery for me.To smoke an source code is for the overhead. </p><br><p> <strong> </strong> :  ,  . </p><br><p> <strong> </strong> :  .         ,    .       .        . </p><br><p> <strong> </strong> :     :     .   -      (,   ).           ,   :          16? </p><br><p> <strong> </strong> :    .      .    ,   mol_fiber  …   ,          30fps     60fps —   .              —    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413791/">https://habr.com/ru/post/de413791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413779/index.html">Timer und Multitasking auf Arduino</a></li>
<li><a href="../de413781/index.html">Wie Werbebluthunde Ihrer Spur im Internet folgen</a></li>
<li><a href="../de413783/index.html">Wie sterben die massereichsten Sterne: Supernova, Hypernova oder direkter Zusammenbruch?</a></li>
<li><a href="../de413787/index.html">Winkel: ngx-translate. Verbesserung der Infrastruktur mit Webpack</a></li>
<li><a href="../de413789/index.html">In Florida überprüften sie ein Jahr lang keine Waffeneinkäufer bei der FBI-Basis, weil sie das Passwort vergessen hatten</a></li>
<li><a href="../de413793/index.html">Audiokassetten in der Popkultur: Warum das veraltete Tonaufnahmeformat wieder als modisch gilt</a></li>
<li><a href="../de413795/index.html">Warum die Unterhaltungsindustrie zu IaaS wechselt: Fallstudie</a></li>
<li><a href="../de413797/index.html">EA stellte den neuen Teil von C & C auf der E3 vor. Und es ist körperlich schmerzhaft, es anzusehen</a></li>
<li><a href="../de413799/index.html">Himbeer Pi Neuronales Netzwerk Bienenzählen</a></li>
<li><a href="../de413801/index.html">"Roskosmos" bietet an, eine Laserkanone neu zu bauen ... ein optisches Teleskop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>