<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õ±Ô∏è üåª üíè Quantenmechanik von Berechnungen in JS üíÑ üíÜüèø ü§ûüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo, mein Name ist Dmitry Karlovsky und ich ... arbeitslos. Daher habe ich viel Freizeit, um Musik, Sport, Kreativit√§t, Sprachen, JS-Konferenzen und...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quantenmechanik von Berechnungen in JS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413791/"><p> Hallo, mein Name ist Dmitry Karlovsky und ich ... arbeitslos.  Daher habe ich viel Freizeit, um Musik, Sport, Kreativit√§t, Sprachen, JS-Konferenzen und Informatik zu spielen.  Ich erz√§hle Ihnen von den neuesten Forschungsergebnissen auf dem Gebiet der halbautomatischen Aufteilung langer Berechnungen in kleine Quanten von mehreren Millisekunden, die zu einer Miniaturbibliothek <code>$mol_fiber</code> .  Aber lassen Sie uns zuerst die Probleme skizzieren, die wir l√∂sen werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/787/033/fb0/787033fb0e7d49cad98ce046a4e2380a.gif" alt="Quanta!"></p><br><p>  Dies ist eine Textversion der gleichnamigen Auff√ºhrung bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HolyJS 2018 Piter</a> .  Sie k√∂nnen es entweder <a href="">als Artikel lesen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in der Pr√§sentationsoberfl√§che √∂ffnen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Video ansehen</a> . </p><a name="habracut"></a><br><h1 id="issue-low-responsiveness">  Problem: Geringe Reaktionsf√§higkeit </h1><br><p>  Wenn wir stabile 60 Bilder pro Sekunde haben m√∂chten, haben wir nur 16 mit einer Kleinigkeit von Millisekunden, um die ganze Arbeit zu erledigen, einschlie√ülich dessen, was der Browser tut, um die Ergebnisse auf dem Bildschirm anzuzeigen. </p><br><p>  Aber was ist, wenn wir l√§nger flie√üen?  Dann wird der Benutzer eine verz√∂gerte Oberfl√§che beobachten, die die Animation und dergleichen der UX-Verschlechterung verhindert. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9f8/b6f/431/9f8b6f43150f6aa318daf6bd7bde9e56.gif" alt="Geringe reaktionsf√§higkeit"></p><br><h1 id="issue-no-escape">  Problem: Kein Entkommen </h1><br><p>  Es kommt vor, dass das Ergebnis f√ºr uns nicht mehr interessant ist, w√§hrend wir die Berechnungen durchf√ºhren.  Zum Beispiel haben wir eine virtuelle Schriftrolle, die der Benutzer aktiv zieht, aber wir k√∂nnen nicht mithalten und den tats√§chlichen Bereich nicht rendern, bis das vorherige Rendering die Kontrolle √ºber die Verarbeitung von Benutzerereignissen zur√ºckgibt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/28d/4d9/12f/28d4d912fb979ddb97ac61f3bb314756.jpg" alt="Kann nicht r√ºckg√§ngig gemacht werden"></p><br><p>  Unabh√§ngig davon, wie lange wir arbeiten, sollten wir im Idealfall weiterhin Ereignisse verarbeiten und jederzeit in der Lage sein, die begonnenen, aber noch nicht abgeschlossenen Arbeiten abzubrechen. </p><br><h1 id="im-fast-and-i-know-it">  Ich bin schnell und ich wei√ü es </h1><br><p>  Aber was ist, wenn unsere Arbeit nicht eine, sondern mehrere, sondern ein Strom ist?  Stellen Sie sich vor, Sie fahren mit Ihrem frisch gekauften gelben Lotus und fahren bis zum Bahn√ºbergang.  Wenn es kostenlos ist, k√∂nnen Sie es in Sekundenbruchteilen verschieben.  Aber .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fcc/078/f2b/fcc078f2b90d03703c61d42ffe53701f.jpg" alt="K√ºhlt automatisch ab"></p><br><h1 id="issue-no-concurrency">  Problem: Keine Parallelit√§t </h1><br><p>  Wenn die Kreuzung von einem Kilometerzug besetzt ist, m√ºssen Sie stehen und zehn Minuten warten, bis sie vorbeif√§hrt.  Nicht daf√ºr hast du einen Sportwagen gekauft, oder? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0fe/ed1/d50/0feed1d50bc38d61f26f11d28f80a87c.gif" alt="Schnell warten langsam"></p><br><p>  Und wie cool w√§re es, wenn dieser Zug in 10 Z√ºge zu je 100 Metern aufgeteilt w√ºrde und zwischen ihnen mehrere Minuten Zeit w√§ren, um durchzukommen!  Sie w√ºrden dann nicht so sp√§t sein. </p><br><p>  Was sind nun die L√∂sungen f√ºr diese Probleme in der JS-Welt? </p><br><h1 id="solution-workers">  L√∂sung: Arbeiter </h1><br><p>  Das erste, was mir in den Sinn kommt: Lassen Sie uns einfach alle komplexen Berechnungen in einem separaten Thread zusammenfassen.  Dazu haben wir einen Mechanismus f√ºr WebWorker. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6b/005/e78/f6b005e7836243e1434af86e1cc337cc.png" alt="Arbeiterlogik"></p><br><p>  Ereignisse aus dem UI-Stream werden an den Worker √ºbergeben.  Dort werden sie verarbeitet und Anweisungen, was und wie auf der Seite ge√§ndert werden soll, werden bereits zur√ºckgegeben.  Auf diese Weise speichern wir den UI-Stream vor einer gro√üen Rechenschicht, aber nicht alle Probleme werden auf diese Weise gel√∂st, und zus√§tzlich werden neue hinzugef√ºgt. </p><br><h1 id="workers-issues-deserialization">  Arbeiter: Probleme: (De) Serialisierung </h1><br><p>  Die Kommunikation zwischen Streams erfolgt durch Senden von Nachrichten, die in einen Byte-Stream serialisiert, in einen anderen Stream √ºbertragen und dort in Objekte analysiert werden.  All dies ist viel langsamer als ein direkter Methodenaufruf innerhalb eines einzelnen Threads. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e9f/c76/7db/e9fc767db4a76ac2079610a2df590eaa.jpg" alt="(De) Serialisierung"></p><br><h1 id="workers-issues-asynchronous-only">  Arbeiter: Probleme: Nur asynchron </h1><br><p>  Nachrichten werden streng asynchron √ºbertragen.  Und dies bedeutet, dass einige Funktionen, die ich Sie bitte, nicht verf√ºgbar sind.  Beispielsweise k√∂nnen Sie den Aufstieg eines UI-Ereignisses von einem Worker nicht stoppen, da das Ereignis im UI-Thread zum Zeitpunkt des Starts des Handlers bereits seinen Lebenszyklus abschlie√üt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/083/1c9/d42/0831c9d4270c8a64e17febb2d509ec56.png" alt="Nachrichtenwarteschlangen"></p><br><h1 id="workers-issues-limited-apis">  Arbeiter: Probleme: Begrenzte APIs </h1><br><p>  Die folgenden APIs stehen uns in den Workern nicht zur Verf√ºgung. </p><br><ul><li>  DOM, CSSOM </li><li>  Leinwand </li><li>  GeoLocation </li><li>  Geschichte &amp; Ort </li><li>  HTTP-Anforderungen synchronisieren </li><li>  XMLHttpRequest.responseXML </li><li>  Fenster </li></ul><br><h1 id="workers-issues-cant-cancel">  Arbeiter: Probleme: Kann nicht storniert werden </h1><br><p>  Und wieder haben wir keine M√∂glichkeit, die Berechnungen im Woker zu stoppen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/059/e49/064059e49ab01b803d84001dc2111da8.jpg" alt="H√∂r auf!"></p><br><p>  Ja, wir k√∂nnen den gesamten Arbeiter stoppen, aber das wird alle darin enthaltenen Aufgaben stoppen. <br>  Ja, Sie k√∂nnen jede Aufgabe in einem separaten Worker ausf√ºhren, dies ist jedoch sehr ressourcenintensiv. </p><br><h1 id="solution-react-fiber">  L√∂sung: Faser reagieren </h1><br><p>  Sicherlich haben viele geh√∂rt, dass FaceBook React heldenhaft umschreibt und alle darin enthaltenen Berechnungen in eine Reihe kleiner Funktionen aufteilt, die von einem speziellen Scheduler gestartet werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/079/4f3/de4/0794f3de41b63342f7298e82f7d6bdb2.png" alt="Tricky React Fiber Logic"></p><br><p>  Ich werde nicht auf Details seiner Implementierung eingehen, da dies ein separates gro√ües Thema ist.  Ich werde nur einige Funktionen erw√§hnen, aufgrund derer es m√∂glicherweise nicht zu Ihnen passt. </p><br><h1 id="react-fiber-react-required">  Faser reagieren: Reaktion erforderlich </h1><br><p>  Wenn Sie Angular, Vue oder ein anderes Framework als React verwenden, ist React Fibre nat√ºrlich f√ºr Sie nutzlos. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/015/01e/1fa/01501e1fa047ab219dbaf0cd140e7002.jpg" alt="Reagieren Sie genie√üen!"></p><br><h1 id="react-fiber-only-rendering">  React Fibre: Nur Rendern </h1><br><p>  Reagieren - deckt nur die Rendering-Ebene ab.  Alle anderen Schichten der Anwendung bleiben ohne Quantisierung. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a82/3f5/c3e/a823f5c3e063d3961f64b0c18b25aa1b.gif" alt="Nicht so schnell!"></p><br><p>  React Fibre speichert Sie nicht, wenn Sie beispielsweise einen gro√üen Datenblock nach schwierigen Bedingungen filtern m√ºssen. </p><br><h1 id="react-fiber-quantization-is-disabled">  React Fibre: Quantisierung ist deaktiviert </h1><br><p>  Trotz der behaupteten Unterst√ºtzung f√ºr die Quantisierung ist sie standardm√§√üig immer noch deaktiviert, da sie die Abw√§rtskompatibilit√§t beeintr√§chtigt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/498/f7b/4be/498f7b4be46edbbbf0884a71bccc89a8.jpg" alt="Marketingfalle"></p><br><p>  Die Quantisierung in React ist immer noch eine experimentelle Sache.  Seid vorsichtig! </p><br><h1 id="react-fiber-debug-is-pain">  React Fibre: Debug ist Schmerz </h1><br><p>  Wenn Sie die Quantisierung aktivieren, stimmt Callstack nicht mehr mit Ihrem Code √ºberein, was das Debuggen erheblich erschwert.  Aber wir werden auf dieses Thema zur√ºckkommen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3dd/725/bd5/3dd725bd5c728f4ecc43f167f2724f63.jpg" alt="Der ganze Schmerz des Debuggens"></p><br><h1 id="solution-quantization">  L√∂sung: Quantisierung </h1><br><p>  Versuchen wir, den React Fibre-Ansatz zu verallgemeinern, um die genannten Nachteile zu beseitigen.  Wir m√∂chten im Rahmen eines Streams bleiben, aber lange Berechnungen in kleine Quanten aufteilen, zwischen denen der Browser die bereits an der Seite vorgenommenen √Ñnderungen rendern kann, und auf Ereignisse reagieren. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a98/9c5/e9e/a989c5e9e41bc35a36a656a7ce19d610.png" alt="Flammendiagramme"></p><br><p>  Oben sehen Sie eine lange Berechnung, die die ganze Welt um mehr als 100 ms gestoppt hat.  Und von unten - die gleiche Berechnung, jedoch in Zeitscheiben von etwa 16 ms unterteilt, was durchschnittlich 60 Bilder pro Sekunde ergab.  Da wir normalerweise nicht wissen, wie viel Zeit die Berechnungen in Anspruch nehmen werden, k√∂nnen wir sie nicht manuell im Voraus in 16 ms aufteilen.  Daher ben√∂tigen wir eine Art Laufzeitmechanismus, der die Zeit misst, die zum Abschlie√üen der Aufgabe ben√∂tigt wird, und wenn das Quantum √ºberschritten wird, wodurch die Ausf√ºhrung bis zum n√§chsten Animationsframe angehalten wird.  Lassen Sie uns dar√ºber nachdenken, welche Mechanismen wir haben, um solche angehaltenen Aufgaben hier zu implementieren. </p><br><h1 id="concurrency-fibers--stackfull-coroutines">  Parallelit√§t: Fasern - stapelbare Coroutinen </h1><br><p>  In Sprachen wie Go und D gibt es eine Redewendung wie "Coroutine mit Stapel", es ist auch eine "Faser" oder "Faser". </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Future } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'node-fibers'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> Future.wait( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">future</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( future.return ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> Future.task( four ).detach()</code> </pre> <br><p>  Im Codebeispiel sehen Sie die <code>one</code> Funktion, die die aktuelle Glasfaser anhalten kann, aber selbst eine vollst√§ndig synchrone Schnittstelle hat.  Die <code>two</code> , <code>three</code> und <code>four</code> Funktionen sind regul√§re synchrone Funktionen, die nichts √ºber Glasfaser wissen.  In ihnen k√∂nnen Sie alle Funktionen von Javascript vollst√§ndig nutzen.  Und schlie√ülich f√ºhren wir in der letzten Zeile einfach die <code>four</code> Funktionen in einer separaten Faser aus. </p><br><p>  Die Verwendung von Fasern ist recht praktisch, aber um sie zu unterst√ºtzen, ben√∂tigen Sie Laufzeitunterst√ºtzung, die die meisten JS-Interpreter nicht haben.  F√ºr NodeJS gibt es jedoch eine native <code>node-fibers</code> Erweiterung, die diese Unterst√ºtzung hinzuf√ºgt.  Leider sind in keinem Browser Browser verf√ºgbar. </p><br><h1 id="concurrency-fsm--stackless-coroutines">  Parallelit√§t: FSM - stapellose Coroutinen </h1><br><p>  In Sprachen wie C # und jetzt JS werden "stapellose Coroutinen" oder "asynchrone Funktionen" unterst√ºtzt.  Solche Funktionen sind eine Zustandsmaschine unter der Haube und wissen nichts √ºber den Stapel. Daher m√ºssen sie mit dem speziellen Schl√ºsselwort "async" gekennzeichnet werden, und Orte, an denen sie angehalten werden k√∂nnen, werden "erwartet". </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">done</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( done ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">await</span></span></span></span><span class="hljs-function"><span class="hljs-params"> one(</span></span></span><span class="hljs-function">) ) + 1 </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">three</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> two() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> ()=&gt; ( <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> three() ) + <span class="hljs-number"><span class="hljs-number">1</span></span> four()</code> </pre> <br><p>  Da wir die Berechnung m√∂glicherweise jederzeit verschieben m√ºssen, m√ºssen fast alle Funktionen in der Anwendung asynchron ausgef√ºhrt werden.  Dies ist nicht nur die Komplexit√§t des Codes, sondern wirkt sich auch stark auf die Leistung aus.  Dar√ºber hinaus unterst√ºtzen viele APIs, die R√ºckrufe akzeptieren, immer noch keine asynchronen R√ºckrufe.  Ein auff√§lliges Beispiel ist die <code>reduce</code> eines Arrays. </p><br><h1 id="concurrency-semi-fibers---restarts">  Parallelit√§t: Halbfasern - Neustart </h1><br><p>  Versuchen wir, etwas √Ñhnliches wie Glasfaser zu tun, indem wir nur die Funktionen verwenden, die uns in jedem modernen Browser zur Verf√ºgung stehen. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async , $mol_fiber_start } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> one = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> $mol_fiber_async( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> setTimeout( back ) ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> two = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> one() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> three = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> two() + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> four = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> three() + <span class="hljs-number"><span class="hljs-number">1</span></span> $mol_fiber_start( four )</code> </pre> <br><p>  Wie Sie sehen k√∂nnen, wissen die Zwischenfunktionen nichts √ºber Unterbrechungen - dies ist regul√§res JS.  Nur die <code>one</code> Funktion kennt die M√∂glichkeit der Federung.  Um die Berechnung abzubrechen, wirft sie einfach <code>Promise</code> als Ausnahme.  In der letzten Zeile f√ºhren wir die <code>four</code> Funktionen in einer separaten Pseudofaser aus, die die darin ausgel√∂sten Ausnahmen √ºberwacht. Wenn <code>Promise</code> eintrifft, abonniert es seine <code>resolve</code> und startet die Faser neu. </p><br><h1 id="figures">  Zahlen </h1><br><p>  Um zu zeigen, wie Pseudofasern funktionieren, schreiben wir einen kniffligen Code. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dce/e56/26a/dcee5626ad6c81048ca43a54a2825fe4.svg" alt="Typisches Ausf√ºhrungsdiagramm"></p><br><p>  Stellen wir uns vor, dass die <code>step</code> hier etwas in die Konsole schreibt und 20 ms lang andere harte Arbeit leistet.  Die <code>walk</code> Funktion ruft <code>step</code> zweimal auf und protokolliert den gesamten Prozess.  In der Mitte wird angezeigt, was jetzt in der Konsole angezeigt wird.  Und rechts ist der Zustand des Pseudofaserbaums. </p><br><h1 id="mol_fiber-no-quantization">  $ mol_fiber: keine Quantisierung </h1><br><p>  Lassen Sie uns diesen Code ausf√ºhren und sehen, was passiert. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aa0/8aa/d4e/aa08aad4e3770368fd787aba5e8fcf81.svg" alt="Ausf√ºhrung ohne Quantisierung"></p><br><p>  Bisher ist alles einfach und offensichtlich.  Der Pseudofaserbaum ist nat√ºrlich nicht beteiligt.  Und alles w√§re in Ordnung, aber dieser Code wird l√§nger als 40 ms ausgef√ºhrt, was wertlos ist. </p><br><h1 id="mol_fiber-cache-first">  $ mol_fiber: zuerst zwischenspeichern </h1><br><p>  Lassen Sie uns beide Funktionen in einen speziellen Wrapper einwickeln, der sie in einer Pseudofaser ausf√ºhrt, und sehen, was passiert. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1f2/7e3/2f9/1f27e32f982035e32f59c4100aac3dd0.svg" alt="Caches ausf√ºhren"></p><br><p>  Hierbei ist zu beachten, dass f√ºr jeden Ort, an dem die <code>one</code> Funktion innerhalb der <code>walk</code> Faser aufgerufen wird, eine separate Faser erstellt wurde.  Das Ergebnis des ersten Aufrufs wurde zwischengespeichert, aber anstelle des zweiten wurde <code>Promise</code> geworfen, da wir unsere Zeitscheibe ersch√∂pft hatten. </p><br><h1 id="mol_fiber-cache-second">  $ mol_fiber: Cache Sekunde </h1><br><p>  Im ersten Frame wird das <code>Promise</code> im n√§chsten automatisch aufgel√∂st, was zu einem Neustart der <code>walk</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2ec/d06/80b/2ecd0680bb11b2b425c2464e8d119362.svg" alt="Cache-wiederverwendung"></p><br><p>  Wie Sie sehen k√∂nnen, geben wir aufgrund des Neustarts erneut "start" und "first done" an die Konsole aus, aber "first begin" ist bereits weg, da es sich in der Glasfaser befindet und der Cache fr√ºher gef√ºllt wurde, weshalb der Handler mehr ist nicht angerufen.  Wenn der Cache der <code>walk</code> Faser gef√ºllt ist, werden alle eingebetteten Fasern zerst√∂rt, da die Ausf√ºhrung sie niemals erreichen wird. </p><br><p>  Warum wurde <code>first begin</code> Drucken begonnen und <code>first done</code> <code>first begin</code> Drucken?  Es geht nur um Idempotenz.  <code>console.log</code> - nicht idempotenter Vorgang, wie oft Sie ihn aufrufen, so oft wird der Konsole ein Eintrag hinzugef√ºgt.  Die Faser, die in einer anderen Faser ausgef√ºhrt wird, ist jedoch idempotent. Sie f√ºhrt das Handle nur beim ersten Aufruf aus und gibt bei nachfolgenden Aufrufen sofort das Ergebnis aus dem Cache zur√ºck, ohne dass zus√§tzliche Nebenwirkungen auftreten. </p><br><h1 id="mol_fiber-idempotence-first">  $ mol_fiber: Idempotenz zuerst </h1><br><p>  Lassen Sie uns <code>console.log</code> in eine Glasfaser einwickeln, um sie idempotent zu machen, und sehen, wie sich das Programm verh√§lt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/340/552/c63/340552c63f8356ee7b680ae76558ec90.svg" alt="idempotente caches ausf√ºhren"></p><br><p>  Wie Sie sehen k√∂nnen, haben wir jetzt im Faserbaum Eintr√§ge f√ºr jeden Aufruf der <code>log</code> . </p><br><h1 id="mol_fiber-idempotence-second">  $ mol_fiber: zweite Idempotenz </h1><br><p>  Beim n√§chsten Neustart der <code>walk</code> Fiber f√ºhren wiederholte Aufrufe der <code>log</code> nicht mehr zu Aufrufen der realen <code>console.log</code> , aber sobald wir zur Ausf√ºhrung der Fibers mit einem leeren Cache gelangen, werden die Aufrufe der <code>console.log</code> fortgesetzt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b32/2ac/e0b/b322ace0b34b91d3db8c52cbf78599f5.svg" alt="Wiederverwendung idempotenter Caches"></p><br><p>  Bitte beachten Sie, dass in der Konsole jetzt nichts √úberfl√ºssiges angezeigt wird - genau das, was im synchronen Code ohne Faser und Quantifizierung angezeigt w√ºrde. </p><br><h1 id="mol_fiber-break">  $ mol_fiber: Pause </h1><br><p>  Wie unterbricht die Berechnung?  Zu Beginn des Quantums wird eine Frist festgelegt.  Und bevor jede Faser gestartet wird, wird gepr√ºft, ob wir sie erreicht haben.  Und wenn Sie erreichen, dann eilt <code>Promise</code> , das im n√§chsten Frame aufgel√∂st wird und ein neues Quantum startet. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) }</code> </pre> <br><h1 id="mol_fiber-deadline">  $ mol_fiber: Frist </h1><br><p>  Die Frist f√ºr das Quantum ist einfach festzulegen.  Zur aktuellen Zeit werden 8 Millisekunden hinzugef√ºgt.  Warum genau 8, weil es bis zu 16 gibt, um den Schuss vorzubereiten?  Tatsache ist, dass wir nicht im Voraus wissen, wie lange der Browser rendern muss, sodass wir etwas Zeit einplanen m√ºssen, damit er funktioniert.  Aber manchmal kommt es vor, dass der Browser nichts rendern muss, und dann k√∂nnen wir mit 8-ms-Quanten ein weiteres Quantum in denselben Frame einf√ºgen, was eine dichte Packung von Quanten mit minimalen Prozessorausfallzeiten ergibt. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> now = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quant = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> elapsed = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.max( <span class="hljs-number"><span class="hljs-number">0</span></span> , now - $mol_fiber.deadline ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resistance = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.min( elapsed , <span class="hljs-number"><span class="hljs-number">1000</span></span> ) / <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0 .. 100 ms $mol_fiber.deadline = now + quant + resistence</span></span></code> </pre> <br><p>  Wenn wir jedoch alle 8 ms eine Ausnahme ausl√∂sen, wird das Debuggen mit aktiviertem Ausnahmestopp zu einem kleinen Zweig der H√∂lle.  Wir brauchen einen Mechanismus, um diesen Debugger-Modus zu erkennen.  Leider kann dies nur indirekt verstanden werden: Eine Person braucht ungef√§hr eine Sekunde, um zu verstehen, ob sie die Ausf√ºhrung fortsetzen soll oder nicht.  Dies bedeutet, dass entweder das Debugger gestoppt wurde oder eine umfangreiche Berechnung durchgef√ºhrt wurde, wenn das Steuerelement l√§ngere Zeit nicht zum Skript zur√ºckkehrte.  Um auf beiden St√ºhlen zu sitzen, addieren wir 10% der verstrichenen Zeit zum Quantum, jedoch nicht mehr als 100 ms.  Dies hat keinen gro√üen Einfluss auf die FPS, verringert jedoch die Stoppfrequenz des Debuggers aufgrund der Quantisierung um eine Gr√∂√üenordnung. </p><br><h1 id="debug-trycatch">  Debug: versuchen / fangen </h1><br><p>  Was denken Sie, an welcher Stelle dieses Codes stoppt der Debugger, da wir √ºber das Debuggen sprechen? </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> new Error( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) // [<span class="hljs-number"><span class="hljs-number">1</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { foo() } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ) { handle( error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error // [<span class="hljs-number"><span class="hljs-number">2</span></span>] }</code> </pre> <br><p>  In der Regel muss er dort anhalten, wo die Ausnahme zum ersten Mal ausgel√∂st wird. In Wirklichkeit stoppt er jedoch nur dort, wo sie das letzte Mal ausgel√∂st wurde, was normalerweise sehr weit von dem Ort entfernt ist, an dem sie aufgetreten ist.  Um das Debuggen nicht zu erschweren, sollten Ausnahmen daher niemals durch Try-Catch abgefangen werden.  Aber auch ohne Ausnahmebehandlung ist es unm√∂glich. </p><br><h1 id="debug-unhandled-events">  Debug: nicht behandelte Ereignisse </h1><br><p>  In der Regel stellt eine Laufzeit ein globales Ereignis bereit, das f√ºr jede nicht erfasste Ausnahme auftritt. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener( <span class="hljs-string"><span class="hljs-string">'error'</span></span> , event =&gt; handle( event.error ) ) foo()</code> </pre> <br><p>  Zus√§tzlich zur Umst√§ndlichkeit hat diese L√∂sung einen solchen Nachteil, dass alle Ausnahmen hier fallen und es ziemlich schwierig ist zu verstehen, von welcher Faser und Faser das Ereignis aufgetreten ist. </p><br><h1 id="debug-promise">  Debug: Versprechen </h1><br><p>  Versprechen sind der beste Weg, um mit Ausnahmen umzugehen. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>( <span class="hljs-string"><span class="hljs-string">'Something wrong'</span></span> ) } <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { foo() } ).catch( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> handle( error ) )</code> </pre> <br><p>  Die an Promise √ºbergebene Funktion wird sofort synchron aufgerufen, aber die Ausnahme wird nicht abgefangen und stoppt den Debugger sicher an der Stelle seines Auftretens.  Wenig sp√§ter wird asynchron bereits der Fehlerhandler aufgerufen, in dem wir genau wissen, welche Glasfaser den Fehler verursacht hat und welcher Fehler.  Dies ist genau der Mechanismus, der in $ mol_fiber verwendet wird. </p><br><h1 id="stack-trace-react-fiber">  Stapelspur: Faser reagieren </h1><br><p>  Werfen wir einen Blick auf die Stapelverfolgung, die Sie in React Fibre erhalten. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/074/97d/d53/07497dd53b67863fe121c9cc7d314f96.png" alt="Leerer Grundnahrungsmittel"></p><br><p>  Wie Sie sehen k√∂nnen, bekommen wir viel Darmreaktion.  Von dem hier n√ºtzlichen sind nur der Punkt des Auftretens der Ausnahme und die Namen der Komponenten in der Hierarchie h√∂her.  Nicht viel. </p><br><h1 id="stack-trace-mol_fiber">  Stapelverfolgung: $ mol_fiber </h1><br><p>  In $ mol_fiber erhalten wir eine viel n√ºtzlichere Stapelverfolgung: keine Eingeweide, nur bestimmte Punkte im Anwendungscode, durch die es zu einer Ausnahme kam. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b8/99d/8cc/5b899d8ccd70b5489cf87fea439beb5a.png" alt="Inhalt strace"></p><br><p>  Dies wird durch die Verwendung des nativen Stapels, Versprechen und die automatische Entfernung des Darms erreicht.  Wenn Sie m√∂chten, k√∂nnen Sie den Fehler in der Konsole wie im Screenshot erweitern und die Eingeweide sehen, aber es gibt nichts Interessantes. </p><br><h1 id="mol_fiber-handle">  $ mol_fiber: behandeln </h1><br><p>  Um ein Quantum zu unterbrechen, wird Promise geworfen. </p><br><pre> <code class="hljs javascript">limit() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() &gt; $mol_fiber.deadline ) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( $mol_fiber.schedule ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Aber wie Sie sich vorstellen k√∂nnen, kann Promise absolut alles sein - f√ºr eine Glasfaser spielt es im Allgemeinen keine Rolle, was zu erwarten ist: der n√§chste Frame, der Abschluss des Datenladens oder etwas anderes. </p><br><pre> <code class="hljs javascript">fail( error : <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( error <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listener = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> self.start() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error.then( listener , listener ) } <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Fibre abonniert einfach, um Versprechen zu l√∂sen und neu zu starten.  Das manuelle Werfen und Fangen von Versprechungen ist jedoch nicht erforderlich, da das Paket mehrere n√ºtzliche Wrapper enth√§lt. </p><br><h1 id="mol_fiber-functions">  $ mol_fiber: Funktionen </h1><br><p>  Um eine synchrone Funktion in eine idempotente Faser zu verwandeln, wickeln Sie sie einfach in <code>$mol_fiber_func</code> . </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log = fiberize( <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log ) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> main = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { log( getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ).data ) } )</code> </pre> <br><p>  Hier haben wir <code>console.log</code> idempotent gemacht und <code>main</code> gelernt zu unterbrechen, w√§hrend wir auf den Download warten. </p><br><h1 id="mol_fiber-error-handling">  $ mol_fiber: Fehlerbehandlung </h1><br><p>  Aber wie soll man auf Ausnahmen reagieren, wenn wir <code>try-catch</code> nicht verwenden wollen?  Dann k√∂nnen wir den Fehlerhandler mit <code>$mol_fiber_catch</code> ... </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_func <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> fiberize , $mol_fiber_catch <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> onError } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getConfig = fiberize( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> { onError( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">user</span></span> : <span class="hljs-string"><span class="hljs-string">'Anonymous'</span></span> }) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getData( <span class="hljs-string"><span class="hljs-string">'/config'</span></span> ).data } )</code> </pre> <br><p>  Wenn wir etwas anderes als den darin enthaltenen Fehler zur√ºckgeben, ist dies das Ergebnis der aktuellen Faser.  In diesem Beispiel gibt die Funktion <code>getConfig</code> die Konfiguration standardm√§√üig zur√ºck, wenn es nicht m√∂glich ist, die Konfiguration vom Server herunterzuladen. </p><br><h1 id="mol_fiber-methods">  $ mol_fiber: Methoden </h1><br><p>  Nat√ºrlich k√∂nnen Sie nicht nur Funktionen, sondern auch Methoden mit einem Dekorateur umschlie√üen. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_method <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> action } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mover</span></span></span><span class="hljs-class"> </span></span>{ @action move() { sendData( <span class="hljs-string"><span class="hljs-string">'ya.ru'</span></span> , getData( <span class="hljs-string"><span class="hljs-string">'goo.gl'</span></span> ) ) } }</code> </pre> <br><p>  Hier haben wir beispielsweise Daten von Google hochgeladen und auf Yandex hochgeladen. </p><br><h1 id="mol_fiber-promises">  $ mol_fiber: verspricht </h1><br><p>  Um Daten vom Server herunterzuladen, reicht es beispielsweise aus, die asynchrone Funktion <code>fetch</code> und mit einem Handgriff synchron zu machen. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_sync <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sync } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getData = sync( fetch )</code> </pre> <br><p>  Diese Implementierung ist f√ºr alle gut, unterst√ºtzt jedoch nicht das Abbrechen einer Anforderung, wenn ein Faserbaum zerst√∂rt wird. Daher m√ºssen wir eine verwirrendere <code>API</code> . </p><br><h1 id="mol_fiber-cancel-request">  $ mol_fiber: Anfrage abbrechen </h1><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_async <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber/web'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> uri : string </span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">back</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AbortController(); fetch( uri , { <span class="hljs-attr"><span class="hljs-attr">signal</span></span> : controller.signal } ).then( back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> res ) , back( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error } ) , ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> controller.abort() } ) }</code> </pre> <br><p>  Die an den <code>async</code> Wrapper √ºbergebene Funktion wird nur einmal aufgerufen, und der <code>back</code> Wrapper wird an ihn √ºbergeben, in dem Sie die R√ºckrufe umbrechen m√ºssen.  Dementsprechend m√ºssen Sie in diesen R√ºckrufen entweder den Wert zur√ºckgeben oder eine Ausnahme ausl√∂sen.  Was auch immer das Ergebnis des R√ºckrufs ist, es wird auch das Ergebnis der Faser sein.  Bitte beachten Sie, dass wir am Ende eine Funktion zur√ºckgeben, die bei vorzeitiger Zerst√∂rung der Faser aufgerufen wird. </p><br><h1 id="mol_fiber-cancel-response">  $ mol_fiber: Antwort abbrechen </h1><br><p>  Auf der Serverseite kann es auch n√ºtzlich sein, die Berechnung abzubrechen, wenn der Client heruntergefallen ist.  Implementieren wir einen Wrapper √ºber <code>midleware</code> , der eine Faser erstellt, in der die urspr√ºngliche <code>midleware</code> wird.     ,    ,       ,      . </p><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { $mol_fiber_make <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Fiber } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mol_fiber'</span></span> const middle_fiber = middleware =&gt; ( req , res ) =&gt; { const fiber = Fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> middleware( req , res ) ) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>( <span class="hljs-string"><span class="hljs-string">'close'</span></span> , <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span> fiber.destructor() ) fiber.start() } app.get( <span class="hljs-string"><span class="hljs-string">'/foo'</span></span> , middle_fiber( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( req , res )</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something } ) )</code> </pre> <br><h1 id="mol_fiber-concurrency"> $mol_fiber: concurrency </h1><br><p>       ,         .  ,    3 :    ,     ,   - .. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/257/b87/a50/257b87a5095cecaf0e53da2234666a62.png" alt="Schnelle und langsame Anfragen"></p><br><p>      :      ,    .       .       ,       ,   . </p><br><h1 id="mol_fiber-properties"> $mol_fiber: properties </h1><br><p>  ,    .. </p><br><blockquote> <strong>Pros:</strong> <br><ul><li> Runtime support isn't required </li><li> Can be cancelled at any time </li><li> High FPS </li><li> Concurrent execution </li><li> Debug friendly </li><li> ~ 3KB gzipped </li></ul><br><br> <strong>Cons:</strong> <br><ul><li> Instrumentation is required </li><li> All code should be idempotent </li><li> Longer total execution </li></ul><br></blockquote><p> $mol_fiber ‚Äî   ,         .  ‚Äî ,            .      , ,    .  ,   ,     ,     ,      .  ,          .        . </p><br><h1 id="links">  Links </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nin-jin.github.io/slides/fibers/</a> ‚Äî this slides </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mol.js.org/fiber</a> ‚Äî $mol_fiber online demo </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/eigenmethod/mol/tree/master/fiber</a> ‚Äî $mol_fiber documentation </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">t.me/mam_mol</a> ‚Äî lovely $mol chat </li></ul><br><h1 id="call-back"> Call back </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d35/cd4/554/d35cd4554553fa35a7d756cbf9737949.jpg" alt="Ruckkopplung"></p><br><p> <strong></strong> :   , ,        ) </p><br><p> <strong></strong> :  ,       . </p><br><p> <strong></strong> :  .    ,        . </p><br><p> <strong></strong> :    .   ,        .   ,    . </p><br><p> <strong></strong> :   ,            .     ,      ) </p><br><p> <strong></strong> :    ,     . </p><br><p> <strong></strong> :    -      .   ,        ,     . </p><br><p> <strong></strong> :       .  ,  ,     . </p><br><p> <strong></strong> :  ,     .     16ms,     ?  16  8 ,      8,   .      ,       .            ,    ¬´¬ª. </p><br><p> <strong></strong> :      ‚Äî       .  Vielen Dank! </p><br><p> <strong></strong> :    .    ,   .  Liebte es! </p><br><p> <strong></strong> :  ,         .        . </p><br><p> <strong></strong> :  ,     ,            ,      ,     ,     / ,            . </p><br><p> <strong></strong> :  ,     . </p><br><p> <strong></strong> :  . </p><br><p> <strong></strong> :         ,     .      mol. </p><br><p> <strong></strong> :    ,     ,    . ,  ,  ,   . </p><br><p> <strong></strong> :   . </p><br><p> <strong></strong> :       ,     .   ,     $mol,    ,  . </p><br><p> <strong></strong> :  ,  ,      .            ‚Äî .  . </p><br><p> <strong></strong> :  -   ,         . </p><br><p> <strong></strong> :       $mol    ,        .  (pdf,  )  ,      . </p><br><p> <strong></strong> :     ,   .   ,     . </p><br><p> <strong></strong> :   ,    )       . </p><br><p> <strong></strong> :   .  . </p><br><p> <strong></strong> : In some places I missed what the reporter was saying. The conversation was about how to use the "Mola" library and "why?". But how it works remains a mystery for me.To smoke an source code is for the overhead. </p><br><p> <strong> </strong> :  ,  . </p><br><p> <strong> </strong> :  .         ,    .       .        . </p><br><p> <strong> </strong> :     :     .   -      (,   ).           ,   :          16? </p><br><p> <strong> </strong> :    .      .    ,   mol_fiber  ‚Ä¶   ,          30fps     60fps ‚Äî   .              ‚Äî    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413791/">https://habr.com/ru/post/de413791/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413779/index.html">Timer und Multitasking auf Arduino</a></li>
<li><a href="../de413781/index.html">Wie Werbebluthunde Ihrer Spur im Internet folgen</a></li>
<li><a href="../de413783/index.html">Wie sterben die massereichsten Sterne: Supernova, Hypernova oder direkter Zusammenbruch?</a></li>
<li><a href="../de413787/index.html">Winkel: ngx-translate. Verbesserung der Infrastruktur mit Webpack</a></li>
<li><a href="../de413789/index.html">In Florida √ºberpr√ºften sie ein Jahr lang keine Waffeneink√§ufer bei der FBI-Basis, weil sie das Passwort vergessen hatten</a></li>
<li><a href="../de413793/index.html">Audiokassetten in der Popkultur: Warum das veraltete Tonaufnahmeformat wieder als modisch gilt</a></li>
<li><a href="../de413795/index.html">Warum die Unterhaltungsindustrie zu IaaS wechselt: Fallstudie</a></li>
<li><a href="../de413797/index.html">EA stellte den neuen Teil von C & C auf der E3 vor. Und es ist k√∂rperlich schmerzhaft, es anzusehen</a></li>
<li><a href="../de413799/index.html">Himbeer Pi Neuronales Netzwerk Bienenz√§hlen</a></li>
<li><a href="../de413801/index.html">"Roskosmos" bietet an, eine Laserkanone neu zu bauen ... ein optisches Teleskop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>