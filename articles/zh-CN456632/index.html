<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏴󠁧󠁢󠁳󠁣󠁴󠁿 ❓ 👨🏼‍🍳 我们正在RESTinio中构建C ++模板的第四层。 为什么以及如何？ 👉🏾 🔇 📶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RESTinio是一个相对较小的项目，它是内置在C ++应用程序中的异步HTTP服务器。 可以说，它的特征是C ++模板的广泛使用。 无论是在实施中还是在公共API中。 


 RESTinio中的C ++模板得到了如此积极的使用，以至于第一篇在Habr上谈论RESTinio的文章被称为“ 在具有人...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们正在RESTinio中构建C ++模板的第四层。 为什么以及如何？</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456632/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RESTinio</a>是一个相对较小的项目，它是内置在C ++应用程序中的异步HTTP服务器。 可以说，它的特征是C ++模板的广泛使用。 无论是在实施中还是在公共API中。 </p><br><p>  RESTinio中的C ++模板得到了如此积极的使用，以至于第一篇在Habr上谈论RESTinio的文章被称为“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在具有人脸的嵌入式异步HTTP服务器的实现中的三层C ++模板</a> ”。 </p><br><p> 三层模板。 总体而言，这不是一个比喻。 </p><br><p> 最近，我们再次更新了RESTinio，并将新功能添加到版本0.5.1中，我们不得不使模板的“层数”更高。 因此，在某些地方，RESTinio中的C ++模板已经是四层楼了。 </p><br><p><img src="https://habrastorage.org/webt/vz/t3/vw/vzt3vwbp8snyu3y7hhrcr6crela.jpeg"></p><br><p> 如果有人想知道为什么我们需要它以及我们如何使用模板，然后与我们呆在一起，那么削减中会有一些细节。 熟练的C ++专家不太可能为自己找到任何新东西，但是较不高级的C ++昵称将能够看到如何使用模板来插入/删除功能。 几乎在野外。 </p><a name="habracut"></a><br><h1 id="slushatel-sostoyaniya-podklyucheniy"> 连接状态监听器 </h1><br><p> 创建版本0.5.1的主要功能是能够通知用户与HTTP服务器的连接状态已更改的功能。 例如，客户端“下降”，这使得不必处理仍在排队等待的来自该客户端的请求。 </p><br><p> 有时我们被问到这个功能，现在我们已经实现了它。 但是因为 并不是每个人都问这个功能，有人认为它应该是可选的：如果某些用户需要它，那么让它明确包含它，其余所有在RESTinio中都不需付出任何代价。 </p><br><p> 并且由于RESTinio中HTTP服务器的主要特征是通过“特征”设置的，因此决定通过服务器属性启用/禁用侦听连接状态。 </p><br><h2 id="kak-polzovatel-zadaet-sobstvennogo-slushatelya-sostoyaniya-podklyucheniy"> 用户如何为连接状态设置自己的侦听器？ </h2><br><p> 为了将您的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">侦听器</a>设置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为连接状态，</a>用户必须执行三个步骤。 </p><br><p> 步骤＃1：定义您自己的类，该类应具有以下形式的非静态state_changed方法： </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::connection_state::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">notice_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; notice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>;</code> </pre> <br><p> 例如，可能是这样的： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_state_listener</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex lock_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::connection_state::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">notice_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; notice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; l{lock_}; .... } ... };</code> </pre> <br><p> 步骤2：在服务器属性中，您需要定义一个名为<code>connection_state_listener_t</code>的typedef，它应引用在步骤1中创建的类型的名称： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = my_state_listener; };</code> </pre> <br><p> 因此，在启动HTTP服务器时应使用以下属性： </p><br><pre> <code class="cpp hljs">restinio::run(restinio::on_thread_pool&lt;my_traits&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>)...);</code> </pre> <br><p> 步骤＃3：用户必须创建其侦听器的实例，并将此指针通过服务器参数中的shared_ptr传递： </p><br><pre> <code class="cpp hljs">restinio::run( restinio::on_thread_pool&lt;my_traits&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>) .port(<span class="hljs-number"><span class="hljs-number">8080</span></span>) .address(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) .request_handler(...) .connection_state_listener(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;my_state_listener&gt;(...)) ) );</code> </pre> <br><p> 如果用户未调用<code>connection_state_listener</code>方法，则在启动HTTP服务器时将引发异常：如果用户希望使用状态侦听器但未指定此侦听器，则North无法工作。 </p><br><h3 id="a-esli-ne-zadavat-connection_state_listener_t"> 如果不设置connection_state_listener_t？ </h3><br><p> 如果用户在服务器属性中设置<code>connection_state_listener_t</code>名称，则他必须调用<code>connection_state_listener</code>方法来设置服务器参数。 但是，如果用户未指定<code>connection_state_listener_t</code> ？ </p><br><p> 在这种情况下， <code>connection_state_listener_t</code>名称仍将出现在服务器属性中，但是该名称将指向特殊类型<code>restinio::connection_state::noop_listener_t</code> 。 </p><br><p> 实际上，会发生以下情况：在RESTinio中，定义常规特征时，将设置值<code>connection_state_listener_t</code> 。 类似于： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> restinio { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">default_traits_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">time_manager_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">asio_time_manager_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">null_logger_t</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = connection_state::<span class="hljs-keyword"><span class="hljs-keyword">noop_listener_t</span></span>; }; } <span class="hljs-comment"><span class="hljs-comment">/* namespace restinio */</span></span></code> </pre> <br><p> 并且当用户从<code>restinio::default_traits_t</code>继承时， <code>restinio::default_traits_t</code>的标准定义也<code>connection_state_listener_t</code>被继承。 但是，如果在后续类中定义了新名称<code>connection_state_listener_t</code> ： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = my_state_listener; ... };</code> </pre> <br><p> 然后新名称将隐藏对<code>connection_state_listener_t</code>的继承定义。 如果没有新定义，则旧定义仍然可见。 </p><br><p> 因此，如果用户未为<code>connection_state_listener_t</code>定义自己的值，则RESTinio将使用默认值<code>noop_listener_t</code> ，该值由RESTinio以特殊方式处理。 例如： </p><br><ul><li> 在这种情况下，RESTinio根本不为<code>connection_state_listener_t</code>存储shared_ptr。 因此，禁止调用<code>connection_state_listener</code>方法（这样的调用将导致编译时错误）。 </li><li>  RESTinio不会进行与更改连接状态有关的任何其他调用。 </li></ul><br><p> 以及关于如何实现所有这些的内容，将在下面进行讨论。 </p><br><h2 id="kak-eto-realizovano-v-restinio"> 如何在RESTinio中实现？ </h2><br><p> 因此，在RESTinio代码中，您需要检查<code>connection_state_listener_t</code>的定义在服务器属性中<code>connection_state_listener_t</code>什么值，并且取决于此值： </p><br><ul><li> 存储或不存储<code>connecton_state_listener_t</code>类型的对象的shared_ptr实例； </li><li> 允许或禁止调用<code>connection_state_listener</code>方法来设置HTTP服务器参数； </li><li> 在开始HTTP服务器操作之前，检查或不检查是否存在指向<code>connection_state_listener_t</code>类型的对象的当前指针； </li><li> 当与客户端的连接状态更改时，对<code>state_changed</code>方法进行或不进行调用。 </li></ul><br><p>  RESTinio仍在作为C ++ 14库开发的边界条件上也添加了它，因此，您不能在实现中使用C ++ 17的功能（如果使用constexpr，则相同）。 </p><br><p> 所有这些都是通过简单的技巧实现的：模板类及其对<code>restinio::connection_state::noop_listener_t</code>类型的<code>restinio::connection_state::noop_listener_t</code> 。 例如，这是服务器参数中类型为<code>connection_state_listener_t</code>的对象的shared_ptr存储方式。 第一部分： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Listener &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_state_listener_holder_t</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//  compile-time . std::shared_ptr&lt; Listener &gt; m_connection_state_listener; static constexpr bool has_actual_connection_state_listener = true; void check_valid_connection_state_listener_pointer() const { if( !m_connection_state_listener ) throw exception_t{ "connection state listener is not specified" }; } }; template&lt;&gt; struct connection_state_listener_holder_t&lt; connection_state::noop_listener_t &gt; { static constexpr bool has_actual_connection_state_listener = false; void check_valid_connection_state_listener_pointer() const { // Nothing to do. } };</span></span></code> </pre> <br><p> 此处定义的模板结构具有有用的内容或没有有用的内容。 仅对于类型<code>noop_listener_t</code> ，它没有有用的内容。 </p><br><p> 第二部分： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Derived, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_server_settings_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">socket_type_dependent_settings_t</span></span>&lt; Derived, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">stream_socket_t</span></span> &gt; , <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; , <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ip_blocker_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">ip_blocker_t</span></span> &gt; { ... };</code> </pre> <br><p> 包含HTTP服务器参数的类是从<code>connection_state_listener_holder_t</code>继承的。 因此，服务器参数要么显示<code>connection_state_listener_t</code>类型的对象的shared_ptr，要么不显示。 </p><br><p> 我必须说在参数中存储或不存储shared_ptr都是鲜花。 但是，只有当<code>connection_state_listener_t</code>与<code>noop_listener_t</code>不同时，尝试使<code>basic_server_settings_t</code>用于状态侦听器的方法可用时，浆果才<code>noop_listener_t</code> 。 </p><br><p> 理想情况下，我想使编译器“根本看不到”。 但是我很痛苦地为<code>std::enable_if</code>编写条件以隐藏这些方法。 因此，只限于添加static_asser： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Derived &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Traits::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">connection_state_listener_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt; listener )</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( has_actual_connection_state_listener, <span class="hljs-string"><span class="hljs-string">"connection_state_listener(listener) can't be used "</span></span> <span class="hljs-string"><span class="hljs-string">"for the default connection_state::noop_listener_t"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_connection_state_listener = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(listener); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference_to_derived(); } <span class="hljs-function"><span class="hljs-function">Derived &amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Traits::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">connection_state_listener_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt; listener )</span></span></span><span class="hljs-function"> &amp;&amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;connection_state_listener(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(listener))); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; &amp; connection_state_listener() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( has_actual_connection_state_listener, <span class="hljs-string"><span class="hljs-string">"connection_state_listener() can't be used "</span></span> <span class="hljs-string"><span class="hljs-string">"for the default connection_state::noop_listener_t"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_connection_state_listener; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ensure_valid_connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;check_valid_connection_state_listener_pointer(); }</code> </pre> <br><p> 只是有一瞬间，我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">碰巧后悔在C ++中，如果constexpr与在D中的static不同，那么</a>我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">感到很遗憾。</a> 通常在C ++ 14中没有类似的东西:( </p><br><p> 在这里，您还可以查看<code>ensure_valid_connection_state_listener</code>方法的可用性。 在<code>http_server_t</code>构造函数中调用此方法，以验证服务器参数是否包含所有必需的值： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">http_server_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">io_context_holder_t</span></span> io_context, <span class="hljs-keyword"><span class="hljs-keyword">basic_server_settings_t</span></span>&lt; D, Traits &gt; &amp;&amp; settings ) : m_io_context{ io_context.giveaway_context() } , m_cleanup_functor{ settings.giveaway_cleanup_func() } { <span class="hljs-comment"><span class="hljs-comment">// Since v.0.5.1 the presence of custom connection state // listener should be checked before the start of HTTP server. settings.ensure_valid_connection_state_listener(); ...</span></span></code> </pre> <br><p> 同时，在<code>ensure_valid_connection_state_listener</code>内部<code>ensure_valid_connection_state_listener</code>了从<code>connection_state_listener_holder_t</code>继承<code>ensure_valid_connection_state_listener</code>方法，由于<code>connection_state_listener_holder_t</code>专门化，因此该方法要么进行实际检查，要么不执行任何操作。 </p><br><p> 如果用户要使用状态侦听器，则使用类似的技巧来调用当前的<code>state_changed</code> ，否则不调用任何其他方法。 </p><br><p> 首先，我们需要另一个<code>state_listener_holder_t</code>选项： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> connection_settings_details { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Listener &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_listener_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; Listener &gt; m_connection_state_listener; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Settings &amp; settings ) : m_connection_state_listener{ settings.connection_state_listener() } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Lambda &amp;&amp; lambda )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ m_connection_state_listener-&gt;state_changed( lambda() ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_listener_holder_t</span></span></span><span class="hljs-class">&lt; connection_state::noop_listener_t &gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Settings &amp; ) { <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Lambda &amp;&amp; </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*lambda*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } }; } <span class="hljs-comment"><span class="hljs-comment">/* namespace connection_settings_details */</span></span></code> </pre> <br><p> 与之前显示的用来在整个服务器的参数中（即在<code>basic_server_settings_t</code>类型的对象中）存储连接状态侦听器的connection_state_listener_holder_t不同，该<code>state_listener_holder_t</code>将用于类似目的，而不是用于整个服务器的参数，而是用于单独的服务器连接： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_settings_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt; <span class="hljs-keyword"><span class="hljs-keyword">connection_settings_t</span></span>&lt; Traits &gt; &gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> connection_settings_details::<span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span> = connection_settings_details::<span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt;; ...</code> </pre> <br><p> 这里有两个功能。 </p><br><p> 首先，初始化<code>state_listener_holder_t</code> 。 是否需要它。 但是只有<code>state_listener_holder_t</code>知道这一点。 因此，正如他们所说，为<code>state_listener_holder_t</code> ， <code>connection_settings_t</code>构造函数只是简单地“拉” <code>state_listener_holder_t</code>构造函数： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">connection_settings_t</span></span>( Settings &amp;&amp; settings, http_parser_settings parser_settings, <span class="hljs-keyword"><span class="hljs-keyword">timer_manager_handle_t</span></span> timer_manager ) : <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span>{ settings } , m_request_handler{ settings.request_handler() }</code> </pre> <br><p> 而且<code>state_listener_holder_t</code>构造函数<code>state_listener_holder_t</code>要么执行必要的操作，要么什么都不做（在后一种情况下，或多或少明智的编译器将根本不生成任何代码来初始化<code>state_listener_holder_t</code> ）。 </p><br><p> 其次，是<code>state_listner_holder_t::call_state_listener</code> ，它对状态侦听器进行<code>state_changed</code>调用。 如果没有状态侦听器，则为否。 在RESTinio诊断连接状态更改的地方<code>call_state_listener</code>此<code>call_state_listener</code> 。 例如，当检测到连接已关闭时： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_logger.trace( [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt::format( <span class="hljs-string"><span class="hljs-string">"[connection:{}] close"</span></span>, connection_id() ); } ); ... <span class="hljs-comment"><span class="hljs-comment">// Inform state listener if it used. m_settings-&gt;call_state_listener( [this]() noexcept { return connection_state::notice_t{ this-&gt;connection_id(), this-&gt;m_remote_endpoint, connection_state::cause_t::closed }; } ); }</span></span></code> </pre> <br><p> 将<code>call_state_listener</code>传递给<code>call_state_listener</code> ，从该<code>call_state_listener</code>返回带有连接状态信息的<code>notice_t</code>对象。 如果存在实际的侦听器，则确实会调用此lambda，并将其返回的值传递给<code>state_changed</code> 。 </p><br><p> 但是，如果没有侦听器，则<code>call_state_listener</code>将为空，因此不会调用任何lambda。 实际上，普通的编译器只是将所有调用都抛出一个空的<code>call_state_listener</code> 。 在这种情况下，在生成的代码中，根本没有任何内容与侦听器正在访问的连接状态有关。 </p><br><h1 id="esche-i-ip-blocker"> 也是IP拦截器 </h1><br><p> 在RESTinio-0.5.1中，除了连接状态侦听器之外，还添加了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IP阻止程序</a> 。 即 用户可以为每个新的传入连接指定RESTinio将“拉”的对象。 如果IP阻止程序说您可以使用该连接，则RESTinio将开始对新连接的常规维护（它将读取和解析请求，调用请求处理程序，控制超时等）。 但是，如果IP阻止程序禁止使用该连接，则RESTinio会愚蠢地关闭此连接，并且不再执行任何操作。 </p><br><p> 像状态侦听器一样，IP阻止程序是一项可选功能。 要使用IP阻止程序，必须明确启用它。 通过HTTP服务器的属性。 就像连接状态监听器一样。  RESTinio中IP阻止程序支持的实现使用了上面已经描述的相同技术。 因此，我们将不讨论在RESTinio中如何使用IP阻止程序。 而是考虑一个IP阻止程序和状态侦听器都是同一对象的示例。 </p><br><h2 id="razbor-shtatnogo-primera-ip_blocker"> 分析标准示例ip_blocker </h2><br><p> 在版本0.5.1中，标准RESTinio示例中包括另一个示例： <a href="">ip_blocker</a> 。 本示例演示如何限制从单个IP地址到服务器的并发连接数。 </p><br><p> 这不仅需要一个IP阻止程序，它可以允许或禁止接受连接。 而且还是连接状态的监听器。 需要一个侦听器以跟踪创建和关闭连接的时刻。 </p><br><p> 同时，IP阻止程序和侦听器将需要相同的数据集。 因此，最简单的解决方案是使IP阻止程序和侦听器成为同一对象。 </p><br><p> 没问题，我们可以轻松做到这一点： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blocker_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m_lock; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connections_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt; restinio::asio_ns::ip::address, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; restinio::<span class="hljs-keyword"><span class="hljs-keyword">connection_id_t</span></span> &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">connections_t</span></span> m_connections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   IP-blocker-. restinio::ip_blocker::inspection_result_t inspect( const restinio::ip_blocker::incoming_info_t &amp; info ) noexcept {...} //     . void state_changed( const restinio::connection_state::notice_t &amp; notice ) noexcept {...} };</span></span></code> </pre> <br><p> 在这里，我们没有任何接口的继承或继承的虚方法的替代。 侦听器的唯一要求是<code>state_changed</code>方法的存在。 满足此要求。 </p><br><p> 同样，对于IP阻止程序的唯一要求是：是否存在带有所需签名的<code>inspect</code>方法？ 有！ 所以一切都很好。 </p><br><p> 然后剩下的就是确定HTTP服务器的正确属性： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = restinio::<span class="hljs-keyword"><span class="hljs-keyword">shared_ostream_logger_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      . using connection_state_listener_t = blocker_t; using ip_blocker_t = blocker_t; };</span></span></code> </pre> <br><p> 之后，仅保留创建<code>blocker_t</code>的实例并将其作为参数传递给HTTP服务器： </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> blocker = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">blocker_t</span></span>&gt;(); restinio::run( ioctx, restinio::on_thread_pool&lt;<span class="hljs-keyword"><span class="hljs-keyword">my_traits_t</span></span>&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::hardware_concurrency() ) .port( <span class="hljs-number"><span class="hljs-number">8080</span></span> ) .address( <span class="hljs-string"><span class="hljs-string">"localhost"</span></span> ) .connection_state_listener( blocker ) .ip_blocker( blocker ) .max_pipelined_requests( <span class="hljs-number"><span class="hljs-number">4</span></span> ) .handle_request_timeout( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">20</span></span>} ) .request_handler( [&amp;ioctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler( ioctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req) ); } ) );</code> </pre> <br><h1 id="zaklyuchenie"> 结论 </h1><br><h2 id="o-cnyh-shablonah"> 关于C ++模板 </h2><br><p> 在我看来，C ++模板就是所谓的“大炮”。 即 如此强大的功能，您不由自主地必须考虑如何合理地使用它。 因此，现代C ++社区似乎被划分为多个交战阵营。 </p><br><p> 其中之一的代表希望远离模板。 因为模板很复杂，所以它们会生成无法读取的错误消息表的长度，从而大大增加了编译时间。 更不用说关于膨胀代码和降低性能的城市传说了。 </p><br><p> 另一个阵营的代表（如我）相信模板是C ++最强大的方面之一。 模板甚至有可能是C ++在现代世界中为数不多的最重要的竞争优势之一。 因此，我认为C ++的未来正是模板。 随着时间的流逝，与模板广泛使用相关的一些当前不便（例如冗长而耗费资源的编译或无信息的错误消息）将被消除。 </p><br><p> 因此，在我个人看来，在RESTinio的实现过程中选择的方法（即模板的广泛使用和通过属性设置HTTP服务器的特征）仍然会奏效。 因此，我们可以针对特定需求进行良好的自定义。 同时，从字面上看，我们不为不使用的商品付费。 </p><br><p> 但是，另一方面，似乎C ++模板中的编程仍然不合理地复杂。 当您不必经常编程时，而是在不同活动之间进行切换时，您会特别感到。 您将因编码而分心数周，然后您将返回并开始公开地公开表示自己（如果有必要的话），然后使用SFINAE隐藏某种方法，或者检查对象上是否存在具有特定签名的方法。 </p><br><p> 因此，最好使用C ++。 如果使它们达到这样的状态，甚至像我这样的初学者也可以轻松地使用C ++模板，而不必每隔10-15分钟研究cppreference和stackoverflow，那就更好了。 </p><br><h2 id="o-tekuschem-sostoyanii-restinio-i-buduschey-funkcionalnosti-restinio-i-ne-tolko-restinio"> 关于RESTinio的当前状态和RESTinio的未来功能。 不仅是RESTinio </h2><br><p> 目前，RESTinio正在基于“有时间有心愿单”的原则进行开发。 例如，在2018年秋季和2019年冬季，我们没有太多时间来开发RESTinio。 他们回答了用户的问题，进行了较小的更改，但是对于更多的事情，我们的资源还不够。 </p><br><p> 但是在2019年春末，有时间使用RESTinio，我们首先将RESTinio设置为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">0.5.0</a> ，然后是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">0.5.1</a> 。 同时，我们和其他人的愿望清单的供应已用尽。 即 我们自己希望在RESTinio中看到的内容以及用户告诉我们的内容已经在RESTinio中。 </p><br><p> 显然，RESTinio可以填充更多内容。 但是到底是什么呢？ </p><br><p> 答案很简单：只有我们被要求进入RESTinio。 因此，如果您想在RESTinio中看到自己需要的东西，那么花点时间告诉我们（例如，通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BitBucket</a>上的问题，或者通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google小组</a> ，或者直接在Habré上的评论中） 。 你什么也不会说-你什么也不会收到;） </p><br><p> 实际上，其他项目，尤其是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SObjectizer</a> ，情况也是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如此</a> 。 他们的新版本将在收到可理解的愿望清单后发布。 </p><br><p> 好吧，最后，我想向尚未尝试过RESTinio的所有人提供：尝试一下 <del> 免费的 </del> 不伤人。 突然喜欢上它。 如果您不喜欢它，请准确分享。 这将帮助我们使RESTinio更加方便和实用。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN456632/">https://habr.com/ru/post/zh-CN456632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN456616/index.html">可以编码的人三百万卢布</a></li>
<li><a href="../zh-CN456618/index.html">莫斯科拉腊贝尔-6月21日</a></li>
<li><a href="../zh-CN456622/index.html">如何创建根据I类保护认证的OS</a></li>
<li><a href="../zh-CN456624/index.html">有用的Python工具</a></li>
<li><a href="../zh-CN456630/index.html">引入Airflow在ivi中管理Spark作业：希望与拐杖</a></li>
<li><a href="../zh-CN456634/index.html">Nginx食谱：CAS（中央授权服务）</a></li>
<li><a href="../zh-CN456638/index.html">在Rust，Haskell，C ++，Python，Scala和OCaml中比较同一项目</a></li>
<li><a href="../zh-CN456640/index.html">PHDays 9的竞争情报竞赛分析</a></li>
<li><a href="../zh-CN456642/index.html">JetBrains企业硕士课程和ITMO大学的首届毕业</a></li>
<li><a href="../zh-CN456644/index.html">更长的低成本3D照片聚合物打印机出现在Kickstarter上</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>