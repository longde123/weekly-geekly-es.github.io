<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåà üëÜüèª üè¥‚Äç‚ò†Ô∏è Emballage d'applications ASP.NET Core √† l'aide de Docker ü§ï üë®‚Äçüë®‚Äçüëß‚Äçüëß üìΩÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les applications ASP.NET Core sont v√©ritablement multiplateformes et peuvent s'ex√©cuter dans des nix et, en cons√©quence, dans Docker. Voyons comment i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Emballage d'applications ASP.NET Core √† l'aide de Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/435914/"><p>  Les applications ASP.NET Core sont v√©ritablement multiplateformes et peuvent s'ex√©cuter dans des nix et, en cons√©quence, dans Docker.  Voyons comment ils peuvent √™tre empaquet√©s pour √™tre d√©ploy√©s sur Linux et utilis√©s en conjonction avec Nginx.  D√©tails sous la coupe! </p><br><p><img src="https://habrastorage.org/webt/rv/zy/xx/rvzyxxq8mg8yreoka2rkkukpr3i.jpeg"><a name="habracut"></a></p><br><p>  <em>Remarque: nous continuons la s√©rie de publications de versions compl√®tes d'articles du magazine Hacker.</em>  <em>Orthographe et ponctuation de l'auteur enregistr√©es.</em> </p><br><h2>  √Ä propos de Docker </h2><br><p>  Presque tout le monde a entendu parler de l'architecture des microservices.  Le concept de diviser l'application en plusieurs parties ne signifie pas qu'elle est nouvelle.  Mais, le nouveau est l'ancien bien oubli√© et recycl√©. </p><br><p>  Si vous essayez de parler d'architecture en quelques mots, l'application Web est divis√©e en parties unitaires distinctes - services.  Les services n'interagissent pas directement entre eux et n'ont pas de bases de donn√©es communes.  Ceci est fait pour pouvoir changer chaque service sans cons√©quences pour les autres.  Les services sont conditionn√©s dans des conteneurs.  Parmi les conteneurs, Docker gouverne le ballon. </p><br><p>  Pour d√©crire ce que Docker est tr√®s souvent simplifi√©, utilisez le terme "machine virtuelle".  Il y a certainement une similitude, mais il est faux de le dire.  La fa√ßon la plus simple de comprendre cette diff√©rence est de regarder les images suivantes de la documentation officielle de docker: </p><br><p><img src="https://habrastorage.org/webt/xf/os/nu/xfosnujlxyttzdhimiuzf8tmcd8.png"></p><br><p><img src="https://habrastorage.org/webt/w4/y4/6e/w4y46e4boi3u-l8pwo70rs-7xmm.png"></p><br><p>  Les conteneurs utilisent le c≈ìur du syst√®me d'exploitation actuel et le partagent entre eux.  Alors que les machines virtuelles utilisant l'hyperviseur utilisent des ressources mat√©rielles. <br>  Docker Image est un objet en lecture seule qui stocke essentiellement un mod√®le pour la construction d'un conteneur.  Un conteneur est un environnement dans lequel le code est ex√©cut√©.  Les images sont stock√©es dans des r√©f√©rentiels.  Par exemple, le r√©f√©rentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker Hub</a> officiel vous permet de stocker une seule image en priv√©.  Cependant, c'est gratuit, donc m√™me pour cela, vous devez les remercier. </p><br><h1>  INFO </h1><br><p>  Docker n'est pas le seul repr√©sentant de la conteneurisation.  En plus de cela, il existe d'autres technologies.  Par exemple: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rkt</a> (prononc√© 'rocket') par CoreOS </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LXD</a> (prononc√© 'lexdi') par Ubuntu </p><br><p>  Conteneurs Windows - vous ne devinerez jamais personne. </p><br><p>  Maintenant que nous nous sommes familiaris√©s avec la th√©orie, passons √† la pratique. </p><br><p>  Il est inutile de d√©monter l'installation de docker, car elle peut √™tre install√©e sur de nombreux syst√®mes d'exploitation.  Je vais seulement indiquer que vous pouvez le t√©l√©charger pour votre plate-forme √† partir du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker Store</a> .  Si vous installez Docker sous Windows, la virtualisation doit √™tre activ√©e dans le BIOS et le syst√®me d'exploitation.  Vous pouvez lire comment l'activer en 10 ke dans l'article suivant: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Installation d'Hyper-V dans Windows10</a> </p><br><h2>  Cr√©ation d'un projet compatible Docker </h2><br><p> Docker est, bien s√ªr, un produit Linux, mais si n√©cessaire, vous pouvez l'utiliser lors du d√©veloppement pour Mac ou pour Windows.  Lors de la cr√©ation d'un projet dans Visual Studio, pour ajouter la prise en charge de docker, cochez simplement la case Activer la prise en charge de docker. </p><br><p>  La prise en charge de Docker peut √™tre ajout√©e √† un projet existant.  Il est ajout√© au projet de la m√™me mani√®re que divers nouveaux composants sont ajout√©s.  Menu contextuel Ajouter - Support Docker. </p><br><p>  Si Docker est install√© et fonctionne sur votre machine, la console sera automatiquement ouverte et la commande sera ex√©cut√©e </p><br><pre><code class="lua hljs">docker pull microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span></code> </pre> <br><p>  qui d√©marre le processus de t√©l√©chargement de l'image.  Cette image est en fait un blanc sur la base duquel votre image sera cr√©√©e.  ASP.NET Core 2.1 utilise une image diff√©rente - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Microsoft / Dotnet: SDK</a> </p><br><p>  Les fichiers suivants seront automatiquement cr√©√©s dans le r√©pertoire avec la solution pour vous: <br>  .dockerignore (√† l'exclusion des fichiers et r√©pertoires de l'image docker), docker-compose.yml (√† l'aide de ce fichier, vous pouvez configurer l'ex√©cution de plusieurs services), docker-compose.override.yml (configuration auxiliaire docker-compose), docker-compose.dcproj ( fichier de projet pour Visual Studio). </p><br><p>  Un fichier Dockerfile sera cr√©√© dans le r√©pertoire du projet.  En fait, avec l'aide de ce fichier, nous cr√©ons notre image.  Par d√©faut (dans le cas o√π le projet s'appelle DockerServiceDemo), il peut ressembler √† ceci: </p><br><pre> <code class="java hljs">FROM microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> FROM microsoft/aspnetcore-build:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS build WORKDIR /src COPY DockerServiceDemo/DockerServiceDemo.csproj DockerServiceDemo/ RUN dotnet restore DockerServiceDemo/DockerServiceDemo.csproj COPY . . WORKDIR /src/DockerServiceDemo RUN dotnet build DockerServiceDemo.csproj -c Release -o /app FROM build AS publish RUN dotnet publish DockerServiceDemo.csproj -c Release -o /app FROM base AS <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WORKDIR /app COPY --from=publish /app . ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"dotnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"DockerServiceDemo.dll"</span></span>]</code> </pre> <br><p>  La configuration initiale de .NET Core 2.0 ne vous permettra pas de cr√©er imm√©diatement l'image √† l'aide de la commande docker build.  Il est configur√© pour lancer le fichier docker-compose √† partir d'un r√©pertoire d'un niveau sup√©rieur.  Pour que la construction se d√©roule correctement, le Dockerfile peut √™tre amen√© √† un aspect similaire: </p><br><pre> <code class="java hljs">FROM microsoft/aspnetcore:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> FROM microsoft/aspnetcore-build:<span class="hljs-number"><span class="hljs-number">2.0</span></span> AS build WORKDIR /src COPY DockerServiceDemo.csproj DockerServiceDemo.csproj RUN dotnet restore DockerServiceDemo.csproj COPY . . WORKDIR /src RUN dotnet build DockerServiceDemo.csproj -c Release -o /app FROM build AS publish RUN dotnet publish DockerServiceDemo.csproj -c Release -o /app FROM base AS <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> WORKDIR /app COPY --from=publish /app . ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"dotnet"</span></span>, <span class="hljs-string"><span class="hljs-string">"DockerServiceDemo.dll"</span></span>]</code> </pre> <br><p>  Tout ce que j'ai fait, c'est supprimer le r√©pertoire DockerServiceDemo suppl√©mentaire. </p><br><p>  Si vous utilisez Visual Studio Code, vous devrez g√©n√©rer les fichiers manuellement.  Bien que VS Code ait des fonctionnalit√©s auxiliaires sous la forme d‚Äôune extension <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Docker</a> , j‚Äôajouterai un lien vers le manuel sur la fa√ßon de travailler avec le docker √† partir de VS Code - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Travailler avec Docker</a> .  Oui, l'article est en anglais, mais c'est avec des photos </p><br><h2>  Docker √† trois accords </h2><br><p>  Pour le travail quotidien avec le docker, quelques commandes suffisent √† retenir. </p><br><p>  L'√©quipe la plus importante est bien s√ªr de construire une image.  Pour ce faire, vous devez utiliser bash / CMD / PowerShell pour aller dans le r√©pertoire o√π se trouve le Dockerfile et ex√©cuter la commande: </p><br><pre> <code class="python hljs">docker build -t your_image_name .</code> </pre> <br><p>  Ici, apr√®s l'option -t, le nom de votre image est d√©fini.  Attention - √† la fin de la commande, un espace apr√®s l'espace.  Ce point signifie que le r√©pertoire courant est utilis√©.  Une image peut √™tre √©tiquet√©e avec une √©tiquette (num√©ro ou nom).  Pour ce faire, placez deux points apr√®s le nom et sp√©cifiez une balise.  Si la balise n'est pas sp√©cifi√©e, par d√©faut, elle sera d√©finie avec le nom le plus r√©cent.  Pour envoyer une image au r√©f√©rentiel, il est n√©cessaire que le nom de l'image inclue le nom du r√©f√©rentiel.  Quelque chose comme √ßa: </p><br><pre> <code class="python hljs">docker build -t docker_account_name/image_name:your_tag .</code> </pre> <br><p>  Ici, your_docker_account_name est le nom de votre compte Docker Hub. </p><br><p>  Si vous avez cr√©√© l'image uniquement avec un nom local qui n'inclut pas le r√©f√©rentiel, vous pouvez marquer l'image avec un nom diff√©rent apr√®s la construction √† l'aide de la commande suivante: </p><br><pre> <code class="python hljs">docker tag image_name docker_account_name/image_name:your_tag</code> </pre> <br><p>  Pour envoyer des modifications au concentrateur, vous devez maintenant ex√©cuter la commande suivante: </p><br><pre> <code class="python hljs">docker push docker_account_name/image_name:your_tag</code> </pre> <br><p>  Avant cela, vous devez vous connecter √† votre compte Docker.  Sous Windows, cela se fait √† partir de l'interface utilisateur de l'application, mais sur * nix, cela se fait avec la commande: </p><br><pre> <code class="python hljs">docker login</code> </pre> <br><p>  En fait, trois √©quipes ne suffisent pas.  Vous devez √©galement √™tre en mesure de v√©rifier le fonctionnement du conteneur.  La commande avec laquelle vous pouvez d√©marrer le conteneur ressemble √† ceci: </p><br><pre> <code class="python hljs">docker run -it -p <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> image_name</code> </pre> <br><p>  L'option -it cr√©era un pseudo-ATS et votre conteneur r√©pondra aux demandes.  Apr√®s avoir ex√©cut√© la commande, le service sera disponible sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 5000 /</a> </p><br><p>  -p 5000: 80 associe le port 5000 du conteneur au port 80 de l'h√¥te. </p><br><p>  De plus, il existe de telles commandes: </p><br><pre> <code class="python hljs">docker ps ‚Äìa</code> </pre> <br><p>  Vous montrer une liste de conteneurs.  Depuis que le commutateur -a a √©t√© ajout√©, tous les conteneurs seront affich√©s, pas seulement ceux qui sont en cours d'ex√©cution. </p><br><pre> <code class="python hljs">docker rm container_name</code> </pre> <br><p>  Cette commande supprimera le conteneur nomm√© nom_conteneur.  rm - court pour supprimer </p><br><pre> <code class="python hljs">docker logs container_name</code> </pre> <br><p>  Afficher les journaux des conteneurs </p><br><pre> <code class="python hljs">docker rmi image_name</code> </pre> <br><p>  Supprime une image nomm√©e image_name </p><br><h2>  Lancement d'un conteneur via un serveur proxy inverse </h2><br><p>  Le fait est que les applications .NET Core elles-m√™mes utilisent leur serveur Web Kestrel.  Ce serveur n'est pas recommand√© pour la production.  Pourquoi?  Il y a plusieurs explications. <br>  S'il y a plusieurs applications qui partagent IP et port, alors Kestrel ne pourra pas distribuer le trafic.  De plus, le serveur proxy inverse fournit une couche de s√©curit√© suppl√©mentaire, simplifie l'√©quilibrage de charge et les param√®tres SSL, et s'int√®gre √©galement mieux dans l'infrastructure existante.  Pour la plupart des d√©veloppeurs, la raison la plus importante du besoin de procurations inverses est une s√©curit√© suppl√©mentaire. </p><br><p>  Tout d'abord, restaurez la configuration Dockerfile d'origine.  Apr√®s cela, nous traiterons le fichier docker-compose.yml et essaierons d'ex√©cuter notre service seul.  Le format de fichier yml est lu comme "yaml" et est une abr√©viation de "Yet Another Markup Language", ou de "YAML Ain't Markup Language".  Soit un autre langage de balisage, soit pas du tout un langage de balisage.  D'une mani√®re ou d'une autre, tout n'est pas certain. </p><br><p>  Mon fichier docker-compose par d√©faut ressemble √† ceci: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile</code> </pre> <br><p>  Le fichier docker-compose.override.yml ajoute plusieurs param√®tres √† la configuration: <br>  version: '3.4' </p><br><pre> <code class="python hljs">services: dockerservicedemo: environment: - ASPNETCORE_ENVIRONMENT=Development ports: - <span class="hljs-string"><span class="hljs-string">"80"</span></span></code> </pre> <br><p>  Nous pouvons construire la solution cr√©√©e en utilisant la construction docker-compose, en appelant la commande docker-compose up, nous lancerons notre conteneur.  Est-ce que tout fonctionne?  Passez ensuite √† l'√©tape suivante.  Cr√©ez le fichier nginx.info.  La configuration sera approximativement la suivante: </p><br><pre> <code class="python hljs">worker_processes <span class="hljs-number"><span class="hljs-number">4</span></span>; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; } http { sendfile on; upstream app_servers { server dockerservicedemo:<span class="hljs-number"><span class="hljs-number">80</span></span>; } server { listen <span class="hljs-number"><span class="hljs-number">80</span></span>; location / { proxy_pass http://app_servers; proxy_http_version <span class="hljs-number"><span class="hljs-number">1.1</span></span>; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } }</code> </pre> <br><p>  Ici, nous indiquons que nginx √©coutera sur le port 80 (√©couter 80;).  Et les demandes re√ßues seront redirig√©es vers le 80e port de l'h√¥te dans le conteneur dockerservicedemo.  De plus, nous indiquons √† nginx les en-t√™tes √† transmettre. </p><br><p>  Nous pouvons utiliser http dans nginx et acc√©der au site Web via https.  Lorsqu'une demande https passe par un proxy http, de nombreuses informations provenant de https ne sont pas transmises √† http.  De plus, lors de l'utilisation d'un proxy, l'adresse IP externe est perdue.  Pour que ces informations soient transmises dans les en-t√™tes, vous devez modifier le code de notre projet ASP.NET et ajouter le code suivant au d√©but de la m√©thode Configure du fichier Startup.cs: </p><br><pre> <code class="python hljs"> app.UseForwardedHeaders(new ForwardedHeadersOptions { ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto });</code> </pre> <br><p>  La plupart des serveurs proxy utilisent les en-t√™tes X-Forwarded-For et X-Forwarded-Proto.  Ce sont ces en-t√™tes qui sont sp√©cifi√©s maintenant dans la configuration nginx. </p><br><p>  Incluez maintenant l'image nginx et le fichier nginx.conf dans la configuration de doker-compose.  La prudence dans les espaces YAML est importante: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile ports: - <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> proxy: image: nginx:latest volumes: - ./DockerServiceDemo/nginx.conf:/etc/nginx/nginx.conf ports: - <span class="hljs-number"><span class="hljs-number">80</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span></code> </pre> <br><p>  Ici, nous ajoutons des proxys √† notre configuration en tant qu'image nginx.  Nous attachons √† cette image un fichier de param√®tres externes.  Nous le montons en quelque sorte dans le syst√®me de fichiers conteneur en utilisant un m√©canisme appel√© volume.  Si vous ajoutez √† la fin: ro, l'objet sera mont√© en lecture seule. </p><br><p>  Le proxy √©coute le 80e port externe de la machine sur laquelle le conteneur s'ex√©cute et envoie une demande au 80e port interne du conteneur. </p><br><p>  En ex√©cutant la commande doker-compose up, nous allons remplir, c'est-√†-dire extraire l'image nginx du r√©f√©rentiel et d√©marrer notre conteneur avec le conteneur proxy.  Maintenant sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http: // localhost: 80 /</a> il sera accessible via nginx.  Sur le 5000e port, l'application ¬´tourne¬ª √©galement sous Kestrel. </p><br><p>  Nous pouvons v√©rifier que la demande √† l'application Web passe par le proxy inverse.  Ouvrez les outils de d√©veloppement dans le navigateur Chrome et acc√©dez √† l'onglet R√©seau.  Cliquez sur localhost ici et s√©lectionnez l'onglet En-t√™tes. </p><br><p><img src="https://habrastorage.org/webt/zx/xi/sp/zxxisp6hjwtbza8u5wlmgu54jqq.png"></p><br><h2>  Nous lan√ßons le conteneur via des proxys et HTTPS </h2><br><p>  ASP.NET Core 2.1 a apport√© des am√©liorations dans la prise en charge HTTPS. <br>  Supposons que le middleware suivant vous permet de rediriger d'une connexion non s√©curis√©e vers une connexion s√©curis√©e: </p><br><pre> <code class="python hljs">app.UseHttpsRedirection();</code> </pre> <br><p>  Et le suivant vous permet d'utiliser le protocole HTTP Strict Transport Security Protocol - HSTS. </p><br><pre> <code class="python hljs">app.UseHsts();</code> </pre> <br><p>  HSTS est une fonctionnalit√© du protocole HTTP / 2, dont la sp√©cification a √©t√© publi√©e en 2015.  Cette fonctionnalit√© est prise en charge par les navigateurs modernes et informe que le site Web utilise uniquement https.  Ainsi, une protection contre une attaque de d√©classement se produit au cours de laquelle l'attaquant peut profiter de la situation en utilisant la transition vers un protocole http non s√©curis√©.  Par exemple, r√©trograder TLS ou m√™me remplacer un certificat. </p><br><p>  En r√®gle g√©n√©rale, ce type d'attaque est utilis√© en conjonction avec les attaques de l'homme du milieu.  Vous devez savoir et vous rappeler que HSTS ne vous sauve pas d'une situation o√π un utilisateur visite le site en utilisant le protocole http puis redirige vers https.  Il existe la soi-disant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste de pr√©chargement Chrome</a> , qui contient des liens vers des sites prenant en charge https.  D'autres navigateurs (Firefox, Opera, Safari, Edge) prennent √©galement en charge les listes de sites https cr√©√©es √† partir de la liste Chrome.  Mais toutes ces listes sont loin de tous les sites. </p><br><p>  La premi√®re fois que vous ex√©cutez une application Core sous Windows, vous recevrez un message indiquant qu'un certificat de d√©veloppeur a √©t√© cr√©√© et install√©.  En cliquant sur le bouton et en installant le certificat, vous le rendrez ainsi fiable.  √Ä partir de la ligne de commande sur macOS, vous pouvez ajouter une approbation au certificat √† l'aide de la commande: <br>  dotnet dev-certs https ‚Äìtrust </p><br><p>  Si l'utilitaire dev-certs n'est pas install√©, vous pouvez l'installer avec la commande: </p><br><pre> <code class="python hljs">dotnet tool install --<span class="hljs-keyword"><span class="hljs-keyword">global</span></span> dotnet-dev-certs</code> </pre> <br><p>  La fa√ßon d'ajouter un certificat √† Trusted sous Linux d√©pend de la distribution. <br>  √Ä des fins de test, nous utilisons le certificat du d√©veloppeur.  Les actions avec un certificat sign√© par CA sont similaires.  Si vous le souhaitez, vous pouvez utiliser des certificats <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LetsEncrypt</a> gratuits </p><br><p>  Vous pouvez exporter le certificat de d√©veloppeur dans un fichier √† l'aide de la commande </p><br><pre> <code class="python hljs">dotnet dev-certs https -ep ___.pfx</code> </pre> <br><p>  Le fichier doit √™tre copi√© dans le r√©pertoire% APPDATA% / ASP.NET / Https / sous Windows ou dans /root/.aspnet/https/ sous macOS / Linux. </p><br><p>  Pour que le conteneur r√©cup√®re le chemin d'acc√®s au certificat et son mot de passe, cr√©ez des secrets d'utilisateur avec le contenu suivant: </p><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"Kestrel"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Certificates"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Default"</span></span>:{ <span class="hljs-string"><span class="hljs-string">"Path"</span></span>: <span class="hljs-string"><span class="hljs-string">"/root/.aspnet/https/__.pfx"</span></span>, <span class="hljs-string"><span class="hljs-string">"Password"</span></span>: <span class="hljs-string"><span class="hljs-string">"___"</span></span> } } } }</code> </pre> <br><p>  Ce fichier stocke des donn√©es non chiffr√©es et n'est donc utilis√© que pendant le d√©veloppement.  Un fichier est cr√©√© dans Visual Studio en appelant le menu contextuel sur l'ic√¥ne du projet ou en utilisant l'utilitaire de secrets d'utilisateurs sous Linux. </p><br><p>  Sous Windows, le fichier sera enregistr√© dans le r√©pertoire% APPDATA% \ Microsoft \ UserSecrets \ &lt;user_secrets_id&gt; \ secrets.json, et sous macOS et Linux, il sera enregistr√© dans ~ / .microsoft / usersecrets / &lt;user_secrets_id&gt; /secrets.json </p><br><p>  Pour enregistrer les param√®tres de production, certaines distributions Linux peuvent utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">systemd. Les</a> param√®tres sont enregistr√©s sous l'attribut Service.  Par exemple, comme ceci: </p><br><pre> <code class="python hljs">[Service] Environment=<span class="hljs-string"><span class="hljs-string">"Kestrel _ Certificates _ Default _Path=/root/.aspnet/https/__.pfx"</span></span> Environment=<span class="hljs-string"><span class="hljs-string">"Kestrel _ Certificates _ Default _Password=___"</span></span></code> </pre> <br><p>  Ensuite, je vais donner et analyser imm√©diatement la version de travail de la configuration du docker pour le proxy et le conteneur via https. </p><br><p>  Fichier Docker-compose: </p><br><pre> <code class="python hljs">version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo21: image: ${DOCKER_REGISTRY}dockerservicedemo build: context: . dockerfile: DockerServiceDemo/Dockerfile  override: version: <span class="hljs-string"><span class="hljs-string">'3.4'</span></span> services: dockerservicedemo: environment: - ASPNETCORE_ENVIRONMENT=Development - ASPNETCORE_URLS=https://+:<span class="hljs-number"><span class="hljs-number">44392</span></span>;http://+:<span class="hljs-number"><span class="hljs-number">80</span></span> - ASPNETCORE_HTTPS_PORT=<span class="hljs-number"><span class="hljs-number">44392</span></span> ports: - <span class="hljs-string"><span class="hljs-string">"59404:80"</span></span> - <span class="hljs-string"><span class="hljs-string">"44392:44392"</span></span> volumes: - ${APPDATA}/ASP.NET/Https:/root/.aspnet/https:ro - ${APPDATA}/Microsoft/UserSecrets:/root/.microsoft/usersecrets:ro proxy: image: nginx:latest volumes: - ./DockerServiceDemo/nginx.conf:/etc/nginx/nginx.conf - ./DockerServiceDemo/cert.crt:/etc/nginx/cert.crt - ./DockerServiceDemo/cert.rsa:/etc/nginx/cert.rsa ports: - <span class="hljs-string"><span class="hljs-string">"5001:44392"</span></span></code> </pre> <br><p>  Je vais maintenant d√©crire des moments incompr√©hensibles.  ASPNETCORE_URLS nous permet de ne pas indiquer dans le code d'application en utilisant app.UseUrl le port sur lequel l'application √©coute. </p><br><p>  ASPNETCORE_HTTPS_PORT effectue une redirection similaire √† ce que ferait le code suivant: <br>  services.AddHttpsRedirection (options =&gt; options.HttpsPort = 44392) </p><br><p>  Autrement dit, le trafic provenant des requ√™tes http sera redirig√© vers un port sp√©cifique de requ√™tes https. <br>  En utilisant les ports, il est indiqu√© que la demande du port externe 59404th sera redirig√©e vers le 80√®me conteneur, et du port externe 44392nd vers le 44392nd.  Th√©oriquement, puisque nous avons configur√© un serveur proxy inverse, nous pouvons supprimer les ports avec ces redirections. <br>  √Ä l'aide des volumes, un r√©pertoire avec un certificat pfx et une application UserSecrets sont mont√©s avec un mot de passe et un lien vers le certificat. </p><br><p>  La section proxy indique que les demandes du 5001e port externe seront redirig√©es vers le 44392e port nginx.  De plus, un fichier de configuration nginx est mont√©, ainsi qu'un certificat et une cl√© de certificat. </p><br><p>  Pour qu'ils puissent cr√©er un seul certificat pfx (que nous avons d√©j√†) pour cr√©er des fichiers crt et rsa, vous pouvez utiliser OpenSSL.  Vous devez d'abord extraire le certificat: </p><br><pre> <code class="python hljs">openssl pkcs12 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./_.pfx -clcerts -nokeys -out domain.crt</code> </pre> <br><p>  Et puis la cl√© priv√©e: </p><br><pre> <code class="python hljs">openssl pkcs12 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ./_.pfx -nocerts -nodes -out domain.rsa</code> </pre> <br><p>  La configuration de nginx est la suivante: </p><br><pre> <code class="python hljs">worker_processes <span class="hljs-number"><span class="hljs-number">4</span></span>; events { worker_connections <span class="hljs-number"><span class="hljs-number">1024</span></span>; } http { sendfile on; upstream app_servers { server dockerservicedemo:<span class="hljs-number"><span class="hljs-number">44392</span></span>; } server { listen <span class="hljs-number"><span class="hljs-number">44392</span></span> ssl; ssl_certificate /etc/nginx/cert.crt; ssl_certificate_key /etc/nginx/cert.rsa; location / { proxy_pass https://app_servers; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection keep-alive; proxy_set_header Host $host; proxy_cache_bypass $http_upgrade; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } }</code> </pre> <br><p>  Le serveur proxy √©coute sur le port 44392.  Ce port re√ßoit les demandes du 5001e port h√¥te.  Ensuite, le proxy redirige les demandes vers le port 44392e du conteneur dockerdemoservice. </p><br><p>  Apr√®s avoir compris ces exemples, vous aurez une bonne exp√©rience pour travailler avec docker, microservices et nginx. </p><br><p>  Nous vous rappelons qu'il s'agit de la version compl√®te d'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article du magazine Hacker</a> .  Son auteur est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alexey Sommer</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435914/">https://habr.com/ru/post/fr435914/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435904/index.html">L'IA a traduit l'activit√© c√©r√©brale en discours</a></li>
<li><a href="../fr435906/index.html">Stockage en cluster de pacemaker + DRBD (double primaire) + ctdb</a></li>
<li><a href="../fr435908/index.html">Web asc√©tique: prototypes de march√©s aux puces on go et js</a></li>
<li><a href="../fr435910/index.html">Pourquoi BSD a-t-il perdu la bataille avec GNU / Linux?</a></li>
<li><a href="../fr435912/index.html">Les principaux probl√®mes de d√©veloppement d'interfaces modernes</a></li>
<li><a href="../fr435916/index.html">Hacking VK, l'authentification √† deux facteurs ne sauvera pas</a></li>
<li><a href="../fr435920/index.html">D√©veloppeur Cookbook: DDD Recipes (Part 4, Structures)</a></li>
<li><a href="../fr435922/index.html">Java, Spring, Kurento et services m√©dias. 2e partie</a></li>
<li><a href="../fr435924/index.html">Le r√©seau neuronal g√©n√®re des images de plats selon des recettes pour leur pr√©paration</a></li>
<li><a href="../fr435926/index.html">Un r√©seau de neurones recueille des fragments de d√©couvertes arch√©ologiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>