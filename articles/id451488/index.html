<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥓 💜 ♌️ Perhitungan kanibalisasi didasarkan pada uji A / B klasik dan metode bootstrap 👩🏾‍🌾 🕺🏾 🦗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini membahas metode untuk menghitung kanibalisasi untuk aplikasi seluler berdasarkan uji A / B klasik. Dalam hal ini, tindakan target dipertim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perhitungan kanibalisasi didasarkan pada uji A / B klasik dan metode bootstrap</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451488/">  Artikel ini membahas metode untuk menghitung kanibalisasi untuk aplikasi seluler berdasarkan uji A / B klasik.  Dalam hal ini, tindakan target dipertimbangkan dan dievaluasi sebagai bagian dari proses re-atribusi dari sumber periklanan (Langsung, Criteo, AdWords UAC dan lainnya) dibandingkan dengan tindakan target dalam grup yang menonaktifkan iklan. <br><br>  Artikel ini memberikan ikhtisar metode klasik untuk membandingkan sampel independen dengan dasar teori singkat dan deskripsi perpustakaan yang digunakan, termasuk  menjelaskan secara singkat esensi dari metode bootstrap dan implementasinya di perpustakaan FaceBook Bootstrap, serta masalah yang muncul dalam praktik saat menerapkan teknik ini, dan bagaimana menyelesaikannya. <br><a name="habracut"></a><br>  Bukti dikaburkan atau tidak disediakan untuk mempertahankan perjanjian tidak ada pengungkapan. <br><br>  Di masa depan, saya berencana untuk menambah dan sedikit memodifikasi artikel ini saat fakta baru muncul, sehingga versi ini dapat dianggap sebagai rilis pertama.  Saya akan berterima kasih atas komentar dan ulasannya. <br><br><h3>  Pendahuluan </h3> <br>  Kanibalisasi adalah proses arus lalu lintas, lengkap dan tertarget, dari satu saluran ke saluran lainnya. <br><br>  Pemasar biasanya menggunakan indikator ini sebagai koefisien K tambahan dalam menghitung BPA: BPA yang dihitung dikalikan dengan 1 + K.  Dalam hal ini, BPA berarti total biaya untuk menarik lalu lintas / jumlah tindakan bertarget yang dimonetisasi secara langsung, yaitu, yang menghasilkan laba aktual - misalnya, panggilan bertarget, dan / atau dimonetisasi secara tidak langsung - misalnya, meningkatkan volume basis data iklan, meningkatkan pemirsa, dan sebagainya. <br><br>  Ketika saluran gratis (misalnya, kunjungan dari SERP organik, klik pada tautan di situs yang bebas untuk kami gunakan) dikanibal untuk dibayar (Langsung, Adwords alih-alih organik, beriklan di umpan jejaring sosial alih-alih mengklik iklan, gratis ditempatkan dalam kelompok, dan sebagainya), ini disertai dengan risiko kerugian finansial, sehingga penting untuk mengetahui tingkat kanibalisasi. <br><br>  Dalam kasus kami, tugasnya adalah menghitung kanibalisasi transisi "organik" ke aplikasi dengan transisi dari jaringan periklanan Criteo.  Surveillance adalah perangkat atau cairan pengguna (GAID / ADVID dan IDFA). <br><br><h3>  Persiapan percobaan </h3><br>  Anda dapat menyiapkan audiens untuk eksperimen dengan membagi pengguna di antarmuka sistem analitik AdJust menjadi grup untuk mengisolasi mereka yang akan melihat iklan dari jaringan iklan tertentu (sampel kontrol) dan mereka yang tidak akan ditampilkan masing-masing menggunakan iklan menggunakan GAID atau ADVID dan IDFA. (AdJust menyediakan API Pembuat Pemirsa).  Kemudian, dalam sampel kontrol, Anda dapat menyertakan kampanye iklan dalam jaringan iklan yang dipelajari dalam percobaan. <br><br>  Saya perhatikan dari diri saya sendiri bahwa, karena tampaknya secara intuitif, percobaan berikut akan lebih kompeten dalam kasus ini: untuk memilih empat kelompok - mereka yang memiliki penargetan ulang dinonaktifkan dari semua saluran (1), sebagai kelompok eksperimen, dan mereka yang memiliki hanya penargetan ulang yang diaktifkan dengan Criteo (2);  mereka yang hanya memiliki penargetan ulang dinonaktifkan dengan Criteo (3), mereka yang memiliki semua penargetan ulang (4) dihidupkan.  Maka akan mungkin untuk menghitung (1) / (2), setelah menerima nilai aktual dari kanibalisasi kampanye iklan dari jaringan Criteo untuk transisi "organik" ke aplikasi, dan (3) / (4), setelah menerima kanibalisasi Criteo di lingkungan "alami" (setelah semua, Criteo, jelas dapat mengkanibal saluran berbayar lainnya juga).  Eksperimen yang sama harus diulang untuk jaringan iklan lain untuk mengetahui dampak masing-masing;  di dunia yang ideal, akan lebih baik untuk menyelidiki kanibalisasi silang antara semua sumber berbayar utama yang merupakan bagian terbesar dalam total lalu lintas, tetapi akan memakan banyak waktu (baik untuk menyiapkan eksperimen dari sudut pandang pengembangan dan untuk mengevaluasi hasil), yang akan menyebabkan kritik atas ketelitian yang tidak masuk akal. <br><br>  Faktanya, percobaan kami dilakukan dalam kondisi (3) dan (4), sampel dibagi dalam rasio 10% hingga 90%, percobaan dilakukan selama 2 minggu. <br><br><h3>  Persiapan dan verifikasi data </h3><br>  Sebelum memulai studi apa pun, langkah penting adalah pra-pelatihan yang kompeten dan pembersihan data. <br><br>  Perlu dicatat bahwa sebenarnya perangkat aktif untuk periode percobaan 2 kali lebih sedikit (masing-masing 42,5% dan 50% dari kelompok kontrol dan eksperimen) daripada perangkat dalam sampel awal lengkap, yang dijelaskan oleh sifat data: <br><br><ol><li>  pertama (dan ini adalah alasan utama), pemilihan penargetan ulang dari Adjust berisi pengidentifikasi semua perangkat yang pernah menginstal aplikasi, yaitu, perangkat yang tidak lagi digunakan, dan yang sudah digunakan aplikasi tersebut. dihapus </li><li>  kedua, tidak perlu semua perangkat masuk ke aplikasi selama percobaan. </li></ol><br>  Namun, kami menghitung kanibalisasi berdasarkan data dari sampel lengkap.  Bagi saya pribadi, kebenaran perhitungan seperti itu masih menjadi titik perdebatan - secara umum, menurut pendapat saya, lebih tepat untuk membersihkan semua orang yang menghapus instalasi aplikasi dan tidak menginstalnya dengan tag yang sesuai, serta mereka yang belum masuk ke aplikasi selama lebih dari setahun - periode waktu ini pengguna dapat mengubah perangkat;  minus - dengan cara ini, untuk percobaan, pengguna yang tidak beralih ke aplikasi, tetapi dapat melakukannya, dapat dihapus dari pilihan jika kami menampilkan iklan di jaringan Criteo.  Saya ingin mencatat bahwa di dunia yang baik semua pengabaian dan asumsi yang dipaksakan ini harus diselidiki dan diverifikasi secara terpisah, tetapi kita hidup di dunia yang melakukannya dengan cepat dan berbulu. <br><br>  Dalam kasus kami, penting untuk memeriksa poin-poin berikut: <br><br><ol><li>  Kami memeriksa persimpangan dalam sampel awal kami - eksperimental dan kontrol.  Dalam percobaan yang diimplementasikan dengan benar, persimpangan tersebut tidak boleh, namun, dalam kasus kami, ada beberapa duplikat dari sampel eksperimental dalam kontrol.  Dalam kasus kami, pangsa duplikat ini dalam volume total perangkat yang terlibat dalam percobaan kecil, oleh karena itu, kami mengabaikan kondisi ini.  Jika ada&gt; 1% duplikat, percobaan harus dianggap salah dan percobaan kedua harus dilakukan, setelah sebelumnya membersihkan duplikat. </li><li>  Kami memeriksa bahwa data dalam percobaan benar-benar terpengaruh - penargetan ulang seharusnya dinonaktifkan pada sampel eksperimen (setidaknya dengan Criteo, dalam percobaan yang ditetapkan dengan benar - dari semua saluran), oleh karena itu, perlu untuk memeriksa tidak adanya DeviceID dari percobaan dalam penargetan ulang dengan Criteo.  Dalam kasus kami, DeviceID dari kelompok eksperimental jatuh ke retargeting, tetapi ada kurang dari 1%, yang dapat diabaikan. </li></ol><br><h3>  Evaluasi langsung percobaan </h3><br>  Kami akan mempertimbangkan perubahan dalam metrik target berikut: absolut - jumlah panggilan, dan relatif - jumlah panggilan per pengguna dalam kontrol (melihat iklan di jaringan Criteo) dan grup eksperimental (iklan dinonaktifkan).  Dalam kode di bawah ini, data variabel mengacu pada struktur panda.DataFrame, yang dibentuk dari hasil sampel eksperimental atau kontrol. <br><br>  Ada metode parametrik dan nonparametrik untuk menilai signifikansi statistik dari perbedaan nilai dalam sampel yang tidak terkait.  Kriteria evaluasi parametrik memberikan akurasi yang lebih besar, tetapi memiliki keterbatasan dalam penerapannya - khususnya, salah satu syarat utama adalah bahwa nilai yang terukur untuk pengamatan dalam sampel harus didistribusikan secara normal. <br><br><h4>  1. Studi tentang distribusi nilai dalam sampel untuk normalitas </h4><br>  Langkah pertama adalah memeriksa sampel yang ada untuk jenis distribusi nilai dan persamaan varians sampel menggunakan tes standar - kriteria Kolmogorov-Smirnov dan Shapiro-Wilks dan uji Bartlett diimplementasikan di perpustakaan sklearn.stats, mengambil p-value = 0,05: <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    : def norm_test(df, pvalue = 0.05, test_name = 'kstest'): if test_name == 'kstest': st = stats.kstest(df, 'norm') if test_name == 'shapiro': st = stats.shapiro(df) sys.stdout.write('According to {} {} is {}normal\n'.format(test_name, df.name, {True:'NOT ', False:''}[st[1] &lt; pvalue])) #    : def barlett_test(df1, df2, pvalue = 0.05): st = stats.bartlett(df1, df2) sys.stdout.write('Variances of {} and {} is {}equals\n'.format(df1.name, df2.name, {True:'NOT ', False:''}[st[1] &lt; pvalue]))</span></span></code> </pre> <br>  Selain itu, untuk penilaian visual dari hasil, Anda dapat menggunakan fungsi histogram. <br><br><pre> <code class="python hljs">data_agg = data.groupby([<span class="hljs-string"><span class="hljs-string">'bucket'</span></span>]).aggregate({<span class="hljs-string"><span class="hljs-string">'device_id'</span></span>: <span class="hljs-string"><span class="hljs-string">'nunique'</span></span>, <span class="hljs-string"><span class="hljs-string">'calls'</span></span>: <span class="hljs-string"><span class="hljs-string">'sum'</span></span>}).fillna(<span class="hljs-number"><span class="hljs-number">0</span></span>) data_conv = data_agg[<span class="hljs-string"><span class="hljs-string">'calls_auto'</span></span>]/data_agg[<span class="hljs-string"><span class="hljs-string">'device_id'</span></span>] data_conv.hist(bins=<span class="hljs-number"><span class="hljs-number">20</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/8m/zc/u4/8mzcu4-emautrimdpvczuttfkf8.png" alt="gambar"><br><br>  Anda dapat membaca histogram seperti ini: 10 kali dalam sampel ada konversi 0,08, 1 - 0,14.  Ini tidak mengatakan apa-apa tentang jumlah perangkat sebagai pengamatan untuk salah satu indikator konversi. <br><br>  Dalam kasus kami, distribusi nilai parameter baik dalam nilai absolut dan relatif (jumlah panggilan ke perangkat) dalam sampel tidak normal. <br>  Dalam hal ini, Anda dapat menggunakan tes Wilcoxon nonparametrik yang diterapkan di perpustakaan standar sklearn.stats, atau mencoba membawa distribusi nilai dalam sampel ke bentuk normal dan menerapkan salah satu kriteria parametrik - Uji t alias siswa atau uji Shapiro-Wilks. <br><br><h4>  2. Metode mengurangi distribusi nilai dalam sampel ke bentuk normal </h4><br>  <b>2.1.</b>  <b>Sub-ember</b> <br><br>  Salah satu pendekatan untuk membawa distribusi menjadi normal adalah metode sub-bucket.  Esensinya sederhana, dan tesis matematika berikut ini adalah dasar teoretis: menurut teorema limit pusat klasik, distribusi rata-rata cenderung normal - jumlah n variabel acak independen yang terdistribusi secara identik memiliki distribusi mendekati normal, dan, yang setara, distribusi sampel berarti dari yang pertama n independen yang identik secara acak jumlah cenderung normal.  Oleh karena itu, kita dapat membagi bucket yang ada menjadi sub-bucket'y dan, dengan demikian, dengan mengambil nilai rata-rata sub-bucket'y untuk masing-masing bucket'ov, kami dapat memperoleh distribusi mendekati normal: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   subbucket' data['subbucket'] = data['device_id'].apply(lambda x: randint(0,1000)) # Variant 1 data['subbucket'] = data['device_id'].apply(lambda x: hash(x)%1000) # Variant 2</span></span></code> </pre> <br>  Mungkin ada banyak opsi untuk pemisahan, semuanya tergantung pada imajinasi pengembang dan prinsip-prinsip moral - Anda dapat mengambil secara acak atau menggunakan hash dari keranjang asli, dengan demikian mempertimbangkan mekanisme untuk menerbitkannya dalam skema. <br><br>  Namun, dalam praktiknya, dari beberapa lusin peluncuran kode, kami menerima distribusi normal hanya sekali, yaitu, metode ini tidak dijamin atau stabil. <br><br>  Selain itu, rasio tindakan target dan pengguna dengan jumlah total tindakan dan pengguna di sub-bucket mungkin tidak konsisten dengan backet awal, jadi Anda harus terlebih dahulu memeriksa apakah rasio tersebut dipertahankan. <br><br><pre> <code class="python hljs">data[data[<span class="hljs-string"><span class="hljs-string">'calls'</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>].device_id.nunique()/data.device_id.nunique() <span class="hljs-comment"><span class="hljs-comment"># Total buckets = data.groupby(['bucket']).aggregate({'device_id': 'nunique', 'calls': 'sum'}) buckets[buckets['calls'] &gt; 0].device_id.nunique()/buckets.device_id.nunique() # Buckets subbuckets = data.groupby(['subbucket']).aggregate({'device_id': 'nunique', 'calls': 'sum'}) subbuckets[subbuckets['calls'] &gt; 0].device_id.nunique()/subbuckets.device_id.nunique() # Subbuckets</span></span></code> </pre> <br>  Dalam proses verifikasi tersebut, kami menemukan bahwa rasio konversi untuk subbucket relatif terhadap pemilihan asli tidak dipertahankan.  Karena kita perlu juga menjamin konsistensi rasio pembagian panggilan dalam sampel keluaran dan sumber, kami menggunakan penyeimbangan kelas, menambahkan pembobotan sehingga data dipilih secara terpisah oleh subkelompok: terpisah dari pengamatan dengan tindakan target dan secara terpisah dari pengamatan tanpa tindakan target dalam proporsi yang tepat.  Selain itu, dalam kasus kami, sampel didistribusikan secara tidak merata;  secara intuitif, tampaknya rata-rata tidak boleh berubah, tetapi bagaimana ketidakseragaman sampel mempengaruhi varians tidak jelas dari rumus dispersi.  Untuk memperjelas apakah perbedaan dalam ukuran sampel mempengaruhi hasil, kriteria Xi-square digunakan - jika perbedaan yang signifikan secara statistik terdeteksi, kerangka data yang lebih besar dengan ukuran yang lebih kecil akan dijadikan sampel: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">class_arrays_balancer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df1, df2, target = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'calls'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, pvalue=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.05</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> df1_target_size = len(df1[df1[target] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>]) print(df1.columns.to_list()) df2_target_size = len(df2[df2[target] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>]) total_target_size = df1_target_size + df2_target_size chi2_target, pvalue_target, dof_target, expected_target = chi2_contingency([[df1_target_size, total_target_size], [df2_target_size, total_target_size]]) df1_other_size = len(df1[df1[target] == <span class="hljs-number"><span class="hljs-number">0</span></span>]) df2_other_size = len(df1[df1[target] == <span class="hljs-number"><span class="hljs-number">0</span></span>]) total_other_size = df1_other_size + df2_other_size chi2_other, pvalue_other, dof_other, expected_other = chi2_contingency([[df1_other_size, total_other_size], [df2_other_size, total_other_size]]) df1_target, df2_target, df1_other, df2_other = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pvalue_target &lt; pvalue: sample_size = min([df1_target_size, df2_target_size]) df1_rnd_indx = np.random.choice(df1_target_size, size=sample_size, replace=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) df2_rnd_indx = np.random.choice(df2_target_size, size=sample_size, replace=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) df1_target = pd.DataFrame((np.asarray(df1[df1[target] == <span class="hljs-number"><span class="hljs-number">1</span></span>])[df1_rnd_indx]).tolist(), columns = df1.columns.tolist()) df2_target = pd.DataFrame((np.asarray(df2[df2[target] == <span class="hljs-number"><span class="hljs-number">1</span></span>])[df2_rnd_indx]).tolist(), columns = df2.columns.tolist()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p_value_other &lt; pvalue: sample_size = min([df1_other_size, df2_other_size]) df1_rnd_indx = np.random.choice(df1_other_size, size=sample_size, replace=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) df2_rnd_indx = np.random.choice(df2_other_size, size=sample_size, replace=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) df1_other = pd.DataFrame((np.asarray(df1[df1[target] == <span class="hljs-number"><span class="hljs-number">0</span></span>])[df1_rnd_indx]).tolist(), columns = df1.columns.tolist()) df2_other = pd.DataFrame((np.asarray(df2[df2[target] == <span class="hljs-number"><span class="hljs-number">0</span></span>])[df2_rnd_indx]).tolist(), columns = df2.columns.tolist()) df1 = pd.concat([df1_target, df1_other]) df2 = pd.concat([df2_target, df2_other]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> df1, df2 exp_classes, control_classes = class_arrays_balancer(data_exp, data_control)</code> </pre> <br>  Pada output, kami memperoleh data yang seimbang dalam ukuran dan konsisten dengan rasio konversi awal, metrik yang dipelajari (dihitung untuk nilai rata-rata untuk sub-ember) di mana mereka sudah didistribusikan secara normal, yang dapat dilihat baik secara visual maupun dengan hasil penerapan kriteria pengujian yang sudah diketahui oleh kami. normalitas (dengan p-value&gt; = 0,05).  Misalnya, untuk indikator relatif: <br><br><pre> <code class="python hljs">data_conv = (data[data[<span class="hljs-string"><span class="hljs-string">'calls'</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>].groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).calls.sum()*<span class="hljs-number"><span class="hljs-number">1.0</span></span>/data.groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).device_id.nunique()) data_conv.hist(bins = <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br>  Sekarang, uji-t dapat diterapkan pada rata-rata di atas sub-bucket (jadi, itu bukan device_id, bukan perangkat, tapi sub-bucket yang bertindak sebagai pengamatan). <br><br>  Setelah memastikan bahwa perubahannya signifikan secara statistik, kami dapat, dengan hati nurani yang jelas, melakukan apa yang kami mulai semua - menghitung kanibalisasi: <br><br><pre> <code class="python hljs">(data_exp.groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).calls.avg() - data_cntrl.groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).calls.avg() )/ data_exp.groupby([<span class="hljs-string"><span class="hljs-string">'subbucket'</span></span>]).calls.avg()</code> </pre> <br>  Penyebutnya harus berupa lalu lintas tanpa iklan, yaitu eksperimental. <br><br><h4>  3. Metode Bootstrap </h4><br>  Metode bootstrap adalah perpanjangan dari metode sub-bucket dan mewakili versinya yang lebih maju dan lebih baik;  implementasi perangkat lunak dari metode ini dengan Python dapat ditemukan di pustaka Bootstrap Facebook. <br>  Secara singkat, ide bootstrap dapat dijelaskan sebagai berikut: suatu metode tidak lebih dari sebuah konstruktor sampel yang dihasilkan dengan cara yang mirip dengan metode sub-ember secara acak, tetapi dengan kemungkinan pengulangan.  Kita dapat mengatakan penempatan dari populasi umum (jika seseorang dapat memanggil sampel asli) dengan pengembalian.  Pada output, rata-rata (atau median, jumlah, dll.) Dibentuk dari rata-rata untuk masing-masing subsampel yang dihasilkan. <br><br>  <i>Metode utama perpustakaan FaceBook Bootstrap</i> : <br><pre> <code class="python hljs">bootstrap()</code> </pre>  - Menerapkan mekanisme untuk pembentukan sampel;  mengembalikan batas bawah (5 persen) dan batas atas (95 persen) secara default;  untuk mengembalikan distribusi diskrit dalam rentang ini, perlu untuk mengatur parameter <i>return_distribution = True</i> (dihasilkan oleh fungsi pembantu <i>generate_distributions ()</i> ). <br><br>  Anda dapat menentukan jumlah iterasi menggunakan parameter <i>num_iterations</i> , di mana subsampel akan dihasilkan, dan jumlah subsampel <i>iteration_batch_size</i> untuk setiap iterasi.  Pada output dari <i>generate_distributions ()</i> , sampel akan dihasilkan dengan ukuran yang sama dengan jumlah iterasi <i>num_iterations</i> , elemen-elemen yang akan menjadi rata-rata dari nilai-nilai sampel <i>iteration_batch_size</i> dihitung pada setiap iterasi.  Dengan volume sampel yang besar, data mungkin tidak lagi sesuai dengan memori, sehingga dalam kasus seperti itu disarankan untuk mengurangi nilai <i>iteration_batch_size</i> . <br><br>  <i>Contoh</i> : biarkan sampel asli menjadi 2.000.000;  <i>num_iterations</i> = 10.000, <i>iteration_batch_size</i> = 300. Kemudian, di setiap 10.000 iterasi, 300 daftar 2.000.000 item akan disimpan dalam memori. <br><br>  Fungsi ini juga memungkinkan komputasi paralel pada beberapa inti prosesor, pada beberapa utas, mengatur angka yang diperlukan menggunakan parameter <i>num_threads</i> . <br><br><pre> <code class="python hljs">bootstrap_ab()</code> </pre> <br>  melakukan semua tindakan yang sama seperti fungsi <i>bootstrap () yang</i> dijelaskan di atas, namun, selain itu, agregasi nilai rata-rata juga dilakukan oleh metode yang ditentukan dalam <i>stat_func</i> - dari nilai <i>num_iterations</i> .  Selanjutnya, metrik yang ditentukan dalam parameter compare_func dihitung, dan signifikansi statistik diperkirakan. <br><br><pre> <code class="python hljs">compare_functions</code> </pre> <br>  - kelas fungsi yang menyediakan alat untuk pembentukan metrik untuk penilaian: <br><pre> <code class="python hljs">compare_functions.difference() compare_functions.percent_change() compare_functions.ratio() compare_functions.percent_difference() <span class="hljs-comment"><span class="hljs-comment"># difference = (test_stat - ctrl_stat) # percent_change = (test_stat - ctrl_stat) * 100.0 / ctrl_stat # ratio = test_stat / ctrl_stat # percent_difference = (test_stat - ctrl_stat) / ((test_stat + ctrl_stat) / 2.0) * 100.0</span></span></code> </pre> <br><pre> <code class="python hljs">stats_functions</code> </pre>  - kelas fungsi dari mana metode agregasi metrik yang dipelajari dipilih: <br><pre> <code class="python hljs">stats_functions.mean stats_functions.sum stats_functions.median stats_functions.std</code> </pre> <br>  Sebagai <i>stat_func,</i> Anda juga dapat menggunakan fungsi kustom yang ditentukan pengguna, misalnya: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(test_stat, ctrl_stat)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (test_stat - ctrl_stat)/test_stat bs.bootstrap_ab(test.values, control.values, stats_functions.mean, test_func, num_iterations=<span class="hljs-number"><span class="hljs-number">5000</span></span>, alpha=<span class="hljs-number"><span class="hljs-number">0.05</span></span>, iteration_batch_size=<span class="hljs-number"><span class="hljs-number">100</span></span>, scale_test_by=<span class="hljs-number"><span class="hljs-number">1</span></span>, num_threads=<span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre> <br>  Bahkan, <i>(test_stat - ctrl_stat) / test_stat</i> adalah rumus untuk menghitung kanibalisasi kita. <br><br>  Sebagai alternatif, atau untuk tujuan percobaan praktis, Anda awalnya dapat memperoleh distribusi menggunakan <i>bootstrap ()</i> , memeriksa signifikansi statistik perbedaan dalam metrik target menggunakan uji-t, dan kemudian menerapkan manipulasi yang diperlukan untuk mereka. <br>  Contoh bagaimana distribusi normal "kualitas" dapat diperoleh dengan menggunakan metode ini: <br><br><img src="https://habrastorage.org/webt/pc/is/ws/pciswsulv_wuinbcqkn-hgmluwe.png"><br><br>  Dokumentasi yang lebih terperinci dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman repositori</a> . <br><br>  Saat ini, hanya itulah yang saya inginkan (atau berhasil) bicarakan.  Saya mencoba menjelaskan secara singkat metode yang digunakan dan proses penerapannya.  Ada kemungkinan bahwa metodologi membutuhkan penyesuaian, jadi saya akan berterima kasih atas umpan balik dan ulasan. <br><br>  Saya juga ingin mengucapkan terima kasih kepada kolega saya atas bantuan mereka dalam mempersiapkan pekerjaan ini.  Jika artikel tersebut menerima umpan balik yang sebagian besar positif, saya akan menunjukkan di sini nama atau nama panggilan mereka (dengan persetujuan sebelumnya). <br><br>  Salam hangat untuk semuanya!  :) <br><br>  PS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dear Championship Channel</a> , tugas mengevaluasi hasil pengujian A / B adalah salah satu yang paling penting dalam Ilmu Data, karena tidak satu pun peluncuran model-ML baru dalam produksi selesai tanpa A / B.  Mungkin sudah waktunya untuk menyelenggarakan kompetisi untuk mengembangkan sistem untuk mengevaluasi hasil pengujian A / B?  :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451488/">https://habr.com/ru/post/id451488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451468/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 364 (6 - 12 Mei 2019)</a></li>
<li><a href="../id451476/index.html">LLVM dalam hal Go</a></li>
<li><a href="../id451478/index.html">Mempercepat eksplorasi data menggunakan panda-profiling library</a></li>
<li><a href="../id451480/index.html">Mengapa Departemen Perindustrian dan Perdagangan melarang penyimpanan data pada peralatan asing</a></li>
<li><a href="../id451482/index.html">Kompetensi programmer modern dari sudut yang berbeda</a></li>
<li><a href="../id451492/index.html">Tujuh Variabel Bash yang Tidak Terduga</a></li>
<li><a href="../id451496/index.html">Mitap Netologii "Karir dalam Ilmu Data untuk Pemula"</a></li>
<li><a href="../id451498/index.html">Intisari Desain Makanan, April 2019</a></li>
<li><a href="../id451502/index.html">Acara digital di Moskow dari 13 hingga 19 Mei</a></li>
<li><a href="../id451504/index.html">Gambar di web 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>