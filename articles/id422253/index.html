<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💸 🏥 ✳️ Yew - Kerangka front-end Rust & WebAssembly 🚎 ☯️ 🛌🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yew adalah analog dari React dan Elm, ditulis seluruhnya dalam Rust dan disusun menjadi WebAssembly yang jujur. Dalam artikel tersebut, Denis Kolodin,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Yew - Kerangka front-end Rust & WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/422253/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yew</a> adalah analog dari React dan Elm, ditulis seluruhnya dalam Rust dan disusun menjadi WebAssembly yang jujur.  Dalam artikel tersebut, Denis Kolodin, pengembang Yew, berbicara tentang bagaimana Anda dapat membuat kerangka kerja tanpa pengumpul sampah, secara efektif memastikan tidak berubah, tanpa perlu menyalin keadaan karena aturan kepemilikan data Rust, dan apa saja fitur saat menerjemahkan Karat ke Web. <br><br><img src="https://habrastorage.org/webt/dc/ro/wt/dcrowtesfnjfmpr7wl9j0suzjug.jpeg"><br><br>  <i>Pos disiapkan berdasarkan laporan Denis pada konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Piter 201 HolyJS</a> .</i>  <i>Di bawah transkrip video dan teks laporan.</i> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OqFOXMIwzTc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Denis Kolodin bekerja untuk Bitfury Group, sebuah perusahaan yang mengembangkan berbagai solusi blockchain.</i>  <i>Selama lebih dari dua tahun sekarang, telah dikodekan di Rust, bahasa pemrograman dari Mozilla Research.</i>  <i>Selama waktu ini, Denis berhasil mempelajari bahasa ini secara menyeluruh dan menggunakannya untuk mengembangkan berbagai aplikasi sistem, sebuah backend.</i>  <i>Sekarang, sehubungan dengan munculnya standar WebAssembly, saya mulai melihat ke arah front-end.</i> <br><br><h2>  Agenda </h2><br>  Hari ini kita akan belajar tentang apa Yew itu (nama kerangka membaca sama dengan kata bahasa Inggris "kamu" - kamu; "yew" adalah pohon yew yang diterjemahkan dari bahasa Inggris). <br><br>  Mari kita bicara sedikit tentang aspek arsitektur, tentang ide-ide apa kerangka dibangun di atas, tentang kemungkinan yang tertanam di dalamnya, serta tentang fitur-fitur yang memberi Rust selain kita dibandingkan dengan bahasa lain. <br><br>  Pada akhirnya, saya akan menunjukkan kepada Anda bagaimana mulai menggunakan Yew dan WebAssembly hari ini. <br><br><h2>  Apa itu Yew? </h2><br>  Pertama-tama, ini adalah WebAssembly, mis.  bytecode yang dapat dieksekusi yang bekerja di browser.  Diperlukan untuk menjalankan algoritma yang kompleks di sisi pengguna, misalnya, kriptografi, pengodean / dekode.  Lebih mudah untuk menerapkan ini dalam bahasa sistem daripada mengacaukan kruk. <br><br>  WebAssembly adalah standar yang dijelaskan dengan jelas, dipahami, dan didukung oleh semua browser modern.  Ini memungkinkan Anda untuk menggunakan berbagai bahasa pemrograman.  Dan ini menarik terutama karena Anda dapat menggunakan kembali kode yang dibuat oleh komunitas dalam bahasa lain. <br><br>  Jika mau, Anda dapat sepenuhnya menulis aplikasi di WebAssembly, dan Yew memungkinkan Anda melakukan ini, tetapi penting untuk tidak lupa bahwa meskipun dalam kasus ini, JavaScript tetap ada di browser.  Penting untuk mempersiapkan WebAssembly - ambil modul (WASM), tambahkan lingkungan ke dalamnya dan jalankan.  Yaitu  JavaScript sangat diperlukan.  Oleh karena itu, WebAssembly layak dipertimbangkan sebagai ekstensi daripada alternatif revolusioner untuk JS. <br><br><h3>  Seperti apa perkembangannya </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/9ef/8d5/b7f/9ef8d5b7ffb36029d2a4d840f9432980.png"><br><br>  Anda punya sumber, ada kompiler.  Anda menerjemahkan semua ini ke dalam format biner dan menjalankannya di browser.  Jika browser sudah tua, tanpa dukungan WebAssembly, maka emscripten diperlukan.  Ini, kira-kira, emulator WebAssembly untuk browser. <br><br><h3>  Yew - kerangka kerja siap pakai </h3><br>  Mari kita beralih ke Yew.  Saya mengembangkan kerangka kerja ini pada akhir tahun lalu.  Kemudian saya menulis beberapa jenis aplikasi cryptocurrency di Elm dan dihadapkan pada kenyataan bahwa karena batasan bahasa saya tidak dapat membuat struktur rekursif.  Dan pada saat itu saya berpikir: di Rust, masalah saya akan diselesaikan dengan sangat mudah.  Dan karena 99% dari waktu saya menulis di Rust dan hanya menyukai bahasa ini tepatnya untuk fitur-fiturnya, saya memutuskan untuk bereksperimen - untuk mengkompilasi aplikasi dengan fungsi pembaruan yang sama di Rust. <br><br>  Sketsa pertama saya butuh beberapa jam, saya harus mencari cara untuk mengkompilasi WebAssembly.  Saya meluncurkannya dan menyadari bahwa hanya dalam beberapa jam ia telah meletakkan inti, yang sangat mudah untuk dikembangkan.  Saya hanya perlu beberapa hari untuk membawa semuanya ke mesin kerangka minimum. <br><br>  Saya mempostingnya di open source, tetapi tidak berharap itu menjadi populer.  Namun, hari ini ia telah mengumpulkan lebih dari 4 ribu bintang di GitHub.  Anda dapat melihat proyek di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Ada banyak contoh. <br><br>  Kerangka kerja ini sepenuhnya ditulis dalam Rust.  Yew mendukung kompilasi langsung ke WebAssembly (wasm32-unknown-unknown target) tanpa emscripten.  Jika perlu, Anda bisa mengerjakan emscripten. <br><br><h2>  Arsitektur </h2><br>  Sekarang beberapa kata tentang bagaimana kerangka berbeda dari pendekatan tradisional yang ada di dunia JavaScript. <br><br>  Pertama, saya akan menunjukkan batasan bahasa apa yang saya temui di Elm.  Ambil kasing ketika ada model dan ada pesan yang memungkinkan Anda mengubah model ini. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Model =    { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> : <span class="hljs-type"><span class="hljs-type">Int</span></span>    }  <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Msg    = <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span>    | Decrement</code> </pre> <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">Increment</span></span> -&gt;     { value = model.value + <span class="hljs-number"><span class="hljs-number">1</span></span> }   Decrement -&gt;     { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = model.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br>  Di Elm, kami cukup membuat model baru dan menampilkannya di layar.  Versi model sebelumnya tetap tidak berubah.  Mengapa saya fokus pada ini?  Karena di Yew, modelnya bisa berubah, dan ini adalah salah satu pertanyaan paling umum.  Selanjutnya, saya akan menjelaskan mengapa ini dilakukan. <br><br>  Awalnya, saya mengikuti jalur klasik ketika model diciptakan kembali.  Tetapi ketika kerangka dikembangkan, saya melihat bahwa tidak masuk akal untuk menyimpan versi model sebelumnya.  Karat memungkinkan Anda untuk melacak masa pakai semua data, apakah itu dimodifikasi atau tidak.  Jadi saya dapat mengubah model dengan aman, mengetahui bahwa Rust mengendalikan tidak adanya konflik. <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span></span> {   value: <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span>, } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Msg</span></span></span></span> {   Increment,   Decrement, }</code> </pre><br><pre> <code class="hljs php">match msg {   Msg::Increment =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value += <span class="hljs-number"><span class="hljs-number">1</span></span>;   }   Msg::Decrement =&gt; {       <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value -= <span class="hljs-number"><span class="hljs-number">1</span></span>;   } }</code> </pre><br>  Ini adalah momen pertama.  Poin kedua: mengapa kita membutuhkan versi model yang lama?  Di Elm yang sama, hampir tidak ada masalah semacam akses kompetitif.  Model lama hanya perlu memahami kapan harus merender.  Kesadaran akan momen ini memungkinkan saya untuk sepenuhnya menyingkirkan kekekalan dan tidak mempertahankan versi yang lama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c98/ff5/d94/c98ff5d946992d46ba910e36375b4fc7.png"><br><br>  Lihatlah opsi ketika kita memiliki fungsi <code>update</code> dan dua bidang - <code>value</code> dan <code>name</code> .  Ada nilai yang disimpan saat kita memasukkan data ke dalam kolom <code>input</code> .  Modelnya berubah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/140/a12/d41/140a12d4106fb15b17204d547de29b82.png"><br><br>  Penting bahwa <code>value</code> tidak terlibat dalam rendering.  Jadi kita bisa mengubahnya sebanyak yang kita mau.  Tetapi kita tidak perlu mempengaruhi pohon DOM dan tidak perlu melakukan perubahan ini. <br><br>  Ini membawa saya pada gagasan bahwa hanya pengembang yang dapat mengetahui saat yang tepat ketika rendering benar-benar perlu dimulai.  Untuk memulai, saya mulai menggunakan flag - hanya nilai Boolean - <code>ShouldRender</code> , yang menandakan bahwa model telah berubah dan kita harus mulai render.  Pada saat yang sama, tidak ada overhead untuk perbandingan konstan, tidak ada konsumsi memori - aplikasi yang ditulis dalam Yew paling efektif. <br><br>  Dalam contoh di atas, tidak ada alokasi memori sama sekali kecuali untuk pesan yang dihasilkan dan dikirim.  Model mempertahankan keadaannya, dan ini tercermin dalam rendering hanya dengan bantuan bendera. <br><br><h2>  Kemungkinan </h2><br>  Menulis kerangka kerja yang bekerja di WebAssembly bukanlah tugas yang mudah.  Kami memiliki JavaScript, tetapi harus menciptakan semacam lingkungan yang perlu berinteraksi, dan ini adalah pekerjaan yang sangat besar.  Versi awal bundel ini terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ab/5aa/f25/3ab5aaf257e0a6a9f611e885dba4bd8d.png"><br><br>  Saya mengambil demo dari proyek lain.  Ada banyak proyek yang berjalan seperti ini, tetapi dengan cepat mengarah ke jalan buntu.  Lagi pula, frameworknya adalah pengembangan yang cukup besar dan Anda harus menulis banyak kode docking.  Saya mulai menggunakan perpustakaan di Rust yang disebut peti, khususnya, <code>Stdweb</code> . <br><br><h3>  JS terintegrasi </h3><br>  Dengan bantuan makro Rust, Anda dapat memperluas bahasa - kami dapat menyematkan potongan-potongan JavaScript dalam kode Rust, ini adalah fitur bahasa yang sangat berguna. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handle = js! {   var callback = @{callback};   var action = function() {       callback();   };   var delay = @{ms};   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {       interval_id: setInterval(action, delay),       callback: callback,   }; };</code> </pre><br>  Menggunakan makro dan Stdweb memungkinkan saya untuk dengan cepat dan efisien menulis semua tautan yang diperlukan. <br><br><h3>  Template JSX </h3><br>  Pada awalnya, saya menyusuri jalur Elm dan mulai menggunakan templat yang diimplementasikan menggunakan kode. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Html&lt;Context, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; {   nav(<span class="hljs-string"><span class="hljs-string">"nav"</span></span>, (<span class="hljs-string"><span class="hljs-string">"menu"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[       button(<span class="hljs-string"><span class="hljs-string">"button"</span></span>, (), (<span class="hljs-string"><span class="hljs-string">"onclick"</span></span>, || Msg::Clicked)),       tag(<span class="hljs-string"><span class="hljs-string">"section"</span></span>, (<span class="hljs-string"><span class="hljs-string">"ontop"</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[           p(<span class="hljs-string"><span class="hljs-string">"My text..."</span></span>)       ])   ]) }</code> </pre><br>  Saya tidak pernah menjadi pendukung React.  Tetapi ketika saya mulai menulis kerangka kerja saya, saya menyadari bahwa BEJ di React adalah hal yang sangat keren.  Berikut ini adalah presentasi templat kode yang sangat nyaman. <br><br>  Sebagai hasilnya, saya mengambil makro di Rust dan mengimplementasikan langsung di dalam Rust kemampuan untuk menulis markup HTML yang segera menghasilkan elemen pohon virtual. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Renderable&lt;Context, Model&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Model {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">view</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Html&lt;Context, <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt; {       html! {           &lt;div&gt;               &lt;nav class=<span class="hljs-string"><span class="hljs-string">"menu"</span></span>,&gt;                   &lt;button onclick=|_| Msg::Increment,&gt;{ <span class="hljs-string"><span class="hljs-string">"Increment"</span></span> }&lt;/button&gt;                   &lt;button onclick=|_| Msg::Decrement,&gt;{ <span class="hljs-string"><span class="hljs-string">"Decrement"</span></span> }&lt;/button&gt;               &lt;/nav&gt;               &lt;p&gt;{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.value }&lt;/p&gt;               &lt;p&gt;{ Local::now() }&lt;/p&gt;           &lt;/div&gt;       }   } }</code> </pre><br>  Kita dapat mengatakan bahwa templat mirip JSX adalah templat kode murni, tetapi pada steroid.  Mereka disajikan dalam format yang mudah.  Perhatikan juga bahwa di sini saya memasukkan ekspresi Rust langsung ke tombol (ekspresi Rust dapat dimasukkan ke dalam template ini).  Ini memungkinkan Anda untuk berintegrasi sangat dekat. <br><br><h3>  Komponen yang terstruktur dengan baik </h3><br>  Kemudian saya mulai mengembangkan template dan menyadari kemungkinan menggunakan komponen.  Ini adalah masalah pertama yang telah dibuat dalam repositori.  Saya telah mengimplementasikan komponen yang dapat digunakan dalam kode templat.  Anda cukup mendeklarasikan struktur jujur ​​di Rust dan menulis beberapa properti untuknya.  Dan properti ini dapat diatur langsung dari template. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b9/3d0/d37/9b93d0d3797e46f73650b00689315009.png"><br><br>  Sekali lagi, saya perhatikan hal penting bahwa templat ini dihasilkan kode Rust secara jujur.  Oleh karena itu, setiap kesalahan di sini akan diperhatikan oleh kompiler.  Yaitu  Anda tidak dapat salah, seperti yang sering terjadi dalam pengembangan JavaScript. <br><br><h3>  Area yang diketik </h3><br>  Fitur lain yang menarik adalah bahwa ketika suatu komponen ditempatkan di dalam komponen lain, ia dapat melihat tipe pesan dari induknya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/933/831/4cb/9338314cb1560b2172c6ab11bbff7977.png"><br><br>  Compiler secara kaku mengikat tipe-tipe ini dan tidak akan memberi Anda kesempatan untuk membuat kesalahan.  Saat memproses peristiwa, pesan yang diharapkan atau dikirim oleh komponen harus sepenuhnya cocok dengan induknya. <br><br><h3>  Fitur lainnya </h3><br>  Saya mentransfer implementasi dari Rust langsung ke kerangka kerja yang memungkinkan Anda dengan mudah menggunakan berbagai format untuk serialisasi / deserialisasi (menyediakannya dengan pembungkus tambahan).  Di bawah ini adalah contoh: kita pergi ke penyimpanan lokal dan, memulihkan data, tentukan bungkus tertentu - yang kita harapkan di sini adalah json. <br><br><pre> <code class="rust hljs">Msg::Store =&gt; {   context.local_storage.store(KEY, Json(&amp;model.clients)); } Msg::Restore =&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Json(<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(clients)) = context.local_storage.restore(KEY) {        model.clients = clients;   } }</code> </pre><br>  Ini bisa berupa format apa saja, termasuk biner.  Dengan demikian, serialisasi dan deserialisasi menjadi transparan dan nyaman. <br><br>  Gagasan peluang lain yang saya terapkan berasal dari pengguna kerangka kerja.  Mereka diminta membuat fragmen.  Dan di sini saya menemukan hal yang menarik.  Melihat di JavaScript kemampuan untuk menanamkan fragmen di pohon DOM, saya pertama kali memutuskan bahwa akan sangat mudah untuk menerapkan fungsi seperti itu dalam kerangka kerja saya.  Tetapi saya mencoba opsi ini, dan ternyata itu tidak berhasil.  Saya harus mencari tahu, berjalan di pohon ini, melihat apa yang telah berubah di sana, dll. <br><br>  Kerangka kerja Yew menggunakan pohon DOM virtual, semuanya awalnya ada di dalamnya.  Bahkan, ketika ada beberapa perubahan dalam template, mereka berubah menjadi tambalan yang sudah mengubah pohon DOM yang diberikan. <br><br><pre> <code class="hljs xml">html! {   <span class="hljs-tag"><span class="hljs-tag">&lt;&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>       <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span>{ "Row" }<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">td</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tr</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/&gt;</span></span> }</code> </pre><br><h2>  Manfaat tambahan </h2><br>  Rust menyediakan banyak fitur canggih yang berbeda, saya hanya akan berbicara tentang yang paling penting. <br><br><h3>  Layanan: interaksi dengan dunia luar </h3><br>  Peluang pertama yang ingin saya bicarakan adalah layanan.  Anda dapat menggambarkan fungsionalitas yang diperlukan dalam bentuk beberapa layanan, menerbitkannya sebagai peti dan menggunakannya kembali. <br><br>  Di Rust, kemampuan untuk membuat perpustakaan, integrasi, docking, dan perekatannya diimplementasikan dengan sangat baik.  Bahkan, Anda dapat membuat berbagai API untuk berinteraksi dengan layanan Anda, termasuk yang JavaScript.  Pada saat yang sama, kerangka kerja dapat berinteraksi dengan dunia luar, meskipun fakta bahwa itu berfungsi di dalam runtime WebAssembly. <br><br>  Contoh layanan: <br><br><ul><li>  TimeOutService; <br></li><li>  IntervalService; <br></li><li>  FetchService; <br></li><li>  WebSocketService; <br></li><li>  Layanan Kustom ... <br></li></ul><br>  Layanan dan Krat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Karat</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">crates.io</a> . <br><br><h3>  Konteks: persyaratan negara </h3><br>  Hal lain yang saya terapkan dalam kerangka tidak sepenuhnya tradisional, adalah konteksnya.  Bereaksi memiliki API Konteks, tetapi saya menggunakan Konteks dalam arti yang berbeda.  Kerangka kerja Yew terdiri dari komponen yang Anda buat, dan Konteks adalah beberapa kondisi global.  Komponen mungkin tidak mempertimbangkan keadaan global ini, tetapi dapat membuat beberapa tuntutan - sehingga entitas global memenuhi beberapa kriteria. <br><br>  Katakanlah komponen abstrak kami membutuhkan kemampuan untuk mengunggah sesuatu ke S3. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f6/477/776/3f6477776d227c4b7abcf64be2f17f5c.png"><br><br>  Dapat dilihat di bawah ini bahwa ia menggunakan unggahan ini, mis.  mengirim data ke S3.  Komponen seperti itu dapat ditata dalam bentuk rak.  Pengguna yang mengunduh komponen ini dan menambahkannya di dalam templat ke aplikasinya akan mengalami kesalahan - kompiler akan bertanya kepadanya di mana dukungan S3?  Pengguna harus mengimplementasikan dukungan ini.  Setelah itu, komponen secara otomatis mulai hidup penuh. <br><br>  Di mana itu dibutuhkan?  Bayangkan: Anda membuat komponen dengan kriptografi pintar.  Dia memiliki persyaratan bahwa konteks sekitarnya harus memungkinkannya untuk masuk ke suatu tempat.  Yang perlu Anda lakukan adalah menambahkan formulir otorisasi dalam template dan dalam konteks Anda menerapkan koneksi dengan layanan Anda.  Yaitu  itu akan menjadi tiga baris kode.  Setelah itu, komponen mulai bekerja. <br><br>  Bayangkan kita memiliki banyak komponen yang berbeda.  Dan mereka semua memiliki persyaratan yang sama.  Ini memungkinkan Anda untuk menerapkan beberapa jenis fungsi sekali untuk menghidupkan kembali semua komponen dan menarik data yang diperlukan.  Tepat di luar konteks.  Dan kompiler tidak akan memungkinkan Anda untuk membuat kesalahan: jika Anda tidak memiliki antarmuka yang memerlukan komponen, tidak ada yang berfungsi. <br><br>  Oleh karena itu, Anda dapat dengan mudah membuat tombol yang sangat rumit yang akan meminta beberapa API atau fitur lainnya.  Berkat Rust dan sistem antarmuka ini (mereka disebut sifat dalam Rust), menjadi mungkin untuk mendeklarasikan persyaratan komponen. <br><br><h3>  Kompiler tidak akan membiarkan Anda melakukan kesalahan </h3><br>  Bayangkan kita sedang membuat komponen dengan beberapa properti, salah satunya adalah kemampuan untuk mengatur panggilan kembali.  Dan, misalnya, kami mengatur properti dan melewatkan satu huruf dalam namanya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/829/d84/93d/829d8493d52ccff0299dc030661c5b37.png"><br><br>  Mencoba mengkompilasi, Rust merespons dengan cepat.  Dia mengatakan bahwa kita salah dan tidak ada properti seperti itu: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/02d/08d/ef7/02d08def74b01670bc6b4b0695f5cc2f.png"><br><br>  Seperti yang Anda lihat, Rust langsung menggunakan templat ini dan dapat membuat semua kesalahan di dalam makro.  Dia memberi tahu Anda apa sebutan properti itu seharusnya.  Jika Anda melewati kompiler, maka Anda tidak akan memiliki kesalahan runtime konyol seperti kesalahan ketik. <br><br>  Sekarang bayangkan, kita memiliki tombol yang meminta konteks global kita untuk dapat terhubung ke S3.  Dan buat konteks yang tidak mengimplementasikan dukungan S3.  Mari kita lihat apa yang terjadi. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a50/8d6/c7e/a508d6c7e4470c16f7890f36f0bd4135.png"><br><br>  Kompiler melaporkan bahwa kami telah memasukkan tombol, tetapi antarmuka ini tidak diterapkan untuk konteks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/63b/4f9/790/63b4f97902e2460ced9cbbdd0f820f23.png"><br><br>  Tetap hanya untuk masuk ke editor, menambahkan tautan ke Amazon dalam konteks, dan semuanya akan dimulai.  Anda dapat membuat layanan yang sudah jadi dengan beberapa jenis API, lalu cukup tambahkan ke konteksnya, gantikan tautannya, dan komponennya langsung hidup.  Ini memungkinkan Anda untuk melakukan hal-hal yang sangat keren: Anda menambahkan komponen, membuat konteks, mengisinya dengan layanan.  Dan semua ini bekerja sepenuhnya secara otomatis, diperlukan upaya minimal untuk mengikat semuanya. <br><br><h2>  Bagaimana cara mulai menggunakan Yew? </h2><br>  Di mana harus memulai jika Anda ingin mencoba kompilasi aplikasi WebAssembly?  Dan bagaimana ini bisa dilakukan dengan menggunakan kerangka Yew? <br><br><h3>  Kompilasi Rust-to-wasm </h3><br>  Pertama, Anda perlu menginstal kompiler.  Ada alat rustup untuk ini: <br><br> <code>curl https://sh.rustup.rs -sSf | sh <br></code> <br>  Plus, Anda mungkin perlu emscripten.  Apa manfaatnya?  Sebagian besar pustaka yang ditulis untuk bahasa pemrograman sistem, terutama untuk Rust (awalnya sebuah sistem), dikembangkan untuk Linux, Windows, dan OS lengkap lainnya.  Tentunya, browser tidak memiliki banyak fitur. <br><br>  Misalnya, pembuatan angka acak dalam browser tidak dilakukan dengan cara yang sama seperti di Linux.  emscripten berguna jika Anda ingin menggunakan perpustakaan yang membutuhkan API sistem. <br><br>  Perpustakaan dan seluruh infrastruktur diam-diam beralih ke WebAssembly yang jujur, dan emscripten tidak lagi diperlukan (Anda menggunakan kemampuan berbasis JavaScript untuk menghasilkan angka acak dan hal-hal lain), tetapi jika Anda perlu membangun sesuatu yang tidak didukung di browser sama sekali, Anda tidak dapat melakukannya tanpa emscripten . <br><br>  Saya juga merekomendasikan menggunakan web kargo: <br><br> <code>cargo install cargo-web <br></code> <br>  Dimungkinkan untuk mengkompilasi WebAssembly tanpa utilitas tambahan.  Tapi kargo-web adalah alat keren yang menyediakan beberapa hal yang berguna bagi pengembang JavaScript.  Secara khusus, itu akan memonitor file: jika Anda membuat perubahan, itu akan mulai mengkompilasi segera (kompiler tidak menyediakan fungsi-fungsi seperti itu).  Dalam hal ini, Cargo-web akan memungkinkan Anda untuk mempercepat pengembangan.  Ada sistem pembangunan yang berbeda untuk Rust, tetapi kargo adalah 99,9% dari semua proyek. <br><br>  Proyek baru dibuat sebagai berikut: <br><br> <code>cargo new --bin my-project <br></code> <br> <code>[package] <br> name = "my-project" <br> version = "0.1.0" <br> <br> [dependencies] <br> yew = "0.3.0" <br></code> <br>  Maka mulailah proyek: <br><br> <code>cargo web start --target wasm32-unknown-unknown <br></code> <br>  Saya memberi contoh WebAssembly yang jujur.  Jika Anda perlu mengkompilasi di bawah emscripten (compiler karat dapat menghubungkan emscripten itu sendiri), Anda dapat memasukkan kata <code>emscripten</code> di elemen yang terakhir <code>unknown</code> , yang memungkinkan Anda menggunakan lebih banyak peti.  Jangan lupa bahwa emscripten adalah kit tambahan yang cukup besar untuk file Anda.  Oleh karena itu, lebih baik menulis kode WebAssembly yang jujur. <br><br><h3>  Batasan yang ada </h3><br>  Siapa pun yang memiliki pengalaman pengkodean dalam bahasa pemrograman sistem dapat frustrasi oleh keterbatasan yang ada dalam kerangka kerja.  Tidak semua perpustakaan dapat digunakan di WebAssembly.  Misalnya, dalam lingkungan JavaScript tidak ada utas.  WebAssembly pada prinsipnya tidak menyatakan ini, dan tentu saja Anda dapat menggunakannya di lingkungan multi-utas (ini adalah pertanyaan terbuka), tetapi JavaScript masih merupakan lingkungan utas tunggal.  Ya, ada pekerja, tetapi ini adalah isolasi, sehingga tidak akan ada aliran di sana. <br><br>  Tampaknya Anda dapat hidup tanpa arus.  Tetapi jika Anda ingin menggunakan pustaka berbasis thread, misalnya, Anda ingin menambahkan semacam runtime, ini mungkin tidak lepas landas. <br><br>  Juga, tidak ada API sistem, kecuali yang Anda akan transfer dari JavaScript ke WebAssembly.  Karena itu, banyak perpustakaan tidak akan porting.  Anda tidak dapat menulis dan membaca file secara langsung, soket tidak dapat dibuka, dan Anda tidak dapat menulis ke jaringan.  Jika Anda ingin membuat soket-web, misalnya, Anda harus menyeretnya dari JavaScript. <br><br>  Kelemahan lain adalah bahwa debugger WASM ada, tetapi tidak ada yang melihatnya.  Masih dalam kondisi mentah sehingga tidak mungkin berguna bagi Anda.  Jadi debugging WebAssembly adalah pertanyaan yang sulit. <br><br>  Saat menggunakan Rust, hampir semua masalah runtime akan dikaitkan dengan kesalahan dalam logika bisnis, mereka akan mudah diperbaiki.  Tetapi bug tingkat rendah sangat jarang muncul - misalnya, salah satu perpustakaan melakukan docking yang salah - dan ini sudah merupakan pertanyaan yang sulit.  Sebagai contoh, saat ini ada masalah seperti itu: jika saya mengkompilasi kerangka kerja dengan emscripten dan ada sel memori variabel, kepemilikan yang diambil, itu diberikan, emscripten berantakan di suatu tempat di tengah (dan saya bahkan tidak yakin apakah itu emscripten).  Ketahuilah, jika Anda menemukan masalah di middleware di level rendah, maka memperbaikinya akan sulit saat ini. <br><br><h2>  Masa depan kerangka kerja </h2><br>  Bagaimana Yew akan berkembang lebih lanjut?  Saya melihat tujuan utamanya dalam menciptakan komponen monolitik.  Anda akan memiliki file WebAssembly yang dikompilasi, dan Anda cukup menempelkannya ke dalam aplikasi.  Misalnya, ini dapat memberikan kemampuan kriptografis, render, atau mengedit. <br><br><h3>  Integrasi JS </h3><br>  Integrasi dengan JavaScript akan diperkuat.  JavaScript telah menulis sejumlah besar perpustakaan keren yang mudah digunakan.  Dan ada beberapa contoh di repositori tempat saya menunjukkan bagaimana Anda bisa menggunakan pustaka JavaScript yang ada langsung dari framework Yew. <br><br><h3>  CSS yang diketik </h3><br>  Karena Rust digunakan, jelas bahwa Anda dapat menambahkan CSS yang diketik yang dapat dihasilkan dengan makro yang sama seperti pada contoh mesin templat yang mirip JSX.  Dalam hal ini, kompiler akan memeriksa, misalnya, jika Anda telah menetapkan beberapa atribut lain alih-alih warna.  Ini akan menghemat banyak waktu Anda. <br><br><h3>  Komponen siap </h3><br>  Saya juga ingin membuat komponen yang siap pakai.  Pada kerangka itu, Anda bisa membuat celah yang akan menyediakan, misalnya, satu set beberapa tombol atau elemen yang akan terhubung sebagai perpustakaan, ditambahkan ke templat dan digunakan. <br><br><h3>  Peningkatan kinerja dalam kasus pribadi </h3><br>  Kinerja adalah masalah yang sangat rumit dan rumit.  Apakah WebAssembly lebih cepat dari JavaScript?  Saya tidak punya bukti yang mengonfirmasi jawaban positif atau negatif.  Rasanya seperti dan menurut beberapa tes yang sangat sederhana yang saya lakukan, WebAssembly sangat cepat.  Dan saya memiliki keyakinan penuh bahwa kinerjanya akan lebih tinggi daripada JavaScript, hanya karena itu adalah bytecode tingkat rendah di mana alokasi memori tidak diperlukan dan ada banyak momen lain yang membutuhkan sumber daya. <br><br><h3>  Lebih Banyak Kontributor </h3><br>  Saya ingin menarik lebih banyak kontributor.  Pintu untuk berpartisipasi dalam kerangka kerja selalu terbuka.  Setiap orang yang ingin memutakhirkan sesuatu, memahami kernel dan mentransformasikan alat-alat yang bekerja dengan sejumlah besar pengembang dapat dengan mudah terhubung dan menawarkan suntingan mereka sendiri. <br><br>  Proyek ini telah dihadiri oleh banyak kontributor.  Tetapi tidak ada kontributor Inti saat ini, karena untuk ini Anda perlu memahami vektor pengembangan kerangka kerja, tetapi belum dirumuskan dengan jelas.  Tapi ada tulang punggung, cowok yang sangat berpengalaman dalam Yew - sekitar 30 orang.  Jika Anda juga ingin menambahkan sesuatu ke kerangka kerja, selalu kirimkan permintaan tarik. <br><br><h3>  Dokumentasi </h3><br>  Poin wajib dalam rencana saya adalah pembuatan sejumlah besar dokumentasi tentang cara menulis aplikasi pada Yew.  Jelas, pendekatan pengembangan dalam kasus ini berbeda dari apa yang kami lihat di React dan Elm. <br><br>  Kadang-kadang orang-orang menunjukkan kepada saya kasus-kasus menarik tentang bagaimana menggunakan kerangka kerja  Tetap saja, membuat kerangka kerja tidak sama dengan menulis secara profesional di atasnya.  Praktek untuk menggunakan kerangka kerja masih sedang dibentuk. <br><br>  Cobalah, instal Rust, perluas kemampuan Anda sebagai pengembang.  Menguasai WebAssembly akan berguna bagi kita masing-masing, karena pembuatan aplikasi yang sangat kompleks adalah saat yang telah kita tunggu-tunggu sejak lama.  Dengan kata lain, WebAssembly bukan hanya tentang browser web, tetapi pada umumnya adalah runtime yang pasti berkembang dan akan berkembang bahkan lebih aktif. <br><br><blockquote>  Jika Anda menyukai laporan ini, perhatikan: pada 24-25 November, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HolyJS</a> baru akan diadakan di Moskow, dan juga akan ada banyak hal menarik di sana.      —  ,       ( <b>  </b>  ). </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id422253/">https://habr.com/ru/post/id422253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id422239/index.html">Cara meluncurkan pengiriman untuk jutaan pengguna</a></li>
<li><a href="../id422241/index.html">KPI - Tiga Huruf Tersandung</a></li>
<li><a href="../id422243/index.html">CRM untuk bisnis kecil. Apakah kamu membutuhkannya?</a></li>
<li><a href="../id422247/index.html">OK Cup Permainan Instan. Persaingan untuk pengembang game HTML5</a></li>
<li><a href="../id422251/index.html">"Tingkat disiplin diri yang tinggi." Jeffrey Richter tentang cara membuat kode, menulis buku, dan membuat perusahaan sendiri</a></li>
<li><a href="../id422255/index.html">Penciptaan Karakter dalam Blender dan Persatuan</a></li>
<li><a href="../id422257/index.html">Ulasan pembaca PocketBook 627: kelas menengah dengan lampu latar, Wi-Fi, dan layanan cloud</a></li>
<li><a href="../id422259/index.html">Struktur data dasar. Materiel. Dasar-dasarnya</a></li>
<li><a href="../id422261/index.html">Zextras Powerstore dan Sistem Tiering</a></li>
<li><a href="../id422263/index.html">“Dormammu, aku setuju”: suatu algoritma untuk kerja sama yang saling menguntungkan dengan seseorang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>