<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📒 🚴🏿 🌾 Una pequeña práctica de programación funcional en Swift para principiantes 💲 ✔️ 👸🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Me gustaría presentar el concepto de Programación Funcional a los principiantes de la manera más simple, destacando algunas de sus ventajas de las muc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una pequeña práctica de programación funcional en Swift para principiantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440722/"><img src="https://habrastorage.org/webt/r4/cx/wi/r4cxwi9bjlhswlncf4ru1uslm4q.png"><br><br>  Me gustaría presentar el concepto de <i>Programación Funcional a los</i> principiantes de la manera más simple, destacando algunas de sus ventajas de las muchas otras que realmente harán que el código sea más legible y expresivo.  Recogí algunas demostraciones interesantes para ti que están en <code>Playground</code> en <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Github</a></b> . <br><br><h2>  Programación funcional: definición </h2><br>  En primer lugar, la <i>programación funcional</i> no es un lenguaje o una sintaxis, sino una forma de resolver problemas dividiendo procesos complejos en procesos más simples y su posterior composición.  Como su nombre lo indica, " <i>Programación funcional</i> " <i>,</i> la unidad de composición para este enfoque es una <i>función</i> ;  y el propósito de tal <i>función</i> es evitar el cambio de estado o valores fuera de su <code>scope)</code> . <br><br>  En <code>Swift</code> World, existen todas las condiciones para esto, porque las <i>funciones</i> aquí son participantes tan completos en el proceso de programación como los <i>objetos,</i> y el problema de la <code>mutation</code> se resuelve a nivel del concepto de TIPOS de <code>value</code> ( <code><font color="#0000FF">struct</font></code> estructuras y <code><font color="#0000FF">enum</font></code> enumeración) que ayudan a gestionar la mutabilidad ( <code>mutation</code> ) y comunicar claramente cómo y cuándo puede suceder esto. <br><br>  Sin embargo, <code>Swift</code> no <code>Swift</code> , en el sentido completo, el lenguaje de la <i>programación funcional</i> , no lo obliga a la <i>programación funcional</i> , aunque reconoce las ventajas de los enfoques <i>funcionales</i> y encuentra formas de incorporarlos. <br><br>  En este artículo, nos centraremos en utilizar los elementos integrados de la <i>Programación funcional</i> en <code>Swift</code> (es decir, "listos para usar") y en comprender cómo puede utilizarlos cómodamente en su aplicación. <br><a name="habracut"></a><br><h2>  Enfoques imperativos y funcionales: comparación </h2><br>  Para evaluar el Enfoque <i>Funcional</i> , comparemos las soluciones a un problema simple de dos maneras diferentes.  La primera solución es " <i>Imperativo</i> " <i>,</i> en el que el código cambia el estado dentro del programa. <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//Imperative Approach var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] for i in 0..&lt;numbers.count { let timesTen = numbers[i] * 10 numbers[i] = timesTen } print(numbers) //[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]</span></span></code> </pre><br>  Observe que manipulamos los valores dentro de la matriz mutable llamada <code><font color="#0000FF">numbers</font></code> y luego la imprimimos en la consola.  Mirando este código, intente responder las siguientes preguntas que discutiremos en un futuro cercano: <br><br><ol><li>  ¿Qué estás tratando de lograr con tu código? </li><li>  ¿Qué sucede si otro <code>thread</code> intenta acceder a la matriz de <code><font color="#0000FF">numbers</font></code> mientras se está ejecutando su código? </li><li>  ¿Qué sucede si desea tener acceso a los valores originales en la matriz de <code><font color="#0000FF">numbers</font></code> ? </li><li>  ¿Qué tan confiable se puede probar este código? </li></ol><br>  Ahora veamos un enfoque " <i>funcional</i> " alternativo: <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//Functional Approach let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] extension Array where Element == Int { func timesTen() -&gt; [Int] { var output = [Int]() for num in self { output.append(num * 10) } return output } } let result = numbers.timesTen() print(numbers) //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(result) //[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]</span></span></code> </pre><br>  En este fragmento de código, obtenemos el mismo resultado en la consola, abordando la solución del problema de una manera completamente diferente.  Tenga en cuenta que esta vez nuestra matriz de <code><font color="#0000FF">numbers</font></code> es inmutable gracias a la palabra clave <code><font color="#0000FF">let</font></code> .  Hemos movido el proceso de multiplicar números de la matriz de <code><font color="#0000FF">numbers</font></code> al método <code><font color="#0000FF">timesTen()</font></code> , que se encuentra en la extensión de <code><font color="#0000FF">extension</font></code> la <code><font color="#0000FF">Array</font></code> .  Todavía usamos un bucle <code><font color="#0000FF">for</font></code> y modificamos una variable llamada <code><font color="#0000FF">output</font></code> , pero el <code>scope</code> esta variable está limitado solo por este método.  De manera similar, nuestro argumento de entrada <code><font color="#0000FF">self</font></code> se pasa al método <code><font color="#0000FF">timesTen()</font></code> por valor ( <code>by value</code> ), teniendo el mismo alcance que la variable de <code><font color="#0000FF">output</font></code> .  Se <code><font color="#0000FF">timesTen()</font></code> método <code><font color="#0000FF">timesTen()</font></code> , y podemos imprimir en la consola tanto la matriz de <code><font color="#0000FF">numbers</font></code> originales como el resultado de la matriz de <code><font color="#0000FF">result</font></code> . <br>  Volvamos a nuestras 4 preguntas. <br><br>  <i>1. ¿Qué estás tratando de lograr con tu código?</i> <br><br>  En nuestro ejemplo, realizamos una tarea muy simple multiplicando los números en la matriz de <code><font color="#0000FF">numbers</font></code> por <code><font color="#0000FF">10</font></code> . <br><br>  Con un enfoque <i>imperativo</i> , para obtener una salida, debe pensar como una computadora, siguiendo las instrucciones en el bucle <code><font color="#0000FF">for</font></code> .  En este caso, el código muestra <code></code> lograr el resultado.  Con el enfoque <i>funcional</i> , " <code></code> " se "envuelve" en el método <code><font color="#0000FF">timesTen()</font></code> .  Siempre que este método se haya implementado en otro lugar, en realidad solo puede ver la expresión <code><font color="#0000FF">numbers.timesTen()</font></code> .  Dicho código muestra claramente <code></code> logra con este código y no <code></code> se resuelve la tarea.  Esto se llama <i>programación declarativa</i> , y es fácil adivinar por qué este enfoque es atractivo.  <i>El</i> enfoque <i>imperativo</i> hace que el desarrollador entienda <code></code> código para determinar <code></code> debe hacer.  <i>El</i> enfoque <i>funcional en</i> comparación con el enfoque <i>imperativo</i> es mucho más "expresivo" y le brinda al desarrollador una oportunidad de lujo de simplemente asumir que el método hace lo que dice hacer.  (Obviamente, esta suposición se aplica solo al código previamente verificado). <br><br>  <i>2. ¿Qué sucede si otro <code>thread</code> intenta acceder a la matriz de <code><font color="#0000FF">numbers</font></code> mientras se ejecuta el código?</i> <br><br>  Los ejemplos presentados anteriormente existen en un espacio completamente aislado, aunque en un entorno complejo de subprocesos múltiples, es muy posible que dos <code>threads</code> intenten acceder a los mismos recursos simultáneamente.  En el caso del enfoque <i>Imperativo</i> , es fácil ver que cuando otro <code>thread</code> tiene acceso a la matriz de <code><font color="#0000FF">numbers</font></code> en el proceso de uso, el resultado será dictado por el orden en que los <code>threads</code> acceden a la matriz de <code><font color="#0000FF">numbers</font></code> .  Esta situación se denomina <code>race condition</code> y puede conducir a un comportamiento impredecible e incluso a la inestabilidad y el bloqueo de la aplicación. <br><br>  En comparación, el enfoque <i>funcional</i> no tiene "efectos secundarios".  En otras palabras, la salida del método de <code><font color="#0000FF">output</font></code> no cambia ningún valor almacenado en nuestro sistema y está determinada únicamente por la entrada.  En este caso, cualquier subproceso ( <code>threads</code> ) que tenga acceso a la matriz de <code><font color="#0000FF">numbers</font></code> SIEMPRE recibirá los mismos valores y su comportamiento será estable y predecible. <br><br>  3. ¿Qué sucede si desea tener acceso a los valores originales almacenados en la matriz de <code><font color="#0000FF">numbers</font></code> ? <br><br>  Esta es una continuación de nuestra discusión sobre los "efectos secundarios".  Obviamente, los cambios de estado no se rastrean.  Por lo tanto, con el enfoque <i>imperativo</i> , perdemos el estado inicial de nuestra matriz de <code><font color="#0000FF">numbers</font></code> durante el proceso de conversión.  Nuestra solución, basada en el enfoque <i>funcional</i> , guarda la matriz de <code><font color="#0000FF">numbers</font></code> originales y genera una nueva matriz de <code><font color="#0000FF">result</font></code> con las propiedades deseadas en la salida.  Deja la matriz de <code><font color="#0000FF">numbers</font></code> original intacta y adecuada para el procesamiento futuro. <br><br>  4. ¿Qué tan confiable puede ser probado este código? <br><br>  Dado que el enfoque <i>funcional</i> destruye todos los "efectos secundarios", la funcionalidad probada está completamente dentro del método.  La entrada de este método NUNCA experimentará ningún cambio, por lo que puede probar varias veces usando el ciclo tantas veces como desee, y SIEMPRE obtendrá el mismo resultado.  En este caso, la prueba es muy fácil.  En comparación, probar la solución <i>Imperativa</i> en un bucle cambiará el inicio de la entrada y obtendrá resultados completamente diferentes después de cada iteración. <br><br><h2>  Resumen de beneficios </h2><br>  Como vimos en un ejemplo muy simple, el Enfoque <i>Funcional</i> es genial si se trata de un Modelo de Datos porque: <br><br><ul><li>  Es declarativo </li><li>  Soluciona problemas relacionados con hilos como <code>race condition</code> y puntos muertos </li><li>  Deja el estado sin cambios, que se puede utilizar para transformaciones posteriores. </li><li>  Es fácil de probar. </li></ul><br>  Avancemos un poco más en el aprendizaje de la programación <i>funcional</i> en <code>Swift</code> .  Se supone que los principales "actores" son funciones, y deberían ser principalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">objetos de la primera clase</a> . <br><br><h2>  Funciones de primera clase y funciones de orden superior </h2><br>  Para que una función sea de primera clase, debe tener la capacidad de ser declarada como variable.  Esto le permite administrar la función como un TIPO de datos normal y, al mismo tiempo, ejecutarla.  Afortunadamente, en <code>Swift</code> funciones son objetos de la primera clase, es decir, se admiten pasándolas como argumentos a otras funciones, devolviéndolas como resultado de otras funciones, asignándolas a variables o almacenándolas en estructuras de datos. <br><br>  Debido a esto, tenemos otras funciones en <code>Swift</code> : funciones de orden superior que se definen como funciones que toman otra función como argumento o devuelven una función.  Hay muchos de ellos: <code><font color="#0000FF">map</font></code> , <code><font color="#0000FF">filter</font></code> , <code><font color="#0000FF">reduce</font></code> , para cada <code><font color="#0000FF">forEach</font></code> , <code><font color="#0000FF">flatMap</font></code> , <code><font color="#0000FF">compactMap</font></code> , <code><font color="#0000FF">sorted</font></code> , etc.  Los ejemplos más comunes de funciones de orden superior son <code><font color="#0000FF">map</font></code> , <code><font color="#0000FF">filter</font></code> y <code><font color="#0000FF">reduce</font></code> .  No son globales, todos están "unidos" a ciertos TIPOS.  Funcionan en todos los TIPOS de <code><font color="#0000FF">Sequence</font></code> , incluida la <code><font color="#0000FF">Collection</font></code> , que está representada por estructuras de datos <code>Swift</code> como una <code><font color="#0000FF">Array</font></code> , un <code><font color="#0000FF">Dictionary</font></code> y un <code><font color="#0000FF">Set</font></code> .  En <code>Swift 5</code> , las funciones de orden superior también funcionan con un TIPO - <code><font color="#0000FF">Result</font></code> completamente nuevo. <br><br><h2> <code><font color="#0000FF">map(_:)</font></code> </h2> <br>  En el <code><font color="#0000FF">map(_:)</font></code> <code>Swift</code> <code><font color="#0000FF">map(_:)</font></code> toma una función como parámetro y convierte los valores de un determinado <code></code> acuerdo con esta función.  Por ejemplo, al aplicar <code><font color="#0000FF">map(_:)</font></code> a una matriz de valores de <code><font color="#0000FF">Array</font></code> , aplicamos una función de parámetro a cada elemento de la matriz original y obtenemos una matriz de <code><font color="#0000FF">Array</font></code> , pero también los valores convertidos. <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//Functional Approach let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] func timesTen(_ x:Int) -&gt; Int { return x * 10 } let result = numbers.map (timesTen) print(numbers) //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(result) //[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]</span></span></code> </pre><br>  En el código anterior, creamos la función <code><font color="#0000FF">timesTen (_:Int)</font></code> , que toma un valor entero <code><font color="#0000FF">Int</font></code> y devuelve el valor entero <code><font color="#0000FF">Int</font></code> multiplicado por <code><font color="#0000FF">10</font></code> , y lo usamos como parámetro de entrada a nuestra función de <code><font color="#0000FF">map(_:)</font></code> orden superior <code><font color="#0000FF">map(_:)</font></code> , aplicándolo a nuestra matriz <code><font color="#0000FF">numbers</font></code>  Obtuvimos el resultado que necesitamos en la matriz de <code><font color="#0000FF">result</font></code> . <br><br>  El nombre de la función de parámetro <code><font color="#0000FF">timesTen</font></code> para funciones de orden superior como <code><font color="#0000FF">map(_:)</font></code> no importa, el <code></code> parámetro de entrada y el valor de retorno son importantes, es decir, la firma <code><font color="#0000FF">(Int) -&gt; Int</font></code> parámetro de entrada de función.  Por lo tanto, podemos usar funciones anónimas en el <code><font color="#0000FF">map(_:)</font></code> - cierres - en cualquier forma, incluidos aquellos con nombres de argumentos acortados <code><font color="#0000FF">$0</font></code> , <code><font color="#0000FF">$1</font></code> , etc. <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//Functional Approach let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] let result = numbers.map { $0 * 10 } print(numbers) //[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(result) //[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]</span></span></code> </pre><br>  Si miramos la función <code><font color="#0000FF">map(_ :)</font></code> para una <code><font color="#0000FF">Array</font></code> , podría verse así: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> transform: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Element)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span>) -&gt; [<span class="hljs-type"><span class="hljs-type">T</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> returnValue = [<span class="hljs-type"><span class="hljs-type">T</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { returnValue.append(transform(item)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnValue }</code> </pre><br>  Este es un código imperativo que nos es familiar, pero ya no es un problema de desarrollador, es un problema de <code>Apple</code> , un problema de <code>Swift</code> .  La implementación de la función <code><font color="#0000FF">map(_:)</font></code> orden superior está optimizada por <code>Apple</code> en términos de rendimiento, y nosotros, los desarrolladores, tenemos garantizada la funcionalidad <code><font color="#0000FF">map(_:)</font></code> , por lo que solo podemos expresar correctamente con el argumento de la función de <code><font color="#0000FF">transform</font></code> <code></code> que queremos sin preocuparnos por <code></code> se implementará.  Como resultado, obtenemos código perfectamente legible en forma de una sola línea, que funcionará mejor y más rápido. <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//Functional Approach let possibleNumbers = ["1", "2", "three", "///4///", "5"] let mapped = possibleNumbers.map {str in Int(str) } print (mapped) // [Optional(1), Optional(2), nil, nil, Optional(5)]</span></span></code> </pre><br>  El <code></code> devuelto por la función de parámetro puede no coincidir con el <code></code> elementos en la colección original. <br><br>  En el código anterior, tenemos posibles números enteros <code><font color="#0000FF">possibleNumbers</font></code> , representados como cadenas, y queremos convertirlos a números enteros de <code></code> <code><font color="#0000FF">Int</font></code> , utilizando el inicializador <code>failable</code> <code><font color="#0000FF">Int(_ :String)</font></code> representado por el cierre <code><font color="#0000FF">{ str in Int(str) }</font></code> .  Hacemos esto usando <code><font color="#0000FF">map(_:)</font></code> y obtenemos una matriz <code><font color="#0000FF">mapped</font></code> de <code></code> <code><font color="#0000FF">Optional</font></code> como salida: <br><br><img src="https://habrastorage.org/webt/43/mg/hd/43mghd5aphvgnytu06eos4zhxos.png"><br><br>  No <code></code> convertir <code></code> elementos de nuestra matriz <code><font color="#0000FF">possibleNumbers</font></code> a enteros, como resultado, una parte recibió el valor <code><font color="#0000FF">nil</font></code> , lo que indica la imposibilidad de convertir la <code><font color="#0000FF">String</font></code> a un entero <code><font color="#0000FF">Int</font></code> , y la otra parte se convirtió en <code><font color="#0000FF">Optionals</font></code> , que tienen valores: <br><br><pre> <code class="swift hljs"><span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (mapped) <span class="hljs-comment"><span class="hljs-comment">// [Optional(1), Optional(2), nil, nil, Optional(5)]</span></span></code> </pre><br><h2> <code><font color="#0000FF">compactMap(_ :)</font></code> </h2> <br>  Si la función de parámetro pasada a la función de orden superior tiene un valor <code><font color="#0000FF">Optional</font></code> en la salida, entonces puede ser más útil usar otra función de orden superior, similar en significado: <code><font color="#0000FF">compactMap(_ :)</font></code> , que hace lo mismo que <code><font color="#0000FF">map(_:)</font></code> , pero adicionalmente "expande" los valores recibidos en la salida <code><font color="#0000FF">Optional</font></code> y elimina los valores <code><font color="#0000FF">nil</font></code> de la colección. <br><br><img src="https://habrastorage.org/webt/ie/a8/ls/iea8lshgmocoqytj8horz--kx0k.png"><br><br>  En este caso, obtenemos una matriz de <code><font color="#0000FF">compactMapped</font></code> TYPE <code><font color="#0000FF">[Int]</font></code> , pero posiblemente más pequeña: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> possibleNumbers = [<span class="hljs-string"><span class="hljs-string">"1"</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-string"><span class="hljs-string">"three"</span></span>, <span class="hljs-string"><span class="hljs-string">"///4///"</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> compactMapped = possibleNumbers.compactMap(<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (compactMapped) <span class="hljs-comment"><span class="hljs-comment">// [1, 2, 5]</span></span></code> </pre><br><img src="https://habrastorage.org/webt/wl/wf/ae/wlwfaep3tzyxrennftqqdtwezb8.png"><br><br>  Siempre que use el <code><font color="#0000FF">init?()</font></code> Como la función de transformación, tendrá que usar <code><font color="#0000FF">compactMap(_ :)</font></code> : <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Validate URLs let strings = ["https://demo0989623.mockable.io/car/1", "https://i.imgur.com/Wm1xcNZ.jpg"] let validateURLs = strings.compactMap(URL.init) // Separate Numbers and Operations let mathString: String = "12-37*2/5+44" let numbers1 = mathString.components(separatedBy: ["-", "*", "+", "/"]).compactMap(Int.init) print(numbers1) // [12, 37, 2, 5, 44]</span></span></code> </pre><br>  Debo decir que hay razones más que suficientes para usar la función de orden superior <code><font color="#0000FF">compactMap(_ :)</font></code> .  <code>Swift</code> "amores" Valores <code><font color="#0000FF">Optional</font></code> , se pueden obtener no solo usando el <code>failable</code> " <code><font color="#0000FF">init?()</font></code> <code>failable</code> ", sino también usando el <code><font color="#0000FF">as?</font></code>  <code></code> "Fundición": <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> views = [innerView,shadowView,logoView] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageViews = views.compactMap{$<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UIImageView</span></span>}</code> </pre><br>  ... y la <code><font color="#0000FF">try?</font></code>  al procesar errores arrojados por algunos métodos.  Debo decir que a <code>Apple</code> preocupa que el uso de <code><font color="#0000FF">try?</font></code>  muy a menudo conduce al doble <code><font color="#0000FF">Optional</font></code> y en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Swift 5</a> ahora deja solo un nivel <code><font color="#0000FF">Optional</font></code> después de aplicar <code><font color="#0000FF">try?</font></code>  . <br><br>  Hay una función más similar en nombre del <code><font color="#0000FF">flatMap(_ :)</font></code> orden <code><font color="#0000FF">flatMap(_ :)</font></code> , sobre el cual es un poco más bajo. <br><br>  A veces, para usar el <code><font color="#0000FF">map(_:)</font></code> funciones de orden superior <code><font color="#0000FF">map(_:)</font></code> , es útil usar el método <code><font color="#0000FF">zip (_:, _:)</font></code> para crear una secuencia de pares a partir de dos secuencias diferentes. <br><br>  Supongamos que tenemos una <code><font color="#0000FF">view</font></code> en la que se representan varios puntos, conectados entre sí y formando una línea discontinua: <br><br><img src="https://habrastorage.org/webt/gj/ut/_3/gjut_3xu92asnbvjvibucndse5o.png"><br><br>  Necesitamos construir otra línea discontinua que conecte los puntos medios de los segmentos de la línea discontinua original: <br><br><img src="https://habrastorage.org/webt/zv/hr/ke/zvhrkexsungckflo4orcpnkkm7e.png"><br><br>  Para calcular el punto medio de un segmento, debemos tener las coordenadas de dos puntos: el actual y el siguiente.  Para hacer esto, podemos crear una secuencia que consista en pares de puntos, el actual y el siguiente, utilizando el método <code><font color="#0000FF">zip (_:, _:)</font></code> , en el que usaremos la matriz de puntos de inicio y la matriz de los siguientes <code><font color="#0000FF">points.dropFirst()</font></code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pairs = <span class="hljs-built_in"><span class="hljs-built_in">zip</span></span> (points,points.<span class="hljs-built_in"><span class="hljs-built_in">dropFirst</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> averagePoints = pairs.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: ($<span class="hljs-number"><span class="hljs-number">0</span></span>.x + $<span class="hljs-number"><span class="hljs-number">1</span></span>.x) / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: ($<span class="hljs-number"><span class="hljs-number">0</span></span>.y + $<span class="hljs-number"><span class="hljs-number">1</span></span>.y) / <span class="hljs-number"><span class="hljs-number">2</span></span> )}</code> </pre><br>  Teniendo tal secuencia, calculamos muy fácilmente los puntos medios usando el <code><font color="#0000FF">map(_:)</font></code> funciones de orden superior <code><font color="#0000FF">map(_:)</font></code> y los mostramos en el gráfico. <br><br><h2> <code><font color="#0000FF">filter (_:)</font></code> </h2> <br>  En <code>Swift</code> , el <code><font color="#0000FF">filter (_:)</font></code> función de orden superior <code><font color="#0000FF">filter (_:)</font></code> está disponible para la mayoría de los <code></code> que está disponible la función de <code><font color="#0000FF">map(_:)</font></code> .  Puede filtrar cualquier <code><font color="#0000FF">Sequence</font></code> secuencia con <code><font color="#0000FF">filter (_:)</font></code> , ¡esto es obvio!  El método <code><font color="#0000FF">filter (_:)</font></code> toma otra función como parámetro, que es una condición para cada elemento de la secuencia, y si la condición se cumple, entonces el elemento se incluye en el resultado, y si no, no se incluye.  Esta "otra función" toma un solo valor, un elemento de la <code><font color="#0000FF">Sequence</font></code> secuencia, y devuelve un <code><font color="#0000FF">Bool</font></code> , el llamado predicado. <br><br>  Por ejemplo, para las matrices de matrices, el <code><font color="#0000FF">filter (_:)</font></code> función de orden superior <code><font color="#0000FF">filter (_:)</font></code> aplica la función de predicado y devuelve otra matriz que consta únicamente de aquellos elementos de la matriz original para los cuales la función de predicado de entrada devuelve <code><font color="#0000FF">true</font></code> . <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">//Functional Approach let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] let filted = numbers.filter{$0 % 2 == 0} //[2, 4, 6, 8, 10]</span></span></code> </pre><br>  Aquí, el <code><font color="#0000FF">filter (_:)</font></code> función de orden superior <code><font color="#0000FF">filter (_:)</font></code> toma cada elemento de la matriz de <code><font color="#0000FF">numbers</font></code> (representado por <code><font color="#0000FF">$0</font></code> ) y verifica si este elemento es un número par.  Si este es un número par, entonces los elementos de la matriz de <code><font color="#0000FF">numbers</font></code> caen en la nueva matriz <code><font color="#0000FF">filted</font></code> , de lo contrario no.  En forma declarativa, informamos al programa <code></code> queremos obtener en lugar de preocuparnos por <code></code> debemos hacerlo. <br><br>  Daré otro ejemplo del uso del <code><font color="#0000FF">filter (_:)</font></code> función de orden superior <code><font color="#0000FF">filter (_:)</font></code> para obtener solo los primeros <code><font color="#0000FF">20</font></code> números de Fibonacci con valores <code><font color="#0000FF">&lt; 4000</font></code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fibonacci = sequence(first: (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), next: { ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span> + $<span class="hljs-number"><span class="hljs-number">1</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">prefix</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{$<span class="hljs-number"><span class="hljs-number">0.0</span></span>} .<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> {$<span class="hljs-number"><span class="hljs-number">0</span></span> % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (fibonacci) <span class="hljs-comment"><span class="hljs-comment">// [0, 2, 8, 34, 144, 610, 2584]</span></span></code> </pre><br>  Obtenemos una secuencia de tuplas que consta de dos elementos de la secuencia de Fibonacci: el n-ésimo y (n + 1) -ésimo: <br><br><pre> <code class="swift hljs">(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) …</code> </pre><br>  Para un procesamiento adicional, limitamos el número de elementos a los veintiún elementos usando el <code><font color="#0000FF">prefix (20)</font></code> y tomamos el elemento <code><font color="#0000FF">0</font></code> de la tupla generada usando el <code><font color="#0000FF">map {$0.0 }</font></code> , que corresponderá a la secuencia de Fibonacci que comienza con <code><font color="#0000FF">0</font></code> : <br><br><pre> <code class="swift hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">55</span></span>, <span class="hljs-number"><span class="hljs-number">89</span></span>, <span class="hljs-number"><span class="hljs-number">144</span></span>, <span class="hljs-number"><span class="hljs-number">233</span></span>, <span class="hljs-number"><span class="hljs-number">377</span></span>, <span class="hljs-number"><span class="hljs-number">610</span></span>, <span class="hljs-number"><span class="hljs-number">987</span></span>, <span class="hljs-number"><span class="hljs-number">1597</span></span>, <span class="hljs-number"><span class="hljs-number">2584</span></span>,...</code> </pre><br>  Podríamos tomar el <code><font color="#0000FF">1</font></code> elemento de la tupla formada usando el <code><font color="#0000FF">map {$0.1 }</font></code> , que correspondería a la secuencia de Fibonacci que comienza con <code><font color="#0000FF">1</font></code> : <br><br><pre> <code class="swift hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">55</span></span>, <span class="hljs-number"><span class="hljs-number">89</span></span>, <span class="hljs-number"><span class="hljs-number">144</span></span>, <span class="hljs-number"><span class="hljs-number">233</span></span>, <span class="hljs-number"><span class="hljs-number">377</span></span>, <span class="hljs-number"><span class="hljs-number">610</span></span>, <span class="hljs-number"><span class="hljs-number">987</span></span>, <span class="hljs-number"><span class="hljs-number">1597</span></span>, <span class="hljs-number"><span class="hljs-number">2584</span></span>,...</code> </pre><br>  Obtenemos los elementos que necesitamos con la ayuda del <code><font color="#0000FF">filter {$0 % 2 == 0 &amp;&amp; $0 &lt; 4000}</font></code> función de orden superior <code><font color="#0000FF">filter {$0 % 2 == 0 &amp;&amp; $0 &lt; 4000}</font></code> , que devuelve una matriz de elementos de secuencia que satisfacen el predicado dado.  En nuestro caso, será una matriz de enteros <code><font color="#0000FF">[Int]</font></code> : <br><br><pre> <code class="swift hljs">[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">144</span></span>, <span class="hljs-number"><span class="hljs-number">610</span></span>, <span class="hljs-number"><span class="hljs-number">2584</span></span>]</code> </pre><br>  Hay otro ejemplo útil del uso del <code><font color="#0000FF">filter (_:)</font></code> para una <code><font color="#0000FF">Collection</font></code> . <br><br>  Me encontré <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">con un problema real</a> , cuando tienes una gran variedad de <code><font color="#0000FF">images</font></code> que se muestran con <code><font color="#0000FF">CollectionView</font></code> , y con la tecnología <code>Drag &amp; Drop</code> puedes recopilar un montón de imágenes y moverlas a todas partes, incluso soltarlas en " bote de basura ". <br><br><img src="https://habrastorage.org/webt/0s/-u/ks/0s-ukstskzfumukk9geirokdl-w.png"><br><br>  En este caso, la matriz de índices <code><font color="#0000FF">removedIndexes</font></code> índices <code><font color="#0000FF">removedIndexes</font></code> vertidas en el "bote de basura" son fijos, y usted necesita crear una nueva matriz de imágenes, excluyendo aquellos cuyos índices están en la matriz <code><font color="#0000FF">removedIndexes</font></code> .  Supongamos que tenemos una matriz de <code><font color="#0000FF">images</font></code> de enteros que imita imágenes, y una matriz de índices de estos enteros <code><font color="#0000FF">removedIndexes</font></code> que deben eliminarse.  Usaremos <code><font color="#0000FF">filter (_:)</font></code> para resolver nuestro problema: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> images = [<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> removedIndexes = [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> images1 = images .enumerated() .<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { !removedIndexes.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>.offset) } .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.element } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (images1) <span class="hljs-comment"><span class="hljs-comment">// [22, 14, 16, 9]</span></span></code> </pre><br>  El método <code><font color="#0000FF">enumerated()</font></code> devuelve una secuencia de tuplas que consta de índices de <code><font color="#0000FF">offset</font></code> y valores de <code><font color="#0000FF">element</font></code> matriz.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego aplicamos un filtro </font></font><code><font color="#0000FF">filter</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la secuencia resultante de tuplas, dejando solo aquellos cuyo índice </font></font><code><font color="#0000FF">$0.offset</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">está </font><font style="vertical-align: inherit;">contenido en la matriz </font></font><code><font color="#0000FF">removedIndexes</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El siguiente paso, seleccionamos el valor de la tupla </font></font><code><font color="#0000FF">$0.element</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y obtenemos la matriz que necesitamos </font></font><code><font color="#0000FF">images1</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h2> <code><font color="#0000FF">reduce (_:, _:)</font></code> </h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El método </font></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">también </font><font style="vertical-align: inherit;">está </font><font style="vertical-align: inherit;">disponible para la mayoría de los </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que están disponibles </font></font><code><font color="#0000FF">map(_:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y los </font><font style="vertical-align: inherit;">métodos </font></font><code><font color="#0000FF">filter (_:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El método </font></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"colapsa" la secuencia </font></font><code><font color="#0000FF">Sequence</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en un solo valor de acumulación y tiene dos parámetros. </font><font style="vertical-align: inherit;">El primer parámetro es el valor de acumulación inicial, y el segundo parámetro es una función que combina el valor de acumulación con el elemento de secuencia </font></font><code><font color="#0000FF">Sequence</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para obtener un nuevo valor de acumulación. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La función del parámetro de entrada se aplica a cada elemento de la secuencia </font></font><code><font color="#0000FF">Sequence</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, uno tras otro, hasta que llega al final y crea el valor de acumulación final.</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = <span class="hljs-type"><span class="hljs-type">Array</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>...<span class="hljs-number"><span class="hljs-number">100</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, +)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es un ejemplo trivial clásico del uso de una función de orden superior </font></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: contar la suma de los elementos de una matriz </font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="swift hljs">    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> +<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">6</span></span> = <span class="hljs-number"><span class="hljs-number">10</span></span> . . . . . . . . . . . . . . . . . . . <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">4950</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">4950</span></span> + <span class="hljs-number"><span class="hljs-number">100</span></span> = <span class="hljs-number"><span class="hljs-number">5050</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando la función, </font></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">podemos calcular simplemente la suma de los números de Fibonacci que satisfacen una determinada condición:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fibonacci = sequence(first: (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), next: { ($<span class="hljs-number"><span class="hljs-number">1</span></span>, $<span class="hljs-number"><span class="hljs-number">0</span></span> + $<span class="hljs-number"><span class="hljs-number">1</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">prefix</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{$<span class="hljs-number"><span class="hljs-number">0.0</span></span>} .<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> {$<span class="hljs-number"><span class="hljs-number">0</span></span> % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; <span class="hljs-number"><span class="hljs-number">4000</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (fibonacci) <span class="hljs-comment"><span class="hljs-comment">// [0, 2, 8, 34, 144, 610, 2584] print(fibonacci.reduce(0,+)) // 3382</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero hay aplicaciones más interesantes de una función de orden superior </font></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, podemos determinar de manera muy simple y concisa un parámetro muy importante para </font></font><code><font color="#0000FF">UIScrollView</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el tamaño del área "desplazable" </font></font><code><font color="#0000FF">contentSize</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en función de su tamaño </font></font><code><font color="#0000FF">subviews</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> scrollView = <span class="hljs-type"><span class="hljs-type">UIScrollView</span></span>() scrollView.addSubview(<span class="hljs-type"><span class="hljs-type">UIView</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>(x: <span class="hljs-number"><span class="hljs-number">300.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, width: <span class="hljs-number"><span class="hljs-number">200</span></span>, height: <span class="hljs-number"><span class="hljs-number">300</span></span>))) scrollView.addSubview(<span class="hljs-type"><span class="hljs-type">UIView</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>(x: <span class="hljs-number"><span class="hljs-number">100.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, width: <span class="hljs-number"><span class="hljs-number">300</span></span>, height: <span class="hljs-number"><span class="hljs-number">600</span></span>))) scrollView.contentSize = scrollView.subviews .<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(<span class="hljs-type"><span class="hljs-type">CGRect</span></span>.zero,{$<span class="hljs-number"><span class="hljs-number">0</span></span>.union($<span class="hljs-number"><span class="hljs-number">1</span></span>.frame)}) .size <span class="hljs-comment"><span class="hljs-comment">// (500.0, 600.0)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta demostración, el valor de acumulación es </font></font><code></code> <code><font color="#0000FF">GCRect</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y la operación de acumulación es la operación de combinar los </font></font><code><font color="#0000FF">union</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rectángulos que son </font></font><code><font color="#0000FF">frame</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuestros </font></font><code><font color="#0000FF">subviews</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesar de que una función de orden superior </font></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asume un carácter acumulativo, se puede usar en una perspectiva completamente diferente. </font><font style="vertical-align: inherit;">Por ejemplo, para dividir una tupla en partes en una matriz de tuplas:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Separate Tuples let arr = [("one", 1), ("two", 2), ("three", 3), ("four", 4)] let (arr1, arr2) = arr.reduce(([], [])) { ($0.0 + [$1.0], $0.1 + [$1.1]) } print(arr1) // ["one", "two", "three", "four"] print(arr2) // [1, 2, 3, 4]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swift </font></font><code>4.2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introdujo un nuevo tipo de función de orden superior </font></font><code><font color="#0000FF">reduce (into:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El método </font></font><code><font color="#0000FF">reduce (into:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es preferible en eficiencia en comparación con el método </font></font><code><font color="#0000FF">reduce (:, :)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si </font></font><code>COW (copy-on-write)</code> <code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por ejemplo, </font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o se </font><font style="vertical-align: inherit;">usa como la estructura resultante </font></font><code><font color="#0000FF">Dictionary</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede usarse efectivamente para eliminar valores coincidentes en una matriz de enteros:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Remove duplicates let arrayInt = [1,1,2,6,6,7,2,9,7].reduce(into: []) { !$0.contains($1) ? $0.append($1) : () } // [1, 2, 6, 7, 9]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... o al contar el número de elementos diferentes en una matriz: </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// Count equal elements in array let arrayIntCount = [1,1,2,2,6,6,7,2,9,7].reduce(into: [:]) { counts, letter in counts[letter, default: 0] += 1 } // [6: 2, 9: 1, 1: 2, 2: 3, 7: 2]</span></span></code> </pre><br><h2> <code><font color="#0000FF">flatMap (_:)</font></code> </h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Antes de pasar a esta función de orden superior, veamos una demostración muy simple. </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maybeNumbers = [<span class="hljs-string"><span class="hljs-string">"42"</span></span>, <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-string"><span class="hljs-string">"three"</span></span>, <span class="hljs-string"><span class="hljs-string">"///4///"</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstNumber = maybeNumbers.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> (<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>).first</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si ejecutamos este código para ejecutarlo </font></font><code>Playground</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, entonces todo se ve bien, y el nuestro </font></font><code><font color="#0000FF">firstNumber</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es igual </font></font><code><font color="#0000FF">42</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/ld/wu/t6/ldwut6x-1iu4yxapphmpzcyamj4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, si no lo sabe, a </font></font><code>Playground</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menudo oculta el verdadero </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, en particular las </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constantes </font></font><code><font color="#0000FF">firstNumber</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De hecho, la constante </font></font><code><font color="#0000FF">firstNumber</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos </font><font style="vertical-align: inherit;">cosas </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/v9/0k/xy/v90kxymnnsd_cxv-y4pznc0yj5s.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esto se debe a que </font></font><code><font color="#0000FF">map (Int.init)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la salida forma una matriz </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de valores TYPE </font></font><code><font color="#0000FF">[Int?]</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya que no todas las líneas </font></font><code><font color="#0000FF">String</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pueden convertirse </font></font><code><font color="#0000FF">Int</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el inicializador </font></font><code><font color="#0000FF">Int.int</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">está "cayendo" ( </font></font><code>failable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Luego tomamos el primer elemento de la matriz formada usando la función </font></font><code><font color="#0000FF">first</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para la matriz </font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que también forma la salida</font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya que la matriz puede estar vacía y no podremos obtener el primer elemento de la matriz. </font><font style="vertical-align: inherit;">Como resultado, tenemos un doble </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es decir</font></font><code><font color="#0000FF">Int??</font></code>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos una estructura anidada </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la que es realmente más difícil trabajar y que, naturalmente, no queremos tener. </font><font style="vertical-align: inherit;">Para obtener el valor de esta estructura anidada, tenemos que "sumergirnos" en dos niveles. </font><font style="vertical-align: inherit;">Además, cualquier transformación adicional puede profundizar </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aún más </font><font style="vertical-align: inherit;">el nivel </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtener el valor del doble anidado es </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente oneroso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenemos 3 opciones y todas ellas requieren un conocimiento profundo del idioma </font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><ul><li>      <code><font color="#0000FF">if let</font></code> ,       ;    «» «» <code><font color="#0000FF">Optional</font></code> ,    —  «» <code><font color="#0000FF">Optional</font></code> : <br><br><img src="https://habrastorage.org/webt/dp/wa/qh/dpwaqh4oebq7cjcwy35777cnno0.png"></li><li>       <code><font color="#0000FF">if case let</font></code>      ( <code>pattern match</code> )  : <br><br><img src="https://habrastorage.org/webt/v8/a6/tg/v8a6tg2npzwpktlvjpvqxf1pa0q.png"><br><br>       <code><font color="#0000FF">??</font></code>     : <br><br><img src="https://habrastorage.org/webt/a6/ny/ia/a6nyiaeq5bds4kiewmcugwomppq.png"></li><li> ,      <code><font color="#0000FF">switch</font></code>     : <br><br><img src="https://habrastorage.org/webt/oq/dx/1s/oqdx1siedfr6cxs2lug7zasq4qg.png"></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peor aún, tales problemas de anidación </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">surgen en cualquier situación que involucre </font></font><code>generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenedores </font><font style="vertical-align: inherit;">generalizados ( </font><font style="vertical-align: inherit;">) para los cuales se define una operación </font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por ejemplo, para matrices </font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere otro código de ejemplo. </font><font style="vertical-align: inherit;">Supongamos que tenemos un texto de varias líneas </font></font><code><font color="#0000FF">multilineString</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que queremos dividir en palabras escritas en minúsculas (pequeñas):</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> multilineString = <span class="hljs-string"><span class="hljs-string">"""  ,  ,   ;     , —  ,   :  —   ,   .   ,   ,   .    .  ,        ,  « »  .  ,  ,   ! """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> words = multilineString.lowercased() .<span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(separator: <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{$<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(separator: <span class="hljs-string"><span class="hljs-string">" "</span></span>)}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener una matriz de palabras </font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, primero hacemos letras mayúsculas (grandes) minúsculas (pequeñas) usando el método </font></font><code><font color="#0000FF">lowercased()</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, luego dividimos el texto en </font></font><code><font color="#0000FF">split(separatot: "\n")</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">líneas </font><font style="vertical-align: inherit;">usando el método </font><font style="vertical-align: inherit;">y obtenemos una matriz de cadenas, y luego las usamos </font></font><code><font color="#0000FF">map {$0.split(separator: " ")}</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para separar cada línea en palabras separadas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtenemos matrices anidadas:</font></font><br><br><pre> <code class="swift hljs">[[<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">";"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">"—"</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">":"</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"—"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"«"</span></span>, <span class="hljs-string"><span class="hljs-string">"»"</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>], [<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"!"</span></span>]]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... y </font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dos cosas </font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/b0/kc/y3/b0kcy3vh-dkhtw6ytrmk7fe_cbk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuevamente obtuvimos una estructura de datos "anidada", pero esta vez no </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero </font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si queremos continuar procesando las palabras recibidas </font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por ejemplo, para encontrar el espectro de letras de este texto de varias líneas, primero tendremos que "enderezar" de alguna manera la matriz del doble </font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y convertirla en una matriz única </font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esto es similar a lo que hicimos con el doble </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para una demostración al comienzo de esta sección sobre </font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maybeNumbers = [<span class="hljs-string"><span class="hljs-string">"42"</span></span>, <span class="hljs-string"><span class="hljs-string">"7"</span></span>, <span class="hljs-string"><span class="hljs-string">"three"</span></span>, <span class="hljs-string"><span class="hljs-string">"///4///"</span></span>, <span class="hljs-string"><span class="hljs-string">"5"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstNumber = maybeNumbers.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> (<span class="hljs-type"><span class="hljs-type">Int</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>).first</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afortunadamente, </font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no tenemos que recurrir a construcciones sintácticas complejas. </font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos proporciona una solución preparada para matrices </font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esta es una función de orden superior </font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! Es muy similar a </font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero tiene una funcionalidad adicional asociada con el "enderezado" posterior de los "archivos adjuntos" que aparecen durante la ejecución </font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Y es por eso que se llama </font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, "endereza" ( </font></font><code>flattens</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) el resultado </font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intentemos aplicar </font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code><font color="#0000FF">firstNumber</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/l7/1g/ag/l71gagrp7qtfvn-9nae3ofbmlb0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realmente obtuvimos la salida con un solo nivel </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Funciona </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aún más interesante </font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para una matriz </font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En nuestra expresión para, </font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplemente reemplazamos </font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con</font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/zh/t9/bm/zht9bmajklq5ybm4xxpigddrrma.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... y solo obtenemos una serie de palabras </font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sin ningún tipo de "anidamiento":</font></font><br><br><pre> <code class="swift hljs">[<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">";"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">"—"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">":"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"—"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"«"</span></span>, <span class="hljs-string"><span class="hljs-string">"»"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"!"</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos continuar con el procesamiento que necesitamos de la matriz de palabras resultante </font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero tenga cuidado. </font><font style="vertical-align: inherit;">Si lo aplicamos una vez más </font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a cada elemento de la matriz </font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, obtendremos, tal vez, un resultado inesperado, pero bastante comprensible. </font></font><br><br><img src="https://habrastorage.org/webt/vw/iq/jd/vwiqjd_y3ambrq0w8e-r9dnjpl4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtenemos una matriz única, no "anidada" de letras y símbolos </font></font><code><font color="#0000FF">[Character]</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenidos en nuestra frase de varias líneas:</font></font><br><br><pre> <code class="swift hljs">[<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">";"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, ...]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El hecho es que la cadena </font></font><code><font color="#0000FF">String</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es una colección de </font></font><code><font color="#0000FF">Collection</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caracteres </font></font><code><font color="#0000FF">[Character]</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y, aplicando </font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a cada palabra individual, una vez más bajamos el nivel de "anidamiento" y llegamos a una serie de caracteres </font></font><code><font color="#0000FF">flattenCharacters</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tal vez esto es exactamente lo que quieres, o tal vez no. </font><font style="vertical-align: inherit;">Presta atención a esto.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Poniendo todo junto: resolviendo algunos problemas </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TAREA 1 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos continuar el procesamiento que necesitamos de la matriz de palabras obtenida en la sección anterior </font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y calcular la frecuencia de aparición de letras en nuestra frase de varias líneas. </font><font style="vertical-align: inherit;">Primero, peguemos todas las palabras de la matriz </font></font><code><font color="#0000FF">words</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en una línea grande y excluyamos todos los signos de puntuación, es decir, deje solo las letras:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wordsString = words.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>,+).<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { <span class="hljs-string"><span class="hljs-string">""</span></span> .<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>)} <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces, tenemos todas las letras que necesitamos. </font><font style="vertical-align: inherit;">Ahora hagamos un diccionario de ellos, donde la clave </font></font><code><font color="#0000FF">key</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es la letra, y el valor </font></font><code><font color="#0000FF">value</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es la frecuencia de su aparición en el texto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos hacer esto de dos maneras. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El primer método</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> está asociado con el uso de una nueva </font></font><code>Swift 4.2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variedad de una función de orden superior </font><font style="vertical-align: inherit;">que ha aparecido en </font></font><code><font color="#0000FF">reduce (into:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este método es bastante adecuado para que organicemos un diccionario </font></font><code><font color="#0000FF">letterCount</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con la frecuencia de aparición de letras en nuestra frase de varias líneas:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> letterCount = wordsString.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(into: [:]) { counts, letter <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> counts[letter, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (letterCount) <span class="hljs-comment"><span class="hljs-comment">// ["": 1, "": 18, "": 2, "": 2, "": 5, "": 7, "": 17, "": 4, "": 23, ...]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, obtendremos un diccionario </font></font><code><font color="#0000FF">letterCount</font></code> <code></code> <code><font color="#0000FF">[Character : Int]</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el que las claves </font></font><code><font color="#0000FF">key</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son los caracteres encontrados en la frase en estudio, y como el valor </font></font><code><font color="#0000FF">value</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es el número de estos caracteres. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El segundo método</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consiste en inicializar el diccionario usando la agrupación, que da el mismo resultado:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> letterCountDictionary = <span class="hljs-type"><span class="hljs-type">Dictionary</span></span>(grouping: wordsString ){ $<span class="hljs-number"><span class="hljs-number">0</span></span>}.mapValues {$<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>} letterCount == letterCountDictionary <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos gustaría ordenar el diccionario </font></font><code><font color="#0000FF">letterCount</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alfabéticamente:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lettersStat = letterCountDictionary .sorted(by: &lt;) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{<span class="hljs-string"><span class="hljs-string">"\($0.0):\($0.1)"</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (lettersStat) <span class="hljs-comment"><span class="hljs-comment">// [":17", ":5", ":18", ":4", ":8", ":35", ":3", ":4", ":18", ":5", ":2", ":10", ":4", ":26", ":34", ":5", ":7", ":23", ":25", ":4", ":2", ":3", ":4", ":2", ":1", ":14", ":2", ":4"]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero no podemos ordenar el diccionario directamente </font></font><code><font color="#0000FF">Dictionary</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya que fundamentalmente no es una estructura de datos ordenada. Si aplicamos la función </font></font><code><font color="#0000FF">sorted (by:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al diccionario </font></font><code><font color="#0000FF">Dictionary</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nos devolverá los elementos de la secuencia ordenados con el predicado dado en forma de un conjunto de tuplas con nombre, que </font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convertiremos en un conjunto de cadenas que </font></font><code><font color="#0000FF">[":17", ":5", ":18", ...]</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reflejan la frecuencia de aparición de la letra correspondiente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vemos que esta vez </font></font><code><font color="#0000FF">sorted (by:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo el operador " </font></font><code><font color="#0000FF">&lt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font><font style="vertical-align: inherit;">se pasa </font><font style="vertical-align: inherit;">como un predicado a una función de </font><font style="vertical-align: inherit;">orden superior </font><font style="vertical-align: inherit;">. La función </font></font><code><font color="#0000FF">sorted (by:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">espera una "función de comparación" como único argumento en la entrada. Se utiliza para comparar dos valores adyacentes y decidir si están ordenados correctamente (en este caso, devuelve</font></font><code><font color="#0000FF">true</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) o no (devuelve </font></font><code><font color="#0000FF">false</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Podemos dar a esta "función de comparación" funciones </font></font><code><font color="#0000FF">sorted (by:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en forma de cierre anónimo:</font></font><br><br><pre> <code class="swift hljs">sorted(by: {$<span class="hljs-number"><span class="hljs-number">0</span></span>.key &lt; $<span class="hljs-number"><span class="hljs-number">1</span></span>.key}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y podemos darle el operador " </font></font><code><font color="#0000FF">&lt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">", que tiene la firma que necesitamos, como se hizo anteriormente. </font><font style="vertical-align: inherit;">Esta también es una función, y la clasificación por clave está en progreso </font></font><code><font color="#0000FF">key</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si queremos ordenar el diccionario por valores </font></font><code><font color="#0000FF">value</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y descubrir qué letras se encuentran con más frecuencia en esta frase, entonces tendremos que usar el cierre para la función </font></font><code><font color="#0000FF">sorted (by:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> countsStat = letterCountDictionary .sorted(by: {$<span class="hljs-number"><span class="hljs-number">0</span></span>.value &gt; $<span class="hljs-number"><span class="hljs-number">1</span></span>.value}) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{<span class="hljs-string"><span class="hljs-string">"\($0.0):\($0.1)"</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (countsStat ) <span class="hljs-comment"><span class="hljs-comment">//[":35", ":34", ":26", ":25", ":23", ":18", ":18", ":17", ":14", ":10", ":8", ":7", ":5", ":5", ":5", ":4", ":4", ":4", ":4", ":4", ":4", ":3", ":3", ":2", ":2", ":2", ":2", ":1"]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si echamos un vistazo a la solución al problema de determinar el espectro de letras de una frase multilínea en su conjunto ... </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> multilineString = <span class="hljs-string"><span class="hljs-string">"""  ,  ,   ;     , —  ,   :  —   ,   .   ,   ,   .    .  ,        ,  « »  .  ,  ,   ! """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> words = multilineString.lowercased() .<span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(separator: <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) .flatMap{$<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(separator: <span class="hljs-string"><span class="hljs-string">" "</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wordsString = words.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span> (<span class="hljs-string"><span class="hljs-string">""</span></span>,+).<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { <span class="hljs-string"><span class="hljs-string">""</span></span> .<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> letterCount = wordsString.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(into: [:]) { counts, letter <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> counts[letter, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">1</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lettersStat = letterCountDictionary .sorted(by: &lt;) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{<span class="hljs-string"><span class="hljs-string">"\($0.0):\($0.1)"</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (lettersStat) <span class="hljs-comment"><span class="hljs-comment">// [":17", ":5", ":18", ":4", ":8", ":35", ":3", ":4", ":18", ":5", ":2", ":10", ":4", ":26", ":34", ":5", ":7", ":23", ":25", ":4", ":2", ":3", ":4", ":2", ":1", ":14", ":2", ":4"] let countsStat = letterCountDictionary .sorted(by: {$0.value &gt; $1.value}) .map{"\($0.0):\($0.1)"} print (countsStat ) //[":35", ":34", ":26", ":25", ":23", ":18", ":18", ":17", ":14", ":10", ":8", ":7", ":5", ":5", ":5", ":4", ":4", ":4", ":4", ":4", ":4", ":3", ":3", ":2", ":2", ":2", ":2", ":1"]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... luego notaremos que en este fragmento de código básicamente no hay variables (no </font></font><code><font color="#0000FF">var</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, solo </font></font><code><font color="#0000FF">let)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todos los nombres de las funciones utilizadas reflejan ACCIONES (funciones) en cierta información, sin preocuparse en absoluto de CÓMO se implementan estas acciones: </font></font><br><br> <code><font color="#0000FF">split</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- dividir, </font></font><br> <code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- transformar </font></font><br> <code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- transformar con alineación (mediante la eliminación de un nivel de anidamiento), </font></font><br> <code><font color="#0000FF">filter</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- filtro, </font></font><br> <code><font color="#0000FF">sorted</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- clasificación, </font></font><br> <code><font color="#0000FF">reduce</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- para convertir los datos en una cierta estructura por medio de una operación específica </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en este fragmento de cada línea de código explica el nombre de la función que usamos si estamos en. rellenos transformación "pura" se utiliza </font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si realizamos se utiliza la conversión del nivel de anidamiento</font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, si queremos seleccionar solo ciertos datos, los usamos </font></font><code><font color="#0000FF">filter</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, etc. Todas estas funciones de "orden superior" están diseñadas y probadas </font></font><code>Apple</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teniendo en cuenta la optimización del rendimiento. Entonces, este código es muy confiable y conciso: no necesitábamos más de 5 oraciones para resolver nuestro problema. Este es un ejemplo de programación funcional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El único inconveniente de aplicar el enfoque funcional en esta demostración es que, en aras de la inmutabilidad, la capacidad de prueba y la legibilidad, perseguimos repetidamente nuestro texto a través de varias funciones de orden superior. En el caso de una gran cantidad de artículos de colección, el </font></font><code><font color="#0000FF">Collection</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendimiento puede caer en picado. Por ejemplo, si primero usamos </font></font><code><font color="#0000FF">filter(_:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y, y luego - </font></font><code><font color="#0000FF">first</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En</font></font><code>Swift 4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se han agregado algunas opciones de funciones nuevas para mejorar el rendimiento, y aquí hay algunos consejos para escribir código más rápido. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Uso </font></font><code><font color="#0000FF">contains</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, NO</font></font><code><font color="#0000FF">first( where: ) != nil</font></code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La verificación de que un objeto está en una colección </font></font><code><font color="#0000FF">Collection</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se puede hacer de muchas maneras. </font><font style="vertical-align: inherit;">El mejor rendimiento es proporcionado por la función </font></font><code><font color="#0000FF">contains</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CÓDIGO CORRECTO</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] numbers.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CÓDIGO INCORRECTO </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] numbers.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> number == <span class="hljs-number"><span class="hljs-number">1</span></span> }.isEmpty == <span class="hljs-literal"><span class="hljs-literal">false</span></span> numbers.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> number == <span class="hljs-number"><span class="hljs-number">1</span></span> }) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Use validación </font></font><code><font color="#0000FF">isEmpty</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, NO una comparación </font></font><code><font color="#0000FF">count</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con cero</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que para algunas colecciones el acceso a la propiedad </font></font><code><font color="#0000FF">count</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se realiza iterando sobre todos los elementos de la colección. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CÓDIGO CORRECTO</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [] numbers.isEmpty</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CÓDIGO INCORRECTO </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [] numbers.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Verifique la cadena vacía </font></font><code><font color="#0000FF">String</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con</font></font><code><font color="#0000FF">isEmpty</font></code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String </font></font><code><font color="#0000FF">String</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es una colección de personajes </font></font><code><font color="#0000FF">[Character]</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto significa que para cadenas también es </font></font><code><font color="#0000FF">String</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mejor usar </font></font><code><font color="#0000FF">isEmpty</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CÓDIGO CORRECTO</font></font><br><br><pre> <code class="swift hljs">myString.isEmpty</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CÓDIGO INCORRECTO </font></font><br><br><pre> <code class="swift hljs">myString == <span class="hljs-string"><span class="hljs-string">""</span></span> myString.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Obtener el primer elemento que satisface ciertas condiciones. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La iteración sobre toda la colección para obtener el primer objeto que satisfaga ciertas condiciones se puede realizar utilizando el método </font></font><code><font color="#0000FF">filter</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seguido por el método </font></font><code><font color="#0000FF">first</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero el </font><font style="vertical-align: inherit;">método </font><font style="vertical-align: inherit;">es el mejor en términos de velocidad </font></font><code><font color="#0000FF">first (where:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este método deja de iterar sobre la colección tan pronto como cumple con la condición necesaria. </font><font style="vertical-align: inherit;">El método </font></font><code><font color="#0000FF">filter</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">continuará iterando sobre toda la colección, independientemente de si cumple con los elementos necesarios o no. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, lo mismo es cierto para el método </font></font><code><font color="#0000FF">last (where:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CÓDIGO CORRECTO</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, -<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, -<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> firstNegative = numbers.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { $<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> })</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CÓDIGO INCORRECTO </font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> allEven = numbers.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span> % <span class="hljs-number"><span class="hljs-number">2</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span> }.isEmpty</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A veces, cuando la colección </font></font><code><font color="#0000FF">Collection</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es muy grande y el rendimiento es crítico para usted, vale la pena volver a comparar los enfoques imperativos y funcionales y elegir el que más le convenga.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> TAREA 2 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay otro gran ejemplo de un uso muy conciso de una función de orden superior </font></font><code><font color="#0000FF">reduce (_:, _:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que he encontrado. Este es un juego </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SET</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aquí están sus reglas básicas. El nombre del juego </font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proviene de la palabra inglesa "set" - "set". </font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">81 cartas participan </font><font style="vertical-align: inherit;">en el juego </font><font style="vertical-align: inherit;">, cada una con una imagen única: </font></font><br><br><img src="https://habrastorage.org/webt/ho/tg/rr/hotgrrs2vjmbgdyuxo0l4if6fai.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada carta tiene 4 atributos, que se enumeran a continuación: </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cantidad</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cada carta tiene uno, dos o tres símbolos. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo de caracteres</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : óvalos, rombos u ondas. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : los símbolos pueden ser rojos, verdes o morados. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relleno</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : los caracteres pueden estar vacíos, sombreados o sombreados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Propósito del juego.</font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Entre las 12 cartas dispuestas sobre la mesa, debe encontrar </font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(un conjunto) que consta de 3 cartas, en las que cada uno de los signos coincide completamente o difiere por completo en las 3 cartas. Todas las señales deben cumplir completamente con esta regla. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ejemplo, el número de caracteres en las 3 cartas debe ser igual o diferente, el color en las 3 cartas debe ser igual o diferente, y así sucesivamente ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este ejemplo, solo nos interesará el Modelo de mapa </font></font><code>SET</code> <code><font color="#0000FF">struct SetCard</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el algoritmo para determinar </font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por 3er mapas </font></font><code><font color="#0000FF">isSet( cards:[SetCard])</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SetCard</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Equatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number: <span class="hljs-type"><span class="hljs-type">Variant</span></span> <span class="hljs-comment"><span class="hljs-comment">// number - 1, 2, 3 let color: Variant // color - 1, 2, 3 (, , , ) let shape: Variant // symbol - 1, 2, 3 (, , , ) let fill: Variant // fill - 1, 2, 3 (, , , ) enum Variant: Int, CaseIterable { case v1 = 1 case v2 case v3 } static func isSet(cards: [SetCard]) -&gt; Bool { guard cards.count == 3 else {return false} let sums = [ cards.reduce(0, { $0 + $1.number.rawValue }), cards.reduce(0, { $0 + $1.color.rawValue }), cards.reduce(0, { $0 + $1.shape.rawValue }), cards.reduce(0, { $0 + $1.fill.rawValue }) ] return sums.reduce(true, { $0 &amp;&amp; ($1 % 3 == 0) }) } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los modelos cada característica - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">número</font></font></i> <code><font color="#0000FF">number</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipo de símbolo</font></font></i> <code><font color="#0000FF">shape</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de color</font></font></i> <code><font color="#0000FF">color</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de llenado</font></font></i> <code><font color="#0000FF">fill</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - presentados lista </font></font><code><font color="#0000FF">Variant</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que tiene tres valores posibles </font></font><code><font color="#0000FF">var1</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">var2</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code><font color="#0000FF">var3</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que corresponde a la 3ª enteros </font></font><code><font color="#0000FF">rawValue</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code><font color="#0000FF">1,2,3</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. De esta forma, </font></font><code><font color="#0000FF">rawValue</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es fácil de operar. Si tomamos una indicación, por ejemplo </font></font><code><font color="#0000FF">color</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a continuación, añadir todo </font></font><code><font color="#0000FF">rawValue</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code><font color="#0000FF">colors</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 cartas, nos encontramos con que si </font></font><code><font color="#0000FF">colors</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">los 3 cartas son iguales, la cantidad será igual a </font></font><code><font color="#0000FF">3</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">6</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code><font color="#0000FF">9</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, si son diferentes, entonces la cantidad será iguales </font></font><code><font color="#0000FF">6</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En cualquiera de estos casos, tenemos la multiplicidad de la tercera suma </font></font><code><font color="#0000FF">rawValue</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para</font></font><code><font color="#0000FF">colors</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las 3 cartas. Sabemos que este es un requisito previo para lo que componen 3 cartas </font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Para que 3 cartas sean realmente </font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necesarias, para todos los signos </font></font><code><font color="#0000FF">SetCard</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Cantidad </font></font><code><font color="#0000FF">number</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Tipo de símbolo </font></font><code><font color="#0000FF">shape</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Color </font></font><code><font color="#0000FF">color</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y Relleno </font></font><code><font color="#0000FF">fill</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) su suma debe </font></font><code><font color="#0000FF">rawValue</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser un múltiplo de la 3ra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, en el </font></font><code><font color="#0000FF">static</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método, </font></font><code><font color="#0000FF">isSet( cards:[SetCard])</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primero calculamos la matriz </font></font><code><font color="#0000FF">sums</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de las sumas </font></font><code><font color="#0000FF">rawValue</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para todos los 3 mapas para todos mapa 4 rendimiento utilizando función de orden superior </font></font><code><font color="#0000FF">reduce</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un valor inicial igual a </font></font><code><font color="#0000FF">0</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y la acumulación de funciones </font></font><code><font color="#0000FF">{$0 + $1.number.rawValue}</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">{$0 + $1.color.rawValue}</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">{$0 + $1.shape.rawValue}</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">{ {$0 + $1.fill.rawValue}</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cada elemento de la matriz </font></font><code><font color="#0000FF">sums</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe ser un múltiplo de 3er, y nuevamente usamos la función</font></font><code><font color="#0000FF">reduce</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero esta vez con un valor inicial igual </font></font><code><font color="#0000FF">true</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y que acumula la función lógica " </font></font><code>AND</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><code><font color="#0000FF">{$0 &amp;&amp; ($1 % 3) == 0}</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swift 5,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para probar la multiplicidad de un número por otro, se introduce una función en </font></font><code><font color="#0000FF">isMultiply(of:)</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar del operador </font></font><code><font color="#0000FF">%</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">restante. También mejorará la legibilidad del código: </font></font><code><font color="#0000FF">{ $0 &amp;&amp; ($1.isMultiply(of:3) }</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este código fantásticamente corto para descubrir si 3 </font></font><code><font color="#0000FF">SetCard</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cartas son las </font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i-ésimas se obtiene gracias al </font><font style="vertical-align: inherit;">enfoque </font><font style="vertical-align: inherit;">" </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funcional</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", y podemos asegurarnos de que funcione en </font></font><code>Playground</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/9y/cg/6e/9ycg6e0hzi_kfdc4kvsnd0cnjsy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cómo </font></font><code>SET</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">construir la interfaz de usuario ( </font></font><code>UI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">en este Modelo de juego </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Características puras y efectos secundarios. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una función pura cumple dos condiciones. </font><font style="vertical-align: inherit;">Siempre devuelve el mismo resultado con los mismos parámetros de entrada. </font><font style="vertical-align: inherit;">Y el cálculo del resultado no causa efectos secundarios asociados con la salida de datos externos (por ejemplo, al disco) o con el préstamo de datos fuente del exterior (por ejemplo, el tiempo). </font><font style="vertical-align: inherit;">Esto le permite optimizar significativamente el código. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este tema se </font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">expone perfectamente en </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">point.free</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en los primeros episodios de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funciones</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Efectos secundarios</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que se traducen al ruso y se presentan como </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funciones</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Efectos secundarios"</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Composición de la función </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En un sentido matemático, esto significa aplicar una función al resultado de otra función. En una </font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">función, pueden devolver un valor que puede usar como entrada para otra función. Esta es una práctica de programación común. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine que tenemos una matriz de enteros y queremos obtener una matriz de cuadrados de números pares únicos en la salida. Por lo general, implementamos esto de la siguiente manera:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> integerArray = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unique</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> array: [Int])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.<span class="hljs-built_in"><span class="hljs-built_in">reduce</span></span>(into: [], { (results, element) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !results.<span class="hljs-built_in"><span class="hljs-built_in">contains</span></span>(element) { results.append(element) } }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">even</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> array: [Int])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span>{ $<span class="hljs-number"><span class="hljs-number">0</span></span>%<span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> array: [Int])</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> array.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>{ $<span class="hljs-number"><span class="hljs-number">0</span></span>*$<span class="hljs-number"><span class="hljs-number">0</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = square(even(unique(integerArray))) <span class="hljs-comment"><span class="hljs-comment">// it returns [4, 16, 36, 64]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este código nos da el resultado correcto, pero ve que la legibilidad de la última línea de código no es tan fácil. La secuencia de funciones (de derecha a izquierda) es la opuesta a la que estamos acostumbrados (de izquierda a derecha) y nos gustaría ver aquí. Necesitamos dirigir nuestra lógica primero a la parte más interna de las incrustaciones múltiples: a una matriz </font></font><code><font color="#0000FF">inegerArray</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, luego a una función externa a esta matriz </font></font><code><font color="#0000FF">unique</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, luego subimos un nivel más: una función </font></font><code><font color="#0000FF">even</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y, finalmente, una función en conclusión </font></font><code><font color="#0000FF">square</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y aquí la "composición" de funciones </font></font><code><font color="#0000FF">&gt;&gt;&gt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font><font style="vertical-align: inherit;">operadores nos ayuda </font></font><code><font color="#0000FF">|&gt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que nos permite escribir el código de una manera muy conveniente, representando el procesamiento de la matriz original </font></font><code><font color="#0000FF">integerArray</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como un "transportador" de funciones:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array1 = integerArray |&gt; unique &gt;&gt;&gt; even &gt;&gt;&gt; square</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casi todos los lenguajes de programación tales como funcional especializada </font></font><code>F#</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Elixir</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Elm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilizar estos operadores para las funciones de "composición". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No </font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay operadores integrados de la "composición" de funciones </font></font><code><font color="#0000FF">&gt;&gt;&gt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code><font color="#0000FF">|&gt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero podemos obtenerlos fácilmente con la ayuda de </font></font><code>Generics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">closures ( </font></font><code>closure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y el </font></font><code><font color="#0000FF">infix</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operador:</font></font><br><br><pre> <code class="swift hljs">precedencegroup <span class="hljs-type"><span class="hljs-type">ForwardComposition</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associativity</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> higherThan: <span class="hljs-type"><span class="hljs-type">ForwardApplication</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &gt;&gt;&gt; : <span class="hljs-type"><span class="hljs-type">ForwardComposition</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> &gt;&gt;&gt; &lt;A, B, C&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">left</span></span></span></span><span class="hljs-function"><span class="hljs-params">: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>: @escaping (<span class="hljs-type"><span class="hljs-type">B</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">C</span></span>) -&gt; (<span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">C</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">left</span></span>($<span class="hljs-number"><span class="hljs-number">0</span></span>)) } } precedencegroup <span class="hljs-type"><span class="hljs-type">ForwardApplication</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">associativity</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> |&gt; : <span class="hljs-type"><span class="hljs-type">ForwardApplication</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> |&gt; &lt;A, B&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: A, f: </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(A)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">B</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(a) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pesar de los costos adicionales, en algunos casos esto puede aumentar significativamente el rendimiento, la legibilidad y la capacidad de prueba de su código. </font><font style="vertical-align: inherit;">Por ejemplo, cuando dentro de </font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usted coloca una cadena completa de funciones utilizando el operador "composición" en </font></font><code><font color="#0000FF">&gt;&gt;&gt;</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar de perseguir una matriz a través de numerosos </font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> integerArray1 = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = integerArray1.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>( { $<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> } &gt;&gt;&gt; { $<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span> } &gt;&gt;&gt; <span class="hljs-type"><span class="hljs-type">String</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (b) <span class="hljs-comment"><span class="hljs-comment">// ["6", "9", "12", "15", "18", "21", "24", "27", "30", "6", "15", "18"]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero no siempre un enfoque funcional da un efecto positivo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al principio, cuando apareció </font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en 2014, todos se apresuraron a escribir bibliotecas con operadores para la "composición" de funciones y resolver una tarea difícil para ese momento, como analizar </font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usando operadores de programación funcional en lugar de usar construcciones infinitamente anidadas </font></font><code><font color="#0000FF">if let</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Yo mismo traduje el </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artículo sobre el análisis funcional JSON que</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> me deleitó con su elegante solución </font><font style="vertical-align: inherit;">y era fanático de la biblioteca </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Argo</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero los desarrolladores </font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tomaron un camino completamente diferente y propusieron, sobre la base de la tecnología orientada al protocolo, una forma mucho más concisa de escribir código. Para "entregar" los </font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datos directamente a</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo suficiente como para hacer esto </font></font><code></code> <code><font color="#0000FF">Codable</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que implementa automáticamente este protocolo, si el modelo se compone de las conocidas </font></font><code>Swift</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estructuras de datos: </font></font><code><font color="#0000FF">String</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">Int</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">URL</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">Array</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">Dictionary</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, etc.</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Blog</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url: <span class="hljs-type"><span class="hljs-type">URL</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tener </font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datos de ese </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">famoso artículo</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ...</font></font><br><pre> <code class="swift hljs">[ { <span class="hljs-string"><span class="hljs-string">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">73</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"Bloxus test"</span></span>, <span class="hljs-string"><span class="hljs-string">"url"</span></span> : <span class="hljs-string"><span class="hljs-string">"http://remote.bloxus.com/"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"id"</span></span> : <span class="hljs-number"><span class="hljs-number">74</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"Manila Test"</span></span>, <span class="hljs-string"><span class="hljs-string">"url"</span></span> : <span class="hljs-string"><span class="hljs-string">"http://flickrtest1.userland.com/"</span></span> } ]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... en este momento solo necesita una línea de código para obtener una variedad de blogs </font></font><code><font color="#0000FF">blogs</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> blogs = <span class="hljs-type"><span class="hljs-type">Bundle</span></span>.main.path(forResource: <span class="hljs-string"><span class="hljs-string">"blogs"</span></span>, ofType: <span class="hljs-string"><span class="hljs-string">"json"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(<span class="hljs-type"><span class="hljs-type">URL</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(fileURLWithPath:)) .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(contentsOf: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode([<span class="hljs-type"><span class="hljs-type">Blog</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (<span class="hljs-string"><span class="hljs-string">"\(blogs!)"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// [id: 73 name: Bloxus test url: http://remote.bloxus.com/, // id: 74 name: Manila Test url: http://flickrtest1.userland.com/]</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo el mundo se ha olvidado de usar los operadores de la "composición" de funciones para analizar </font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, si hay otra manera más fácil y comprensible de hacerlo mediante protocolos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si todo es tan fácil, entonces podemos "subir" </font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datos a modelos más complejos. </font><font style="vertical-align: inherit;">Supongamos que tenemos un archivo de </font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datos que tiene un nombre </font></font><code>user.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y se encuentra en nuestro directorio </font></font><code>Resources.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Contiene datos sobre un usuario:</font></font><br><br><pre> <code class="swift hljs">{ <span class="hljs-string"><span class="hljs-string">"email"</span></span>: <span class="hljs-string"><span class="hljs-string">"blob@pointfree.co"</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Blob"</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y tenemos un </font></font><code><font color="#0000FF">Codable</font></code> <code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usuario </font></font><code><font color="#0000FF">User</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un inicializador de los datos </font></font><code><font color="#0000FF">json</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> email: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(json: <span class="hljs-type"><span class="hljs-type">Data</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newValue = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode(<span class="hljs-type"><span class="hljs-type">User</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: json) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = newValue } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos obtener fácilmente un nuevo usuario </font></font><code><font color="#0000FF">newUser</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un código funcional aún más simple:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newUser = <span class="hljs-type"><span class="hljs-type">Bundle</span></span>.main.path(forResource: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, ofType: <span class="hljs-string"><span class="hljs-string">"json"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(<span class="hljs-type"><span class="hljs-type">URL</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(fileURLWithPath:)) .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(contentsOf: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } .flatMap { <span class="hljs-type"><span class="hljs-type">User</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(json: $<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, </font></font><code><font color="#0000FF">newUser</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habrá un </font><font style="vertical-align: inherit;">TIPO </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es decir </font></font><code><font color="#0000FF">User?</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/ws/hp/ba/wshpbajpp-wrpb00sxusmhycttk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supongamos que en nuestro directorio </font></font><code>Resources</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay otro archivo con un nombre </font></font><code>invoices.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y contiene datos sobre las facturas de este usuario.</font></font><br><br><pre> <code class="swift hljs">[ { <span class="hljs-string"><span class="hljs-string">"amountPaid"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-string"><span class="hljs-string">"amountDue"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"closed"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, { <span class="hljs-string"><span class="hljs-string">"amountPaid"</span></span>: <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">"amountDue"</span></span>: <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">"closed"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> } ]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos cargar estos datos exactamente como lo hicimos con </font></font><code><font color="#0000FF">User</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Definamos la estructura como un modelo de factura </font></font><code><font color="#0000FF">struct Invoice</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invoice</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Codable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> amountDue: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> amountPaid: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> closed: <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id: <span class="hljs-type"><span class="hljs-type">Int</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... y decodifica la </font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matriz de facturas </font><font style="vertical-align: inherit;">presentada anteriormente </font></font><code><font color="#0000FF">invoices</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, cambiando solo la ruta del archivo y la lógica de decodificación </font></font><code><font color="#0000FF">decode</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invoices = <span class="hljs-type"><span class="hljs-type">Bundle</span></span>.main.path(forResource: <span class="hljs-string"><span class="hljs-string">"invoices"</span></span>, ofType: <span class="hljs-string"><span class="hljs-string">"json"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>( <span class="hljs-type"><span class="hljs-type">URL</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(fileURLWithPath:) ) .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(contentsOf: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode([<span class="hljs-type"><span class="hljs-type">Invoice</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: $<span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre><br> <code></code> <code><font color="#0000FF">invoices</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">será </font></font><code><font color="#0000FF">[Invoice]?</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/webt/rk/-s/l0/rk-sl0uz-jcgqfdxuqlrzhpbrby.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora nos gustaría conectar al usuario </font></font><code><font color="#0000FF">user</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con sus facturas </font></font><code><font color="#0000FF">invoices</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, si no son iguales </font></font><code><font color="#0000FF">nil</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y guardar, por ejemplo, en la estructura del sobre </font></font><code><font color="#0000FF">UserEnvelope</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que se envía al usuario junto con sus facturas:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserEnvelope</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> user: <span class="hljs-type"><span class="hljs-type">User</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invoices: [<span class="hljs-type"><span class="hljs-type">Invoice</span></span>] }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lugar de actuar dos veces </font></font><code><font color="#0000FF">if let</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newUser = newUser, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invoices = invoices { }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... escribamos un análogo funcional del doble </font></font><code><font color="#0000FF">if let</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como una </font></font><code>Generic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">función </font><font style="vertical-align: inherit;">auxiliar </font></font><code><font color="#0000FF">zip</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que convierte dos </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valores en una </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tupla:</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zip</span></span></span><span class="hljs-function">&lt;A, B&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a: A?, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b: B?)</span></span></span></span> -&gt; (<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>)? { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = a, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = b { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a, b) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¡Ahora no tenemos ninguna razón para asignar algo a las variables </font></font><code><font color="#0000FF">newUser</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code><font color="#0000FF">invoices</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, simplemente construimos todo en nuestra nueva función </font></font><code><font color="#0000FF">zip</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, usamos el inicializador </font></font><code><font color="#0000FF">UserEnvelope.init</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y todo funcionará!</font></font><br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userEnv = <span class="hljs-built_in"><span class="hljs-built_in">zip</span></span>( <span class="hljs-type"><span class="hljs-type">Bundle</span></span>.main.path(forResource: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, ofType: <span class="hljs-string"><span class="hljs-string">"json"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(<span class="hljs-type"><span class="hljs-type">URL</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(fileURLWithPath:)) .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(contentsOf: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } .flatMap { <span class="hljs-type"><span class="hljs-type">User</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(json: $<span class="hljs-number"><span class="hljs-number">0</span></span>) }, <span class="hljs-type"><span class="hljs-type">Bundle</span></span>.main.path(forResource: <span class="hljs-string"><span class="hljs-string">"invoices"</span></span>, ofType: <span class="hljs-string"><span class="hljs-string">"json"</span></span>) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>(<span class="hljs-type"><span class="hljs-type">URL</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(fileURLWithPath:)) .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(contentsOf: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } .flatMap { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>().decode([<span class="hljs-type"><span class="hljs-type">Invoice</span></span>].<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: $<span class="hljs-number"><span class="hljs-number">0</span></span>) } ).flatMap (<span class="hljs-type"><span class="hljs-type">UserEnvelope</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span> (<span class="hljs-string"><span class="hljs-string">"\(userEnv!)"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// UserEnvelope(user: id: 42 name: Blob , // invoices: [id: 1 amountDue: 0 amountPaid: 1000 closed: true, // id: 2 amountDue: 500 amountPaid: 500 closed: false])</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En una sola expresión, </font><font style="vertical-align: inherit;">se </font><font style="vertical-align: inherit;">empaqueta un algoritmo completo para entregar </font></font><code>JSON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datos a uno complejo </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en forma de estructura </font></font><code><font color="#0000FF">struct UserEnvelope</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><ul><li>    <code><font color="#0000FF">zip</font></code> ,  ,         .     <code><font color="#0000FF">user</font></code> , <code>JSON</code>   ,    <code><font color="#0000FF">invoices</font></code> ,      <code>JSON</code> .         . </li><li>    <code><font color="#0000FF">map</font></code> ,  ,   «»       . </li><li>    <code><font color="#0000FF">flatMap</font></code> ,  ,        ,     . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operaciones </font></font><code><font color="#0000FF">zip</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">representan un tipo de </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lenguaje específico</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">dominio (DSL)</font></a></b><font style="vertical-align: inherit;"> para la conversión de datos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos desarrollar aún más esta demostración para representar la lectura asíncrona del contenido de un archivo como una función especial que puede ver en </font></font><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointfree.co</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No soy un fanático de la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programación funcional en</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> todas partes y en todo, pero me parece aconsejable su uso moderado.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusión </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di ejemplos de varios programación funcional dispone de </font></font><code>Swf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t «fuera de la caja", basado en el uso de funciones de orden superior </font></font><code><font color="#0000FF">map</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">flatMap</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">reduce</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">filter</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el otro para las secuencias </font></font><code><font color="#0000FF">Sequence</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code><font color="#0000FF">Optional</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code><font color="#0000FF">Result</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pueden ser los "caballos de batalla" de la creación de código, </font></font><code>,</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especialmente si las </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estructuras de </font><font style="vertical-align: inherit;">valor </font></font><code><font color="#0000FF">struct</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y las enumeraciones están </font><font style="vertical-align: inherit;">involucradas allí </font></font><code><font color="#0000FF">enum</font></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Un desarrollador de </font></font><code>iOS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplicaciones debe poseer esta herramienta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todas las demos compiladas </font></font><code>Playground</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se pueden encontrar en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si tiene problemas con el lanzamiento </font></font><code>Playground</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, puede ver este artículo:</font></font><br><br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cómo deshacerse de los errores de "congelación" de Xcode Playground con los mensajes "Launching Simulator" y "Running Playground".</font></font></a></b> <br><br>  Referencias <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Functional Programming in Swift: An Introduction.</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">An Introduction to Functional Programming in Swift.</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">The Many Faces of Flat-Map: Part 3</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Inside the Standard Library: Sequence.map()</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">Practical functional programming in Swift</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440722/">https://habr.com/ru/post/440722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440712/index.html">La nube es solo la computadora de alguien</a></li>
<li><a href="../440714/index.html">Cómo nos afecta la reducción de la tasa de adquisición (tarjetahabientes)</a></li>
<li><a href="../440716/index.html">Implementación del IDCS premontado más grande para autoridades públicas en Volgogrado</a></li>
<li><a href="../440718/index.html">Transferencia de datos entre escenas en Unity: aplicación de valores múltiples al desarrollo simple de juegos</a></li>
<li><a href="../440720/index.html">Implementamos IU en iOS: mejoramos, aceleramos, escalamos</a></li>
<li><a href="../440724/index.html">Selección: 4 servicios útiles para potenciales inmigrantes a los EE. UU., Europa y otros países</a></li>
<li><a href="../440726/index.html">El juego de los arquetipos: cómo funciona la narración de historias para marcas tecnológicas</a></li>
<li><a href="../440728/index.html">Desarrollo móvil: de la idea a la estimación de costos</a></li>
<li><a href="../440732/index.html">Actualice una placa de depuración con un procesador Baikal-T1: agregue una tarjeta SD</a></li>
<li><a href="../440734/index.html">Sesión abierta a la vista en Spring Boot: The Phantom Menace</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>