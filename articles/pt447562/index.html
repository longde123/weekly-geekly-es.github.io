<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèΩ üíáüèæ ‚ñ™Ô∏è Introdu√ß√£o √† engenharia reversa: pirataria no formato de dados do jogo üë©üèø‚Äçüíº üé© ü§æüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 A engenharia reversa de um arquivo de dados desconhecido pode ser descrita como um processo de entendimento gradual. De muitas maneira...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introdu√ß√£o √† engenharia reversa: pirataria no formato de dados do jogo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/447562/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/xm/us/qv/xmusqvwf26b55v59lw13mtqxrru.png"></div><br><h3>  1. Introdu√ß√£o </h3><br>  A engenharia reversa de um arquivo de dados desconhecido pode ser descrita como um processo de entendimento gradual.  De muitas maneiras, assemelha-se a um m√©todo cient√≠fico, aplicado apenas a objetos abstratos criados pelo homem, e n√£o ao mundo natural.  Come√ßamos coletando dados e depois usamos essas informa√ß√µes para apresentar uma ou mais hip√≥teses.  Testamos as hip√≥teses e aplicamos os resultados desses testes para esclarec√™-las.  Se necess√°rio, repita o processo. <br><br>  Desenvolver habilidades de engenharia reversa √© basicamente uma quest√£o de pr√°tica.  Ao adquirir experi√™ncia, voc√™ constr√≥i um entendimento intuitivo do que precisa explorar antes de tudo, quais padr√µes precisa procurar e quais ferramentas s√£o mais convenientes para usar. <br><br>  Neste artigo, falarei em detalhes sobre o processo de arquivos de dados de engenharia reversa de um jogo de computador antigo para demonstrar como isso √© feito. <br><br><h3>  Um pouco de fundo </h3><br>  Tudo come√ßou quando tentei recriar o <em>Desafio do Chip</em> no Linux. <br><br>  O <em>Desafio do Chip</em> foi lan√ßado originalmente em 1989 para o agora esquecido console port√°til Atari Lynx.  Naquela √©poca, o Atari Lynx era um carro impressionante, mas saiu ao mesmo tempo que o Nintendo Game Boy, que acabou conquistando o mercado. <br><br>  <em>Chip's Challenge</em> √© um jogo de quebra-cabe√ßa com uma vista superior e um mapa de pe√ßas.  Como na maioria dos jogos, o objetivo de cada n√≠vel √© chegar √† sa√≠da.  Na maioria dos n√≠veis, a sa√≠da √© protegida por um conector para o chip, que pode ser ignorado apenas pela coleta de um determinado n√∫mero de chips de computador. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7a/ec3/52a/d7aec352a9ecea5a20825cb1d7eb1273.jpg" alt="imagem"></div><br>  V√≠deo: <a href="">Atari Lynx em a√ß√£o</a> , <a href="">passo a passo de n√≠vel um</a> . <br><br>  Um novo jogo come√ßa no primeiro n√≠vel, com o nome "LI√á√ÉO 1".  Al√©m de chips e um slot para um chip, chaves e portas aparecem nele.  Em outros n√≠veis, surgem obst√°culos como armadilhas, bombas, √°gua e criaturas que (na maioria das vezes) se movem ao longo de rotas previs√≠veis.  Uma ampla variedade de objetos e dispositivos permite criar muitos quebra-cabe√ßas e prazos.  Para completar o jogo, voc√™ precisa passar por mais de 140 n√≠veis. <br><br>  Embora o Lynx eventualmente tenha falhado, o <em>Chip's Challenge</em> provou ser bastante popular e foi portado para muitas outras plataformas, aparecendo no Microsoft Windows, onde se espalhou.  Ao redor do jogo, uma pequena mas dedicada base de f√£s se formou e, com o tempo, foi escrito um editor de n√≠veis que permitia aos jogadores criar in√∫meros n√≠veis. <br><br>  E √© a√≠ que a minha hist√≥ria come√ßa.  Decidi que queria criar uma vers√£o do mecanismo b√°sico de jogos de c√≥digo aberto para poder jogar o <em>Desafio do Chip</em> no Linux e Windows e facilitar a execu√ß√£o de todos os n√≠veis criados pelos f√£s. <br><br>  A exist√™ncia do editor de n√≠veis acabou sendo um milagre para mim, porque eu pude explorar os recursos ocultos da l√≥gica do jogo, criando meus pr√≥prios n√≠veis e realizando testes.  Infelizmente, n√£o havia um editor de n√≠veis para o jogo original do Lynx; ele apareceu apenas na porta mais conhecida do Windows. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a57/5e9/279/a575e927941878177f8b346378d1735d.jpg" alt="imagem"></div><br>  A porta do Windows n√£o foi criada pelos desenvolvedores originais, surgiram muitas altera√ß√µes na l√≥gica do jogo (e nem todas foram intencionais).  Quando comecei a escrever meu mecanismo, queria recriar nele a l√≥gica do jogo original no Lynx e a vers√£o mais conhecida do Windows.  Mas a falta de um editor de n√≠veis no Lynx limitou seriamente minha capacidade de estudar o jogo original em detalhes.  A porta do Windows tinha uma vantagem: os n√≠veis foram armazenados em um arquivo de dados separado, o que simplificou sua detec√ß√£o e engenharia reversa.  O jogo para Lynx foi distribu√≠do em cartuchos de ROM contendo imagens de sprites, efeitos sonoros e c√≥digo de m√°quina, al√©m de dados de n√≠vel que foram executados todos juntos.  N√£o h√° dicas sobre onde os dados est√£o localizados neste despejo de 128 kilobytes da ROM, ou como eles se parecem, e sem esse conhecimento, n√£o pude criar um editor de n√≠veis para a vers√£o do Lynx. <br><br>  Certa vez, em um processo de pesquisa, me deparei com uma c√≥pia da porta do <em>Chip's Challenge</em> no MS-DOS.  Como na maioria das portas iniciais do jogo, sua l√≥gica estava mais pr√≥xima do original do que na vers√£o para Windows.  Quando examinei os dados do programa para descobrir como eles s√£o armazenados, fiquei surpreso ao descobrir que os dados do n√≠vel estavam alocados em um diret√≥rio separado e cada n√≠vel foi armazenado em seu pr√≥prio arquivo.  Tendo dados de n√≠vel t√£o convenientemente separados, sugeri que n√£o seria muito dif√≠cil fazer a engenharia reversa dos arquivos de dados de n√≠vel.  E isso permitir√° que voc√™ escreva um editor de n√≠veis para a vers√£o do jogo no MS-DOS.  Decidi que essa era uma oportunidade interessante. <br><br>  Mas outro membro da comunidade do <em>Chip's Challenge</em> me alertou sobre um fato interessante.  O conte√∫do dos arquivos de n√≠vel do MS-DOS acabou sendo um despejo de bytes do ROM Lynx.  Isso significava que, se eu pudesse decodificar os arquivos do MS-DOS, poderia usar esse conhecimento para ler e alterar os n√≠veis dentro do despejo de ROM do Lynx.  Em seguida, voc√™ pode criar um editor de n√≠veis diretamente para o jogo original no Lynx. <br><br>  De repente, minha principal prioridade era arquivos de n√≠vel de engenharia reversa para o MS-DOS. <br><br><h3>  Arquivos de dados </h3><br>  Aqui est√° um link para o diret√≥rio <a href="">tarball que</a> cont√©m todos os arquivos de dados.  Dou-o no caso de voc√™ querer repetir depois de mim todas as etapas descritas neste artigo ou tentar decodificar os arquivos de dados voc√™ mesmo. <br><blockquote>  <strong>Isso √© legal?</strong>  Boa pergunta  Como esses arquivos s√£o apenas uma pequena parte do programa para MS-DOS e, por si s√≥, s√£o in√∫teis, e como eu os publico apenas para fins educacionais, acredito que isso se enquadre nos requisitos de uso justo.  Espero que todas as partes interessadas concordem comigo.  (Se, no entanto, receber uma carta amea√ßadora de advogados, posso alterar o artigo para apresentar os arquivos de dados de uma maneira engra√ßada e depois declarar que √© uma par√≥dia.) </blockquote><br><h3>  Pr√©-requisitos </h3><br>  Assumirei que voc√™ conhece o c√°lculo hexadecimal, mesmo que n√£o saiba a decodifica√ß√£o de valores hexadecimais, e tamb√©m que voc√™ est√° um pouco familiarizado com o shell Unix.  A sess√£o do shell mostrada neste artigo √© executada em um sistema Linux padr√£o, mas os comandos quase usados ‚Äã‚Äãs√£o utilit√°rios comuns do Unix e s√£o amplamente distribu√≠dos em outros sistemas semelhantes ao Unix. <br><br><h3>  Primeiro olhar </h3><br>  Aqui est√° uma lista do diret√≥rio que cont√©m os arquivos de dados da porta no MS-DOS: <br><blockquote><pre>  N√≠veis de $ ls
 all_full.pak cake_wal.pak eeny_min.pak iceberg.pak li√ß√£o_5.pak mulligan.pak playtime.pak southpol.pak totally_.pak
 alphabet.pak castle_m.pak elementa.pak ice_cube.pak li√ß√£o_6.pak nice_day.pak potpourr.pak special.pak traffic_.pak
 amsterda.pak catacomb.pak fireflie.pak icedeath.pak li√ß√£o_7.pak pesadelo.pak problemas.pak spirals.pak trinity.pak
 apartmen.pak cellbloc.pak firetrap.pak icehouse.pak li√ß√£o_8.pak now_you_.pak refracti.pak spooks.pak trust_me.pak
 arcticfl.pak chchchip.pak floorgas.pak invincib.pak lagosta_.pak nozes_e.pak reverse_.pak steam.pak unders.pak
 Bolas_o_.pak chiller.pak for√ßado_e.pak i.pak lock_blo.pak em_the_r.pak rink.pak stripes.pak up_the_b.pak
 beware_o.pak chipmine.pak force_fi.pak i_slide.pak loop_aro.pak oorto_ge.pak roadsign.pak suicide.pak vanishin.pak
 blink.pak citybloc.pak force_sq.pak jailer.pak memory.pak open_que.pak sampler.pak telebloc.pak v√≠tima.pak
 blobdanc.pak colony.pak fortune_.pak jumping_.pak metastab.pak oversea_.pak scavenge.pak telenet.pak vortex.pak
 blobnet.pak corridor.pak four_ple.pak kablam.pak mind_blo.pak pain.pak scoundre.pak t_fair.pak wars.pak
 block_fa.pak cypher.pak four_squ.pak knot.pak mishmesh.pak paranoia.pak vendo_s.pak the_last.pak writers_.pak
 block_ii.pak deceptio.pak glut.pak ladder.pak miss_dir.pak parcial_.pak short_ci.pak the_mars.pak yorkhous.pak
 block_n_.pak deepfree.pak goldkey.pak lemmings.pak mixed_nu.pak pentagra.pak shrinkin.pak the_pris.pak
 block_ou.pak digdirt.pak go_with_.pak li√ß√£o_1.pak mix_up.pak perfect_.pak skelzie.pak three_do.pak
 block.pak digger.pak grail.pak li√ß√£o_2.pak monstro_.pak pier_sev.pak slide_st.pak time_lap.pak
 bounce_c.pak doublema.pak hidden_d.pak li√ß√£o_3.pak morton.pak ping_pon.pak slo_mo.pak torturec.pak
 brushfir.pak drawn_an.pak hunt.pak li√ß√£o_4.pak mugger_s.pak playhous.pak socialis.pak tossed_s.pak </pre></blockquote>  Como voc√™ pode ver, todos os arquivos terminam em <code>.pak</code> .  <code>.pak</code> √© a permiss√£o padr√£o para o arquivo de dados do aplicativo e, infelizmente, n√£o nos fornece nenhuma informa√ß√£o sobre sua estrutura interna.  Os nomes dos arquivos s√£o os oito primeiros caracteres do nome do n√≠vel, com algumas exce√ß√µes.  (Por exemplo, nos nomes dos arquivos de n√≠vel ‚ÄúBLOCK BUSTER‚Äù e ‚ÄúBLOCK BUSTER II‚Äù, a palavra ‚Äúbuster‚Äù √© omitida para que n√£o correspondam.) <br><blockquote><pre>  n√≠veis de $ ls |  wc
      17 148 1974 </pre></blockquote>  Existem 148 arquivos de dados no diret√≥rio, e o jogo tem exatamente 148 n√≠veis, ent√£o tudo √© o mesmo aqui. <br><br>  Agora vamos examinar o que esses arquivos s√£o.  <code>xxd</code> √© um utilit√°rio padr√£o para descarregar dados hexadecimais (hexdump).  Vamos ver como √© a li√ß√£o 1. <br><blockquote><pre>  N√≠veis de $ xxd / li√ß√£o_1.pak
 00000000: 1100 cb00 0200 0004 0202 0504 0407 0505 ................
 00000010: 0807 0709 0001 0a01 010b 0808 0d0a 0a11 ................
 00000020: 0023 1509 0718 0200 2209 0d26 0911 270b. # ...... ".. &amp; .. '.
 00000030: 0b28 0705 291e 0127 2705 020d 0122 0704. (..) .. ''
 00000040: 0902 090a 0215 0426 0925 0111 1502 221d ....... &amp;.% .... ".
 00000050: 0124 011d 0d01 0709 0020 001b 0400 1a00. $ ....... ......
 00000060: 2015 2609 1f00 3300 2911 1522 2302 110d. &amp; ... 3.) .. "# ...
 00000070: 0107 2609 1f18 2911 1509 181a 0223 021b .. &amp; ...) ...... # ..
 00000080: 0215 2201 1c01 1c0d 0a07 0409 0201 0201 .. ".............
 00000090: 2826 0123 1505 0902 0121 1505 220a 2727 (&amp;. # .....! .. ". ''
 000000a0: 0b05 0400 060b 0828 0418 780b 0828 0418 ....... (.. x .. (..
 000000b0: 700b 0828 0418 6400 1710 1e1e 1a19 0103 p .. (.. d .........
 000000c0: 000e 1a17 1710 0e1f 010e 1314 1b29 1f1a .............) ..
 000000d0: 0012 101f 011b 0c1e 1f01 1f13 1001 0e13 ................
 000000e0: 141b 001e 1a0e 1610 1f2d 0020 1e10 0116 .........-.  ....
 000000f0: 1024 291f 1a01 1a1b 1019 000f 1a1a 1d1e. $) .............
 00000100: 2d02 </pre></blockquote><blockquote>  <strong>O que √© um utilit√°rio hexdump?</strong>  Um despejo hexadecimal √© uma maneira padr√£o de exibir os bytes exatos de um arquivo bin√°rio.  A maioria dos valores de bytes n√£o pode ser associada a caracteres ASCII imprim√≠veis ou eles t√™m uma apar√™ncia incompreens√≠vel (como um caractere de tabula√ß√£o).  Em um dump hexadecimal, bytes individuais s√£o emitidos como valores num√©ricos.  Os valores s√£o exibidos em hexadecimal, da√≠ o nome.  No exemplo acima, 16 bytes s√£o exibidos em uma linha de sa√≠da.  A coluna mais √† esquerda mostra a posi√ß√£o da linha no arquivo, tamb√©m em hexadecimal, para que o n√∫mero em cada linha seja aumentado em 16. Os bytes s√£o exibidos em oito colunas e dois bytes em cada coluna.  O hexdump √† direita mostra a apar√™ncia dos bytes quando exibidos por caracteres, apenas todos os valores ASCII n√£o imprim√≠veis s√£o substitu√≠dos por pontos.  Isso facilita a localiza√ß√£o de strings que podem ser incorporadas em um arquivo bin√°rio. </blockquote>  Obviamente, a engenharia reversa desses arquivos n√£o se resume apenas a navegar pelo conte√∫do e explorar o que √© vis√≠vel l√°.  At√© o momento, nada nos diz que fun√ß√µes os dados executam. <br><br><h3>  O que esperamos ver? </h3><br>  Vamos dar um passo atr√°s e esclarecer a situa√ß√£o: que dados espec√≠ficos esperamos encontrar nesses arquivos de dados? <br><br>  O mais √≥bvio √© um certo "mapa" do n√≠vel: dados indicando as posi√ß√µes de paredes e portas, bem como tudo o mais, o que torna o n√≠vel √∫nico. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe5/03a/ae9/fe503aae95f2acaa3a3663c43f528cef.png"></div><br>  (Felizmente para n√≥s, os f√£s do jogo fizeram um trabalho minucioso e coletaram mapas completos para todos os 148 n√≠veis, para que possamos us√°-los para saber o que deve estar em cada mapa.) <br><br>  Al√©m do mapa, cada n√≠vel deve ter v√°rios outros atributos.  Por exemplo, voc√™ pode perceber que cada n√≠vel tem um nome, por exemplo, "LI√á√ÉO 1", "JOGO PERFEITO", "DRAWN AND QUARTERED" e assim por diante.  N√≠veis diferentes tamb√©m t√™m limites de tempo diferentes, portanto, podemos assumir que essas informa√ß√µes tamb√©m est√£o contidas nos dados.  Al√©m disso, cada n√≠vel tem seu pr√≥prio n√∫mero de chips montados.  (Podemos supor que esse n√∫mero simplesmente corresponda ao n√∫mero de chips no n√≠vel, mas acontece que em alguns n√≠veis h√° mais chips do que o necess√°rio para abrir o conector do chip. Pelo menos para esses n√≠veis, o n√∫mero m√≠nimo deve ser indicado de forma expl√≠cita.) <br><br>  Outro dado que esperamos encontrar nos dados de n√≠vel √© o texto da dica.  Em alguns n√≠veis, h√° um "bot√£o de dica" - um grande ponto de interroga√ß√£o no ch√£o.  Quando o Chip aparece nele, um texto de dica de ferramenta √© exibido.  O bot√£o de dica est√° em cerca de 20 n√≠veis. <br><br>  Finalmente, cada n√≠vel tem uma senha - uma sequ√™ncia de quatro letras que permite ao jogador continuar o jogo a partir deste n√≠vel.  (Essa senha √© necess√°ria porque o Lynx n√£o possui um armazenamento de dados. Era imposs√≠vel salvar jogos no console, para que voc√™ pudesse continuar o jogo depois de lig√°-lo usando senhas.) <br><br>  Ent√£o, aqui est√° a nossa lista de dados relevantes: <br><br><ul><li>  Mapa de n√≠vel </li><li>  Nome do n√≠vel </li><li>  N√≠vel de senha </li><li>  Prazo </li><li>  N√∫mero de fichas </li><li>  Texto da dica de ferramenta </li></ul><br>  Vamos estimar aproximadamente o tamanho total dos dados.  A maneira mais f√°cil de determinar o limite de tempo e o n√∫mero de fichas.  Esses dois par√¢metros podem ter valores no intervalo de 0 a 999; portanto, eles provavelmente s√£o armazenados como valores inteiros com um tamanho total de 4 bytes.  A senha sempre consiste em quatro letras, portanto √© mais prov√°vel que seja armazenada como mais quatro bytes, ou seja, apenas 8 bytes.  A dura√ß√£o dos nomes dos n√≠veis varia de quatro a dezenove caracteres.  Se supusermos que precisamos de outro byte para completar a linha, isso significa vinte bytes, ou seja, o subtotal √© 28 bytes.  O texto mais longo da dica de ferramenta tem mais de 80 bytes de tamanho;  se arredondar esse valor para 90, obteremos 118 bytes no total. <br><br>  E o esquema de n√≠veis?  A maioria dos n√≠veis tem um tamanho de 32 √ó 32 pe√ßas.  N√≠veis maiores n√£o existem.  Alguns n√≠veis s√£o mais baixos, mas seria l√≥gico supor que eles s√£o simplesmente incorporados a uma placa 32 √ó 32. Se assumirmos que um byte √© necess√°rio para um bloco, 1024 bytes s√£o necess√°rios para o circuito completo.  Ou seja, em geral, obtemos uma estimativa aproximada de 1142 bytes por n√≠vel.  Obviamente, essa √© apenas uma estimativa inicial aproximada.  √â poss√≠vel que alguns desses elementos sejam armazenados de maneira diferente ou n√£o sejam armazenados em arquivos de n√≠vel.  Ou eles podem conter outros dados que n√£o notamos ou que n√£o conhecemos.  Mas at√© agora estabelecemos uma boa base. <br><br>  Tendo decidido o que esperamos ver nos arquivos de dados, voltemos ao estudo do que eles realmente cont√™m. <br><br><h3>  O que existe e o que n√£o √© </h3><br>  Embora √† primeira vista o arquivo de dados pare√ßa completamente incompreens√≠vel, voc√™ ainda pode notar alguns pontos nele.  Em primeiro lugar, √© isso que <em>n√£o</em> vemos.  Por exemplo, n√£o vemos o nome do n√≠vel ou o texto das dicas.  Voc√™ pode entender que isso n√£o √© uma coincid√™ncia, tendo estudado outros arquivos: <br><blockquote><pre>  N√≠veis de strings $ / * |  menos
 : !!; #
 &amp;&gt; '' :: 4 #
 . ,,!
 -54 ";
 / &amp; 67
 !) 60
 &lt;171
 * (0 *
 82&gt; '= /
 8&gt; &lt;171 &amp;&amp;
 9&gt; # 2 ') (
 ,) 9
  0hX
 `@PX
 ) "" *
 24 ** 5
 ;)) &lt;
 B777: .. 22C1
 E ,, F
 -GDED
 EGFF16G ;; H &lt;
 IECJ
 9K444
 = MBBB &gt;&gt; N9 "O" 9P3? Q
 linhas 1-24 / 1544 (mais) </pre></blockquote>  Nada √© vis√≠vel aqui, exceto fragmentos arbitr√°rios de lixo ASCII. <br><br>  Presumivelmente, em algum lugar nesses arquivos h√° nomes e dicas de n√≠vel, mas eles n√£o s√£o armazenados em ASCII ou passaram por alguma transforma√ß√£o (por exemplo, devido √† compacta√ß√£o). <br><br>  Tamb√©m √© importante notar o seguinte: o arquivo mal atinge 256 bytes de tamanho.  Isso √© muito pequeno, considerando que inicialmente estimamos seu tamanho em mais de 1140 bytes. <br><br>  A op√ß√£o <code>-S</code> classifica os arquivos em ordem decrescente de tamanho. <br><br><blockquote><pre>  N√≠veis $ ls -lS |  cabe√ßa
 592 total
 -rw-r - r-- 1 breadbox breadbox 680 jun 23 2015 mulligan.pak
 -rw-r - r-- 1 breadbox breadbox 675 jun 23 2015 shrinkin.pak
 -rw-r - r-- 1 breadbox breadbox 671 23 de junho de 2015 balls_o_.pak
 -rw-r - r-- 1 breadbox breadbox 648 jun 23 2015 cake_wal.pak
 -rw-r - r-- 1 breadbox breadbox 647 jun 23 2015 citybloc.pak
 -rw-r - r-- 1 breadbox breadbox 639 jun 23 2015 four_ple.pak
 -rw-r - r-- 1 breadbox breadbox 636 jun 23 2015 trust_me.pak
 -rw-r - r-- 1 breadbox breadbox 625 jun 23 2015 block_n_.pak
 -rw-r - r-- 1 breadbox breadbox 622 jun 23 2015 mix_up.pak </pre></blockquote><br>  O arquivo maior ocupa apenas 680 bytes, e isso n√£o √© muito.  E qual ser√° o menor? <br><br>  A op√ß√£o <code>-r</code> diz ao <code>ls</code> para reverter a ordem. <br><br><blockquote><pre>  N√≠veis $ ls -lSr |  cabe√ßa
 592 total
 -rw-r - r-- 1 breadbox breadbox 206 jun 23 2015 kablam.pak
 -rw-r - r-- 1 breadbox breadbox 214 jun 23 2015 fortune_.pak
 -rw-r - r-- 1 breadbox breadbox 219 jun 23 2015 digdirt.pak
 -rw-r - r-- 1 breadbox breadbox 226 jun 23 2015 lesson_2.pak
 -rw-r - r-- 1 breadbox breadbox 229 jun 23 2015 lesson_8.pak
 -rw-r - r-- 1 breadbox breadbox 237 jun 23 2015 parcial_.pak
 -rw-r - r-- 1 breadbox breadbox 239 jun 23 2015 knot.pak
 -rw-r - r-- 1 breadbox breadbox 247 jun 23 2015 cellbloc.pak
 -rw-r - r-- 1 breadbox breadbox 248 jun 23 2015 torturec.pak </pre></blockquote><br>  O arquivo menor ocupa apenas 206 bytes, que √© tr√™s vezes menor que o maior.  Essa √© uma faixa bastante ampla, levando em considera√ß√£o o fato de que esper√°vamos aproximadamente os mesmos tamanhos de n√≠vel. <br><br>  Em nossa avalia√ß√£o inicial, assumimos que o cart√£o precisaria de um byte por bloco e apenas 1024 bytes.  Se cortarmos essa estimativa pela metade, ou seja, cada bloco exigir√° apenas 4 bits (ou dois blocos por byte), o cart√£o ainda ocupar√° 512 bytes.  512 √© menor que 680, mas ainda maior que a maioria dos n√≠veis.  E de qualquer forma - 4 bits fornecer√£o apenas 16 valores diferentes e, no jogo, h√° muito mais objetos diferentes. <br><br>  Ou seja, √© √≥bvio que os cart√µes n√£o s√£o armazenados nesses arquivos em formato aberto.  Eles usam codifica√ß√£o mais complexa, fornecendo uma descri√ß√£o mais eficiente e / ou s√£o de alguma forma compactados.  Por exemplo, no n√≠vel "LI√á√ÉO 1", podemos ver como as entradas ausentes para blocos "vazios" reduzir√£o significativamente o tamanho geral dos dados do mapa. <br><br>  Podemos ver os mapas dos maiores arquivos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9c/175/2b5/b9c1752b51bd23f6dda6893236e0de52.png"></div><br>  <i>Mapa de n√≠vel 57: STRANGE MAZE</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/193/6ec/806/1936ec8062fe1d211522161d7322c213.png"></div><br>  <i>Cart√£o de n√≠vel 98: SHRINKING</i> <br><br>  e compare-os com os mapas dos menores arquivos: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/522/4ef/687/5224ef6870b3120bb4cdc7bf0fde9322.png"></div><br>  <i>Cart√£o de n√≠vel 106: KABLAM</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/812/ac5/5c0/812ac55c04b62d73430a182064af2d90.png"></div><br>  <i>Carta de n√≠vel 112: FORTUNE FAVORECE O</i> <br><br>  Essa compara√ß√£o apoia nossa ideia de que pequenos arquivos de dados correspondem a n√≠veis mais simples ou cont√™m mais redund√¢ncia.  Por exemplo, se os dados forem compactados por algum tipo de codifica√ß√£o de dura√ß√£o da execu√ß√£o, isso pode explicar facilmente os intervalos de tamanho de arquivos diferentes. <br><br>  Se os arquivos forem realmente criptografados, provavelmente teremos que descriptografar a compacta√ß√£o antes de decodificar os dados do cart√£o. <br><br><h3>  Estudamos v√°rios arquivos ao mesmo tempo </h3><br>  Nosso breve estudo do primeiro arquivo de dados nos permitiu fazer algumas suposi√ß√µes, mas n√£o encontrou nada concreto.  Como pr√≥ximo passo, come√ßaremos a explorar os padr√µes de v√°rios arquivos de dados.  Por enquanto, assumimos que todos os 148 arquivos usam o mesmo esquema de pedidos para codificar dados, portanto, procurar padr√µes duplicados nesses arquivos nos ajudar√° a come√ßar. <br><br>  Vamos come√ßar do come√ßo dos ladrilhos.  A parte superior do arquivo provavelmente √© usada para armazenar "metadados" que nos informam sobre o conte√∫do do arquivo.  Observando apenas a primeira linha do dump hexadecimal, podemos realizar uma compara√ß√£o simples e r√°pida dos 16 primeiros bytes e procurar por padr√µes de destaque neles: <br><br><blockquote><pre>  $ para f em n√≠veis / *;  xxd $ f |  sed -n 1p;  feito |  menos
 00000000: 2300 dc01 0300 0004 0101 0a03 030b 2323 # ............. ##
 00000000: 2d00 bf01 0300 0015 0101 2203 0329 2222 -... "..)"
 00000000: 2b00 a101 0301 0105 0000 0601 0207 0505 + ...............
 00000000: 1d00 d300 0200 0003 0101 0402 0205 0102 ................
 00000000: 2d00 7a01 0300 0006 1414 0701 0109 0303 -.z .............
 00000000: 3100 0802 0200 0003 0101 0502 0206 1313 1 ...............
 00000000: 1a00 b700 0200 0003 0100 0502 0206 0101 ................
 00000000: 1a00 0601 0300 0005 0001 0601 0107 0303 ................
 00000000: 2000 7a01 0200 0003 0202 0401 0105 0028 .z ............ (
 00000000: 3a00 a400 0200 0003 2828 0428 0205 0303: ....... ((. (....
 00000000: 2600 da00 0300 0004 0507 0901 010a 0303 &amp; ...............
 00000000: 2400 f000 0300 0004 0303 0504 0407 0101 $ ...............
 00000000: 2a00 ef01 0300 0005 0101 0614 0007 0303 * ...............
 00000000: 2c00 8c01 0300 0004 0303 0500 0107 0101, ...............
 00000000: 2a00 0001 0300 0004 0303 0501 0107 0404 * ...............
 00000000: 1b00 6d01 0200 0003 0101 0502 0206 0003 ..m .............
 00000000: 1e00 1701 0200 0003 0202 0401 0105 0013 ................
 00000000: 3200 ee01 0f00 0015 0101 270f 0f29 1414 2 ......... '..) ..
 00000000: 2a00 5b01 0300 0005 0303 0601 0107 1414 *. [.............
 00000000: 2c00 8a01 0200 0003 0202 0401 0105 0303, ...............
 00000000: 1d00 9c00 0216 1604 0000 0516 0107 0205 ................
 00000000: 2000 e100 0200 0003 0101 0402 0205 0303 ...............
 00000000: 2000 2601 0300 0004 0303 0502 0207 0101. &amp; .............
 00000000: 1f00 f600 0132 0403 0000 0532 3206 0404 ..... 2 ..... 22 ...
 linhas 1-24 / 148 (mais) </pre></blockquote><br>  Olhando para esse despejo, voc√™ pode ver que em cada coluna h√° alguns valores semelhantes. <br><br>  Come√ßando com o primeiro byte, logo percebemos que seu valor est√° em um intervalo muito limitado de valores, no intervalo hexadecimal de <code>40</code> (ou aproximadamente <code>20‚Äì60</code> em decimal).  Este √© um recurso bastante espec√≠fico. <br><br>  Ainda mais interessante √© que o segundo byte de cada arquivo √© sempre zero, sem exce√ß√µes.  O segundo byte provavelmente n√£o √© usado ou √© um espa√ßo reservado.  No entanto, h√° outra possibilidade - esses dois primeiros bytes juntos representam um valor de 16 bits armazenado em ordem little-endian. <br><br><blockquote>  <strong>O que √© little-endian?</strong>  Ao armazenar um valor num√©rico com mais de um byte, voc√™ deve primeiro selecionar a ordem em que os bytes ser√£o armazenados.  Se voc√™ primeiro armazenar um byte representando a parte menor do n√∫mero, isso ser√° chamado de ordem direta ( <em>little-endian</em> );  se voc√™ primeiro armazenar bytes que denotam a maior parte do n√∫mero, essa √© a ordem inversa ( <em>big-endian</em> ).  Por exemplo, escrevemos os valores decimais em ordem inversa (big-endian): a linha "42" significa "quarenta e dois", n√£o "quatro e vinte".  Little-endian √© uma ordem natural para muitas fam√≠lias de microprocessadores, por isso geralmente √© mais popular, com exce√ß√£o dos protocolos de rede, que geralmente exigem big-endian. </blockquote><br>  Se continuarmos a an√°lise, veremos em breve que o terceiro byte no arquivo n√£o √© semelhante aos dois anteriores: seu valor varia em uma ampla faixa.  No entanto, o quarto byte √© sempre <code>00</code> , <code>01</code> ou <code>02</code> e <code>01</code> √© o mais comum.  Isso tamb√©m nos sugere que esses dois bytes constituem outro valor de 16 bits, aproximadamente no intervalo de valores decimais de 0 a 700.  Essa hip√≥tese tamb√©m pode ser confirmada pelo fato de que o valor do terceiro byte √© geralmente baixo se o valor do quarto byte for <code>02</code> e, geralmente, grande se o quarto byte for <code>00</code> . <br><br>  A prop√≥sito, vale a pena notar que esse √© parcialmente o motivo pelo qual o formato de despejo hexadecimal exibe bytes em pares por padr√£o - isso facilita a leitura de uma sequ√™ncia de n√∫meros inteiros de 16 bits.  O formato hexadecimal foi padronizado quando computadores de 16 bits estavam em uso.  Tente substituir <code>xxd</code> por <code>xxd -g1</code> para desativar completamente o agrupamento, e voc√™ perceber√° que reconhecer pares de bytes no meio de uma linha √© muito trabalhoso.  Este √© um exemplo simples de como as ferramentas usadas para estudar dados desconhecidos tendem a nos fazer perceber certos tipos de padr√µes.  √â bom que o <code>xxd</code> destaque esse padr√£o por padr√£o, porque √© muito comum (ainda hoje, quando computadores de 64 bits s√£o usados ‚Äã‚Äãem todos os lugares).  Mas √© √∫til saber como alterar esses par√¢metros se eles n√£o ajudarem. <br><br>  Vamos continuar a explora√ß√£o visual e ver se esse padr√£o √© preservado dos valores inteiros de 16 bits.  O quinto byte geralmente possui valores muito baixos: <code>02</code> e <code>03</code> s√£o encontrados com mais frequ√™ncia e o valor m√°ximo parece ser <code>05</code> .  O sexto byte de um arquivo √© muitas vezes igual a zero - mas √†s vezes cont√©m valores muito maiores, por exemplo <code>32</code> ou <code>2C</code> .  Nesse par, nossa suposi√ß√£o sobre os valores distribu√≠dos no intervalo n√£o √© particularmente confirmada. <br><br><h3>  Estudamos cuidadosamente os valores iniciais </h3><br>  Podemos testar nosso palpite usando <code>od</code> para gerar um dump hexadecimal.  O utilit√°rio <code>od</code> √© semelhante ao <code>xxd</code> , mas fornece uma sele√ß√£o muito maior de formatos de sa√≠da.  Podemos us√°-lo para despejar a sa√≠da como n√∫meros inteiros decimais de 16 bits: <br><br>  A op√ß√£o <code>-t</code> para o utilit√°rio <code>od</code> especifica o formato de sa√≠da.  Nesse caso, <code>u</code> representa n√∫meros decimais n√£o assinados e <code>2</code> representa dois bytes por registro.  (Voc√™ tamb√©m pode especificar esse formato usando a op√ß√£o <code>-d</code> .) <br><br><blockquote><pre>  $ para f em n√≠veis / *;  do od -tu2 $ f |  sed -n 1p;  feito |  menos
 0000000 35 476 3 1024 257 778 2819 8995
 0000000 45 447 3 5376 257 802 10499 8738
 0000000 43 417 259 1281 0 262 1794 1285
 0000000 29 211 2 768 257 516 1282 513
 0000000 45 378 3 1536 5140 263 2305 771
 0000000 49 520 2 768 257 517 1538 4883
 0000000 26 183 2 768 1 517 1538 257
 0000000 26 262 3 1280 256 262 1793 771
 0000000 32 378 2 768 514 260 1281 10240
 0000000 58 164 2 768 10280 10244 1282 771
 0000000 38 218 3 1024 1797 265 2561 771
 0000000 36 240 3 1024 771 1029 1796 257
 0000000 42 495 3 1280 257 5126 1792 771
 0000000 44 396 3 1024 771 5 1793 257
 0000000 42 256 3 1024 771 261 1793 1028
 0000000 27365 2 768 257 517 1538 768
 0000000 30 279 2 768 514 260 1281 4864
 0000000 50 494 15 5376 257 3879 10511 5140
 0000000 42 347 3 1280 771 262 1793 5140
 0000000 44 394 2 768 514 260 1281 771
 0000000 29 156 5634 1046 0 5637 1793 1282
 0000000 32 225 2 768 257 516 1282 771
 0000000 32 294 3 1024 771 517 1794 257
 0000000 31246 12801 772 0 12805 1586 1028
 linhas 1-24 / 148 (mais) </pre></blockquote><br>  Esta sa√≠da mostra que nossas suposi√ß√µes sobre os primeiros bytes estavam corretas.  Vemos que o primeiro valor de 16 bits est√° no intervalo decimal de 20 a 70 e o segundo valor de 16 bits est√° no intervalo decimal de 100 a 600.  No entanto, os valores subsequentes n√£o se comportam t√£o bem.  Certos padr√µes aparecem neles (por exemplo, na quarta posi√ß√£o, surpreendentemente frequentemente 1024), mas eles n√£o t√™m a repetibilidade inerente aos primeiros valores do arquivo. <br><br>  Portanto, vamos primeiro assumir que os quatro primeiros bytes do arquivo s√£o especiais e consistem em dois valores de 16 bits.  Como eles est√£o no in√≠cio do arquivo, eles provavelmente s√£o metadados e ajudam a determinar como ler o restante do arquivo. <br><br>  De fato, o segundo intervalo de valores (100-600) est√° bem pr√≥ximo do intervalo de tamanho de arquivo que observamos anteriormente (208-680).  Talvez isso n√£o seja uma coincid√™ncia?  Vamos apresentar uma hip√≥tese: o valor de 16 bits armazenado no terceiro e quarto bytes do arquivo se correlaciona com o tamanho total do arquivo.  Agora que temos uma hip√≥tese, podemos test√°-la.  Vamos ver se os arquivos grandes neste local realmente t√™m valores grandes o tempo todo e os pequenos t√™m valores pequenos. <br><br>  Para exibir o tamanho do arquivo em bytes sem nenhuma outra informa√ß√£o, voc√™ pode usar <code>wc</code> com a op√ß√£o <code>-c</code> .  Da mesma forma, voc√™ pode adicionar ao <code>od</code> op√ß√µes que permitem exibir apenas os valores de seu interesse.  Em seguida, podemos usar a substitui√ß√£o de comandos para escrever esses valores para projetar vari√°veis ‚Äã‚Äãe exibi-los juntos: <br><br>  A op√ß√£o <code>-An</code> do utilit√°rio <code>od</code> desativa a coluna mais √† esquerda, que exibe o deslocamento no arquivo, e <code>-N4</code> diz <code>od</code> parar ap√≥s os primeiros 4 bytes do arquivo. <br><br><blockquote><pre>  $ para f em n√≠veis / *;  fa√ßa tamanho = $ (wc -c &lt;$ f);  data = $ (od-tuS-An -N4 $ f);  eco "$ size: $ data";  feito |  menos
 585: 35 476
 586: 45 447
 550: 43.417
 302: 29.211
 517: 45 378
 671: 49 520
 265: 26 183
 344: 26.262
 478: 32.378
 342: 58 164
 336: 38 218
 352: 36.240
 625: 42 495
 532: 44.396
 386: 42.256
 450: 27 365
 373: 30 279
 648: 50 494
 477: 42 347
 530: 44.394
 247: 29 156
 325: 32.225
 394: 32.294
 343: 31.246 </pre></blockquote><br>  Olhando para esta sa√≠da, voc√™ pode ver que os valores est√£o aproximadamente correlacionados.  Arquivos menores geralmente t√™m valores mais baixos na segunda posi√ß√£o e arquivos grandes t√™m valores maiores.  No entanto, a correla√ß√£o n√£o √© precisa e vale a pena notar que o tamanho do arquivo √© sempre significativamente maior que o valor armazenado nele. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, o primeiro valor de 16 bits tamb√©m √© geralmente maior com tamanhos grandes de arquivo, mas a correspond√™ncia tamb√©m n√£o √© completa e voc√™ pode facilmente encontrar exemplos de arquivos de tamanho m√©dio com valores relativamente grandes na primeira posi√ß√£o. Mas talvez, se somarmos esses dois valores, a soma deles ser√° melhor correlacionada com o tamanho do arquivo? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar </font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para extrair dois n√∫meros da sa√≠da </font></font><code>od</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em vari√°veis ‚Äã‚Äãseparadas e, em seguida, usar a aritm√©tica do shell para encontrar sua soma: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comando Shell</font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o pode ser usado no lado direito da barra vertical, porque os comandos transferidos para o pipeline s√£o executados em um processador de comandos filho (subshell), que, ao sair, leva suas vari√°veis ‚Äã‚Äãde ambiente para o receptor de bits. </font><font style="vertical-align: inherit;">Portanto, em vez disso, precisamos usar a fun√ß√£o de substitui√ß√£o de processo </font></font><code>bash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e direcionar a sa√≠da </font></font><code>od</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para um arquivo tempor√°rio, que pode ser redirecionado para o comando </font></font><code>read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ para f em n√≠veis / *; </font><font style="vertical-align: inherit;">fa√ßa tamanho = $ (wc -c &lt;$ f); </font><font style="vertical-align: inherit;">leia v1 v2 &lt;&lt; (od -tuS -An -N4 $ f); </font><font style="vertical-align: inherit;">soma = $ (($ v1 + $ v2));</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    eco "$ size: $ v1 + $ v2 = $ sum"; </font><font style="vertical-align: inherit;">feito | </font><font style="vertical-align: inherit;">menos</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
585: 35 + 476 = 511</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
586: 45 + 447 = 492</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
550: 43 + 417 = 460</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
302: 29 + 211 = 240</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
517: 45 + 378 = 423</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
671: 49 + 520 = 569</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
265: 26 + 183 = 209</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
344: 26 + 262 = 288</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
478: 32 + 378 = 410</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
342: 58 + 164 = 222</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
336: 38 + 218 = 256</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
352: 36 + 240 = 276</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
625: 42 + 495 = 537</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
532: 44 + 396 = 440</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
386: 42 + 256 = 298</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
450: 27 + 365 = 392</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
373: 30 + 279 = 309</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
648: 50 + 494 = 544</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
477: 42 + 347 = 389</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
530: 44 + 394 = 438</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
247: 29 + 156 = 185</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
325: 32 + 225 = 257</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
394: 32 + 294 = 326</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
343: 31 + 246 = 277</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
linhas 1-24 / 148 (mais) </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A soma dos dois n√∫meros tamb√©m se correlaciona aproximadamente com o tamanho do arquivo, mas eles ainda n√£o coincidem. </font><font style="vertical-align: inherit;">Qu√£o diferentes eles s√£o? </font><font style="vertical-align: inherit;">Vamos demonstrar sua diferen√ßa:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ para f em n√≠veis / *; </font><font style="vertical-align: inherit;">fa√ßa tamanho = $ (wc -c &lt;$ f); </font><font style="vertical-align: inherit;">leia v1 v2 &lt;&lt; (od -tuS -An -N4 $ f); </font><font style="vertical-align: inherit;">diff = $ ((tamanho $ - $ v1 - $ v2));</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    echo "$ size = $ v1 + $ v2 + $ diff"; </font><font style="vertical-align: inherit;">feito | </font><font style="vertical-align: inherit;">menos</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
585 = 35 + 476 + 74</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
586 = 45 + 447 + 94</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
550 = 43 + 417 + 90</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
302 = 29 + 211 + 62</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
517 = 45 + 378 + 94</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
671 = 49 + 520 + 102</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
265 = 26 + 183 + 56</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
344 = 26 + 262 + 56</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
478 = 32 + 378 + 68</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
342 = 58 + 164 + 120</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
336 = 38 + 218 + 80</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
352 = 36 + 240 + 76</font></font><font></font>
625 = 42 + 495 + 88<font></font>
532 = 44 + 396 + 92<font></font>
386 = 42 + 256 + 88<font></font>
450 = 27 + 365 + 58<font></font>
373 = 30 + 279 + 64<font></font>
648 = 50 + 494 + 104<font></font>
477 = 42 + 347 + 88<font></font>
530 = 44 + 394 + 92<font></font>
247 = 29 + 156 + 62<font></font>
325 = 32 + 225 + 68<font></font>
394 = 32 + 294 + 68<font></font>
343 = 31 + 246 + 66<font></font>
lines 1-24/148 (more) </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A diferen√ßa, ou o valor "restante", √© exibida no lado direito da sa√≠da. </font><font style="vertical-align: inherit;">Esse valor n√£o se enquadra no padr√£o constante, mas parece permanecer aproximadamente em um intervalo limitado de 40 a 120. </font><font style="vertical-align: inherit;">E, novamente, quanto maiores os arquivos, geralmente o valor residual √© maior. </font><font style="vertical-align: inherit;">Mas, √†s vezes, arquivos pequenos tamb√©m t√™m grandes valores residuais; portanto, isso n√£o √© t√£o constante quanto gostar√≠amos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, vale ressaltar que os valores dos res√≠duos nunca s√£o negativos. </font><font style="vertical-align: inherit;">Portanto, a ideia de que esses dois valores de metadados indicam subse√ß√µes de um arquivo permanece atraente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Se voc√™ for cuidadoso o suficiente, voc√™ j√° viu algo dando uma dica sobre uma conex√£o que ainda n√£o foi notada. Se voc√™ n√£o tiver, continue lendo; o segredo ser√° revelado em breve.)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compara√ß√µes maiores entre arquivos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse momento, seria bom poder comparar mais de 16 bytes por vez. Para isso, precisamos de um tipo diferente de visualiza√ß√£o. Uma boa abordagem √© criar uma imagem na qual cada pixel denota um byte separado de um dos arquivos, e a cor denota o valor desse byte. Uma imagem pode mostrar uma fatia de todos os 148 arquivos por vez, se cada arquivo de dados for indicado por uma √∫nica linha de pixels da imagem. Como todos os arquivos t√™m tamanhos diferentes, usamos os primeiros 200 bytes de cada um para criar uma imagem retangular. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A maneira mais f√°cil √© criar uma imagem em escala de cinza, na qual o valor de cada byte corresponde a diferentes n√≠veis de cinza. √â muito simples criar um arquivo PGM com nossos dados, porque o cabe√ßalho PGM consiste apenas em texto ASCII:</font></font><br><br><blockquote><pre> $ echo P5 200 148 255 &gt;hdr.pgm </pre></blockquote><br><blockquote> <strong>   PGM?</strong> PGM,    ¬´portable graymap¬ª (¬´   ¬ª) ‚Äî       ,        :    ASCII,         .        ‚Äî  PBM (¬´portable bitmap¬ª, ¬´  ¬ª),     8   ,  PPM (¬´portable pixmap¬ª, ¬´  ¬ª),     3   . </blockquote><br> <code>P5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â a assinatura inicial para o formato de arquivo PGM. </font><font style="vertical-align: inherit;">Os pr√≥ximos dois n√∫meros </font></font><code>200</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>148</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especificam a largura e a altura da imagem e o √∫ltimo </font></font><code>255</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,, indica o valor m√°ximo por pixel. </font><font style="vertical-align: inherit;">O cabe√ßalho PGM termina com uma nova linha seguida por dados de pixel. </font><font style="vertical-align: inherit;">(√â importante notar que o cabe√ßalho PGM geralmente √© dividido em tr√™s linhas de texto separadas, mas o padr√£o PGM exige apenas que os elementos sejam separados por algum caractere de espa√ßo em branco.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar o utilit√°rio </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para extrair os primeiros 200 bytes de cada arquivo:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ para f em n√≠veis / *; </font><font style="vertical-align: inherit;">fa√ßa -c200 $ f; </font><font style="vertical-align: inherit;">done&gt; out.pgm</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, podemos concaten√°-los com um cabe√ßalho e criar uma imagem exibida: </font></font><br><br> <code>xview</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- este √© um programa X antigo para exibir imagens em uma janela. </font><font style="vertical-align: inherit;">Voc√™ pode substitu√≠-lo pelo seu visualizador de imagens favorito, por exemplo, um utilit√°rio </font></font><code>display</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do ImageMagick, mas lembre-se de que existem surpreendentemente muitos visualizadores de imagens que n√£o aceitam um arquivo de imagem redirecionado para a entrada padr√£o.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cat hdr.pgm out.pgm | </font><font style="vertical-align: inherit;">xview / dev / stdin</font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/160/236/6cf/1602366cf98b4fd6fd448d5f3cf0b3a8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se for dif√≠cil considerar os detalhes em uma imagem escura, voc√™ poder√° escolher um esquema de cores diferente. </font><font style="vertical-align: inherit;">Use o utilit√°rio </font></font><code>pgmtoppm</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageMagick para converter pixels em um intervalo diferente de cores. </font><font style="vertical-align: inherit;">Esta vers√£o criar√° uma imagem "negativa":</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cat hdr.pgm out.pgm | </font><font style="vertical-align: inherit;">pgmtoppm branco-preto | </font><font style="vertical-align: inherit;">xview / dev / stdin</font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/923/1ed/90a/9231ed90a4b0e0b0f94dfb67dc5f4e6d.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E esta vers√£o torna os valores baixos em amarelo e os valores altos em azul: </font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cat hdr.pgm out.pgm | </font><font style="vertical-align: inherit;">pgmtoppm amarelo-azul | </font><font style="vertical-align: inherit;">xview / dev / stdin</font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44f/61b/53e/44f61b53ecc026af2ad851f24d494c06.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A visibilidade das cores √© uma quest√£o muito subjetiva, para que voc√™ possa experimentar e escolher qual √© o melhor para voc√™. </font><font style="vertical-align: inherit;">Seja como for, a imagem 200 √ó 148 √© bastante pequena, portanto, √© melhor aumentar a visibilidade aumentando seu tamanho:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cat hdr.pgm out.pgm | </font><font style="vertical-align: inherit;">xview -zoom 300 / dev / stdin</font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/97a/ed3/b4d97aed3c0baf3086d16c62b146742f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A imagem est√° escura e isso significa que a maioria dos bytes cont√©m valores pequenos. Uma faixa percept√≠vel de pixels principalmente brilhantes pr√≥ximos √† borda esquerda contrasta com ela. Essa faixa est√° localizada no terceiro byte do arquivo, que, como dissemos acima, varia em toda a faixa de valores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E embora n√£o existam muitos valores altos fora do terceiro byte, quando eles aparecem, eles geralmente consistem em s√©ries, criando pequenas faixas brilhantes na imagem. Algumas dessas s√©ries s√£o interrompidas periodicamente, criando um efeito de linha tracejada. (Talvez, com a sele√ß√£o de cores correta, seja poss√≠vel notar essas seq√º√™ncias em cores mais escuras.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com um estudo cuidadoso da imagem, pode-se entender que principalmente na parte esquerda predominam pequenas faixas verticais. Essas bandas nos falam sobre repetibilidade na maioria dos arquivos. Mas nem todos os arquivos - de tempos em tempos, existem linhas de pixels nas quais as bandas s√£o interrompidas - mas isso √© mais do que suficiente para determinar a presen√ßa de um padr√£o real. Esse padr√£o desaparece no lado direito da imagem, o fundo escuro das faixas d√° lugar a algo mais barulhento e indefinido. (Parece que as listras tamb√©m est√£o faltando na parte esquerda da imagem, mas, repito, √© poss√≠vel que ao usar um esquema de cores diferente, voc√™ possa ver que elas come√ßam mais perto da borda esquerda do que parece aqui.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As faixas consistem em linhas finas de pixels levemente mais brilhantes contra um fundo de pixels levemente mais escuros. Portanto, esse padr√£o gr√°fico deve se correlacionar com o padr√£o de arquivos de dados nos quais valores ligeiramente maiores s√£o igualmente dispersos entre valores de bytes ligeiramente menores. Parece que as listras est√£o vazias no meio da imagem. Como mostra os primeiros 200 bytes de arquivos, voc√™ deve esperar que o padr√£o de bytes termine ap√≥s cerca de 100 bytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O fato de esses padr√µes mudarem em diferentes arquivos de dados deve nos levar √† pergunta: como ser√£o os arquivos ap√≥s os primeiros 200 bytes. Bem, podemos facilmente substituir o utilit√°rio por um </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilit√°rio </font></font><code>tail</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e ver como s√£o os √∫ltimos 200 bytes:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ para f em n√≠veis / *; </font><font style="vertical-align: inherit;">fa√ßa tail -c200 $ f; </font><font style="vertical-align: inherit;">done&gt; out.pgm; </font><font style="vertical-align: inherit;">gato hdr.pgm out.pgm | </font><font style="vertical-align: inherit;">xview -zoom 300 / dev / stdin</font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b7/e21/262/5b7e2126215bf4e9953890622b4e2767.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vimos imediatamente que essa √°rea de arquivos de dados √© muito diferente. </font><font style="vertical-align: inherit;">Aqui, os bytes s√£o muito mais comuns, especialmente no final do arquivo. </font><font style="vertical-align: inherit;">(No entanto, como antes, eles preferem agrupar, cobrindo a imagem com faixas horizontais brilhantes.) Parece que a frequ√™ncia de valores altos de bytes aumenta quase at√© o fim, onde √© interrompida abruptamente e √© substitu√≠da por valores baixos nos √∫ltimos dez a doze bytes. </font><font style="vertical-align: inherit;">E o padr√£o aqui tamb√©m n√£o √© universal, mas √© padr√£o demais para ser uma coincid√™ncia.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Talvez no meio dos arquivos possam haver outras √°reas que ainda n√£o consideramos. </font><font style="vertical-align: inherit;">A pr√≥xima coisa que queremos fazer √© examinar todos os arquivos dessa maneira. </font><font style="vertical-align: inherit;">Mas como todos os arquivos t√™m tamanhos diferentes, eles n√£o podem ser colocados em uma bela matriz retangular de pixels. </font><font style="vertical-align: inherit;">Podemos preencher o final de cada linha com pixels pretos, mas seria melhor redimension√°-los para que todas as linhas tenham a mesma largura e as √°reas proporcionais de arquivos diferentes correspondam mais ou menos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E podemos realmente fazer isso com um pouco mais de esfor√ßo. </font><font style="vertical-align: inherit;">Voc√™ pode usar o Python e sua biblioteca para trabalhar com imagens </font></font><code>PIL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(‚ÄúPillow‚Äù): </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquivo showbytes.py:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-comment"><span class="hljs-comment"># Retrieve the full list of data files. filenames = sys.argv[1:] # Create a grayscale image, its height equal to the number of data files. width = 750 height = len(filenames) image = Image.new('L', (width, height)) # Fill in the image, one row at a time. for y in range(height): # Retrieve the contents of one data file. data = open(filenames[y]).read() linewidth = len(data) # Turn the data into a pixel-high image, each byte becoming one pixel. line = Image.new(image.mode, (linewidth, 1)) linepixels = line.load() for x in range(linewidth): linepixels[x,0] = ord(data[x]) # Stretch the line out to fit the final image, and paste it into place. line = line.resize((width, 1)) image.paste(line, (0, y)) # Magnify the final image and display it. image = image.resize((width, 3 * height)) image.show()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando chamamos esse script, usando a lista completa de arquivos de dados como argumentos, ele cria uma imagem completa e a exibe em uma janela separada: </font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≠veis $ python showbytes.py / * </font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/844/f82/c04/844f82c04bc2b27a36a62ffe2511f8fc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infelizmente, embora esta imagem esteja completa, ela n√£o nos mostra nada de novo. </font><font style="vertical-align: inherit;">(Mas, na verdade, mostra menos ainda, porque o redimensionamento destruiu o padr√£o das faixas.) Provavelmente, para estudar todo o conjunto de dados, precisamos de um melhor processo de visualiza√ß√£o.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caracterizar os dados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com isso em mente, vamos parar por um momento e concluir um censo completo de dados. </font><font style="vertical-align: inherit;">Precisamos saber se os arquivos de dados d√£o prefer√™ncia a determinados valores de bytes. </font><font style="vertical-align: inherit;">Por exemplo, se cada valor geralmente for igualmente duplicado, ser√° uma forte evid√™ncia de que os arquivos est√£o realmente compactados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reescrever </font><font style="vertical-align: inherit;">completamente os valores, basta algumas linhas no Python: </font><font style="vertical-align: inherit;">O arquivo census.py:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys data = sys.stdin.read() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">256</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> c, data.count(chr(c))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tendo colocado todos os dados em uma vari√°vel, podemos calcular a frequ√™ncia de ocorr√™ncia de cada valor de byte. </font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cat levels / * | </font><font style="vertical-align: inherit;">python ./census.py | </font><font style="vertical-align: inherit;">menos</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0 2458</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 2525</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2 1626</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3 1768</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4 1042</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5 1491</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 1081</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
7 1445</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8 958</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
9 1541</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 1279</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
11 1224</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
12.845</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
13 908</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
14 859</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
15 1022</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 679</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
17 1087</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
18.881</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
19 1116</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
20 1007</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
21 1189</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
22 1029</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
23.733</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
linhas 1-24 / 256 (mais) </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vemos que, na maioria das vezes, existem valores de bytes 0 e 1, os seguintes em frequ√™ncia s√£o 2 e 3, ap√≥s o qual o n√∫mero continua a diminuir (embora com menos const√¢ncia). </font><font style="vertical-align: inherit;">Para visualizar melhor esses dados, podemos transferir a sa√≠da </font></font><code>gnuplot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e transformar esse censo em um histograma: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A op√ß√£o de </font></font><code>-p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilit√°rio </font></font><code>gnuplot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordena que n√£o feche a janela com o gr√°fico ap√≥s a conclus√£o do trabalho </font></font><code>gnuplot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cat levels / * | </font><font style="vertical-align: inherit;">python ./census.py | </font><font style="vertical-align: inherit;">gnuplot -p -e 'plot "-" com caixas'</font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/040/76b/783/04076b783d61f8b6f976333a67a95a25.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â muito percept√≠vel que os primeiros valores de bytes s√£o muito mais comuns que todos os outros. </font><font style="vertical-align: inherit;">V√°rios dos seguintes valores tamb√©m s√£o bastante comuns e, em seguida, as frequ√™ncias de valores de cerca de 50 come√ßam a diminuir ao longo de uma curva de probabilidade suave. </font><font style="vertical-align: inherit;">No entanto, h√° um subconjunto de valores altos que s√£o uniformemente separados um do outro, cuja frequ√™ncia parece bastante est√°vel. </font><font style="vertical-align: inherit;">Observando a sa√≠da original, podemos garantir que esse subconjunto consista em valores que podem ser divis√≠veis por oito.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essas diferen√ßas no n√∫mero de valores sugerem que existem v√°rias "classes" diferentes de valores de bytes, portanto, ser√° l√≥gico ver como essas classes s√£o distribu√≠das. O primeiro grupo de valores de bytes ser√° o valor mais baixo: 0, 1, 2 e 3. Em seguida, o segundo grupo pode ter valores de 4 a 64. E o terceiro grupo ter√° valores acima de 64, que s√£o divis√≠veis por 8. Qualquer outra coisa, incluindo n√£o divis√≠vel por 8 valores maiores que 64 ser√° o quarto e √∫ltimo grupo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com tudo isso em mente, podemos alterar o √∫ltimo script de gera√ß√£o de imagem escrito. </font><font style="vertical-align: inherit;">Em vez de exibir os valores reais de cada byte em uma cor separada, vamos apenas mostrar a qual grupo cada byte pertence. </font><font style="vertical-align: inherit;">Voc√™ pode atribuir uma cor exclusiva a cada um dos quatro grupos, e isso nos ajudar√° a ver se determinados valores realmente aparecem em determinados lugares. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquivo Showbytes2.py:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-comment"><span class="hljs-comment"># Retrieve the full list of data files. filenames = sys.argv[1:] # Create a color image, its height equal to the number of data files. width = 750 height = len(filenames) image = Image.new('RGB', (width, height)) # Fill in the image, one row at a time. for y in range(height): # Retrieve the contents of one data file. data = open(filenames[y]).read() linewidth = len(data) # Turn the data into a pixel-high image, each byte becoming one pixel. line = Image.new(image.mode, (linewidth, 1)) linepixels = line.load() # Determine which group each byte belongs to and assign it a color. for x in range(linewidth): byte = ord(data[x]) if byte &lt; 0x04: linepixels[x,0] = (255, 0, 0) elif byte &lt; 0x40: linepixels[x,0] = (0, 255, 0) elif byte % 8 == 0: linepixels[x,0] = (0, 0, 255) else: linepixels[x,0] = (255, 255, 255) # Paste the line of pixels into the final image, stretching to fit. line = line.resize((width, 1)) image.paste(line, (0, y)) # Magnify the final image and display it. image = image.resize((width, 3 * height)) image.show()</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribu√≠mos quatro grupos vermelho, verde, azul e branco. </font><font style="vertical-align: inherit;">(Novamente, voc√™ pode tentar escolher outras cores para atender √†s suas prefer√™ncias.)</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√≠veis $ python showbytes2.py / * </font></font></pre></blockquote><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/322/77f/f31/32277ff31e600de756627d442671ba9e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gra√ßas a esta imagem, podemos pr√©-confirmar a corre√ß√£o da separa√ß√£o dos arquivos de dados em cinco partes: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O cabe√ßalho de quatro bytes que encontramos anteriormente. </font></font></li><li>  ,     ,       (..   ). </li><li>  ,           (.   64). </li><li>    ,      . </li><li>   ,      . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gra√ßas a essas cores, fica claro que na quarta parte, onde prevalecem valores altos de bytes, como pode ser visto na imagem em tons de cinza, valores altos de bytes, dividindo por 8, principalmente, prevalecem 8. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na imagem anterior, sabemos que a segunda parte, ou seja, a parte com listras estende-se por uma √°rea quase completamente vermelha. De fato, em uma das primeiras imagens, vimos que a parte com listras, indo da esquerda para a direita, brilha lentamente em m√©dia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vimos novamente que os pixels verdes da terceira parte principal formam padr√µes pontilhados de pixels verdes e vermelhos intermitentes (azuis ou brancos) de tempos em tempos. No entanto, esse padr√£o n√£o √© particularmente regular e pode ser imagin√°rio.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, essa divis√£o do arquivo em cinco partes √© muito arbitr√°ria. </font><font style="vertical-align: inherit;">Uma quarta parte com altos valores de bytes divis√≠veis por oito pode acabar sendo apenas o final da terceira parte. </font><font style="vertical-align: inherit;">Ou pode ser melhor dividir uma terceira parte grande em v√°rias partes que ainda n√£o determinamos. </font><font style="vertical-align: inherit;">Nesta fase, a descoberta de pe√ßas nos ajuda a encontrar mais lugares para pesquisas adicionais. </font><font style="vertical-align: inherit;">Por enquanto, basta que saibamos que existem partes nas quais a composi√ß√£o geral dos valores de bytes √© alterada, e uma ideia aproximada do seu tamanho nos ajudar√° a continuar nossa pesquisa.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pesquisa de estrutura </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que devemos procurar a seguir? Bem, como antes, a maneira mais f√°cil de come√ßar √© do topo do arquivo. Ou melhor, perto do topo. Como j√° identificamos com bastante confian√ßa a primeira parte como um cabe√ßalho de quatro bytes, vamos dar uma olhada no que vem a seguir - a √°rea que chamamos de segunda parte ou parte das bandas. Essas bandas s√£o a dica mais forte da exist√™ncia da estrutura; portanto, √© melhor procurar novas evid√™ncias da presen√ßa do padr√£o aqui. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Por enquanto, assumimos que o padr√£o de faixa come√ßa imediatamente ap√≥s os primeiros quatro bytes. Visualmente, isso n√£o √© √≥bvio, mas parece prov√°vel, e o exame dos valores de bytes deve nos mostrar rapidamente a verdade.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos voltar ao hex dump, desta vez focando na segunda parte. </font><font style="vertical-align: inherit;">Lembre-se de que esperamos encontrar um padr√£o repetitivo de valores um pouco mais altos distribu√≠dos igualmente entre valores um pouco mais baixos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A op√ß√£o </font></font><code>-s4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordena </font></font><code>xxd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pular os primeiros 4 bytes do arquivo.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ para f em n√≠veis / *; </font><font style="vertical-align: inherit;">fa√ßa xxd -s4 $ f | </font><font style="vertical-align: inherit;">sed -n 1p; </font><font style="vertical-align: inherit;">feito | </font><font style="vertical-align: inherit;">menos</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0200 0003 0202 0401 0105 0303 0700 0108 ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0201 0104 0000 0504 0407 0202 0902 010a ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0300 0004 0303 0504 0407 0505 0801 0109 ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0300 0009 0202 1203 0313 0909 1401 0115 ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0203 0305 0000 0602 0207 0505 0901 010a ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0203 0304 0000 0502 0206 0404 0901 010a ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 0300 0005 022a 0602 2907 0303 0902 000a ..... * ..) .......</font></font><font></font>
00000004: 0203 0305 0000 0605 0507 0101 0802 0209 ................<font></font>
00000004: 0300 0007 0303 0901 010a 0707 0b09 090c ................<font></font>
00000004: 0300 0004 0101 0903 030e 0404 1609 0920 ...............<font></font>
00000004: 0200 0003 1313 0402 0205 0013 0701 0109 ................<font></font>
00000004: 0500 0006 0505 0701 0109 0606 0e07 070f ................<font></font>
00000004: 0100 0003 0101 0a03 030b 0a0a 0e32 3216 .............22.<font></font>
00000004: 0300 0004 0705 0903 030a 0606 0b08 080c ................<font></font>
00000004: 0200 0003 0701 0402 0209 0501 0a08 080b ................<font></font>
00000004: 0200 0003 0202 0901 010a 0303 0b05 010d ................<font></font>
00000004: 0200 0003 0202 0403 0305 0101 0904 040a ................<font></font>
00000004: 0300 0007 0303 0f01 0115 0707 2114 1422 ............!.."<font></font>
00000004: 0200 0003 0202 0403 0309 0101 0a04 040b ................<font></font>
00000004: 0231 3103 0202 0500 0006 0303 0701 0109 .11.............<font></font>
00000004: 0200 0003 0202 0b32 320c 0303 0e08 0811 .......22.......<font></font>
00000004: 0201 0103 0000 0902 020a 0303 0b09 090c ................<font></font>
00000004: 0200 0003 0202 0a01 010b 0303 0d0b 0b0f ................<font></font>
00000004: 0300 0005 0303 0701 0109 0001 0b05 051b ................<font></font>
lines 27-50/148 (more) </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observando atentamente a sequ√™ncia de bytes na string, podemos ver um padr√£o no qual o primeiro, quarto, s√©timo e d√©cimo bytes s√£o maiores que os vizinhos mais pr√≥ximos. Esse padr√£o √© imperfeito, possui exce√ß√µes, mas √© definitivamente est√°vel o suficiente para criar a repetibilidade visual das bandas vistas em todas as imagens. (E √© suficiente para confirmar nossa suposi√ß√£o de que o padr√£o de faixas come√ßa imediatamente ap√≥s o cabe√ßalho de quatro bytes.) A </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const√¢ncia desse padr√£o implica claramente que essa parte do arquivo √© uma matriz ou tabela e cada registro na matriz possui um comprimento de tr√™s bytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voc√™ pode configurar o formato de hex dump para facilitar a visualiza√ß√£o da sa√≠da como uma s√©rie de trig√™meos: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A op√ß√£o </font></font><code>-g3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define o agrupamento por tr√™s bytes em vez de dois. Op√ß√£o</font></font><code>-c18</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> define 18 bytes (um m√∫ltiplo de 3) por linha em vez de 16. </font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ para f em n√≠veis / *; </font><font style="vertical-align: inherit;">fa√ßa xxd -s4 -g3 -c18 $ f | </font><font style="vertical-align: inherit;">sed -n 1p; </font><font style="vertical-align: inherit;">feito | </font><font style="vertical-align: inherit;">menos</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 050000 060505 070101 090606 0e0707 0f0001 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 010000 030101 0a0303 0b0a0a 0e3232 161414 ........... 22 ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 030000 040705 090303 0a0606 0b0808 0c0101 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 020000 030701 040202 090501 0a0808 0b0101 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 020000 030202 090101 0a0303 0b0501 0d0302 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 020000 030202 040303 050101 090404 0a0302 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 030000 070303 0f0101 150707 211414 221313 ............! .. "..</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 020000 030202 040303 090101 0a0404 0b0001 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 023131 030202 050000 060303 070101 090505 .11 ...............</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 020000 030202 0b3232 0c0303 0e0808 110b0b ....... 22 .........</font></font><font></font>
00000004: 020101 030000 090202 0a0303 0b0909 0c0a0a ..................<font></font>
00000004: 020000 030202 0a0101 0b0303 0d0b0b 0f2323 ................##<font></font>
00000004: 030000 050303 070101 090001 0b0505 1b0707 ..................<font></font>
00000004: 022323 030000 040202 050303 030101 070505 .##...............<font></font>
00000004: 031414 050000 060303 070505 080101 090707 ..................<font></font>
00000004: 030000 050202 060303 070505 080101 090606 ..................<font></font>
00000004: 030202 040000 050303 070404 080005 090101 ..................<font></font>
00000004: 030202 040000 050303 090404 1d0101 1f0909 ..................<font></font>
00000004: 020000 050303 060101 070202 0f0300 110505 ..................<font></font>
00000004: 050000 070101 0c0505 0d0007 110c0c 120707 ..................<font></font>
00000004: 030202 050000 060303 070505 080101 090606 ..................<font></font>
00000004: 020000 030101 050202 060505 070100 080303 ..................<font></font>
00000004: 020000 030202 050303 090101 0a0505 0b0302 ..................<font></font>
00000004: 022c2c 030000 040202 020303 050101 060202 .,,...............<font></font>
lines 38-61/148 (more) </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em um dump formatado dessa maneira, alguns outros recursos desse padr√£o come√ßam a aparecer. Como antes, o primeiro byte de cada trig√™meo √© geralmente maior que os bytes ao seu redor. Voc√™ tamb√©m pode notar que o segundo e o terceiro bytes de cada trig√™meo s√£o frequentemente duplicados. Descendo a primeira coluna, veremos que a maioria dos valores do segundo e terceiro bytes s√£o iguais </font></font><code>0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mas valores diferentes de zero tamb√©m s√£o frequentemente encontrados em pares, por exemplo, </font></font><code>0101</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>2323</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Esse padr√£o tamb√©m √© imperfeito, mas tem muito em comum para ser uma coincid√™ncia. Observando a coluna ASCII √† direita, veremos que, quando temos valores de bytes que correspondem ao caractere ASCII imprim√≠vel, eles geralmente s√£o encontrados em pares.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro padr√£o que vale a pena mencionar que n√£o √© percebido imediatamente: o primeiro byte de cada triplo aumenta da esquerda para a direita. Embora esse padr√£o seja menos percept√≠vel, sua estabilidade √© alta; precisamos examinar muitas linhas antes de encontrar a primeira incompatibilidade. E os bytes geralmente aumentam em valores pequenos, mas eles n√£o representam nenhum padr√£o regular. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao estudar a imagem original, percebemos que a parte com as listras termina em cada arquivo e n√£o no mesmo local. H√° uma transi√ß√£o da cria√ß√£o de uma faixa de padr√£o √† esquerda para ru√≠do aleat√≥rio √† direita, mas essa transi√ß√£o ocorre para cada linha de pixels em pontos diferentes. Isso implica que deve haver algum marcador para que o programa que est√° lendo o arquivo de dados possa entender onde a matriz termina e outro conjunto de dados come√ßa.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vamos voltar ao despejo apenas no primeiro n√≠vel para examinar o arquivo inteiro: </font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ xxd -s4 -g3 -c18 n√≠veis / li√ß√£o_1.pak</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000004: 020000 040202 050404 070505 080707 090001 ..................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000016: 0a0101 0b0808 0d0a0a 110023 150907 180200 ........... # ......</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000028: 22090d 260911 270b0b 280705 291e01 272705 ".. &amp; .. '.. (..) ..' '.</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0000003a: 020d01 220704 090209 0a0215 042609 250111 ... "......... &amp;.% ..</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0000004c: 150222 1d0124 011d0d 010709 002000 1b0400 .. ".. $ ....... ....</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
0000005e: 1a0020 152609 1f0033 002911 152223 02110d ... &amp; ... 3.) .. "# ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000070: 010726 091f18 291115 09181a 022302 1b0215 .. &amp; ...) ...... # ....</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000082: 22011c 011c0d 0a0704 090201 020128 260123 "............. (&amp;. #</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000094: 150509 020121 150522 0a2727 0b0504 00060b .....! .. ".''......</font></font><font></font>
000000a6: 082804 18780b 082804 18700b 082804 186400 .(..x..(..p..(..d.<font></font>
000000b8: 17101e 1e1a19 010300 0e1a17 17100e 1f010e ..................<font></font>
000000ca: 13141b 291f1a 001210 1f011b 0c1e1f 011f13 ...)..............<font></font>
000000dc: 10010e 13141b 001e1a 0e1610 1f2d00 201e10 .............-. ..<font></font>
000000ee: 011610 24291f 1a011a 1b1019 000f1a 1a1d1e ...$).............<font></font>
00000100: 2d02 </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estudando a sequ√™ncia de trig√™meos, podemos supor provisoriamente que a parte com faixas nesses dados termina ap√≥s 17 trig√™meos, por deslocamento </font></font><code>00000036</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Isso n√£o √© exato, mas o primeiro byte de cada trig√™meo aumenta constantemente seu valor e depois diminui no d√©cimo oitavo trig√™meo. Mais uma prova: no d√©cimo oitavo trig√™meo, o segundo byte tem o mesmo significado que o primeiro. Ainda n√£o percebemos isso, mas, se voltarmos e olharmos, veremos que o primeiro byte nunca √© igual ao segundo ou terceiro byte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se nossa teoria dos marcadores estiver correta, existem duas possibilidades. Em primeiro lugar, √© poss√≠vel que, ap√≥s a parte da tira, exista algum valor de byte especial (logo ap√≥s o d√©cimo s√©timo trig√™meo). Em segundo lugar, provavelmente existe um valor armazenado em algum lugar igual ao tamanho da pe√ßa com listras. Esse tamanho pode ser igual a 17 (ou seja, indica o n√∫mero de trig√™meos) ou 51 (indica o n√∫mero total de bytes em uma parte) ou 55 (51 mais 4, ou seja, o deslocamento do arquivo no qual essa parte termina). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para a primeira op√ß√£o, um valor de byte duplo pode ser um marcador para o final da parte (dado que essa sequ√™ncia nunca ocorre na segunda parte). No entanto, o estudo cuidadoso de v√°rios outros arquivos de dados contradiz essa id√©ia, porque esse padr√£o n√£o aparece em nenhum outro lugar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para a segunda op√ß√£o, obviamente procurar√° o indicador de tamanho na primeira parte. </font><font style="vertical-align: inherit;">Eis que o primeiro valor de 16 bits no cabe√ßalho do arquivo de quatro bytes √© 17:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ od -An -tuS -N4 levels / li√ß√£o_1.pak</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    17 203 </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se nossa teoria estiver correta, esse valor n√£o determina o tamanho da pe√ßa com faixas, mas o n√∫mero de registros de tr√™s bytes. </font><font style="vertical-align: inherit;">Para testar essa id√©ia, voltemos √† computa√ß√£o, onde comparamos a soma de dois valores inteiros de 16 bits com o tamanho do arquivo. </font><font style="vertical-align: inherit;">Desta vez, multiplicamos o primeiro n√∫mero por tr√™s para obter o tamanho real em bytes:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ para f em n√≠veis / *; </font><font style="vertical-align: inherit;">fa√ßa tamanho = $ (wc -c &lt;$ f); </font><font style="vertical-align: inherit;">leia v1 v2 &lt;&lt; (od -tuS -An -N4 $ f); </font><font style="vertical-align: inherit;">diff = $ ((tamanho $ - 3 * $ v1 - $ v2));</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    echo "$ size = 3 * $ v1 + $ v2 + $ diff"; </font><font style="vertical-align: inherit;">feito | </font><font style="vertical-align: inherit;">menos</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
585 = 3 * 35 + 476 + 4</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
586 = 3 * 45 + 447 + 4</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
550 = 3 * 43 + 417 + 4</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
302 = 3 * 29 + 211 + 4</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
517 = 3 * 45 + 378 + 4</font></font><font></font>
671 = 3 * 49 + 520 + 4<font></font>
265 = 3 * 26 + 183 + 4<font></font>
344 = 3 * 26 + 262 + 4<font></font>
478 = 3 * 32 + 378 + 4<font></font>
342 = 3 * 58 + 164 + 4<font></font>
336 = 3 * 38 + 218 + 4<font></font>
352 = 3 * 36 + 240 + 4<font></font>
625 = 3 * 42 + 495 + 4<font></font>
532 = 3 * 44 + 396 + 4<font></font>
386 = 3 * 42 + 256 + 4<font></font>
450 = 3 * 27 + 365 + 4<font></font>
373 = 3 * 30 + 279 + 4<font></font>
648 = 3 * 50 + 494 + 4<font></font>
477 = 3 * 42 + 347 + 4<font></font>
530 = 3 * 44 + 394 + 4<font></font>
247 = 3 * 29 + 156 + 4<font></font>
325 = 3 * 32 + 225 + 4<font></font>
394 = 3 * 32 + 294 + 4<font></font>
343 = 3 * 31 + 246 + 4<font></font>
lines 1-24/148 (more) </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sim! Ap√≥s essa altera√ß√£o, o valor total do cabe√ßalho √© sempre exatamente quatro a menos que o tamanho do arquivo de dados inteiro. E como quatro tamb√©m √© o n√∫mero de bytes no cabe√ßalho, √© √≥bvio que isso n√£o √© uma coincid√™ncia. O primeiro n√∫mero nos fornece o n√∫mero de entradas de tr√™s bytes na tabela e o segundo n√∫mero nos fornece o n√∫mero de bytes que comp√µem o restante do arquivo de dados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encontramos uma f√≥rmula constante, o que significa que agora entendemos completamente o que significam os n√∫meros na primeira parte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(A prop√≥sito, aqui est√° o padr√£o muito secreto que os leitores atentos podem perceber. Um estudo cuidadoso das equa√ß√µes deixa claro que, quando os arquivos t√™m o mesmo primeiro n√∫mero, eles obt√™m a mesma diferen√ßa residual. Isso acontece porque a diferen√ßa √© sempre duas vezes o valor Este √© um padr√£o n√£o √≥bvio, mas um observador meticuloso ou bem-sucedido pode not√°-lo.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, podemos dizer que o arquivo tem tr√™s partes principais:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cabe√ßalho de quatro bytes; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tabela de registros de tr√™s bytes; </font></font> e </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o restante do arquivo, que supostamente cont√©m a maioria dos dados. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Consequentemente, as outras partes que determinamos anteriormente anteriormente devem ser subse√ß√µes da terceira parte.) </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpretando Metadados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado esse esquema, seria l√≥gico supor que as entradas na tabela da segunda parte sejam alguns metadados necess√°rios para interpretar os dados da terceira parte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas que tipo de metadados esta tabela cont√©m?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observamos acima que existem alguns sinais de que o arquivo de dados pode ser compactado. (Agora isso parece ainda mais plaus√≠vel, porque sabemos que a terceira parte de cada arquivo, supostamente contendo dados de cada n√≠vel, tem apenas 100-600 bytes de tamanho.) Nesse caso, √© bem poss√≠vel que a tabela que precede os dados principais contenha metadados de compacta√ß√£o - um dicion√°rio usado durante a descompacta√ß√£o. Por exemplo, antes dos dados codificados pelo algoritmo de Huffman, geralmente h√° um dicion√°rio que mapeia os valores de bytes originais para sequ√™ncias de bits. Embora n√£o esperemos que esses arquivos sejam codificados pelo algoritmo Huffman (como os dados mostram padr√µes claros no n√≠vel de bytes, ou seja, dificilmente s√£o um fluxo de bits), seria prudente tentar interpretar essa tabela como um dicion√°rio de descompress√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(√â claro que nem todo tipo de compacta√ß√£o usa um dicion√°rio armazenado. Por exemplo, o algoritmo de defla√ß√£o usado no </font></font><code>gzip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>zlib</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permite recriar o dicion√°rio diretamente do fluxo de dados. Mas esses casos s√£o a exce√ß√£o e n√£o a regra.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalmente, a entrada do dicion√°rio consiste em duas partes: a chave e valores. Obviamente, algumas vezes uma chave est√° impl√≠cita, por exemplo, quando √© ordenada n√£o em uma tabela de pesquisa, mas em uma matriz. No entanto, j√° observamos que os registros de tr√™s bytes parecem consistir em duas partes - em particular, o primeiro byte de cada registro segue um padr√£o claramente diferente do padr√£o do segundo e terceiro bytes. Com isso em mente, uma primeira hip√≥tese razo√°vel seria considerar o primeiro byte como a chave e os dois bytes restantes como o valor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se esse for o caso, uma das maneiras mais simples de interpretar a parte da faixa √© que o primeiro byte √© o valor do byte que precisa ser substitu√≠do nos dados compactados e o segundo e o terceiro bytes s√£o o valor que precisa ser substitu√≠do. </font><font style="vertical-align: inherit;">O resultado criado por esse esquema ser√° definitivamente maior, embora n√£o esteja claro quanto. </font><font style="vertical-align: inherit;">Seja como for, essa √© uma hip√≥tese l√≥gica e √© bastante f√°cil de verificar. </font><font style="vertical-align: inherit;">Podemos escrever um pequeno programa em Python que implementa esse esquema de descompress√£o: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">File decompress.py:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-comment"><span class="hljs-comment"># Read the compressed data file. data = sys.stdin.read() # Extract the two integers of the four-byte header. tablesize, datasize = struct.unpack('HH', data[0:4]) data = data[4:] # Separate the dictionary table and the compressed data. tablesize *= 3 table = data[0:tablesize] data = data[tablesize:datasize] # Apply the dictionary entries to the data section. for n in range(0, len(table), 3): key = table[n] val = table[n+1:n+3] data = data.replace(key, val) # Output the expanded result. sys.stdout.write(data)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora podemos verificar esse script usando um exemplo de arquivo de dados: </font></font><br><br><blockquote> <code>$ python ./decompress.py &lt;levels/lesson_1.pak | xxd <br> 00000000: 0b0b 0b0b 0404 0000 0a0a 0109 0d05 0502 ................ <br> 00000010: 0200 0100 0000 0101 0100 0009 0702 0209 ................ <br> 00000020: 1100 0125 0100 2309 0700 0009 0d1d 0124 ...%..#........$ <br> 00000030: 011d 0a0a 0105 0500 0100 2000 1b02 0200 .......... ..... <br> 00000040: 1a00 2009 0709 1100 011f 0033 001e 0100 .. ........3.... <br> 00000050: 2309 0709 0d23 0000 0023 0a0a 0105 0509 #....#...#...... <br> 00000060: 1100 011f 0200 1e01 0023 0907 0001 0200 .........#...... <br> 00000070: 1a00 0023 0000 1b00 0009 0709 0d01 1c01 ...#............ <br> 00000080: 1c0a 0a01 0105 0502 0200 0100 0001 0000 ................ <br> 00000090: 0107 0509 1101 2309 0704 0400 0100 0001 ......#......... <br> 000000a0: 2109 0704 0409 0d01 010b 0b0b 0b08 0804 !............... <br> 000000b0: 0402 0200 0608 0807 0707 0502 0202 0078 ...............x <br> 000000c0: 0808 0707 0705 0202 0200 7008 0807 0707 ..........p..... <br> 000000d0: 0502 0202 0064 0017 101e 1e1a 1901 0300 .....d.......... <br> 000000e0: 0e1a 1717 100e 1f01 0e13 141b 1e01 1f1a ................ <br> 000000f0: 0012 101f 011b 0c1e 1f01 1f13 1001 0e13 ................ <br> 00000100: 141b 001e 1a0e 1610 1f2d 0020 1e10 0116 .........-. .... <br> 00000110: 1024 1e01 1f1a 011a 1b10 1900 0f1a 1a1d .$.............. <br> 00000120: 1e2d 0000</code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, os resultados n√£o s√£o dignos de nota. Obviamente, o fluxo de dados resultante tornou-se mais implantado que o original, mas n√£o muito. Definitivamente, n√£o √© suficiente para conter todos os dados que esperamos encontrar. Obviamente, esse esquema de descompacta√ß√£o √© um pouco mais simples que o necess√°rio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se examinarmos cuidadosamente a sa√≠da resultante, veremos em breve que ela come√ßa com muitos bytes repetidos. </font></font><code>0b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>0a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- todos eles ocorrem em pares. Observando o original compactado, veremos que todos esses pares surgiram devido a uma substitui√ß√£o do dicion√°rio. Mas, no processo, notamos imediatamente que todos esses significados duplicados tamb√©m correspondem √†s entradas no dicion√°rio. Ou seja, se aplicarmos novamente o dicion√°rio, os dados ser√£o expandidos novamente. Talvez n√£o estejamos descompactando o suficiente?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nosso primeiro palpite pode ser realizar uma segunda passagem, aplicando cada entrada do dicion√°rio uma segunda vez para expandir ainda mais os dados. O segundo palpite pode ser executar v√°rias passagens com o dicion√°rio, repetindo o processo at√© que todos os bytes semelhantes √†s chaves do dicion√°rio sejam substitu√≠dos. No entanto, se dermos uma olhada na estrutura do dicion√°rio, percebemos que simplesmente aplicamos as entradas </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dicion√°rio </font><em><font style="vertical-align: inherit;">da direita para a esquerda</font></em><font style="vertical-align: inherit;"> , e n√£o da esquerda para a direita, quando todos os nossos valores s√£o expandidos em uma √∫nica passagem.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tomando essa hip√≥tese, podemos ver a estrutura de um algoritmo de compress√£o mais plaus√≠vel. O programa pega os dados de origem e os verifica, procurando as seq√º√™ncias mais comuns de dois bytes. Em seguida, substitui a sequ√™ncia de dois bytes por um valor de byte que n√£o √© encontrado nos dados. Em seguida, repete o processo, continuando-o at√© que os dados contenham mais de duas repeti√ß√µes de seq√º√™ncias de byte duplo. De fato, esse algoritmo de compacta√ß√£o tem um nome: √© conhecido como compacta√ß√£o "re-emparelhar", que √© a abrevia√ß√£o de "pares recursivos".</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (E isso pode explicar alguns padr√µes que vemos no dicion√°rio. Durante a compacta√ß√£o, o dicion√°rio √© constru√≠do da esquerda para a direita, portanto, ao descompactar, ele deve ser aplicado da direita para a esquerda. Como as entradas do dicion√°rio geralmente se referem √†s entradas anteriores, √© l√≥gico que o segundo e o terceiro bytes geralmente sejam menor que o primeiro.) </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora a remontagem da compacta√ß√£o n√£o produza resultados muito impressionantes, ela tem uma vantagem: o descompactador pode ser implementado com um m√≠nimo de c√≥digo. </font><font style="vertical-align: inherit;">Eu pr√≥prio usei o emparelhamento em algumas situa√ß√µes em que precisei minimizar o </font><font style="vertical-align: inherit;">tamanho </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">total</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dos dados compactados e o c√≥digo de descompress√£o.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, podemos fazer uma altera√ß√£o em uma linha do programa Python para aplicar o dicion√°rio da direita para a esquerda: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquivo decompress2.py:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-comment"><span class="hljs-comment"># Read the compressed data file. data = sys.stdin.read() # Extract the two integers of the four-byte header. tablesize, datasize = struct.unpack('HH', data[0:4]) data = data[4:] # Separate the dictionary table and the compressed data. tablesize *= 3 table = data[0:tablesize] data = data[tablesize:datasize] # Apply the dictionary entries to the data section in reverse order. for n in range(len(table) - 3, -3, -3): key = table[n] val = table[n+1:n+3] data = data.replace(key, val) # Output the expanded result. sys.stdout.write(data)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se tentarmos esta vers√£o, a sa√≠da ser√° muito maior: </font></font><br><br><blockquote><pre> $ python ./decompress2.py &lt;levels/lesson_1.pak | xxd | less<font></font>
00000000: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000010: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000020: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000030: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000040: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000050: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000060: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000070: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000080: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000090: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000000b0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000000c0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000000d0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000000e0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000000f0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000100: 0000 0000 0000 0000 0000 0101 0101 0100 ................<font></font>
00000110: 0101 0101 0100 0000 0000 0000 0000 0000 ................<font></font>
00000120: 0000 0000 0000 0000 0000 0100 0000 0101 ................<font></font>
00000130: 0100 0000 0100 0000 0000 0000 0000 0000 ................<font></font>
00000140: 0000 0000 0000 0000 0000 0100 2300 0125 ............#..%<font></font>
00000150: 0100 2300 0100 0000 0000 0000 0000 0000 ..#.............<font></font>
00000160: 0000 0000 0000 0000 0101 0101 011d 0124 ...............$<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000170: 011d 0101 0101 0100 0000 0000 0000 0000 ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
linhas 1-24 / 93 (mais) </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vemos muitos bytes nulos nesta sa√≠da, mas isso pode muito bem corresponder a um cart√£o quase vazio. </font><font style="vertical-align: inherit;">Bytes diferentes de zero parecem estar agrupados um ao lado do outro. </font><font style="vertical-align: inherit;">Como esperamos encontrar uma placa 32 √ó 32, reformate a sa√≠da para 32 bytes por linha:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ python ./decompress2.py &lt;levels / li√ß√£o_1.pak | </font><font style="vertical-align: inherit;">xxd -c32 | </font><font style="vertical-align: inherit;">menos</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000000: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000020: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000040: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................</font></font><font></font>
00000060: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
00000080: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
000000a0: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
000000c0: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
000000e0: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
00000100: 0000 0000 0000 0000 0000 0101 0101 0100 0101 0101 0100 0000 0000 0000 0000 0000 ................................<font></font>
00000120: 0000 0000 0000 0000 0000 0100 0000 0101 0100 0000 0100 0000 0000 0000 0000 0000 ................................<font></font>
00000140: 0000 0000 0000 0000 0000 0100 2300 0125 0100 2300 0100 0000 0000 0000 0000 0000 ............#..%..#.............<font></font>
00000160: 0000 0000 0000 0000 0101 0101 011d 0124 011d 0101 0101 0100 0000 0000 0000 0000 ...............$................<font></font>
00000180: 0000 0000 0000 0000 0100 2000 1b00 0000 0000 1a00 2000 0100 0000 0000 0000 0000 .......... ......... ...........<font></font>
000001a0: 0000 0000 0000 0000 0100 2300 011f 0033 001e 0100 2300 0100 0000 0000 0000 0000 ..........#....3....#...........<font></font>
000001c0: 0000 0000 0000 0000 0101 0101 0123 0000 0023 0101 0101 0100 0000 0000 0000 0000 .............#...#..............<font></font>
000001e0: 0000 0000 0000 0000 0100 2300 011f 0000 001e 0100 2300 0100 0000 0000 0000 0000 ..........#.........#...........<font></font>
00000200: 0000 0000 0000 0000 0100 0000 1a00 0023 0000 1b00 0000 0100 0000 0000 0000 0000 ...............#................<font></font>
00000220: 0000 0000 0000 0000 0101 0101 0101 1c01 1c01 0101 0101 0100 0000 0000 0000 0000 ................................<font></font>
00000240: 0000 0000 0000 0000 0000 0000 0100 0001 0000 0100 0000 0000 0000 0000 0000 0000 ................................<font></font>
00000260: 0000 0000 0000 0000 0000 0000 0100 2301 2300 0100 0000 0000 0000 0000 0000 0000 ..............#.#...............<font></font>
00000280: 0000 0000 0000 0000 0000 0000 0100 0001 2100 0100 0000 0000 0000 0000 0000 0000 ................!...............<font></font>
000002a0: 0000 0000 0000 0000 0000 0000 0101 0101 0101 0100 0000 0000 0000 0000 0000 0000 ................................<font></font>
000002c0: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
000002e0: 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ................................<font></font>
lines 1-24/47 (more) </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tendo analisado cuidadosamente padr√µes de valores diferentes de zero, veremos que o mapa √© claramente vis√≠vel na sa√≠da. </font><font style="vertical-align: inherit;">De fato, podemos tornar esse padr√£o mais vis√≠vel usando a ferramenta de despejo ‚Äúcolorida‚Äù, que atribui uma cor a cada valor de byte, simplificando a pesquisa de padr√µes de valores repetidos: </font></font><br><br> <code>xcd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© uma ferramenta n√£o padr√£o, mas voc√™ pode baix√°-lo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Observe a op√ß√£o do </font></font><code>-r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilit√°rio </font></font><code>less</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que informa para limpar as seq√º√™ncias de controle.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w4/8p/68/w48p68o5f00b_zuu13pagsfb0um.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compare isso com um mapa de primeiro n√≠vel desenhado por f√£s: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe5/03a/ae9/fe503aae95f2acaa3a3663c43f528cef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sem d√∫vida, vemos os dados do mapa de n√≠veis. </font><font style="vertical-align: inherit;">Voc√™ pode ter certeza de que determinamos corretamente o algoritmo de descompacta√ß√£o.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpreta√ß√£o de dados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao comparar os valores de bytes com a imagem do mapa, podemos determinar o que </font></font><code>00</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codifica um bloco vazio, </font></font><code>01</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codifica uma parede e </font></font><code>23</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indica um chip. </font></font><code>1A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indica uma porta vermelha, </font></font><code>1B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- uma porta azul, e assim por diante. Podemos atribuir valores exatos √†s fichas, chaves, portas e todas as outras pe√ßas que comp√µem todo o mapa de n√≠veis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos ir para o pr√≥ximo n√≠vel e encontrar os valores de bytes para os objetos que aparecem l√°. E continue com os pr√≥ximos n√≠veis at√© obter uma lista completa de valores de bytes e objetos de jogo que eles codificam. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como sugerimos inicialmente, o cart√£o termina exatamente ap√≥s 1024 bytes (no deslocamento </font></font><code>000003FF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desta vez, para remover as primeiras 32 linhas do despejo, usamos</font></font><code>sed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como temos 32 bytes por linha, pularemos os primeiros 1024 bytes.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lq/xf/tu/lqxftuj5dvg9tletfkavcjd3n6m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imediatamente ap√≥s os dados do mapa, h√° uma sequ√™ncia de 384 bytes (cujos valores est√£o no intervalo </font></font><code>00000400</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font><code>0000057F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), quase todos iguais a zero, mas valores diferentes de zero tamb√©m ficam entre eles. </font><font style="vertical-align: inherit;">Depois disso, surge um padr√£o de bytes completamente diferente, portanto, seria l√≥gico supor que essa sequ√™ncia de 384 bytes seja uma parte separada. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se observarmos mais alguns n√≠veis, notamos rapidamente o padr√£o. </font><font style="vertical-align: inherit;">A parte de 384 bytes na verdade consiste em tr√™s subse√ß√µes, cada uma com 128 bytes de comprimento. </font><font style="vertical-align: inherit;">Cada subse√ß√£o come√ßa com alguns bytes diferentes de zero, seguidos de zeros que preenchem o restante da subse√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alguns n√≠veis cont√™m muitos dados; para outros (por exemplo, para o primeiro n√≠vel) apenas o m√≠nimo. Comparando os n√≠veis com seus cart√µes, notamos em breve que a quantidade de dados nesta parte do arquivo est√° diretamente relacionada ao n√∫mero de "mobs" por n√≠vel. Nesse caso, o n√∫mero de "monstros" inclui todas as criaturas no n√≠vel, blocos de terra (que n√£o se movem independentemente, mas podem ser empurrados) e o personagem principal, Chip (jogador). Ou seja, os mobs n√£o s√£o indicados no pr√≥prio mapa, mas s√£o codificados nesses tr√™s buffers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois que soubemos que essas tr√™s subse√ß√µes cont√™m dados sobre os mobs no n√≠vel, n√£o ser√° muito dif√≠cil descobrir o que est√° contido em cada uma das subse√ß√µes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira subse√ß√£o de 128 bytes √© uma lista de valores de bytes que determinam o tipo de mob. Por exemplo, os buffers de segundo n√≠vel t√™m a seguinte apar√™ncia:</font></font><br><br><blockquote><pre> $ python ./decompress2.py &lt;levels/lesson_2.pak | xxd | less<font></font>
00000400: 0608 1c1c 0808 0000 0000 0000 0000 0000 ................<font></font>
00000410: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000420: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000430: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000440: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000450: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000460: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000470: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000480: a870 98a0 6868 0000 0000 0000 0000 0000 .p..hh..........<font></font>
00000490: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000004a0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000004b0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000004c0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000004d0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000004e0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
000004f0: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000500: 6060 6060 5868 0000 0000 0000 0000 0000 ````Xh..........<font></font>
00000510: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000520: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000530: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000540: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000550: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font>
00000560: 0000 0000 0000 0000 0000 0000 0000 0000 ................<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000570: 0000 0000 0000 0000 0000 0000 0000 0000 ................</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
linhas 64-87 / 93 (mais) </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compare isso com um mapa de n√≠vel: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/705/4aa/f21/7054aaf21da6d4ccaf7c7d30a31cee94.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse n√≠vel, existem seis monstros: tr√™s bugs, dois blocos e um chip. </font><font style="vertical-align: inherit;">A primeira subchave de 128 bytes cont√©m um byte </font></font><code>06</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tr√™s bytes </font></font><code>08</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e dois bytes </font></font><code>1C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seria razo√°vel concluir o que </font></font><code>06</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chip representa </font></font><code>08</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- um bug e </font></font><code>1C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- um bloco. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Continuando a comparar arquivos de dados a partir dos n√≠veis dos cart√µes e preencha o nosso mobs dicion√°rio, n√≥s rapidamente encontrar uma falha nessa teoria: O chip pode ser referido quatro valores diferentes, ou seja </font></font><code>04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>05</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>06</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou</font></font><code>07</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Na verdade, esse conjunto de nota√ß√µes cont√©m todos os mobs. Quando estudarmos cuidadosamente os diferentes valores, entenderemos eventualmente que o valor 0, 1, 2 ou 3 √© adicionado ao valor do byte, indicando o tipo, indicando a dire√ß√£o inicial da multid√£o: norte, leste, sul ou oeste. Ou seja, por exemplo, um valor de byte </font></font><code>06</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indica um Chip olhando para o sul.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O significado das outras duas subse√ß√µes √© menos √≥bvio. Mas, tendo estudado os valores repetidos nessas subse√ß√µes e comparando as placas para esses mobs, entenderemos que os bytes na segunda subse√ß√£o armazenam a coordenada X de cada mob e os bytes na terceira subse√ß√£o armazenam a coordenada Y de cada mob. A compreens√£o dessa decis√£o √© prejudicada pelo fato de que as coordenadas armazenadas nessas subse√ß√µes s√£o na verdade deslocadas 3 bits para a esquerda, ou seja, multiplicado por 8. Esse pequeno fato explica o grupo "azul", encontrado no censo de valores. (As raz√µes pelas quais essa altera√ß√£o foi feita n√£o s√£o claras, mas √© mais prov√°vel que os tr√™s bits inferiores sejam usados ‚Äã‚Äãpara representar a anima√ß√£o quando os mobs se movem.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de lidar com essa parte, agora podemos ver quantos arquivos de dados t√™m apenas alguns bytes restantes: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota o que</font></font><code>xxd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aceita um </font></font><code>-s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor hexadecimal </font><font style="vertical-align: inherit;">para a op√ß√£o</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ para f em n√≠veis / *; </font><font style="vertical-align: inherit;">fa√ßa python ./decompress2.py &lt;$ f | </font><font style="vertical-align: inherit;">xxd -s 0x580 | </font><font style="vertical-align: inherit;">sed -n 1p; </font><font style="vertical-align: inherit;">feito | </font><font style="vertical-align: inherit;">menos</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 9001 0c17 1701 1120 1717 00 ....... ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 0000 0c17 1b13 0c0d 101f 011e 1a20 1b00 .............</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: f401 0c18 1e1f 101d 0f0c 1800 ............</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 2c01 0c1b 0c1d 1f18 1019 1f00, ...........</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 9001 0c1d 0e1f 140e 1117 1a22 00 ............ "</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 2c01 0d0c 1717 1e01 1a01 1114 1d10 00, ..............</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 2c01 0d10 220c 1d10 011a 1101 0d20 1200, ... "........</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 5802 0d17 1419 1600 X .......</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: 0000 0d17 1a0d 0f0c 190e 1000 ............</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: f401 0d17 1a0d 1910 1f00 ..........</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000580: f401 0d17 1a0e 1601 110c 0e1f 1a1d 2400 .............. $.</font></font><font></font>
00000580: ee02 0d17 1a0e 1601 0d20 1e1f 101d 0114 ......... ......<font></font>
00000580: 5802 0d17 1a0e 1601 1901 1d1a 1717 00 X..............<font></font>
00000580: 5e01 0d17 1a0e 1601 1a20 1f00 ^........ ..<font></font>
00000580: c201 0d17 1a0e 1601 0d20 1e1f 101d 00 ......... .....<font></font>
00000580: 2c01 0d1a 2019 0e10 010e 141f 2400 ,... .......$.<font></font>
00000580: 5000 0d1d 201e 1311 141d 1000 P... .......<font></font>
00000580: e703 0e0c 1610 0122 0c17 1600 ......."....<font></font>
00000580: 5802 0e0c 1e1f 1710 0118 1a0c 1f00 X.............<font></font>
00000580: 8f01 0e0c 1f0c 0e1a 180d 1e00 ............<font></font>
00000580: 0000 0e10 1717 0d17 1a0e 1610 0f00 1b1d ................<font></font>
00000580: 2c01 0e13 0e13 0e13 141b 1e00 ,...........<font></font>
00000580: 8f01 0e13 1417 1710 1d00 ..........<font></font>
00000580: bc02 0e13 141b 1814 1910 00 ...........<font></font>
lines 1-24/148 (more) </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinar o primeiro par de bytes no restante indica rapidamente que eles cont√™m outro valor inteiro de 16 bits. </font><font style="vertical-align: inherit;">Se voc√™ cont√°-los de modo que a maioria dos valores em nota√ß√£o decimal √© um n√∫mero redondo: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comando </font></font><code>od</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para ir para o original deslocamento √© usado </font></font><code>-j</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em vez </font></font><code>-s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tamb√©m vale a pena observar o comando </font></font><code>printf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: al√©m de fornecer formata√ß√£o, √© uma maneira conveniente de exibir texto sem uma nova linha pendurada no final.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ para f em n√≠veis / *; </font><font style="vertical-align: inherit;">imprimef "% -20s" $ f; </font><font style="vertical-align: inherit;">python ./decompress2.py &lt;$ f | </font><font style="vertical-align: inherit;">od -An -j 0x580 -tuS -N2; </font><font style="vertical-align: inherit;">feito | </font><font style="vertical-align: inherit;">menos</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / all_full.pak 400</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / alphabet.pak 0</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / amsterda.pak 500</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n√≠veis / apartmen.pak 300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n√≠veis / arcticfl.pak 400</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / balls_o_.pak 300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / beware_o.pak 300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n√≠veis / blink.pak 600</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / blobdanc.pak 0</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / blobnet.pak 500</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / block_fa.pak 500</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / block_ii.pak 750</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / block_n_.pak 600</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / block_ou.pak 350</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n√≠veis / bloco.pak 450</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / bounce_c.pak 300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / brushfir.pak 80</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / cake_wal.pak 999</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / castle_m.pak 600</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n√≠veis / catacomb.pak 399</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / cellbloc.pak 0</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n√≠veis / chchchip.pak 300</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
n√≠veis / chiller.pak 399</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
levels / chipmine.pak 700</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
linhas 1-24 / 148 (mais) </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voltarmos √† lista, criada originalmente a partir dos dados que esper√°vamos encontrar nos arquivos, perceberemos que esse n√∫mero √© o momento de concluir o n√≠vel (se o valor for zero, n√£o haver√° limite de tempo no n√≠vel). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s esses dois bytes, os dados se tornam mais vol√°teis. </font><font style="vertical-align: inherit;">O fato de que para a maioria dos n√≠veis existem cerca de dez bytes restantes no arquivo limita seriamente seu conte√∫do:</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ python ./decompress2.py &lt;levels / all_full.pak | </font><font style="vertical-align: inherit;">xxd -s 0x0582</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000582: 0c17 1701 1120 1717 00 ..... ... </font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, apenas nove bytes permanecem nesse n√≠vel. </font><font style="vertical-align: inherit;">Levamos em conta esse tamanho limitado e o fato de esses nove bytes conterem quatro ocorr√™ncias do valor </font></font><code>17</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, coletadas em dois pares. </font><font style="vertical-align: inherit;">Notaremos imediatamente que o padr√£o de n√∫meros </font></font><code>17</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corresponde ao padr√£o de letras </font></font><code>L</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no nome do n√≠vel "TUDO CHEIO". </font><font style="vertical-align: inherit;">O nome tem oito caracteres, portanto o byte nulo no final provavelmente √© o caractere de final de linha. </font><font style="vertical-align: inherit;">Depois de descobrir isso, voc√™ pode examinar trivialmente todos os outros n√≠veis e usar seus nomes para criar uma lista completa de caracteres:</font></font><br><br><table><tbody><tr><td> <code>00</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fim de linha </font></font></td></tr><tr><td> <code>01</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> barra de espa√ßo </font></font></td></tr><tr><td> <code>02</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><code>0B</code> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√≠gitos de 0 a 9 </font></font></td></tr><tr><td> <code>0C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><code>25</code> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> letras AZ </font></font></td></tr><tr><td> <code>26</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><code>30</code> </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sinais de pontua√ß√£o </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para a maioria dos n√≠veis, o arquivo de dados termina aqui. </font><font style="vertical-align: inherit;">No entanto, algumas d√∫zias do nome ainda t√™m dados. </font><font style="vertical-align: inherit;">Se dermos uma olhada na lista, veremos que existem n√≠veis com bot√µes de dica, e esses dados restantes cont√™m o texto da linha de dica de n√≠vel codificada com o mesmo conjunto de caracteres que os nomes dos n√≠veis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois disso, chegamos ao final de todos os arquivos. </font><font style="vertical-align: inherit;">Agora, temos uma descri√ß√£o completa do esquema da camada de dados. </font><font style="vertical-align: inherit;">Nossa tarefa est√° conclu√≠da.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Neg√≥cios inacabados </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um leitor atento pode perceber que, inicialmente, esper√°vamos encontrar mais dois elementos nesses arquivos que nunca encontramos. Explicaremos a aus√™ncia de ambos: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O primeiro elemento √© o n√∫mero de chips, ou seja, O n√∫mero total de fichas que um jogador deve coletar para passar pelo conector do chip. Como dissemos inicialmente, geralmente √© igual ao n√∫mero total de fichas em um n√≠vel, mas isso nem sempre acontece. Portanto, esses dados devem ser obtidos de alguma maneira. A resposta pode ser encontrada estudando cartas dos n√≠veis em que existem fichas extras. Acontece que dois valores diferentes s√£o usados ‚Äã‚Äãpara indicar chips. O valor </font></font><code>23</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que encontramos inicialmente, mas o valor tamb√©m √© usado</font></font><code>31</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denotando um chip que n√£o afeta a quantidade total necess√°ria para abrir o conector do chip. (No entanto, do ponto de vista da jogabilidade, os dois tipos de fichas s√£o os mesmos. Se houver um tipo de ficha </font></font><code>31</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no n√≠vel, ent√£o no n√≠vel voc√™ n√£o poder√° coletar nenhum n√∫mero de fichas.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O segundo elemento √© a senha de n√≠vel de quatro letras. </font><font style="vertical-align: inherit;">N√£o est√° oculto em nenhum lugar nos dados de n√≠vel. </font><font style="vertical-align: inherit;">Infelizmente, esse problema n√£o pode ser resolvido por uma investiga√ß√£o mais aprofundada do arquivo de dados. </font><font style="vertical-align: inherit;">Somos for√ßados a concluir que as senhas s√£o simplesmente armazenadas em outro lugar. </font><font style="vertical-align: inherit;">A explica√ß√£o mais prov√°vel: eles s√£o codificados em algum lugar do pr√≥prio programa. </font><font style="vertical-align: inherit;">No entanto, mais tarde ficou claro que as senhas n√£o s√£o armazenadas diretamente. </font><font style="vertical-align: inherit;">De pessoas familiarizadas com o pr√≥prio c√≥digo, aprendi que as senhas s√£o geradas dinamicamente usando um gerador de n√∫meros pseudo-aleat√≥rios inicializado com uma sequ√™ncia espec√≠fica. </font><font style="vertical-align: inherit;">Portanto, as senhas para n√≠veis n√£o podem ser alteradas diretamente; isso s√≥ pode ser feito alterando o c√≥digo do assembler.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posf√°cio </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazendo uma engenharia reversa completa dos dados nos arquivos de n√≠vel, eu poderia come√ßar a escrever um programa que pode codificar e decodificar dados de n√≠vel. Gra√ßas a ela, eu pude criar o t√£o esperado editor de n√≠veis para a vers√£o do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chip's Challenge</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for Lynx, e a presen√ßa dessa ferramenta aumentou muito minha capacidade de estudar a l√≥gica do jogo e tamb√©m melhorou a qualidade de sua emula√ß√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas ... devo admitir que pessoalmente fiz o desenvolvimento reverso dos arquivos de dados de uma maneira n√£o descrita acima. Comecei do outro lado - com a defini√ß√£o de dados de string. Comecei a estudar os arquivos dos oito primeiros n√≠veis. Como eles s√£o chamados de ‚ÄúLI√á√ÉO 1‚Äù a ‚ÄúLI√á√ÉO 8‚Äù, procurei os dados de substrings id√™nticos neles. E tive sorte: nenhum dos nomes desses n√≠veis foi compactado; portanto, todos os oito nomes s√£o armazenados nos arquivos de dados em sua forma original. Obviamente, fiquei envergonhado por essas linhas n√£o terem sido armazenadas em caracteres ASCII, mas o duplo S no nome me ajudou a detectar um padr√£o que se repetia nos oito arquivos de dados. E, tendo encontrado o nome, reconheci a codifica√ß√£o de caracteres de letras, n√∫meros e o caractere de espa√ßo. Depois apliquei essa codifica√ß√£o no restante do arquivo e, logo ap√≥s o nome, vi linhas de prompt e comecei a observar as anomalias:</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um √≥timo utilit√°rio </font></font><code>tr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">facilita a convers√£o de seu pr√≥prio conjunto de caracteres de arquivos de dados para ASCII.</font></font><br><br><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ tr '\ 001- \ 045' '0-9A-Z' &lt;n√≠veis / li√ß√£o_1.pak | </font><font style="vertical-align: inherit;">xxd</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000000: 4600 cb00 3000 0032 3030 3332 3235 3333 F ... 0..200322533</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000010: 3635 3537 0020 3820 2039 3636 4238 3846 6557. 8 966B88F</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000020: 0058 4a37 354d 3000 5737 4226 3746 2739 .XJ75M0.W7B &amp; 7F'9</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000030: 3928 3533 2953 2027 2733 3042 2057 3532 9 (53) S '' 30B W52</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000040: 3730 3738 304a 3226 375a 2046 4a30 5752 70780J2 &amp; 7Z FJ0WR</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000050: 2059 2052 4220 3537 0055 0050 3200 4f00 Y RB 57.U.P2.O.</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000060: 554a 2637 5400 3300 2946 4a57 5830 4642 UJ e 7T.3.) FJWX0FB</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000070: 2035 2637 544d 2946 4a37 4d4f 3058 3050 5 &amp; 7TM) FJ7MO0X0P</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
00000080: 304a 5720 5120 5142 3835 3237 3020 3020 0JW Q QB85270 0</font></font><font></font>
00000090: 2826 2058 4a33 3730 2056 4a33 5738 2727 (&amp; XJ370 VJ3W8''<font></font>
000000a0: 3933 3200 3439 3628 324d 7839 3628 324d 932.496(2Mx96(2M<font></font>
000000b0: 7039 3628 324d 6400 4c45 5353 4f4e 2031 p96(2Md.LESSON 1<font></font>
000000c0: 0043 4f4c 4c45 4354 2043 4849 5029 544f .COLLECT CHIP)TO<font></font>
000000d0: 0047 4554 2050 4153 5420 5448 4520 4348 .GET PAST THE CH<font></font>
000000e0: 4950 0053 4f43 4b45 542d 0055 5345 204b IP.SOCKET-.USE K<font></font>
000000f0: 4559 2954 4f20 4f50 454e 0044 4f4f 5253 EY)TO OPEN.DOORS<font></font>
00000100: 2d30 -0 </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, no texto de ajuda, h√° dois lugares onde a sequ√™ncia de S e o espa√ßo s√£o substitu√≠dos pelo colchete direito. </font><font style="vertical-align: inherit;">Essas anomalias me deram evid√™ncias suficientes para calcular dedutivamente a presen√ßa de compress√£o e obter algumas informa√ß√µes sobre sua natureza. </font><font style="vertical-align: inherit;">Mais tarde, associei valores anormais de bytes com suas ocorr√™ncias mais perto do in√≠cio do arquivo de dados. </font><font style="vertical-align: inherit;">(Por exemplo, no despejo de deslocamento hexadecimal mostrado acima, </font></font><code>00000035</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h√° um colchete direito, seguido por um capital S e um espa√ßo.) A partir disso, calculei o esquema de compacta√ß√£o de maneira semelhante ao processo descrito no artigo. </font><font style="vertical-align: inherit;">Tudo o resto era bem simples. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece-me que se pode tirar uma li√ß√£o disso: n√£o h√° uma maneira √∫nica de examinar um arquivo de dados desconhecido. </font><font style="vertical-align: inherit;">Qualquer ferramenta adequada a voc√™ √© a ferramenta certa para engenharia reversa.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt447562/">https://habr.com/ru/post/pt447562/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt447552/index.html">Como otimizar se√ß√µes de cat√°logo em uma loja online: instru√ß√µes passo a passo</a></li>
<li><a href="../pt447554/index.html">Vis√£o geral dos novos recursos do NestJS 6</a></li>
<li><a href="../pt447556/index.html">Extens√£o Mypy com plugins</a></li>
<li><a href="../pt447558/index.html">Realidade virtual - jogo, tratamento, vida. Tecnologia VR ao servi√ßo da medicina de reabilita√ß√£o</a></li>
<li><a href="../pt447560/index.html">Construindo um projeto BEM usando o Webpack</a></li>
<li><a href="../pt447564/index.html">Altera√ß√µes na autoriza√ß√£o do reposit√≥rio no GitLab.com</a></li>
<li><a href="../pt447566/index.html">Os cientistas mostraram pela primeira vez uma "foto" real de um buraco negro</a></li>
<li><a href="../pt447568/index.html">Entrevista com o astronauta Alexander Laveikin sobre cinema espacial, sobrecargas de 20 unidades e pouso suave</a></li>
<li><a href="../pt447570/index.html">GoLand 2019.1: an√°lise de desempenho de c√≥digo, Smart Step Into, refatora√ß√£o da Extract Interface, Nilness Analyzer e mais</a></li>
<li><a href="../pt447572/index.html">Energia, calor e √°gua: parte dois</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>