<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧒🏻 👩🏽‍💼 ◾️ 两个红色按钮，烙铁和React：我们如何推动IT会议 🧝🏽 🐓 👴🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Badoo经常通过展位参加IT会议的展览。 因此，每年，我们都会与同事-工程师和精疲力竭-一起做一件事情，做一件好事，以免在报告之间感到无聊。 


 我叫Ivan，我是前端开发人员。 在本文中，我们将与我们的同事和DIY爱好者lilek Yura Lilekov一起，向您介绍如何使用两个红色按钮，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>两个红色按钮，烙铁和React：我们如何推动IT会议</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/482028/"><p>  Badoo经常通过展位参加IT会议的展览。 因此，每年，我们都会与同事-工程师和精疲力竭-一起做一件事情，做一件好事，以免在报告之间感到无聊。 </p><br><p> 我叫Ivan，我是前端开发人员。 在本文中，我们将与我们的同事和DIY爱好者<a href="https://habr.com/ru/users/lilek/" class="user_link">lilek</a> Yura Lilekov一起，向您介绍如何使用两个红色按钮，一个微控制器，一个React代码和250个有关IT主题的单词，制作出“ IT猜测游戏”游戏，并在Highload ++上进行舒适的聚会和Heisenbug。 </p><br><p><img src="https://habrastorage.org/webt/op/k9/r9/opk9r9az9g7eovtbqkgcra83ntm.png"></p><a name="habracut"></a><br><h1 id="soderzhanie"> 内容： </h1><br><p>  <a href="https://habr.com/ru/company/badoo/blog/482028/">不平凡的传统知识</a> <br>  <a href="https://habr.com/ru/company/badoo/blog/482028/">游戏机制和得分</a> <br>  <a href="https://habr.com/ru/company/badoo/blog/482028/">动画制作</a> <br>  <a href="https://habr.com/ru/company/badoo/blog/482028/">前端</a> <br>  <a href="https://habr.com/ru/company/badoo/blog/482028/">硬件：两个红色按钮</a> <br>  <a href="https://habr.com/ru/company/badoo/blog/482028/">结果</a> </p><br><h1 id="netrivialnoe-tz"> 不平凡的传统知识 </h1><br><p>  IT会议有自己的氛围：有很多人，要吸引和吸引他们的注意力并不容易。 为了使他们能够在两次报告休息之间准确地来找我们，我们需要为他们提供有趣但简单的课程。 </p><br><p> 受到去年IT别名成功的启发，我们对新游戏制定了以下要求： </p><br><ul><li> 它必须是多用户。 参与者的沟通是主要任务。 我们知道，有许多人独自一人，并不总是很容易与陌生人对话。 游戏应该给彼此和与Badoo工程师交谈的机会。 </li><li> 会议时间应简短。 会议可能有1-3千人，我们希望尽可能多地吸引与会人员。 </li><li>游戏应该是壮观的。 如果一个人不参加游戏，那么至少让他观看。 这激发了兴趣，有助于理解本质并决定参与。 </li><li> 最简单的管理。 众所周知，如果某些东西可以破裂，那肯定会破裂。 </li><li> 无需注册和短信！ </li></ul><br><p> 经过集思广益，在梦中进行思考并尝试获得灵感，我们提出了“ IT猜谜游戏” —一个简单的游戏，上面写有有关IT主题的文字。 </p><br><p><img src="https://habrastorage.org/webt/8r/p4/5f/8rp45fdtczsizalimesfrnb9kc4.jpeg"></p><br><p> 的本质是什么： </p><br><ul><li> 两个参与者同时玩。 </li><li> 任务是比对手更快地按下按钮，然后猜测屏幕上显示的加密单词。 </li><li> 分为两个阶段：简单的（“快捷方式”），将单词写回到最前面；困难的阶段（“ Stirrers”），将单词中的所有字母混合在一起。 </li><li> 如果答案是正确的，则计分到响应者。 错误-比分归于对手。 </li><li> 得分至少为N分的人可以参加降噪耳机的抽奖。 </li></ul><br><p> 看起来一切都很简单，但困难重重。 </p><br><h1 id="mehanika-igry-i-podschyot-ballov"> 游戏机制和得分 </h1><br><p><img src="https://habrastorage.org/webt/wf/vr/e_/wfvre_npwrjlh4duabj8kkxb6og.gif"></p><br><p> 从此gif来看，很明显，舍入过程是什么样的： </p><br><ol><li> 出现一个加密的单词。 </li><li> 计时器开始10秒钟。 </li><li> 如果其中一个玩家按下按钮，则此计时器停止，而另一个计时器开始-3秒钟。 在这段时间内，必须给玩家一个答案，否则分数将记入对手。 </li><li> 如果没有人按该按钮，则单词会自动更改，然后再次重复整个过程。 </li></ol><br><p> 我们面临的主要问题是如何保持得分和记录球员。 我们希望使游戏尽可能快，而不是迫使参与者在任何地方注册。 但是，有必要了解其中的哪些人得分达到一定数量并可以得到主要奖励。 </p><br><p> 我们不是第一次提出计算机制。 经过几次测试，才变得清楚如何使游戏变得既方便又简单-无论是对于参与者还是对于主持人。 </p><br><h2 id="provalnye-i-genialnye-idei"> 失败的想法 </h2><br><h3 id="ideya-1-odin-ball--odna-malenkaya-shokoladka"> 想法＃1：1分= 1小块巧克力 </h3><br><p> 对于每个正确答案，首先我们决定提供一个巧克力棒。 最后，参与者带来了巧克力（或者至少从被吃掉的“要点”中拿出糖果包装纸），就这样！ 我们计算奖杯，我们认识赢家。 </p><br><p> 但是有几点。 </p><br><p> 第一：不方便。 事实证明，适度游戏并同时计算积分是不可能的；需要第二个助手。 就摊位上的人的力量和时间而言，这太昂贵了。 考虑到游戏的速度，我将不得不向参与者扔巧克力。 </p><br><p> 第二点-如何区分我的巧克力和其他人的巧克力？ 玩家可以合作并从中堆叠巧克力或糖果包装。 因此，电路不起作用！ 此外，会议为期两天，您可以无休止地收集巧克力。 </p><br><p> 第三点：您需要太多巧克力。 我们通过实验检查了一个普通玩家的得分，并意识到至少一辆货车需要巧克力。 而且我们只有一个小推车。 </p><br><p><img src="https://habrastorage.org/webt/1h/j_/8z/1hj_8zp8amb6-taaowqum3y54gm.jpeg"></p><br><h3 id="ideya-2-turnirnaya-tablica"> 想法＃2：排名 </h3><br><p> 一些人在比赛时，其他人将自己记录在积分榜中。 在这种情况下，我们将遇到所有可能的问题：同名，同名，书写错误，书写不清（或需要放置另一台大型显示器和笔记本电脑进行输入），不愿离开您的联系人等等。 </p><br><p> 因此，我们继续搜索。 </p><br><h3 id="ideya-3-otmetki-na-beydzhah-uchastnikov"> 想法3：参与者徽章上的标记 </h3><br><p> 为了解决注册玩家的问题，我们使用了现成的解决方案：将徽章分发给所有参与者。 这是没有人会失去的，每个参与者都有。 我们决定直接向他们写一个帐户。 参与者来计数，看了徽章，数了点并确定了获胜者。 但是这个计划也有一个陷阱：玩家可以“伪造”徽章上的最终分数。 </p><br><p> 然后我们完全放弃了记录分数的想法。 让获得积分阈值的人在徽章上获得特殊标记-以我们内心的形式邮票-他们进入了“选择的”圈子。 在这些参与者之间，我们将随机抽取主要奖项。 其余的人仍然会收到礼物：我们的贴纸，笔记本，持卡人和决策者。 </p><br><p><img src="https://habrastorage.org/webt/_m/hz/u7/_mhzu7f8w8nizwmtpq57u-zdew4.jpeg" alt="当然，Badoo员工没有参加赠品。"><br>  <em>当然，Badoo员工没有参加赠品。</em> </p><br><p> 该方案如下： </p><br><ol><li> 访客在徽章上标记有参与标记：黑色代表达到20分，紫色代表参加比赛。 一天可以进行三次尝试，并获得三颗心。 </li><li> 所有带有黑色标记的获奖者都将在特定时间聚集在展台上，借助温暖的电子管抽奖鼓，我们在他们之间播放耳机。 </li></ol><br><p><img src="https://habrastorage.org/webt/gd/ui/bn/gduibngslf724dhlrpftt2ivxua.png"></p><br><p> 在对有生命的人进行游戏测试之后，我们计算了阈值：在游戏中获得20分并非易事。 但是在两天的Highload ++中，大约有15个人是赢家！ </p><br><p> 的确，在单词列表中，有很多术语是开发人员首先理解的，因此对于Heisenbug QA会议，我们同意将阈值定为15分。 也许是徒劳的：准决赛者竟然增加了很多倍，这意味着赢得耳机的机会更少了。 </p><br><p>  PS在开始阶段，我们认为答案错误将使参与者失去巧克力棒得分。 但是没有人喜欢被抢劫。  “这是我的巧克力棒，我赚了！”-最初的游戏测试人员都很愤慨。 因此，作为惩罚，我们开始为对手加分。 </p><br><p><img src="https://habrastorage.org/webt/ry/yo/y5/ryyoy50ox1-o3zo-hyth8bae_pc.jpeg"></p><br><h1 id="animaciya"> 动画制作 </h1><br><p> 猜词应以某种动画形式出现。 这给了我们两个好处： </p><br><ol><li> 单词之间的一种“跳动”。 如果玩家之间有任何动作，则从一个单词切换到另一个单词要容易得多。 记住旧的格斗游戏。 每个新回合都以“ 3..2..1..FIGHT！”开始。 我不想在这里再做一个计时器-我们已经批量使用了。 </li><li> 视觉多样性。 我们试图使游戏尽可能简单，我们没有动画背景和关卡之间的过渡。 我们也不能使用声音，以免干扰其他会议参与者。 因此，动画是必要的。 </li></ol><br><p> 有了她，并不是一切都马上顺利进行。 在测试运行中，有些狡猾的家伙没有等待动画的结束，而是更早地单击了按钮。 为了教授这些技巧，当一名玩家过早按下按钮时，我们开始阻止单词出现。 单词的尚未出现的部分，在这种情况下仍隐藏在字符后面。 无论玩家是否想要，他都必须回答。 很难用几个字母猜出一个单词，所以对手得了分。 </p><br><p> 如果您提前单击按钮，则单词的外观如下： </p><br><p><img src="https://habrastorage.org/webt/nv/gy/cb/nvgycbadg6xh84ufckataq_izri.gif"></p><br><p> 第二个困难时刻是动画的持续时间。 它总是持续相同的时间-1.5秒。 如果您“赶上节奏”，那么您可以比对手更快地获得按下按钮的快感。 为了解决该问题，我们添加了一个0到500 ms的随机变量。 在这种情况下，调整节奏变得更加困难。 </p><br><h1 id="frontend"> 前端 </h1><br><p> 我会告诉您一些有关软件部分的信息。 如果您不感兴趣，请直接看<a href="https://habr.com/ru/company/badoo/blog/482028/">一下我们如何搜索红色按钮</a>的<a href="https://habr.com/ru/company/badoo/blog/482028/">故事</a> 。 </p><br><p>事实证明游戏的机制很简单，我不想重新发明轮子。 为客户端使用了<code>create-react-app</code> 。 但是仍然需要挑战。 </p><br><p> 如此钩！ 挂钩已经出现很长时间了，但是它们在Badoo主要产品中的应用需要对开发过程进行认真的重新思考。 一个小的附带项目是使用它们的绝佳跳板。 </p><br><p> 没有redux！  Redux是一件伟大的事情，我们每天在工作中使用它。 但是对于如此小的应用程序，使用redux是不合理的。 此外，还有一个新的<code>useContext</code>挂钩。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { score, changeScore } = useContext(SessionContext); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { next } = useContext(QuestionsContext); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> steps = useContext(StepsContext);</code> </pre> <br><p> 是的，我们得到了三个根本不相交的上下文，而不是一个全球性的故事。 </p><br><p>  <code>SessionContext</code>得分。 <br>  <code>StepsContext</code>负责切换应用程序屏幕：简介，循环，结尾... <br>  <code>QuestionsContext</code>上下文了解所有问题：回答了哪些问题，接下来是哪个问题，还剩下多少。 </p><br><h2 id="provider"> 提供者 </h2><br><p> 每个上下文都需要一个提供程序，它将提供数据到最终组件。 例如，我们将使用一个简单的提供程序进行评分。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> increment = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">score</span></span></span><span class="hljs-function"> =&gt;</span></span> score + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SessionProvider = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [leftPlayerScore, changeLeftPlayerScore] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [rightPlayerScore, changeRightPlayerScore] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resetScore = useCallback(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { changeLeftPlayerScore(<span class="hljs-number"><span class="hljs-number">0</span></span>); changeRightPlayerScore(<span class="hljs-number"><span class="hljs-number">0</span></span>); }, []); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> changeScore = useCallback(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">player</span></span></span><span class="hljs-function"> =&gt;</span></span> { player === <span class="hljs-string"><span class="hljs-string">'left'</span></span> ? changeLeftPlayerScore(increment) : changeRightPlayerScore(increment); }, []); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> score = { <span class="hljs-attr"><span class="hljs-attr">left</span></span>: leftPlayerScore, <span class="hljs-attr"><span class="hljs-attr">right</span></span>: rightPlayerScore }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">SessionContext.Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{{</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">score</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">changeScore</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resetScore</span></span></span></span><span class="xml"><span class="hljs-tag"> }}&gt;</span></span></span><span class="xml"> {props.children} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">SessionContext.Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); };</span></span></code> </pre> <br><p> 从代码中可以看到，我们独立跟踪点。  “左”玩家和“右”玩家有单独的状态。 以及管理帐户的功能：重置帐户并进行更改。 </p><br><p> 生成的提供程序API非常简单。 通常，几乎所有与提供程序相关的逻辑都非常简单，因此我们将不再关注它。 </p><br><h2 id="taymery"> 计时器 </h2><br><p> 游戏主轮的组成部分很有趣：其中有不明确的时刻。 两种模式（反向和随机播放-“快捷方式”和“混音器”）的组件均相同。 </p><br><p> 从这一轮的描述中可以明显看出，时间之间存在很多互动。 </p><br><p> 首先，有一个计时器负责屏幕上单词的持续时间：按下按钮需要10秒。 如果没有人按下按钮，下一个单词将自动出现。 </p><br><p> 其次，一个计时器在一个玩家单击按钮时启动。 然后，他有3秒的时间来猜单词。 </p><br><p> 似乎没有什么复杂的，所以我们编写了看似显而易见的代码： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [time, nextTick] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { nextTick(time + <span class="hljs-number"><span class="hljs-number">1</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> clearInterval(id); }, []);</code> </pre> <br><p> 但是，您可以猜测，这没有用。 根本没用！ </p><br><p> 计时器达到1并停止在该位置。 事实是旧<code>time</code>值已“锁定”在处理程序的函数内部。 因此，对于每个刻度， <code>setInterval</code>指的是从第一个渲染开始的<code>time</code>值。 </p><br><p> 解决了使用函数而不是直接值的问题： </p><br><pre> <code class="javascript hljs">nextTick(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">currentTime</span></span></span><span class="hljs-function"> =&gt;</span></span> currentTime + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p> 是的，这样我们对计时器始终拥有一个“新鲜”值。 但是，例如，我们无法获得“新鲜” <code>props</code> 。 </p><br><p> 显然，必须找到一种不同的方法。 最确定的决定是使处理函数可变。  React <code>useRef</code>有一个特殊的<code>useRef</code>钩子。 </p><br><p> 大多数情况下，它用于处理DOM元素，但这并不是其唯一的应用。 我们可以“记住” <code>current</code>属性中的任何变量，并在每次渲染时对其进行更新。 </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ setCount(count + <span class="hljs-number"><span class="hljs-number">1</span></span>); } useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { savedCallback.current = callback; }); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ savedCallback.current(); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> id = setInterval(tick, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> clearInterval(id); }, []);</code> </pre> <br><p>  Dan Abramov有一篇很好的文章介绍了如何使用<code>setInterval</code>和React钩子： <a href="https://overreacted.io/making-setinterval-declarative-with-react-hooks/">使用React Hooks使setInterval声明式</a> 。 他完美地描述了<code>useInterval</code>挂钩的实现的所有陷阱和思考的所有阶段，我们将其用作解决问题的方法。 </p><br><p> 由于摊位在整个会议期间都是开放的，因此使用该游戏进行的连续会议非常多。 该页面根本没有更新（F5），因此在开发阶段监视内存非常重要。 如您所知，泄漏与计时器是并存的，如果所有这些都通过重新渲染反应来进行，那么编写吃掉非常多内存的代码将非常容易。 </p><br><p> 在一个游戏会话中， <code>Countdown</code>开始，停止，重置并重新启动了数十次（也许数百次）。 为了不打扰检查工作，检查工作本来应该很多，所以我们使用了一个非常简单的“技巧”-在此组件中添加了关键道具。 </p><br><pre> <code class="javascript hljs">&lt;QuestionCountdown key={question.text} onComplete={nextQuestion} /&gt;</code> </pre> <br><p> 我们不会对此进行详细介绍，仍然使用相同的Dan Abramov： <a href="https://overreacted.io/react-as-a-ui-runtime/">React作为UI Runtime来</a>详尽描述反应的协调过程。 </p><br><h1 id="apparatnaya-chast-dve-krasnye-knopki"> 硬件：两个红色按钮 </h1><br><p> 因此，我们已经满足了游戏的一些要求：它是多人游戏，速度快，而且机制简单。 它仍然增加了她的娱乐性。 故事之后将是Yura Lilekov <a href="https://habr.com/ru/users/lilek/" class="user_link">lilek-</a>我们的DIY爱好者，社区<a href="https://habr.com/ru/users/lilek/" class="user_link">常任</a>发言人，机翼和其他“自己动手”设备的创作者。 </p><br><p> 我们真的很想找到两个大型机械按钮。 并确保红色-如与Agutin的模因一样。 </p><br><p> 不幸的是，在线商店中发现的所有东西都太小（直径5厘米）或根本没有按钮。 当然，有一个很好的旧的速卖通，但是没有时间等待交货。 </p><br><p> 结果，我们在广告素材代理商的网站上找到了正确的按钮。 亚历山大在郊区的某个地方做过按钮（显然是无线电电子学院的毕业生）。 我们打电话，询问将哪个微控制器缝入盒子，并要求保留对其的访问权限，因为我们需要对其进行重新编程。 </p><br><p> 坦率地说，亚历山大对这些问题感到惊讶。 当我们问这些按钮是否能承受热情的程序员的压力时，他向我们保证，这些按钮位于“ Cosmic”中的老虎机中，可以完美地应对孩子们的流动。 展望未来，我要说的是，热情的工程师们也保留了这些按钮（只需要更换一次电池）。 </p><br><p><img src="https://habrastorage.org/webt/bh/hb/bd/bhhbbdvztsnypogvlbn3jpo3nvg.png"></p><br><h2 id="nachinka"> 馅料 </h2><br><p> 但是，不幸的是，完成的设备并没有我们需要的所有质量。 而且，如果仍然可以通过断开扬声器的导线来消除声音效果，那么自动确定按下了哪个按钮并不是一件容易的事。 一个简单的建议是：将设备连接到计算机，然后将这些按钮的按下转换为键盘上的击键。 </p><br><p> 该解决方案毫不费吹灰之力-拿起旧的USB键盘，并通过键盘将几个带有附加导线的按钮从键盘连接到设备-立即被取消为“集体农场”。 并接上了DIY的力量。 </p><br><p> 经过深思熟虑，我们决定使用基于Atmel AVmel系列ATmega32u4微控制器的Arduino Pro Micro板，并进行必要的绑定。 在该板上，I / O和MicroUSB端口分开。 最重要的是-ATmega32u4微控制器可以充当HID设备，在我们的情况下，即在某些条件下模拟按键。 </p><br><p><img src="https://habrastorage.org/webt/me/pn/d9/mepnd9yvzya5fkqdxqgbsvtwgjo.png" alt="（图片是从AliExpress.com的一位卖家拍摄的"></p><br><p> 要对该微控制器进行编程，您只需要通常的MicroUSB线和Arduino IDE开发环境即可。 </p><br><p> 安装开发环境后，最简单的代码示例将立即可用。 </p><br><p> 例如，位于下面的程序可以模拟在按下按钮（连接到输入/输出端口）时在键盘上打字： </p><br><p> 文件-&gt;示例-&gt; USB-&gt;键盘-&gt; KeyboardMessage </p><br><p> 击键的模拟非常简单地实现： </p><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#include "Keyboard.h" //      void setup() { Keyboard.begin(); //   } void loop() { Keyboard.print("Test"); //   4  delay(1000); //   1  }</span></span></code> </pre> <br><p> 读取输入端口状态也不是多余的事情： </p><br><pre> <code class="cmake hljs">int button_pin = <span class="hljs-number"><span class="hljs-number">7</span></span>; //  ,     void setup() { pinMode(button_pin, INPUT); //     } void loop() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (digitalRead(button_pin)) { //   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    } }</code> </pre> <br><p> 由于端口是通过电压而不是电流打开的，因此从按钮到端口的电线中的最小感应电流会产生误报。 因此，我们建议使用高阻电阻器“拉”输入端口：感应电流会立即流过它，进入“地”，防止输入和“地”之间出现高电压差，因此不会出现误触发。 为了这些目的，一个5-10kΩ的电阻就足够了，该电阻连接在微控制器的输入与其“地”之间。 </p><br><p> 因此，我们得到以下方案： </p><br><p><img src="https://habrastorage.org/webt/gt/na/3l/gtna3lp5_d3iag_lzxh115oug6s.png"></p><br><p> 通过microUSB的Arduino Pro Micro开发板通过游戏的软件部分连接到笔记本电脑，两个按钮连接开发板的两个输入和常规电源。 另外，这两个输入被两个电阻器拉至地。 </p><br><p> 当按下其中一个按钮时，来自板的电源输出通过按钮的电流将流至板的相应输入-因此我们将在输入处看到一个逻辑“单位”。 </p><br><p> 在软件部分，我们决定模拟击键“左箭头”和“右箭头”，并在确定按下后还给出4秒钟的延迟，以避免参与者反复单击或按钮中的联系人嘎嘎作响。 </p><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;Keyboard.h&gt; char leftKey = KEY_LEFT_ARROW; char rightKey = KEY_RIGHT_ARROW; int btn1pin = 7; int btn1value = 0; int btn2pin = 8; int btn2value = 0; void setup() { pinMode(btn1pin, INPUT); pinMode(btn2pin, INPUT); Keyboard.begin(); } void loop() { btn1value = digitalRead(btn1pin); btn2value = digitalRead(btn2pin); if (btn1value == 1 &amp;&amp; btn2value == 1) { //    =    } else if (btn1value == 0 &amp;&amp; btn2value == 0) { //    =    } else if (btn1value == 1) { //    =       4  Keyboard.press(leftKey); delay(100); Keyboard.releaseAll(); delay(4000); } else if (btn2value == 1) { //    =       4  Keyboard.press(rightKey); delay(100); Keyboard.releaseAll(); delay(4000); } }</span></span></code> </pre> <br><p> 因此，借助简单的设备，我们教会了按钮以识别比对手更快地单击它们的玩家，并向演示者发出信号。 </p><br><h2 id="upravlenie"> 管理学 </h2><br><p> 完全手动且尽可能简单： </p><br><ul><li>  <strong>空间</strong> -下一个字 </li><li>  <strong>输入</strong> -显示正确的单词 </li><li>  <strong>+</strong> -正确（1分） </li><li>  <strong>0-</strong>错误（指向对手） </li><li>  <strong>左移</strong> -下一步 </li><li> 右移-上一步 </li></ul><br><h1 id="rezultat"> 结果 </h1><br><p> 在Badoo展位的所有为期四天的会议（两场在Highload ++上，两场在Heisenbug上）持续播放“ IT猜测游戏”。 我们所有的希望都实现了： </p><br><ul><li> 这场比赛吸引了参与者和观众：一排排的人聚集在展位上。 在会议的第二天，参加人数没有减少，这是特别令人愉快的。 </li><li> 按钮是最重要的！ 加100兴奋。 即使竞争对手彼此之间是陌生人，游戏也引起了很多情绪。 </li><li> 在徽章上带有标记的想法行得通：毫不费力地找到获奖者并收集联系人。 几个人要求保持徽章清洁，因此我们在手腕上做了标记（它们很容易擦除）。 </li><li> 我们分发了14对耳机和几百个小礼物。 没有人没有礼物！ </li></ul><br><p><img src="https://habrastorage.org/webt/zd/fd/vh/zdfdvheuxobpk3y0st_kbzpkgl0.jpeg"></p><br><div class="spoiler">  <b class="spoiler_title">为了参加会议上的游戏，我们赠送了很酷的商品</b> <div class="spoiler_text"><p>  <strong>决策者如痴如醉。</strong> 不知道该如何处理任务-旋转魔术盘！ 由于分发了所有内容，我们只剩下了几张照片： </p><br><p><img src="https://habrastorage.org/webt/qe/yc/fw/qeycfwgjxk5wad7b4slq5uqgmy0.jpeg"><br>  <em>对于质量检查工程师</em> </p><br><p><img src="https://habrastorage.org/webt/wy/so/ct/wysoct41vwjzn6qd-lzog7nmo7o.jpeg"><br>  <em>对于开发人员</em> </p><br><p>  <strong>IT预测性Cookie</strong> <br> 自己发明了预测（52种选择）。 实现可能性高达100％。 </p><br><p><img src="https://habrastorage.org/webt/ni/c9/vu/nic9vu9vf1xqh3xb7dyyli-mqni.png"></p><br><p><img src="https://habrastorage.org/webt/av/nf/vm/avnfvmkteect_rwrelfazf8kuau.png"></p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN482028/">https://habr.com/ru/post/zh-CN482028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN482010/index.html">“新史诗”。 对于开发人员，操作人员和好奇的人</a></li>
<li><a href="../zh-CN482012/index.html">Raspberry Pi和iperf-智能家居和物联网设备的带宽测试仪</a></li>
<li><a href="../zh-CN482014/index.html">使用SDR和Python接受和解码模拟电视</a></li>
<li><a href="../zh-CN482020/index.html">R，蒙特卡洛和企业任务</a></li>
<li><a href="../zh-CN482022/index.html">看看！ 20部关于科学和科学家的电影</a></li>
<li><a href="../zh-CN482030/index.html">Vue.js：您和第三方组件的生命周期挂钩</a></li>
<li><a href="../zh-CN482032/index.html">我们玩火：我们在开发的iPhone 7上运行任意代码</a></li>
<li><a href="../zh-CN482034/index.html">Yandex：关于用户的一切……</a></li>
<li><a href="../zh-CN482038/index.html">我们正在Haber Career总结2019年的结果</a></li>
<li><a href="../zh-CN482042/index.html">使用真实示例使用Newtonsoft.Json库。 第二部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>