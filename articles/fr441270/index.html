<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèª üö† üóùÔ∏è Premier aper√ßu de la FoundationDB d'Apple üëåüèª üßìüèæ üöá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans le dernier article, nous avons examin√© les limites et les obstacles qui surviennent lorsque vous devez mettre √† l'√©chelle des donn√©es horizontale...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Premier aper√ßu de la FoundationDB d'Apple</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441270/">  Dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dernier article,</a> nous avons examin√© les limites et les obstacles qui surviennent lorsque vous devez mettre √† l'√©chelle des donn√©es horizontalement et avoir une garantie des propri√©t√©s ACID des transactions.  Dans cet article, nous parlons de la technologie FoundationDB et comprenons comment elle aide √† surmonter ces limitations lors du d√©veloppement d'applications strat√©giques. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FoundationDB</a> est une base de donn√©es NoSQL distribu√©e avec des transactions ACID s√©rialisables qui stocke des paires de magasins cl√©-valeur tri√©es.  Les cl√©s et les valeurs peuvent √™tre des s√©quences arbitraires d'octets.  Il n'a pas un seul point d'incidence - toutes les machines de cluster sont √©gales.  Il r√©partit lui-m√™me les donn√©es entre les serveurs du cluster et √©volue √† la vol√©e: lorsque vous devez ajouter des ressources au cluster, vous ajoutez simplement l'adresse de la nouvelle machine sur les serveurs de configuration et la base de donn√©es la r√©cup√®re elle-m√™me. <a name="habracut"></a><br><br>  Dans FoundationDB, les transactions ne se bloquent jamais.  La lecture est impl√©ment√©e via le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contr√¥le de version multiversion</a> (MVCC), et la lecture est impl√©ment√©e via le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contr√¥le de concurrence optimiste</a> (OCC).  Les d√©veloppeurs affirment que lorsque toutes les machines du cluster sont dans le m√™me centre de donn√©es, la latence d'√©criture est de 2 √† 3 ms et la latence de lecture est inf√©rieure √† une milliseconde.  La documentation contient des estimations de 10 √† 15 ms, ce qui est probablement plus proche des r√©sultats en conditions r√©elles. <br><br><img src="https://habrastorage.org/webt/ob/9m/jt/ob9mjtfiyqpvxfjpjc1tp48ujho.png">  <font color="#777777">* Ne prend pas en charge les propri√©t√©s ACID sur plusieurs fragments.</font> <br><br>  FoundationDB a un avantage unique: le redistribution automatique.  Le SGBD lui-m√™me assure un chargement uniforme des machines dans le cluster: lorsqu'un serveur est plein, il redistribue les donn√©es aux serveurs voisins en arri√®re-plan.  Dans le m√™me temps, la garantie du niveau de s√©rialisation pour toutes les transactions est pr√©serv√©e, et le seul effet perceptible pour les clients est une l√©g√®re augmentation de la latence des r√©ponses.  La base de donn√©es garantit que la quantit√© de donn√©es sur les serveurs de cluster les plus et les moins charg√©s ne diff√®re pas de plus de 5%. <br><br><h2>  L'architecture </h2><br>  Logiquement, un cluster FoundationDB est un ensemble de processus du m√™me type sur diff√©rentes machines physiques.  Les processus n'ont pas leurs propres fichiers de configuration, ils sont donc interchangeables.  Plusieurs processus fixes ont un r√¥le d√©di√© - coordinateurs, et chaque processus de cluster au d√©marrage conna√Æt leurs adresses.  Il est important que les plantages des coordinateurs soient aussi ind√©pendants que possible, il est donc pr√©f√©rable de les placer sur diff√©rentes machines physiques ou m√™me dans diff√©rents centres de donn√©es. <br><br><img src="https://habrastorage.org/webt/ai/sx/qv/aisxqvwfakb618b27cl_vyjnc5a.png"><br><br>  Les coordinateurs s'accordent entre eux via l'algorithme de consensus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Paxos</a> .  Ils s√©lectionnent le processus Cluster Controller, qui attribue ensuite des r√¥les au reste des processus de cluster.  Le Cluster Controller informe en permanence tous les coordinateurs qu'il est vivant.  Si la plupart des coordinateurs pensent qu'il est mort, ils en choisissent simplement un nouveau.  Ni le Cluster Controller ni les Coordinators ne sont impliqu√©s dans le traitement des transactions; leur t√¢che principale est d'√©liminer la situation de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">split brain</a> . <br><br>  Lorsqu'un client souhaite se connecter √† la base de donn√©es, il contacte imm√©diatement tous les coordinateurs pour l'adresse du contr√¥leur de cluster actuel.  Si la plupart des r√©ponses correspondent, il re√ßoit du contr√¥leur de cluster la configuration actuelle compl√®te du cluster (s'il ne correspond pas, il appelle √† nouveau les coordinateurs). <br><br><img src="https://habrastorage.org/webt/ig/g6/qq/igg6qqffqlxbbrd-cpchddyktbu.png"><br><br>  Le Cluster Controller conna√Æt le nombre total de processus disponibles et r√©partit les r√¥les: ces 5 seront Proxy, ces 2 seront Resolver, celui-ci sera Master.  Et si l'un d'eux meurt, il trouvera imm√©diatement un rempla√ßant pour lui, attribuant le r√¥le n√©cessaire √† un processus libre arbitraire.  Tout cela se passe en arri√®re-plan, invisible pour le programmeur d'application. <br><br>  Le processus ma√Ætre est responsable du num√©ro de la version actuelle de l'ensemble de donn√©es (il augmente chaque fois qu'il est √©crit dans la base de donn√©es), ainsi que de la distribution de nombreuses cl√©s entre les serveurs de stockage et de la limitation du d√©bit (performances artificiellement inf√©rieures sous de lourdes charges: si le cluster sait que le client fera beaucoup de petites demandes, il attendra, les groupera et r√©pondra √† l'ensemble du pack en une seule fois). <br><br>  La journalisation des transactions et le stockage sont deux sous-syst√®mes de stockage ind√©pendants.  Le premier est un stockage temporaire pour √©crire rapidement des donn√©es sur le disque dans l'ordre de r√©ception, le second est un stockage permanent, o√π les donn√©es sur le disque sont tri√©es par ordre croissant de cl√©s.  √Ä chaque validation de transaction, au moins trois processus tLog doivent enregistrer les donn√©es avant que le cluster ne signale le succ√®s au client.  En parall√®le, les donn√©es en arri√®re-plan passent des serveurs tLog aux serveurs de stockage (stockage sur lequel est √©galement redondant). <br><br><h2>  Traitement des demandes </h2><br>  Toutes les demandes des clients traitent les processus proxy.  En ouvrant une transaction, le client acc√®de √† n'importe quel proxy, il interroge tous les autres proxy et renvoie le num√©ro de version actuel des donn√©es du cluster.  Toutes les lectures suivantes ont lieu √† ce num√©ro de version.  Si un autre client a not√© les donn√©es apr√®s avoir ouvert la transaction, je ne verrai tout simplement pas ses modifications. <br><br>  L'enregistrement d'une transaction est un peu plus compliqu√© car vous devez r√©soudre des conflits.  Cela inclut le processus Resolver, qui stocke en m√©moire toutes les cl√©s modifi√©es pendant une certaine p√©riode de temps.  Lorsque le client termine la transaction de validation, le r√©solveur v√©rifie si les donn√©es qu'il lisait sont obsol√®tes.  (C'est-√†-dire si la transaction qui a √©t√© ouverte plus tard que la mienne a √©t√© termin√©e et a chang√© les cl√©s que j'ai lues.) Si cela se produit, la transaction est annul√©e et la biblioth√®que cliente elle-m√™me (!) Fait une deuxi√®me tentative de validation.  La seule chose √† laquelle le d√©veloppeur doit penser est que les transactions sont idempotentes, c'est-√†-dire qu'une utilisation r√©p√©t√©e devrait donner un r√©sultat identique.  Une fa√ßon d'y parvenir consiste √† enregistrer une valeur unique dans la transaction et, au d√©but de la transaction, √† v√©rifier sa pr√©sence dans la base de donn√©es. <br><br><img src="https://habrastorage.org/webt/h6/sl/tn/h6sltnc7mmauiguiymix7msytv0.png"><br><br>  Comme dans tout syst√®me client-serveur, il existe des situations o√π la transaction s'est termin√©e avec succ√®s, mais le client n'a pas re√ßu de confirmation en raison d'une d√©connexion.  La biblioth√®que cliente les traite comme n'importe quelle autre erreur - elle r√©essaye simplement.  Cela pourrait potentiellement conduire √† la r√©ex√©cution de l'ensemble de la transaction.  Cependant, si la transaction est idempotente, cela ne pose aucun probl√®me - cela n'affectera pas le r√©sultat final. <br><br><h2>  Mise √† l'√©chelle </h2><br>  Il peut y avoir des milliers de serveurs dans un sous-syst√®me de stockage.  Lequel d'entre eux un client doit-il contacter lorsqu'il a besoin de donn√©es sur une certaine cl√©?  Depuis Cluster Controller, le client conna√Æt la configuration compl√®te de l'ensemble du cluster et il inclut des plages de cl√©s sur chaque serveur de stockage.  Par cons√©quent, il acc√®de simplement aux serveurs de stockage souhait√©s directement sans aucune demande interm√©diaire. <br><br>  Si le serveur de stockage souhait√© n'est pas disponible, la biblioth√®que cliente prend une nouvelle configuration √† partir du Cluster Controller.  Si, √† la suite d'une panne de serveur, le cluster comprend que la redondance est insuffisante, il commence imm√©diatement √† collecter un nouveau n≈ìud √† partir de morceaux d'un autre stockage. <br><br>  Supposons que vous enregistrez un gigaoctet de donn√©es dans une transaction.  Comment pouvez-vous r√©pondre rapidement?  En aucun cas, FoundationDB n'a simplement limit√© la taille d'une transaction √† 10 m√©gaoctets.  De plus, il s'agit d'une restriction sur toutes les donn√©es concern√©es par la transaction - lues ou √©crites.  Chaque entr√©e dans la base de donn√©es est √©galement limit√©e - la cl√© ne peut pas d√©passer 10 kilo-octets, la valeur est de 100 kilo-octets.  (Dans le m√™me temps, pour des performances optimales, les d√©veloppeurs recommandent des cl√©s d'une longueur de 32 octets et des valeurs d'une longueur de 10 kilo-octets.) <br><br>  Toute transaction peut potentiellement devenir une source de conflit, puis elle devra √™tre annul√©e.  Par cons√©quent, pour des raisons de vitesse, jusqu'√† ce que la commande commit arrive, il est logique de conserver les modifications actuelles dans la RAM et non sur le disque.  Supposons que vous √©crivez des donn√©es dans une base de donn√©es avec une charge de 1 Go / seconde.  Ensuite, dans un cas extr√™me, votre cluster allouera 3 Go de RAM chaque seconde (nous √©crivons des transactions sur 3 machines).  Comment limiter une telle croissance en avalanche de la m√©moire utilis√©e?  Il est tr√®s simple de limiter le temps de transaction maximum.  Dans FoundationDB, une transaction ne peut pas durer plus de 5 secondes.  Si le client tente d'acc√©der √† la base de donn√©es 5 secondes apr√®s l'ouverture de la transaction, le cluster ignorera toutes ses commandes jusqu'√† ce qu'il en ouvre une nouvelle. <br><br><h2>  Indices </h2><br>  Supposons que vous gardiez une liste de personnes, chaque personne a un identifiant unique, nous l'utilisons comme cl√©, et dans la valeur, nous √©crivons tous les autres attributs - nom, sexe, √¢ge, etc. <br><table><tbody><tr><td>  Cl√© </td><td>  Valeur </td></tr><tr><td>  12345 </td><td>  (Ivanov Ivan Ivanovich, M, 35 ans) </td></tr></tbody></table><br>  Comment obtenir une liste de toutes les personnes de 30 ans sans recherche exhaustive?  Pour cela, un index est g√©n√©ralement cr√©√© dans la base de donn√©es.  Un index est une autre vue de donn√©es con√ßue pour rechercher rapidement des attributs suppl√©mentaires.  Nous pouvons simplement ajouter des entr√©es du formulaire: <br><table><tbody><tr><td>  Cl√© </td><td>  Valeur </td></tr><tr><td>  (35, 12345) </td><td>  '' </td></tr></tbody></table><br>  Maintenant, pour obtenir la liste dont vous avez besoin, il vous suffit de rechercher la plage de touches (30, *).  √âtant donn√© que FoundationDB stocke les donn√©es tri√©es par cl√©, une telle requ√™te s'ex√©cutera tr√®s rapidement.  Bien s√ªr, l'index prend de l'espace disque suppl√©mentaire, mais tr√®s peu.  Veuillez noter que tous les attributs ne sont pas dupliqu√©s, mais uniquement l'√¢ge et l'identifiant. <br><br>  Il est important que les op√©rations d'ajout de l'enregistrement lui-m√™me et de son index soient effectu√©es en une seule transaction. <br><br><h2>  Fiabilit√© </h2><br>  FoundationDB est √©crit en C ++.  Les auteurs ont commenc√© √† y travailler en 2009, la premi√®re version a √©t√© publi√©e en 2013 et en mars 2015, ils ont √©t√© achet√©s par Apple.  Trois ans plus tard, Apple a ouvert le code source de mani√®re inattendue.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La rumeur veut</a> qu'Apple l'utilise, entre autres, pour stocker les donn√©es du service iCloud. <br><br>  Les d√©veloppeurs exp√©riment√©s ne font g√©n√©ralement pas imm√©diatement confiance aux nouvelles solutions.  Cela peut prendre des ann√©es avant que la technologie ne s'√©tablisse de mani√®re fiable et qu'elle commence √† √™tre massivement utilis√©e en production.  Pour r√©duire ce temps, les auteurs ont fait une extension int√©ressante du langage C ++: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Flow</a> .  Il vous permet d'√©muler gracieusement le travail avec des composants externes non fiables avec la possibilit√© d'une r√©p√©tition pr√©visible compl√®te de l'ex√©cution du programme.  Chaque appel vers un r√©seau ou un disque est encapsul√© dans un wrapper (Acteur), et chaque Acteur a plusieurs impl√©mentations.  L'impl√©mentation standard √©crit les donn√©es sur le disque ou sur le r√©seau, comme pr√©vu.  Et l'autre √©crit sur le disque 999 fois sur 1000 et perd 1 fois sur 1000.  Une impl√©mentation r√©seau alternative peut, par exemple, permuter des octets dans des paquets r√©seau.  Il y a m√™me des acteurs qui imitent le travail d'un administrateur syst√®me imprudent.  Cela peut supprimer le dossier de donn√©es ou √©changer deux dossiers.  Les d√©veloppeurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pilotent des milliers de simulations</a> , en rempla√ßant diff√©rents acteurs et en utilisant Flow atteignent une reproductibilit√© √† 100%: si un test √©choue, ils peuvent red√©marrer la simulation et obtenir un plantage au m√™me endroit.  En particulier, pour √©liminer l'incertitude introduite par les threads de commutation du planificateur du syst√®me d'exploitation, chaque processus FoundationDB est strictement monothread. <br><br>  Lorsqu'un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chercheur</a> qui a d√©couvert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des sc√©narios de perte de donn√©es dans presque toutes les solutions NoSQL populaires a</a> √©t√© invit√© √† tester FoundationDB, il a refus√©, notant qu'il ne voyait pas le point, car les auteurs ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fait un travail g√©ant</a> et les ont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">test√©s</a> beaucoup plus profond√©ment et plus en profondeur que le sien. <br><br>  Il est habituel de penser que les √©checs de cluster sont al√©atoires, mais les devops exp√©riment√©s savent que c'est loin d'√™tre le cas.  Si vous disposez de 10 000 disques du m√™me fabricant et du m√™me nombre d'autres, le taux d'√©chec sera diff√©rent.  Dans FoundationDB, une configuration dite orient√©e machine est possible dans laquelle vous pouvez indiquer au cluster quelles machines se trouvent dans le m√™me centre de donn√©es et quels processus se trouvent sur la m√™me machine.  La base de donn√©es en tiendra compte lors de la r√©partition de la charge entre les machines.  Et les machines d'un cluster ont g√©n√©ralement des caract√©ristiques diff√©rentes.  FoundationDB prend √©galement cela en compte, examine la longueur des files d'attente de demandes et redistribue la charge de mani√®re √©quilibr√©e: les machines les plus faibles re√ßoivent moins de demandes. <br><br>  Ainsi, FoundationDB fournit des transactions ACID et le plus haut niveau d'isolation, s√©rialisable, sur un cluster de milliers de machines.  Avec une flexibilit√© incroyable et des performances √©lev√©es, cela ressemble √† de la magie.  Mais vous devez tout payer, il y a donc des limites technologiques. <br><br><h2>  Limitations </h2><br>  En plus des limites d√©j√† mentionn√©es sur la taille et la dur√©e de la transaction, il est important de noter les caract√©ristiques suivantes: <br><br><ul><li>  Le langage de requ√™te n'est pas SQL, c'est-√†-dire que les d√©veloppeurs ayant une exp√©rience SQL devront r√©apprendre. <br></li><li>  La biblioth√®que cliente ne prend en charge que 5 langages de haut niveau (Phyton, Ruby, Java, Golang et C).  Il n'y a pas encore de client officiel pour C #.  Puisqu'il n'y a pas d'API REST, la seule fa√ßon de prendre en charge une autre langue est d'√©crire un wrapper dessus au-dessus de la biblioth√®que C standard. <br></li><li>  Il n'y a pas de m√©canismes de partage, toute cette logique doit √™tre fournie par votre application. <br></li><li>  Le format de stockage des donn√©es n'est pas document√© (bien qu'il ne soit g√©n√©ralement pas document√© non plus dans les bases de donn√©es commerciales).  C'est un risque, car si soudainement le cluster ne s'assemble pas, il n'est pas imm√©diatement clair quoi faire et devra fouiller dans les fichiers source. <br></li><li>  Un mod√®le de programmation strictement asynchrone peut sembler compliqu√© aux d√©veloppeurs d√©butants. <br></li><li>  Vous devez constamment penser √† l'idempotence des transactions. <br></li><li>  Si vous devez diviser de longues transactions en petites transactions, vous devez vous-m√™me vous soucier de l'int√©grit√© au niveau mondial. <br></li></ul><br>  Traduit de l'anglais, ¬´Foundation¬ª signifie ¬´Foundation¬ª et les auteurs de ce SGBD voient son r√¥le de cette fa√ßon: fournir un haut niveau de fiabilit√© au niveau des enregistrements simples, et toute autre base de donn√©es peut √™tre impl√©ment√©e en tant que compl√©ment √† la fonctionnalit√© de base.  Ainsi, en plus de FoundationDB, vous pouvez potentiellement cr√©er d'autres couches - documents, graphiques, etc.  La question reste de savoir comment ces couches √©volueront sans perte de performances.  Par exemple, les auteurs de CockroachDB ont d√©j√† emprunt√© cette voie - en cr√©ant une couche SQL au-dessus de RocksDB (magasin de valeurs de cl√©s locales) et ils ont rencontr√© des probl√®mes de performances inh√©rents aux jointures relationnelles. <br><br>  √Ä ce jour, Apple a d√©velopp√© et publi√© 2 couches au-dessus de FoundationDB: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Document Layer</a> (prend en charge MongoDB API) et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Record Layer</a> (stocke les enregistrements sous forme d'ensembles de champs au format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Protocol Buffers</a> , prend en charge les index, n'est disponible qu'en Java).  Il est agr√©able et agr√©ablement surprenant que la soci√©t√© historiquement ferm√©e d'Apple suive aujourd'hui les traces de Google et de Microsoft et publie le code source des technologies utilis√©es √† l'int√©rieur. <br><br><h2>  Perspectives </h2><br>  Il existe un tel conflit existentiel dans le d√©veloppement de logiciels: l'entreprise veut constamment des changements, des am√©liorations par rapport au produit.  Mais en m√™me temps, il veut un logiciel fiable.  Et ces deux exigences se contredisent, car lorsque le logiciel change, des bugs apparaissent et l'entreprise en souffre.  Par cons√©quent, si dans votre produit vous pouvez compter sur une technologie fiable et √©prouv√©e et √©crire moins de code vous-m√™me, cela vaut toujours la peine.  En ce sens, malgr√© certaines restrictions, il est cool de ne pas pouvoir sculpter des b√©quilles dans diff√©rentes bases de donn√©es NoSQL, mais d'utiliser une solution √©prouv√©e en production avec des propri√©t√©s ACID. <br><br>  Il y a un an, nous √©tions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">optimistes</a> quant √† une autre technologie - CockroachDB, mais elle ne r√©pondait pas √† nos attentes de performance.  Depuis lors, nous avons perdu notre app√©tit pour l'id√©e d'une couche SQL sur un magasin de valeurs-cl√©s distribu√©, et n'avons donc pas examin√© attentivement, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TiDB</a> .  Nous pr√©voyons d'essayer soigneusement FoundationDB comme base de donn√©es secondaire pour les plus grands ensembles de donn√©es de notre projet.  Si vous avez d√©j√† de l'exp√©rience dans l'utilisation r√©elle de FoundationDB ou TiDB en production, nous serons heureux d'entendre votre avis dans les commentaires. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441270/">https://habr.com/ru/post/fr441270/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441260/index.html">Comment les graphiques de r√©seaux neuronaux ont aid√©</a></li>
<li><a href="../fr441262/index.html">Les t√¢ches simples et longues √©liminent mieux les candidats que les t√¢ches courtes et complexes</a></li>
<li><a href="../fr441264/index.html">Guide de l'utilisateur Kibana. Visualisation. 2e partie</a></li>
<li><a href="../fr441266/index.html">Fonctionnement du framework tiOPF pour delphi / lazarus. Mod√®le de visiteur</a></li>
<li><a href="../fr441268/index.html">Ceedling + Eclipse ou tests unitaires pour microcontr√¥leurs</a></li>
<li><a href="../fr441274/index.html">Comment devenir un testeur - les connaissances et les comp√©tences n√©cessaires</a></li>
<li><a href="../fr441278/index.html">Comment cr√©er une belle palette de couleurs</a></li>
<li><a href="../fr441280/index.html">Configuration de GAL dans Zimbra Collaboration Suite</a></li>
<li><a href="../fr441282/index.html">Grande interview avec le cr√©ateur de Jenkins, Kohsuke Kawaguchi</a></li>
<li><a href="../fr441284/index.html">Chargement de donn√©es en masse ou Comment nourrir un village chinois</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>