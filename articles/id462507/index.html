<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🚀 🈷️ ✊🏼 Saat pengiriman surat: melawan hilangnya pemberitahuan push di iOS 🛂 👩🏼‍🏭 🏏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di pihak pengguna, klien email adalah aplikasi sederhana. Pengembang Yandex.Mail bahkan bercanda bahwa hanya ada tiga layar dalam aplikasi: daftar sur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Saat pengiriman surat: melawan hilangnya pemberitahuan push di iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462507/">  Di pihak pengguna, klien email adalah aplikasi sederhana.  Pengembang Yandex.Mail bahkan bercanda bahwa hanya ada tiga layar dalam aplikasi: daftar surat;  mengirim surat;  tentang layar. <br><br>  Tetapi banyak hal menarik terjadi di bawah tenda.  Seperti banyak aplikasi seluler, Mail menggunakan pemberitahuan push untuk berinteraksi dengan pengguna.  Seperti banyak aplikasi iOS, Mail kehilangan beberapa pemberitahuan karena sifat dari Layanan Pemberitahuan Dorong Apple. <br><br>  <strong>Asya Sviridenko</strong> , kepala kelompok iOS Yandex.Mail, akan membuktikan bahwa meskipun dengan keterbatasan sistem, hilangnya pemberitahuan push dapat dan harus diperjuangkan jika mereka penting untuk aplikasi Anda.  Ini berlaku untuk Mail, karena pemberitahuan push surat baru adalah tujuan pengguna menginstal aplikasi.  Jika, untuk aplikasi Anda, pengiriman pemberitahuan push tidak terlalu penting, masih menarik untuk mencari tahu sepeda mana yang dipasangi Yandex.Mail seluler. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SVCMbPIuy8w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ini tentang notifikasi jarak jauh, yaitu notifikasi yang datang dari server melalui APN (Apple Push Notification Service).  Kami tidak akan menyentuh notifikasi lokal dan membicarakan: <br><br><ul><li>  Seperti apa tampilan API untuk bekerja dengan pemberitahuan push.  Pertimbangkan skema pengiriman pemberitahuan push dan di mana kerugian dapat terjadi dalam skema ini. </li><li>  Bagaimana Anda memutuskan untuk menangani kerugian di Yandex.Mail - antrian pemberitahuan push. </li><li>  Bagaimana cara log dan kesulitan apa yang bisa ditemui. </li></ul><a name="habracut"></a><br><h2>  Apa yang kita miliki dan di mana kita kehilangan </h2><br>  Sekarang API untuk bekerja dengan pemberitahuan push adalah hal yang cukup kuat yang memungkinkan Anda melakukan banyak hal menarik.  Tapi itu tidak selalu terjadi. <br><br><img src="https://habrastorage.org/webt/p6/ln/n1/p6lnn1nbbopnz4xr9k2xiuf1dre.jpeg"><br><br>  Sebelumnya, pemberitahuan push tampak persis seperti ini - itu adalah dasbor biru yang muncul di layar, diblokir bekerja dengan aplikasi saat ini, tidak mengizinkan apa pun dilakukan, dan kemudian menghilang selamanya, dan tidak ada lagi pengingat tentang hal itu. <br><br>  Sudah cukup waktu sejak itu. <br><br><img src="https://habrastorage.org/webt/nq/kr/9j/nqkr9jbh2v4nwacrbhksoa1tpy0.jpeg"><br><br>  Bagi kami, sebagai pengembang, <strong>semuanya dimulai di iOS 3</strong> ketika pemberitahuan push tersedia untuk perpustakaan pihak ketiga. <br><br>  <strong>Pusat Pemberitahuan muncul di iOS 5</strong> , dan pemberitahuan push berhenti ke mana-mana, sekarang mereka tetap berada di Pusat Pemberitahuan, tempat mereka dapat dilihat lagi. <br><br>  <strong>IOS 6 memperkenalkan Do Not Disturb</strong> .  Pengguna memiliki kesempatan untuk mengatur periode waktu di mana ia tidak ingin menerima pemberitahuan. <br><br>  Perubahan ini terutama menyangkut bagaimana pengguna dapat bekerja dengan pemberitahuan push, bagaimana mereka bisa membuat hidupnya lebih nyaman, dan bukan bagaimana pengembang dapat memengaruhi pemberitahuan. <br><br>  Untuk pengembang, tonggak penting adalah <strong>iOS 8 dan munculnya Tindakan Pemberitahuan</strong> , yang memungkinkan untuk melakukan tindakan khusus untuk aplikasi tertentu dengan pemberitahuan push. <br><br>  <strong>IOS 10 memperkenalkan Perpanjangan Layanan Pemberitahuan dan Perpanjangan Konten Pemberitahuan</strong> .  Yang pertama memungkinkan Anda untuk memodifikasi pemberitahuan push sebelum ditampilkan kepada pengguna.  Yang kedua adalah menampilkan beberapa UI dengan pemberitahuan push pada Push notification, di mana, misalnya, Anda dapat menampilkan informasi yang lebih detail.  Di iOS 10, UI ini tidak dapat diklik - Anda dapat menonton, Anda tidak dapat menyentuhnya. <br><br>  <strong>IOS 11 memperkenalkan Pengaturan Privasi Pemberitahuan</strong> .  Sekarang pengguna dapat masuk ke pengaturan dan menunjukkan apakah ia ingin konten pemberitahuan yang masuk ditampilkan.  Ini adalah langkah besar menuju keamanan.  Hanya perlu 8 versi iOS untuk memahami bahwa tidak semua pengguna ingin informasi pribadi tiba-tiba muncul di iPhone yang tergeletak di atas meja. <br><br>  <strong>Di iOS 12, menjadi mungkin untuk mengelompokkan pemberitahuan push</strong> berdasarkan thread-id, dan UI yang kami terima di iOS 10 menggunakan Pemberitahuan Konten Ekstensi telah menjadi dapat diklik.  Sekarang Anda dapat menambahkan tombol dan kontrol gerakan di sana - semua yang membantu pengguna berinteraksi dengan UI. <br><br><h2>  Pemberitahuan push hari ini </h2><br>  Seperti yang dapat Anda lihat, pemberitahuan push telah lama, dan hari ini dengan bantuan mereka Anda benar-benar dapat melakukan banyak hal. <br><br><h3>  Pesan teks dan lokalisasi </h3><br>  Seperti sebelumnya, kami dapat mengirim pesan teks dalam pemberitahuan push, tetapi sekarang Anda juga dapat menentukan kunci untuk pelokalan. <br><br><pre><code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"alert"</span></span> : { <span class="hljs-string"><span class="hljs-string">"title"</span></span> : <span class="hljs-string"><span class="hljs-string">"New Mail"</span></span>, <span class="hljs-string"><span class="hljs-string">"subtitle-loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"alert_subtitle_localization_key"</span></span>, <span class="hljs-string"><span class="hljs-string">"loc-key"</span></span> : <span class="hljs-string"><span class="hljs-string">"alert_body_localization_key"</span></span>, } }</code> </pre> <br>  Jika Anda menentukan <code>subtitle-loc-key</code> dan <code>loc-key</code> dalam notifikasi payload, maka ketika notifikasi push tiba di perangkat, nilai-nilai yang diperlukan akan ditemukan dalam file Localizable.string aplikasi dan pengguna akan melihat pesan yang dilokalkan. <br><br><h3>  Suara dan peringatan kritis </h3><br>  Seperti sebelumnya, Anda dapat menambahkan suara ke notifikasi payload. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"sound"</span></span> : { <span class="hljs-string"><span class="hljs-string">"critical"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span> : <span class="hljs-string"><span class="hljs-string">"bingbong.aiff"</span></span>, <span class="hljs-string"><span class="hljs-string">"volume"</span></span> : <span class="hljs-number"><span class="hljs-number">1.0</span></span>, } }</code> </pre> <br>  IOS 12 memiliki peringatan kritis.  Ini adalah suara yang akan diputar bahkan jika pengguna dalam mode Do Not Disturb. <br><br>  Biasanya, pengguna tidak perlu, misalnya, aplikasi dengan berlangganan majalah di malam hari untuk melaporkan bahwa nomor baru telah dirilis.  Karena itu, Apple membatasi aplikasi yang dapat menggunakan peringatan kritis.  Jika aplikasi Anda bekerja dengan kesehatan, keselamatan, atau Anda berpikir bahwa peringatan kritis adalah sesuatu yang benar-benar dapat membantu pengguna berinteraksi dengan aplikasi Anda, tulis ke Apple.  Mungkin mereka akan memungkinkan Anda untuk menggunakan fungsi ini. <br><br><h3>  Notifikasi diam </h3><br>  Pengguna tidak melihat pemberitahuan diam.  Mereka datang langsung ke aplikasi, membangunkannya dan memungkinkan Anda untuk melakukan beberapa tindakan untuk memperbarui aplikasi: mengirim permintaan ke server, meminta data di latar belakang, memperbarui data dari database, memperbarui UI sehingga ketika pengguna memasukkan aplikasi, ia melihat data yang diperbarui. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"content-available"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">//   alert, sound  badge   payload }</span></span></code> </pre> <br>  Agar pemberitahuan push menjadi senyap, Anda harus menentukan di payload: <code>"content-available" : 1</code> .  Dan jangan tentukan tanda peringatan, suara dan kunci lencana dalam payload - mereka sama sekali tidak berguna untuk pemberitahuan push yang tidak akan ditampilkan kepada pengguna. <br><br><h3>  Pengelompokan Pemberitahuan </h3><br>  Untuk mengelompokkan pesan, Anda harus menentukan “thread-id” dalam payload.  Ini dapat memiliki beberapa nilai dalam aplikasi yang sama, jika Anda ingin mengelompokkan dalam berbagai cara: berdasarkan akun, oleh penerima, berdasarkan topik. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"thread-id"</span></span> : <span class="hljs-string"><span class="hljs-string">"any_thread_identifier"</span></span> }</code> </pre> <br>  Ini sangat mudah, karena sekarang pemberitahuan push tidak mengambil semua ruang di layar yang terkunci, tetapi dikelompokkan bersama.  Jika Anda belum menggunakan fungsi ini, sekarang saatnya untuk memulai. <br><br><h3>  Ubah pemberitahuan sebelum menampilkannya </h3><br>  Pemberitahuan push dapat diubah sebelum ditampilkan.  Untuk melakukan ini, Anda perlu menambahkan Ekstensi Konten Pemberitahuan ke aplikasi dan mengganti metode <code>didReceive</code> .  Dalam metode ini, Anda bisa mendapatkan konten notifikasi dan memodifikasinya. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"mutable-content"</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: UNNotificationRequest, withContentHandler contentHandler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(UNNotificationContent)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mutableContent = request.content.mutableCopy() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UNMutableNotificationContent</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentHandler(request.content); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } mutableContent.subtitle = <span class="hljs-string"><span class="hljs-string">"Got it!"</span></span> contentHandler(mutableContent) }</code> </pre> <br>  Misalnya, Anda dapat mengirim tautan ke konten media dalam pemberitahuan, mengunduh konten dalam Ekstensi, dan melampirkan unduhan ke pemberitahuan.  Setelah itu, panggil penyelesaian dengan konteks baru, dan tunjukkan kepada pengguna pemberitahuan push yang diperpanjang.  Anda dapat mengubah judul, subtitle, dll. <br><br>  Kasus menarik lainnya adalah Anda dapat mengirim pemberitahuan push dengan konteks terenkripsi, jika Anda ingin data dilindungi tambahan, dan Apple tidak melihatnya.  Di Ekstensi Konten Pemberitahuan, Anda dapat mendekripsi dan menunjukkan data yang sudah didekripsi kepada pengguna. <br><br><h3>  Konten Pemberitahuan Tersembunyi </h3><br>  Di iOS 11, menjadi mungkin untuk menyembunyikan konten pemberitahuan push, dan kami, sebagai pengembang, tidak dapat memengaruhi ini dengan cara apa pun.  Jika pengguna mencentang "Sembunyikan konten pemberitahuan", satu atau lain cara itu akan disembunyikan.  Yang bisa kita lakukan adalah melalui UNNotificationCategory untuk menentukan placeholder yang akan ditampilkan alih-alih konten (secara default ini adalah notifikasi), dan untuk mengatur apakah akan menampilkan judul atau subtitle. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commentCategory = <span class="hljs-type"><span class="hljs-type">UNNotificationCategory</span></span>(identifier: <span class="hljs-string"><span class="hljs-string">"comment-category"</span></span>, actions: [], intentIdentifiers: [], hiddenPreviewsBodyPlaceholder: <span class="hljs-type"><span class="hljs-type">NSString</span></span>.localizedUserNotificationString(forKey:<span class="hljs-string"><span class="hljs-string">"COMMENT_KEY"</span></span>,arguments: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>), options: [.hiddenPreviewsShowTitle])</code> </pre> <br><h3>  Langkah-langkah pemberitahuan tanpa meluncurkan aplikasi </h3><br>  Untuk melakukan tindakan pemberitahuan push tanpa meluncurkan aplikasi itu sendiri, Anda perlu membuat kategori dan menambahkan tindakan ke sana.  Pengidentifikasi kategori diteruskan ke bidang kategori pemberitahuan muatan.  Anda dapat menghubungkan berbagai tindakan ke berbagai jenis notifikasi. <br><br><pre> <code class="swift hljs"><span class="hljs-string"><span class="hljs-string">"aps"</span></span> : { <span class="hljs-string"><span class="hljs-string">"category"</span></span> : <span class="hljs-string"><span class="hljs-string">"message"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> action = <span class="hljs-type"><span class="hljs-type">UNNotificationAction</span></span>(identifier:<span class="hljs-string"><span class="hljs-string">"reply"</span></span>, title:<span class="hljs-string"><span class="hljs-string">"Reply"</span></span>, options:[]) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> category = <span class="hljs-type"><span class="hljs-type">UNNotificationCategory</span></span>(identifier: <span class="hljs-string"><span class="hljs-string">"message"</span></span>, actions: [action], minimalActions: [action], intentIdentifiers: [], options: []) <span class="hljs-type"><span class="hljs-type">UNUserNotificationCenter</span></span>.current().setNotificationCategories([category])</code> </pre> <br><h3>  Notifikasi kaya </h3><br>  Dalam ekstensi ini, Anda dapat memproses tindakan tambahan yang Anda tambahkan ke pemberitahuan push dan menampilkan UI khusus. <br><br>  Untuk melakukan ini, Anda perlu menambahkan Ekstensi Konten Pemberitahuan ke aplikasi, menentukan kelas di dalamnya yang mewarisi dari UNNotificationContentExtension, dan kemudian bekerja dengannya seperti dengan UIViewController biasa. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotificationViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UNNotificationContentExtension</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userLabel: <span class="hljs-type"><span class="hljs-type">UILabel?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> notification: UNNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> content = notification.request.content <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.title = content.title <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userInfo = content.userInfo <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.userLabel?.text = userInfo[<span class="hljs-string"><span class="hljs-string">"video-user"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">String</span></span> } }</code> </pre> <br>  Jika Anda memproses tindakan kustom, penting untuk diingat bahwa tindakan ini layak memperbarui UI yang Anda tampilkan kepada pengguna.  Tidak perlu mencoba menerapkan logika bisnis dalam ekstensi ini.  Kirim permintaan ke server melalui tindakan dengan pemberitahuan push di aplikasi utama, dan tidak di sini.  Tempat ini hanya untuk UI. <br><br><h2>  Skema Pengiriman Pemberitahuan Push </h2><br>  Lihat seberapa banyak yang dapat Anda lakukan dengan pemberitahuan push di iOS.  Dari versi ke versi, kami memiliki lebih banyak fungsi baru, tetapi skema pengiriman pemberitahuan push sekarang persis sama seperti di iOS 3. <br><br><img src="https://habrastorage.org/webt/gt/pb/dd/gtpbdd_4eu403euuueyxscvk8bw.jpeg"><br><br>  Orang akan berpikir bahwa skema pengiriman pemberitahuan push baik-baik saja dari awal, tetapi tidak. <br><br>  Ada tiga node utama dalam skema pengiriman pemberitahuan push: <br><br><ul><li>  penyedia yang menghasilkan pemberitahuan push payload; </li><li>  APNs - Layanan Pemberitahuan Push Apple, yang memberikan pemberitahuan; </li><li>  perangkat iOS dan aplikasi Anda. </li></ul><br>  Saya akan melewatkan bagian tentang cara mendaftar, menerima token, ke mana harus mengirimkannya.  Misalkan kita memiliki semua ini.  Apa yang terjadi selanjutnya? <br><br><ul><li>  Penyedia menghasilkan payload dan mengirimkannya ke APN. </li><li>  APN mengirimkannya ke perangkat. </li><li>  Pengguna melihat pesan push di perangkatnya. </li></ul><br>  Mail dan banyak aplikasi lain menggunakan skema pengiriman pemberitahuan push tingkat lanjut.  Ekstensi Layanan Pemberitahuan ditambahkan, yang menerima pemberitahuan push dengan <code>"mutable-content" : 1</code> .  Penyedia dibagi menjadi server yang berurusan dengan logika backend aplikasi, dan penyedia itu sendiri, yang menghasilkan muatan dan berurusan dengan langganan. <br><br>  Di Yandex, penyedia yang membentuk payload disebut XIVA.  XIVA adalah basis data berlangganan.  Mail menggunakan XIVA untuk bekerja dengan pemberitahuan push sebagai perpustakaan pihak ketiga. <br><br>  Di Mail, pekerjaan dengan langganan diatur secara non-sepele.  Kami tidak hanya menandatangani aplikasi untuk notifikasi, kami memiliki multi-akun.  Kami dapat menandatangani akun yang berbeda, atau dalam satu akun memilih folder mana pengguna ingin menerima notifikasi dan mana yang tidak mereka inginkan.  XIVA menangani semua ini.  Beberapa layanan Yandex lainnya juga bekerja melalui XIVA: semua informasi tentang aplikasi, pemberitahuan, langganan, token disimpan dalam XIVA. <br><br><h3>  Dimana kerugiannya? </h3><br>  Ada empat panah dalam skema pengiriman pemberitahuan push, kerugian dapat terjadi pada tiga transisi ini. <br><br>  <strong>Antara server dan XIVA,</strong> kerugian dapat terjadi dalam kasus berikut.  Pengguna menerima surat, server tahu tentang hal itu, menghasilkan pemberitahuan dan mengirimkannya ke XIVA.  Tetapi XIVA dapat kehilangan informasi ini, misalnya, jika pengguna dalam aplikasi memilih "Berlangganan" ke folder tertentu saat ia offline.  Kemudian XIVA tidak akan menerima informasi tentang berlangganan ke folder, dan ketika payload tiba, itu hanya akan menghapusnya dan pengguna tidak akan melihat notifikasi. <br><br>  <strong>Antara XIVA dan APN</strong> , kehilangan jaringan dapat terjadi.  Kami hampir tidak dapat mempengaruhi jaringan, jadi kami tidak akan membahas hal ini. <br><br>  <strong>Antara APNs dan Extension, atau APNS dan iOS</strong> jika Anda tidak menggunakan Extension.  Ini adalah jenis kehilangan yang paling umum.  Kerugian tersebut terjadi karena APN tidak menyimpan lebih dari satu dorongan per aplikasi pada perangkat.  Jika, saat pengguna offline, ia menerima beberapa notifikasi, ketika ia online, ia hanya akan melihat pesan terakhir. <br><br>  Ini adalah kerugian yang sama yang tidak memungkinkan kami untuk menjamin pengiriman dan bergantung pada pemberitahuan push.  Apple dengan jelas menulis bahwa pengiriman tidak dijamin. <br><br>  <strong>Antara aplikasi Ekstensi dan iOS, kerugian</strong> <strong><em>tidak</em></strong> <strong>dapat</strong> <strong><em>terjadi</em></strong> <strong>, dan Apple menjamin ini.</strong>  Jika Anda menggunakan Extension dan mengganti didReceiveContent dengan metode penyelesaian, bahkan jika Anda tidak memanggil penyelesaian ini, notifikasi akan tetap ditampilkan.  Ini penting untuk diingat.  Anda mungkin tidak menyebutnya atau tidak punya waktu untuk memanggilnya, tetapi kemudian pemberitahuan akan ditampilkan tanpa perubahan apa pun, dalam bentuk di mana ia berasal dari APN. <br><br>  Kami akan melihat bagaimana kami menangani kerugian antara APN dan Perpanjangan.  Tetapi jika Anda perlu meningkatkan kemampuan pengiriman pemberitahuan push, lihat keseluruhan skema.  Periksa apakah ada kerugian di sisi layanan, apakah penyedia Anda berinteraksi secara normal dengan APN dan sebagainya.  Periksa dan ukur keseluruhan rantai, dan kemudian buat kesimpulan di mana kerugian paling banyak terjadi dan bagian mana dari sirkuit ini yang harus dimodifikasi. <br><br><h2>  Tekan Notifikasi Antrian </h2><br>  Cara kami menangani kerugian dalam bundel APN dan Ekstensi yang kami sebut antrian pemberitahuan push. <br><br>  Jika Anda mengompres keseluruhan cerita menjadi satu frasa, maka itu akan menjadi: <br><blockquote>  Jika Anda melewatkan pemberitahuan push, Anda dapat memintanya lagi. </blockquote><br><img src="https://habrastorage.org/webt/mi/dl/c8/midlc81bedgy18xv4gzgmkyb7zo.jpeg"><br><br>  Dalam skema pengiriman pemberitahuan kami, semua peserta yang sama adalah: XIVA, APNs, Extension.  Skema yang disederhanakan bekerja seperti ini: <br><br><ul><li>  XIVA memberi nomor pada notifikasi push yang ingin dikirim ke APN, dan baru kemudian mengirim informasi. </li><li>  Ekstensi menerima pemberitahuan push nomor 1 dan, setelah beberapa waktu, nomor 3. Ini memahami bahwa beberapa data hilang. </li><li>  Mengirim ke XIVA permintaan dengan posisi terakhir diterima, berbeda dan meminta untuk mengirim data yang hilang lagi. </li><li>  XIVA mengirim ulang pemberitahuan push karena menyimpan database payload dan database berlangganan.  Semua langganan disimpan selama beberapa waktu dan dapat diminta kembali. </li><li>  Kami kembali bertanya, kami menerima pemberitahuan push, dan kami memiliki semua pesan yang seharusnya diterima klien. </li></ul><br>  Masalah yang diharapkan pertama adalah pemberitahuan rangkap.  Ketika kami meminta kembali pesan dari XIVA, kami tidak tahu apa yang ada dalam antrian untuk dikirim, karena kami berkomunikasi dengannya tidak secara langsung, tetapi melalui APN.  Misalkan kita melihat bahwa beberapa pemberitahuan hilang, dan mengirim permintaan ke XIVA.  XIVA dikirim melalui APN payload dengan pemberitahuan yang terlewat.  Tetapi sebelum kami menerimanya, kami menerima muatan lain dan juga dengan izin.  Mereka bertanya lagi - XIVA mengirim lagi. <br><br>  Agar notifikasi tidak digandakan, kami menggunakan <strong>apns-collapse-id</strong> .  Pengaturan ini memungkinkan sisi iOS untuk membatalkan pemberitahuan push dengan ID yang sama.  Jika beberapa notifikasi push dengan apns-collapse-id yang sama telah tiba di perangkat, iOS akan menutupnya dan pengguna hanya akan melihat satu notifikasi. <br><br><h3>  XIVA </h3><br>  Saya akan memberi tahu Anda cara kerjanya di XIVA, karena selalu ingin tahu apa yang terjadi di backend. <br><br>  XIVA ada sebelum antrian pemberitahuan push dan merupakan basis data berlangganan.  Penting bahwa dalam basis data semua disimpan oleh pengguna: <br><br><ul><li>  Kuncinya adalah <code>&lt;service, user&gt;</code> . </li><li>  Payload disimpan sebagai nilai (data tentang surat dalam kasus Mail). </li></ul><br>  XIVA mengambil data dari database dan dikirim ke APNs atau layanan lain, karena ia bekerja tidak hanya dengan iOS.  Kami memutuskan untuk menggunakannya kembali. <br><br>  Kami datang ke tim pengembangan XIVA dan benar-benar meminta antrian pemberitahuan push.  Pada prinsipnya, XIVA sudah memiliki segalanya untuk ini: database, TTL untuk payload, yaitu, mereka tidak segera dihapus, mereka dapat diteruskan.  Satu-satunya hal yang hilang adalah bahwa itu mungkin untuk mengkonfigurasi antrian pemberitahuan push sebagai bagian dari implementasi XIVA saat ini - itu penomoran ujung-ke-ujung. <br><br>  Untuk penomoran pass-through, notifikasi push harus diberi nomor oleh perangkat dan app_name.  Artinya, penomoran ujung-ke-ujung diperlukan untuk perangkat tertentu dan untuk aplikasi tertentu agar dapat mengandalkannya di sisi klien.  Kami melakukan ini sebagai berikut: menggunakan kembali basis data XIVA, tetapi mulai menulis payload ke sana menggunakan kunci yang berbeda.  Sekarang apns_queue bertindak sebagai layanan, <code>device_id + app_name</code> sebagai pengguna - data yang perlu diberi nomor pada klien, yaitu, <code>key: &lt;apns_queue, device_id + app_name&gt;</code> . <br><br>  Sekarang XIVA mengambil data dari database utama dan memasukkannya ke dalam antrian ketika perlu dikirim.  Pada titik ini, payload menerima penomoran baru, karena sekarang mereka berada di database yang sama, tetapi dengan kunci yang berbeda.  Sudah dari sana XIVA mengeluarkannya dan mengirimkannya melalui APN.  Secara total, klien menerima penomoran payload yang diperlukan. <br><br>  Klien menggunakan Ekstensi Layanan Pemberitahuan. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request: UNNotificationRequest, withContentHandler contentHandler: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(UNNotificationContent)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// . . . }</span></span></code> </pre> <br>  Kami mendefinisikan kembali metode <code>didReceive</code> di <code>didReceive</code> dan melihat apa yang datang dari server.  Kami menambahkan <code>"mutable-content" : 1</code> ke semua pemberitahuan push sehingga masuk ke dalam Ekstensi, karena jika tidak, kami tidak dapat memperhitungkannya dalam perhitungan. <br><br>  Lebih lanjut dalam kode di dalam metode ada pemeriksaan berkelanjutan: apakah muatan yang diperlukan datang, apakah mereka dapat menguraikannya.  Jika tidak diuraikan, maka pesan ini bukan dari XIVA.  Jika pesan itu bukan dari XIVA, kami tidak dapat terus bekerja dengannya dan cukup memanggil penyelesaian dengan pemberitahuan yang datang dari APN, kami tidak melakukan perhitungan apa pun. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> payload = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.payloadParser.parsePayload(from: request.content.userInfo) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,     xiva contentHandler(request.content); return }</span></span></code> </pre> <br>  Kami masuk, periksa apakah deviceId telah berubah, karena kami tahu bahwa di iOS itu mungkin.  Jujur, kami belum menemukan perubahan pada deviceId, tapi kalau-kalau kami sedang memprosesnya, karena jika itu berubah, kami tidak akan bisa mempercayai angka-angka dari XIVA. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.logger.logNotificationReceived(with: payload) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastPositionDeviceId != deviceId { <span class="hljs-comment"><span class="hljs-comment">// deviceId ,    lastNotificationPosition = nil lastPositionDeviceId = deviceId }</span></span></code> </pre> <br>  Lebih jauh kita melihat, apakah kita dapat menerima data XIVA dalam muatan ini, apakah mereka atau tidak.  Jika tidak, panggil contentHandler lagi. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> xivaInfo = payload.xivaInfo <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { contentHandler(request.content); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  Jika ada data, periksa untuk melihat apakah deviceId telah menerima data.  XIVA mengirimkan hash perangkat ke payload, jika diverifikasi dan cocok, kami melanjutkan, tidak, kami sebut contentHandler. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> isHashCompatible(deviceId: deviceId, deviceIdHash: xivaInfo.deviceIdHash) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// payload device_id   device_id  contentHandler(request.content); return }</span></span></code> </pre> <br>  Blok selanjutnya adalah untuk melihat apakah ada posisi yang disimpan: <br><br><ul><li>  Jika kami tidak memiliki posisi yang disimpan terakhir, maka kami belum menerima pemberitahuan dan belum memasukkan Ekstensi, atau karena alasan tertentu keluar.  Lalu tidak ada yang perlu dilakukan untuk menemukan perbedaan yang terlewat, dan kami kembali memanggil penyelesaian. </li><li>  Jika ada, lanjutkan. </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastPos = lastNotificationPosition <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      lastNotificationPosition = xivaInfo.notificationPosition contentHandler(request.content); return }</span></span></code> </pre> <br>  Kami menghitung jumlah pemberitahuan yang terlewat.  Jika kehilangan nol baik-baik saja, kami tidak melewatkan apa pun. <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> missedMessages = xivaInfo.notificationPosition - lastPos - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> missedMessages &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   push–     contentHandler(request.content); return }</span></span></code> </pre> <br>  Jika tidak, kami mengambil dari XIVA data posisi - dari penomoran berkelanjutan yang sama.  Lebih jauh kita melihat, apakah jumlah yang terlewat tidak melebihi nilai yang ditentukan. <br><br><pre> <code class="swift hljs">lastNotificationPosition = xivaInfo.notificationPosition <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> missedMessages &lt;= repeatMaxCount <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    ,   contentHandler(buildNewNotification()); return }</span></span></code> </pre> <br>  Mengapa ini dibutuhkan?  Misalkan pengguna telah offline untuk waktu yang lama, dan selama waktu ini seratus pesan telah terakumulasi.  Kami akan meminta seluruh seratus (mudah bagi kami), XIVA akan mengirim seluruh seratus, dan pengguna akan menerima semua pemberitahuan.  Bahkan jika kita mengelompokkannya berdasarkan thread-id (dan kita mengelompokkannya), semua sama, untuk setiap notifikasi, ekstensi ini akan dipanggil, semua cek akan berlalu.  Tampaknya tidak mungkin bahwa pengguna membutuhkan semua seratus notifikasi.  Karena itu, kami membuat pemberitahuan di mana kami menulis bahwa Anda memiliki 100 pesan yang tidak terjawab, buka aplikasi dan lihat.  Dan kami menunjukkan pesan ini kepada pengguna, karena kami dapat mengganti pemberitahuan push. <br><br>  Ketika semua cek telah lulus, kami mengirim permintaan ke XIVA: posisi terakhir yang datang kepada kami, dan jumlah pesan yang terlewat.  Dan lihat: <br><br><ul><li>  Jika XIVA berhasil merespons: “Semuanya baik-baik saja, saya akan mengirim data”, kami menunjukkan kepada pengguna pemberitahuan saat ini dan menunggu hingga XIVA mengirim semua yang lain dan pengguna melihat semua pesan yang terlewat. </li><li>  Jika XIVA menjawab dengan kesalahan, maka kami menunjukkan kepada pengguna pemberitahuan khusus bahwa ia telah melewatkan pesan yang dapat dilihat dalam aplikasi. </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.requestMissedNotifications(lastPosition: xivaInfo.notificationPosition, gap: missedMessages) { result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> result.onValue { <span class="hljs-number"><span class="hljs-number">_</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.logger.logNotificationProcessed(with: .success) contentHandler(request.content) }.onError { error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.logger.logNotificationProcessed(with: .failure(error)) contentHandler(buildNewNotification()) } }</code> </pre> <br>  Dengan demikian, implementasi pada klien datang ke sejumlah besar pemeriksaan di mana kami mengetahui apakah kami dapat bekerja dengan data yang diterima. <br><br><h2>  Penebangan dan kesulitan lainnya </h2><br>  Seperti yang Anda ketahui, untuk memastikan pendekatan tersebut berfungsi dengan baik, Anda harus login.  Kami mulai mengumpulkan statistik tentang metode baru untuk mengirimkan pemberitahuan dan membandingkan bagaimana kemampuan pengiriman telah berubah. <br><br><h3>  Keterbatasan ekstensi push </h3><br>  Hal pertama yang kami temui adalah pembatasan push-extension. <br><br>  <strong>Tidak selalu dipanggil</strong> .  Jika Anda mematikan gambar pemberitahuan di pengaturan aplikasi (kemampuan untuk menerima pemberitahuan tetap menyala, tetapi semua kemungkinan render dimatikan), Ekstensi tidak akan dipanggil - semua logika dengan penghitungan ulang dan, yang paling penting, pencatatan tidak akan dipanggil.  Kami tidak akan dapat menemukan apa yang paling penting bagi kami - apakah pengguna telah menerima pemberitahuan. <br><br>  <strong>Ekstensi dorong memiliki batas waktu</strong> .  Dokumentasi Apple mengatakan bahwa dalam waktu sekitar 30 detik Anda harus memanggil penyelesaian dengan notifikasi yang dimodifikasi, jika tidak, notifikasi awal akan ditampilkan. <br><br>  Saya bertanya-tanya bagaimana kita menemukan jawabannya.  Kami menerapkan fitur yang kami sebut notifikasi push "cantik", elemen media terlampir pada notifikasi, mengubah judul, subtitle.  Selama pengujian, ternyata beberapa notifikasi push menjadi indah, sementara sisanya seperti bebek jelek tetap. <br><br>  Kami mulai melihat perbedaan antara pemberitahuan push ini dan menemukan bahwa tidak ada perbedaan, hanya untuk beberapa yang berhasil kami selesaikan, tetapi untuk yang lain tidak. ,   , push-     ,     APNs. <br><br> <strong>  —  </strong> . Apple ,  ,   push-extension, ,        ,     .   ,    12 . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apple Developer Forum</a>   ,   ,        .     ,     — 10 . <br><br>     ,   .      AppMetrica.   , AppMetrica     ,   Extension   .      ,  -   . <br><br>     :    Extension   . <br><br><h3>   </h3><br>    push-extension    UserDefaults. ,    ,     AppMetrica. <br><br>     .      .   ,          ,      .          ,          .         ,   XIVA (  ),  ,   . <br><br>  ,  Notification Extension   iOS 10  ,       Extension,       ,     . <br><br> <strong> </strong> <strong>AppMetrica</strong> :      , push-extension      .  AppMetrica   push-,   ,             .   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppMetrica Push SDK</a> . <br><br> ,   .    —   ,   .   ,   . <br><br><img src="https://habrastorage.org/webt/tg/k_/nk/tgk_nkvmus8kud-brgg6v9jvmhm.jpeg"><br><br>   —   ,      ,     . <br><br>  ,     push-,   ,        —   . <br><br>  ,  ,     .      , … <br><br><h2>  </h2><br>   :  , ,  .   ,  ?   -  ,     push-?  ,        ?    user experience   ? <br><br><blockquote>       ,       2–3–20  ? <br></blockquote><br> , ,  ,  ,  ,   ,  ,  .           ,      push-. ,     . <br><br><h2>  Ringkasan </h2><br> <strong>Push-  iOS   .</strong>             ,    .. ,    . <br><br> <strong> push-  ( ) .</strong>       .  XIVA. ,     ,     . ,  ,      . ! <br><br> <strong>   push-extension.</strong>     ,    . ,   . <br><br> <strong>,     .</strong> ,     , ,    ,    -  . ,   push-           . , ,      ,      App Store,     ,   ! <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf</a>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> ,     21  22      ,        ..        50 ,     .  1   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a>      ,       — . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462507/">https://habr.com/ru/post/id462507/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462493/index.html">Multimodel DBMS - dasar sistem informasi modern?</a></li>
<li><a href="../id462495/index.html">Acara digital di Moskow dari 05 hingga 11 Agustus</a></li>
<li><a href="../id462501/index.html">Mengapa saya memerlukan otoritas sertifikasi saya sendiri</a></li>
<li><a href="../id462503/index.html">Untuk apa "sinyal emas" pemantauan dan SRE?</a></li>
<li><a href="../id462505/index.html">Jangan membodohi saya dengan pemrograman fungsional Anda</a></li>
<li><a href="../id462509/index.html">Product Fest - konferensi manajemen produk TI yang ingin Anda kunjungi</a></li>
<li><a href="../id462511/index.html">Google Play Instan. Refactoring seumur hidup</a></li>
<li><a href="../id462513/index.html">Relokasi: persiapan, pemilihan, pengembangan wilayah</a></li>
<li><a href="../id462515/index.html">Bug saat bekerja dengan keyboard sistem</a></li>
<li><a href="../id462519/index.html">Buku "Layanan Mikro. Pengembangan dan pola refactoring »</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>