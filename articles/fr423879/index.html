<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>#‚É£ ‚¨ÜÔ∏è üßÄ Est-il facile d'ajouter de nouvelles fonctionnalit√©s √† l'ancien framework? Farine de choix sur l'exemple du d√©veloppement de SObjectizer ü§£ üïØÔ∏è üíë</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="D√©velopper un cadre gratuit pour les besoins des d√©veloppeurs est un sujet sp√©cifique. Si en m√™me temps le cadre vit et se d√©veloppe assez longtemps, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Est-il facile d'ajouter de nouvelles fonctionnalit√©s √† l'ancien framework? Farine de choix sur l'exemple du d√©veloppement de SObjectizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423879/"><img src="https://habrastorage.org/webt/en/lw/bb/enlwbb8hjnjmprjbfysbwsnejiy.jpeg"><br><br>  D√©velopper un cadre gratuit pour les besoins des d√©veloppeurs est un sujet sp√©cifique.  Si en m√™me temps le cadre vit et se d√©veloppe assez longtemps, alors les sp√©cificit√©s sont ajout√©es.  Aujourd'hui, je vais essayer de le montrer en utilisant un exemple de tentative d'extension de la fonctionnalit√© d'un framework "acteur" pour C ++ appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> . <br><br>  Le fait est que ce cadre est d√©j√† assez ancien, il a radicalement chang√© plusieurs fois.  M√™me son incarnation actuelle, SObjectizer-5, a subi de nombreux changements, graves et non.  De plus, nous sommes assez sensibles √† la compatibilit√© et introduire des changements qui cassent la compatibilit√© est une √©tape trop s√©rieuse pour que nous d√©cidions simplement. <br><br>  En ce moment, nous devons d√©cider comment ajouter une nouvelle fonctionnalit√© √† la prochaine version.  Dans le processus de recherche d'une solution appropri√©e, deux options sont apparues.  Les deux semblent assez r√©alisables.  Mais ils sont tr√®s diff√©rents les uns des autres.  Tant en termes de complexit√© et de complexit√© de mise en ≈ìuvre que dans son ¬´apparence¬ª.  C'est-√†-dire  ce que le d√©veloppeur traitera sera diff√©rent dans chacune des options.  Probablement m√™me fondamentalement diff√©rent. <br><br>  Et maintenant, en tant que d√©veloppeurs du framework, nous devons faire un choix en faveur de l'une ou l'autre solution.  Ou bien il faut admettre qu‚Äôaucune d‚Äôelles n‚Äôest satisfaisante et qu‚Äôil faut donc inventer autre chose.  De telles d√©cisions au cours de l'histoire de SObjectizer ont d√ª √™tre prises plus d'une fois.  Si quelqu'un est int√©ress√© √† se sentir √† la place du d√©veloppeur d'un tel cadre, vous √™tes le bienvenu chez cat. <br><a name="habracut"></a><br><h1>  Probl√®me d'origine </h1><br>  Donc, bri√®vement l'essence du probl√®me d'origine.  D√®s le d√©but de son existence, SObjectizer avait la caract√©ristique suivante: un message de temporisation n'est pas si facile √† annuler.  Sous la minuterie, on comprendra tout d'abord un message diff√©r√©.  C'est-√†-dire  un message qui ne doit pas √™tre envoy√© imm√©diatement au destinataire, mais apr√®s un certain temps.  Par exemple, nous faisons send_delayed avec une pause de 1s.  Cela signifie qu'en r√©alit√© le message sera envoy√© par le temporisateur 1s apr√®s l'appel send_delayed. <br><br>  Un message en attente peut, en principe, √™tre annul√©.  Si le message est toujours en possession de la minuterie, le message apr√®s l'annulation n'ira nulle part.  Il sera lanc√© par la minuterie et c'est tout.  Mais si le temporisateur a d√©j√† envoy√© un message et qu'il se trouve maintenant dans la file d'attente des demandes de l'agent r√©cepteur, l'annulation du temporisateur ne fonctionnera pas.  Il n'existe aucun m√©canisme dans SObjectizer pour supprimer un message de la file d'attente des applications. <br><br>  Le probl√®me est aggrav√© par au moins deux facteurs. <br><br>  Premi√®rement, SObjectizer prend en charge la livraison en mode 1: N, c'est-√†-dire  si le message a √©t√© envoy√© √† la mbox multi-consommateurs, le message ne sera pas dans une file d'attente, mais dans plusieurs files d'attente pour N destinataires √† la fois. <br><br>  Deuxi√®mement, dans SObjectizer, le m√©canisme de r√©partition est utilis√© et les r√©partiteurs peuvent √™tre tr√®s diff√©rents, y compris ceux √©crits par l'utilisateur pour ses besoins sp√©cifiques.  Les files d'attente de demandes sont g√©r√©es par des r√©partiteurs.  Et dans l'interface du r√©partiteur, il n'y a aucune fonctionnalit√© pour retirer une application qui a d√©j√† √©t√© transf√©r√©e au r√©partiteur.  Mais m√™me si de telles fonctionnalit√©s √©taient int√©gr√©es dans l'interface, il est loin d'√™tre certain qu'elles pourraient √™tre mises en ≈ìuvre efficacement dans tous les cas.  Sans oublier le fait qu'une telle fonctionnalit√© augmenterait la complexit√© du d√©veloppement de nouveaux r√©partiteurs. <br><br>  En g√©n√©ral, objectivement, si le temporisateur a d√©j√† envoy√© un message en attente au (x) destinataire (s), alors forcer SObjectizer √† ne pas remettre cette instance du message est actuellement impossible. <br><blockquote>  En fait, ce probl√®me est √©galement pertinent pour les messages p√©riodiques (c'est-√†-dire les messages que le temporisateur doit envoyer p√©riodiquement √† des intervalles de temps pr√©d√©termin√©s).  Mais en pratique, l'annulation de messages p√©riodiques est beaucoup moins n√©cessaire que l'annulation d'un message en attente.  C'est du moins le cas dans notre pratique. </blockquote><h2>  Que peut-on faire maintenant? </h2><br>  Donc, ce probl√®me n'est pas nouveau et pendant longtemps il y a des recommandations sur la fa√ßon de le traiter. <br><br><h3>  Identifiant unique dans le message en attente </h3><br>  Le moyen le plus simple est de tenir un compteur.  L'agent dispose d'un compteur; lors de l'envoi d'un message en attente, la valeur actuelle du compteur est envoy√©e dans le message.  Lorsqu'un message est annul√©, le compteur de l'agent est incr√©ment√©.  A la r√©ception du message, la valeur actuelle du compteur dans l'agent est compar√©e √† la valeur du message.  Si les valeurs ne correspondent pas, le message est rejet√©: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delayed_msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id_; ... }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> expected_msg_id_{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> timer_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_some_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . //   send_periodic, ..    //  timer_id   . timer_ = so_5::send_periodic&lt;delayed_msg&gt;(*this, 25s, //     . 0s, //    . //      delayed_msg, //      id   . ++expected_msg_id_, ... //  . ); ... } void on_cancel_event() { //   ,        //   .   : timer_.reset(); //     . ++expected_msg_id_; //   id-. ... } void on_delayed_msg(mhood_t&lt;delayed_msg&gt; cmd) { //     id    //  . if(expected_msg_id_ == cmd-&gt;id_) { ... //  . } } };</span></span></code> </pre> <br>  Le probl√®me avec cette m√©thode est que le d√©veloppeur d'agent doit √™tre intrigu√© par la maintenance de ces compteurs.  Et si en tant que message diff√©r√© nous devons envoyer le message de quelqu'un d'autre que quelqu'un d'autre a fait et dans lequel il n'y a pas de champ id_, alors nous nous trouvons dans une situation difficile. <br><br>  Bien que, d'autre part, c'est la mani√®re la plus efficace qui existe actuellement. <br><br><h3>  Utiliser une mbox unique pour les messages retard√©s </h3><br>  Une autre m√©thode qui fonctionne bien consiste √† utiliser une bo√Æte aux lettres unique (mbox) pour un message diff√©r√©.  Dans ce cas, nous cr√©ons une nouvelle mbox pour chaque message en attente, nous y abonnons et envoyons le message en attente √† cette mbox.  Lorsqu'un message doit √™tre annul√©, nous supprimons simplement les abonnements mbox. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delayed_msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//   id_   . }; so_5::mbox_t timer_mbox_; //   . so_5::timer_id_t timer_; void on_some_event() { //        mbox //     . timer_mbox_ = so_environment().create_mbox(); some_state.event(time_mbox_, ...); another_state.event(time_mbox_, ...); ... //    . timer_ = so_5::send_delayed&lt;delayed_msg&gt;( so_environment(), timer_mbox_, //     . 25s, 0s, ... //    delayed_msg. ); } void on_cancel_event() { //        mbox. timer_.reset(); so_drop_subscription_for_all_states(timer_mbox_); } void on_delayed_msg(mhood_t&lt;delayed_msg&gt; cmd) { //     ,   //    . ... } };</span></span></code> </pre> <br>  Cette m√©thode peut d√©j√† fonctionner avec les messages d'autres personnes, √† l'int√©rieur desquels il n'y a pas d'identifiant unique.  Mais cela n√©cessite √©galement du travail et de l'attention de la part du d√©veloppeur. <br><br>  Par exemple, dans le mode de r√©alisation ci-dessus, il n'y a aucune protection contre le fait qu'un message en attente a d√©j√† √©t√© envoy√© plus t√¥t.  Dans le bon sens, avant d'envoyer un nouveau message en attente, vous devez toujours effectuer des actions de on_cancel_event (), sinon l'agent aura des abonnements inutiles pour cela. <br><br><h2>  Pourquoi ce probl√®me n'a-t-il pas √©t√© r√©solu auparavant? </h2><br>  Tout est assez simple ici: en fait, ce n'est pas un probl√®me aussi grave qu'il y para√Æt.  Au moins dans la vraie vie, vous n'avez pas √† y faire face souvent.  Habituellement, les messages en attente et p√©riodiques ne sont pas du tout annul√©s (c'est pourquoi, en passant, la fonction send_delayed ne renvoie pas timer_id).  Et lorsque le besoin d'annulation survient, vous pouvez utiliser l'une des m√©thodes d√©crites ci-dessus.  Ou m√™me en utiliser un autre.  Par exemple, cr√©ez des agents distincts qui traiteront un message en attente.  Ces agents peuvent √™tre d√©sinscrits lorsqu'un message en attente doit √™tre annul√©. <br><br>  Ainsi, dans le contexte des autres t√¢ches qui nous ont √©t√© confront√©es, la simplification de l'annulation garantie d'un message en attente n'√©tait pas une priorit√© au point de consacrer nos ressources √† la r√©solution de ce probl√®me. <br><br><h2>  Pourquoi le probl√®me est-il pertinent maintenant? </h2><br>  Ici, tout est aussi simple.  D'une part, les mains ont finalement atteint. <br><br>  D'un autre c√¥t√©, lorsque de nouvelles personnes qui n'avaient pas d'exp√©rience avec lui commencent √† utiliser SObjectizer, cette fonctionnalit√© avec l'annulation des temporisations les surprend grandement.  Pas si agr√©ablement surprenant.  Et si oui, alors je voudrais minimiser les impressions n√©gatives de la connaissance de notre outil. <br><br>  De plus, nous avions nos propres t√¢ches, nous n'avions pas besoin d'annuler constamment les messages en attente.  Et les nouveaux utilisateurs ont leurs propres t√¢ches, peut-√™tre que tout est invers√©. <br><br><h1>  Nouvelle d√©claration du probl√®me </h1><br>  Presque imm√©diatement, d√®s que l‚Äôon a envisag√© la possibilit√© d‚Äôune ¬´annulation de la temporisation garantie¬ª, j‚Äôai pens√© que la t√¢che pourrait √™tre √©largie.  Vous pouvez essayer de r√©soudre le probl√®me du rappel de l'un des messages pr√©c√©demment envoy√©s, pas n√©cessairement retard√© et p√©riodique. <br><br>  De temps en temps, cette opportunit√© est recherch√©e.  Par exemple, imaginez que nous avons plusieurs agents en interaction de deux types: entry_point (accepte les demandes des clients) et processeur (traite les demandes): <br><br><img src="https://habrastorage.org/webt/s7/mo/jp/s7mojpeyu9s6prshykrqxul14he.png"><br><br>  Les agents Entry_point envoient des requ√™tes √† l'agent processeur, qui les traite autant que possible et r√©pond aux agents Entry_point.  Mais parfois, entry_point peut constater que le traitement d'une demande envoy√©e pr√©c√©demment n'est plus n√©cessaire.  Par exemple, le client a envoy√© une commande d'annulation ou le client est ¬´tomb√©¬ª et vous n'avez plus besoin de traiter ses demandes.  Maintenant, si les messages de demande sont mis en file d'attente par l'agent de processeur, vous ne pouvez pas les rappeler.  Et ce serait utile. <br><br>  Par cons√©quent, l'approche actuelle pour r√©soudre le probl√®me de ¬´l'annulation garantie de la minuterie¬ª est mise en ≈ìuvre avec pr√©cision en tant que prise en charge des ¬´messages de rappel¬ª.  Nous envoyons tout message d'une mani√®re sp√©ciale, nous obtenons une poign√©e sous la main, avec laquelle vous pouvez ensuite rappeler le message.  Et ce n'est pas si important qu'un message r√©gulier ou retard√© r√©ponde. <br><br><h1>  Une tentative de proposer la mise en place de "messages de rappel" </h1><br>  Vous devez donc introduire le concept de "message de rappel" et prendre en charge ce concept dans SObjectizer.  Et donc, pour rester dans la branche 5.5.  La premi√®re version de ce fil, 5.5.0, est sortie il y a pr√®s de quatre ans, en octobre 2014.  Depuis lors, il n'y a eu aucun changement majeur dans 5.5.  Les projets qui ont d√©j√† bascul√© ou d√©marr√© imm√©diatement sur SObjectize-5.5 peuvent passer √† de nouvelles versions dans la branche 5.5 sans aucun probl√®me.  Cette compatibilit√© doit √™tre maintenue cette fois. <br><br>  En g√©n√©ral, tout est simple: il faut prendre et faire. <br><br><h2>  Comment faire clairement </h2><br>  Apr√®s la premi√®re approche du probl√®me, deux choses sont devenues claires au sujet de la mise en ≈ìuvre des ¬´messages de rappel¬ª. <br><br><h3>  Drapeau atomique et sa v√©rification avant le traitement du message </h3><br>  Premi√®rement, il est √©vident que dans le cadre de l'architecture SObjectizer-5.5 actuelle (et peut-√™tre m√™me plus globalement: dans le cadre des principes de SObjectizer-5 lui-m√™me), il est impossible de supprimer des messages des files d'attente de requ√™tes du r√©partiteur, o√π les messages attendent que les agents r√©cepteurs les traitent.  Essayer de faire cela tuera toute l'id√©e de r√©partiteurs h√©t√©rog√®nes, que m√™me l'utilisateur peut faire lui-m√™me, selon les sp√©cificit√©s de sa t√¢che (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">celle-ci</a> ).  De plus, dans le cas de l'envoi d'un message en mode 1: N, o√π N sera grand, il sera co√ªteux de conserver une liste de pointeurs vers une instance du message envoy√© dans toutes les files d'attente. <br><br>  Cela signifie qu'avec le message, une sorte d'indicateur atomique doit √™tre transmis, qui devra √™tre analys√© imm√©diatement apr√®s la suppression du message de la file d'attente des demandes, mais avant l'envoi du message pour traitement √† l'agent r√©cepteur.  C'est-√†-dire  le message entre dans la file d'attente et n'est retir√© de nulle part.  Mais lorsque le tour arrive au message, son drapeau est v√©rifi√©.  Et si le drapeau indique que le message a √©t√© retir√©, le message n'est pas trait√©. <br><br>  En cons√©quence, le rappel de message lui-m√™me consiste √† d√©finir une valeur sp√©ciale pour le drapeau atomique √† l'int√©rieur du message. <br><br><h3>  Objet &lt;M&gt; Revocable_handle_t </h3><br>  Deuxi√®mement, jusqu'√† pr√©sent (?) Il est √©vident que pour envoyer un message r√©vocable, non pas les m√©thodes habituelles d'envoi de messages doivent √™tre utilis√©es, mais un objet sp√©cial sous le nom conditionnel revocable_handle_t. <br><br>  Pour envoyer un message r√©vocable, l'utilisateur doit cr√©er une instance de revocable_handle_t, puis appeler la m√©thode d'envoi sur cette instance.  Et si le message doit √™tre rappel√©, cela se fait √† l'aide de la m√©thode de r√©vocation.  Quelque chose comme: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_message</span></span></span><span class="hljs-class"> {</span></span>...}; ... so_5::<span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_message&gt; msg; <span class="hljs-comment"><span class="hljs-comment">//    . msg.send(target, //  . ... //    my_message. ); ... //   . msg.revoke();</span></span></code> </pre> <br>  Il n'y a pas encore de d√©tails clairs sur la mise en ≈ìuvre de revocable_handle_t, ce qui n'est pas surprenant, car  le m√©canisme de travail des messages de rappel n'a pas encore √©t√© s√©lectionn√©.  Mais le principe de travail est que dans revocable_handle_t un lien intelligent est enregistr√© dans le message envoy√© et dans le drapeau atomique pour celui-ci.  La m√©thode revoke () tente de remplacer la valeur de l'indicateur.  Si cela r√©ussit, le message, apr√®s extraction de la file d'attente de commandes, ne sera plus trait√©. <br><br><h3>  Avec quoi il ne sera pas ami </h3><br>  Malheureusement, il y a deux ou trois choses avec lesquelles le rappel des messages ne peut pas √™tre correctement li√©.  Tout simplement parce que le message retir√© continue de rester dans les files d'attente o√π il est d√©j√† arriv√©. <br><br><h4>  message_limits </h4><br>  Une caract√©ristique aussi importante de SObjectizer que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">message_limits</a> est con√ßue pour prot√©ger les agents contre les surcharges.  Message_limits fonctionne en fonction du nombre de messages dans la file d'attente.  Mis en file d'attente un message - augment√© le compteur.  Sorti de la ligne - r√©duit. <br><br>  Parce que  lorsqu'un message est r√©voqu√©, il reste dans la file d'attente, puis message_limits n'affecte pas la r√©ponse du message.  Par cons√©quent, il peut s'av√©rer que la file d'attente a une limite sur le nombre de messages de type M, mais tous ont √©t√© rappel√©s.  En fait, aucun d'entre eux ne sera trait√©.  Mais la mise en file d'attente d'un nouveau message de type M ne fonctionnera pas, car  la limite est d√©pass√©e. <br><br>  La situation n'est pas bonne.  Mais comment s'en sortir?  Ce n'est pas clair. <br><br><h4>  cha√Ænes de file d'attente fixes </h4><br>  Dans SObjectizer, un message peut √™tre envoy√© non seulement √† mbox, mais aussi √† mchain (c'est notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analogue du canal CSP</a> ).  Et les cha√Ænes peuvent avoir une taille fixe pour leurs files d'attente.  Une tentative de mettre un nouveau message pour mchain avec une taille fixe en mchain complet devrait conduire √† une sorte de r√©action.  Par exemple, en attendant la lib√©ration d'espace dans la file d'attente.  Ou pour pousser le message le plus ancien. <br><br>  Dans le cas d'un rappel de message, il restera dans la file d'attente mchain.  Il s'av√®re que le message n'est plus n√©cessaire, mais il prend de la place dans la file d'attente mchain.  Et emp√™che l'envoi de nouveaux messages √† mchain. <br><br>  La m√™me mauvaise situation qu'avec message_limits.  Et encore une fois, il n'est pas clair comment cela peut √™tre r√©solu. <br><br><h2>  Ce qui n'est pas clair comment faire </h2><br>  Nous avons donc eu le choix entre deux (jusqu'√† pr√©sent?) Options pour impl√©menter les messages de rappel.  La premi√®re option est simple √† impl√©menter et ne n√©cessite pas de modification des abats de SObjectizer.  La deuxi√®me option est beaucoup plus compliqu√©e, mais le destinataire du message ne sait m√™me pas qu'il s'agit de messages r√©vocables.  Nous allons bri√®vement examiner chacun d'eux. <br><br><h3>  Recevoir des messages r√©vocables comme revocable_t &lt;M&gt; </h3><br>  La premi√®re solution, qui semble, d'une part, faisable et, d'autre part, assez pratique, est l'introduction d'un wrapper sp√©cial revocable_t &lt;M&gt;.  Lorsque l'utilisateur envoie un message r√©vocable de type M via revocable_handle_t &lt;M&gt;, ce n'est pas le message M qui est envoy√©, mais le message M √† l'int√©rieur du wrapper sp√©cial revocable_t &lt;M&gt;.  Et, en cons√©quence, l'utilisateur ne recevra pas et ne traitera pas le message de type M, mais le message revocable_t &lt;M&gt;.  Par exemple, de cette fa√ßon: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> {</span></span> ... }; <span class="hljs-comment"><span class="hljs-comment">// ,    . void so_define_agent() override { //   . so_subscribe_self().event( //     ,    //   . [this](mhood_t&lt; revocable_t&lt;request&gt; &gt; cmd) { // ,      . cmd-&gt;try_handle([this](mhood_t&lt;request&gt; msg) { ... }); }); ... } ... };</span></span></code> </pre> <br>  La m√©thode revocable_t &lt;M&gt; :: try_handle () v√©rifie la valeur du drapeau atomique et, si le message n'est pas rappel√©, appelle la fonction lambda qui lui est pass√©e.  Si le message est retir√©, try_handle () ne fait rien. <br><br><h4>  Avantages et inconv√©nients de cette approche </h4><br>  Le principal avantage est que ce voyage est facile √† mettre en ≈ìuvre (du moins jusqu'√† pr√©sent, il semble).  En fait, revocable_handle_t &lt;M&gt; et revocable_t &lt;M&gt; ne seront qu'un compl√©ment subtil au SObjectizer. <br><br>  Une intervention dans les internes de SObjectizer peut √™tre n√©cessaire pour se faire des amis revocable_t et mutable_msg.  Le fait est que dans SObjectizer il y a le concept de messages immuables (ils peuvent √™tre envoy√©s √† la fois en mode 1: 1 et en mode 1: N).  Et il y a le concept de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">messages mutables</a> qui ne peuvent √™tre envoy√©s qu'en mode 1: 1.  Dans ce cas, SObjectizer traite de mani√®re sp√©ciale le marqueur mutable_msg &lt;M&gt; et effectue les v√©rifications correspondantes au moment de l'ex√©cution.  Dans le cas de revocable_t &lt;mutable_msg &lt;M&gt;&gt;, vous devrez apprendre √† SObjectizer √† traiter cette construction comme mutable_msg &lt;M&gt;. <br><br>  Un autre avantage est que le surco√ªt suppl√©mentaire (√† la fois sur les m√©tadonn√©es du message r√©vocable et sur la v√©rification du drapeau atomique) ne sera que dans des endroits o√π vous ne pouvez pas vous en passer.  Lorsque les messages de rappel ne sont pas utilis√©s, il n'y aura pas de surcharge suppl√©mentaire du tout. <br><br>  Mais le principal inconv√©nient est id√©ologique.  Dans cette approche, le fait d'utiliser des messages r√©vocables affecte √† la fois l'exp√©diteur (en utilisant revocable_handle_t &lt;M&gt;) et le destinataire (en utilisant revocable_t &lt;M&gt;).  Mais le destinataire n'a tout simplement pas besoin de savoir qu'il re√ßoit des messages de rappel.  De plus, en tant que destinataire, vous pouvez avoir un agent tiers pr√™t √† l'emploi qui est √©crit sans revocable_t &lt;M&gt;. <br><br>  De plus, des questions id√©ologiques subsistent, par exemple sur la possibilit√© de transmettre de tels messages.  Mais, selon les premi√®res estimations, ces probl√®mes sont r√©solus. <br><br><h3>  Recevoir des messages de rappel sous forme de messages r√©guliers </h3><br>  La seconde approche consiste √† ne voir que le message de type M c√¥t√© r√©cepteur et √† ne pas avoir une id√©e de l'existence de revocable_handle_t &lt;M&gt; et revocable_t &lt;M&gt;.  C'est-√†-dire  si le processeur doit recevoir une demande, il ne doit voir qu'une demande, sans aucun wrapper suppl√©mentaire. <br><br>  En fait, on ne peut pas se passer de certains wrappers dans cette approche, mais ils seront cach√©s √† l'int√©rieur du SObjectizer et l'utilisateur ne devrait pas les voir.  Une fois l'application r√©cup√©r√©e de la file d'attente, SObjectizer d√©terminera par lui-m√™me qu'il s'agit d'un message r√©vocable sp√©cialement encapsul√©, v√©rifiera l'indicateur de la pertinence du message et d√©veloppera le message s'il est toujours pertinent.  Ensuite, il enverra un message √† l'agent pour traitement comme s'il s'agissait d'un message normal. <br><br><h4>  Avantages et inconv√©nients de cette approche </h4><br>  Le principal avantage de cette approche est √©vident - le destinataire du message ne sait pas avec quels messages il travaille.  Cela permet √† l'exp√©diteur du message de retirer calmement les messages de tous les agents, m√™me ceux qui ont √©t√© √©crits par d'autres d√©veloppeurs. <br><br>  Un autre avantage important est la capacit√© √† s'int√©grer au m√©canisme de tra√ßage de remise des messages ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici le r√¥le de ce m√©canisme est d√©crit plus en d√©tail</a> ).  C'est-√†-dire  si msg_tracing est activ√© et que l'exp√©diteur retire le message, des traces de cela peuvent √™tre trouv√©es dans le journal msg_tracing.  Ce qui est tr√®s pratique lors du d√©bogage. <br><br>  Mais le principal inconv√©nient est la complexit√© de la mise en ≈ìuvre de cette approche.  √Ä laquelle plusieurs facteurs devront √™tre pris en compte. <br><br>  Tout d'abord, les frais g√©n√©raux.  Toutes sortes de choses. <br><br>  Supposons que vous puissiez cr√©er un indicateur sp√©cial dans un message qui indique si ce message est r√©vocable ou non.  V√©rifiez ensuite cet indicateur avant de commencer √† traiter chaque message.  En gros, un autre if est ajout√© au m√©canisme de remise des messages, qui fonctionnera lors du traitement de chaque (!) Message. <br><br>  Je suis s√ªr que dans les applications r√©elles, la perte sur ce point sera √† peine perceptible.  Mais le recul des benchmarks synth√©tiques appara√Ætra certainement.  De plus, plus le rep√®re est abstrait, moins il fait de travail r√©el, plus il s'enfonce.  Et c'est mauvais d'un point de vue marketing, car  plusieurs personnes tirent des conclusions sur le cadre en termes de rep√®res synth√©tiques.  Et ils le font sp√©cifiquement: ne pas comprendre de quel type de r√©f√©rence il s'agit, qu'il montre essentiellement sur quel mat√©riel il fonctionne, mais en comparant les totaux avec les performances d'un outil sp√©cialis√©, dans un autre sc√©nario, sur un autre mat√©riel, etc. ., etc. <br><br>  En g√©n√©ral, puisque nous cr√©ons un cadre universel, qui, en fin de compte, est jug√© par des nombres abstraits dans des rep√®res abstraits, nous ne voulons pas perdre, disons, 5% des performances du m√©canisme de livraison de <i>tous les</i> messages en raison de l'ajout d'une fonctionnalit√© qui ne prend que du temps de temps en temps et pas √† tous les utilisateurs. <br><br>  Par cons√©quent, vous devez vous assurer que lors de l'envoi du message au destinataire, SObjectizer comprend que lorsque vous extrayez le message, vous devez le g√©rer d'une mani√®re sp√©ciale.  En principe, lorsqu'un message est remis √† un agent, SObjectizer stocke avec le message un pointeur vers une fonction qui sera utilis√©e lors du traitement du message.  Cela est n√©cessaire maintenant pour g√©rer les messages asynchrones et les demandes synchrones de diff√©rentes mani√®res.  En fait, voici √† quoi ressemble la demande de message adress√©e √† l'agent: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">execution_demand_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//! Receiver of demand. agent_t * m_receiver; //! Optional message limit for that message. const message_limit::control_block_t * m_limit; //! ID of mbox. mbox_id_t m_mbox_id; //! Type of the message. std::type_index m_msg_type; //! Event incident. message_ref_t m_message_ref; //! Demand handler. demand_handler_pfn_t m_demand_handler; ... };</span></span></code> </pre> <br>  O√π demand_handler_pfn_t est un pointeur de fonction r√©gulier: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">demand_handler_pfn_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">current_thread_id_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">execution_demand_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; )</span></span></span></span>;</code> </pre><br>  Le m√™me m√©canisme peut √©galement √™tre utilis√© pour traiter sp√©cialement le message retir√©.  C'est-√†-dire  lorsque mbox envoie un message √† l'agent, l'agent sait si un message asynchrone ou une demande synchrone lui est envoy√©.  De m√™me, un agent peut recevoir un message de rappel asynchrone d'une mani√®re sp√©ciale.  Et l'agent enregistre, avec le message, un pointeur sur une fonction qui sait comment il doit g√©rer les messages r√©voqu√©s. <br><br>  Tout semble aller bien, mais il y a deux gros "mais" ... :( <br><br>  Premi√®rement, l'interface mbox existante (√† savoir la classe <a href="">abstract_message_mbox_t</a> ) ne dispose d'aucune m√©thode pour envoyer des messages de rappel.  Cette interface doit donc √™tre √©tendue.  Et pour que les impl√©mentations mbox d'autres personnes li√©es √† abstract_message_box_t de SObjectizer-5.5 ne se cassent pas (en particulier, la s√©rie mbox est impl√©ment√©e dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">so_5_extra</a> et je ne veux tout simplement pas les casser). <br><br>  Deuxi√®mement, les messages peuvent √™tre envoy√©s non seulement aux mbox-s, derri√®re lesquels les agents sont cach√©s, mais aussi aux mchain-s.  Quels sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nos homologues des canaux CSP</a> .  Et jusqu'√† pr√©sent, les applications mentaient sans pointeurs suppl√©mentaires sur les fonctions.  Pour introduire un pointeur suppl√©mentaire dans chaque √©l√©ment de la cha√Æne de file d'attente d'application ... Vous pouvez, bien s√ªr, mais cela ressemble √† une solution assez co√ªteuse.  De plus, les impl√©mentations mchain elles-m√™mes n'ont jusqu'√† pr√©sent pas pr√©vu de situation dans laquelle le message extrait doit √™tre v√©rifi√© et √©ventuellement jet√©. <br><br>  Si vous essayez de r√©sumer tous les probl√®mes d√©crits ci-dessus, le principal probl√®me de cette approche est qu'il n'est pas si facile de faire son impl√©mentation de sorte qu'elle soit bon march√© pour les cas o√π les messages de rappel ne sont pas utilis√©s. <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais qu'en est-il de l'annulation garantie des messages en attente? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je crains que le probl√®me d'origine ne se soit perdu dans la jungle des d√©tails techniques. </font><font style="vertical-align: inherit;">Supposons qu'il y ait des messages r√©vocables, comment l'annulation des messages en attente / p√©riodiques se produira-t-elle? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, comme on dit, des options sont possibles. </font><font style="vertical-align: inherit;">Par exemple, travailler avec des messages en attente / p√©riodiques peut faire partie de la fonctionnalit√© revocable_handle_t &lt;M&gt;:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_mesage&gt; msg; msg.send_delayed(target, <span class="hljs-number"><span class="hljs-number">15</span></span>s, ...); ... msg.revoke();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ou vous pouvez cr√©er au-dessus de revocable_handle_t &lt;M&gt; une classe d'assistance suppl√©mentaire cancelable_timer_t &lt;M&gt;, qui fournira les m√©thodes send_delayed / send_periodic. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Point blanc: demandes synchrones </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5 prend en charge non seulement l'interaction asynchrone entre les entit√©s du programme (en envoyant des messages √† mbox et mchain), mais √©galement l'interaction synchrone via request_value / request_future. </font><font style="vertical-align: inherit;">Cette interaction synchrone ne fonctionne pas uniquement pour les agents.</font></font> C'est-√†-dire<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez non seulement envoyer une demande synchrone √† un agent via sa mbox. </font><font style="vertical-align: inherit;">Dans le cas de mchains, vous pouvez √©galement effectuer des requ√™tes synchrones, par exemple, vers un autre thread de travail, sur lequel receive () ou select () a √©t√© appel√© pour mchain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, il n'est toujours pas clair s'il devrait √™tre autoris√© √† utiliser des demandes synchrones en conjonction avec des messages r√©vocables. </font><font style="vertical-align: inherit;">D'une part, cela a peut-√™tre un sens. </font><font style="vertical-align: inherit;">Et cela peut ressembler, par exemple, √† ceci:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_request&gt; msg; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = msg.request_future&lt;my_reply&gt;(target, ...); ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(some_condition) msg.revoke(); ... f.get(); <span class="hljs-comment"><span class="hljs-comment">//      revoke().</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D'un autre c√¥t√©, il y a encore beaucoup de messages incompr√©hensibles avec des messages de rappel, donc la question de l'interaction synchrone a √©t√© report√©e √† des temps meilleurs. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Choisissez, mais soyez prudent. </font><font style="vertical-align: inherit;">Mais choisissez</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a donc une compr√©hension du probl√®me. </font><font style="vertical-align: inherit;">Il existe deux options pour le r√©soudre. </font><font style="vertical-align: inherit;">Ce qui pour le moment semble r√©alisable. </font><font style="vertical-align: inherit;">Mais ils diff√®rent consid√©rablement dans le niveau de commodit√© offert √† l'utilisateur, et encore plus fortement dans le co√ªt de mise en ≈ìuvre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez choisir entre ces deux options. </font><font style="vertical-align: inherit;">Ou trouver autre chose. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle est la difficult√© de choisir? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La difficult√© est que SObjectizer est un framework gratuit. </font><font style="vertical-align: inherit;">Il ne nous apporte pas directement d'argent. </font><font style="vertical-align: inherit;">Nous le faisons, comme on dit, pour le n√¥tre. </font><font style="vertical-align: inherit;">Par cons√©quent, uniquement √† partir des pr√©f√©rences √©conomiques, une option plus simple et plus rapide √† mettre en ≈ìuvre est plus rentable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais, d'autre part, tout n'est pas mesur√© en argent, et √† long terme, un outil bien fait, dont les caract√©ristiques sont normalement li√©es les unes aux autres, est meilleur qu'un patchwork de patchs coll√©s ensemble. La qualit√© est √©valu√©e √† la fois par les utilisateurs et par nous-m√™mes, lorsque nous accompagnons ensuite notre d√©veloppement et y ajoutons de nouvelles fonctionnalit√©s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, le choix va en fait entre les b√©n√©fices √† court terme et les perspectives √† long terme. Certes, dans le monde moderne, les outils C ++ avec des perspectives √† long terme sont en quelque sorte brumeux. Ce qui rend le choix encore plus difficile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est dans de telles conditions que vous devez choisir. Attention Mais choisissez.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet article, nous avons essay√© de montrer un peu le processus de conception et de mise en ≈ìuvre de nouvelles fonctionnalit√©s dans notre framework. </font><font style="vertical-align: inherit;">Un tel processus se d√©roule r√©guli√®rement avec nous. </font><font style="vertical-align: inherit;">Plus t√¥t souvent parce que </font><font style="vertical-align: inherit;">En 2014-2016, SObjectizer s'est d√©velopp√© beaucoup plus activement. </font><font style="vertical-align: inherit;">Maintenant, le rythme de sortie des nouvelles versions a diminu√©. </font><font style="vertical-align: inherit;">Ce qui est objectif, notamment parce que l'ajout de nouvelles fonctionnalit√©s sans rien casser, cela devient plus difficile √† chaque nouvelle version. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'esp√®re que c'√©tait int√©ressant de regarder dans les coulisses pour nous.</font></font> Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423879/">https://habr.com/ru/post/fr423879/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423869/index.html">L'avenir de l'emploi. L'essentiel du rapport du Forum √©conomique mondial</a></li>
<li><a href="../fr423871/index.html">Nous r√©solvons un probl√®me logique pour les √©tudiants en SQL</a></li>
<li><a href="../fr423873/index.html">Pr√©sentation de l'imprimante 3D PICASO 3D Designer X</a></li>
<li><a href="../fr423875/index.html">Stockage d'un grand nombre de fichiers</a></li>
<li><a href="../fr423877/index.html">29-31 octobre: ‚Äã‚Äãcr√©ation d'un cluster Kubernetes pr√™t pour la production</a></li>
<li><a href="../fr423881/index.html">Quels √©taient les soudeurs pour l'optique (deuxi√®me partie)</a></li>
<li><a href="../fr423885/index.html">Une invitation √† un spectacle de lumi√®re et un petit initi√© de la future plateforme Circle of Light √† Moscou</a></li>
<li><a href="../fr423889/index.html">Ma d√©ception dans le logiciel</a></li>
<li><a href="../fr423891/index.html">Arbres d'expression de d√©veloppement d'entreprise</a></li>
<li><a href="../fr423893/index.html">Hello World pour recevoir des donn√©es d'un appareil Bluetooth (BLE) via C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>