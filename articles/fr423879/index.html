<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>#⃣ ⬆️ 🧀 Est-il facile d'ajouter de nouvelles fonctionnalités à l'ancien framework? Farine de choix sur l'exemple du développement de SObjectizer 🤣 🕯️ 💑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Développer un cadre gratuit pour les besoins des développeurs est un sujet spécifique. Si en même temps le cadre vit et se développe assez longtemps, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Est-il facile d'ajouter de nouvelles fonctionnalités à l'ancien framework? Farine de choix sur l'exemple du développement de SObjectizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423879/"><img src="https://habrastorage.org/webt/en/lw/bb/enlwbb8hjnjmprjbfysbwsnejiy.jpeg"><br><br>  Développer un cadre gratuit pour les besoins des développeurs est un sujet spécifique.  Si en même temps le cadre vit et se développe assez longtemps, alors les spécificités sont ajoutées.  Aujourd'hui, je vais essayer de le montrer en utilisant un exemple de tentative d'extension de la fonctionnalité d'un framework "acteur" pour C ++ appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> . <br><br>  Le fait est que ce cadre est déjà assez ancien, il a radicalement changé plusieurs fois.  Même son incarnation actuelle, SObjectizer-5, a subi de nombreux changements, graves et non.  De plus, nous sommes assez sensibles à la compatibilité et introduire des changements qui cassent la compatibilité est une étape trop sérieuse pour que nous décidions simplement. <br><br>  En ce moment, nous devons décider comment ajouter une nouvelle fonctionnalité à la prochaine version.  Dans le processus de recherche d'une solution appropriée, deux options sont apparues.  Les deux semblent assez réalisables.  Mais ils sont très différents les uns des autres.  Tant en termes de complexité et de complexité de mise en œuvre que dans son «apparence».  C'est-à-dire  ce que le développeur traitera sera différent dans chacune des options.  Probablement même fondamentalement différent. <br><br>  Et maintenant, en tant que développeurs du framework, nous devons faire un choix en faveur de l'une ou l'autre solution.  Ou bien il faut admettre qu’aucune d’elles n’est satisfaisante et qu’il faut donc inventer autre chose.  De telles décisions au cours de l'histoire de SObjectizer ont dû être prises plus d'une fois.  Si quelqu'un est intéressé à se sentir à la place du développeur d'un tel cadre, vous êtes le bienvenu chez cat. <br><a name="habracut"></a><br><h1>  Problème d'origine </h1><br>  Donc, brièvement l'essence du problème d'origine.  Dès le début de son existence, SObjectizer avait la caractéristique suivante: un message de temporisation n'est pas si facile à annuler.  Sous la minuterie, on comprendra tout d'abord un message différé.  C'est-à-dire  un message qui ne doit pas être envoyé immédiatement au destinataire, mais après un certain temps.  Par exemple, nous faisons send_delayed avec une pause de 1s.  Cela signifie qu'en réalité le message sera envoyé par le temporisateur 1s après l'appel send_delayed. <br><br>  Un message en attente peut, en principe, être annulé.  Si le message est toujours en possession de la minuterie, le message après l'annulation n'ira nulle part.  Il sera lancé par la minuterie et c'est tout.  Mais si le temporisateur a déjà envoyé un message et qu'il se trouve maintenant dans la file d'attente des demandes de l'agent récepteur, l'annulation du temporisateur ne fonctionnera pas.  Il n'existe aucun mécanisme dans SObjectizer pour supprimer un message de la file d'attente des applications. <br><br>  Le problème est aggravé par au moins deux facteurs. <br><br>  Premièrement, SObjectizer prend en charge la livraison en mode 1: N, c'est-à-dire  si le message a été envoyé à la mbox multi-consommateurs, le message ne sera pas dans une file d'attente, mais dans plusieurs files d'attente pour N destinataires à la fois. <br><br>  Deuxièmement, dans SObjectizer, le mécanisme de répartition est utilisé et les répartiteurs peuvent être très différents, y compris ceux écrits par l'utilisateur pour ses besoins spécifiques.  Les files d'attente de demandes sont gérées par des répartiteurs.  Et dans l'interface du répartiteur, il n'y a aucune fonctionnalité pour retirer une application qui a déjà été transférée au répartiteur.  Mais même si de telles fonctionnalités étaient intégrées dans l'interface, il est loin d'être certain qu'elles pourraient être mises en œuvre efficacement dans tous les cas.  Sans oublier le fait qu'une telle fonctionnalité augmenterait la complexité du développement de nouveaux répartiteurs. <br><br>  En général, objectivement, si le temporisateur a déjà envoyé un message en attente au (x) destinataire (s), alors forcer SObjectizer à ne pas remettre cette instance du message est actuellement impossible. <br><blockquote>  En fait, ce problème est également pertinent pour les messages périodiques (c'est-à-dire les messages que le temporisateur doit envoyer périodiquement à des intervalles de temps prédéterminés).  Mais en pratique, l'annulation de messages périodiques est beaucoup moins nécessaire que l'annulation d'un message en attente.  C'est du moins le cas dans notre pratique. </blockquote><h2>  Que peut-on faire maintenant? </h2><br>  Donc, ce problème n'est pas nouveau et pendant longtemps il y a des recommandations sur la façon de le traiter. <br><br><h3>  Identifiant unique dans le message en attente </h3><br>  Le moyen le plus simple est de tenir un compteur.  L'agent dispose d'un compteur; lors de l'envoi d'un message en attente, la valeur actuelle du compteur est envoyée dans le message.  Lorsqu'un message est annulé, le compteur de l'agent est incrémenté.  A la réception du message, la valeur actuelle du compteur dans l'agent est comparée à la valeur du message.  Si les valeurs ne correspondent pas, le message est rejeté: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delayed_msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id_; ... }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> expected_msg_id_{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> timer_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_some_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . //   send_periodic, ..    //  timer_id   . timer_ = so_5::send_periodic&lt;delayed_msg&gt;(*this, 25s, //     . 0s, //    . //      delayed_msg, //      id   . ++expected_msg_id_, ... //  . ); ... } void on_cancel_event() { //   ,        //   .   : timer_.reset(); //     . ++expected_msg_id_; //   id-. ... } void on_delayed_msg(mhood_t&lt;delayed_msg&gt; cmd) { //     id    //  . if(expected_msg_id_ == cmd-&gt;id_) { ... //  . } } };</span></span></code> </pre> <br>  Le problème avec cette méthode est que le développeur d'agent doit être intrigué par la maintenance de ces compteurs.  Et si en tant que message différé nous devons envoyer le message de quelqu'un d'autre que quelqu'un d'autre a fait et dans lequel il n'y a pas de champ id_, alors nous nous trouvons dans une situation difficile. <br><br>  Bien que, d'autre part, c'est la manière la plus efficace qui existe actuellement. <br><br><h3>  Utiliser une mbox unique pour les messages retardés </h3><br>  Une autre méthode qui fonctionne bien consiste à utiliser une boîte aux lettres unique (mbox) pour un message différé.  Dans ce cas, nous créons une nouvelle mbox pour chaque message en attente, nous y abonnons et envoyons le message en attente à cette mbox.  Lorsqu'un message doit être annulé, nous supprimons simplement les abonnements mbox. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delayed_msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//   id_   . }; so_5::mbox_t timer_mbox_; //   . so_5::timer_id_t timer_; void on_some_event() { //        mbox //     . timer_mbox_ = so_environment().create_mbox(); some_state.event(time_mbox_, ...); another_state.event(time_mbox_, ...); ... //    . timer_ = so_5::send_delayed&lt;delayed_msg&gt;( so_environment(), timer_mbox_, //     . 25s, 0s, ... //    delayed_msg. ); } void on_cancel_event() { //        mbox. timer_.reset(); so_drop_subscription_for_all_states(timer_mbox_); } void on_delayed_msg(mhood_t&lt;delayed_msg&gt; cmd) { //     ,   //    . ... } };</span></span></code> </pre> <br>  Cette méthode peut déjà fonctionner avec les messages d'autres personnes, à l'intérieur desquels il n'y a pas d'identifiant unique.  Mais cela nécessite également du travail et de l'attention de la part du développeur. <br><br>  Par exemple, dans le mode de réalisation ci-dessus, il n'y a aucune protection contre le fait qu'un message en attente a déjà été envoyé plus tôt.  Dans le bon sens, avant d'envoyer un nouveau message en attente, vous devez toujours effectuer des actions de on_cancel_event (), sinon l'agent aura des abonnements inutiles pour cela. <br><br><h2>  Pourquoi ce problème n'a-t-il pas été résolu auparavant? </h2><br>  Tout est assez simple ici: en fait, ce n'est pas un problème aussi grave qu'il y paraît.  Au moins dans la vraie vie, vous n'avez pas à y faire face souvent.  Habituellement, les messages en attente et périodiques ne sont pas du tout annulés (c'est pourquoi, en passant, la fonction send_delayed ne renvoie pas timer_id).  Et lorsque le besoin d'annulation survient, vous pouvez utiliser l'une des méthodes décrites ci-dessus.  Ou même en utiliser un autre.  Par exemple, créez des agents distincts qui traiteront un message en attente.  Ces agents peuvent être désinscrits lorsqu'un message en attente doit être annulé. <br><br>  Ainsi, dans le contexte des autres tâches qui nous ont été confrontées, la simplification de l'annulation garantie d'un message en attente n'était pas une priorité au point de consacrer nos ressources à la résolution de ce problème. <br><br><h2>  Pourquoi le problème est-il pertinent maintenant? </h2><br>  Ici, tout est aussi simple.  D'une part, les mains ont finalement atteint. <br><br>  D'un autre côté, lorsque de nouvelles personnes qui n'avaient pas d'expérience avec lui commencent à utiliser SObjectizer, cette fonctionnalité avec l'annulation des temporisations les surprend grandement.  Pas si agréablement surprenant.  Et si oui, alors je voudrais minimiser les impressions négatives de la connaissance de notre outil. <br><br>  De plus, nous avions nos propres tâches, nous n'avions pas besoin d'annuler constamment les messages en attente.  Et les nouveaux utilisateurs ont leurs propres tâches, peut-être que tout est inversé. <br><br><h1>  Nouvelle déclaration du problème </h1><br>  Presque immédiatement, dès que l’on a envisagé la possibilité d’une «annulation de la temporisation garantie», j’ai pensé que la tâche pourrait être élargie.  Vous pouvez essayer de résoudre le problème du rappel de l'un des messages précédemment envoyés, pas nécessairement retardé et périodique. <br><br>  De temps en temps, cette opportunité est recherchée.  Par exemple, imaginez que nous avons plusieurs agents en interaction de deux types: entry_point (accepte les demandes des clients) et processeur (traite les demandes): <br><br><img src="https://habrastorage.org/webt/s7/mo/jp/s7mojpeyu9s6prshykrqxul14he.png"><br><br>  Les agents Entry_point envoient des requêtes à l'agent processeur, qui les traite autant que possible et répond aux agents Entry_point.  Mais parfois, entry_point peut constater que le traitement d'une demande envoyée précédemment n'est plus nécessaire.  Par exemple, le client a envoyé une commande d'annulation ou le client est «tombé» et vous n'avez plus besoin de traiter ses demandes.  Maintenant, si les messages de demande sont mis en file d'attente par l'agent de processeur, vous ne pouvez pas les rappeler.  Et ce serait utile. <br><br>  Par conséquent, l'approche actuelle pour résoudre le problème de «l'annulation garantie de la minuterie» est mise en œuvre avec précision en tant que prise en charge des «messages de rappel».  Nous envoyons tout message d'une manière spéciale, nous obtenons une poignée sous la main, avec laquelle vous pouvez ensuite rappeler le message.  Et ce n'est pas si important qu'un message régulier ou retardé réponde. <br><br><h1>  Une tentative de proposer la mise en place de "messages de rappel" </h1><br>  Vous devez donc introduire le concept de "message de rappel" et prendre en charge ce concept dans SObjectizer.  Et donc, pour rester dans la branche 5.5.  La première version de ce fil, 5.5.0, est sortie il y a près de quatre ans, en octobre 2014.  Depuis lors, il n'y a eu aucun changement majeur dans 5.5.  Les projets qui ont déjà basculé ou démarré immédiatement sur SObjectize-5.5 peuvent passer à de nouvelles versions dans la branche 5.5 sans aucun problème.  Cette compatibilité doit être maintenue cette fois. <br><br>  En général, tout est simple: il faut prendre et faire. <br><br><h2>  Comment faire clairement </h2><br>  Après la première approche du problème, deux choses sont devenues claires au sujet de la mise en œuvre des «messages de rappel». <br><br><h3>  Drapeau atomique et sa vérification avant le traitement du message </h3><br>  Premièrement, il est évident que dans le cadre de l'architecture SObjectizer-5.5 actuelle (et peut-être même plus globalement: dans le cadre des principes de SObjectizer-5 lui-même), il est impossible de supprimer des messages des files d'attente de requêtes du répartiteur, où les messages attendent que les agents récepteurs les traitent.  Essayer de faire cela tuera toute l'idée de répartiteurs hétérogènes, que même l'utilisateur peut faire lui-même, selon les spécificités de sa tâche (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">celle-ci</a> ).  De plus, dans le cas de l'envoi d'un message en mode 1: N, où N sera grand, il sera coûteux de conserver une liste de pointeurs vers une instance du message envoyé dans toutes les files d'attente. <br><br>  Cela signifie qu'avec le message, une sorte d'indicateur atomique doit être transmis, qui devra être analysé immédiatement après la suppression du message de la file d'attente des demandes, mais avant l'envoi du message pour traitement à l'agent récepteur.  C'est-à-dire  le message entre dans la file d'attente et n'est retiré de nulle part.  Mais lorsque le tour arrive au message, son drapeau est vérifié.  Et si le drapeau indique que le message a été retiré, le message n'est pas traité. <br><br>  En conséquence, le rappel de message lui-même consiste à définir une valeur spéciale pour le drapeau atomique à l'intérieur du message. <br><br><h3>  Objet &lt;M&gt; Revocable_handle_t </h3><br>  Deuxièmement, jusqu'à présent (?) Il est évident que pour envoyer un message révocable, non pas les méthodes habituelles d'envoi de messages doivent être utilisées, mais un objet spécial sous le nom conditionnel revocable_handle_t. <br><br>  Pour envoyer un message révocable, l'utilisateur doit créer une instance de revocable_handle_t, puis appeler la méthode d'envoi sur cette instance.  Et si le message doit être rappelé, cela se fait à l'aide de la méthode de révocation.  Quelque chose comme: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_message</span></span></span><span class="hljs-class"> {</span></span>...}; ... so_5::<span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_message&gt; msg; <span class="hljs-comment"><span class="hljs-comment">//    . msg.send(target, //  . ... //    my_message. ); ... //   . msg.revoke();</span></span></code> </pre> <br>  Il n'y a pas encore de détails clairs sur la mise en œuvre de revocable_handle_t, ce qui n'est pas surprenant, car  le mécanisme de travail des messages de rappel n'a pas encore été sélectionné.  Mais le principe de travail est que dans revocable_handle_t un lien intelligent est enregistré dans le message envoyé et dans le drapeau atomique pour celui-ci.  La méthode revoke () tente de remplacer la valeur de l'indicateur.  Si cela réussit, le message, après extraction de la file d'attente de commandes, ne sera plus traité. <br><br><h3>  Avec quoi il ne sera pas ami </h3><br>  Malheureusement, il y a deux ou trois choses avec lesquelles le rappel des messages ne peut pas être correctement lié.  Tout simplement parce que le message retiré continue de rester dans les files d'attente où il est déjà arrivé. <br><br><h4>  message_limits </h4><br>  Une caractéristique aussi importante de SObjectizer que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">message_limits</a> est conçue pour protéger les agents contre les surcharges.  Message_limits fonctionne en fonction du nombre de messages dans la file d'attente.  Mis en file d'attente un message - augmenté le compteur.  Sorti de la ligne - réduit. <br><br>  Parce que  lorsqu'un message est révoqué, il reste dans la file d'attente, puis message_limits n'affecte pas la réponse du message.  Par conséquent, il peut s'avérer que la file d'attente a une limite sur le nombre de messages de type M, mais tous ont été rappelés.  En fait, aucun d'entre eux ne sera traité.  Mais la mise en file d'attente d'un nouveau message de type M ne fonctionnera pas, car  la limite est dépassée. <br><br>  La situation n'est pas bonne.  Mais comment s'en sortir?  Ce n'est pas clair. <br><br><h4>  chaînes de file d'attente fixes </h4><br>  Dans SObjectizer, un message peut être envoyé non seulement à mbox, mais aussi à mchain (c'est notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analogue du canal CSP</a> ).  Et les chaînes peuvent avoir une taille fixe pour leurs files d'attente.  Une tentative de mettre un nouveau message pour mchain avec une taille fixe en mchain complet devrait conduire à une sorte de réaction.  Par exemple, en attendant la libération d'espace dans la file d'attente.  Ou pour pousser le message le plus ancien. <br><br>  Dans le cas d'un rappel de message, il restera dans la file d'attente mchain.  Il s'avère que le message n'est plus nécessaire, mais il prend de la place dans la file d'attente mchain.  Et empêche l'envoi de nouveaux messages à mchain. <br><br>  La même mauvaise situation qu'avec message_limits.  Et encore une fois, il n'est pas clair comment cela peut être résolu. <br><br><h2>  Ce qui n'est pas clair comment faire </h2><br>  Nous avons donc eu le choix entre deux (jusqu'à présent?) Options pour implémenter les messages de rappel.  La première option est simple à implémenter et ne nécessite pas de modification des abats de SObjectizer.  La deuxième option est beaucoup plus compliquée, mais le destinataire du message ne sait même pas qu'il s'agit de messages révocables.  Nous allons brièvement examiner chacun d'eux. <br><br><h3>  Recevoir des messages révocables comme revocable_t &lt;M&gt; </h3><br>  La première solution, qui semble, d'une part, faisable et, d'autre part, assez pratique, est l'introduction d'un wrapper spécial revocable_t &lt;M&gt;.  Lorsque l'utilisateur envoie un message révocable de type M via revocable_handle_t &lt;M&gt;, ce n'est pas le message M qui est envoyé, mais le message M à l'intérieur du wrapper spécial revocable_t &lt;M&gt;.  Et, en conséquence, l'utilisateur ne recevra pas et ne traitera pas le message de type M, mais le message revocable_t &lt;M&gt;.  Par exemple, de cette façon: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> {</span></span> ... }; <span class="hljs-comment"><span class="hljs-comment">// ,    . void so_define_agent() override { //   . so_subscribe_self().event( //     ,    //   . [this](mhood_t&lt; revocable_t&lt;request&gt; &gt; cmd) { // ,      . cmd-&gt;try_handle([this](mhood_t&lt;request&gt; msg) { ... }); }); ... } ... };</span></span></code> </pre> <br>  La méthode revocable_t &lt;M&gt; :: try_handle () vérifie la valeur du drapeau atomique et, si le message n'est pas rappelé, appelle la fonction lambda qui lui est passée.  Si le message est retiré, try_handle () ne fait rien. <br><br><h4>  Avantages et inconvénients de cette approche </h4><br>  Le principal avantage est que ce voyage est facile à mettre en œuvre (du moins jusqu'à présent, il semble).  En fait, revocable_handle_t &lt;M&gt; et revocable_t &lt;M&gt; ne seront qu'un complément subtil au SObjectizer. <br><br>  Une intervention dans les internes de SObjectizer peut être nécessaire pour se faire des amis revocable_t et mutable_msg.  Le fait est que dans SObjectizer il y a le concept de messages immuables (ils peuvent être envoyés à la fois en mode 1: 1 et en mode 1: N).  Et il y a le concept de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">messages mutables</a> qui ne peuvent être envoyés qu'en mode 1: 1.  Dans ce cas, SObjectizer traite de manière spéciale le marqueur mutable_msg &lt;M&gt; et effectue les vérifications correspondantes au moment de l'exécution.  Dans le cas de revocable_t &lt;mutable_msg &lt;M&gt;&gt;, vous devrez apprendre à SObjectizer à traiter cette construction comme mutable_msg &lt;M&gt;. <br><br>  Un autre avantage est que le surcoût supplémentaire (à la fois sur les métadonnées du message révocable et sur la vérification du drapeau atomique) ne sera que dans des endroits où vous ne pouvez pas vous en passer.  Lorsque les messages de rappel ne sont pas utilisés, il n'y aura pas de surcharge supplémentaire du tout. <br><br>  Mais le principal inconvénient est idéologique.  Dans cette approche, le fait d'utiliser des messages révocables affecte à la fois l'expéditeur (en utilisant revocable_handle_t &lt;M&gt;) et le destinataire (en utilisant revocable_t &lt;M&gt;).  Mais le destinataire n'a tout simplement pas besoin de savoir qu'il reçoit des messages de rappel.  De plus, en tant que destinataire, vous pouvez avoir un agent tiers prêt à l'emploi qui est écrit sans revocable_t &lt;M&gt;. <br><br>  De plus, des questions idéologiques subsistent, par exemple sur la possibilité de transmettre de tels messages.  Mais, selon les premières estimations, ces problèmes sont résolus. <br><br><h3>  Recevoir des messages de rappel sous forme de messages réguliers </h3><br>  La seconde approche consiste à ne voir que le message de type M côté récepteur et à ne pas avoir une idée de l'existence de revocable_handle_t &lt;M&gt; et revocable_t &lt;M&gt;.  C'est-à-dire  si le processeur doit recevoir une demande, il ne doit voir qu'une demande, sans aucun wrapper supplémentaire. <br><br>  En fait, on ne peut pas se passer de certains wrappers dans cette approche, mais ils seront cachés à l'intérieur du SObjectizer et l'utilisateur ne devrait pas les voir.  Une fois l'application récupérée de la file d'attente, SObjectizer déterminera par lui-même qu'il s'agit d'un message révocable spécialement encapsulé, vérifiera l'indicateur de la pertinence du message et développera le message s'il est toujours pertinent.  Ensuite, il enverra un message à l'agent pour traitement comme s'il s'agissait d'un message normal. <br><br><h4>  Avantages et inconvénients de cette approche </h4><br>  Le principal avantage de cette approche est évident - le destinataire du message ne sait pas avec quels messages il travaille.  Cela permet à l'expéditeur du message de retirer calmement les messages de tous les agents, même ceux qui ont été écrits par d'autres développeurs. <br><br>  Un autre avantage important est la capacité à s'intégrer au mécanisme de traçage de remise des messages ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici le rôle de ce mécanisme est décrit plus en détail</a> ).  C'est-à-dire  si msg_tracing est activé et que l'expéditeur retire le message, des traces de cela peuvent être trouvées dans le journal msg_tracing.  Ce qui est très pratique lors du débogage. <br><br>  Mais le principal inconvénient est la complexité de la mise en œuvre de cette approche.  À laquelle plusieurs facteurs devront être pris en compte. <br><br>  Tout d'abord, les frais généraux.  Toutes sortes de choses. <br><br>  Supposons que vous puissiez créer un indicateur spécial dans un message qui indique si ce message est révocable ou non.  Vérifiez ensuite cet indicateur avant de commencer à traiter chaque message.  En gros, un autre if est ajouté au mécanisme de remise des messages, qui fonctionnera lors du traitement de chaque (!) Message. <br><br>  Je suis sûr que dans les applications réelles, la perte sur ce point sera à peine perceptible.  Mais le recul des benchmarks synthétiques apparaîtra certainement.  De plus, plus le repère est abstrait, moins il fait de travail réel, plus il s'enfonce.  Et c'est mauvais d'un point de vue marketing, car  plusieurs personnes tirent des conclusions sur le cadre en termes de repères synthétiques.  Et ils le font spécifiquement: ne pas comprendre de quel type de référence il s'agit, qu'il montre essentiellement sur quel matériel il fonctionne, mais en comparant les totaux avec les performances d'un outil spécialisé, dans un autre scénario, sur un autre matériel, etc. ., etc. <br><br>  En général, puisque nous créons un cadre universel, qui, en fin de compte, est jugé par des nombres abstraits dans des repères abstraits, nous ne voulons pas perdre, disons, 5% des performances du mécanisme de livraison de <i>tous les</i> messages en raison de l'ajout d'une fonctionnalité qui ne prend que du temps de temps en temps et pas à tous les utilisateurs. <br><br>  Par conséquent, vous devez vous assurer que lors de l'envoi du message au destinataire, SObjectizer comprend que lorsque vous extrayez le message, vous devez le gérer d'une manière spéciale.  En principe, lorsqu'un message est remis à un agent, SObjectizer stocke avec le message un pointeur vers une fonction qui sera utilisée lors du traitement du message.  Cela est nécessaire maintenant pour gérer les messages asynchrones et les demandes synchrones de différentes manières.  En fait, voici à quoi ressemble la demande de message adressée à l'agent: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">execution_demand_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//! Receiver of demand. agent_t * m_receiver; //! Optional message limit for that message. const message_limit::control_block_t * m_limit; //! ID of mbox. mbox_id_t m_mbox_id; //! Type of the message. std::type_index m_msg_type; //! Event incident. message_ref_t m_message_ref; //! Demand handler. demand_handler_pfn_t m_demand_handler; ... };</span></span></code> </pre> <br>  Où demand_handler_pfn_t est un pointeur de fonction régulier: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">demand_handler_pfn_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">current_thread_id_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">execution_demand_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; )</span></span></span></span>;</code> </pre><br>  Le même mécanisme peut également être utilisé pour traiter spécialement le message retiré.  C'est-à-dire  lorsque mbox envoie un message à l'agent, l'agent sait si un message asynchrone ou une demande synchrone lui est envoyé.  De même, un agent peut recevoir un message de rappel asynchrone d'une manière spéciale.  Et l'agent enregistre, avec le message, un pointeur sur une fonction qui sait comment il doit gérer les messages révoqués. <br><br>  Tout semble aller bien, mais il y a deux gros "mais" ... :( <br><br>  Premièrement, l'interface mbox existante (à savoir la classe <a href="">abstract_message_mbox_t</a> ) ne dispose d'aucune méthode pour envoyer des messages de rappel.  Cette interface doit donc être étendue.  Et pour que les implémentations mbox d'autres personnes liées à abstract_message_box_t de SObjectizer-5.5 ne se cassent pas (en particulier, la série mbox est implémentée dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">so_5_extra</a> et je ne veux tout simplement pas les casser). <br><br>  Deuxièmement, les messages peuvent être envoyés non seulement aux mbox-s, derrière lesquels les agents sont cachés, mais aussi aux mchain-s.  Quels sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nos homologues des canaux CSP</a> .  Et jusqu'à présent, les applications mentaient sans pointeurs supplémentaires sur les fonctions.  Pour introduire un pointeur supplémentaire dans chaque élément de la chaîne de file d'attente d'application ... Vous pouvez, bien sûr, mais cela ressemble à une solution assez coûteuse.  De plus, les implémentations mchain elles-mêmes n'ont jusqu'à présent pas prévu de situation dans laquelle le message extrait doit être vérifié et éventuellement jeté. <br><br>  Si vous essayez de résumer tous les problèmes décrits ci-dessus, le principal problème de cette approche est qu'il n'est pas si facile de faire son implémentation de sorte qu'elle soit bon marché pour les cas où les messages de rappel ne sont pas utilisés. <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais qu'en est-il de l'annulation garantie des messages en attente? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je crains que le problème d'origine ne se soit perdu dans la jungle des détails techniques. </font><font style="vertical-align: inherit;">Supposons qu'il y ait des messages révocables, comment l'annulation des messages en attente / périodiques se produira-t-elle? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, comme on dit, des options sont possibles. </font><font style="vertical-align: inherit;">Par exemple, travailler avec des messages en attente / périodiques peut faire partie de la fonctionnalité revocable_handle_t &lt;M&gt;:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_mesage&gt; msg; msg.send_delayed(target, <span class="hljs-number"><span class="hljs-number">15</span></span>s, ...); ... msg.revoke();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ou vous pouvez créer au-dessus de revocable_handle_t &lt;M&gt; une classe d'assistance supplémentaire cancelable_timer_t &lt;M&gt;, qui fournira les méthodes send_delayed / send_periodic. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Point blanc: demandes synchrones </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5 prend en charge non seulement l'interaction asynchrone entre les entités du programme (en envoyant des messages à mbox et mchain), mais également l'interaction synchrone via request_value / request_future. </font><font style="vertical-align: inherit;">Cette interaction synchrone ne fonctionne pas uniquement pour les agents.</font></font> C'est-à-dire<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez non seulement envoyer une demande synchrone à un agent via sa mbox. </font><font style="vertical-align: inherit;">Dans le cas de mchains, vous pouvez également effectuer des requêtes synchrones, par exemple, vers un autre thread de travail, sur lequel receive () ou select () a été appelé pour mchain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, il n'est toujours pas clair s'il devrait être autorisé à utiliser des demandes synchrones en conjonction avec des messages révocables. </font><font style="vertical-align: inherit;">D'une part, cela a peut-être un sens. </font><font style="vertical-align: inherit;">Et cela peut ressembler, par exemple, à ceci:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_request&gt; msg; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = msg.request_future&lt;my_reply&gt;(target, ...); ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(some_condition) msg.revoke(); ... f.get(); <span class="hljs-comment"><span class="hljs-comment">//      revoke().</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> D'un autre côté, il y a encore beaucoup de messages incompréhensibles avec des messages de rappel, donc la question de l'interaction synchrone a été reportée à des temps meilleurs. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Choisissez, mais soyez prudent. </font><font style="vertical-align: inherit;">Mais choisissez</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a donc une compréhension du problème. </font><font style="vertical-align: inherit;">Il existe deux options pour le résoudre. </font><font style="vertical-align: inherit;">Ce qui pour le moment semble réalisable. </font><font style="vertical-align: inherit;">Mais ils diffèrent considérablement dans le niveau de commodité offert à l'utilisateur, et encore plus fortement dans le coût de mise en œuvre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous devez choisir entre ces deux options. </font><font style="vertical-align: inherit;">Ou trouver autre chose. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelle est la difficulté de choisir? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La difficulté est que SObjectizer est un framework gratuit. </font><font style="vertical-align: inherit;">Il ne nous apporte pas directement d'argent. </font><font style="vertical-align: inherit;">Nous le faisons, comme on dit, pour le nôtre. </font><font style="vertical-align: inherit;">Par conséquent, uniquement à partir des préférences économiques, une option plus simple et plus rapide à mettre en œuvre est plus rentable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais, d'autre part, tout n'est pas mesuré en argent, et à long terme, un outil bien fait, dont les caractéristiques sont normalement liées les unes aux autres, est meilleur qu'un patchwork de patchs collés ensemble. La qualité est évaluée à la fois par les utilisateurs et par nous-mêmes, lorsque nous accompagnons ensuite notre développement et y ajoutons de nouvelles fonctionnalités. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, le choix va en fait entre les bénéfices à court terme et les perspectives à long terme. Certes, dans le monde moderne, les outils C ++ avec des perspectives à long terme sont en quelque sorte brumeux. Ce qui rend le choix encore plus difficile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est dans de telles conditions que vous devez choisir. Attention Mais choisissez.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans cet article, nous avons essayé de montrer un peu le processus de conception et de mise en œuvre de nouvelles fonctionnalités dans notre framework. </font><font style="vertical-align: inherit;">Un tel processus se déroule régulièrement avec nous. </font><font style="vertical-align: inherit;">Plus tôt souvent parce que </font><font style="vertical-align: inherit;">En 2014-2016, SObjectizer s'est développé beaucoup plus activement. </font><font style="vertical-align: inherit;">Maintenant, le rythme de sortie des nouvelles versions a diminué. </font><font style="vertical-align: inherit;">Ce qui est objectif, notamment parce que l'ajout de nouvelles fonctionnalités sans rien casser, cela devient plus difficile à chaque nouvelle version. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'espère que c'était intéressant de regarder dans les coulisses pour nous.</font></font> Merci de votre attention! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423879/">https://habr.com/ru/post/fr423879/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423869/index.html">L'avenir de l'emploi. L'essentiel du rapport du Forum économique mondial</a></li>
<li><a href="../fr423871/index.html">Nous résolvons un problème logique pour les étudiants en SQL</a></li>
<li><a href="../fr423873/index.html">Présentation de l'imprimante 3D PICASO 3D Designer X</a></li>
<li><a href="../fr423875/index.html">Stockage d'un grand nombre de fichiers</a></li>
<li><a href="../fr423877/index.html">29-31 octobre: ​​création d'un cluster Kubernetes prêt pour la production</a></li>
<li><a href="../fr423881/index.html">Quels étaient les soudeurs pour l'optique (deuxième partie)</a></li>
<li><a href="../fr423885/index.html">Une invitation à un spectacle de lumière et un petit initié de la future plateforme Circle of Light à Moscou</a></li>
<li><a href="../fr423889/index.html">Ma déception dans le logiciel</a></li>
<li><a href="../fr423891/index.html">Arbres d'expression de développement d'entreprise</a></li>
<li><a href="../fr423893/index.html">Hello World pour recevoir des données d'un appareil Bluetooth (BLE) via C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>