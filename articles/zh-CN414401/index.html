<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🔧 🤰 👨🏻‍🔬 Oracle数据库中的100,500种缓存方法 🚐 🔸 👩🏿‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="要说出什么是高速缓存，什么是结果高速缓存，如何在Oracle和其他数据库中进行创建，并不是很有趣并且很简单。 但是，当涉及到具体示例时，一切都呈现完全不同的颜色。 Alexander Tokarev （ shtock ）基于案例构建了有关Highload ++ 2017的报告。 正是基于这种情况，他...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Oracle数据库中的100,500种缓存方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/414401/"> 要说出什么是高速缓存，什么是结果高速缓存，如何在Oracle和其他数据库中进行创建，并不是很有趣并且很简单。 但是，当涉及到具体示例时，一切都呈现完全不同的颜色。  <strong>Alexander Tokarev</strong> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">shtock</a> ）基于案例构建了有关Highload ++ 2017的报告。 正是基于这种情况，他告诉了何时可以使用自制缓存，服务器端结果缓存的痛苦是什么，以及如何用客户端替换它，总的来说，他提出了许多有用的技巧来在Oracle中设置结果缓存。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hTCXaAKIArk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>关于演讲者：</strong> Alexander Tokarev在DataArt工作，处理与数据库有关的问题，包括从头开始构建系统和优化现有系统。 <br><br> 让我们从一些反问开始。 您是否使用过Oracle结果缓存？ 您是否认为Oracle是适合所有场合的数据库？ 根据亚历山大的经验，大多数人否定地回答最后一个问题， <strong>一百个梦想家有一个梦想家</strong> 。 但是由于他的信仰，进步正在前进。 <br><br> 顺便说一句，Oracle已经拥有14个数据库-到目前为止14个-未来将发生什么尚不清楚。 <br><br> 如前所述，所有问题和解决方案将通过具体案例进行说明。 这将是DataArt项目的两种情况，以及一个第三方示例。 <br><a name="habracut"></a><br><h2> 数据库缓存 <br></h2><br> 首先，哪些高速缓存位于数据库中。 这里的一切都很清楚： <br><br><ul><li> 缓冲区高速缓存-数据高速缓存-数据页/数据块的高速缓存； </li><li> 语句缓存-语句及其计划的缓存-查询计划的缓存； </li><li> 结果缓存-行结果缓存-查询中的行； </li><li> 操作系统缓存-操作系统缓存。 </li></ul><br> 而且，结果缓存一般仅在Oracle中使用。 他曾经在MySQL中工作，但后来被英勇地淘汰了。 在PostgreSQL中不存在，它仅以一种形式或另一种形式存在于第三方pgpool产品中。 <br><br><h2> 案例1：零售商库 <br></h2><br><img src="https://habrastorage.org/webt/qo/cq/t5/qocqt5zzctiqj1hh5n-6hc9skkm.jpeg"><br><br> 上面是我们随附的产品图-存储库（Oracle 11、20 Tb，300个用户），它包含某种沉闷的报告，其中每5000条数据行有350个独特的产品。 获得它大约花费了20分钟，用户为此感到难过。 <br><br><blockquote> 与其他所有人一样，此报告<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的演示文稿</a>可以在Highload ++会议站点上获得。 </blockquote><br> 该报告具有SELECT，JOIN和功能。 一个函数作为一个函数，一切都会好起来的，只有它计算出一个神秘的参数，称为“转移定价值”，它的作用时间为0.2 s-似乎什么都没有，但是它被调用的次数与表中的行数相同。 该函数具有400行SQL + PL / SQL，因为 该产品受到支持，因此很难进行更改。 <br><br> 出于相同的原因，不能使用result_cache。 <br><br><img src="https://habrastorage.org/webt/1o/u5/ct/1ou5ctbufxqrsme66mbz60bieuy.jpeg"><br><br> 为了解决该问题，我们使用<strong>带有手工缓存</strong>的标准<strong>方法</strong> ：照原样保留电路的前三个块，只需将sku_detail（）函数重命名为sku_full（）并分别声明一个关联数组： <br><br><ul><li> 关键是我们的SKU（商品）， <br></li><li> 值是计算出的转移转换价格。 <br></li></ul><br> 我们使cache（sku）函数显而易见：如果关联数组中没有此类id，则将启动我们的函数，结果将被缓存，保存并返回。 因此，如果这样的id是，那么这一切都不会发生。 实际上，我们有了<strong>按需缓存</strong> 。 <br><br> 因此，我们已将函数调用的数量减少到实际需要的数量。  <strong>报表处理时间减少到4分钟</strong> ，所有用户都感觉良好。 <br><br><h3>  <strong>手工缓存</strong> <br></h3><br> 从这张大型智能图片可以清楚地看出该系统的缺点和优势，这将是我们要解决的很多问题-这就是内存体系结构。 <br><br><img src="https://habrastorage.org/webt/ku/e4/2o/kue42onfhkjjpxxyk0klg0-at50.jpeg"><br><br> 重要的是要了解集合位于哪个存储区中。 它们被放置在称为PGA的存储区中。 在与数据库的每个连接上实例化<strong>程序全局区域</strong> 。 这是确定优点和缺点的原因，因为更多的连接-更多的内存，以及<strong>昂贵的内存，服务器</strong>和管理员都很温柔。 <br><br><img src="https://habrastorage.org/webt/7c/gi/hd/7cgihdigefzcded25cmfondxkcc.jpeg"><br><br><ul><li>  <strong>优点：</strong>一切工作都非常快，非常容易，不需要配置，进程间参与也没有麻烦。 <br></li><li>  <strong>缺点</strong>是可以理解的：如果项目中禁止使用存储的逻辑，则不能使用它们，没有自动失效的机制，并且由于缓存中的内存是在一个数据库会话（而不是实例）中分配的，因此其<strong>消耗被夸大了</strong> 。 此外，在连接池用例的情况下，如果每个会话应该有不同的缓存，则必须记住刷新缓存。 <br></li></ul><br> 基于物化视图和临时表的手工缓存还有其他选择，但是从它们来看，输入输出系统上的负担很大，因此在此不考虑它们。 它们更适用于其他数据库，在这些数据库中，通常通过将存储过程存储在某个中间表中并在访问繁重的请求之前从中获取数据来解决这些问题。 并且只有在未找到所需内容的情况下，才会调用初始请求。 <br><br><img src="https://habrastorage.org/webt/mh/8u/xg/mh8uxg2hjytjwrp0fbds1gvoc4k.jpeg"><br><br> 上面是对这种缓存问题的方法的说明，该方法用于获取MsSQL中的相关产品列表。 通常，该方法相对相似，但是就获取数据和主要填充而言，它在数据库内存中均不起作用，因此，它<strong>可能更慢</strong> 。 <br><br> 通常，积极使用自制的result_cache，但是数据库内result_cache是​​实现此任务的另一种方法。 它以及它如何无法快速获胜，我们将进一步考虑。 <br><br><h2> 案例2.财务文件处理 <br></h2><br> 因此，我们的第二种情况。 <br><br><img src="https://habrastorage.org/webt/dd/zn/wy/ddznwymy92vgt32eox6fvwanepq.jpeg"><br><br> 这是一个半自动化的财务文件处理系统-具有传统架构的沉闷企业，其中包括： <br><br><ul><li> 瘦客户 <br></li><li>  4,000个生活在世界各地的用户； <br></li><li> 平衡器 <br></li><li>  2个用于计算业务逻辑的JBoss； <br></li><li> 内存集群 <br></li><li> 核心Oracle； <br></li><li>  Oracle备份 <br></li></ul><br> 该系统的许多任务之一是<strong>建议</strong>的<strong>计算</strong> 。 <br><br><img src="https://habrastorage.org/webt/dm/rt/cf/dmrtcfcgvy2q94g-jl52qnhatbo.jpeg"><br><br> 对于某些未通过系统自动识别的指标的文档，有一些指标是由先前的客户文档，类似行业或相似的获利能力提供的，同时将指标与公认的价值进行比较，以免提供太多指标。 重要的是， <strong>文件是多语言的</strong> 。 <br><br> 用户选择所需的值，并为每个空行重复该操作。 <br><br> 简化后，该任务包括以下内容：文档以键值对的形式从不同的识别系统到达，并且参数在某处而不是某处被识别。 有必要确保最终用户可以处理文档并识别所有值。 该建议正是为了简化此任务，并考虑到： <br><br><ol><li> 多种语言-大约30种语言。 每种语言都有其自身的词干，同义词和其他功能。 </li><li> 该客户的先前数据，或者在没有该客户的情况下，来自同一行业的客户或利润相似的客户的数据。 </li></ol><br> 实际上，这大约是12条非常复杂的规则。 <br><br>  <strong>初始假设：</strong> <br><br><ul><li> 一次不超过100个用户； </li><li>  2-3列用于识别； </li><li>  100行。 </li></ul><br>  <strong>根本没有高负载</strong> -一切都很无聊。 <br><br> 因此，该发布了。 发生代码冻结，Java害怕触摸，处理文档至少需要5分钟。 <br><br> 他们来到数据库开发团队寻求帮助。 当然，因为<em>如果JVM的运行速度变慢，那么就需要更改或修复数据库</em> 。 <br><br><img src="https://habrastorage.org/webt/ae/q_/tm/aeq_tm3cua2tkk3ohgxl7rntova.jpeg"><br><br> 我们研究了文档，并意识到在键值对中，值经常重复-5-10次。 因此，我们决定使用数据库进行缓存，因为它已经过测试。 <br><br> 我们决定使用Oracle服务器端结果缓存，因为： <br><br><ol><li> 优化SQL的机会已经耗尽，因为它使用了Oracle全文搜索引擎。 <br></li><li> 缓存将用于重复的参数； <br></li><li> 由于大多数推荐数据使用全文索引，因此每小时都会重新计算一次； <br></li><li>  <strong>禁止使用PL / SQL</strong> 。 <br></li></ol><br><h3>  <strong>Oracle结果缓存</strong> <br></h3><br> 结果缓存-Oracle缓存结果-具有以下属性： <br><br><ul><li> 这是翻查所有查询结果的存储区； </li><li> 读取一致，并自动失效； </li><li> 对应用程序的更改最少。 您可以使应用程序根本不需要更改； </li><li> 红利-您可以缓存PL / SQL逻辑，但此处禁止这样做。 </li></ul><br>  <strong>如何启用？</strong> <br><br><h4> 方法1 <br></h4><br><img src="https://habrastorage.org/webt/qo/im/jv/qoimjvcbfclnfsp_pncn6uf-74g.jpeg"><br><br>  <strong>指定result_cache语句</strong>非常简单。 幻灯片显示结果标识符已出现。 因此，第一次执行查询时，数据库将做一些工作；在随后的执行过程中，在这种情况下，不需要任何工作。 一切都很好。 <br><br><h4> 方法2 <br></h4><br><img src="https://habrastorage.org/webt/5x/uy/d5/5xuyd5seajh5kshz1xmdvmd6fu0.jpeg"><br><br> 第二种方法允许应用程序开发人员不执行任何操作-这些就是所谓的注释。 我们为该表指示一个选中标记，该标记应将对它的请求放置在result_cache中。 因此，没有任何提示，我们不触摸应用程序，所有内容都已经在result_cache中。 <br><br><blockquote> 顺便说一句，如果查询引用了两个表，其中一个被标记为result_cache，而第二个没有标记，您会如何看待这种查询的结果呢？ <br><br> 答案是否定的，根本没有。 <br></blockquote><br> 为了对其进行缓存，参与查询的所有表都必须具有result_cache注释。 <br><br><h3>  <strong>依赖追踪</strong> <br></h3><br> 在相关视图中，您可以查看什么依赖项。 <br><br><img src="https://habrastorage.org/webt/ni/12/bp/ni12bpiy04zhswxncy1rsq1h29s.jpeg"><br><br> 在上面的示例中，JOIN查询是某个表，其中存在一个依赖性。 怎么了 因为Oracle不仅通过解析来确定依赖关系，而且还<strong>根据工作计划的结果来</strong>实现它。 <br><br> 在这种情况下，选择这种计划是因为仅使用了一个表，并且实际上通过外键约束将工作表链接到雇员表。 如果我们删除允许进行此联接消除转换的外键约束，则将看到两个依赖关系，因为计划将以这种方式进行更改。 <br><br>  <strong>Oracle不会跟踪不需要跟踪的内容</strong> 。 <br><br> 在PL / SQL中，依赖项在运行时运行，因此您可以使用动态SQL并执行其他操作。 <br><br><img src="https://habrastorage.org/webt/3j/nh/fk/3jnhfkrft2dgbs-4nyvnwg6nfkm.jpeg"><br><br> 请注意，您不仅可以缓存整个请求， <strong>还可以通过和从缓存内联视图</strong> 。 假设我们需要一个缓存，而另一件事最好是从数据库中读取，以免造成压力。 我们采用内联视图，再次将其声明为result_cache，然后看到仅缓存了一部分，第二部分我们每次都访问数据库。 <br><br><img src="https://habrastorage.org/webt/zq/ze/7z/zqze7zgbnbljnme7a9j8qfbewdo.jpeg"><br><br> 最后， <strong>数据库也有封装</strong> ，尽管没有人相信。 我们采用一个视图，将result_cache放入其中，我们的程序员甚至没有意识到它已被缓存。 下面我们看到实际上只有一部分有效。 <br><br><img src="https://habrastorage.org/webt/-x/-a/mt/-x-amt3jzaygadispddtfx_fojy.jpeg"><br><br><h3> 残障人士 <br></h3><br> 因此，让我们看一下Oracle什么时候会使result_cache无效。Published状态显示了缓存有效性的当前状态。 如我所说，当对result_cache的请求时，数据库中没有作业 <br><br><img src="https://habrastorage.org/webt/uv/9b/at/uv9batcfvtszo6tudxpovnhzy8s.jpeg"><br><br> 当我们进行更新时，状态仍为已发布，因为尚未提交更新，其他会话应看到旧的result_cache。 这就是臭名昭著的阅读一致性。 <br><br> 但是在当前会话中，我们将看到负载已消失，因为在此会话中缓存被忽略了。 这是非常合理的，让我们提交-结果将变为无效，一切都将自行完成。 <br><br><img src="https://habrastorage.org/webt/-r/sn/rt/-rsnrtdyj9bk6vthaott4qondaq.jpeg"><br><br> 似乎-一个梦想！ 依赖关系被认为是正确的-仅取决于请求。 但是，没有发现一些细微差别。  <strong>Oracle在许多不明显的情况下都会造成残疾</strong> ： <br><br><ol><li> 使用任何SELECT FOR UPDATE调用，依赖关系都会消失。 </li><li> 如果表具有未索引的外键，并且在标记为result_cache的表上进行了更新，这根本不影响任何事情，但是父表中发生了某些变化，则缓存也将变为无效。 </li><li> 这是最有趣的事情，它会尽可能地破坏生命-如果在标记为result_cache的表上进行了一些不成功的更新，则没有任何效果，但是在同一事务中，应用了其他任何更改，以某种方式影响了第一个表，因此无论如何result_cache将被重置。 </li></ol><br> 关于result_cache仍然有一种反模式，当开发人员听说这是一件很酷的事情时，会想：“哦，有存储！ 现在，我们将处理一些适用于2-3个分区的请求-在当前日期和上一个日期，将其标记为result_cache，它将始终从内存中获取！” <br><br> 但是当事后改变父权制时，整个缓存就会失效，因为事实上result_cache中依赖项跟踪的单位始终是一个表，并且我不知道是否会有分区。 <br><br> 我们考虑并决定，我们将使用以下内容来制作推荐系统： <br><br><ul><li>  <strong>我们不会缓存所有的表，只会处理必要的表。</strong> <br></li><li>  <strong>为长时间运行的查询设置result_cache。</strong> <br></li></ul><br> 我们检查了所有内容，进行了性能测试， <strong>处理时间为30 s</strong> 。 一切都很好，开始生产！ <br><br> 脱衣服-睡觉了。 我们早上到达。 我们看到一封信：“识别至少需要20分钟，会话会冻结。” 他们为什么冻结？  <strong>30秒</strong>如何<strong>变成20分钟</strong> ？ <br><br> 他们开始了解，看一下数据库： <br><br><ul><li> 活动会话-400； </li><li> 用于识别的文档中的平均行数-500； </li><li> 最小列-5-8; </li><li> 数据库中的会话数始终等于用户应用程序数乘以3！ 而且result_cache不喜欢频繁访问它。 </li></ul><br> 在进行内部调查之后，我们发现Java开发人员在3个线程中进行了识别。 <br><br> 我们很沮丧-5倍的负载，跌落，降级，即使有了这样的参数，也不会发生这样的沉陷。 <br><br> 显然，您需要了解。 <br><br><h3> 监控方式 <br></h3><br><img src="https://habrastorage.org/webt/b6/iq/iw/b6iqiwwevjqyua9xr6p8j2aq0bu.jpeg"><br><br> 对于监视，我们有两个关键事项： <br><br><ol><li>  V $ RESULT_CACHE_OBJECTS-所有对象的列表； </li><li>  V $ RESULT_CACHE_STATISTICS-整个result_cache的聚合统计信息。 </li></ol><br>  MEMORY_REPORT是主题的变体，我们将不需要它们。 <br><br> 甲骨文是神奇的！ 有很多文档，但是它是为那些从其他数据库切换而来的人设计的，以便他们阅读并认为Oracle非常酷！ 但是<strong>关于result_cache的所有信息仅与support有关</strong> 。 <br><br><img src="https://habrastorage.org/webt/vm/u1/bt/vmu1bt35lwpsvebw9o-rnxxasgs.jpeg"><br><br> 有一个细微之处在于，只要我们为了解决问题而转向这些对象，我们就会最终埋葬自己，从而加剧了这种情况！ 在Oracle12.2于去年10月发布补丁之前，这些请求使result_cache无法访问状态和写入，直到完全计数为止。 <br><br><img src="https://habrastorage.org/webt/8b/nd/4y/8bnd4ygeerwxy7n38lqjrqrfwnw.jpeg"><br><br> 因此，使用v $ result_cache_objects视图，我们发现缓存的对象列表中有成千上万的条目-比我们预期的要多得多。 此外，这些是我们在奇怪表上进行的某些查询中的对象-小型平板电脑和last_modified_date查询。 显然， <strong>有人在我们的基础上设置了ETL</strong> 。 <br><br> 在向ETL开发人员发誓之前，我们检查了这些表是否启用了result_cache force选项，并记住我们自己打开了它，因为应用程序经常需要某些数据，并且缓存是适当的。 <br><br><img src="https://habrastorage.org/webt/u1/wq/28/u1wq28jkvtylav6ndpx7qql6koo.jpeg"><br><br> 但是事实证明， <strong>所有这些请求只是占用并清洗了我们的缓存</strong> 。 幸运的是，开发人员有机会影响生产中的ETL，因此我们能够更改result_cache以排除这些微小的请求。 <br><br> 您认为这更容易吗？  -感觉不舒服！ 缓存对象的数量减少，然后又上升到12,000。由于速度没有改变，我们继续研究了缓存的对象。 <br><br><img src="https://habrastorage.org/webt/iy/1o/di/iy1odismaewdpasdhlh_uidjeay.jpeg"><br><br> 我们看起来-一堆请求，如此聪明，但都难以理解。 尽管使用Oracle 12的任何人都知道DS SVC是自适应统计信息。 需要提高性能，但是当有result_cache时，事实证明它会杀死他，因为竞争正在发生。 当然，这<strong>只是出于支持目的</strong> 。 <br><br> 我们知道工作量的安排方式，并了解在我们的案例中，自适应统计不会特别从根本上改善我们的计划。 因此，我们英勇地关闭了它-结果在秘密手册中写成，每个文档10分钟。 不错，但还不够。 <br><br><h3> 锁存器 <br></h3><br>  <strong>result_cache和DS SVC之间的竞争</strong>是由于Oracle具有闩锁这一事实-轻巧的小锁。 <br><br><img src="https://habrastorage.org/webt/d5/ts/nd/d5tsndbmieve1hguz6yv-qzq2jk.jpeg"><br><br> 在不详细介绍它们如何工作的情况下，我们尝试多次放置一个已命名的闩锁-未能成功-Oracle接过头睡着了 <br><br> 主题中的任何人都可以说，在result_cache中，两个块通过fetch放置在每个块上。 这些是细节。  result_cache中有两种闩锁： <br><br>  1.在我们将数据写入result_cache期间锁存一段时间。 <br><br><img src="https://habrastorage.org/webt/pv/db/qe/pvdbqeunmn4qjgcybpkxai3thne.jpeg"><br><br> 也就是说，如果您的请求已经工作了8 s，在这8 s的时间内，其他类似的请求（关键字“ same”）将无法执行任何操作，因为它们要等到将数据写入result_cache为止。 其他请求将被记录，但是它们将仅在第一行等待锁定。 他们将要等待多少时间是未知的；这是未记录的参数result_cache_timeout。 在那之后，他们开始忽略result_cache，并且工作缓慢。 但是，一旦从门上的最后一行的锁被释放，它们就会自动再次开始使用result_cache。 <br><br>  2.第二种类型的锁-也从第一行到最后一行从result_cache接收。 <br> 但是由于提取来自即时内存，因此它们会很快被删除。 <br><br><img src="https://habrastorage.org/webt/pl/es/ds/plesds8v7w0qd8vjfrecofbmwno.jpeg"><br><br> 请务必记住，当DBA看到数据库中的闩锁时，它会开始说：“闩锁！ 等待时间-一切都消失了！ »      : <strong> DBA,  wait time       ,    </strong> . <br><br><img src="https://habrastorage.org/webt/ii/du/sv/iidusv3bzptakrexkjrco7cubsw.jpeg"><br><br>    ,  , <strong>  result_cache  10%   </strong> . <br><br><img src="https://habrastorage.org/webt/7-/o8/8a/7-o88agtahp-edtfts_lb2ss6s4.jpeg"><br><br>   . ,   ,    ,   .    — Proper results are deleted.   <strong> </strong> .  ,        —         ,    ,  -   . <br><br><img src="https://habrastorage.org/webt/mg/lh/5e/mglh5eorzkulnfqoewvrreqpb_u.jpeg"><br><br>  support   2 ,  ,  <strong>  result_cache   </strong> .         . <br><br>   ,    .   , ,   ,  workload   5 .           ,     ,    . <br><br> <strong>   ?</strong> <br><br>  :     .   ,      . <br><br><img src="https://habrastorage.org/webt/2i/qm/_j/2iqm_jbqws8mw7udadiwhkrngao.jpeg"><br><br>    4 : <br><br><ul><li> RESULT_CACHE_MAX_SIZE; <br></li><li> RESULT_CACHE_MAX_RESULT; <br></li><li> RESULT_CACHE_MODE; <br></li><li> _RESULT_CACHE_MAX_TIMEOUT. <br></li></ul><br><img src="https://habrastorage.org/webt/bt/fr/wp/btfrwpqmjmcs6evdykbcvizgte4.jpeg"><br><br>     —  .  ,    100   512,      6 . <br><br>    ,    - . , Invalidation Count = 10000. <br><br>   ,    .     ,   job  ,      . ,   .   job   ,    ,      . <br><br><img src="https://habrastorage.org/webt/2b/m0/dl/2bm0dl2vlmo6bbv16wyksdoora0.jpeg"><br><br>    , invalid     ,    . <strong>         40 </strong> . <br><br>  ,    .     ,     ,     Oracle.  ! <br><br><img src="https://habrastorage.org/webt/wj/dd/jw/wjddjwnlpkmemk8lglmb7rczgb0.jpeg"><br><br> <strong>SHELFLIVE</strong> — ,    read-consistent  ,       10 ,   .        . ,     ,    . <br><br>      — <strong>SNAPSHOT</strong> .  ,       ,     read-consistent    —       . <br><br> <strong></strong> : <br><br><img src="https://habrastorage.org/webt/bj/ts/pd/bjtspdkmsfo2d2xicp_pmxgtqag.jpeg"><br><br><ol><li>  —       SYS. </li><li>      . ,    ,  Oracle    ,     ,        .  , Oracle ,   ,   12.2     . ,  external  -    support,    . </li><li>    sql  pl/sql : current_date, current_time  .   ,     current_time,          . </li><li>    . </li><li>          ,    CLOB, BLOB  . </li></ol><br><h3> Result cache inside Oracle <br></h3><br> Result_cache —   Oracle Core.        , ,    job  result_cache (,    hint,    )  ,    APEX. <br><br><img src="https://habrastorage.org/webt/6n/u3/wf/6nu3wfqtrqzz3n5r_kyfdfwfv8c.jpeg"><br><br> ,    Dynamic sampling    ,   ,      ,   result_cache. <br><br><img src="https://habrastorage.org/webt/qa/gr/al/qagralka35xxjh68wtrfpprgrii.jpeg"><br><br><h2> Oracle internals for result cache <br></h2><br>         result_cache: <br><br><ol><li>        (storage)   ; <br></li><li>         result_cache; <br></li><li> result_cache   shared pool. <br></li></ol><br><img src="https://habrastorage.org/webt/yx/29/pk/yx29pkuz-o_c4dbgk9dbjwbn0lm.jpeg"><br><br> <strong>:</strong> <br><br><ul><li>     . <br></li><li>           read-consistent. </li><li> Result_cache,   ,  . </li></ul><br> <strong>:</strong> <br><br><ul><li>    . <br></li><li>     ,    . <br></li></ul><br><h2>   ! <br></h2><br>      ,    .    support Oracle, ,  29  2017 .:   Oracle E-Business suite    result_cache,      . <br><br><img src="https://habrastorage.org/webt/zh/h3/eu/zhh3eud6fphqdaiuukx1yoklczu.jpeg"><br><br> ,       ,     .          support        ,    ,      . <br><br><img src="https://habrastorage.org/webt/qp/e8/5i/qpe85iwdofjvbxhgtrrihdjmxb4.jpeg"><br><br>             : <br><br><ol><li>  -    ; <br></li><li> , , , ,  v$result_cache_memory  dbms_result_cache.memory_report,       . <br></li></ol><br> ,     ,      ,   v_result_cache_objects  . <br><br><blockquote>   ,  support note —   support ,   . <br></blockquote><br><img src="https://habrastorage.org/webt/me/ut/5o/meut5o7krxdlelwjxgavdxrq-fe.jpeg"><br><br>    ,       ,   :     - .    ,    ,      : <br><br><ol><li>  hint result_cache; </li><li>  hint no result_cache; </li><li>  black_list,  ,   ,   -. </li></ol><br> <strong>    ?</strong> <br><br><ul><li>   ,  - , ,      ; </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在引导期间禁用高速缓存，即快速断开连接，倾倒并打开。</font><font style="vertical-align: inherit;">最好让系统稍慢一些，但先起作用，然后再出现故障。</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正如我们所注意到的，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务器上缓存</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><strong><font style="vertical-align: inherit;">主要问题是昂贵的服务器内存</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Oracle有第三个最终解决方案。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 客户端结果缓存 </font></font><br></h3><br><img src="https://habrastorage.org/webt/mk/6s/5m/mk6s5m24srinff6gkhrmxxei7xu.jpeg"><br><br> 上面显示了他的设备的示意图，这些是数据库和驱动程序的主要组件。 <br><br> 第一次访问客户端时，结果缓存将转到已预先配置的数据库，并从数据库接收客户端缓存的大小，并在第一次连接时一次性在客户端上安装此缓存。 缓存的查询首先访问数据库，然后将数据写入缓存。 其余线程请求共享驱动程序缓存，从而节省服务器内存和资源。 顺便说一下，有时取决于负载，驱动程序会将有关缓存使用情况的统计信息发送到数据库，然后可以查看该统计信息。 <br><br>  <strong>一个有趣的问题是，残疾如何发生？</strong> <br><br> 无效模式有两种，可以通过参数“ Invalidation lag”来增强。 这是Oracle允许驱动程序缓存不一致的程度。 <br><br> 当请求频繁进行且不会发生无效滞后时，使用第一种模式。 在这种情况下，流将转到数据库，更新缓存并从中读取数据。 <br><br><img src="https://habrastorage.org/webt/ah/wo/u1/ahwou1tplbgyiq4w8lizx0raeto.jpeg"><br><br> 如果Invalidation滞后失败，则除了查询结果之外，任何引用数据库的非缓存请求都将带来无效对象列表。 因此，它们在高速缓存中被标记为无效，并且所有操作均与第一种情况的图片相同。 <br><br> 在第二种情况下，如果经过的时间超过了Invalidation滞后时间，则客户端result_cache本身将转到数据库并说：“给我一份更改列表！” 也就是说，他本人保持了自己的状态。 <br><br>  <strong>配置客户端结果缓存非常简单</strong> 。 有2个选项： <br><br><ol><li>  CLIENT_RESULT_CACHE_LAG —缓存滞后值； </li><li>  CLIENT_RESULT_CACHE_SIZE-大小（最小32 Kb，最大-2 GB）。 </li></ol><br><img src="https://habrastorage.org/webt/ky/zl/mh/kyzlmhtgmgjkodcgtwkjm6sqoym.jpeg"><br><br> 从应用程序开发人员的角度来看，客户端缓存与服务器缓存没有太大区别，他们还输入了提示result_cache。 如果是这样，那么它将开始被客户端使用-在.Net和Java上。 <br><br><img src="https://habrastorage.org/webt/xo/bv/of/xobvof-_m9gwfhdocpw5dywqshe.jpeg"><br><br> 完成查询的10次迭代后，我得到了以下内容。 <br><br><img src="https://habrastorage.org/webt/vq/zs/di/vqzsdifg9jkvb18jnrgy_bu9je4.jpeg"><br><br> 首先是创建，然后是9次缓存访问。 该表表明该内存也按块分配。 也要注意SELECT-它不是很直观。 老实说，在我开始处理这个问题之前，我什至不知道<code>GV$SESSION_CONNECT_INFO</code>的表示形式。 为什么Oracle没有将其直接带到该表（这是一个表，而不是视图），我无法理解。 但这就是为什么我认为此功能不是很流行的原因，尽管在我看来，它非常有用。 <br><br>  <strong>客户端缓存的优点：</strong> <br><br><ul><li> 便宜的客户端内存； </li><li> 任何可用的驱动程序-JDBC，.NET等； </li><li> 对应用程序代码的影响最小。 </li><li> 减少CPU，I / O和一般数据库的负载； </li><li> 无需学习和使用各种智能缓存层和API； </li><li> 没有闩锁。 </li></ul><br>  <strong>缺点：</strong> <br><br><ul><li> 延迟阅读具有一致性-原则上，这是一种趋势； </li><li> 需要Oracle OCI客户端； </li><li> 每个客户端2 GB的限制，但是通常2 GB是很多； </li><li> 对我个人而言，关键限制是有关生产的一些信息。 </li></ul><br> 关于支持，在处理result_cache时我们经常使用该支持，我发现只有5个错误。 这表明，极有可能很少有人需要它。 <br><br> 因此，我们将上述所有内容汇总在一起。 <br><br><h3>  <strong>手工缓存</strong> <br></h3><br>  <strong>不良情况：</strong> <br><br><ul><li> 即时更改-如果更改数据后，缓存应立即变得无关紧要。 对于自制的缓存，如果要对其构建的对象进行更改，则很难创建正确的失效。 </li><li> 如果开发策略禁止使用存储在数据库中的逻辑。 </li></ul><br>  <strong>好方案：</strong> <br><br><ul><li> 有强大的数据库开发团队。 </li><li> 实现PL / SQL逻辑。 </li><li> 存在一些限制，无法使用其他缓存技术。 </li></ul><br><h3>  <strong>服务器端结果缓存</strong> <br></h3><br>  <strong>不良情况：</strong> <br><br><ul><li> 洗了整个缓存的结果很多。 </li><li> 请求花费的时间超过_RESULT_CACHE_TIMEOUT或此参数配置不正确。 </li><li> 来自非常大的会话的结果将以并行线程的形式加载到缓存中。 </li></ul><br>  <strong>好方案：</strong> <br><br><ul><li> 合理数量的缓存结果。 </li><li> 相对较小的数据集（200-300行）。 </li><li> 非常昂贵的SQL，否则所有的时间都将用于闩锁。 </li><li> 或多或少的静态表。 </li><li> 有一个DBA，如果有的话，它将拯救所有人。 </li></ul><br><h3>  <strong>客户端结果缓存</strong> <br></h3><br>  <strong>不良情况：</strong> <br><br><ul><li> 当出现即时残疾的问题时。 </li><li> 需要瘦驱动程序。 <br></li></ul><br>  <strong>好方案：</strong> <br><br><ul><li> 有一个正常的中间层开发团队。 </li><li> 许多SQL已经在使用，而没有使用可以轻松连接的外部缓存层。 </li><li> 腺体有限制。 </li></ul><br><br><h2> 结论 <br></h2><br> 我相信我的故事是关于服务器端结果缓存的痛苦的，所以结论如下： <br><br><ol><li> 请始终考虑查询数量而不是结果数量来正确评估内存大小，即：块，APEX，作业，自适应统计信息等。 </li><li> 不要害怕使用自动缓存刷新选项（快照+保质期）。 </li><li> 加载大量数据时，请勿使请求超载高速缓存；在此之前禁用result_cache。 预热缓存。 </li><li> 确保_result_cache_timeout符合您的期望。 </li><li> 切勿对整个数据库使用FORCE。 需要内存中的数据库-使用专门的内存解决方案。 </li><li> 检查FORCE选项是否适当地用于单个表，以使其无法像我们使用第三方ETL那样工作。 </li><li> 确定自适应统计信息是否与Oracle描述的一样好（_optimizer_ads_use_result_cache = false）。 </li></ol><br><blockquote> 下周一， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Highload ++ Siberia</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已</a>准备好<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">时间表，</a>并在网站上发布。 本文主题中有一些报告： <br><br><ul><li>  <strong>Alexander Makarov</strong> （CFT GC） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将以</a> Oracle数据库为例， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示一种</a>识别软件服务器端瓶颈<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>方法。 <br></li><li>  <strong>Ivan Sharov</strong>和<strong>Konstantin Poluektov</strong>将告诉您将产品迁移到新版本的Oracle数据库时会出现什么问题，并承诺<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为</a>组织和进行此类工作<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">提供建议</a> 。 <br></li><li>  <strong>Nikolay Golov</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将告诉您</a>如何确保微服务架构中的数据完整性，而无需分布式事务和紧密连接。 <br></li></ul><br>  <strong>在新西伯利亚见我！</strong> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN414401/">https://habr.com/ru/post/zh-CN414401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN414389/index.html">使用Splunk Cisco Security Suite分析Cisco设备日志</a></li>
<li><a href="../zh-CN414393/index.html">1961年的声控机器人</a></li>
<li><a href="../zh-CN414395/index.html">比听起来容易。 骨折</a></li>
<li><a href="../zh-CN414397/index.html">FCS建议将免税门槛降至零</a></li>
<li><a href="../zh-CN414399/index.html">数字产品在真实商业和教育中的使用</a></li>
<li><a href="../zh-CN414403/index.html">富士通创造了一种新的分子建模技术</a></li>
<li><a href="../zh-CN414405/index.html">在Apache HTTP服务器上安装证书</a></li>
<li><a href="../zh-CN414411/index.html">Wiren Board 6：再次在Habré上使用新版本的自动化控制器</a></li>
<li><a href="../zh-CN414413/index.html">电影节的游戏开发与游戏行业网络故事的概要和视频</a></li>
<li><a href="../zh-CN414415/index.html">6月21日召开的Tarantool会议-不仅涉及Tarantool，而且涉及内存中的计算</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>