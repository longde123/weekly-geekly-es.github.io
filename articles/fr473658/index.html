<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏾 🌮 🌼 Gérer les bogues dans Go 1.13 🏖️ 🏴󠁧󠁢󠁳󠁣󠁴󠁿 👩🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au cours de la dernière décennie, nous avons réussi à exploiter le fait que Go traite les erreurs comme des valeurs . Bien que la bibliothèque standar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gérer les bogues dans Go 1.13</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/473658/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/9f/wo/zl/9fwozl-z2zhf7bg5l_i8lfvdxdw.jpeg"></div><br>  Au cours de la dernière décennie, nous avons réussi à exploiter le fait que Go traite les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">erreurs comme des valeurs</a> .  Bien que la bibliothèque standard ait un support minimal pour les erreurs: uniquement les fonctions <code>errors.New</code> et <code>fmt.Errorf</code> qui génèrent une erreur contenant uniquement un message - l'interface intégrée permet aux programmeurs Go d'ajouter des informations.  Tout ce dont vous avez besoin est un type qui implémente la méthode <code>Error</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *QueryError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Query + <span class="hljs-string"><span class="hljs-string">": "</span></span> + e.Err.Error() }</code> </pre> <a name="habracut"></a><br>  Ces types d'erreurs se retrouvent dans toutes les langues et stockent une grande variété d'informations, des horodatages aux noms de fichiers et adresses de serveurs.  Les erreurs de bas niveau qui fournissent un contexte supplémentaire sont souvent mentionnées. <br><br>  Le modèle, lorsqu'une erreur en contient une autre, est rencontré si souvent dans Go qu'après une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discussion animée</a> dans Go 1.13, son support explicite a été ajouté.  Dans cet article, nous examinerons les ajouts à la bibliothèque standard qui fournissent le support mentionné: trois nouvelles fonctions dans le package d'erreurs et une nouvelle commande de formatage pour <code>fmt.Errorf</code> . <br><br>  Avant de discuter des changements en détail, parlons de la manière dont les erreurs ont été étudiées et construites dans les versions précédentes du langage. <br><br><h1>  Erreurs avant Go 1.13 </h1><br><h4>  Recherche d'erreurs </h4><br>  Les erreurs dans Go sont des significations.  Les programmes prennent des décisions basées sur ces valeurs de différentes manières.  Le plus souvent, l'erreur est comparée à zéro pour voir si l'opération a échoué. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// something went wrong }</span></span></code> </pre><br>  Parfois, nous comparons l'erreur pour trouver la valeur de <i>contrôle</i> et voir si une erreur spécifique s'est produite. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNotFound = errors.New(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == ErrNotFound { <span class="hljs-comment"><span class="hljs-comment">// something wasn't found }</span></span></code> </pre> <br>  La valeur d'erreur peut être de tout type satisfaisant l'interface d'erreur définie dans la langue.  Un programme peut utiliser une instruction de type ou un commutateur de type pour afficher la valeur d'erreur d'un type plus spécifique. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> NotFoundError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *NotFoundError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Name + <span class="hljs-string"><span class="hljs-string">": not found"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*NotFoundError); ok { <span class="hljs-comment"><span class="hljs-comment">// e.Name wasn't found }</span></span></code> </pre><br><h4>  Ajout d'informations </h4><br>  Souvent, une fonction transmet une erreur dans la pile d'appels, en y ajoutant des informations, par exemple, une brève description de ce qui s'est produit lorsque l'erreur s'est produite.  C'est facile à faire, il suffit de construire une nouvelle erreur qui inclut le texte de l'erreur précédente: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"decompress %v: %v"</span></span>, name, err) }</code> </pre> <br>  Lors de la création d'une nouvelle erreur à l'aide de <code>fmt.Errorf</code> nous <code>fmt.Errorf</code> tout sauf le texte de l'erreur d'origine.  Comme nous l'avons vu dans l'exemple <code>QueryError</code> , vous devez parfois définir un nouveau type d'erreur qui contient l'erreur d'origine afin de la sauvegarder pour l'analyse à l'aide de code: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error }</code> </pre> <br>  Les programmes peuvent regarder à l'intérieur de la <code>*QueryError</code> et prendre une décision basée sur l'erreur d'origine.  Ceci est parfois appelé le déballage d'une erreur. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission { <span class="hljs-comment"><span class="hljs-comment">// query failed because of a permission problem }</span></span></code> </pre> <br>  Le type <code>os.PathError</code> de la bibliothèque standard est un autre exemple de la façon dont une erreur en contient une autre. <br><br><h1>  Erreurs dans Go 1.13 </h1><br><h4>  Méthode de déballage </h4><br>  Dans Go 1.13, les packages de bibliothèques standard <code>errors</code> et <code>fmt</code> ont simplifié la <code>fmt</code> erreurs qui contiennent d'autres erreurs.  La plus importante est la convention, pas la modification: une erreur contenant une autre erreur peut implémenter la méthode <code>Unwrap</code> , qui renvoie l'erreur d'origine.  Si <code>e1.Unwrap()</code> renvoie <code>e2</code> , alors nous disons que <code>e1</code> <i>emballe</i> <code>e2</code> et vous pouvez <i>décompresser</i> <code>e1</code> pour obtenir <code>e2</code> . <br><br>  Selon cette convention, vous pouvez attribuer le type <code>QueryError</code> décrit ci-dessus à la méthode <code>QueryError</code> , qui renvoie l'erreur contenue dans celle-ci: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *QueryError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unwrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Err }</code> </pre> <br>  Le résultat du déballage de l'erreur peut également contenir la méthode <code>Unwrap</code> .  La séquence d'erreurs obtenue par le déballage répété, nous appelons la <i>chaîne d'erreurs</i> . <br><br><h4>  Recherche d'erreur avec Is et As </h4><br>  Dans Go 1.13, le package d' <code>errors</code> contient deux nouvelles fonctions pour rechercher les erreurs: <code>Is</code> et <code>As</code> . <br><br>  La fonction <code>errors.Is</code> compare une erreur avec une valeur. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Similar to: // if err == ErrNotFound { … } if errors.Is(err, ErrNotFound) { // something wasn't found }</span></span></code> </pre> <br>  La fonction <code>As</code> vérifie si l'erreur est d'un type particulier. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Similar to: // if e, ok := err.(*QueryError); ok { … } var e *QueryError if errors.As(err, &amp;e) { // err is a *QueryError, and e is set to the error's value }</span></span></code> </pre> <br>  Dans le cas le plus simple, la fonction <code>errors.Is</code> se comporte comme une comparaison avec une erreur de contrôle et la fonction <code>errors.As</code> se comporte comme une instruction de type.  Cependant, lorsque vous travaillez avec des erreurs compressées, ces fonctions évaluent toutes les erreurs de la chaîne.  Examinons l'exemple de <code>QueryError</code> ci-dessus pour examiner l'erreur d'origine: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission { <span class="hljs-comment"><span class="hljs-comment">// query failed because of a permission problem }</span></span></code> </pre> <br>  En utilisant la fonction <code>errors.Is</code> , <code>errors.Is</code> pouvez écrire ceci: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, ErrPermission) { <span class="hljs-comment"><span class="hljs-comment">// err, or some error that it wraps, is a permission problem }</span></span></code> </pre> <br>  Le package d' <code>errors</code> contient également une nouvelle fonction <code>Unwrap</code> qui renvoie le résultat de l'appel de la méthode <code>Unwrap</code> de l'erreur, ou renvoie nil si l'erreur n'a pas la méthode <code>Unwrap</code> .  Il est généralement préférable d'utiliser des <code>errors.Is</code> des <code>errors.Is</code> ou des <code>errors.As</code> , car elles vous permettent d'examiner toute la chaîne en un seul appel. <br><br><h4>  Erreur de conditionnement avec% w </h4><br>  Comme je l'ai mentionné, il est normal d'utiliser la fonction <code>fmt.Errorf</code> pour ajouter des informations supplémentaires à l'erreur. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"decompress %v: %v"</span></span>, name, err) }</code> </pre> <br>  Dans Go 1.13, la fonction <code>fmt.Errorf</code> prend en charge la nouvelle commande <code>%w</code> .  Si c'est le cas, l'erreur renvoyée par <code>fmt.Errorf</code> contiendra la méthode <code>Unwrap</code> qui renvoie l'argument <code>%w</code> , qui devrait être une erreur.  Dans tous les autres cas, <code>%w</code> identique à <code>%v</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Return an error which unwraps to err. return fmt.Errorf("decompress %v: %w", name, err) }</span></span></code> </pre> <br>  L'emballage de l'erreur avec <code>%w</code> rend disponible pour les <code>errors.Is</code> et <code>errors.As</code> . <br><br><pre> <code class="go hljs">err := fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"access denied: %w"</span></span>, ErrPermission) ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, ErrPermission) ...</code> </pre><br><h4>  Quand emballer? </h4><br>  Lorsque vous ajoutez un contexte supplémentaire à l'erreur à l'aide de <code>fmt.Errorf</code> ou d'une implémentation de type personnalisé, vous devez décider si la nouvelle erreur contiendra l'original.  Il n'y a pas de réponse unique à cela, tout dépend du contexte dans lequel la nouvelle erreur est créée.  Pack pour montrer son appelant.  Ne pas empaqueter l'erreur si cela conduit à la divulgation des détails d'implémentation. <br><br>  Par exemple, imaginez une fonction <code>Parse</code> qui lit une structure de données complexe à partir de <code>io.Reader</code> .  Si une erreur se produit, nous souhaitons connaître le numéro de la ligne et de la colonne où elle s'est produite.  Si une erreur s'est produite lors de la lecture à partir de <code>io.Reader</code> , nous devrons l'emballer pour en trouver la raison.  Étant donné que l'appelant a reçu la fonction <code>io.Reader</code> , il est logique d'afficher l'erreur qu'il a générée. <br><br>  Autre cas: une fonction qui effectue plusieurs appels de base de données ne devrait probablement pas retourner une erreur dans laquelle le résultat de l'un de ces appels est compressé.  Si la base de données utilisée par cette fonction fait partie de l'implémentation, la divulgation de ces erreurs violera l'abstraction.  Par exemple, si la fonction <code>LookupUser</code> du package <code>pkg</code> utilise le package Go <code>database/sql</code> , elle peut rencontrer l'erreur <code>sql.ErrNoRows</code> .  Si vous renvoyez une erreur à l'aide de <code>fmt.Errorf("accessing DB: %v", err)</code> , l'appelant ne peut pas regarder à l'intérieur et trouver <code>sql.ErrNoRows</code> .  Mais si la fonction renvoie <code>fmt.Errorf("accessing DB: %w", err)</code> , alors l'appelant pourrait écrire: <br><br><pre> <code class="go hljs">err := pkg.LookupUser(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, sql.ErrNoRows) …</code> </pre> <br>  Dans ce cas, la fonction doit toujours renvoyer <code>sql.ErrNoRows</code> si vous ne souhaitez pas interrompre les clients, même lorsque vous passez à un package avec une base de données différente.  En d'autres termes, l'empaquetage fait une erreur dans votre API.  Si vous ne souhaitez pas valider la prise en charge de cette erreur à l'avenir dans le cadre de l'API, ne la regroupez pas. <br><br>  Il est important de se rappeler que, que vous l'emballiez ou non, l'erreur restera inchangée.  <i>Une personne</i> qui le comprendra aura les mêmes informations.  La prise de décisions concernant l'emballage dépend de la nécessité ou non de fournir des informations supplémentaires aux <i>programmes</i> afin qu'ils puissent prendre des décisions plus éclairées;  ou si vous souhaitez masquer ces informations afin de maintenir le niveau d'abstraction. <br><br><h4>  Configuration des tests d'erreur à l'aide des méthodes Is et As </h4><br>  La fonction <code>errors.Is</code> vérifie chaque erreur de la chaîne par rapport à la valeur cible.  Par défaut, une erreur correspond à cette valeur si elles sont équivalentes.  De plus, une erreur dans la chaîne peut déclarer sa conformité à la valeur cible à l'aide de l'implémentation de <i>la méthode</i> <code>Is</code> . <br><br>  Considérez l'erreur provoquée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par le package Upspin</a> , qui compare l'erreur avec le modèle et évalue uniquement les champs non nuls: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { t, ok := target.(*Error) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (e.Path == t.Path || t.Path == <span class="hljs-string"><span class="hljs-string">""</span></span>) &amp;&amp; (e.User == t.User || t.User == <span class="hljs-string"><span class="hljs-string">""</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, &amp;Error{User: <span class="hljs-string"><span class="hljs-string">"someuser"</span></span>}) { <span class="hljs-comment"><span class="hljs-comment">// err's User field is "someuser". }</span></span></code> </pre> <br>  La fonction <code>errors.As</code> conseille également la méthode <code>As</code> , le cas échéant. <br><br><h4>  Erreurs et API de package </h4><br>  Un package qui renvoie des erreurs (et la plupart des packages le font) doit décrire les propriétés de ces erreurs sur lesquelles un programmeur peut s'appuyer.  Un package bien conçu évitera également de renvoyer des erreurs avec des propriétés sur lesquelles on ne peut pas compter. <br><br>  Le plus simple est de dire si l'opération a réussi, en renvoyant respectivement la valeur nil ou non nil.  Dans de nombreux cas, aucune autre information n'est requise. <br><br>  Si vous avez besoin de la fonction pour renvoyer un état d'erreur identifiable, par exemple, «élément non trouvé», vous pouvez renvoyer une erreur dans laquelle la valeur du signal est compressée. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNotFound = errors.New(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// FetchItem returns the named item. // // If no item with the name exists, FetchItem returns an error // wrapping ErrNotFound. func FetchItem(name string) (*Item, error) { if itemNotFound(name) { return nil, fmt.Errorf("%q: %w", name, ErrNotFound) } // ... }</span></span></code> </pre> <br>  Il existe d'autres modèles pour fournir des erreurs que l'appelant peut examiner sémantiquement.  Par exemple, renvoyez directement une valeur de contrôle, un type spécifique ou une valeur qui peut être analysée à l'aide d'une fonction prédicative. <br><br>  Dans tous les cas, ne divulguez pas les détails internes à l'utilisateur.  Comme mentionné dans le chapitre «Quand vaut-il la peine d'être empaqueté?», Si vous renvoyez une erreur à partir d'un autre package, convertissez-la afin de ne pas révéler l'erreur d'origine, sauf si vous avez l'intention de vous engager à renvoyer cette erreur spécifique à l'avenir. <br><br><pre> <code class="go hljs">f, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The *os.PathError returned by os.Open is an internal detail. // To avoid exposing it to the caller, repackage it as a new // error with the same text. We use the %v formatting verb, since // %w would permit the caller to unwrap the original *os.PathError. return fmt.Errorf("%v", err) }</span></span></code> </pre> <br>  Si une fonction renvoie une erreur avec une valeur ou un type de signal compressé, ne retournez pas directement l'erreur d'origine. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrPermission = errors.New(<span class="hljs-string"><span class="hljs-string">"permission denied"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// DoSomething returns an error wrapping ErrPermission if the user // does not have permission to do something. func DoSomething() { if !userHasPermission() { // If we return ErrPermission directly, callers might come // to depend on the exact error value, writing code like this: // // if err := pkg.DoSomething(); err == pkg.ErrPermission { … } // // This will cause problems if we want to add additional // context to the error in the future. To avoid this, we // return an error wrapping the sentinel so that users must // always unwrap it: // // if err := pkg.DoSomething(); errors.Is(err, pkg.ErrPermission) { ... } return fmt.Errorf("%w", ErrPermission) } // ... }</span></span></code> </pre><br><h4>  Conclusion </h4><br>  Bien que nous n'ayons discuté que de trois fonctions et d'une commande de formatage, nous espérons qu'elles contribueront grandement à améliorer la gestion des erreurs dans les programmes Go.  Nous espérons que l'empaquetage dans le but de fournir un contexte supplémentaire deviendra une pratique normale, aidant les programmeurs à prendre de meilleures décisions et à trouver plus rapidement les bogues. <br><br>  Comme Russ Cox l'a dit dans son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">discours à GopherCon 2019</a> , sur le chemin de Go 2, nous expérimentons, simplifions et expédions.  Et maintenant, après avoir expédié ces changements, nous avons entrepris de nouvelles expériences. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473658/">https://habr.com/ru/post/fr473658/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473646/index.html">Hackathon dans une petite entreprise: comment organiser sans vider un train de ressources</a></li>
<li><a href="../fr473648/index.html">Le cheval est mort - Cri: transition du tslint au eslint</a></li>
<li><a href="../fr473652/index.html">Création d'une API REST avec Node.js et une base de données Oracle. Partie 5</a></li>
<li><a href="../fr473654/index.html">Compositeur PHP: corriger les dépendances sans douleur</a></li>
<li><a href="../fr473656/index.html">Expérience de générateur de site statique Hugo</a></li>
<li><a href="../fr473660/index.html">Arcade Reverse Engineering: Record Michael Jordan au NBA Jam</a></li>
<li><a href="../fr473664/index.html">Expérience d'apprentissage de première main. Yandex.Practicum - Analyste de données</a></li>
<li><a href="../fr473666/index.html">En tant qu'écrivain de science-fiction, Arthur Clark a presque fermé la revue Tech - Youth</a></li>
<li><a href="../fr473668/index.html">Pourquoi Bitrix - Bitrix</a></li>
<li><a href="../fr473670/index.html">Stoloto: comment introduire un mobile à la loterie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>