<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïâÔ∏è üë± üëÜüèª C√≥mo conect√© computadoras y usuarios a puertos de dispositivos de red en el programa de monitoreo Network MACMonitor ‚ù£Ô∏è üí∑ üö∂üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Soy un desarrollador del software de monitoreo de red Network MACMonitor . 


 En el proceso de desarrollo del programa, surgi√≥ una tarea: determinar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo conect√© computadoras y usuarios a puertos de dispositivos de red en el programa de monitoreo Network MACMonitor</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/macmonitor/blog/416217/"><p>  Soy un desarrollador del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">software de</a> monitoreo de red <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Network MACMonitor</a> . </p><br><p>  En el proceso de desarrollo del programa, surgi√≥ una tarea: determinar qu√© computadoras est√°n usando los usuarios y asociar esta informaci√≥n con los puertos de los dispositivos de red.  En este art√≠culo quiero escribir c√≥mo logr√© hacer esto. </p><br><p><img src="https://habrastorage.org/webt/ab/uf/qc/abufqc8euaofveu4dqt-htkaqrm.png" alt="imagen"></p><a name="habracut"></a><br><p>  Comenc√© con consideraciones simples: para asociar un usuario con un puerto en un dispositivo de red, primero debe conectar la computadora con la que el usuario est√° trabajando a este puerto.  Dado que el programa Network MACMonitor le permite encontrar direcciones mac en los puertos de los dispositivos de red, se decidi√≥ conectar las computadoras a los puertos utilizando direcciones mac.  A continuaci√≥n, debe conectar a los usuarios a las computadoras.  Esta informaci√≥n se puede obtener interrogando a las computadoras de cualquier manera. </p><br><p>  Vi dos opciones para resolver este problema: </p><br><ol><li>  Escribir un agente de Windows e interrogarlo usando Network MACMonitor; </li><li>  Utilice el Instrumental de administraci√≥n de Windows (WMI). </li></ol><br><p>  La versi√≥n con el agente de Windows tiene una serie de desventajas que fueron significativas para m√≠: </p><br><ul><li>  desarrollo de un protocolo seguro para la interacci√≥n de red de un agente de Windows con Network MACMonitor; </li><li>  la necesidad de preinstalar el agente en las computadoras; </li><li>  usando un lenguaje de programaci√≥n diferente (escribo en Java), ya que considero que Java no es adecuado para escribir un agente: debido al gran consumo de memoria virtual y la necesidad de instalar JRE en todas las computadoras. </li></ul><br><p>  Debido a todas las desventajas anteriores, decid√≠ detenerme en la opci√≥n usando WMI. </p><br><h3>  Desarrollo de clientes WMI </h3><br><p>  Dado que Network MACMonitor est√° escrito en Java, intent√© encontrar una biblioteca Java multiplataforma lista para usar que implemente la funcionalidad del cliente WMI.  Y luego me decepcion√≥: no existe tal biblioteca.  Todas las bibliotecas existentes son envoltorios sobre las utilidades de Windows o (biblioteca j-Interop) requieren manipulaci√≥n de registro adicional (cambio de propiedad y permisos en las ramas del registro) para activar WMI a trav√©s de un registro remoto.  Como no hab√≠a una biblioteca totalmente funcional para Java, decid√≠ buscar una biblioteca o un cliente WMI escrito en cualquier otro lenguaje de programaci√≥n.  Y encontr√© un cliente WMI para Linux.  Despu√©s de descargar y verificar su trabajo, me di cuenta de que es posible sondear computadoras con Windows desde Linux. </p><br><p>  Si esto es posible, decid√≠ escribir mi biblioteca en Java puro, lo que me permitir√≠a sondear la computadora usando WMI. </p><br><p>  Para escribir la biblioteca, se necesitaba documentaci√≥n clara sobre el funcionamiento del protocolo WMI.  Result√≥ que existe dicha documentaci√≥n y es de dominio p√∫blico. </p><br><p>  Comenc√© a prepararme para escribir la biblioteca mirando la pila de red del protocolo WMI. </p><br><table><tbody><tr><th>  Protocolo </th><th>  Especificaciones </th></tr><tr><td>  Instrumental de administraci√≥n de Windows (WMI) </td><td>  MS-WMI, MS-WMIO </td></tr><tr><td>  Modelo de objetos componentes distribuidos (DCOM) </td><td>  MS-DCOM </td></tr><tr><td>  Llamada a procedimiento remoto (RPC) </td><td>  MS-RPCE </td></tr><tr><td>  Protocolo de control de transmisi√≥n (TCP) </td><td>  - </td></tr><tr><td>  Protocolo de internet (IP) </td><td>  - </td></tr></tbody></table><br><p>  Para que WMI funcione correctamente, se deben implementar todos los niveles de la pila. </p><br><p>  Como WMI no est√° implementado en Java, pas√© al siguiente protocolo en la pila: DCOM.  Y aqu√≠ tuve suerte.  Aunque la biblioteca j-Interop mencionada anteriormente no implementa la funcionalidad WMI, la funcionalidad DCOM se implementa en ella.  Por lo tanto, queda por escribir una implementaci√≥n del protocolo WMI, es decir, escribir una implementaci√≥n de las especificaciones MS-WMI y MS-WMIO. </p><br><p>  Comenc√© implementando la especificaci√≥n MS-WMIO, que es responsable del formato de codificaci√≥n de datos en los paquetes de red del protocolo WMI.  De la especificaci√≥n, aprend√≠ que al codificar datos, se utiliza la especificaci√≥n de sintaxis Backus-Naur extendida (ABNF, RFC 5234).  La especificaci√≥n MS-WMIO describe completamente el formato de codificaci√≥n utilizando ABNF.  Se sabe que si hay una gram√°tica descrita en ABNF, entonces es posible crear un analizador para esta gram√°tica.  En Internet, encontr√© un generador de analizador ABNF para Java y lo ingres√© con una gram√°tica tomada de la especificaci√≥n.  Dado que el analizador generado funcionaba con cadenas y MS-WMIO describe un formato de codificaci√≥n binario, la idea era simplemente reemplazar el analizador generado con cadenas por matrices y caracteres con bytes.  Pero despu√©s de mirar la cantidad de archivos donde era necesario un reemplazo, y tambi√©n de haber aprendido de la especificaci√≥n MS-WMIO que a veces ser√≠a necesario trabajar con bits, me di cuenta de que ser√≠a muy dif√≠cil arreglar el analizador generado, y decid√≠ abandonar esta idea.  Pens√© que escribir un analizador desde cero ser√≠a m√°s r√°pido.  Y ahora el analizador estaba listo. </p><br><p>  ¬øPero c√≥mo verificar que el analizador est√° escrito correctamente si la especificaci√≥n MS-WMI, que es responsable del funcionamiento del protocolo WMI, a√∫n no est√° implementada?  Entonces Wireshark, un analizador de tr√°fico de red, me ayud√≥.  Despu√©s de haber realizado solicitudes WMI utilizando herramientas est√°ndar de Windows (wbemtest), habiendo deshabilitado previamente el cifrado, recib√≠ paquetes de red y los guard√© en archivos binarios.  Ya era posible usar estos archivos como datos de prueba para el analizador. </p><br><p>  Cuando se prob√≥ el analizador y se corrigieron los errores encontrados, proced√≠ a implementar la especificaci√≥n MS-WMI, que describe el funcionamiento del protocolo WMI. </p><br><p>  La especificaci√≥n MS-WMI se divide en servidor y cliente.  Implement√© parcialmente la parte del cliente, en la medida necesaria para sondear una computadora a trav√©s de WMI.  En esta parte, tambi√©n necesitaba Wireshark, pero ya para analizar la secuencia de paquetes de red durante el sondeo de WMI. </p><br><h3 id="popytka-polucheniya-neobhodimyh-dannyh-s-pomoschyu-wmi">  Intentando obtener los datos necesarios usando WMI </h3><br><p>  Despu√©s de escribir la biblioteca WMI, se convirti√≥ en la tarea de usarla en el programa Network MACMonitor.  Surgi√≥ la pregunta: ¬øqu√© datos se deben obtener de las computadoras?  Pens√© que necesitaba obtener el nombre de la computadora, el dominio, el sistema operativo, el tiempo de encendido, las direcciones mac, las direcciones IP, los usuarios activos que trabajan en la computadora. </p><br><p>  Pero surgi√≥ un problema muy importante: ¬øc√≥mo identificar de manera √∫nica una computadora durante el sondeo de WMI?  Consider√© las siguientes opciones: </p><br><ul><li>  direcci√≥n mac, posible cambio, posible no √∫nico; </li><li>  nombre y dominio de la computadora (grupo de trabajo), posible cambio, no √∫nico (para grupo de trabajo); </li><li>  el n√∫mero de serie del disco duro donde est√° instalado el sistema operativo, se requieren derechos de administrador durante el sondeo de WMI, no verifiqu√© la unicidad, pero sospecho que es posible que no sea √∫nico; </li><li>  el n√∫mero de serie de la placa base, no √∫nico es posible, y con bastante frecuencia; </li><li>  el identificador del sistema inform√°tico (propiedad <em>UUID</em> WMI de la clase <em>Win32_ComputerSystemProduct</em> ), la falta de uniformidad es posible, y con bastante frecuencia; </li><li>  El tiempo de instalaci√≥n del sistema operativo es la mejor de todas las opciones, pero la falta de uniformidad es posible al clonar el sistema o al implementar desde una imagen. </li></ul><br><p>  Ninguna opci√≥n le permite identificar de manera √∫nica la computadora, as√≠ que decid√≠ identificarla de tres maneras: </p><br><ul><li>  n√∫mero de serie de la placa base, </li><li>  identificador del sistema inform√°tico </li><li>  tiempo de instalaci√≥n del sistema operativo. </li></ul><br><p>  Por supuesto, estos tres par√°metros pueden coincidir en diferentes computadoras, pero con menos frecuencia que uno de ellos. </p><br><p>  Tambi√©n se intent√≥ obtener usuarios activos utilizando la clase WMI est√°ndar: <em>Win32_LogonSession</em> .  Entonces apareci√≥ el primer problema: result√≥ que <em>Win32_LogonSession</em> muestra todas las sesiones de usuario, incluso aquellas que ya se han completado.  Comenc√© a pensar c√≥mo filtrar las sesiones activas de las que terminaron.  <em>Descubrimos</em> que esto se puede hacer usando la clase <em>Win32_SessionProcess</em> , que asocia instancias de las clases <em>Win32_LogonSession</em> con <em>Win32_Process</em> .  Si el enlace a la sesi√≥n est√° presente en la lista de instancias de la clase <em>Win32_SessionProcess</em> (hay al menos un proceso con el identificador de esta sesi√≥n), entonces est√° activo.  Luego, surgi√≥ la pregunta sobre c√≥mo asociar una sesi√≥n con un usuario.  Esto se puede hacer usando la clase <em>Win32_LoggedOnUser</em> , que une instancias de las <em>clases</em> <em>Win32_LogonSession</em> y <em>Win32_UserAccount</em> .  Solo queda obtener instancias de la clase <em>Win32_UserAccount</em> que brinden informaci√≥n detallada sobre el usuario. </p><br><p><img src="https://habrastorage.org/webt/gq/0x/vg/gq0xvgaauo2dtpkmzajpife-x5g.png" alt="imagen"></p><br><p>  Pero aqu√≠ estaba decepcionado.  Al usar WMI de forma remota, result√≥ que al intentar obtener instancias de la clase <em>Win32_UserAccount</em> , es posible obtener solo usuarios de computadoras locales.  Es decir, result√≥ que usando herramientas WMI est√°ndar, es imposible averiguar qu√© usuarios est√°n activos en la computadora. </p><br><h3 id="razrabotka-wmi-provaydera">  Desarrollo de un proveedor de WMI. </h3><br><p>  Debido a la imposibilidad de una identificaci√≥n inequ√≠voca de las computadoras y la imposibilidad de obtener informaci√≥n sobre usuarios activos que usan clases WMI est√°ndar, se decidi√≥ ampliar la funcionalidad de WMI.  Puede hacer esto describiendo sus clases de WMI en un archivo MOF y escribiendo un proveedor de WMI para obtener instancias de estas clases. </p><br><p>  Se han descrito dos nuevas clases de WMI: <em>NMBY_InstallInfo</em> - para identificar una computadora y <em>NMBY_LogonSession</em> - para identificar usuarios activos de una computadora. </p><br><p><img src="https://habrastorage.org/webt/5b/op/gi/5bopgiwlndpdgqpb7h2zdhqbyxg.png" alt="imagen"></p><br><p>  Luego se escribi√≥ un proveedor de WMI con el que puede obtener instancias de estas clases. </p><br><p>  Se establecieron requisitos adicionales para el proveedor: </p><br><ul><li>  trabajar en un sistema sin .NET; </li><li>  trabajar en el sistema operativo Windows XP y superior; </li><li>  la capacidad de obtener informaci√≥n usando una cuenta no administrativa. </li></ul><br><p>  Por lo tanto, el proveedor se escribi√≥ en C ++ con WinApi. </p><br><p>  En el proceso de redacci√≥n del proveedor, surgieron dificultades debido a la peque√±a cantidad y calidad de la documentaci√≥n sobre este tema, pero a pesar de esto, el proveedor se escribi√≥ con √©xito. </p><br><p>  Un proveedor escrito est√° disponible en la p√°gina de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">descarga</a> .  Se puede instalar y utilizar de forma gratuita. </p><br><h3 id="itog">  Resumen </h3><br><p>  Como resultado, utilizando el programa Network MACMonitor se hizo posible: </p><br><ul><li>  Asociar usuarios con computadoras </li></ul><br><p><img src="https://habrastorage.org/webt/u7/zn/op/u7znop78jhskuqgge9w7axw1i5g.png" alt="imagen"></p><br><ul><li>  Asociar computadoras con puertos en dispositivos de red </li></ul><br><p><img src="https://habrastorage.org/webt/ri/53/zq/ri53zqdcphgvs9q5xnyqtc2wdjs.png" alt="imagen"></p><br><ul><li>  Asociar puertos de dispositivos de red con computadoras y usuarios </li></ul><br><p><img src="https://habrastorage.org/webt/_0/t-/ks/_0t-kseg8qqmzmxobo4z138hb54.png" alt="imagen"></p><br><ul><li>  Ver el historial de registro de usuarios en las computadoras. </li></ul><br><p><img src="https://habrastorage.org/webt/wp/u0/aa/wpu0aat6iwqqappksaq_vem9-yw.png" alt="imagen"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sitio web del programa</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416217/">https://habr.com/ru/post/es416217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416207/index.html">‚ÄúNo es peor que en Hogwarts‚Äù: los futuros estudiantes hablan sobre TI</a></li>
<li><a href="../es416209/index.html">DeepMind no puede parar: AI puede jugar Quake III Arena ahora</a></li>
<li><a href="../es416211/index.html">Neuronas en 5 minutos</a></li>
<li><a href="../es416213/index.html">Webinar abierto "Inyecci√≥n de dependencias en angular"</a></li>
<li><a href="../es416215/index.html">Food Design Digest Junio ‚Äã‚Äã2018</a></li>
<li><a href="../es416219/index.html">Yandex comenz√≥ a indexar Google Docs con contrase√±as</a></li>
<li><a href="../es416229/index.html">10 libros sobre marketing y temas relacionados que un dise√±ador debe leer</a></li>
<li><a href="../es416231/index.html">Monitoreo de habitaciones Zadarma Zabbix</a></li>
<li><a href="../es416235/index.html">Crear componentes personalizados para Bootstrap 4</a></li>
<li><a href="../es416237/index.html">Convertirse en dise√±ador: desde trabajar como freelance desde un albergue hasta trabajar con las principales empresas y lanzar su producto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>