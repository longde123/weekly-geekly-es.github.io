<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•à üß¶ üé∑ Haskell Applicative Parsers ü•Ñ üïµüèΩ üçπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Motivation 


 Als ich gerade anfing, Haskell zu lernen, war ich sehr ver√§rgert √ºber die weit verbreitete Verwendung komplexer Abstraktionen anstelle ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haskell Applicative Parsers</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436234/"><p><img src="https://habrastorage.org/webt/tq/9u/iw/tq9uiw8d_nbb1bbwrfdg1euyvci.png"></p><br><h1 id="motivaciya">  Motivation </h1><br><p>  Als ich gerade anfing, Haskell zu lernen, war ich sehr ver√§rgert √ºber die weit verbreitete Verwendung komplexer Abstraktionen anstelle spezifischer L√∂sungen.  Es schien mir viel besser, immer dem KISS-Prinzip zu folgen und Fahrr√§der mit elementaren Sprachkonstrukten zu schreiben, als all diese Typklassen zu verstehen, um irgendwo eine vermeintlich bequeme Konstruktion zu schreiben. </p><br><p>  Ich hatte kein gutes Beispiel daf√ºr, wo sich die Anstrengungen zur Entwicklung des "Materials" auszahlen w√ºrden.  Eines der erfolgreichsten Beispiele f√ºr mich waren Parser.  Jetzt spreche ich oft √ºber sie, wenn sie mich fragen, welche allgemeinen Aufgaben Sie Haskell wunderbar verwenden k√∂nnen. </p><br><p> Ich m√∂chte Anf√§ngern anbieten, auch diesen Weg zu gehen und eine kleine Basis von Funktionen von Grund auf neu zu erstellen, um Parser bequem zu implementieren, und dann einen eigenen Parser zu schreiben, dessen Code die f√ºr das Parsen verwendete Grammatik fast buchst√§blich wiederholt. </p><br><p>  Ich hoffe, dies hilft jemandem, die Angst vor Abstraktionen zu √ºberwinden und ihm den <em>richtigen</em> Umgang mit ihnen beizubringen (ja, ich denke immer noch, dass es manchmal effizienter ist, ein Fahrrad zu schreiben). </p><a name="habracut"></a><br><p>  Ich habe keinen Zweck und keine Lust, einen Haskell-Kurs aus einem Artikel von Grund auf neu zu erstellen, daher gehe ich davon aus, dass der Leser mit der Syntax und den unabh√§ngig entwickelten einfachen Programmen vertraut ist.  F√ºr alle F√§lle werde ich kurz auf Typklassen eingehen, bevor ich mit der Beschreibung der Implementierung fortfahre. </p><br><p>  F√ºr diejenigen, die noch nie an Haskell geschrieben haben, aber verstehen m√∂chten, was hier passiert, empfehle ich, dass Sie sich zuerst die entsprechende Seite zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Learn X in Y Minuten</a> ansehen.  Als ausgezeichnetes russischsprachiges Buch f√ºr Anf√§nger empfehle ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"√úber Haskell als Mensch" von</a> Denis Shevchenko. </p><br><p>  Ich werde versuchen, die einfachsten Sprachkonstrukte zu verwenden, die Anf√§nger verstehen k√∂nnen.  Am Ende des Artikels wird ein Link zum Quell-Repository angegeben, in dem in einigen Teilen des Codes ein bequemerer und k√ºrzerer Eintrag verwendet wird, der auf den ersten Blick weniger klar sein kann. </p><br><p>  Und ja, meine Herren Haskellisten, viele Dinge werden sehr einfach und ungeschickt erkl√§rt, f√ºr spezielle F√§lle nicht sehr abstrakt, ohne Begriffe aus der Kategorietheorie und andere be√§ngstigende W√∂rter zu verwenden.  Ich bin froh, dass du sie kennst und sie sie nat√ºrlich leicht beherrschen.  Ich kenne sie auch, aber ich halte es nicht f√ºr notwendig, eine solche Menge an Informationen in diesem Zusammenhang unvorbereiteten Lesern zur Verf√ºgung zu stellen. </p><br><h1 id="klassy-tipov">  Typklassen </h1><br><p>  Klassen vom Typ Haskell haben nichts mit Klassen in C ++ und anderen objektorientierten Sprachen zu tun.  Wenn wir eine Analogie zu OOP ziehen, sind Typklassen eher eine √úberladung von Methoden und Funktionen. </p><br><p> Klassen bestimmen, welche Aktionen mit Objekten der Typen ausgef√ºhrt werden k√∂nnen, aus denen die Klasse besteht.  Zum Beispiel k√∂nnen alle Zahlen auf Gleichheit verglichen werden, aber alles kann bis auf komplexe geordnet werden, und im Allgemeinen k√∂nnen Funktionen √ºberhaupt nicht verglichen werden.  Die Klasse der Typen, die verglichen werden k√∂nnen, hei√üt <code>Eq</code> , Geordnet - <code>Ord</code> (Typen m√ºssen nicht numerisch sein).  Was durch √úbersetzen in eine Zeichenfolge gedruckt werden kann, geh√∂rt zur <code>Show</code> Klasse. Es gibt die "entgegengesetzte" <code>Read</code> Klasse, die bestimmt, wie Zeichenfolgen in Objekte des gew√ºnschten Typs konvertiert werden. </p><br><p>  F√ºr eine Reihe von Standardtypklassen (wie <code>Eq</code> , <code>Show</code> , <code>Read</code> ...) k√∂nnen Sie den Compiler auffordern, die gew√ºnschte Funktionalit√§t auf Standardweise zu implementieren, indem Sie das Schl√ºsselwort <code>deriving</code> nachdem Sie den Typ bestimmt haben: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Sie k√∂nnen Ihre eigenen Typklassen definieren: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint :: a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre> <br><p>  Hier ist <code>PrettyPrint</code> der Name der Klasse, <code>a</code> ist eine Typvariable.  Dem Schl√ºsselwort <code>where</code> folgt eine Liste der sogenannten Klassenmethoden, d.h.  Funktionen, die auf Objekte vom Typ dieser Klasse angewendet werden k√∂nnen. </p><br><p>  Um die Zugeh√∂rigkeit eines Datentyps zu einer Klasse anzuzeigen, wird die folgende Konstruktion verwendet: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint (<span class="hljs-type"><span class="hljs-type">Point</span></span> xy) = <span class="hljs-string"><span class="hljs-string">"("</span></span> ++ show x ++ <span class="hljs-string"><span class="hljs-string">", "</span></span> ++ show y ++ <span class="hljs-string"><span class="hljs-string">")"</span></span></code> </pre> <br><p>  In der Sprache k√∂nnen Sie Einschr√§nkungen f√ºr die Typklassen festlegen, auf die sich Funktionsargumente beziehen m√ºssen: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">showVsPretty</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> a) =&gt; a -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) showVsPretty x = (show x, pPrint x)</code> </pre> <br><p>  Bei jedem Funktionsaufruf pr√ºft der Compiler, ob diese Typanforderungen erf√ºllt sind, und zeigt im Fehlerfall einen Fehler an (dies geschieht nat√ºrlich in der Kompilierungsphase). </p><br><pre> <code class="haskell hljs">&gt;&gt;&gt; showVsPretty (<span class="hljs-type"><span class="hljs-type">Point</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">"Point {xCoord = 2.0, yCoord = 3.0}"</span></span>,<span class="hljs-string"><span class="hljs-string">"(2.0, 3.0)"</span></span>) &gt;&gt;&gt; showVsPretty <span class="hljs-string"><span class="hljs-string">"str"</span></span> error: <span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> for (<span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> [<span class="hljs-type"><span class="hljs-type">Char</span></span>]) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> 'showVsPretty'</code> </pre> <br><h1 id="realizaciya">  Implementierung </h1><br><p>  Der Parser erh√§lt eine Eingabezeichenfolge, die er nach vordefinierten Regeln analysieren und den Wert des ben√∂tigten Typs abrufen muss (z. B. eine Ganzzahl).  In diesem Fall endet die Eingabezeile m√∂glicherweise nicht und der Rest dient als Eingabe f√ºr die weitere Analyse.  Au√üerdem ist unser Parser im Allgemeinen nicht deterministisch, d. H.  gibt mehrere m√∂gliche Analyseergebnisse als Liste zur√ºck. </p><br><p>  Ein Tupel aus zwei Elementen <code>(String, a)</code> eignet sich zur Beschreibung eines Ergebnisses der Parser-Operation, wobei <code>a</code> eine Typvariable ist, die einen beliebigen Benutzertyp bezeichnen kann. </p><br><p>  Da der Parser die Zeichenfolge nach bestimmten Regeln analysiert, beschreiben wir sie als eine Funktion, die eine Zeichenfolge als Eingabe verwendet und eine Ergebnisliste zur√ºckgibt: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unParser</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; [(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)] }</span></span></code> </pre> <br><p>  Wir werden das Parsen als erfolgreich betrachten, wenn die Ergebnisliste aus einem Element besteht und die Eingabezeichenfolge vollst√§ndig verarbeitet wurde.  Wir implementieren eine Hilfsfunktion, die versucht, die gesamte Zeichenfolge eindeutig zu analysieren: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parseString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a parseString s (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (ps) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [(<span class="hljs-string"><span class="hljs-string">""</span></span>, val)] -&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> val _ -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre> <br><h2 id="prosteyshie-parsery">  Einfache Parser </h2><br><p>  Wir implementieren mehrere einfache Parser, die sich dann als n√ºtzlich erweisen, um komplexere Kombinationen zu erstellen. </p><br><p>  Wir beginnen mit dem Parsen eines einzelnen Zeichens, das ein Pr√§dikat erf√ºllen muss.  Wenn die Eingabezeichenfolge leer ist, ist das Ergebnis der Arbeit eine leere Liste.  Andernfalls √ºberpr√ºfen wir den Wert des Pr√§dikats f√ºr das erste Zeichen der Zeichenfolge.  Wenn <code>True</code> zur√ºckgegeben wird, ist das Ergebnis der Analyse dieses Zeichen.  Geben Sie es mit dem Rest der Zeichenfolge zur√ºck.  Andernfalls schl√§gt auch die Analyse fehl. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">predP</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> predP p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f <span class="hljs-string"><span class="hljs-string">""</span></span> = [] f (c : cs) | pc = [(cs, c)] | otherwise = []</code> </pre> <br><p>  Jetzt k√∂nnen wir einen Parser schreiben, der am Anfang der Zeile ein bestimmtes Zeichen enth√§lt.  Verwenden Sie dazu das gerade geschriebene <code>predP</code> und √ºbergeben Sie ihm als Argument eine Funktion, die sein Argument mit dem von uns ben√∂tigten Zeichen vergleicht: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">charP</span></span> :: <span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> charP char = predP (\c -&gt; c == char)</code> </pre> <br><p>  Der folgende einfachste Fall: Ein Parser, der nur eine bestimmte Zeichenfolge als Ganzes akzeptiert.  Nennen <code>stringP</code> es <code>stringP</code> .  Die Funktion im Parser vergleicht die Eingabezeile mit der gew√ºnschten und gibt bei gleichen Zeilen eine Liste mit einem Element zur√ºck: einem Paar leerer Zeilen (am Eingang ist nichts mehr √ºbrig) und der urspr√ºnglichen.  Andernfalls ist die Analyse fehlgeschlagen und eine leere Ergebnisliste wird zur√ºckgegeben. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">stringP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> stringP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs' | s == s' = [(<span class="hljs-string"><span class="hljs-string">""</span></span>, s)] | otherwise = []</code> </pre> <br><p>  Sehr oft m√ºssen Sie Zeichen mit einer bestimmten Eigenschaft √ºberspringen, w√§hrend sie an den Zeilenanfang gehen (z. B. Leerzeichen).  Dar√ºber hinaus ist das Ergebnis der Analyse f√ºr uns nicht wichtig und wird in Zukunft nicht mehr n√ºtzlich sein.  Wir schreiben eine <code>skip</code> , die die Anfangszeichen der Zeichenfolge <code>skip</code> , w√§hrend der wahre Wert des Pr√§dikats erhalten bleibt.  Als Analyseergebnis verwenden wir ein leeres Tupel. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skip</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skip p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(dropWhile ps, ())])</code> </pre> <br><p>  Die n√§chsten beiden Parser sind einander sehr √§hnlich.  Beide √ºberpr√ºfen das Eingabezeilenpr√§fix, nur das erste gibt dieses Pr√§fix zur√ºck, wenn es erfolgreich ist, und das zweite gibt ein leeres Tupel zur√ºck, d.h.  Mit dieser Option k√∂nnen Sie eine beliebige Zeile am Anfang der Eingabe √ºberspringen.  Die Implementierung verwendet die im Modul <code>isPrefixOf</code> definierte Funktion <code>Data.List</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">prefixP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> prefixP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, s)] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> [] skipString :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, ())] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> []</code> </pre> <br><p>  Wenig sp√§ter werden wir eine einfachere Implementierung der letzteren Funktion in Betracht ziehen und die Codeduplizierung beseitigen. </p><br><h2 id="parser-kak-funktor">  Parser als Funktor </h2><br><p>  Wir k√∂nnen eine ganze Klasse von Containertypen unterscheiden, f√ºr die Folgendes zutrifft: Wenn Sie wissen, wie Objekte in einem Container konvertiert werden, k√∂nnen Sie die Container selbst konvertieren.  Das einfachste Beispiel ist eine Liste als Container und eine <code>map</code> , die in fast allen Hochsprachen verf√ºgbar ist.  In der Tat k√∂nnen Sie alle Elemente einer Liste vom Typ <code>[a]</code> durchgehen, die Funktion <code>a -&gt; b</code> auf jede anwenden und eine Liste vom Typ <code>[b]</code> . </p><br><p>  Diese Typklasse hei√üt <code>Functor</code> , die Klasse verf√ºgt √ºber eine <code>fmap</code> Methode: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  Angenommen, wir wissen bereits, wie Zeichenfolgen in Objekte eines bestimmten Typs <code>a</code> analysiert werden, und wir wissen au√üerdem, wie Objekte vom Typ <code>a</code> in Objekte vom Typ <code>b</code> konvertiert werden.  Kann man sagen, dass es dann einen Parser f√ºr Objekte vom Typ <code>b</code> ? </p><br><p>  Wenn es in Form einer Funktion ausgedr√ºckt wird, hat es den folgenden Typ: </p><br><pre> <code class="haskell hljs">(a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  Dieser Typ stimmt mit dem Typ der <code>fmap</code> Funktion √ºberein. <code>fmap</code> wir also, den Parser zu einem Funktor zu machen.  Erstellen wir einen Parser mit Werten vom Typ <code>b</code> von Grund auf neu, der zuerst den ersten Parser aufruft (wir haben bereits einen) und dann die Funktion auf die Ergebnisse seiner Analyse anwendet. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b fmap f (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> p2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p2 :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] p2 s = convert (p1 s) convert :: [(<span class="hljs-type"><span class="hljs-type">String</span></span>, a)] -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] convert results = map (\(s, val) -&gt; (s, f val)) results</code> </pre> <br><p>  Die Funktion <code>fmap</code> hat ein praktisches Infix-Synonym: <code>fmap fx == f &lt;$&gt; x</code> . </p><br><p>  Wenn wir eine Funktion als Argument f√ºr <code>fmap</code> , die einfach das erste Argument durch einen neuen Wert ersetzt, erhalten wir eine weitere n√ºtzliche Operation, die bereits in zwei F√§llen f√ºr alle Funktoren implementiert ist (sie unterscheiden sich nur in der Reihenfolge der Argumente): </p><br><pre> <code class="plaintext hljs">(&lt;$) :: Functor f =&gt; a -&gt; fb -&gt; fa ($&gt;) :: Functor f =&gt; fa -&gt; b -&gt; fb</code> </pre> <br><p>  Erinnern Sie sich an den Parser, der eine bestimmte Zeile √ºberspringt ( <code>skipString</code> )?  Jetzt k√∂nnen Sie es wie folgt implementieren: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skipString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = () &lt;$ prefixP s</code> </pre> <br><h2 id="kombinacii-parserov">  Parser-Kombinationen </h2><br><p>  In Haskell sind alle Funktionen standardm√§√üig aktiviert und teilweise verwendbar.  Dies bedeutet, dass eine Funktion von <code>n</code> Argumenten tats√§chlich eine Funktion eines Arguments ist und eine Funktion von <code>n-1</code> Argumenten zur√ºckgibt: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">cons</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons = (:) cons1 :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons1 = cons <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">--  cons  </span></span></code> </pre> <br><p>  Wir wenden eine Funktion aus drei Argumenten mit <code>fmap</code> auf einen Wert im Parser <code>fmap</code> .  Die Typen sind wie folgt: </p><br><pre> <code class="plaintext hljs">f :: c -&gt; a -&gt; b p :: Parser c (fmap fp) :: Parser (a -&gt; b)</code> </pre> <br><p>  Der Funktionsparser hat sich herausgestellt ?!  Nat√ºrlich ist eine Situation m√∂glich, in der sich die Darstellung der Funktion tats√§chlich in der Eingabezeile befindet, aber ich m√∂chte diese Funktion verwenden oder vielmehr die <code>Parser (a -&gt; b)</code> und <code>Parser a</code> kombinieren k√∂nnen, um <code>Parser b</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  Der Typ dieser Funktion ist dem <code>fmap</code> Typ sehr √§hnlich, nur die Funktion selbst, die angewendet werden muss, befindet sich ebenfalls im Container.  Dies gibt ein intuitives Verst√§ndnis daf√ºr, wie die Implementierung der Funktion <code>applyP</code> aussehen sollte: <code>applyP</code> sich die Funktion aus dem Container (als Ergebnis der Anwendung des ersten Parsers), rufen Sie die Werte ab, auf die die Funktion <code>applyP</code> werden soll (Ergebnis der Anwendung des zweiten Parsers), und "packen" Sie die mit dieser Funktion konvertierten Werte zur√ºck in den Container (neuen Parser erstellen).  In der Implementierung verwenden wir das Listenverst√§ndnis: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b applyP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs = [ (sx, fx) | (sf, f) &lt;- p1 s, <span class="hljs-comment"><span class="hljs-comment">-- p1     (sx, x) &lt;- p2 sf] -- p2   ,    </span></span></code> </pre> <br><p>  Es gibt eine <code>Applicative</code> Klasse mit einer Methode mit demselben Prototyp.  Die zweite Methode der Klasse hei√üt <code>pure</code> und wird verwendet, <em>um</em> einen Wert, einschlie√ülich eines funktionalen, zu "wickeln" oder zu "heben" (zu <em>heben</em> ).  Bei der Implementierung f√ºr den Parser f√ºgt die Funktion <code>pure</code> ihr Argument zum Ergebnis des Parsers hinzu, ohne die Eingabezeichenfolge zu √§ndern. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pure :: a -&gt; fa (&lt;*&gt;) :: f (a -&gt; b) -&gt; fa -&gt; fb <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Applicative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> pure x = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(s, x)]) pf &lt;*&gt; px = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [ (sx, fx) | (sf, f) &lt;- unParser pf $ s, (sx, x) &lt;- unParser px $ sf])</code> </pre> <br><p>  Die Funktion <code>applyP</code> ist das <code>&lt;*&gt;</code> aus der Klasse <code>Applicative</code> .  Typen, die zu dieser Klasse geh√∂ren, werden als anwendungsbezogene Funktoren bezeichnet. </p><br><p>  F√ºr anwendungsbezogene Funktoren sind zwei Hilfsfunktionen implementiert, die f√ºr uns n√ºtzlich sind: </p><br><pre> <code class="haskell hljs">(*&gt;) :: fa -&gt; fb -&gt; fb (&lt;*) :: fa -&gt; fb -&gt; fa</code> </pre> <br><p>  Diese Funktionen f√ºhren zwei aufeinanderfolgende Aktionen aus und geben nur das Ergebnis einer von ihnen zur√ºck.  F√ºr Parser k√∂nnen sie beispielsweise verwendet werden, um f√ºhrende Leerzeichen zu √ºberspringen, bevor ein Teil eines Strings analysiert wird, der eine semantische Last tr√§gt. </p><br><p>  Durch die Kombination von <code>&lt;$&gt;</code> und <code>&lt;*&gt;</code> k√∂nnen Sie sehr praktische Designs erstellen.  Betrachten Sie den folgenden Datentyp: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStructType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStruct</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type1</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field2</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type2</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field3</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type3</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Der Konstruktor der Werte <code>MyStruct</code> ist ebenfalls eine Funktion, in diesem Fall vom Typ <code>Type1 -&gt; Type2 -&gt; Type3 -&gt; MyStructType</code> .  Sie k√∂nnen mit dem Konstruktor wie mit jeder anderen Funktion arbeiten.  Angenommen, Parser wurden bereits f√ºr die Arten von Strukturfeldern geschrieben: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parser1</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type1</span></span> parser2 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type2</span></span> parser3 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type3</span></span></code> </pre> <br><p>  Mit der Funktion <code>fmap</code> k√∂nnen Sie <code>MyStruct</code> teilweise auf den ersten dieser Parser anwenden: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct'</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct' = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1</code> </pre> <br><p>  Versuchen wir, die Funktion anzuwenden, die sich jetzt "innerhalb" des Parsers befindet.  Dazu m√ºssen Sie bereits <code>&lt;*&gt;</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct''</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct'' = parserStruct' &lt;*&gt; parser2 parserStruct :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = parserStruct'' &lt;*&gt; parser3</code> </pre> <br><p>  Als Ergebnis haben wir einen Parser f√ºr die gesamte Struktur erhalten (hier gehen wir nat√ºrlich davon aus, dass in der urspr√ºnglichen Zeile die Darstellungen der Felder in einer Reihe stehen).  Das gleiche kann in einer Zeile gemacht werden: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1 &lt;*&gt; parser2 &lt;*&gt; parser3</code> </pre> <br><p>  Solche Konstruktionen treten h√§ufig in Anwendungsf√§llen auf. </p><br><p>  Angenommen, wir versuchen, einen Parser zu schreiben, der einfache arithmetische Ausdr√ºcke analysiert, in denen Ganzzahlen und Bezeichner als Operanden vorhanden sein k√∂nnen.  Erstellen <code>Operand</code> f√ºr sie einen separaten <code>Operand</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operand</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IntOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IdentOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span></span></code> </pre> <br><p>  Wenn wir bereits wissen, wie Ganzzahlen und Bezeichner analysiert werden (z. B. wie in C), ben√∂tigen wir <em>einen</em> Parser f√ºr Operanden, die den einen oder anderen analysieren k√∂nnen.  Dieser Parser ist eine Alternative zu den beiden anderen. Daher ben√∂tigen wir eine Funktion, mit der Parser kombiniert werden k√∂nnen, damit die Ergebnisse ihrer Arbeit kombiniert werden.  Das Ergebnis des Parsers ist eine Liste, und das Kombinieren von Listen ist deren Verkettung.  Wir implementieren die <code>altP</code> Funktion, die zwei Parser kombiniert: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">altP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a altP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; p1 s ++ p2 s)</code> </pre> <br><p>  Dann kann der Operandenparser mit dieser Funktion implementiert werden (hier wird angenommen, dass <code>parserInt</code> und <code>parserIdent</code> bereits irgendwo beschrieben sind: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserOperand</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Operand</span></span> parserOperand = altP parserIntOp parserIdentOp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> parserIntOp = <span class="hljs-type"><span class="hljs-type">IntOp</span></span> &lt;$&gt; parserInt parserIdentOp = <span class="hljs-type"><span class="hljs-type">IdentOp</span></span> &lt;$&gt; parserIdent</code> </pre> <br><p>  Nat√ºrlich haben wir f√ºr Alternativen bereits eine separate Klasse entwickelt, die <code>Alternative</code> hei√üt.  Es gibt eine andere Methode, <code>empty</code> , die das neutrale Element f√ºr die alternative Operation beschreibt.  In unserem Fall ist es ein Parser, der niemals etwas analysiert, d. H.  Gibt immer eine leere Ergebnisliste zur√ºck.  F√ºr den Parser sieht die Implementierung der Methoden der <code>Alternative</code> Klasse folgenderma√üen aus: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alternative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> empty :: fa (&lt;|&gt;) :: fa -&gt; fa -&gt; fa <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Alternative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> empty = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (const []) px &lt;|&gt; py = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; unParser px s ++ unParser py s)</code> </pre> <br><p>  Die Operation <code>&lt;|&gt;</code> ist die <code>altP</code> Funktion nur in Infix-Notation. <code>altP</code> ist bequemer, wenn mehrere Parser hintereinander kombiniert werden. </p><br><p>  F√ºr alle Typen in dieser Klasse sind zwei Funktionen implementiert, <code>some</code> und <code>many</code> Typ <code>fa -&gt; f [a]</code> .  Jeder von ihnen kann durch den anderen ausgedr√ºckt werden: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">some</span></span> v = (:) &lt;$&gt; v &lt;*&gt; many v many v = some v &lt;|&gt; pure []</code> </pre> <br><p>  In Bezug auf Parser k√∂nnen Sie mit diesen Funktionen Datensequenzen analysieren, wenn Sie wissen, wie ein einzelnes Datenelement analysiert wird.  Wenn Sie <code>some</code> darf <code>some</code> Sequenz nicht leer sein. </p><br><h1 id="primer-ispolzovaniya">  Anwendungsbeispiel </h1><br><p>  Jetzt k√∂nnen wir Ihren eigenen Parser schreiben, zum Beispiel f√ºr einfache arithmetische Ausdr√ºcke mit der folgenden Grammatik: </p><br><pre> <code class="plaintext hljs"> expr ::= constExpr | binOpExpr | negExpr const ::= int int ::= digit{digit} digit ::= '0' | ... | '9' binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binOp ::= '+' | '*' negExpr ::= '-' expr</code> </pre> <br><p>  Der Ausdruck besteht aus ganzzahligen Konstanten, dem un√§ren Minus und zwei bin√§ren Infix-Operationen: Addition und Multiplikation.  Um einen Ausdruck mit einer bin√§ren Operation sind Klammern erforderlich. Das Operationssymbol ist durch genau ein Leerzeichen von den Operanden getrennt. F√ºhrende und h√§ngende Leerzeichen sind nicht zul√§ssig. </p><br><p>  Beispiele f√ºr das Schreiben korrekter Ausdr√ºcke: </p><br><pre> <code class="plaintext hljs">"123" "-(10 + 42)" "(1 + ((2 + 3) * (4 + 5)))"</code> </pre> <br><p>  Beispiele f√ºr falsche Eintr√§ge: </p><br><pre> <code class="plaintext hljs">" 666 " "2 + 3" "(10 * 10)"</code> </pre> <br><p>  Wir deklarieren die notwendigen Datentypen (den Ausdruck selbst und die bin√§re Operation): </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConstExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinaryExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NegateExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mul</span></span></span></span></code> </pre> <br><p>  Sie k√∂nnen mit dem Parsen beginnen!  Der Ausdruck selbst besteht aus drei Alternativen.  Also schreiben wir: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- expr ::= constExpr | binOpExpr | negExpr exprParser :: Parser Expr exprParser = constParser &lt;|&gt; binParser &lt;|&gt; negParser</span></span></code> </pre> <br><p>  Eine Konstante ist eine positive ganze Zahl.  In unserem Datentyp wird er im Konstruktor "umbrochen", sodass wir den Parser nicht direkt f√ºr eine Ganzzahl verwenden k√∂nnen, sondern <code>fmap</code> verwenden <code>fmap</code> , um den Wert des gew√ºnschten Typs <code>fmap</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- const ::= int constParser :: Parser Expr constParser = ConstExpr &lt;$&gt; intParser</span></span></code> </pre> <br><p>  Eine ganze Zahl wird gem√§√ü der Grammatik als nicht leere Folge von Zahlen dargestellt.  Um eine Ziffer zu analysieren, verwenden wir die Hilfsfunktion <code>predP</code> und das Pr√§dikat <code>isDigit</code> aus dem <code>Data.Char</code> Modul.  Um einen Parser zum Parsen einer Ziffernfolge zu erstellen, verwenden wir die Funktion <code>some</code> (nicht <code>many</code> , da mindestens eine Ziffer vorhanden sein muss).  Das Ergebnis eines solchen Parsers gibt eine Liste aller m√∂glichen Parsing-Optionen zur√ºck, beginnend mit dem l√§ngsten Datensatz.  Wenn die Eingabezeichenfolge beispielsweise "123ab" lautet, lautet die Liste der Ergebnisse wie folgt: <code>[("ab", "123"), ("3ab", "12"), ("23ab", "1")]</code> .  Wir m√ºssen die l√§ngste Folge von Ziffern analysieren und in den Typ <code>Int</code> konvertieren.  Die gesamte Implementierung ist wie folgt: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- int ::= digit{digit} -- digit ::= '0' | ... | '9' intParser :: Parser Int intParser = Parser $ \s -&gt; let res = unParser (some digitParser) s in case res of [] -&gt; [] ((rest, i) : xs) -&gt; [(rest, read i)] where digitParser = predP isDigit</span></span></code> </pre> <br><p>  Die n√§chste M√∂glichkeit, einen Ausdruck zu schreiben, besteht darin, eine bin√§re Operation zu verwenden.  Gem√§√ü der Grammatik muss die √∂ffnende Klammer zuerst die √∂ffnende Klammer, den ersten Operanden, das Leerzeichen, das Operationssymbol, ein anderes Leerzeichen, den zweiten Operanden und die schlie√üende Klammer enthalten.  Um einzelne Zeichen (Klammern und Leerzeichen) zu analysieren, verwenden wir die Funktion <code>charP</code> .  Operanden sind Ausdr√ºcke, und es gibt bereits einen Parser ( <code>exprParser</code> ), um sie zu analysieren.  Um das Symbol f√ºr die bin√§re Operation zu analysieren, beschreiben wir den folgenden Hilfsparser.  Es bleibt, diesen Satz von Parsern ordentlich zu kombinieren.  Am Anfang und am Ende des Ausdrucks sollten Klammern stehen: Sie m√ºssen dies √ºberpr√ºfen, aber das Ergebnis selbst verwerfen.  Verwenden Sie dazu <code>*&gt;</code> und <code>&lt;*</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">binParser</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Expr</span></span> binParser = charP '(' *&gt; ??? &lt;* charP ')'</code> </pre> <br><p>  Zwischen diesen Parsern f√ºr Klammern muss ein Ausdruck mit dem <code>BinaryExpr</code> Konstruktor und Parsern f√ºr den Ausdruck und die Operation erstellt werden.  Vergessen Sie nicht die Leerzeichen um das Operationssymbol. Verwenden Sie dabei die gleiche Methode wie f√ºr die Klammern.  Dieser Teil ist wie folgt: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">BinaryExpr</span></span> &lt;$&gt; exprParser <span class="hljs-comment"><span class="hljs-comment">--   &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') -- ,   &lt;*&gt; exprParser --  </span></span></code> </pre> <br><p>  Wir ersetzen diesen Ausdruck anstelle von Fragezeichen: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binParser :: Parser Expr binParser = charP '(' *&gt; (BinaryExpr &lt;$&gt; exprParser &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') &lt;*&gt; exprParser ) &lt;* charP ')'</span></span></code> </pre> <br><p>  Eine bin√§re Operation ist entweder ein <code>+</code> Zeichen, das den <code>Add</code> Wert analysiert, oder <code>*</code> , das den <code>Mul</code> analysiert: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOp ::= '+' | '*' binOpParser :: Parser Operator binOpParser = plusParser &lt;|&gt; multParser where plusParser = charP '+' $&gt; Add multParser = charP '*' $&gt; Mul</span></span></code> </pre> <br><p>  Der einfachste Teil der Grammatik bleibt die Negation des Ausdrucks.  Mit einem Symbol machen <code>-</code> dasselbe wie mit Klammern und Leerzeichen.  <code>NegateExpr</code> N√§chstes den <code>NegateExpr</code> Konstruktor auf das Ergebnis der rekursiven Analyse an: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- negExpr ::= '-' expr negParser = charP '-' *&gt; (NegateExpr &lt;$&gt; exprParser)</span></span></code> </pre> <br><p>  Somit sind alle Teile des Parsers implementiert.  Der Code √§hnelt einer Grammatik und stimmt in seiner Struktur vollst√§ndig mit ihm √ºberein. </p><br><p>  Der Quellcode ist unter GitLab verf√ºgbar: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://gitlab.com/fierce-katie/applicative-parsers-demo</a> . </p><br><p>  Dort ist es einfacher, das Volumen und den Grad der Ausdruckskraft zu bewerten, da es viel weniger Kommentare gibt.  Sie k√∂nnen das Projekt mit dem Dienstprogramm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stack</a> kompilieren und den primitiven Interpreter mit dem von uns geschriebenen Parser ausf√ºhren: </p><br><pre> <code class="plaintext hljs">$ stack build $ stack exec demo-parser</code> </pre> <br><p>  F√ºr diejenigen, die alleine weiter √ºben m√∂chten, kann ich Folgendes empfehlen: </p><br><ul><li>  Die Grammatik kann in jeder Hinsicht verbessert werden, um beispielsweise f√ºhrende und h√§ngende Leerzeichen zuzulassen, neue Operationen hinzuzuf√ºgen usw. </li><li>  Der Parser √ºbersetzt die Zeichenfolge in die interne Darstellung des Ausdrucks.  Dieser Ausdruck kann berechnet und der Interpreter so konvertiert werden, dass nicht das Ergebnis der Analyse, sondern das Ergebnis der Berechnung gedruckt wird. </li><li>  Entdecken Sie die M√∂glichkeiten der <code>applicative-parsec</code> <code>attoparsec</code> , <code>attoparsec</code> , <code>optparse-applicative</code> und <code>optparse-applicative</code> und versuchen Sie, sie zu verwenden. </li></ul><br><p>  Vielen Dank f√ºr Ihre Aufmerksamkeit! </p><br><h1 id="poleznye-materialy">  N√ºtzliche Materialien </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lerne Haskell in Y Minuten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Denis Shevchenko.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"√úber Haskell als Mensch"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parsec-Bibliothek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Attoparsec-Bibliothek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Applicative-Parsec-Bibliothek</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Optparse-anwendbare Bibliothek</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436234/">https://habr.com/ru/post/de436234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436224/index.html">Wir schreiben unsere Programmiersprache, Teil 4: Darstellung von Strukturen und Klassen, Generierung von Allokatoren</a></li>
<li><a href="../de436226/index.html">Leitfaden und Spickzettel f√ºr Wireshark</a></li>
<li><a href="../de436228/index.html">Entwicklung eines Teams zum Abfragen von Daten aus der Datenbank</a></li>
<li><a href="../de436230/index.html">So √ºbernehmen Sie die Kontrolle √ºber Ihre Netzwerkinfrastruktur. Kapitel Drei Netzwerksicherheit. Teil zwei</a></li>
<li><a href="../de436232/index.html">Telepathie-Strategie</a></li>
<li><a href="../de436236/index.html">Wir verwenden Data Science, um den Lebenszyklus eines Kunden zu bestimmen</a></li>
<li><a href="../de436238/index.html">Authentifizierung in Kubernetes mit GitHub OAuth und Dex</a></li>
<li><a href="../de436240/index.html">Automatisierung gegen Chaos</a></li>
<li><a href="../de436242/index.html">YOLO und andere lose Methoden</a></li>
<li><a href="../de436244/index.html">Professor Lawrences neues Gehirn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>