<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👊🏼 🎅🏻 👨‍🎓 Annotations à la compilation en utilisant @Implement comme exemple 🤴🏾 🚯 🏖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous aimons tous détecter les erreurs lors de la compilation, au lieu des exceptions d'exécution. Le moyen le plus simple de les corriger est que le c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Annotations à la compilation en utilisant @Implement comme exemple</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414715/"><img src="https://habrastorage.org/webt/zq/9v/1a/zq9v1afhchg4c2ft1koorkjfcss.png"><br><br>  Nous aimons tous détecter les erreurs lors de la compilation, au lieu des exceptions d'exécution.  Le moyen le plus simple de les corriger est que le compilateur lui-même affiche tous les endroits qui doivent être corrigés.  Bien que la plupart des problèmes ne puissent être détectés qu'au démarrage du programme, nous essayons toujours de le faire dès que possible. <a name="habracut"></a>  En blocs d'initialisation de classes, en constructeurs d'objets, au premier appel d'une méthode, etc.  Et parfois, nous avons de la chance, et même au stade de la compilation, nous en savons assez pour vérifier le programme pour certaines erreurs. <br><br>  Dans cet article, je veux partager l'expérience de la rédaction d'un tel test.  Plus précisément, créer une annotation pouvant générer des erreurs, comme le fait le compilateur.  A en juger par le fait qu'il n'y a pas tant d'informations sur ce sujet dans RuNet, les situations heureuses décrites ci-dessus ne le sont pas souvent. <br><br>  Je décrirai l'algorithme général de vérification, ainsi que toutes les étapes et nuances pour lesquelles j'ai passé du temps et des cellules nerveuses. <br><br><h3>  Énoncé du problème </h3><br>  Dans cette section, je vais donner un exemple d'utilisation de cette annotation.  Si vous savez déjà quelle vérification vous voulez faire, vous pouvez la sauter en toute sécurité.  Je suis sûr que cela n'affectera pas l'intégralité de la présentation. <br><br>  Maintenant, nous parlerons davantage de l'amélioration de la lisibilité du code que de la correction des bogues.  Un exemple, on pourrait dire, de la vie, ou plutôt de mon projet de loisir. <br><br>  Supposons qu'il existe une classe UnitManager, qui, en fait, est une collection d'unités.  Il a des méthodes pour ajouter, supprimer, obtenir une unité, etc.  Lors de l'ajout d'une nouvelle unité, le gestionnaire lui attribue un identifiant.  La génération d'id est déléguée à la classe RotateCounter, qui renvoie un nombre dans la plage donnée.  Et il y a un petit problème, RotateCounter ne peut pas savoir si l'ID sélectionné est libre.  Selon le principe de l'inversion de dépendance, vous pouvez créer une interface, dans mon cas, c'est RotateCounter.IClient, qui a une seule méthode isValueFree (), qui reçoit id et renvoie true si id est libre.  Et UnitManager implémente cette interface, crée une instance de RotateCounter et la transmet à lui-même en tant que client. <br><br>  J'ai fait juste ça.  Mais, après avoir ouvert la source de UnitManager quelques jours après avoir écrit, je suis tombé dans une stupeur facile après avoir vu la méthode isValueFree (), qui ne correspondait pas vraiment à la logique de UnitManager.  Il serait beaucoup plus simple s'il était possible de spécifier quelle interface implémente cette méthode.  Par exemple, en C #, d'où je suis venu à Java, une implémentation d'interface explicite permet de faire face à ce problème.  Dans ce cas, tout d'abord, vous ne pouvez appeler la méthode qu'avec un transtypage explicite vers l'interface.  Deuxièmement, et plus important dans ce cas, le nom de l'interface (et sans le modificateur d'accès) est explicitement indiqué dans la signature de la méthode, par exemple: <br><br><pre><code class="cs hljs">IClient.isValueFree(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { }</code> </pre> <br>  Une solution consiste à ajouter une annotation avec le nom de l'interface qui implémente cette méthode.  Quelque chose comme <code>@Override</code> , uniquement avec une interface.  Je suis d'accord, vous pouvez utiliser une classe interne anonyme.  Dans ce cas, tout comme en C #, la méthode ne peut pas simplement être appelée sur l'objet, et vous pouvez immédiatement voir quelle interface elle implémente.  Mais cela augmentera la quantité de code, par conséquent, dégradera la lisibilité.  Oui, et vous devez en quelque sorte l'obtenir de la classe - créez un getter ou un champ public (après tout, il n'y a pas de surcharge d'instructions cast en Java non plus).  Pas une mauvaise option, mais je n'aime pas ça. <br><br>  Au début, je pensais qu'en Java, comme en C #, les annotations sont des classes complètes et peuvent en être héritées.  Dans ce cas, il vous suffit de créer une annotation qui hérite de <code>@Override</code> .  Mais ce n'était pas le cas, et j'ai dû plonger dans le monde étonnant et effrayant des chèques au stade de la compilation. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de code UnitManager</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Unit[] units; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RotateCounter idGenerator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Unit[size]; idGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RotateCounter(<span class="hljs-number"><span class="hljs-number">0</span></span>, size, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Unit unit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = idGenerator.findFree(); units[id] = unit; } <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(RotateCounter.IClient.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> units[value] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ units[id] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IClient client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, IClient client)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client = client; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.minValue = minValue; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maxValue = maxValue; next = minValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementAndGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current = next; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next &gt;= maxValue) { next = minValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } next++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> maxValue - minValue + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> range = range(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> trysCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++trysCounter &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"No free values."</span></span>); } id = incrementAndGet(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!client.isValueFree(id)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span></span>; } }</code> </pre></div></div><br><h3>  Un peu de théorie </h3><br>  Je ferai une réservation tout de suite, toutes les méthodes ci-dessus sont des instances, donc, par souci de concision, je vais indiquer les noms de méthode avec le nom de type et sans paramètres: <code>&lt;_&gt;.&lt;_&gt;()</code> . <br><br>  Le traitement des éléments au stade de la compilation implique des classes de processeur spéciales.  Ce sont des classes qui héritent de <code>javax.annotation.processing.AbstractProcessor</code> (vous pouvez simplement implémenter l'interface <code>javax.annotation.processing.Processor</code> ).  Vous pouvez en savoir plus sur les processeurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  La méthode la plus importante est le processus.  Dans lequel nous pouvons obtenir une liste de tous les éléments annotés et effectuer les vérifications nécessaires. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br>  Au début, sincèrement naïf, je pensais que travailler avec des types au stade de la compilation se faisait en termes de réflexion, mais ... non.  Tout est basé sur des éléments là-bas. <br><br>  <b>Element</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javax.lang.model.element.Element</a> ) - l'interface principale pour travailler avec la plupart des éléments structurels du langage.  Un élément a des descendants qui déterminent plus précisément les propriétés d'un élément particulier (pour plus de détails, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ds.magic.example.implement; <span class="hljs-comment"><span class="hljs-comment">// PackageElement public class Unit // TypeElement { private int id; // VariableElement public void setId(int id) { // ExecutableElement this.id = id; } }</span></span></code> </pre> <br>  <b>TypeMirror</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javax.lang.model.type.TypeMirror</a> ) est quelque chose comme Class &lt;?&gt; Renvoyé par la méthode getClass ().  Par exemple, ils peuvent être comparés pour savoir si les types d'éléments correspondent.  Vous pouvez l'obtenir en utilisant la méthode <code>Element.asType()</code> .  Ce type renvoie également certaines opérations de type, telles que <code>TypeElement.getSuperclass()</code> ou <code>TypeElement.getInterfaces()</code> . <br><br>  <b>Types</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javax.lang.model.util.Types</a> ) - Je vous conseille de regarder de plus près cette classe.  Vous pouvez y trouver beaucoup de choses intéressantes.  En substance, il s'agit d'un ensemble d'utilitaires pour travailler avec des types.  Par exemple, il vous permet de récupérer un TypeElement à partir d'un TypeMirror. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asTypeElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeMirror typeMirror)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TypeElement)processingEnv.getTypeUtils().asElement(typeMirror); }</code> </pre> <br>  <b>TypeKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javax.lang.model.type.TypeKind</a> ) - une énumération qui vous permet de clarifier les informations de type, de vérifier si le type est un tableau (ARRAY), un type personnalisé (DECLARED), une variable de type (TYPEVAR), etc.  Vous pouvez l'obtenir via <code>TypeMirror.getKind()</code> <br><br>  <b>ElementKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javax.lang.model.element.ElementKind</a> ) - énumération, vous permet de clarifier les informations sur l'élément, de vérifier si l'élément est un paquet (PACKAGE), une classe (CLASS), une méthode (METHOD), une interface (INTERFACE), etc. <br><br>  <b>Nom</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javax.lang.model.element.Name</a> ) - l'interface pour travailler avec le nom de l'élément, peut être obtenue via <code>Element.getSimpleName()</code> . <br><br>  Fondamentalement, ces types me suffisaient pour écrire un algorithme de vérification. <br><br>  Je veux noter une autre caractéristique intéressante.  Les implémentations des interfaces Element dans Eclipse se trouvent dans les packages org.eclipse ..., par exemple, les éléments qui représentent les méthodes sont de type <code>org.eclipse.jdt.internal.compiler.apt.model.ExecutableElementImpl</code> .  Cela m'a donné l'idée que ces interfaces sont implémentées par chaque IDE indépendamment. <br><br><h3>  Algorithme de validation </h3><br>  Vous devez d'abord créer l'annotation elle-même.  Beaucoup a déjà été écrit à ce sujet (par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ), donc je ne m'attarderai pas là-dessus en détail.  Je peux seulement dire que pour notre exemple, nous devons ajouter deux annotations <code>@Target</code> et <code>@Retention</code> .  La première indique que notre annotation ne peut être appliquée qu'à la méthode, et la seconde que l'annotation n'existera que dans le code source. <br><br>  Les annotations doivent être spécifiées quelle interface implémente la méthode annotée (la méthode à laquelle l'annotation est appliquée).  Cela peut être fait de deux manières: soit spécifiez le nom complet de l'interface avec une chaîne, par exemple <code>@Implement("com.ds.IInterface")</code> , soit passez directement la classe d'interface: <code>@Implement(IInterface.class)</code> .  La deuxième voie est clairement meilleure.  Dans ce cas, le compilateur surveillera le nom d'interface correct.  Par ailleurs, si vous appelez ce membre <b>value (),</b> lors de l'ajout d'annotations à la méthode, vous n'aurez pas besoin de spécifier explicitement le nom de ce paramètre. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.METHOD}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.SOURCE) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Implement { Class&lt;?&gt; value(); }</code> </pre> <br>  Ensuite, le plaisir commence - la création du processeur.  Dans la méthode du processus, nous obtenons une liste de tous les éléments annotés.  Ensuite, nous obtenons l'annotation elle-même et sa signification - l'interface spécifiée.  En général, le cadre de classe de processeur ressemble à ceci: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SupportedAnnotationTypes</span></span>({<span class="hljs-string"><span class="hljs-string">"ds.magic.annotations.compileTime.Implement"</span></span>}) <span class="hljs-meta"><span class="hljs-meta">@SupportedSourceVersion</span></span>(SourceVersion.RELEASE_8) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplementProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Types typeUtils; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessingEnvironment procEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.init(procEnv); typeUtils = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.processingEnv.getTypeUtils(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annos, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;? extends Element&gt; annotatedElements = env.getElementsAnnotatedWith(Implement.class); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Element annotated : annotatedElements) { Implement annotation = annotatedElement.getAnnotation(Implement.class); TypeMirror interfaceMirror = getValueMirror(annotation); TypeElement interfaceType = asTypeElement(interfaceMirror); <span class="hljs-comment"><span class="hljs-comment">//... } return false; } private TypeElement asTypeElement(TypeMirror typeMirror) { return (TypeElement)typeUtils.asElement(typeMirror); } }</span></span></code> </pre> <br>  Je veux noter que vous ne pouvez pas simplement obtenir et obtenir des annotations de valeur comme ça.  Lorsque vous essayez d'appeler <code>annotation.value()</code> , une <b>exception MirroredTypeException</b> est levée, mais vous pouvez en obtenir un TypeMirror.  Cette méthode de triche, ainsi que la bonne réception de la valeur, j'ai trouvé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeMirror </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValueMirror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Implement annotation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { annotation.value(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(MirroredTypeException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.getTypeMirror(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  La vérification elle-même se compose de trois parties, si au moins l'une d'entre elles échoue, vous devez afficher un message d'erreur et passer à l'annotation suivante.  Par ailleurs, vous pouvez afficher un message d'erreur à l'aide de la méthode suivante: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message, Element annotatedElement)</span></span></span><span class="hljs-function"> </span></span>{ Messager messager = processingEnv.getMessager(); messager.printMessage(Kind.ERROR, message, annotatedElement); }</code> </pre> <br>  La première étape consiste à vérifier si les annotations de valeur sont une interface.  Ici, tout est simple: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceType.getKind() != ElementKind.INTERFACE) { String name = Implement.class.getSimpleName(); printError(<span class="hljs-string"><span class="hljs-string">"Value of @"</span></span> + name + <span class="hljs-string"><span class="hljs-string">" must be an interface"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Ensuite, vous devez vérifier si la classe dans laquelle se trouve la méthode annotée implémente réellement l'interface spécifiée.  Au début, j'ai implémenté ce test avec mes mains.  Mais ensuite, en utilisant de bons conseils, j'ai regardé <b>Types</b> et y <code>Types.isSubtype()</code> trouvé la méthode <code>Types.isSubtype()</code> , qui vérifiera l'arborescence d'héritage entière et retournera true si l'interface spécifiée est là.  Surtout, il peut fonctionner avec des types génériques, contrairement à la première option. <br><br><pre> <code class="java hljs">TypeElement enclosingType = (TypeElement)annotatedElement.getEnclosingElement(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!typeUtils.isSubtype(enclosingType.asType(), interfaceMirror)) { Name className = enclosingType.getSimpleName(); Name interfaceName = interfaceType.getSimpleName(); printError(className + <span class="hljs-string"><span class="hljs-string">" must implemet "</span></span> + interfaceName, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Enfin, vous devez vous assurer que l'interface possède une méthode avec la même signature que celle annotée.  Je voudrais utiliser la méthode <code>Types.isSubsignature()</code> , mais, malheureusement, cela ne fonctionne pas correctement si la méthode a des paramètres de type.  Alors nous retroussons nos manches et écrivons tous les chèques avec nos mains.  Et nous en avons encore trois.  Eh bien, plus précisément, la signature de la méthode se compose de trois parties: le nom de la méthode, le type de la valeur de retour et la liste des paramètres.  Vous devez parcourir toutes les méthodes de l'interface et trouver celle qui a réussi les trois vérifications.  Il serait bon de ne pas oublier que la méthode peut être héritée d'une autre interface et effectuer récursivement les mêmes vérifications pour les interfaces sous-jacentes. <br><br>  L'appel doit être placé à la fin de la boucle dans la méthode de processus, comme ceci: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!haveMethod(interfaceType, (ExecutableElement)annotatedElement)) { Name name = interfaceType.getSimpleName(); printError(name + <span class="hljs-string"><span class="hljs-string">" don't have \""</span></span> + annotated + <span class="hljs-string"><span class="hljs-string">"\" method"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Et la méthode haveMethod () elle-même ressemble à ceci: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">haveMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeElement interfaceType, ExecutableElement method)</span></span></span><span class="hljs-function"> </span></span>{ Name methodName = method.getSimpleName(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Element interfaceElement : interfaceType.getEnclosedElements()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceElement <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExecutableElement) { ExecutableElement interfaceMethod = (ExecutableElement)interfaceElement; <span class="hljs-comment"><span class="hljs-comment">// Is names match? if (!interfaceMethod.getSimpleName().equals(methodName)) { continue; } // Is return types match (ignore type variable)? TypeMirror returnType = method.getReturnType(); TypeMirror interfaceReturnType = method.getReturnType(); if (!isTypeVariable(interfaceReturnType) &amp;&amp; !returnType.equals(interfaceReturnType)) { continue; } // Is parameters match? if (!isParametersEquals(method.getParameters(), interfaceMethod.getParameters())) { continue; } return true; } } // Recursive search for (TypeMirror baseMirror : interfaceType.getInterfaces()) { TypeElement base = asTypeElement(baseMirror); if (haveMethod(base, method)) { return true; } } return false; } private boolean isParametersEquals(List&lt;? extends VariableElement&gt; methodParameters, List&lt;? extends VariableElement&gt; interfaceParameters) { if (methodParameters.size() != interfaceParameters.size()) { return false; } for (int i = 0; i &lt; methodParameters.size(); i++) { TypeMirror interfaceParameterMirror = interfaceParameters.get(i).asType(); if (isTypeVariable(interfaceParameterMirror)) { continue; } if (!methodParameters.get(i).asType().equals(interfaceParameterMirror)) { return false; } } return true; } private boolean isTypeVariable(TypeMirror type) { return type.getKind() == TypeKind.TYPEVAR; }</span></span></code> </pre> <br>  Vous voyez le problème?  Non?  Et elle est là.  Le fait est que je n'ai pas pu trouver un moyen d'obtenir les paramètres de type réels pour les interfaces génériques.  Par exemple, j'ai une classe qui implémente l'interface <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Predicate</a> : <br><pre> <code class="java hljs">MyPredicate implements Predicate&amp;ltString&amp;gt { <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(Predicate.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Lors de l'analyse de la méthode dans la classe, le type du paramètre est <code>String</code> , et dans l'interface, c'est <code>T</code> , et toutes les tentatives pour obtenir <code>String</code> au lieu de cela n'ont mené à rien.  En fin de compte, je n'ai rien trouvé de mieux que d'ignorer les paramètres de type.  La vérification sera passée avec tous les paramètres de type réels, même s'ils ne correspondent pas.  Heureusement, le compilateur générera une erreur si la méthode n'a pas d'implémentation par défaut et n'est pas implémentée dans la classe de base.  Mais encore, si quelqu'un sait comment contourner cela, je serai extrêmement reconnaissant pour l'indice. <br><br><h3>  Connectez-vous à Eclipse </h3><br>  Personnellement, j'adore Eclipce et dans ma pratique je ne l'ai utilisé que.  Par conséquent, je vais décrire comment connecter le processeur à cet IDE.  Pour qu'Eclipse puisse voir le processeur, vous devez le placer dans un fichier .JAR distinct, dans lequel l'annotation elle-même sera également.  Dans ce cas, vous devez créer le dossier <b>META-INF / services</b> dans le projet et y créer le fichier <b>javax.annotation.processing.Processor</b> et indiquer le nom complet de la classe de processeur: <code>ds.magic.annotations.compileTime.ImplementProcessor</code> , dans mon cas.  Juste au cas où, je vais faire une capture d'écran, mais quand rien n'a fonctionné pour moi, j'ai presque commencé à pécher sur la structure du projet. <br><br><img src="https://habrastorage.org/webt/bp/oo/ev/bpooev7zwn5msgfm6pyyhupedwi.png" alt="image"><br><br>  Ensuite, collectez .JAR et connectez-le à votre projet, d'abord en tant que bibliothèque régulière, afin que l'annotation soit visible dans le code.  Ensuite, nous connectons le processeur ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici est</a> plus détaillé).  Pour ce faire, ouvrez les <b>propriétés</b> du <b>projet</b> et sélectionnez: <br><br><ol><li>  Compilateur Java -&gt; Traitement des annotations et cochez la case "Activer le traitement des annotations". </li><li>  Compilateur Java -&gt; Traitement des annotations -&gt; Factory Path cochez la case "Activer les paramètres spécifiques au projet".  Cliquez ensuite sur Ajouter des fichiers JAR ... et sélectionnez le fichier JAR créé précédemment. </li><li>  Accepte de reconstruire le projet. </li></ol><br><h3>  Résumé </h3><br>  Tous ensemble et dans le projet Eclipse peuvent être vus sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  Au moment de l'écriture, il n'y a que deux classes, si l'annotation peut être appelée ainsi: Implement.java et ImplementProcessor.java.  Je pense que vous avez déjà deviné leur but. <br><br>  Peut-être que cette annotation peut sembler inutile pour certains.  C'est peut-être le cas.  Mais personnellement, je l'utilise moi-même au lieu de <code>@Override</code> , lorsque les noms de méthode ne correspondent pas bien à l'objectif de la classe.  Et jusqu'à présent, je n'ai aucune envie de me débarrasser d'elle.  En général, j'ai fait une annotation pour moi-même, et le but de l'article était de montrer quel râteau j'attaquais.  J'espère que je l'ai fait.  Merci de votre attention. <br><br>  PS.  Merci aux utilisateurs de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ohotNik_alex</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Comdiv</a> pour leur aide dans la correction des bugs. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414715/">https://habr.com/ru/post/fr414715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414705/index.html">Chefs-d'œuvre de la construction mondiale d'enceintes: la voie innovante de Monitor Audio du tissu au métal et aux matériaux composites</a></li>
<li><a href="../fr414707/index.html">Analyse de la blockchain, ou pourquoi le mélangeur s'est-il cassé?</a></li>
<li><a href="../fr414709/index.html">Lions du désert et introspection</a></li>
<li><a href="../fr414711/index.html">L'application de football espagnole La Liga a rendu ses utilisateurs fraudeurs involontaires</a></li>
<li><a href="../fr414713/index.html">Semaine de rétroaction croisée</a></li>
<li><a href="../fr414717/index.html">Téléviseur 4K 2018: recommandations pour le meilleur choix</a></li>
<li><a href="../fr414719/index.html">Quatre roues c'est bien, deux c'est mieux</a></li>
<li><a href="../fr414723/index.html">Concours de programmation: commerce</a></li>
<li><a href="../fr414725/index.html">Changement de façade: pourquoi battre un flux de protons dans un mur de béton de cinq mètres d'épaisseur</a></li>
<li><a href="../fr414727/index.html">La loi sur la crypto-monnaie sera bientôt lancée en Russie: qu'est-ce que cela changera pour les acteurs du marché</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>