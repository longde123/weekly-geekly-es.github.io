<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëäüèº üéÖüèª üë®‚Äçüéì Annotations √† la compilation en utilisant @Implement comme exemple ü§¥üèæ üöØ üèñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous aimons tous d√©tecter les erreurs lors de la compilation, au lieu des exceptions d'ex√©cution. Le moyen le plus simple de les corriger est que le c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Annotations √† la compilation en utilisant @Implement comme exemple</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414715/"><img src="https://habrastorage.org/webt/zq/9v/1a/zq9v1afhchg4c2ft1koorkjfcss.png"><br><br>  Nous aimons tous d√©tecter les erreurs lors de la compilation, au lieu des exceptions d'ex√©cution.  Le moyen le plus simple de les corriger est que le compilateur lui-m√™me affiche tous les endroits qui doivent √™tre corrig√©s.  Bien que la plupart des probl√®mes ne puissent √™tre d√©tect√©s qu'au d√©marrage du programme, nous essayons toujours de le faire d√®s que possible. <a name="habracut"></a>  En blocs d'initialisation de classes, en constructeurs d'objets, au premier appel d'une m√©thode, etc.  Et parfois, nous avons de la chance, et m√™me au stade de la compilation, nous en savons assez pour v√©rifier le programme pour certaines erreurs. <br><br>  Dans cet article, je veux partager l'exp√©rience de la r√©daction d'un tel test.  Plus pr√©cis√©ment, cr√©er une annotation pouvant g√©n√©rer des erreurs, comme le fait le compilateur.  A en juger par le fait qu'il n'y a pas tant d'informations sur ce sujet dans RuNet, les situations heureuses d√©crites ci-dessus ne le sont pas souvent. <br><br>  Je d√©crirai l'algorithme g√©n√©ral de v√©rification, ainsi que toutes les √©tapes et nuances pour lesquelles j'ai pass√© du temps et des cellules nerveuses. <br><br><h3>  √ânonc√© du probl√®me </h3><br>  Dans cette section, je vais donner un exemple d'utilisation de cette annotation.  Si vous savez d√©j√† quelle v√©rification vous voulez faire, vous pouvez la sauter en toute s√©curit√©.  Je suis s√ªr que cela n'affectera pas l'int√©gralit√© de la pr√©sentation. <br><br>  Maintenant, nous parlerons davantage de l'am√©lioration de la lisibilit√© du code que de la correction des bogues.  Un exemple, on pourrait dire, de la vie, ou plut√¥t de mon projet de loisir. <br><br>  Supposons qu'il existe une classe UnitManager, qui, en fait, est une collection d'unit√©s.  Il a des m√©thodes pour ajouter, supprimer, obtenir une unit√©, etc.  Lors de l'ajout d'une nouvelle unit√©, le gestionnaire lui attribue un identifiant.  La g√©n√©ration d'id est d√©l√©gu√©e √† la classe RotateCounter, qui renvoie un nombre dans la plage donn√©e.  Et il y a un petit probl√®me, RotateCounter ne peut pas savoir si l'ID s√©lectionn√© est libre.  Selon le principe de l'inversion de d√©pendance, vous pouvez cr√©er une interface, dans mon cas, c'est RotateCounter.IClient, qui a une seule m√©thode isValueFree (), qui re√ßoit id et renvoie true si id est libre.  Et UnitManager impl√©mente cette interface, cr√©e une instance de RotateCounter et la transmet √† lui-m√™me en tant que client. <br><br>  J'ai fait juste √ßa.  Mais, apr√®s avoir ouvert la source de UnitManager quelques jours apr√®s avoir √©crit, je suis tomb√© dans une stupeur facile apr√®s avoir vu la m√©thode isValueFree (), qui ne correspondait pas vraiment √† la logique de UnitManager.  Il serait beaucoup plus simple s'il √©tait possible de sp√©cifier quelle interface impl√©mente cette m√©thode.  Par exemple, en C #, d'o√π je suis venu √† Java, une impl√©mentation d'interface explicite permet de faire face √† ce probl√®me.  Dans ce cas, tout d'abord, vous ne pouvez appeler la m√©thode qu'avec un transtypage explicite vers l'interface.  Deuxi√®mement, et plus important dans ce cas, le nom de l'interface (et sans le modificateur d'acc√®s) est explicitement indiqu√© dans la signature de la m√©thode, par exemple: <br><br><pre><code class="cs hljs">IClient.isValueFree(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { }</code> </pre> <br>  Une solution consiste √† ajouter une annotation avec le nom de l'interface qui impl√©mente cette m√©thode.  Quelque chose comme <code>@Override</code> , uniquement avec une interface.  Je suis d'accord, vous pouvez utiliser une classe interne anonyme.  Dans ce cas, tout comme en C #, la m√©thode ne peut pas simplement √™tre appel√©e sur l'objet, et vous pouvez imm√©diatement voir quelle interface elle impl√©mente.  Mais cela augmentera la quantit√© de code, par cons√©quent, d√©gradera la lisibilit√©.  Oui, et vous devez en quelque sorte l'obtenir de la classe - cr√©ez un getter ou un champ public (apr√®s tout, il n'y a pas de surcharge d'instructions cast en Java non plus).  Pas une mauvaise option, mais je n'aime pas √ßa. <br><br>  Au d√©but, je pensais qu'en Java, comme en C #, les annotations sont des classes compl√®tes et peuvent en √™tre h√©rit√©es.  Dans ce cas, il vous suffit de cr√©er une annotation qui h√©rite de <code>@Override</code> .  Mais ce n'√©tait pas le cas, et j'ai d√ª plonger dans le monde √©tonnant et effrayant des ch√®ques au stade de la compilation. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de code UnitManager</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Unit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Unit[] units; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> RotateCounter idGenerator; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnitManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ units = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Unit[size]; idGenerator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RotateCounter(<span class="hljs-number"><span class="hljs-number">0</span></span>, size, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Unit unit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = idGenerator.findFree(); units[id] = unit; } <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(RotateCounter.IClient.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> units[value] == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeUnit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ units[id] = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IClient client; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> next; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minValue; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxValue; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RotateCounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, IClient client)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.client = client; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.minValue = minValue; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maxValue = maxValue; next = minValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incrementAndGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> current = next; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next &gt;= maxValue) { next = minValue; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } next++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> maxValue - minValue + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> range = range(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> trysCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (++trysCounter &gt; range) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"No free values."</span></span>); } id = incrementAndGet(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!client.isValueFree(id)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClient</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValueFree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span></span>; } }</code> </pre></div></div><br><h3>  Un peu de th√©orie </h3><br>  Je ferai une r√©servation tout de suite, toutes les m√©thodes ci-dessus sont des instances, donc, par souci de concision, je vais indiquer les noms de m√©thode avec le nom de type et sans param√®tres: <code>&lt;_&gt;.&lt;_&gt;()</code> . <br><br>  Le traitement des √©l√©ments au stade de la compilation implique des classes de processeur sp√©ciales.  Ce sont des classes qui h√©ritent de <code>javax.annotation.processing.AbstractProcessor</code> (vous pouvez simplement impl√©menter l'interface <code>javax.annotation.processing.Processor</code> ).  Vous pouvez en savoir plus sur les processeurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  La m√©thode la plus importante est le processus.  Dans lequel nous pouvons obtenir une liste de tous les √©l√©ments annot√©s et effectuer les v√©rifications n√©cessaires. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br>  Au d√©but, sinc√®rement na√Øf, je pensais que travailler avec des types au stade de la compilation se faisait en termes de r√©flexion, mais ... non.  Tout est bas√© sur des √©l√©ments l√†-bas. <br><br>  <b>Element</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javax.lang.model.element.Element</a> ) - l'interface principale pour travailler avec la plupart des √©l√©ments structurels du langage.  Un √©l√©ment a des descendants qui d√©terminent plus pr√©cis√©ment les propri√©t√©s d'un √©l√©ment particulier (pour plus de d√©tails, voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ds.magic.example.implement; <span class="hljs-comment"><span class="hljs-comment">// PackageElement public class Unit // TypeElement { private int id; // VariableElement public void setId(int id) { // ExecutableElement this.id = id; } }</span></span></code> </pre> <br>  <b>TypeMirror</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javax.lang.model.type.TypeMirror</a> ) est quelque chose comme Class &lt;?&gt; Renvoy√© par la m√©thode getClass ().  Par exemple, ils peuvent √™tre compar√©s pour savoir si les types d'√©l√©ments correspondent.  Vous pouvez l'obtenir en utilisant la m√©thode <code>Element.asType()</code> .  Ce type renvoie √©galement certaines op√©rations de type, telles que <code>TypeElement.getSuperclass()</code> ou <code>TypeElement.getInterfaces()</code> . <br><br>  <b>Types</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javax.lang.model.util.Types</a> ) - Je vous conseille de regarder de plus pr√®s cette classe.  Vous pouvez y trouver beaucoup de choses int√©ressantes.  En substance, il s'agit d'un ensemble d'utilitaires pour travailler avec des types.  Par exemple, il vous permet de r√©cup√©rer un TypeElement √† partir d'un TypeMirror. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeElement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asTypeElement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeMirror typeMirror)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (TypeElement)processingEnv.getTypeUtils().asElement(typeMirror); }</code> </pre> <br>  <b>TypeKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javax.lang.model.type.TypeKind</a> ) - une √©num√©ration qui vous permet de clarifier les informations de type, de v√©rifier si le type est un tableau (ARRAY), un type personnalis√© (DECLARED), une variable de type (TYPEVAR), etc.  Vous pouvez l'obtenir via <code>TypeMirror.getKind()</code> <br><br>  <b>ElementKind</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javax.lang.model.element.ElementKind</a> ) - √©num√©ration, vous permet de clarifier les informations sur l'√©l√©ment, de v√©rifier si l'√©l√©ment est un paquet (PACKAGE), une classe (CLASS), une m√©thode (METHOD), une interface (INTERFACE), etc. <br><br>  <b>Nom</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">javax.lang.model.element.Name</a> ) - l'interface pour travailler avec le nom de l'√©l√©ment, peut √™tre obtenue via <code>Element.getSimpleName()</code> . <br><br>  Fondamentalement, ces types me suffisaient pour √©crire un algorithme de v√©rification. <br><br>  Je veux noter une autre caract√©ristique int√©ressante.  Les impl√©mentations des interfaces Element dans Eclipse se trouvent dans les packages org.eclipse ..., par exemple, les √©l√©ments qui repr√©sentent les m√©thodes sont de type <code>org.eclipse.jdt.internal.compiler.apt.model.ExecutableElementImpl</code> .  Cela m'a donn√© l'id√©e que ces interfaces sont impl√©ment√©es par chaque IDE ind√©pendamment. <br><br><h3>  Algorithme de validation </h3><br>  Vous devez d'abord cr√©er l'annotation elle-m√™me.  Beaucoup a d√©j√† √©t√© √©crit √† ce sujet (par exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ), donc je ne m'attarderai pas l√†-dessus en d√©tail.  Je peux seulement dire que pour notre exemple, nous devons ajouter deux annotations <code>@Target</code> et <code>@Retention</code> .  La premi√®re indique que notre annotation ne peut √™tre appliqu√©e qu'√† la m√©thode, et la seconde que l'annotation n'existera que dans le code source. <br><br>  Les annotations doivent √™tre sp√©cifi√©es quelle interface impl√©mente la m√©thode annot√©e (la m√©thode √† laquelle l'annotation est appliqu√©e).  Cela peut √™tre fait de deux mani√®res: soit sp√©cifiez le nom complet de l'interface avec une cha√Æne, par exemple <code>@Implement("com.ds.IInterface")</code> , soit passez directement la classe d'interface: <code>@Implement(IInterface.class)</code> .  La deuxi√®me voie est clairement meilleure.  Dans ce cas, le compilateur surveillera le nom d'interface correct.  Par ailleurs, si vous appelez ce membre <b>value (),</b> lors de l'ajout d'annotations √† la m√©thode, vous n'aurez pas besoin de sp√©cifier explicitement le nom de ce param√®tre. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.METHOD}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.SOURCE) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Implement { Class&lt;?&gt; value(); }</code> </pre> <br>  Ensuite, le plaisir commence - la cr√©ation du processeur.  Dans la m√©thode du processus, nous obtenons une liste de tous les √©l√©ments annot√©s.  Ensuite, nous obtenons l'annotation elle-m√™me et sa signification - l'interface sp√©cifi√©e.  En g√©n√©ral, le cadre de classe de processeur ressemble √† ceci: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SupportedAnnotationTypes</span></span>({<span class="hljs-string"><span class="hljs-string">"ds.magic.annotations.compileTime.Implement"</span></span>}) <span class="hljs-meta"><span class="hljs-meta">@SupportedSourceVersion</span></span>(SourceVersion.RELEASE_8) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplementProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Types typeUtils; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessingEnvironment procEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.init(procEnv); typeUtils = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.processingEnv.getTypeUtils(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annos, RoundEnvironment env)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;? extends Element&gt; annotatedElements = env.getElementsAnnotatedWith(Implement.class); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(Element annotated : annotatedElements) { Implement annotation = annotatedElement.getAnnotation(Implement.class); TypeMirror interfaceMirror = getValueMirror(annotation); TypeElement interfaceType = asTypeElement(interfaceMirror); <span class="hljs-comment"><span class="hljs-comment">//... } return false; } private TypeElement asTypeElement(TypeMirror typeMirror) { return (TypeElement)typeUtils.asElement(typeMirror); } }</span></span></code> </pre> <br>  Je veux noter que vous ne pouvez pas simplement obtenir et obtenir des annotations de valeur comme √ßa.  Lorsque vous essayez d'appeler <code>annotation.value()</code> , une <b>exception MirroredTypeException</b> est lev√©e, mais vous pouvez en obtenir un TypeMirror.  Cette m√©thode de triche, ainsi que la bonne r√©ception de la valeur, j'ai trouv√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> TypeMirror </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValueMirror</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Implement annotation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { annotation.value(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(MirroredTypeException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.getTypeMirror(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  La v√©rification elle-m√™me se compose de trois parties, si au moins l'une d'entre elles √©choue, vous devez afficher un message d'erreur et passer √† l'annotation suivante.  Par ailleurs, vous pouvez afficher un message d'erreur √† l'aide de la m√©thode suivante: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String message, Element annotatedElement)</span></span></span><span class="hljs-function"> </span></span>{ Messager messager = processingEnv.getMessager(); messager.printMessage(Kind.ERROR, message, annotatedElement); }</code> </pre> <br>  La premi√®re √©tape consiste √† v√©rifier si les annotations de valeur sont une interface.  Ici, tout est simple: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceType.getKind() != ElementKind.INTERFACE) { String name = Implement.class.getSimpleName(); printError(<span class="hljs-string"><span class="hljs-string">"Value of @"</span></span> + name + <span class="hljs-string"><span class="hljs-string">" must be an interface"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Ensuite, vous devez v√©rifier si la classe dans laquelle se trouve la m√©thode annot√©e impl√©mente r√©ellement l'interface sp√©cifi√©e.  Au d√©but, j'ai impl√©ment√© ce test avec mes mains.  Mais ensuite, en utilisant de bons conseils, j'ai regard√© <b>Types</b> et y <code>Types.isSubtype()</code> trouv√© la m√©thode <code>Types.isSubtype()</code> , qui v√©rifiera l'arborescence d'h√©ritage enti√®re et retournera true si l'interface sp√©cifi√©e est l√†.  Surtout, il peut fonctionner avec des types g√©n√©riques, contrairement √† la premi√®re option. <br><br><pre> <code class="java hljs">TypeElement enclosingType = (TypeElement)annotatedElement.getEnclosingElement(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!typeUtils.isSubtype(enclosingType.asType(), interfaceMirror)) { Name className = enclosingType.getSimpleName(); Name interfaceName = interfaceType.getSimpleName(); printError(className + <span class="hljs-string"><span class="hljs-string">" must implemet "</span></span> + interfaceName, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Enfin, vous devez vous assurer que l'interface poss√®de une m√©thode avec la m√™me signature que celle annot√©e.  Je voudrais utiliser la m√©thode <code>Types.isSubsignature()</code> , mais, malheureusement, cela ne fonctionne pas correctement si la m√©thode a des param√®tres de type.  Alors nous retroussons nos manches et √©crivons tous les ch√®ques avec nos mains.  Et nous en avons encore trois.  Eh bien, plus pr√©cis√©ment, la signature de la m√©thode se compose de trois parties: le nom de la m√©thode, le type de la valeur de retour et la liste des param√®tres.  Vous devez parcourir toutes les m√©thodes de l'interface et trouver celle qui a r√©ussi les trois v√©rifications.  Il serait bon de ne pas oublier que la m√©thode peut √™tre h√©rit√©e d'une autre interface et effectuer r√©cursivement les m√™mes v√©rifications pour les interfaces sous-jacentes. <br><br>  L'appel doit √™tre plac√© √† la fin de la boucle dans la m√©thode de processus, comme ceci: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!haveMethod(interfaceType, (ExecutableElement)annotatedElement)) { Name name = interfaceType.getSimpleName(); printError(name + <span class="hljs-string"><span class="hljs-string">" don't have \""</span></span> + annotated + <span class="hljs-string"><span class="hljs-string">"\" method"</span></span>, annotated); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br>  Et la m√©thode haveMethod () elle-m√™me ressemble √† ceci: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">haveMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TypeElement interfaceType, ExecutableElement method)</span></span></span><span class="hljs-function"> </span></span>{ Name methodName = method.getSimpleName(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Element interfaceElement : interfaceType.getEnclosedElements()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (interfaceElement <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ExecutableElement) { ExecutableElement interfaceMethod = (ExecutableElement)interfaceElement; <span class="hljs-comment"><span class="hljs-comment">// Is names match? if (!interfaceMethod.getSimpleName().equals(methodName)) { continue; } // Is return types match (ignore type variable)? TypeMirror returnType = method.getReturnType(); TypeMirror interfaceReturnType = method.getReturnType(); if (!isTypeVariable(interfaceReturnType) &amp;&amp; !returnType.equals(interfaceReturnType)) { continue; } // Is parameters match? if (!isParametersEquals(method.getParameters(), interfaceMethod.getParameters())) { continue; } return true; } } // Recursive search for (TypeMirror baseMirror : interfaceType.getInterfaces()) { TypeElement base = asTypeElement(baseMirror); if (haveMethod(base, method)) { return true; } } return false; } private boolean isParametersEquals(List&lt;? extends VariableElement&gt; methodParameters, List&lt;? extends VariableElement&gt; interfaceParameters) { if (methodParameters.size() != interfaceParameters.size()) { return false; } for (int i = 0; i &lt; methodParameters.size(); i++) { TypeMirror interfaceParameterMirror = interfaceParameters.get(i).asType(); if (isTypeVariable(interfaceParameterMirror)) { continue; } if (!methodParameters.get(i).asType().equals(interfaceParameterMirror)) { return false; } } return true; } private boolean isTypeVariable(TypeMirror type) { return type.getKind() == TypeKind.TYPEVAR; }</span></span></code> </pre> <br>  Vous voyez le probl√®me?  Non?  Et elle est l√†.  Le fait est que je n'ai pas pu trouver un moyen d'obtenir les param√®tres de type r√©els pour les interfaces g√©n√©riques.  Par exemple, j'ai une classe qui impl√©mente l'interface <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Predicate</a> : <br><pre> <code class="java hljs">MyPredicate implements Predicate&amp;ltString&amp;gt { <span class="hljs-meta"><span class="hljs-meta">@Implement</span></span>(Predicate.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre> <br>  Lors de l'analyse de la m√©thode dans la classe, le type du param√®tre est <code>String</code> , et dans l'interface, c'est <code>T</code> , et toutes les tentatives pour obtenir <code>String</code> au lieu de cela n'ont men√© √† rien.  En fin de compte, je n'ai rien trouv√© de mieux que d'ignorer les param√®tres de type.  La v√©rification sera pass√©e avec tous les param√®tres de type r√©els, m√™me s'ils ne correspondent pas.  Heureusement, le compilateur g√©n√©rera une erreur si la m√©thode n'a pas d'impl√©mentation par d√©faut et n'est pas impl√©ment√©e dans la classe de base.  Mais encore, si quelqu'un sait comment contourner cela, je serai extr√™mement reconnaissant pour l'indice. <br><br><h3>  Connectez-vous √† Eclipse </h3><br>  Personnellement, j'adore Eclipce et dans ma pratique je ne l'ai utilis√© que.  Par cons√©quent, je vais d√©crire comment connecter le processeur √† cet IDE.  Pour qu'Eclipse puisse voir le processeur, vous devez le placer dans un fichier .JAR distinct, dans lequel l'annotation elle-m√™me sera √©galement.  Dans ce cas, vous devez cr√©er le dossier <b>META-INF / services</b> dans le projet et y cr√©er le fichier <b>javax.annotation.processing.Processor</b> et indiquer le nom complet de la classe de processeur: <code>ds.magic.annotations.compileTime.ImplementProcessor</code> , dans mon cas.  Juste au cas o√π, je vais faire une capture d'√©cran, mais quand rien n'a fonctionn√© pour moi, j'ai presque commenc√© √† p√©cher sur la structure du projet. <br><br><img src="https://habrastorage.org/webt/bp/oo/ev/bpooev7zwn5msgfm6pyyhupedwi.png" alt="image"><br><br>  Ensuite, collectez .JAR et connectez-le √† votre projet, d'abord en tant que biblioth√®que r√©guli√®re, afin que l'annotation soit visible dans le code.  Ensuite, nous connectons le processeur ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici est</a> plus d√©taill√©).  Pour ce faire, ouvrez les <b>propri√©t√©s</b> du <b>projet</b> et s√©lectionnez: <br><br><ol><li>  Compilateur Java -&gt; Traitement des annotations et cochez la case "Activer le traitement des annotations". </li><li>  Compilateur Java -&gt; Traitement des annotations -&gt; Factory Path cochez la case "Activer les param√®tres sp√©cifiques au projet".  Cliquez ensuite sur Ajouter des fichiers JAR ... et s√©lectionnez le fichier JAR cr√©√© pr√©c√©demment. </li><li>  Accepte de reconstruire le projet. </li></ol><br><h3>  R√©sum√© </h3><br>  Tous ensemble et dans le projet Eclipse peuvent √™tre vus sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> .  Au moment de l'√©criture, il n'y a que deux classes, si l'annotation peut √™tre appel√©e ainsi: Implement.java et ImplementProcessor.java.  Je pense que vous avez d√©j√† devin√© leur but. <br><br>  Peut-√™tre que cette annotation peut sembler inutile pour certains.  C'est peut-√™tre le cas.  Mais personnellement, je l'utilise moi-m√™me au lieu de <code>@Override</code> , lorsque les noms de m√©thode ne correspondent pas bien √† l'objectif de la classe.  Et jusqu'√† pr√©sent, je n'ai aucune envie de me d√©barrasser d'elle.  En g√©n√©ral, j'ai fait une annotation pour moi-m√™me, et le but de l'article √©tait de montrer quel r√¢teau j'attaquais.  J'esp√®re que je l'ai fait.  Merci de votre attention. <br><br>  PS.  Merci aux utilisateurs de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ohotNik_alex</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Comdiv</a> pour leur aide dans la correction des bugs. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414715/">https://habr.com/ru/post/fr414715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414705/index.html">Chefs-d'≈ìuvre de la construction mondiale d'enceintes: la voie innovante de Monitor Audio du tissu au m√©tal et aux mat√©riaux composites</a></li>
<li><a href="../fr414707/index.html">Analyse de la blockchain, ou pourquoi le m√©langeur s'est-il cass√©?</a></li>
<li><a href="../fr414709/index.html">Lions du d√©sert et introspection</a></li>
<li><a href="../fr414711/index.html">L'application de football espagnole La Liga a rendu ses utilisateurs fraudeurs involontaires</a></li>
<li><a href="../fr414713/index.html">Semaine de r√©troaction crois√©e</a></li>
<li><a href="../fr414717/index.html">T√©l√©viseur 4K 2018: recommandations pour le meilleur choix</a></li>
<li><a href="../fr414719/index.html">Quatre roues c'est bien, deux c'est mieux</a></li>
<li><a href="../fr414723/index.html">Concours de programmation: commerce</a></li>
<li><a href="../fr414725/index.html">Changement de fa√ßade: pourquoi battre un flux de protons dans un mur de b√©ton de cinq m√®tres d'√©paisseur</a></li>
<li><a href="../fr414727/index.html">La loi sur la crypto-monnaie sera bient√¥t lanc√©e en Russie: qu'est-ce que cela changera pour les acteurs du march√©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>