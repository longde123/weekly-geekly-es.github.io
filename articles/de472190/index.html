<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎅🏻 🖐🏿 👩🏿‍🤝‍👨🏾 Führen Sie PHP-Skripte über php-fpm ohne Webserver aus. Oder Ihr FastCGI-Client (unter der Haube) 👨🏽‍🚒 👎🏾 ✔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich begrüße alle Leser von "Habr". 
 Haftungsausschluss 


 Der Artikel erwies sich als ziemlich lang und für diejenigen, die den Hintergrund nicht le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Führen Sie PHP-Skripte über php-fpm ohne Webserver aus. Oder Ihr FastCGI-Client (unter der Haube)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472190/"><p>  Ich begrüße alle Leser von "Habr". </p><br><h4 id="diskleymer">  Haftungsausschluss </h4><br><p>  Der Artikel erwies sich als ziemlich lang und für diejenigen, die den Hintergrund nicht lesen wollen, aber direkt auf den Punkt kommen möchten, bitte ich Sie direkt zum Kapitel "Lösung". </p><br><h3 id="vstuplenie">  Eintrag </h3><br><p>  In diesem Artikel möchte ich über die Lösung eines eher ungewöhnlichen Problems sprechen, mit dem ich während des Arbeitsprozesses konfrontiert war.  Wir mussten nämlich eine Reihe von PHP-Skripten in einer Schleife ausführen.  Ich werde die Gründe und Kontroversen einer solchen architektonischen Lösung in diesem Artikel nicht diskutieren, weil  Tatsächlich ging es überhaupt nicht darum, es war nur eine Aufgabe, es musste gelöst werden und die Lösung schien mir interessant genug, um sie mit Ihnen zu teilen, zumal ich im Internet überhaupt kein Mana gefunden habe (natürlich mit Ausnahme der offiziellen Spezifikationen).  Speck ist natürlich gut, und natürlich ist alles in ihnen, aber ich denke, Sie werden mir zustimmen, dass es immer noch ein Vergnügen ist, sie zu verstehen, wenn Sie mit dem Thema nicht besonders vertraut und zeitlich begrenzt sind. </p><a name="habracut"></a><br><h3 id="dlya-kogo-eta-statya">  Für wen ist dieser Artikel? </h3><br><p>  Jeder, der mit dem Web und dem <strong>FastCgi-</strong> Protokoll arbeitet <strong>,</strong> weiß <strong>nur</strong> , dass dies das Protokoll ist, nach dem der Webserver PHP-Skripte ausführt, möchte es aber genauer studieren und unter die Haube schauen. </p><br><h3 id="obosnovanie-zachem-eta-statya">  Begründung (warum dieser Artikel) </h3><br><p>  Wie ich oben schrieb, als wir vor der Notwendigkeit standen, viele PHP-Skripte ohne die Teilnahme eines Webservers auszuführen (grob gesagt von einem anderen PHP-Skript), fiel mir als Erstes Folgendes ein ... </p><br><pre><code class="php hljs">shell_exec(<span class="hljs-string"><span class="hljs-string">'php \path\to\script.php'</span></span>)</code> </pre> <br><p>  Zu Beginn jedes Skripts wird jedoch eine Umgebung erstellt und ein separater Prozess gestartet. Im Allgemeinen schien dies für Ressourcen irgendwie kostspielig zu sein.  Diese Implementierung wurde abgelehnt.  Das zweite, was mir in den Sinn kam, ist natürlich <strong>php-fpm</strong> , es ist so cool, es startet die Umgebung nur einmal, überwacht den Speicher, protokolliert alles dort korrekt, startet und stoppt Skripte, im Allgemeinen ist alles cool, und natürlich hat uns das gefallen mehr. </p><br><p>  Aber es ist ein Pech, theoretisch wussten wir, wie es im Allgemeinen funktioniert (da es sich als sehr allgemein herausstellte), aber es stellte sich als ziemlich schwierig heraus, dieses Protokoll in der Praxis ohne die Teilnahme eines Webservers zu implementieren.  Das Lesen der Spezifikationen und einige Stunden erfolgloser Versuche zeigten, dass die Implementierung einige Zeit in Anspruch nehmen würde, was wir zu diesem Zeitpunkt noch nicht hatten.  Es gibt kein Mana für die Implementierung dieses Vorhabens, in dem diese Interaktion einfach und klar beschrieben werden könnte. Wir konnten auch keine Spezifikationen übernehmen. Aus den vorgefertigten Lösungen haben wir ein Python-Skript und eine Pykhov-Bibliothek auf dem Github gefunden, die am Ende nicht in mein Projekt gezogen werden wollten (vielleicht) Es ist nicht richtig, aber nicht wirklich. Wir lieben alle Arten von Bibliotheken von Drittanbietern und sogar nicht sehr beliebte und daher nicht getestete Bibliotheken.  Im Allgemeinen haben wir als Ergebnis dieser Idee all dies durch das gute alte Kaninchen abgelehnt und umgesetzt. </p><br><p>  Obwohl das Problem endlich gelöst war, habe ich mich entschlossen, FastCgi im Detail zu verstehen, und außerdem habe ich beschlossen, einen Artikel darüber zu schreiben, in dem einfach und ausführlich beschrieben wird, wie man <strong>php-fpm</strong> dazu <strong>bringt</strong> , ein PHP-Skript ohne Webserver oder besser gesagt als auszuführen Der Webserver wird ein anderes Skript haben, dann werde ich es den Fcgi-Client nennen.  Generell hoffe ich, dass dieser Artikel denjenigen hilft, die vor der gleichen Aufgabe stehen wie wir, und nach dem Lesen schnell alles schreiben kann, was er braucht. </p><br><h3 id="tvorcheskiy-poisk-lozhnyy-put">  Kreative Suche (falscher Pfad) </h3><br><p>  Damit das Problem angezeigt wird, müssen wir mit der Lösung fortfahren.  Natürlich habe ich, wie jeder "normale" Programmierer, die Spezifikation nicht gelesen und übersetzt, um ein Problem zu lösen, über das nirgendwo geschrieben ist, was zu tun ist und was in die Konsole einzugeben ist, sondern sofort meine eigene "brillante" Lösung gefunden.  Sein Wesen ist wie folgt: Ich weiß, dass <strong>Nginx</strong> (wir verwenden Nginx und um keine <strong>dummen Dinge</strong> weiter zu schreiben - ein Webserver, ich werde Nginx schreiben, da es sympathischer ist) etwas an <strong>php-fpm</strong> überträgt, es verarbeitet auch <strong>php-fpm</strong> an Auf dieser Grundlage wird ein Skript ausgeführt. Nun, alles scheint einfach zu sein. Ich nehme es und verspreche es, das <strong>Nginx</strong> überträgt, und ich werde das Gleiche bestehen. </p><br><p>  Hier hilft ein großartiger <strong>Netcat</strong> (UNIX-Dienstprogramm für die Arbeit mit Netzwerkverkehr, das meiner Meinung nach fast alles kann).  Also setzen wir <strong>netcat so</strong> , dass es den lokalen Port <strong>überwacht</strong> und <strong>nginx so</strong> konfiguriert, dass es mit PHP-Dateien über den Socket arbeitet (natürlich den Socket an demselben Port, den <strong>Netcat</strong> abhört). </p><br><p>  9000 Port hören </p><br><pre> <code class="plaintext hljs">nc -l 9000</code> </pre> <br><p>  Sie können überprüfen, ob alles in Ordnung ist, Sie können die Adresse 127.0.0.1:9000 über einen Browser kontaktieren und das folgende Bild sollte sein </p><br><img src="https://habrastorage.org/webt/ux/9s/_f/ux9s_fkir12e0yn3arj010nnezw.png"><br><p>  Konfigurieren Sie <strong>nginx</strong> so, dass es PHP-Skripte über einen Socket an Port 9000 verarbeitet (in den Einstellungen '/ etc / nginx / sites-available / default' können sie natürlich abweichen). </p><br><pre> <code class="plaintext hljs">location ~ \.php$ { include snippets/fastcgi-php.conf; fastcgi_pass 127.0.0.1:9000; }</code> </pre><br><p>  Nach diesen Manipulationen werden wir überprüfen, was passiert ist, indem wir das PHP-Skript über den Browser kontaktieren </p><br><img src="https://habrastorage.org/webt/u_/hf/j1/u_hfj1xa4tnqyb35rdmfu5nf-na.png"><br><p>  Es ist ersichtlich, dass <strong>nginx</strong> Umgebungsvariablen sowie nicht druckbare Zeichen gesendet hat, <strong>dh</strong> die Daten wurden in binärer Codierung übertragen, was bedeutet, dass sie nicht so einfach kopiert und an den <strong>PHP-Fpm-Socket</strong> gesendet <strong>werden können</strong> .  Wenn Sie sie beispielsweise in einer Datei speichern, werden sie in hexadezimaler Codierung gespeichert. Dies sieht anscheinend so aus </p><br><img src="https://habrastorage.org/webt/le/7e/9y/le7e9ycpkn8n3mezj7ksa9xhkki.png"><br><p>  Aber das gibt uns auch nicht viel, wahrscheinlich rein theoretisch können sie in eine binäre Codierung konvertiert werden, irgendwie (ich kann mir nicht einmal vorstellen, wie), um sie an die fpm-Buchse zu senden, und es besteht sogar die Möglichkeit, dass dieses ganze Fahrrad irgendwie funktioniert und sogar eine Art startet ein Skript, aber irgendwie ist alles hässlich und umständlich. </p><br><p>  Es wurde klar, dass dieser Weg völlig falsch ist. Sie können selbst sehen, wie miserabel das alles aussieht, und noch mehr, all diese Aktionen werden es uns nicht ermöglichen, die Verbindung zu kontrollieren, und sie werden uns auch nicht näher bringen, die Interaktion zwischen <strong>php-fpm</strong> und <strong>nginx</strong> zu verstehen. </p><br><p>  Alles ist weg, die Spezifikation kann nicht vermieden werden! </p><br><h3 id="reshenie-tut-sobstvenno-nachinaetsya-vsya-sol-dannoy-stati">  Lösung (hier beginnt tatsächlich das ganze Salz dieses Artikels) </h3><br><h4 id="teoreticheskaya-podgotovka">  Theoretische Ausbildung </h4><br><p>  Betrachten wir nun, wie es <strong>trotzdem</strong> eine Verbindung und einen Datenaustausch zwischen <strong>nginx</strong> und <strong>php-fpm gibt</strong> .  Eine kleine Theorie, alle Kommunikation findet statt, wie bereits durch Sockets klar ist, wir werden weiter speziell eine Verbindung über einen TCP-Socket betrachten. </p><br><p>  Die Informationseinheit im <strong>FastCgi-</strong> Protokoll ist ein <strong>CGI-Datensatz</strong> .  Der Server sendet solche Datensätze an die Anwendung und empfängt als Antwort genau dieselben Datensätze. </p><br><h5 id="nemnogo-teorii-struktury">  Ein bisschen Theorie (Struktur) </h5><br><p>  Betrachten Sie als nächstes die Struktur des Datensatzes.  Um zu verstehen, woraus ein Datensatz besteht, müssen Sie verstehen, wie C-Strukturen aussehen, und ihre Bezeichnungen verstehen.  Für diejenigen, die es nicht weiter wissen, wird dies kurz beschrieben (aber genug zum Verständnis).  Ich werde versuchen, es so einfach wie möglich zu beschreiben. Es ist sinnlos, hier auf Details einzugehen, und ich befürchte, dass ich in den Details verwirrt werde. Hauptsache, ich habe ein gemeinsames Verständnis. </p><br><p>  Strukturen sind einfach eine Sammlung von Bytes, und eine Notation für sie ermöglicht die Interpretation.  Das heißt, Sie haben nur eine Folge von Nullen und Einsen, und einige Daten werden in dieser Folge verschlüsselt. Solange Sie jedoch keine Anmerkung zu dieser Folge haben, sind diese Daten für Sie wertlos, da  Sie können sie nicht interpretieren. </p><br><pre> <code class="plaintext hljs">//     1101111000000010010110000010011100010000</code> </pre> <br><p>  Was hier sichtbar ist, haben wir einige Bits, welche Art von Bits wir keine Ahnung haben.  Versuchen wir zum Beispiel, sie in Bytes zu unterteilen und im Dezimalsystem darzustellen </p><br><pre> <code class="plaintext hljs">//   5  11011110 00000010 01011000 00100111 00010000 //    222 2 88 39 16</code> </pre> <br><p>  Nun, wir haben sie interpretiert und einige Ergebnisse erzielt. Nehmen wir an, diese Daten sind dafür verantwortlich, wie viel eine bestimmte Wohnung für Strom schuldet.  Es stellt sich heraus, dass in Haus 222 Wohnung Nummer 2 88 Rubel bezahlen muss.  Und was noch für zwei Ziffern, was tun mit ihnen, nur um fallen zu lassen?  Natürlich nicht!  Tatsache ist, dass wir keine Notation (Format) hatten, die uns sagen würde, wie wir die Daten interpretieren und auf unsere eigene Weise interpretieren sollen. In dieser Hinsicht haben wir nicht nur nutzlose, sondern auch schädliche Ergebnisse erhalten.  Infolgedessen zahlte Wohnung 2 absolut nicht das, was es haben sollte.  (Die Beispiele sind sicherlich weit hergeholt und dienen nur dazu, die Situation klarer zu erklären) </p><br><p>  Nun wollen wir sehen, wie wir diese Daten mit einer Notation (Format) richtig interpretieren sollen.  Weiter werde ich einen Spaten einen Spaten nennen, nämlich Notation = Format ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier Formate</a> ). </p><br><pre> <code class="plaintext hljs">//  "Cnn" //  //C -   (char) (8 ) //n -  short (16 ) //      11011110 0000001001011000 0010011100010000 //    222 600 10000</code> </pre> <br><p>  Jetzt läuft alles im Haus Nr. 222 zusammen, Wohnung 600 für Strom sollte 1000 Rubel betragen. Ich denke, jetzt ist die Bedeutung des Formats klar, und jetzt ist klar, wie ungefähr eine ähnliche Struktur aussieht.  (Bitte beachten Sie, hier geht es nicht darum, diese Strukturen im Detail zu erklären, sondern ein allgemeines Verständnis dafür zu vermitteln, was es ist und wie es funktioniert.) </p><br><p>  Das Symbol dieser Struktur wird sein </p><br><pre> <code class="plaintext hljs">struct { unsigned char houseNumber; unsigned char flatNumperA1; unsigned char flatNumperA2; unsigned char summB1; unsigned char summB2; }; // ,           // houseNumber -  // flatNumperA1 &amp;&amp; flatNumperA2 -  // summB1 &amp;&amp; summB2 -  </code> </pre> <br><h5 id="esche-nemnogo-teorii-fastcgi-zapisi">  Noch etwas Theorie (FastCgi-Einträge) </h5><br><p>  Wie oben erwähnt, besteht die Informationseinheit im FastCgi-Protokoll aus Aufzeichnungen.  Der Server sendet die Datensätze an die Anwendung und empfängt als Antwort dieselben Datensätze.  Ein Datensatz besteht aus einem Header und einem Body mit Daten. </p><br><p>  Header-Struktur: </p><br><ol><li>  Die Protokollversion (immer 1) wird mit 1 Byte ('C') bezeichnet. </li><li>  Datensatztyp.  Um die Verbindung zu öffnen, zu schließen usw. Ich werde nicht alles berücksichtigen, dann werde ich nur berücksichtigen, was für eine bestimmte Aufgabe benötigt wird. Wenn andere benötigt werden, begrüßen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Spezifikation</a> hier.  Es wird durch 1 Byte ('C') angezeigt. </li><li>  Die Anforderungs-ID, eine beliebige Zahl, wird mit 2 Bytes ('n') bezeichnet. </li><li>  die Länge des Hauptteils des Datensatzes (Daten), angegeben durch 2 Bytes ('n') </li><li>  Die Länge der Ausrichtungsdaten und der reservierten Daten beträgt jeweils ein Byte (es ist nicht erforderlich, besondere Aufmerksamkeit zu schenken, um nicht von der Hauptdaten abgelenkt zu werden. In unserem Fall gibt es immer 0). </li></ol><br><p>  Als nächstes folgt der Hauptteil der Aufzeichnung: </p><br><ol><li>  Die Daten selbst (hier werden genau die Variablen übertragen) können sehr groß sein (bis zu 65535 Byte). </li></ol><br><p>  Hier ist ein Beispiel für den einfachsten FastCgi-Binärdatensatz mit Format </p><br><pre> <code class="plaintext hljs">struct { // unsigned char version; unsigned char type; unsigned char idA1; unsigned char idA2; unsigned char bodyLengthB1; unsigned char bodyLengthB2; unsigned char paddingLength; unsigned char reserved; //  unsigned char contentData; // 65535  unsigned char paddingData; };</code> </pre> <br><h4 id="praktika">  Übe </h4><br><h5 id="skript-klient-i-peredayuschiy-soket">  Skript-Client und Sende-Socket </h5><br><p>  Für die Datenübertragung verwenden wir die Standard-PHP-Socket-Erweiterung.  Als erstes muss <strong>php-fpm so</strong> konfiguriert werden, dass der Port auf dem lokalen Host überwacht wird, z. B. 9000. Dies geschieht in den meisten Fällen in der Datei '/etc/php/7.3/fpm/pool.d/www.conf', dem Pfad natürlich Hängt von Ihren Systemeinstellungen ab.  Dort müssen Sie etwas wie das Folgende registrieren (ich bringe das ganze Fußtuch mit, damit Sie navigieren können, der Hauptabschnitt ist hier zu hören) </p><br><pre> <code class="plaintext hljs">; The address on which to accept FastCGI requests. ; Valid syntaxes are: ; 'ip.add.re.ss:port' - to listen on a TCP socket to a specific IPv4 address on ; a specific port; ; '[ip:6:addr:ess]:port' - to listen on a TCP socket to a specific IPv6 address on ; a specific port; ; 'port' - to listen on a TCP socket to all addresses ; (IPv6 and IPv4-mapped) on a specific port; ; '/path/to/unix/socket' - to listen on a unix socket. ; Note: This value is mandatory. ;listen = /run/php/php7.3-fpm.sock listen = 127.0.0.1:9002</code> </pre> <br><p>  Nach dem Einrichten von fpm besteht der nächste Schritt darin, eine Verbindung zum Socket herzustellen </p><br><pre> <code class="php hljs">$service_port = <span class="hljs-number"><span class="hljs-number">9000</span></span>; $address = <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>; $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); $result = socket_connect($socket, $address, $service_port);</code> </pre> <br><h4 id="nachalo-zaprosa-fcgi_begin_request">  Start der FCGI_BEGIN_REQUEST-Anforderung </h4><br><p>  Um eine Verbindung herzustellen, müssen wir einen Eintrag vom Typ FCGI_BEGIN_REQUEST = 1 senden. Der Titel des Eintrags lautet wie folgt (um numerische Werte in eine Binärzeichenfolge mit dem angegebenen Format zu konvertieren, wird das PHP-Funktionspaket () verwendet). </p><br><pre> <code class="php hljs">socket_write($socket, pack(<span class="hljs-string"><span class="hljs-string">'CCnnCx'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//  - 1 //  - 1 - FCGI_BEGIN_REQUEST //id - 1 //   - 8  // - 0</span></span></code> </pre> <br><p>  Der Aufzeichnungskörper zum Öffnen einer Verbindung muss eine Aufzeichnungsrolle und ein Flag enthalten, das die Verbindung steuert </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//      //struct { // unsigned char roleB1; // unsigned char roleB0; // unsigned char flags; // unsigned char reserved[5]; //}; //php  socket_write($socket, pack('nCxxxxx', 1, 0)); // - 1 -  // - 1 -    1   </span></span></code> </pre> <br><p>  Der Datensatz zum Öffnen der Verbindung wurde erfolgreich gesendet. <strong>PHP-fpm</strong> akzeptiert ihn und erwartet weiterhin von uns einen weiteren Datensatz, in dem wir Daten übertragen müssen, um die Umgebung bereitzustellen und das Skript auszuführen. </p><br><h4 id="peredacha-parametrov-okruzheniya-fcgi_params">  Übergeben von Umgebungsparametern FCGI_PARAMS </h4><br><p>  In diesem Datensatz übergeben wir alle Parameter, die zum Bereitstellen der Umgebung erforderlich sind, sowie den Namen des Skripts, das ausgeführt werden muss. </p><br><p>  Minimal erforderliche Umgebungseinstellungen </p><br><pre> <code class="php hljs">$url = <span class="hljs-string"><span class="hljs-string">'/path/to/script.php'</span></span> $env = [ <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'SCRIPT_FILENAME'</span></span> =&gt; $url, ];</code> </pre> <br><p>  Das erste, was wir hier tun müssen, ist, die erforderlichen Variablen vorzubereiten, dh die Namen =&gt; Wertepaare, die wir an die Anwendung übergeben. </p><br><p>  Die Struktur des Namensnamens des Paares wird so sein </p><br><pre> <code class="plaintext hljs">//          128  typedef struct { unsigned char nameLength; unsigned char valueLength; unsigned char nameData unsigned char valueData; }; //    1 </code> </pre> <br><p>  Zuerst gibt es 1 Byte - der Name ist lang, dann ist 1 Byte der Wert </p><br><pre> <code class="plaintext hljs">//         128  typedef struct { unsigned char nameLengthA1; unsigned char nameLengthA2; unsigned char nameLengthA3; unsigned char nameLengthA4; unsigned char valueLengthB1; unsigned char valueLengthB2; unsigned char valueLengthB3; unsigned char valueLengthB4; unsigned char nameData unsigned char valueData; }; //    4 </code> </pre> <br><p>  In unserem Fall sind sowohl der Name als auch die Bedeutung kurz und passen zur ersten Option, daher werden wir darüber nachdenken. </p><br><p>  Codieren Sie unsere Variablen entsprechend dem Format </p><br><pre> <code class="php hljs">$keyValueFcgiString = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($env <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $key =&gt; $value) { <span class="hljs-comment"><span class="hljs-comment">//        //  128         $keyLen = strlen($key); $lenKeyChar = $keyLen &lt; 128 ? chr($keyLen) : pack('N', $keyLen); $valLen = strlen($value); $valLenChar = $valLen &lt; 128 ? chr($valLen) : pack('N', $valLen); $keyValueFcgiString .= $lenKeyChar . $valLenChar . $key . $value; }</span></span></code> </pre> <br><p>  Hier werden Werte von weniger als 128 Bit von der Funktion <em>chr ($ keyLen)</em> codiert, mehr als <em>pack ('N', $ valLen)</em> , wobei 'N' für 4 Bytes steht.  Und dann wird all dies in einer Zeile entsprechend dem Format der Struktur zusammengeklebt.  Der Hauptteil der Aufnahme ist fertig. </p><br><p>  In der Kopfzeile des Datensatzes übertragen wir alles wie im vorherigen Datensatz, mit Ausnahme des Typs (FCGI_PARAMS = 4) und der Datenlänge (entspricht der Länge der Namen =&gt; Wertepaare oder der Länge der Zeichenfolge $ keyValueFcgiString, die wir zuvor gebildet haben). </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//  socket_write($socket, pack('CCnnCx', 1, 4, 1, strlen($keyValueFcgiString), 0)); // body socket_write($socket, $keyValueFcgiString); //             //  body socket_write($socket, pack('CCnnCx', 1, 4, 1, 0, 0));</span></span></code> </pre> <br><h4 id="poluchenie-otveta-fcgi_params">  Eine Antwort von FCGI_PARAMS erhalten </h4><br><p>  Nachdem alle vorherigen Schritte ausgeführt wurden und alles, was erwartet wird, an die Anwendung gesendet wurde, funktioniert sie tatsächlich und wir können das Ergebnis dieser Arbeit nur aus dem Socket entnehmen. <br>  Denken Sie daran, dass wir als Antwort dieselben Notizen erhalten und diese auch interpretieren müssen. </p><br><p>  Wir bekommen den Header, es sind immer 8 Bytes (wir erhalten Daten pro Byte) </p><br><pre> <code class="php hljs">$buf = <span class="hljs-string"><span class="hljs-string">''</span></span>; $arrData = []; $len = <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($len) { socket_recv($socket, $buf, <span class="hljs-number"><span class="hljs-number">1</span></span>, MSG_WAITALL); <span class="hljs-comment"><span class="hljs-comment">//   1       $arrData[] = $buf; $len--; } //      'CCnnCx' $protocol = unpack('C', $arrData[0]); $type = unpack('C', $arrData[1]); $id = unpack('n', $arrData[2] . $arrData[3]); $dataLen = unpack('n', $arrData[4] . $arrData[5])[1]; //   ,        (unpack  ,    ) $foo = unpack('C', $arrData[6]); var_dump($dataLen); //     </span></span></code> </pre> <br><p>  In Übereinstimmung mit der Länge des empfangenen Antwortkörpers werden wir nun eine weitere Messung aus dem Socket durchführen </p><br><pre> <code class="php hljs">$buf2 = <span class="hljs-string"><span class="hljs-string">''</span></span>; $result = []; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($dataLen) { socket_recv($socket, $buf2, <span class="hljs-number"><span class="hljs-number">1</span></span>, MSG_WAITALL); $result[] = $buf2; $dataLen--; } var_dump(implode(<span class="hljs-string"><span class="hljs-string">''</span></span>, $result)); <span class="hljs-comment"><span class="hljs-comment">//       socket_close($socket);</span></span></code> </pre> <br><p>  Hurra, es hat funktioniert!  Endlich das! <br>  Was haben wir in der Antwort, wenn zum Beispiel in dieser Datei </p><br><pre> <code class="php hljs">$url = <span class="hljs-string"><span class="hljs-string">'/path/to/script.php'</span></span> <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre> <br><p>  wir werden schreiben </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"My fcgi script"</span></span>;</code> </pre> <br><p>  dann in der Antwort erhalten wir als Ergebnis </p><br><p><img src="https://habrastorage.org/webt/dq/pc/ox/dqpcox1zbmcutdzxxeh69i_hbsc.png" alt="Bild"></p><br><h3 id="itogi">  Zusammenfassung </h3><br><p>  Ich werde hier nicht viel schreiben, daher stellte sich der lange Artikel heraus.  Ich hoffe sie hilft jemandem.  Und ich werde das endgültige Drehbuch selbst geben, es stellte sich als ziemlich klein heraus.  Natürlich kann er in dieser Form einiges tun, und er hat keine Fehlerbehandlung und all dies, aber er braucht es nicht, er braucht ihn als Beispiel, um die Grundlagen zu zeigen. </p><br><div class="spoiler">  <b class="spoiler_title">Vollversion des Skripts</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $url = <span class="hljs-string"><span class="hljs-string">'/path/to/script.php'</span></span>; $env = [ <span class="hljs-string"><span class="hljs-string">'REQUEST_METHOD'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'SCRIPT_FILENAME'</span></span> =&gt; $url, ]; $service_port = <span class="hljs-number"><span class="hljs-number">9000</span></span>; $address = <span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>; $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); $result = socket_connect($socket, $address, $service_port); <span class="hljs-comment"><span class="hljs-comment">//  //     php-fpm //    ,   (    ), id ,   ,     socket_write($socket, pack('CCnnCx', 1, 1, 1, 8, 0)); //     // ,     socket_write($socket, pack('nCxxxxx', 1, 0)); $keyValueFcgiString = ''; foreach ($env as $key =&gt; $value) { //        //  128         $keyLen = strlen($key); $lenKeyChar = $keyLen &lt; 128 ? chr($keyLen) : pack('N', $keyLen); $valLen = strlen($value); $valLenChar = $valLen &lt; 128 ? chr($valLen) : pack('N', $valLen); $keyValueFcgiString .= $lenKeyChar . $valLenChar . $key . $value; } // ,      php-fpm           //      //1- ( ), 4-  (,    - FCGI_PARAMS), id  ( ),    (   -),     socket_write($socket, pack('CCnnCx', 1, 4, 1, strlen($keyValueFcgiString), 0)); //      socket_write($socket, $keyValueFcgiString); //  socket_write($socket, pack('CCnnCx', 1, 4, 1, 0, 0)); $buf = ''; $arrData = []; $len = 8; while ($len) { socket_recv($socket, $buf, 1, MSG_WAITALL); //   1       $arrData[] = $buf; $len--; } //      'CCnnCx' $protocol = unpack('C', $arrData[0]); $type = unpack('C', $arrData[1]); $id = unpack('n', $arrData[2] . $arrData[3]); $dataLen = unpack('n', $arrData[4] . $arrData[5])[1]; //   ,        (unpack  ,    ) $foo = unpack('C', $arrData[6]); $buf2 = ''; $result = []; while ($dataLen) { socket_recv($socket, $buf2, 1, MSG_WAITALL); $result[] = $buf2; $dataLen--; } var_dump(implode('', $result)); //       socket_close($socket);</span></span></code> </pre></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472190/">https://habr.com/ru/post/de472190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472178/index.html">Holivar. Geschichte von Runet. Teil 7. YouTube: Comedians, Squeaks und Silicon Valley</a></li>
<li><a href="../de472182/index.html">Ankündigung von .NET Core 3.1 Vorschau 1</a></li>
<li><a href="../de472184/index.html">Remote SSH: Tipps und Tricks</a></li>
<li><a href="../de472186/index.html">Open-Closed-Prinzip</a></li>
<li><a href="../de472188/index.html">Was Sie über die Überprüfung des App Store-Checks wissen müssen (App Store-Quittung)</a></li>
<li><a href="../de472196/index.html">Selbst gemachter "Zucker" für ein Android-Projekt oder "Wie man es nicht macht"</a></li>
<li><a href="../de472198/index.html">Lokalisierung von Push-Nachrichten in mobilen Anwendungen</a></li>
<li><a href="../de472200/index.html">Modernisierung des Informatikunterrichts an einer russischen Schule auf einer Himbeere: billig und fröhlich</a></li>
<li><a href="../de472202/index.html">Windows 10 + Python = VS Code + WSL</a></li>
<li><a href="../de472204/index.html">Einfache Experimente mit dem Mikrocontroller STM32F103 (Blue Tablet)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>