<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòë üñ±Ô∏è üßíüèæ Desvantagens do RISC-V üõí üëÆ üç¥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Inicialmente, escrevi este documento h√° v√°rios anos, como engenheiro de verifica√ß√£o do n√∫cleo de execu√ß√£o no ARM. Obviamente, minha opini√£o foi influe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desvantagens do RISC-V</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461785/">  Inicialmente, escrevi este documento h√° v√°rios anos, como engenheiro de verifica√ß√£o do n√∫cleo de execu√ß√£o no ARM.  Obviamente, minha opini√£o foi influenciada por um trabalho aprofundado com os n√∫cleos executivos de diferentes processadores.  Fa√ßa isso com desconto, por favor: talvez eu seja muito categ√≥rico. <br><br>  No entanto, ainda acredito que os criadores do RISC-V poderiam fazer muito melhor.  Por outro lado, se eu tivesse projetado um processador de 32 ou 64 bits hoje, provavelmente teria implementado exatamente essa arquitetura para tirar proveito das ferramentas existentes. <br><br>  O artigo descreveu originalmente o conjunto de instru√ß√µes RISC-V 2.0.  Para a vers√£o 2.2, ele fez algumas atualiza√ß√µes. <br><a name="habracut"></a><br><h1>  Pref√°cio original: algumas opini√µes pessoais </h1><br>  O conjunto de instru√ß√µes RISC-V foi reduzido ao m√≠nimo absoluto.  √â prestada muita aten√ß√£o √† minimiza√ß√£o do n√∫mero de instru√ß√µes, √† normaliza√ß√£o da codifica√ß√£o etc. Esse desejo de minimalismo levou a uma falsa ortogonalidade (como a reutiliza√ß√£o da mesma instru√ß√£o para transi√ß√µes, chamadas e retornos) e √† verbosidade obrigat√≥ria, que aumenta o tamanho e a quantidade instru√ß√µes. <br><br>  Por exemplo, aqui est√° o c√≥digo C: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readidx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[idx]; }</code> </pre> <br>  Este √© um caso simples de indexa√ß√£o de uma matriz, uma opera√ß√£o muito comum.  Esta √© a compila√ß√£o para x86_64: <br><br><pre> <code class="plaintext hljs">mov eax, [rdi+rsi*4] ret</code> </pre> <br>  ou BRA√áO: <br><br><pre> <code class="plaintext hljs">ldr r0, [r0, r1, lsl #2] bx lr // return</code> </pre> <br>  No entanto, para o RISC-V, o seguinte c√≥digo √© necess√°rio: <br><br><pre> <code class="plaintext hljs">slli a1, a1, 2 add a0, a1, a1 lw a0, a0, 0 jalr r0, r1, 0 // return</code> </pre> <br>  Simplifica√ß√£o O RISC-V simplifica o decodificador (isto √©, o front-end da CPU) executando mais instru√ß√µes.  Mas escalar a largura do pipeline √© um problema dif√≠cil, enquanto a decodifica√ß√£o de instru√ß√µes irregulares (ou fortemente) irregulares √© bem implementada (a principal dificuldade surge quando √© dif√≠cil determinar o comprimento da instru√ß√£o: isso √© especialmente evidente no conjunto de instru√ß√µes x86 com v√°rios prefixos). <br><br>  A simplifica√ß√£o do conjunto de instru√ß√µes n√£o deve ser levada ao limite.  O registro e a adi√ß√£o de registros com um deslocamento da mem√≥ria do registro s√£o uma instru√ß√£o simples e muito comum nos programas e √© muito f√°cil para o processador implement√°-lo efetivamente.  Se o processador n√£o puder implementar a instru√ß√£o diretamente, pode ser relativamente f√°cil decomp√¥-la em seus componentes;  esse √© um problema muito mais simples do que mesclar seq√º√™ncias de opera√ß√µes simples. <br><br>  Devemos distinguir entre instru√ß√µes espec√≠ficas ‚Äúcomplexas‚Äù dos processadores CISC - instru√ß√µes complicadas, raramente usadas e ineficientes - das instru√ß√µes ‚Äúfuncionais‚Äù comuns aos processadores CISC e RISC, que combinam uma pequena sequ√™ncia de opera√ß√µes.  Estes √∫ltimos s√£o usados ‚Äã‚Äãcom freq√º√™ncia e com alto desempenho. <br><br><h1>  Implementa√ß√£o med√≠ocre </h1><br><ul><li>  Extensibilidade quase ilimitada.  Embora esse seja o objetivo do RISC-V, ele cria um ecossistema fragmentado e incompat√≠vel que deve ser gerenciado com extrema cautela. <br></li><li>  A mesma instru√ß√£o ( <code>JALR</code> ) √© usada para chamadas e retornos e para ramifica√ß√µes indiretas de registro, onde decodifica√ß√£o adicional √© necess√°ria para a previs√£o de ramifica√ß√£o <br><ul><li>  Chamada: <code>Rd</code> = <code>R1</code> <br></li><li>  Retorno: <code>Rd</code> = <code>R0</code> , <code>Rs</code> = <code>R1</code> <br></li><li>  Transi√ß√£o indireta: <code>Rd</code> = <code>R0</code> , <code>Rs</code> ‚â† <code>R1</code> <br></li><li>  (Transi√ß√£o estranha: <code>Rd</code> ‚â† <code>R0</code> , <code>Rd</code> ‚â† <code>R1</code> ) </li></ul></li><li>  A codifica√ß√£o com um comprimento vari√°vel do campo de grava√ß√£o n√£o √© auto-sincronizada (isso geralmente √© encontrado - por exemplo, um problema semelhante com x86 e Thumb-2 - mas isso causa v√°rios problemas de implementa√ß√£o e seguran√ßa, por exemplo, programa√ß√£o orientada a reversa, ou seja, ataques ROP ) <br></li><li>  O RV64I requer uma extens√£o de caractere para todos os valores de 32 bits.  Isso leva ao fato de que a metade superior dos registros de 64 bits se torna imposs√≠vel de usar para armazenar resultados intermedi√°rios, o que leva a um posicionamento especial desnecess√°rio da metade superior dos registros.  √â mais ideal usar a extens√£o com zeros (j√° que reduz o n√∫mero de comuta√ß√µes e geralmente pode ser otimizado rastreando o bit "zero" quando a metade superior √© conhecida como zero) <br></li><li>  A multiplica√ß√£o √© opcional.  Embora os blocos de multiplica√ß√£o r√°pida possam ocupar uma √°rea substancial em pequenos cristais, voc√™ sempre pode usar circuitos um pouco mais lentos que ativamente usam a ALU existente para v√°rios ciclos de multiplica√ß√£o. <br></li><li>  <code>LR</code> / <code>SC</code> requisitos r√≠gidos de progress√£o para um subconjunto limitado de aplicativos.  Embora essa restri√ß√£o seja bastante rigorosa, ela potencialmente cria alguns problemas para pequenas implementa√ß√µes (especialmente sem cache) <br><ul><li>  Parece um substituto para a instru√ß√£o CAS, veja o coment√°rio abaixo </li></ul></li><li>  Os bits da mem√≥ria FP e o modo de arredondamento est√£o no mesmo registro.  Isso requer a serializa√ß√£o do canal FP, se a opera√ß√£o RMW for realizada para alterar o modo de arredondamento. <br></li><li>  <code>FP</code> instru√ß√µes <code>FP</code> s√£o codificadas para precis√£o de 32, 64 e 128 bits, mas n√£o de 16 bits (o que √© muito mais comum em hardware que 128 bits) <br><ul><li>  Isso pode ser facilmente corrigido: o c√≥digo da dimens√£o <code>0b10</code> gratuito. <br></li><li>  <i>Atualiza√ß√£o:</i> espa√ßo reservado <i>decimal</i> apareceu na vers√£o 2.2, mas n√£o h√° espa√ßo reservado de meia precis√£o.  A mente √© incompreens√≠vel. </li></ul></li><li>  A maneira como os valores FP s√£o representados no arquivo de registro FP n√£o est√° definida, mas √© observ√°vel (via carga / armazenamento) <br><ul><li>  Autores de emuladores v√£o te odiar <br></li><li>  A migra√ß√£o de m√°quinas virtuais pode se tornar imposs√≠vel <br></li><li>  <i>Atualiza√ß√£o: a</i> vers√£o 2.2 requer valores maiores de NaN-boxing </li></ul></li></ul><br><h1>  Ruim </h1><br><ul><li>  N√£o h√° c√≥digos de condi√ß√£o e, em vez disso, as instru√ß√µes de compara√ß√£o e ramifica√ß√£o s√£o usadas.  Isso n√£o √© um problema em si, mas as consequ√™ncias s√£o desagrad√°veis: <br><ul><li>  Espa√ßo de codifica√ß√£o reduzido em ramifica√ß√µes condicionais devido √† necessidade de codificar um ou dois especificadores de registro <br></li><li>  Nenhuma op√ß√£o condicional (√∫til para transi√ß√µes muito imprevis√≠veis) <br></li><li>  Nenhuma transfer√™ncia / subtra√ß√£o com transfer√™ncia ou empr√©stimo <br></li><li>  (Observe que isso ainda √© melhor do que conjuntos de comandos que gravam sinalizadores no registro geral e depois alternam para os sinalizadores recebidos) </li></ul></li><li>  Parece que os contadores de alta precis√£o (ciclos de hardware) <i>s√£o necess√°rios</i> em um ISA sem privil√©gios.  Na pr√°tica, fornecer aplicativos a eles √© um excelente vetor para ataques a canais de terceiros <br></li><li>  Multiplica√ß√£o e divis√£o fazem parte da mesma extens√£o, e parece que, se uma √© implementada, a outra tamb√©m deve ser.  A multiplica√ß√£o √© muito mais simples que a divis√£o e √© comum na maioria dos processadores, mas a divis√£o n√£o √©. <br></li><li>  N√£o h√° instru√ß√µes at√¥micas na arquitetura b√°sica do conjunto de instru√ß√µes.  Microcontroladores de m√∫ltiplos n√∫cleos est√£o se tornando mais comuns, portanto instru√ß√µes at√¥micas como LL / SC s√£o baratas (para implementa√ß√£o m√≠nima em um √∫nico processador [de v√°rios n√∫cleos], √© necess√°rio apenas 1 bit de estado do processador) <br></li><li>  <code>LR</code> / <code>SC</code> est√£o na mesma extens√£o que instru√ß√µes at√¥micas mais complexas, o que limita a flexibilidade para pequenas implementa√ß√µes <br></li><li>  Instru√ß√µes at√¥micas gerais (n√£o <code>LR</code> / <code>SC</code> ) n√£o incluem <code>CAS</code> primitivo <br><ul><li>  O <code>CmpHi:CmpLo</code> evitar a necessidade de uma instru√ß√£o que leia cinco registros ( <code>Addr</code> , <code>CmpHi:CmpLo</code> , <code>SwapHi:SwapLo</code> ), mas isso provavelmente impor√° menos sobrecarga de implementa√ß√£o do que o <code>LR</code> / <code>SC</code> avan√ßado garantido, que √© fornecido como substitui√ß√µes </li></ul></li><li>  S√£o fornecidas instru√ß√µes at√¥micas que funcionam com valores de 32 e 64 bits, mas n√£o de 8 ou 16 bits <br></li><li>  Para o RV32I, n√£o h√° como transferir o valor DP FP entre um n√∫mero inteiro e um arquivo de registro FP, exceto atrav√©s da mem√≥ria, ou seja, dos registros inteiros de 32 bits, √© imposs√≠vel criar um n√∫mero de ponto flutuante de precis√£o dupla de 64 bits; voc√™ deve primeiro gravar o valor intermedi√°rio na mem√≥ria e carregar ele no arquivo de registro de l√° <br></li><li>  Por exemplo, a instru√ß√£o <code>ADD</code> 32 bits no RV32I e o <code>ADD</code> 64 bits no RVI64 t√™m as mesmas codifica√ß√µes e, no RVI64, √© <code>ADD.W</code> outra codifica√ß√£o <code>ADD.W</code>  Essa √© uma complica√ß√£o desnecess√°ria para um processador que implementa ambas as instru√ß√µes - seria prefer√≠vel adicionar uma nova codifica√ß√£o de 64 bits. <br></li><li>  Nenhuma instru√ß√£o <code>MOV</code> .  O c√≥digo mnem√¥nico do comando <code>MV</code> √© traduzido pelo assembler na instru√ß√£o <code>MV rD, rS</code> -&gt; <code>ADDI rD, rS, 0</code> .  Os processadores de alto desempenho normalmente otimizam as instru√ß√µes <code>MOV</code> , enquanto reordenam extensivamente as instru√ß√µes.  Uma instru√ß√£o com um operando direto de 12 bits foi escolhida como a forma can√¥nica da instru√ß√£o <code>MV</code> no RISC-V. <br><ul><li>  Na aus√™ncia de <code>MOV</code> a instru√ß√£o <code>ADD rD, rS, r0</code> torna-se prefer√≠vel ao <code>MOV</code> can√¥nico, pois √© mais f√°cil de decodificar, e as opera√ß√µes com registro zero (r0) na CPU geralmente s√£o otimizadas </li></ul></li></ul><br><h1>  Horr√≠vel </h1><br><ul><li>  <code>JAL</code> gasta 5 bits na codifica√ß√£o do registro de comunica√ß√£o, que √© sempre igual a <code>R1</code> (ou <code>R0</code> para transi√ß√µes) <br><ul><li>  Isso significa que o RV32I usa deslocamento de ramifica√ß√£o de 21 bits.  Isso n√£o √© suficiente para aplicativos grandes - por exemplo, navegadores da web - sem usar v√°rias seq√º√™ncias de comandos e / ou "ilhas de ramifica√ß√£o" <br></li><li>  Esta √© uma deteriora√ß√£o em compara√ß√£o com a vers√£o 1.0 da arquitetura de comandos! </li></ul></li><li>  Apesar do grande esfor√ßo para codificar de maneira uniforme, as instru√ß√µes de carregamento / armazenamento s√£o codificadas de maneira diferente (os casos e os campos imediatos mudam) <br><ul><li>  Aparentemente, a ortogonalidade de codifica√ß√£o do registro de sa√≠da era prefer√≠vel √† ortogonalidade de codifica√ß√£o de duas instru√ß√µes fortemente relacionadas.  Essa escolha parece um pouco estranha, pois a gera√ß√£o de endere√ßos √© mais cr√≠tica em termos de tempo. </li></ul></li><li>  N√£o h√° instru√ß√µes de carregamento de mem√≥ria com compensa√ß√µes de registro ( <code>Rbase</code> + <code>Roffset</code> ) ou √≠ndices ( <code>Rbase</code> + <code>Rindex</code> &lt;&lt; <code>Scale</code> ). <br></li><li>  <code>FENCE.I</code> implica uma sincroniza√ß√£o completa do cache de instru√ß√µes com todos os reposit√≥rios anteriores, com ou sem prote√ß√£o.  As implementa√ß√µes precisam limpar todos os I $ em cima do muro ou procurar D $ e o buffer de armazenamento <br></li><li>  No RV32I, a leitura dos contadores de 64 bits requer a leitura da metade superior duas vezes, compara√ß√£o e ramifica√ß√£o no caso de transfer√™ncia entre a metade inferior e a parte superior durante uma opera√ß√£o de leitura <br><ul><li>  Normalmente, os ISAs de 32 bits incluem uma instru√ß√£o de leitura de par de registro especial para evitar esse problema. </li></ul></li><li>  N√£o h√° espa√ßo definido arquitetonicamente para a codifica√ß√£o de dicas, para que as instru√ß√µes desse espa√ßo n√£o causem erros nos processadores mais antigos (processados ‚Äã‚Äãcomo <code>NOP</code> ), mas fa√ßam algo nas CPUs mais modernas <br><ul><li>  Exemplos t√≠picos de dicas de NOP puros s√£o coisas como rendimento de spinlock <br></li><li>  Os processadores mais recentes tamb√©m t√™m dicas mais sofisticadas (com efeitos colaterais vis√≠veis nos processadores mais recentes; por exemplo, instru√ß√µes de verifica√ß√£o de borda x86 s√£o codificadas no espa√ßo de dicas, para que os bin√°rios permane√ßam compat√≠veis com vers√µes anteriores) </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461785/">https://habr.com/ru/post/pt461785/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461771/index.html">Diga n√£o ao sil√™ncio: do ber√ß√°rio ao escrit√≥rio</a></li>
<li><a href="../pt461773/index.html">Airtest IDE - uma nova maneira de testar a automa√ß√£o de jogos para celular?</a></li>
<li><a href="../pt461775/index.html">3 casos para usar o aipo em um aplicativo Django</a></li>
<li><a href="../pt461779/index.html">80% dos dados da sua empresa n√£o est√£o dispon√≠veis para voc√™. O que fazer sobre isso?</a></li>
<li><a href="../pt461781/index.html">"Ycombinator Startup School 2019." V√≠deo das tr√™s primeiras semanas</a></li>
<li><a href="../pt461787/index.html">Exibi√ß√£o de texto Android</a></li>
<li><a href="../pt461793/index.html">Ivan Ponomarev sobre a API do Kafka Streams na reuni√£o jug.msk.ru</a></li>
<li><a href="../pt461797/index.html">Contos de servi√ßo. Um post fr√≠volo sobre trabalho s√©rio</a></li>
<li><a href="../pt461801/index.html">DisplayPort-LVDS</a></li>
<li><a href="../pt461803/index.html">Data Version Control (DVC): controle de vers√£o de dados e reprodutibilidade do experimento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>