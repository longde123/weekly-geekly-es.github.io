<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏾 🦊 🤽🏼 Aktualisierung des Lebenszeitprofils in Visual Studio 2019 Vorschau 2 📐 🙊 🤧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Lebenszeitprofil der C ++ - Kernrichtlinien , das Teil der C ++ - Kernrichtlinien ist , zielt darauf ab, Lebensdauerprobleme wie baumelnde Zeiger ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aktualisierung des Lebenszeitprofils in Visual Studio 2019 Vorschau 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/437660/"><p>  Das Lebenszeitprofil der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ - Kernrichtlinien</a> , das Teil der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ - Kernrichtlinien ist</a> , zielt darauf ab, Lebensdauerprobleme wie baumelnde Zeiger und Referenzen in C ++ - Code zu erkennen.  Es verwendet die bereits in der Quelle vorhandenen Typinformationen zusammen mit einigen einfachen Verträgen zwischen Funktionen, um Fehler zur Kompilierungszeit mit minimaler Annotation zu erkennen. </p><br><br><img src="https://habrastorage.org/webt/m6/sd/zl/m6sdzl8oiweahnxld6esvr3s03u.png"><a name="habracut"></a><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Original im Blog</a> <br><br><p>  Dies sind die Grundverträge, für die das Profil Code erwartet: </p><br><ol><li>  Verwenden Sie keinen möglicherweise baumelnden Zeiger. </li><li>  Übergeben Sie keinen möglicherweise baumelnden Zeiger an eine andere Funktion. </li><li>  Geben Sie keinen möglicherweise baumelnden Zeiger von einer Funktion zurück. </li></ol><br><p>  Weitere Informationen zum Verlauf und zu den Zielen des Profils finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herb Sutters Blogbeitrag zu Version 1.0</a> . </p><br><h2>  Was ist neu in Visual Studio 2019 Vorschau 2 </h2><br><p>  In Vorschau 2 haben wir eine Vorschauversion des Lifetime Profile Checker ausgeliefert, die die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">veröffentlichte Version des Lifetime Profile</a> implementiert.  Dieser Checker ist Teil der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">C ++ Core Checker</a> in Visual Studio. </p><br><ul><li>  Unterstützung für Iteratoren, Zeichenfolgenansichten und Bereiche. </li><li>  Bessere Erkennung von benutzerdefinierten Eigentümer- und Zeigertypen, sodass benutzerdefinierte Typen, die sich wie Container, Eigentümerzeiger oder Nicht-Eigentümerzeiger verhalten, an der Analyse teilnehmen können. </li><li>  Typbezogene Standardregeln für Vor- und Nachbedingungen von Funktionsaufrufen tragen dazu bei, Fehlalarme zu reduzieren und die Genauigkeit zu verbessern. </li><li>  Bessere Unterstützung für Aggregattypen. </li><li>  Allgemeine Korrektheit und Leistungsverbesserungen. </li><li>  Einige einfache Nullptr-Analysen. </li></ul><br><h2>  Aktivieren der Regeln für die Prüfung des Lebenszeitprofils </h2><br><p>  Die Prüferregeln sind standardmäßig nicht aktiviert.  Wenn Sie die neuen Regeln ausprobieren möchten, müssen Sie den für Ihr Projekt ausgewählten Regelsatz für die Codeanalyse aktualisieren.  Sie können entweder die "C ++ Core Check Lifetime Rules" auswählen, die nur die Lifetime Profile-Regeln aktivieren, oder Sie können Ihren vorhandenen Regelsatz ändern, um die Warnungen 26486 bis 26489 zu aktivieren. </p><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/602/81e/cdc/60281ecdcf10232b8e9f58c5f0623d31.png" alt="Screenshot der Eigenschaftenseite der Codeanalyse, auf der der ausgewählte Regelsatz für C ++ Core Check Lifetime Rules angezeigt wird." width="1253" height="898"></a> <p>  Screenshot der Eigenschaftenseite der Codeanalyse, auf der der ausgewählte Regelsatz für C ++ Core Check Lifetime Rules angezeigt wird. </p><br><p>  Warnungen werden in der Fehlerliste angezeigt, wenn die Codeanalyse ausgeführt wird (Analysieren&gt; Codeanalyse ausführen) oder wenn Sie die Hintergrundcodeanalyse aktiviert haben, werden lebenslange Fehler im Editor mit grünen Schnörkeln angezeigt. </p><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/593/6da/b6c/5936dab6c4be57347101009d35125739.png" alt="Screenshot mit einer Warnung zur Überprüfung des Lebenszeitprofils mit einem grünen Kringel im Quellcode." width="982" height="134"></a> <p>  Screenshot mit einer Warnung zur Überprüfung des Lebenszeitprofils mit einem grünen Kringel im Quellcode. </p><br><h2>  Beispiele </h2><br><h3>  Baumelnder Zeiger </h3><br><p> Das einfachste Beispiel - mit einem baumelnden Zeiger - ist der beste Ausgangspunkt.  Hier zeigt <code>px</code> auf <code>x</code> und dann verlässt <code>x</code> Bereich und lässt <code>px</code> baumeln.  Wenn <code>px</code> verwendet wird, wird eine Warnung ausgegeben. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simple_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* px; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; px = &amp;x; } *px = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// error, dangling pointer to 'x' }</span></span></code> </pre> <br><h3>  Baumelnder Ausgabezeiger </h3><br><p>  Das Zurückgeben von baumelnden Zeigern ist ebenfalls nicht zulässig.  In diesem Fall wird angenommen, dass der Parameter <code>ppx</code> ein Ausgabeparameter ist.  In diesem Fall wird auf <code>x</code> was am Ende der Funktion den Gültigkeitsbereich verlässt.  Dies lässt <code>*ppx</code> baumeln. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out_parameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">** ppx)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// *ppx points to 'x' which is invalid { *ppx = &amp;x; }</span></span></span></span></code> </pre> <br><h3>  Baumelnde Schnuransicht </h3><br><p>  Die letzten beiden Beispiele waren offensichtlich, aber temporäre Instanzen können subtile Fehler verursachen.  Können Sie den Fehler im folgenden Code finden? </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_string</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_string_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::string_view sv = get_string(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> c = sv.at(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>  In diesem Fall wird die Zeichenfolgenansicht <code>sv</code> mit der temporären Zeichenfolgeninstanz erstellt, die von <code>get_string()</code> .  Die temporäre Zeichenfolge wird dann zerstört, sodass die Zeichenfolgenansicht auf ein ungültiges Objekt verweist. </p><br><h3>  Dangling Iterator </h3><br><p>  Ein weiteres schwer zu erkennendes Problem für die Lebensdauer tritt auf, wenn ein ungültiger Iterator in einem Container verwendet wird.  Im folgenden Fall kann der Aufruf von <code>push_back</code> dazu führen, dass der Vektor seinen zugrunde liegenden Speicher neu <code>push_back</code> wodurch der Iterator ungültig <code>it</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangling_iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = v.begin(); *it = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ok, iterator is valid v.push_back(4); *it = 0; // error, using an invalid iterator }</span></span></code> </pre> <br><p>  Bei diesem Beispiel ist zu beachten, dass es für 'std :: vector :: push_back' keine spezielle Behandlung gibt.  Dieses Verhalten entspricht nicht den Standardprofilregeln.  Eine Regel klassifiziert Container als "Eigentümer".  Wenn dann eine nicht konstante Methode für den Eigentümer aufgerufen wird, wird angenommen, dass der eigene Speicher ungültig ist, und Iteratoren, die auf den eigenen Speicher verweisen, werden ebenfalls als ungültig betrachtet. </p><br><h3>  Geänderter Besitzer </h3><br><p>  Das Profil ist in seiner Anleitung vorschreibend.  Es wird erwartet, dass der Code beim Definieren von Funktionsparametern das Typsystem idiomatisch verwendet.  In diesem nächsten Beispiel wird <code>std::unique_ptr</code> , ein 'Owner'-Typ, als nicht konstante Referenz an eine andere Funktion übergeben.  Gemäß den Regeln des Profils wird angenommen, dass Eigentümer, die als nicht konstante Referenz übergeben werden, vom Angerufenen geändert werden. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_unique_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; upRef)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assumes_modification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> unique = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Line A auto ptr = unique.get(); *ptr = 10; // ok, ptr is valid use_unique_ptr(unique); *ptr = 10; // error, dangling pointer to the memory held by 'unique' at Line A }</span></span></code> </pre> <br><p>  In diesem Beispiel erhalten wir den <code>ptr</code> auf den Speicher von <code>unique</code> .  Dann wird <code>unique</code> als nicht <code>use_unique_ptr</code> Referenz an die Funktion <code>use_unique_ptr</code> .  Da dies eine nicht konstante Verwendung von <code>unique</code> bei der die Funktion alles tun kann, geht die Analyse davon aus, dass <code>unique</code> 'irgendwie ungültig ist (z. B. unique_ptr :: reset), was dazu führen würde, dass <code>ptr</code> baumelt. </p><br><h3>  Weitere Beispiele </h3><br><p>  Es gibt viele andere Fälle, die die Analyse erkennen kann.  Probieren Sie es in Visual Studio mit Ihrem eigenen Code aus und sehen Sie, was Sie finden.  Weitere Beispiele finden Sie auch in Herbs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog.</a> Wenn Sie neugierig sind, lesen Sie das Lifetime Profile-Dokument. </p><br><h2>  Bekannte Probleme </h2><br><p>  Die aktuelle Implementierung unterstützt die Analyse nicht vollständig, wie im Lifetime Profile-Dokument beschrieben.  Hier sind die allgemeinen Kategorien aufgeführt, die in dieser Version nicht implementiert sind. </p><br><ul><li>  <b>Anmerkungen</b> - In diesem <code>[[gsl::lifetime-const]]</code> Anmerkungen (dh <code>[[gsl::lifetime-const]]</code> ) vorgestellt, die nicht unterstützt werden.  Praktisch bedeutet dies, dass Sie nichts anderes tun können, als falsch positive Ergebnisse zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unterdrücken</a> , wenn die Standardanalyseregeln für Ihren Code nicht funktionieren. </li><li>  <b>Ausnahmen</b> - Ausnahmebehandlungspfade, einschließlich des Inhalts von <code>catch</code> Blöcken, werden derzeit nicht analysiert. </li><li>  <b>Standardregeln für</b> <b>STL-Typen</b> - Anstelle einer Annotation mit <code>lifetime-const</code> Dokument empfohlen, die seltenen STL-Containerelementfunktionen, bei denen die <b>Standardeinstellungen</b> überschrieben werden sollen, so zu behandeln, als wären sie mit Annotationen versehen.  Zum Beispiel ist eine Überladung von <code>std::vector::at</code> nicht <code>const</code> weil sie eine Nicht-const-Referenz zurückgeben kann - wir wissen jedoch, dass der Aufruf <code>lifetime-const</code> weil sie den Speicher des Vektors nicht ungültig macht.  Wir haben die Arbeit für diese implizite Annotation aller STL-Containertypen noch nicht abgeschlossen. </li><li>  <b>Lambda-Erfassungen</b> - Wenn eine Stapelvariable als Referenz in einem Lambda erfasst wird, erkennen wir derzeit nicht, ob das Lambda den Bereich der erfassten Variablen verlässt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> captures_x = [&amp;x] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> captures_x; <span class="hljs-comment"><span class="hljs-comment">// returns a dangling reference to 'x' }</span></span></code> </pre> </li></ul><br><h2>  Einpacken </h2><br><p>  Probieren Sie den Lifetime Profile Checker in Visual Studio 2019 Preview 2 aus. Wir hoffen, dass er Ihnen dabei hilft, lebenslange Probleme in Ihren Projekten zu identifizieren.  Wenn Sie falsch positive oder falsch negative Ergebnisse finden, melden Sie diese bitte, damit wir die für Sie wichtigen Szenarien priorisieren können.  Wenn Sie Vorschläge oder Probleme mit dieser Prüfung oder einer Visual Studio-Funktion haben, melden Sie entweder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ein Problem</a> oder posten Sie es in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwickler-Community</a> und lassen Sie es uns wissen.  Wir sind auch auf Twitter unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@VisualC</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437660/">https://habr.com/ru/post/de437660/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437650/index.html">Eine Auswahl der besten Geschenke an den Geek und begeisterten Menschen am 23. Februar</a></li>
<li><a href="../de437652/index.html">Ankündigung von TypeScript 3.3 RC</a></li>
<li><a href="../de437654/index.html">Preiswerte und kostengünstige 3D-Fotopolymerdrucker</a></li>
<li><a href="../de437656/index.html">Elefant in einem Porzellanladen: 3D-Drucker mit einem riesigen Druckfeld</a></li>
<li><a href="../de437658/index.html">Anleitung: Thymeleaf + Spring. Teil 3</a></li>
<li><a href="../de437664/index.html">Zusammengesetzte Rückgewinnung</a></li>
<li><a href="../de437666/index.html">Ankündigung der F # 4.6-Vorschau</a></li>
<li><a href="../de437670/index.html">MSVC-Backend-Updates in Visual Studio 2019 Vorschau 2: Neue Optimierungen, OpenMP- und Build-Durchsatzverbesserungen</a></li>
<li><a href="../de437672/index.html">cyberd: Berechnung des Wissens aus web3</a></li>
<li><a href="../de437674/index.html">3D-Objekterkennungsmethoden für unbemannte Fahrzeuge. Yandex-Bericht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>