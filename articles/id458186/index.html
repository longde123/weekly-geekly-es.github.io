<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚊 👨🏿‍🔬 👩🏻‍⚖️ WAL di PostgreSQL: 1. Buffer cache 🕙 👩‍👦 🤕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seri sebelumnya dikhususkan untuk isolasi dan multi-versi PostgreSQL, dan hari ini kita akan memulai yang baru - tentang mekanisme logging write-ahead...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL di PostgreSQL: 1. Buffer cache</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/458186/">  Seri sebelumnya dikhususkan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">isolasi dan multi-versi</a> PostgreSQL, dan hari ini kita akan memulai yang baru - <strong>tentang mekanisme</strong> logging write-ahead.  Biarkan saya mengingatkan Anda bahwa materi ini didasarkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kursus pelatihan</a> administrasi yang saya dan Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">pluzanov lakukan</a> , tetapi jangan ulangi kata demi kata dan dimaksudkan untuk membaca dengan penuh pertimbangan dan eksperimen independen. <br><br>  Siklus ini akan terdiri dari empat bagian: <br><br><ul><li>  Cache penyangga (artikel ini); </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jurnal Prarekam</a> - bagaimana ia diatur dan bagaimana ia digunakan selama pemulihan; </li><li>  Rekaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos pemeriksaan</a> dan latar belakang - mengapa mereka dibutuhkan dan bagaimana cara mereka dikonfigurasi; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penyesuaian log</a> - level dan tugas yang harus diselesaikan, keandalan dan kinerja. </li></ul><br><h1>  Mengapa jurnal itu perlu? </h1><br>  Dalam prosesnya, bagian dari data yang ditangani DBMS disimpan dalam RAM dan ditulis ke disk (atau media non-volatil lainnya) dengan cara yang ditangguhkan.  Semakin jarang ini terjadi, semakin sedikit input-output dan semakin cepat sistem bekerja. <br><br>  Tetapi apa yang terjadi jika terjadi kegagalan, misalnya, ketika daya dimatikan atau jika kesalahan terjadi dalam kode DBMS atau sistem operasi?  Semua isi RAM akan hilang, dan hanya data yang ditulis ke disk akan tetap ada (dengan beberapa jenis kegagalan, disk juga akan menderita, tetapi dalam hal ini hanya salinan cadangan yang akan membantu).  Pada prinsipnya, I / O dapat diatur sedemikian rupa sehingga data pada disk selalu dipertahankan dalam keadaan konsisten, tetapi ini sulit dan tidak terlalu efisien (sejauh yang saya tahu, hanya Firebird yang menggunakan cara ini). <br><br>  Biasanya, termasuk PostgreSQL, data yang ditulis ke disk tidak konsisten, dan ketika memulihkan dari kegagalan, tindakan khusus diperlukan untuk mengembalikan konsistensi.  Penjurnalan adalah mekanisme yang memungkinkan hal ini terjadi. <br><a name="habracut"></a><br><h1>  Cache penyangga </h1><br>  Anehnya, kita akan mulai berbicara tentang penjurnalan dengan cache buffer.  Cache penyangga bukan satu-satunya struktur yang disimpan dalam RAM, tetapi salah satu yang paling penting dan kompleks.  Memahami prinsip operasinya itu penting, apalagi, dalam contoh ini kita akan berkenalan dengan bagaimana data dipertukarkan antara RAM dan disk. <br><br>  Caching digunakan di mana-mana dalam sistem komputasi modern, satu prosesor saja dapat menghitung tiga atau empat level cache.  Secara umum, cache apa pun diperlukan untuk memuluskan perbedaan kinerja antara kedua jenis memori, yang salah satunya relatif cepat, tetapi tidak cukup untuk semua orang, dan yang lainnya relatif lambat, tetapi berlimpah.  Jadi buffer cache memperhalus perbedaan antara waktu akses ke RAM (nanoseconds) dan ke disk (milidetik). <br><br>  Perhatikan bahwa sistem operasi juga memiliki cache disk yang memecahkan masalah yang sama.  Oleh karena itu, DBMS biasanya mencoba untuk menghindari caching ganda dengan mengakses disk secara langsung, melewati cache OS.  Tetapi dalam kasus PostgreSQL, ini tidak demikian: semua data dibaca dan ditulis menggunakan operasi file biasa. <br><br>  Selain itu, disk array, dan bahkan disk itu sendiri, juga memiliki cache sendiri.  Fakta ini masih berguna bagi kita ketika kita sampai pada masalah keandalan. <br><br>  Tetapi kembali ke cache buffer DBMS. <br><br>  Disebut demikian karena merupakan susunan <em>buffer</em> .  Setiap buffer adalah tempat untuk satu halaman data (blok), ditambah header.  Judul, antara lain, berisi: <br><br><ul><li>  lokasi pada disk halaman di buffer (file dan nomor blok di dalamnya); </li><li>  tanda bahwa data pada halaman telah berubah dan cepat atau lambat harus ditulis ke disk (buffer seperti itu disebut <em>kotor</em> ); </li><li>  jumlah panggilan ke buffer (jumlah penggunaan); </li><li>  bendera menyematkan buffer (jumlah pin). </li></ul><br>  Cache buffer terletak di memori bersama server dan dapat diakses untuk semua proses.  Untuk bekerja dengan data - baca atau modifikasi, - proses baca halaman dalam cache.  Saat halaman dalam cache, kami bekerja dengannya dalam RAM dan menghemat akses disk. <br><br><img src="https://habrastorage.org/webt/1u/-j/fd/1u-jfdnjvzjwvrddgb7tbvohhge.png"><br><br>  Awalnya, cache berisi buffer kosong, dan semuanya terhubung ke daftar buffer gratis.  Arti dari pointer ke "korban berikutnya" akan menjadi jelas nanti.  Untuk menemukan halaman yang diinginkan dengan cepat di cache, digunakan tabel hash. <br><br><h1>  Cari halaman dalam cache </h1><br>  Ketika suatu proses perlu membaca halaman, itu pertama-tama mencoba menemukannya di cache buffer menggunakan tabel hash.  Kunci hash adalah nomor file dan nomor halaman di dalam file.  Dalam keranjang terkait tabel hash, proses menemukan nomor buffer dan memeriksa apakah itu benar-benar berisi halaman yang diinginkan.  Seperti halnya tabel hash, tabrakan dimungkinkan di sini;  dalam hal ini, proses harus memeriksa beberapa halaman. <br><br><blockquote>  Menggunakan tabel hash telah lama dikritik.  Struktur ini memungkinkan Anda untuk dengan cepat menemukan buffer pada halaman, tetapi sama sekali tidak berguna jika, misalnya, Anda perlu menemukan semua buffer yang ditempati oleh tabel tertentu.  Tapi belum ada yang mengusulkan pengganti yang baik. <br></blockquote><br>  Jika halaman yang diinginkan ditemukan dalam cache, proses harus "membekukan" buffer dengan meningkatkan jumlah pin (beberapa proses dapat melakukan ini secara bersamaan).  Selama buffer diperbaiki (nilai counter lebih besar dari nol), dianggap bahwa buffer digunakan dan kontennya tidak boleh "diubah secara radikal".  Misalnya, versi baru dari garis tersebut dapat muncul di halaman - ini tidak mengganggu siapa pun karena multi-versi dan aturan visibilitas.  Tetapi halaman lain tidak dapat dibaca ke buffer yang disematkan. <br><br><h1>  Berkerumun keluar </h1><br>  Mungkin terjadi bahwa halaman yang diperlukan tidak ditemukan dalam cache.  Dalam hal ini, itu harus dibaca dari disk ke beberapa buffer. <br><br>  Jika masih ada buffer gratis di cache, yang gratis pertama dipilih.  Tetapi cepat atau lambat mereka akan berakhir (biasanya ukuran database lebih besar dari memori yang dialokasikan untuk cache) dan kemudian Anda harus memilih salah satu buffer yang ditempati, memaksa keluar halaman di sana dan membaca yang baru di ruang kosong. <br><br>  Mekanisme preemption didasarkan pada fakta bahwa setiap kali buffer diakses, proses meningkatkan jumlah penggunaan di header buffer.  Dengan demikian, buffer yang digunakan lebih jarang daripada yang lain memiliki nilai counter yang lebih rendah dan merupakan kandidat yang baik untuk berkeliaran. <br><br>  Algoritme clock-sweep loop melalui semua buffer (menggunakan pointer ke "korban berikutnya"), mengurangi jumlah akses mereka dengan satu.  Untuk crowding out, buffer pertama dipilih, yang: <br><br><ol><li>  memiliki hit counter nol (jumlah penggunaan), </li><li>  dan tidak diperbaiki (zero pin count). </li></ol><br>  Anda dapat melihat bahwa jika semua buffer memiliki hit counter non-nol, maka algoritma harus melakukan lebih dari satu lingkaran, mengatur ulang penghitung, sampai salah satu dari mereka akhirnya pergi ke nol.  Untuk menghindari "lingkaran yang berliku" nilai maksimum hit counter dibatasi hingga 5. Tetapi tetap saja, dengan ukuran cache buffer yang besar, algoritma ini dapat menyebabkan overhead yang signifikan. <br><br>  Setelah buffer ditemukan, hal berikut terjadi padanya. <br><br>  Buffer disematkan untuk menunjukkan proses lain yang sedang digunakan.  Selain memperbaiki, cara lain untuk memblokir juga digunakan, tetapi kita akan membicarakan lebih lanjut tentang ini secara terpisah. <br><br>  Jika buffer ternyata kotor, artinya berisi data yang diubah, halaman tidak bisa dibuang begitu saja - pertama-tama perlu disimpan ke disk.  Ini bukan situasi yang baik, karena proses yang akan membaca halaman harus menunggu rekaman data "asing", tetapi efek ini diperhalus oleh pos pemeriksaan dan proses perekaman latar belakang, yang akan dibahas nanti. <br><br>  Selanjutnya, halaman baru dibaca dari disk ke buffer yang dipilih.  Penghitung jumlah panggilan diatur ke satu.  Selain itu, tautan ke halaman yang dimuat harus didaftarkan di tabel hash sehingga dapat ditemukan di masa mendatang. <br><br>  Sekarang tautan ke "korban berikutnya" menunjuk ke buffer berikutnya, dan yang baru saja dimuat punya waktu untuk meningkatkan hit counter sampai pointer melewati seluruh cache buffer dan kembali lagi. <br><br><h1>  Dengan mataku sendiri </h1><br>  Seperti kebiasaan di PostgreSQL, ada ekstensi yang memungkinkan Anda untuk melihat ke dalam cache buffer. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_buffercache;</code> </pre> <br>  Buat tabel dan masukkan satu baris ke dalamnya. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> cacheme( id <span class="hljs-type"><span class="hljs-type">integer</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (autovacuum_enabled = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cacheme <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Apa yang akan ada di cache buffer?  Minimal, sebuah halaman akan muncul di dalamnya dengan satu baris ditambahkan.  Kami akan memverifikasi ini dengan kueri berikut, di mana kami hanya memilih buffer yang termasuk dalam tabel kami (berdasarkan nomor file relfilenode), dan mendekodekan nomor layer (relforknumber): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bufferid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> relforknumber <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'fsm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'vm'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> relfork, relblocknumber, isdirty, usagecount, pinning_backends <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'cacheme'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 1 | 0 (1 row)</code> </pre><br>  Begitulah - ada satu halaman di buffer.  Itu kotor (isdirty), hit counter sama dengan satu (usagecount), dan itu tidak diperbaiki oleh proses apa pun (pinning_backends). <br><br>  Sekarang tambahkan baris lain dan ulangi kueri.  Untuk menyimpan surat, kami menyisipkan baris di sesi lain, dan ulangi permintaan panjang dengan perintah <code>\g</code> . <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cacheme <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 2 | 0 (1 row)</code> </pre><br>  Tidak ada buffer baru yang ditambahkan - baris kedua pas di halaman yang sama.  Harap perhatikan bahwa penghitung penggunaan telah meningkat. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> cacheme;</code> </pre><pre> <code class="plaintext hljs">| id | ---- | 1 | 2 | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15735 | main | 0 | t | 3 | 0 (1 row)</code> </pre><br>  Dan setelah mengakses halaman untuk membaca, penghitung juga bertambah. <br><br>  Dan jika Anda bersih? <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> cacheme;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \g</code> </pre><pre> <code class="plaintext hljs"> bufferid | relfork | relblocknumber | isdirty | usagecount | pinning_backends ----------+---------+----------------+---------+------------+------------------ 15731 | fsm | 1 | t | 1 | 0 15732 | fsm | 0 | t | 1 | 0 15733 | fsm | 2 | t | 2 | 0 15734 | vm | 0 | t | 2 | 0 15735 | main | 0 | t | 3 | 0 (5 rows)</code> </pre><br>  Pembersihan membuat peta visibilitas (satu halaman) dan peta ruang kosong (tiga halaman - ukuran minimum peta ini). <br><br>  Baik dan sebagainya. <br><br><h1>  Pengaturan ukuran </h1><br>  Ukuran cache ditetapkan oleh parameter <em>shared_buffers</em> .  Nilai standarnya adalah 128 MB.  Ini adalah salah satu parameter yang masuk akal untuk meningkat segera setelah menginstal PostgreSQL. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> setting, unit <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_settings <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'shared_buffers'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> setting | unit ---------+------ 16384 | 8kB (1 row)</code> </pre><br>  Perlu diingat bahwa mengubah parameter memerlukan restart server, karena semua memori cache yang diperlukan dialokasikan pada startup server. <br><br>  Untuk alasan apa memilih nilai yang sesuai? <br><br>  Bahkan basis data terbesar memiliki kumpulan data "panas" yang terbatas, yang dengannya pekerjaan aktif dilakukan pada setiap saat.  Idealnya, set ini harus ditempatkan dalam cache buffer (ditambah beberapa ruang untuk data "satu kali").  Jika ukuran cache lebih kecil, maka halaman yang digunakan secara aktif akan terus-menerus saling menekan, sehingga menghasilkan input-output yang berlebihan.  Tapi meningkatkan cache tanpa berpikir juga salah.  Dengan ukuran yang besar, biaya overhead untuk mempertahankannya akan meningkat, dan di samping itu, RAM juga diperlukan untuk kebutuhan lain. <br><br>  Dengan demikian, ukuran cache buffer yang optimal akan berbeda di sistem yang berbeda: itu tergantung pada data, pada aplikasi, pada beban.  Sayangnya, tidak ada makna magis yang akan cocok untuk semua orang sama baiknya. <br><br>  Rekomendasi standar adalah untuk mengambil 1/4 dari RAM sebagai perkiraan pertama (untuk Windows sebelum PostgreSQL 10 disarankan untuk memilih ukuran yang lebih kecil). <br><br>  Dan kemudian Anda perlu melihat situasinya.  Yang terbaik adalah melakukan percobaan: menambah atau mengurangi ukuran cache dan membandingkan kinerja sistem.  Tentu saja, untuk ini perlu memiliki bangku tes dan dapat mereproduksi beban khas - dalam lingkungan produksi, percobaan tersebut terlihat seperti kesenangan yang meragukan. <br><br><blockquote>  Pastikan untuk melihat laporan oleh Nikolay Samokhvalov di PgConf-2019: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendekatan Industri untuk</a> Tuning <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PostgreSQL: Eksperimen Basis Data</a> " <br></blockquote><br>  Tetapi beberapa informasi tentang apa yang terjadi dapat diperoleh secara langsung pada sistem langsung menggunakan ekstensi pg_buffercache yang sama - yang paling penting, lihat sudut kanan. <br><br>  Misalnya, Anda dapat mempelajari distribusi buffer sesuai dengan tingkat penggunaannya: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> usagecount, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> usagecount <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> usagecount;</code> </pre><pre> <code class="plaintext hljs"> usagecount | count ------------+------- 1 | 221 2 | 869 3 | 29 4 | 12 5 | 564 | 14689 (6 rows)</code> </pre><br>  Dalam hal ini, banyak nilai penghitung kosong adalah buffer gratis.  Tidak mengherankan untuk sistem di mana tidak ada yang terjadi. <br><br>  Anda dapat melihat seberapa banyak tabel mana di dalam basis data kami di-cache dan seberapa aktif data ini digunakan (dengan penggunaan aktif dalam kueri ini yang kami maksudkan buffer dengan penghitung penggunaan lebih dari 3): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> c.relname, count(*) blocks, round( <span class="hljs-number"><span class="hljs-number">100.0</span></span> * <span class="hljs-number"><span class="hljs-number">8192</span></span> * count(*) / pg_table_size(c.oid) ) "% of rel", round( <span class="hljs-number"><span class="hljs-number">100.0</span></span> * <span class="hljs-number"><span class="hljs-number">8192</span></span> * count(*) <span class="hljs-keyword"><span class="hljs-keyword">FILTER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.usagecount &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) / pg_table_size(c.oid) ) "% hot" <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache b <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class c <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pg_relation_filenode(c.oid) = b.relfilenode <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> b.reldatabase <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = current_database()) ) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> b.usagecount <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> c.relname, c.oid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relname | blocks | % of rel | % hot ---------------------------+--------+----------+------- vac | 833 | 100 | 0 pg_proc | 71 | 85 | 37 pg_depend | 57 | 98 | 19 pg_attribute | 55 | 100 | 64 vac_s | 32 | 4 | 0 pg_statistic | 27 | 71 | 63 autovac | 22 | 100 | 95 pg_depend_reference_index | 19 | 48 | 35 pg_rewrite | 17 | 23 | 8 pg_class | 16 | 100 | 100 (10 rows)</code> </pre><br>  Di sini, misalnya, dapat dilihat bahwa tabel vakum menempati sebagian besar tempat (kami menggunakannya dalam salah satu topik sebelumnya), tetapi belum ada yang membahasnya sejak lama dan belum diperas hanya karena buffer gratis belum habis. <br><br>  Anda dapat membuat bagian lain yang akan memberikan informasi yang berguna untuk dipikirkan.  Hanya perlu mempertimbangkan bahwa permintaan tersebut: <br><br><ul><li>  harus diulang beberapa kali: angkanya akan bervariasi dalam batas-batas tertentu; </li><li>  tidak perlu untuk melakukannya terus-menerus (sebagai bagian dari pemantauan) karena fakta bahwa ekstensi memblokir operasi dengan cache buffer untuk waktu yang singkat. </li></ul><br>  Dan satu hal lagi.  Kita tidak boleh lupa bahwa PostgreSQL bekerja dengan file melalui panggilan biasa ke sistem operasi dan, dengan demikian, ada caching ganda: halaman jatuh ke dalam buffer buffer DBMS dan cache OS.  Dengan demikian, "miss" dalam cache buffer tidak selalu mengarah pada kebutuhan akan I / O nyata.  Tetapi strategi crowding out OS berbeda dari strategi DBMS: sistem operasi tidak tahu apa-apa tentang makna data yang dibaca. <br><br><h1>  Pemindahan massal </h1><br>  Dalam operasi yang melakukan pembacaan massal atau penulisan data, ada bahaya dengan cepatnya memindahkan halaman berguna dari cache buffer dengan data "satu kali". <br><br>  Untuk mencegah hal ini terjadi, yang disebut <em>cincin buffer</em> digunakan untuk operasi seperti itu - sebagian kecil dari cache buffer dialokasikan untuk setiap operasi.  Ekstrusi hanya bekerja di dalam ring, sehingga data cache buffer lainnya tidak mengalami kerusakan. <br><br>  Untuk pembacaan berurutan dari tabel besar (ukuran yang melebihi seperempat dari cache buffer) dialokasikan 32 halaman.  Jika proses lain juga membutuhkan data ini saat membaca tabel, itu tidak mulai membaca tabel terlebih dahulu, tetapi terhubung ke cincin buffer yang ada.  Setelah memindai, ia membaca awal tabel yang "tidak terjawab". <br><br>  Mari kita periksa.  Untuk melakukan ini, buat tabel agar satu baris menempati seluruh halaman - lebih mudah untuk dihitung.  Ukuran cache buffer standar adalah 128 MB = 16384 halaman dengan 8 KB.  Jadi, Anda harus memasukkan lebih dari 4096 baris halaman ke dalam tabel. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> big( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, s <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (fillfactor=<span class="hljs-number"><span class="hljs-number">10</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> big(s) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'FOO'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4096</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Mari kita menganalisis tabelnya. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> big; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = <span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 4097 (1 row)</code> </pre><br>  Sekarang kita harus me-restart server untuk menghapus cache data tabel yang dibaca oleh analisis. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Setelah reboot, baca seluruh tabel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> big;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Aggregate (actual time=14.472..14.473 rows=1 loops=1) -&gt; Seq Scan on big (actual time=0.031..13.022 rows=4097 loops=1) Planning Time: 0.528 ms Execution Time: 14.590 ms (4 rows)</code> </pre><br>  Dan pastikan hanya 32 buffer ditempati oleh halaman tabular di cache buffer: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 32 (1 row)</code> </pre><br>  Jika pemindaian berurutan dilarang, tabel akan dibaca berdasarkan indeks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> big;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------- Aggregate (actual time=50.300..50.301 rows=1 loops=1) -&gt; Index Only Scan using big_pkey on big (actual time=0.098..48.547 rows=4097 loops=1) Heap Fetches: 4097 Planning Time: 0.067 ms Execution Time: 50.340 ms (5 rows)</code> </pre><br>  Dalam hal ini, cincin buffer tidak digunakan dan seluruh tabel muncul di cache buffer (dan hampir seluruh indeks juga): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br>  Dengan cara yang sama, cincin buffer digunakan untuk proses pembersihan (juga 32 halaman) dan untuk operasi penulisan massal COPY IN dan BUAT TABEL SELECT (biasanya 2048 halaman, tetapi tidak lebih dari 1/8 dari total cache buffer). <br><br><h1>  Meja sementara </h1><br>  Pengecualian untuk aturan umum adalah tabel sementara.  Karena data sementara hanya dapat dilihat oleh satu proses, mereka tidak ada hubungannya dalam cache buffer bersama.  Selain itu, data sementara hanya ada dalam satu sesi, sehingga tidak perlu dilindungi dari kegagalan. <br><br>  Untuk data sementara, cache digunakan dalam memori lokal dari proses yang memiliki tabel.  Karena data tersebut hanya tersedia untuk satu proses, itu tidak perlu dilindungi dengan kunci.  Cache lokal menggunakan algoritma preemptive yang biasa. <br><br>  Tidak seperti cache buffer umum, memori untuk cache lokal dialokasikan sesuai kebutuhan, karena tabel sementara tidak digunakan di semua sesi.  Jumlah maksimum memori untuk tabel sementara dalam satu sesi dibatasi oleh parameter <em>temp_buffers</em> . <br><br><h1>  Pemanasan cache </h1><br>  Setelah me-restart server, beberapa waktu akan berlalu sebelum cache “menghangat” - mengakumulasi data yang sebenarnya digunakan secara aktif.  Terkadang mungkin berguna untuk segera membaca data tabel tertentu ke dalam cache, dan ekstensi khusus dirancang untuk ini: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pg_prewarm;</code> </pre><br>  Sebelumnya, ekstensi hanya bisa membaca tabel tertentu di cache buffer (atau hanya di cache OS).  Tetapi dalam PostgreSQL 11, ia dapat menyimpan status cache saat ini ke disk dan mengembalikannya setelah server reboot.  Untuk memanfaatkan ini, Anda perlu menambahkan perpustakaan ke <em>shared_preload_libraries</em> dan restart server. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> shared_preload_libraries = <span class="hljs-string"><span class="hljs-string">'pg_prewarm'</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Bidang restart, jika parameter <em>pg_prewarm.autoprewarm</em> tidak berubah, proses latar belakang master autoprewarm akan dimulai secara otomatis, yang sekali dalam <em>pg_prewarm.autoprewarm_interval</em> akan membuang daftar halaman dalam cache ke disk (jangan lupa untuk memperhitungkan proses baru saat mengatur <em>max_parallel_processes</em> ). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span>, setting, unit <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_settings <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'pg_prewarm%'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> name | setting | unit ---------------------------------+---------+------ pg_prewarm.autoprewarm | on | pg_prewarm.autoprewarm_interval | 300 | s (2 rows)</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ps -o pid,command --ppid `head -n 1 /var/lib/postgresql/11/main/postmaster.pid` | grep prewarm</code> </pre><pre> <code class="plaintext hljs">10436 postgres: 11/main: autoprewarm master</code> </pre><br>  Sekarang tidak ada tabel besar dalam cache: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 0 (1 row)</code> </pre><br>  Jika kita menganggap bahwa semua isinya sangat penting, kita dapat membacanya ke dalam cache buffer dengan memanggil fungsi berikut: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_prewarm(<span class="hljs-string"><span class="hljs-string">'big'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_prewarm ------------ 4097 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br>  Daftar halaman dibuang ke file autoprewarm.blocks.  Untuk melihatnya, Anda bisa menunggu sampai proses master autoprewarm berjalan untuk pertama kali, tetapi kami secara manual memulai ini: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> autoprewarm_dump_now();</code> </pre><pre> <code class="plaintext hljs"> autoprewarm_dump_now ---------------------- 4340 (1 row)</code> </pre><br>  Jumlah halaman yang dibuang lebih dari 4097 - ini termasuk halaman objek katalog sistem yang sudah dibaca oleh server.  Dan inilah file tersebut: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l /var/lib/postgresql/11/main/autoprewarm.blocks</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 102078  29 15:51 /var/lib/postgresql/11/main/autoprewarm.blocks</code> </pre><br>  Sekarang restart server lagi. <br><br><pre> <code class="plaintext hljs">student$ sudo pg_ctlcluster 11 main restart</code> </pre><br>  Dan segera setelah peluncuran, tabel kami kembali muncul di cache. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_buffercache <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relfilenode = pg_relation_filenode(<span class="hljs-string"><span class="hljs-string">'big'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 4097 (1 row)</code> </pre><br>  Ini memberikan proses master autoprewarm yang sama: ia membaca file, membagi halaman menjadi basis data, mengurutkannya (sehingga membaca dari disk sekonsisten mungkin) dan meneruskan pekerja autoprewarm ke alur kerja individual untuk diproses. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk dilanjutkan</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458186/">https://habr.com/ru/post/id458186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458160/index.html">Kunci Prioritas di .NET</a></li>
<li><a href="../id458168/index.html">Juni Machine Learning dan Intelijen Berita Buatan Intisari</a></li>
<li><a href="../id458170/index.html">Perendaman dalam jaringan saraf convolutional. Bagian 5/10 - 18</a></li>
<li><a href="../id458176/index.html">Penghalang exaflops akan diatasi pada 2021</a></li>
<li><a href="../id458184/index.html">Haxe dan PHP: pengetikan statis, fungsi panah, metaprogramming, dan banyak lagi</a></li>
<li><a href="../id458190/index.html">Saya mengerti, itu berarti saya ada: ulasan tentang Deep Learning in Computer Vision (bagian 2)</a></li>
<li><a href="../id458202/index.html">Lihatlah SObjectizer jika Anda ingin menggunakan Aktor atau CSP dalam proyek C ++ Anda</a></li>
<li><a href="../id458204/index.html">Cara mengevaluasi kinerja penyimpanan di Linux: benchmark menggunakan alat terbuka</a></li>
<li><a href="../id458206/index.html">Sublime Text 3 untuk tata letak situs. Sesuaikan tampilan dan instal plugin. Panduan Pemula</a></li>
<li><a href="../id458208/index.html">Acara digital di Moskow dari 01 Juli hingga 07 Juli</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>