<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè° üàØÔ∏è üçü Grundlegendes zu Partitionen in PostgreSQL 9 üè§ üëå üëßüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PostgreSQL 10 wurde Anfang Oktober 2017, vor fast einem Jahr, ver√∂ffentlicht. 

 Eine der interessantesten neuen ‚ÄûFunktionen‚Äú ist die bedingungslos de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlegendes zu Partitionen in PostgreSQL 9</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/422753/"> PostgreSQL 10 wurde Anfang Oktober 2017, vor fast einem Jahr, ver√∂ffentlicht. <br><br>  Eine der interessantesten neuen ‚ÄûFunktionen‚Äú ist die bedingungslos deklarative Partitionierung.  Aber was ist, wenn Sie es nicht eilig haben, auf 10.000 zu aktualisieren?  Amazon zum Beispiel hat es nicht eilig und hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die PostgreSQL</a> 10- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unterst√ºtzung</a> erst in den letzten Tagen des Februar 2018 eingef√ºhrt. <br><br>  Dann kommt eine gute alte Partitionierung durch Vererbung zur Rettung.  Ich bin der Softwarearchitekt der Finanzabteilung eines Taxiunternehmens, daher beziehen sich alle Beispiele auf Reisen auf die eine oder andere Weise (wir lassen die Geldprobleme f√ºr ein anderes Mal). <br><br>  Seit wir 2015 mit dem Umschreiben unseres Finanzsystems begonnen haben, als ich gerade in das Unternehmen eingetreten bin, war von einer deklarativen Partitionierung keine Rede.  Bis heute wurde die unten beschriebene Technik erfolgreich eingesetzt. <br><br>  Der urspr√ºngliche Grund f√ºr das Schreiben dieses Artikels war, dass die meisten Partitionierungsbeispiele in PostgreSQL, auf die ich gesto√üen bin, sehr einfach waren.  Hier ist eine Tabelle, hier ist eine Spalte, die wir uns ansehen, und vielleicht wissen wir sogar im Voraus, welche Werte darin enthalten sind.  Es scheint, dass alles einfach ist.  Aber das wirkliche Leben nimmt seine eigenen Anpassungen vor. <br><a name="habracut"></a><br>  In unserem Fall teilen wir Tabellen in zwei Spalten auf, von denen eine Reisedaten enth√§lt.  Diesen Fall werden wir betrachten. <br><br>  Beginnen wir mit dem Aussehen unserer Tabelle: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> rides ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> bigserial <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, tenant_id <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, ride_id <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">36</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, created_at <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>, metadata jsonb <span class="hljs-comment"><span class="hljs-comment">-- Probably more columns and indexes coming here );</span></span></code> </pre> <br>  F√ºr jeden Mandanten enth√§lt die Tabelle Millionen von Zeilen pro Monat.  Gl√ºcklicherweise √ºberschneiden sich die Daten zwischen den Mietern nie, und die schwierigsten Anfragen werden innerhalb von ein oder zwei Monaten gestellt. <br><br>  F√ºr diejenigen, die sich nicht mit der Funktionsweise von PostgreSQL-Partitionen befasst haben (Gl√ºck von Oracle, hallo!), Werde ich den Prozess kurz beschreiben. <br><br>  PostgreSQL st√ºtzt sich dabei auf zwei seiner ‚ÄûFunktionen‚Äú: die F√§higkeit, Tabellen, Tabellenvererbung und √ºberpr√ºfte Bedingungen zu erben. <br><br>  Beginnen wir mit der Vererbung.  Mit dem Schl√ºsselwort INHERITS geben wir an, dass die von uns erstellte Tabelle alle Felder der geerbten Tabelle erbt.  Dadurch wird auch eine Beziehung zwischen den beiden Tabellen hergestellt: Wenn Sie eine Abfrage vom √ºbergeordneten Element durchf√ºhren, erhalten wir auch alle Daten von den untergeordneten Tabellen. <br><br>  √úberpr√ºfte Bedingungen erg√§nzen das Bild, indem sie sicherstellen, dass sich Daten nicht √ºberschneiden.  Somit kann der PostgreSQL-Optimierer einen Teil der untergeordneten Tabellen abschneiden, indem er sich auf die Daten aus der Abfrage st√ºtzt. <br><br>  Die erste Gefahr dieses Ansatzes liegt auf der Hand: Jede Anfrage muss tenant_id enthalten.  Wenn Sie sich jedoch nicht st√§ndig daran erinnern, schreiben Sie fr√ºher oder sp√§ter selbst benutzerdefiniertes SQL, in dem Sie vergessen, diese tenant_id anzugeben.  Als Ergebnis ein Scan aller Partitionen und einer nicht funktionierenden Datenbank. <br><br>  Aber zur√ºck zu dem, was wir erreichen wollen.  Auf Anwendungsebene m√∂chte ich Transparenz - wir schreiben immer in dieselbe Tabelle, und bereits die Datenbank w√§hlt aus, wo genau diese Daten abgelegt werden sollen. <br><br>  Dazu verwenden wir die folgende gespeicherte Prozedur: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> insert_row() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> partition_env <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>; partition_date TIMESTAMP; partition_name TEXT; sql TEXT; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">-- construct partition name partition_env := lower(NEW.tenant_id); partition_date := date_trunc('month', NEW.created_at AT TIME ZONE 'UTC'); partition_name := format('%s_%s_%s', TG_TABLE_NAME, partition_env, to_char(partition_date, 'YYYY_MM')); -- create partition, if necessary IF NOT EXISTS(SELECT relname FROM pg_class WHERE relname = partition_name) THEN PERFORM create_new_partition(TG_TABLE_NAME, NEW.tenant_id, partition_date, partition_name); END IF; select format('INSERT INTO %s values ($1.*)', partition_name) into sql; -- Propagate insert EXECUTE sql USING NEW; RETURN NEW; -- RETURN NULL; if no ORM END; $BODY$ LANGUAGE plpgsql;</span></span></code> </pre> <br>  Das erste, worauf Sie achten sollten, ist die Verwendung von TG_TABLE_NAME.  Da dies ein Ausl√∂ser ist, f√ºllt PostgreSQL einige Variablen f√ºr uns, auf die wir zugreifen k√∂nnen.  Die vollst√§ndige Liste finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie hier</a> . <br><br>  In unserem Fall m√∂chten wir den Namen des √ºbergeordneten Elements der Tabelle abrufen, an der der Trigger gearbeitet hat.  In unserem Fall werden es Fahrten sein.  Wir verwenden einen √§hnlichen Ansatz in mehreren Mikrodiensten, und dieser Teil kann praktisch unver√§ndert √ºbertragen werden. <br><br>  <code>PERFORM</code> ist n√ºtzlich, wenn wir eine Funktion aufrufen m√∂chten, die nichts zur√ºckgibt.  In der Regel versuchen sie in Beispielen, die gesamte Logik in einer Funktion zusammenzufassen, aber wir versuchen, vorsichtig zu sein. <br><br>  <code>USING NEW</code> gibt an, dass wir in dieser Abfrage die Werte aus der Zeichenfolge verwenden, die wir hinzuf√ºgen <code>USING NEW</code> . <br><br>  <code>$1.*</code> erweitert alle Zeilenumbruchwerte.  Tats√§chlich kann dies in <code>NEW.*</code> √ºbersetzt werden <code>NEW.*</code> .  Was bedeutet <code>NEW.ID, NEW.TENANT_ID, ‚Ä¶</code> <br><br>  Die folgende Prozedur, die wir mit <code>PERFORM</code> aufrufen, erstellt eine neue Partition, falls diese noch nicht vorhanden ist.  Dies geschieht einmal pro Periode f√ºr jeden Mieter. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> create_new_partition(parent_table_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, env <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, partition_date <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>, partition_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VOID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Notifying RAISE NOTICE 'A new % partition will be created: %', parent_table_name, partition_name; select format('CREATE TABLE IF NOT EXISTS %s (CHECK ( tenant_id = ''%s'' AND created_at AT TIME ZONE ''UTC'' &gt; ''%s'' AND created_at AT TIME ZONE ''UTC'' &lt;= ''%s'')) INHERITS (%I)', partition_name, env, partition_date, partition_date + interval '1 month', parent_table_name) into sql; -- New table, inherited from a master one EXECUTE sql; PERFORM index_partition(partition_name); END; $BODY$ LANGUAGE plpgsql;</span></span></code> </pre> <br>  Wie bereits beschrieben, verwenden wir <code>INHERITS</code> , um eine Tabelle √§hnlich der √ºbergeordneten zu erstellen, und <code>CHECK</code> , um zu bestimmen, welche Daten dorthin gelangen sollen. <br><br>  <code>RAISE NOTICE</code> druckt nur eine Zeichenfolge auf die Konsole.  Wenn wir jetzt <code>INSERT</code> von psql ausf√ºhren, k√∂nnen wir sehen, ob die Partition erstellt wurde. <br><br>  Wir haben ein neues Problem.  <code>INHERITS</code> erbt keine Indizes.  Dazu haben wir zwei L√∂sungen: <br><br>  Erstellen Sie Indizes mithilfe der Vererbung: <br>  Verwenden Sie <code>CREATE TABLE LIKE</code> und dann <code>ALTER TABLE INHERITS</code> <br><br>  Oder erstellen Sie prozedural Indizes: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> index_partition(partition_name <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VOID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Ensure we have all the necessary indices in this partition; EXECUTE 'CREATE INDEX IF NOT EXISTS ' || partition_name || '_tenant_timezone_idx ON ' || partition_name || ' (tenant_id, timezone(''UTC''::text, created_at))'; -- More indexes here... END; $BODY$ LANGUAGE plpgsql;</span></span></code> </pre> <br>  Es ist sehr wichtig, die Indizierung von untergeordneten Tabellen nicht zu vergessen, da jede von ihnen auch nach der Partitionierung Millionen von Zeilen enth√§lt.  Indizes f√ºr Eltern werden in unserem Fall nicht ben√∂tigt, da Eltern immer leer bleiben. <br><br>  Schlie√ülich erstellen wir einen Trigger, der aufgerufen wird, wenn eine neue Zeile erstellt wird: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> before_insert_row_trigger <span class="hljs-keyword"><span class="hljs-keyword">BEFORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EACH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROW</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> insert_row();</code> </pre> <br>  Es gibt noch eine andere Subtilit√§t, auf die man selten achtet.  Partitionierung ist am besten in Spalten, in denen sich die Daten nie √§ndern.  In unserem Fall funktioniert dies: Die Reise √§ndert niemals tenant_id und created_at.  Wenn dies nicht der Fall ist, wird PostreSQL keinen Teil der Daten an uns zur√ºckgeben.  Wir haben ihm dann versprochen, zu √ºberpr√ºfen, ob alle Daten g√ºltig sind. <br><br>  Es gibt verschiedene L√∂sungen (mit Ausnahme der offensichtlichen - mutieren Sie nicht die Daten, f√ºr die wir partitionieren): <br><br>  Anstelle von <code>UPDATE</code> wir auf Anwendungsebene immer <code>DELETE+INSERT</code> <br>  Wir f√ºgen einen weiteren Trigger f√ºr <code>UPDATE</code> der Daten an die richtige Partition √ºbertr√§gt <br><br>  Eine weitere erw√§genswerte Einschr√§nkung ist die korrekte Indizierung von Spalten mit Datumsangaben.  Wenn wir AT TIME ZONE in Abfragen verwenden, d√ºrfen wir nicht vergessen, dass dies tats√§chlich ein Funktionsaufruf ist.  Und das bedeutet, dass unser Index funktionsbasiert sein sollte.  Ich habe vergessen.  Infolgedessen ist die Basis von der Last wieder tot. <br><br>  Der letzte erw√§genswerte Aspekt ist, wie Partitionen mit verschiedenen ORM-Frameworks interagieren, sei es ActiveRecord in Ruby oder GORM in Go. <br><br>  Partitionen in PostgreSQL basieren auf der Tatsache, dass die √ºbergeordnete Tabelle immer leer ist.  Wenn Sie ORM nicht verwenden, k√∂nnen Sie sicher zur ersten gespeicherten Prozedur zur√ºckkehren und RETURN NEW √§ndern.  auf RETURN NULL;  Dann wird die Zeile in der √ºbergeordneten Tabelle einfach nicht hinzugef√ºgt, was genau das ist, was wir wollen. <br><br>  Tatsache ist jedoch, dass die meisten ORMs die RETURNING-Klausel mit INSERT verwenden.  Wenn wir NULL von unserem Trigger zur√ºckgeben, ger√§t der ORM in Panik und glaubt, dass die Zeile nicht hinzugef√ºgt wurde.  Es wird hinzugef√ºgt, aber nicht, wo ORM sucht. <br><br>  Es gibt verschiedene M√∂glichkeiten, dies zu umgehen: <br><br><ul><li>  Verwenden Sie ORM nicht f√ºr INSERTs </li><li>  Patch ORM (was manchmal bei ActiveRecord empfohlen wird) </li><li>  F√ºgen Sie einen weiteren Trigger hinzu, der die Zeile vom √ºbergeordneten Element entfernt. </li></ul><br>  Die letzte Option ist unerw√ºnscht, da f√ºr jede Operation drei ausgef√ºhrt werden.  Trotzdem ist es manchmal unvermeidlich, weil wir es separat betrachten werden: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> delete_parent_row() <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = NEW.ID; RETURN null; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; $BODY$ LANGUAGE plpgsql;</code> </pre> <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> after_insert_row_trigger <span class="hljs-keyword"><span class="hljs-keyword">AFTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EACH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROW</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> delete_parent_row();</code> </pre> <br>  Als letztes m√ºssen wir unsere L√∂sung testen.  Dazu generieren wir eine bestimmte Anzahl von Zeilen: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $script$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> year_start_epoch <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> := <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span>(epoch <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'20170101'</span></span>::timestamptz <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'UTC'</span></span>); delta bigint := extract(epoch from '20171231 23:59:59'::timestamptz at time zone 'UTC') - year_start_epoch; tenant varchar; tenants varchar[] := array['tenant_a', 'tenant_b', 'tenant_c', 'tenant_d']; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> FOREACH tenant <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ARRAY</span></span> tenants <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.100000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> rides (tenant_id, created_at, ride_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (tenant, to_timestamp(random() * delta + year_start_epoch) <span class="hljs-keyword"><span class="hljs-keyword">at</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-string"><span class="hljs-string">'UTC'</span></span>, i); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> $script$;</code> </pre> <br>  Und mal sehen, wie sich die Datenbank verh√§lt: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rides <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tenant_id = <span class="hljs-string"><span class="hljs-string">'tenant_a'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> created_at <span class="hljs-keyword"><span class="hljs-keyword">AT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span> ZONE <span class="hljs-string"><span class="hljs-string">'UTC'</span></span> &gt; <span class="hljs-string"><span class="hljs-string">'20171102'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> created_at <span class="hljs-keyword"><span class="hljs-keyword">AT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIME</span></span> ZONE <span class="hljs-string"><span class="hljs-string">'UTC'</span></span> &lt;= <span class="hljs-string"><span class="hljs-string">'20171103'</span></span>;</code> </pre> <br>  Wenn alles richtig gelaufen ist, sollten wir folgendes Ergebnis sehen: <br><br><pre> <code class="sql hljs"> Append (cost=0.00..4803.76 rows=4 width=196) -&gt; Seq Scan on rides (cost=0.00..4795.46 rows=3 width=196) Filter: (((created_at)::timestamp without time zone &gt; '2017-11-02 00:00:00'::timestamp without time zone) AND ((created_at)::timestamp without time zone &lt;= '2017-11-03 00:00:00'::timestamp without time zone) AND ((tenant_id)::text = 'tenant_a'::text)) -&gt; Index Scan using rides_tenant_a_2017_11_tenant_timezone_idx on rides_tenant_a_2017_11 (cost=0.28..8.30 rows=1 width=196) Index Cond: (((tenant_id)::text = 'tenant_a'::text) AND ((created_at)::timestamp without time zone &gt; '2017-11-02 00:00:00'::timestamp without time zone) AND ((created_at)::timestamp without time zone &lt;= '2017-11-03 00:00:00'::timestamp without time zone)) (5 rows)</code> </pre> <br>  Trotz der Tatsache, dass jeder Mandant Hunderttausende von Zeilen hat, w√§hlen wir nur aus dem gew√ºnschten Datenabschnitt aus.  Erfolg! <br><br>  Ich hoffe, dieser Artikel war interessant f√ºr diejenigen, die noch nicht mit der Partitionierung und ihrer Implementierung in PostgreSQL vertraut waren.  Aber diejenigen, f√ºr die dieses Thema nicht mehr neu ist, haben dennoch ein paar interessante Tricks gelernt. <br><br>  UPD: <br>  Wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">bigtrot</a> richtig beobachtet, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">funktioniert</a> all diese Stra√üenmagie nicht, wenn die Einstellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CONSTRAINT_EXCLUSION</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">deaktiviert</a> ist. <br><br>  Sie k√∂nnen dies mit dem Befehl √ºberpr√ºfen <pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">show</span></span> CONSTRAINT_EXCLUSION</code> </pre> <br><br>  Die Einstellung hat drei Werte: Ein, Aus und Partition <br><br>  Die Partitionskonfiguration ist optimaler, wenn Sie CHECK CONSTRAINTS pl√∂tzlich nicht nur f√ºr Partitionen, sondern auch zur Datennormalisierung verwenden m√∂chten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de422753/">https://habr.com/ru/post/de422753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de422739/index.html">Wind- und Solarkraftwerke in der Sahara werden dazu beitragen, das Klima in der W√ºste zu verbessern</a></li>
<li><a href="../de422743/index.html">Wie das Gehirn Zeit f√ºhlt</a></li>
<li><a href="../de422745/index.html">Stern des fesselnden Wissens</a></li>
<li><a href="../de422747/index.html">IEEE Official Strong Encryption Support Position</a></li>
<li><a href="../de422751/index.html">10 kostenlose SSL / TLS-Diagnosetools f√ºr Webmaster</a></li>
<li><a href="../de422755/index.html">Sch√ºtzt das Portfolio vor Krypto-Senkung?</a></li>
<li><a href="../de422757/index.html">Keine Politik. Wie kann man Stra√üenproteste mit einer mobilen Anwendung dauerhaft transformieren?</a></li>
<li><a href="../de422759/index.html">Interaktive Karte f√ºr eine Webanwendung in wenigen Stunden</a></li>
<li><a href="../de422761/index.html">Vier Wege von der Yandex Data Analysis School</a></li>
<li><a href="../de422763/index.html">Digitale Veranstaltungen in Moskau vom 10. bis 16. September</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>