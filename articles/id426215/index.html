<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌝 🚴🏿 🏂🏿 Pertanyaan Berbagi Kehidupan 🙃 ✌🏿 🕒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap pengembang muncul dengan pertanyaan tentang siklus hidup Aktivitas: apa itu layanan mengikat, bagaimana cara menyimpan keadaan antarmuka saat l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pertanyaan Berbagi Kehidupan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/426215/"><img src="https://habrastorage.org/webt/iq/rl/ci/iqrlcirhwliuqufp0rlca6brqfk.jpeg"><br><br><p>  Setiap pengembang muncul dengan pertanyaan tentang siklus hidup Aktivitas: apa itu layanan mengikat, bagaimana cara menyimpan keadaan antarmuka saat layar diputar, dan bagaimana Fragment berbeda dari Kegiatan. <br>  Kami di FunCorp telah mengumpulkan daftar pertanyaan tentang topik serupa, tetapi dengan nuansa tertentu.  Saya ingin membaginya dengan Anda. </p><a name="habracut"></a><br><p>  <strong>1.</strong> Semua orang tahu bahwa jika Anda membuka aktivitas kedua di atas yang pertama dan memutar layar, maka rantai panggilan siklus hidup akan terlihat seperti ini: </p><br><div class="spoiler">  <b class="spoiler_title">Kegiatan Pembukaan</b> <div class="spoiler_text"><p>  <em>FirstActivity: onPause</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onResume</em> <em><br></em>  <em>FirstActivity: onSaveInstanceState</em> <em><br></em>  <em>FirstActivity: onStop</em> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Putar</b> <div class="spoiler_text"><p>  <em>SecondActivity: onPause</em> <em><br></em>  <em>SecondActivity: onSaveInstanceState</em> <em><br></em>  <em>SecondActivity: onStop</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onRestoreInstanceState</em> <em><br></em>  <em>SecondActivity: onResume</em> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Kembali lagi</b> <div class="spoiler_text"><p>  <em>SecondActivity: onPause</em> <em><br></em>  <em>FirstActivity: onCreate</em> <em><br></em>  <em>FirstActivity: onStart</em> <em><br></em>  <em>FirstActivity: onRestoreInstanceState</em> <em><br></em>  <em>SecondActivity: onStop</em> </p></div></div><br><p>  Dan apa yang akan terjadi jika aktivitas kedua transparan? </p><br><p>  <strong>Solusi</strong> </p><br><p>  Dalam hal aktivitas top transparan, dalam hal logika, semuanya sedikit berbeda.  Justru karena transparan, setelah rotasi, perlu untuk mengembalikan konten dan aktivitas yang langsung di bawahnya.  Karenanya, urutan panggilan akan sedikit berbeda: </p><br><div class="spoiler">  <b class="spoiler_title">Kegiatan penemuan</b> <div class="spoiler_text"><p>  <em>FirstActivity: onPause</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onResume</em> </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Putar</b> <div class="spoiler_text"><p>  <em>SecondActivity: onPause</em> <em><br></em>  <em>SecondActivity: onSaveInstanceState</em> <em><br></em>  <em>SecondActivity: onStop</em> <em><br></em>  <em>SecondActivity: onCreate</em> <em><br></em>  <em>SecondActivity: onStart</em> <em><br></em>  <em>SecondActivity: onRestoreInstanceState</em> <em><br></em>  <em>SecondActivity: onResume</em> <em><br></em>  <em>FirstActivity: onSaveInstanceState</em> <em><br></em>  <em>FirstActivity: onStop</em> <em><br></em>  <em>FirstActivity: onCreate</em> <em><br></em>  <em>FirstActivity: onStart</em> <em><br></em>  <em>FirstActivity: onRestoreInstanceState</em> <em><br></em>  <em>FirstActivity: onResume</em> <em><br></em>  <em>FirstActivity: onPause</em> </p></div></div><br><p>  <strong>2.</strong> Tidak ada aplikasi yang dapat dilakukan tanpa menambahkan tampilan secara dinamis, tetapi terkadang Anda harus memindahkan tampilan yang sama di antara layar yang berbeda.  Bisakah objek yang sama ditambahkan secara bersamaan ke dua kegiatan yang berbeda?  Apa yang terjadi jika saya membuatnya dengan konteks Aplikasi dan ingin menambahkannya ke aktivitas yang berbeda secara bersamaan? </p><br><p>  <strong>Mengapa ini dibutuhkan?</strong> <br>  Ada pustaka "tidak terlalu menyenangkan" yang menyimpan logika bisnis penting di dalam tampilan khusus, dan menciptakan kembali pandangan ini dalam setiap aktivitas baru adalah keputusan yang buruk, karena  Saya ingin memiliki satu set data. </p><br><p><img src="https://habrastorage.org/webt/zs/-e/zk/zs-ezkaoyfadfd-xmrh-fhbm0pa.jpeg" width="200" height="350"><img src="https://habrastorage.org/webt/_r/yz/ie/_ryzienmkhodnc2lqx8mqiouj44.jpeg" width="200" height="350"><img src="https://habrastorage.org/webt/lz/y1/6g/lzy16g4ls7spgu9jqs8dqbpiaaa.jpeg" width="200" height="350"></p><br><p>  <strong>Solusi</strong> </p><br><p>  Tidak ada yang mencegah membuat tampilan dengan konteks Aplikasi.  Ini hanya akan menerapkan gaya default yang tidak terkait dengan aktivitas apa pun.  Anda juga dapat memindahkan tampilan ini di antara berbagai aktivitas tanpa masalah, tetapi Anda perlu memastikan bahwa itu ditambahkan hanya ke satu orangtua </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addViewInner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(View child, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, LayoutParams params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> preventRequestLayout)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (child.getParent() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"The specified child already has a parent. "</span></span> + <span class="hljs-string"><span class="hljs-string">"You must call removeView() on the child's parent first."</span></span>); } ... }</code> </pre> <br><p>  Anda dapat, misalnya, berlangganan ActivityLifecycleCallbacks, menghapus onStop (removeView) dari aktivitas saat ini, tambahkan onStart ke open berikutnya (addView). </p><br><p>  <strong>3.</strong> Fragmen dapat ditambahkan melalui tambah dan ganti.  Dan apa perbedaan antara kedua opsi ini dalam hal urutan metode siklus hidup?  Apa kelebihan masing-masing? </p><br><p>  <strong>Solusi</strong> </p><br><p>  Bahkan jika Anda menambahkan fragmen melalui ganti, ini tidak berarti bahwa itu sepenuhnya diganti.  Ini berarti bahwa pada titik ini dalam wadah tampilan akan diganti, oleh karena itu, onDestroyView akan dipanggil untuk fragmen saat ini, dan onCreateView akan dipanggil lagi ketika kembali. </p><br><br><p>  Ini cukup banyak mengubah aturan permainan.  Anda harus melepaskan semua pengontrol dan kelas yang terkait dengan UI di onDestroyView.  Penting untuk memisahkan dengan jelas penerimaan data yang dibutuhkan oleh fragmen dan pengisian tampilan (daftar, dll.), Karena mengisi dan merusak tampilan akan terjadi jauh lebih sering daripada menerima data (membaca beberapa data dari database). </p><br><p>  Ada juga nuansa dengan pemulihan negara: misalnya, onSaveInstanceState kadang-kadang muncul setelah onDestroyView.  Selain itu, harus diingat bahwa jika null masuk pada onViewStateRestored, maka ini berarti Anda tidak perlu mengembalikan apa pun, tetapi tidak mengatur ulang ke keadaan default. </p><br><p>  Jika kita berbicara tentang kenyamanan antara tambah dan ganti, maka ganti lebih hemat dalam memori jika Anda memiliki navigasi dalam (kami memiliki kedalaman navigasi pengguna dari salah satu KPI produk).  Juga jauh lebih nyaman untuk mengganti bilah alat dengan penggantian, karena di onCreateView Anda dapat memasangnya kembali.  Dari kelebihan menambahkan: lebih sedikit masalah dengan siklus hidup, ketika Anda kembali, saya tidak membuat ulang tampilan dan tidak perlu mengisi ulang apa pun. </p><br><p>  <strong>4.</strong> Terkadang Anda masih harus bekerja secara langsung dengan layanan dan bahkan dengan layanan mengikat.  Aktivitas berinteraksi dengan salah satu layanan ini (hanya satu aktivitas).  Terhubung ke layanan dan transfer data ke sana.  Saat Anda memutar layar, aktivitas kami hancur, dan kami berkewajiban untuk pulih dari layanan ini.  Tetapi jika tidak ada koneksi, maka layanan dihancurkan, dan setelah berbalik mengikat akan menjadi layanan yang sama sekali berbeda.  Bagaimana cara memastikan bahwa ketika Anda menghidupkan layanan tetap hidup? </p><br><p>  <strong>Solusi</strong> </p><br><p>  Jika Anda tahu solusi yang bagus, maka tulis di komentar.  Hanya sesuatu yang serupa yang terlintas dalam pikiran: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); ThreadsUtils.postOnUiThread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ unbindService(mConnection); } }); }</code> </pre> <br><p>  <strong>5.</strong> Baru-baru ini, kami redid navigasi di dalam aplikasi kami pada Kegiatan Tunggal (menggunakan salah satu perpustakaan yang tersedia).  Sebelumnya, setiap layar aplikasi adalah aktivitas yang terpisah, sekarang navigasi berfungsi pada fragmen.  Masalah kembali ke aktivitas di tengah tumpukan diselesaikan dengan bendera niat.  Bagaimana saya bisa kembali ke fragmen di tengah tumpukan? </p><br><p>  <strong>Solusi</strong> </p><br><p>  Ya, FragmentManager tidak memberikan solusi di luar kotak.  Cicerone melakukan sesuatu yang serupa di dalam dirinya: </p><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BackTo command)</span></span></span><span class="hljs-function"> </span></span>{ String key = command.getScreenKey(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (key == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { backToRoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = localStackCopy.indexOf(key); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = localStackCopy.size(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (index != -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; size - index; i++) { localStackCopy.pop(); } fragmentManager.popBackStack(key, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { backToUnexisting(command.getScreenKey()); } } }</code> </pre> <br><p>  <strong>6.</strong> Juga, baru-baru ini kami menyingkirkan komponen yang tidak efisien dan kompleks seperti ViewPager, karena logika berinteraksi dengannya sangat rumit, dan perilaku fragmen tidak dapat diprediksi dalam kasus-kasus tertentu.  Dalam beberapa fragmen, kami menggunakan fragmen dalam.  Apa yang terjadi ketika menggunakan fragmen di dalam elemen RecycleView? </p><br><p>  <strong>Solusi</strong> </p><br><p>  Secara umum, tidak akan ada yang salah.  Fragmen akan ditambahkan dan ditampilkan tanpa masalah.  Satu-satunya hal yang kita hadapi adalah ketidakkonsistenan dengan siklus hidupnya.  Implementasi pada ViewPager mengelola siklus hidup fragmen melalui setUserVisibleHint, dan RecycleView melakukan segala sesuatu di dahi tanpa memikirkan visibilitas aktual dan aksesibilitas fragmen. </p><br><p>  <strong>7.</strong> Semua karena alasan yang sama kami beralih dari ViewPager, kami mengalami masalah memulihkan kondisi.  Dalam kasus fragmen, ini diterapkan oleh kerangka kerja: di tempat yang tepat, kami cukup mendefinisikan ulang diSaveInstanceState dan menyimpan semua data yang diperlukan ke Bundle.  Saat Anda membuat ulang ViewPager, semua fragmen dipulihkan oleh FragmentManager dan mengembalikan statusnya.  Apa yang harus dilakukan dengan RecycleView dan ViewHolder-nya? </p><br><p>  <strong>Solusi</strong> </p><br><p>  "Anda harus menulis semuanya ke database dan membacanya setiap waktu," kata Anda.  Atau logika untuk menyimpan keadaan harus di luar, dan daftar itu hanya tampilan.  Di dunia yang ideal itu.  Tetapi dalam kasus kami, setiap elemen dari daftar adalah layar yang kompleks dengan logikanya sendiri.  Oleh karena itu, saya harus menciptakan sepeda saya dengan gaya "mari kita lakukan logika yang sama seperti pada ViewPager dan fragmen": </p><br><div class="spoiler">  <b class="spoiler_title">Adaptor</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecycleViewGalleryAdapter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecyclerView</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Adapter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GalleryItemViewHolder</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GalleryAdapter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String RV_STATE_KEY = <span class="hljs-string"><span class="hljs-string">"RV_STATE"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Bundle mSavedState; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBindViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GalleryItemViewHolder holder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (holder.isAttached()) { holder.detach(); } holder.attach(createArgs(position, getItemViewType(position))); restoreItemState(holder); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ Bundle adapterState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bundle(); saveItemsState(adapterState); bundle.putBundle(RV_STATE_KEY, adapterState); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle bundle)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bundle == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } mSavedState = bundle.getBundle(RV_STATE_KEY); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restoreItemState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GalleryItemViewHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mSavedState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { holder.restoreState(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } String stateKey = String.valueOf(holder.getGalleryItemId()); Bundle state = mSavedState.getBundle(stateKey); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { holder.restoreState(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); mSavedState = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } holder.restoreState(state); mSavedState.remove(stateKey); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveItemsState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle outState)</span></span></span><span class="hljs-function"> </span></span>{ GalleryItemHolder holder = getCurrentGalleryViewItem(); saveItemState(outState, (GalleryItemViewHolder) holder); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveItemState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle bundle, GalleryItemViewHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ Bundle itemState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bundle(); holder.saveState(itemState); bundle.putBundle(String.valueOf(holder.getGalleryItemId()), itemState); } }</code> </pre> </div></div><br><p>  Di Fragment.onSaveInstanceState kita membaca status pemegang yang kita butuhkan dan memasukkannya ke dalam Bundle.  Saat membuat kembali pemegang, kami mendapatkan Bundel yang disimpan dan di onBindViewHolder kami melewati negara yang ditemukan di dalam pemegang: </p><br><p>  <strong>8. Dengan</strong> apa ini mengancam kita? </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity); ViewGroup root = findViewById(R.id.default_id); ViewGroup view1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinearLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); view1.setId(R.id.default_id); root.addView(view1); ViewGroup view2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); view2.setId(R.id.default_id); view1.addView(view2); ViewGroup view3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RelativeLayout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); view3.setId(R.id.default_id); view2.addView(view3); }</code> </pre> <br><p>  <strong>Solusi</strong> </p><br><p>  Padahal, tidak ada yang salah dengan itu.  Dalam RecycleView yang sama, daftar elemen dengan id yang sama disimpan.  Namun, masih ada sedikit nuansa: </p><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> &lt;T extends View&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findViewTraversal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@IdRes </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == mID) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> View[] where = mChildren; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = mChildrenCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { View v = where[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { v = v.findViewById(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) v; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br><p>  Harus hati-hati jika kita memiliki elemen dengan id yang sama dalam hierarki, karena  itu selalu elemen pertama yang ditemukan yang selalu dikembalikan, dan pada tingkat yang berbeda dari panggilan findViewById itu bisa menjadi objek yang berbeda. </p><br><p>  <strong>9.</strong> Anda jatuh dari TooLargeTransaction ketika Anda memutar layar (ya, di sini ViewPager kita masih secara tidak langsung harus disalahkan).  Bagaimana cara menemukan pelakunya? </p><br><p>  <strong>Solusi</strong> </p><br><p>  Ini cukup sederhana: menggantung ActivityLifecycleCallbacks pada Aplikasi, menangkap semua diActivitySaveInstanceState dan parsing semua yang ada di dalam Bundle.  Di sana Anda bisa mendapatkan status semua tampilan dan semua fragmen di dalam aktivitas ini. </p><br><p>  Di bawah ini adalah contoh bagaimana kita mendapatkan status fragmen dari Bundle: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Tries to find saved [FragmentState] in bundle using 'android:support:fragments' key. */</span></span> fun Bundle.getFragmentsStateList(): List&lt;FragmentBundle&gt;? { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { val fragmentManagerState: FragmentManagerState? = getParcelable(<span class="hljs-string"><span class="hljs-string">"android:support:fragments"</span></span>) val active = fragmentManagerState?.mActive ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> emptyList() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> active.filter { it.mSavedFragmentState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }.map { fragmentState -&gt; FragmentBundle(fragmentState.mClassName, fragmentState.mSavedFragmentState) } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (throwable: Throwable) { Assert.fail(throwable) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } } <span class="hljs-function"><span class="hljs-function">fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ application.registerActivityLifecycleCallbacks(object : SimpleActivityLifecycleCallback() { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivitySaveInstanceState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: Activity, outState: Bundle?)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onActivitySaveInstanceState(activity, outState) outState?.let { ThreadsUtils.runOnMainThread { trackActivitySaveState(activity, outState) } } } }) } <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trackActivitySaveState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity: Activity, outState: Bundle)</span></span></span><span class="hljs-function"> </span></span>{ val sizeInBytes = outState.getSizeInBytes() val fragmentsInfos = outState.getFragmentsStateList() ?.map { mapFragmentsSaveInstanceSaveInfo(it) } ... }</code> </pre> <br><p>  Selanjutnya, kami cukup menghitung ukuran Bundel dan mencatatnya: </p><br><pre> <code class="java hljs"> fun Bundle.getSizeInBytes(): Int { val parcel = Parcel.obtain() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { parcel.writeValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) parcel.dataSize() } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { parcel.recycle() } }</code> </pre><br><p>  <strong>10.</strong> Misalkan kita memiliki aktivitas dan serangkaian dependensi padanya.  Dalam kondisi tertentu, kami perlu membuat ulang satu set dependensi ini (misalnya, dengan mengklik percobaan tertentu dengan UI lain).  Bagaimana kita menerapkan ini? </p><br><p>  <strong>Solusi</strong> </p><br><p>  Tentu saja, Anda dapat mengotak-atik bendera dan menjadikannya semacam aktivitas "kruk" memulai kembali melalui peluncuran niat.  Tetapi pada kenyataannya, semuanya sangat sederhana - aktivitas memiliki metode buat ulang. </p><br><p>  Kemungkinan besar, sebagian besar pengetahuan ini tidak akan berguna bagi Anda, karena Anda tidak datang kepada mereka masing-masing dari kehidupan yang baik.  Namun, beberapa dari mereka menunjukkan dengan baik bagaimana seseorang tahu bagaimana bernalar dan mengusulkan solusi.  Kami menggunakan pertanyaan serupa dalam wawancara.  Jika Anda memiliki tugas menarik yang diminta untuk Anda selesaikan di wawancara, atau Anda atur sendiri, tulis dalam komentar - akan menarik untuk dibahas! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426215/">https://habr.com/ru/post/id426215/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426205/index.html">Dengan rilis Chrome 70 ribu situs yang dilindungi oleh sertifikat Symantec akan menjadi tidak dipercaya</a></li>
<li><a href="../id426207/index.html">Ini akan segera menjadi dingin: kenali Pekatherm dan pilih sarung tangan yang dipanaskan</a></li>
<li><a href="../id426209/index.html">PeerTube 1.0: hosting video tanpa pusat data dan biaya modal</a></li>
<li><a href="../id426211/index.html">Pergi vs Javascript. Cara menulis proyek IoT</a></li>
<li><a href="../id426213/index.html">Sekelompok karyawan pompa bensin ditahan, yang, menggunakan perangkat lunak dan elektronik, dikoreksi dan diorganisasi 5% dengan tidak mengisi di pompa bensin</a></li>
<li><a href="../id426217/index.html">Bagaimana keamanan sistem operasi Windows Anda diatur?</a></li>
<li><a href="../id426223/index.html">Pengembangan Android dan memecahkan masalah pengembangan</a></li>
<li><a href="../id426227/index.html">Cara "bertani" Kaggle</a></li>
<li><a href="../id426229/index.html">Kode Etik: Mengapa Pengembang Kernel Linux Diancam Menghapus Kode Mereka - Memahami Konflik</a></li>
<li><a href="../id426231/index.html">Inggris ingin mengatur Internet - apa yang akan mempengaruhi undang-undang baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>