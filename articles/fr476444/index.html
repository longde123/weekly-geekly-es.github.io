<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏽‍🤝‍🧑🏽 📤 👧🏿 Démystification des principes de l'informatique quantique 👩🏿‍💻 🔇 🤹🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="«Je pense que je peux dire sans risque que personne ne comprend la mécanique quantique», Richard Feynman 

 Le sujet de l'informatique quantique a tou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Démystification des principes de l'informatique quantique</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/476444/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/7de/0de/1cc7de0de64ab4691f4d12f2b54a51ab.png" width="400"></div><br>  «Je pense que je peux dire sans risque que personne ne comprend la mécanique quantique», Richard Feynman <br><br>  Le sujet de l'informatique quantique a toujours attiré les rédacteurs techniques et les journalistes.  Son potentiel informatique et sa complexité lui ont donné une sorte de halo mystique.  Trop souvent, les articles thématiques et les infographies décrivent en détail toutes sortes de perspectives pour cette industrie, tout en abordant à peine les questions de son application pratique: cela peut induire en erreur un lecteur pas trop prudent. <br><a name="habracut"></a><br>  Dans les articles de vulgarisation scientifique, les descriptions des systèmes quantiques sont omises et les déclarations comme: <br><br>  <i>Un bit régulier peut être égal à "1" ou "0", mais un qubit peut être simultanément égal à "1" et "0".</i> <br><br>  Si vous êtes très chanceux (dont je ne suis pas sûr), ils vous diront que: <br><br>  <i>Le qubit est en superposition entre "1" et "0".</i> <br><br>  Aucune de ces explications ne semble plausible, car nous essayons de formuler un phénomène de mécanique quantique à l'aide d'outils langagiers créés dans un monde très traditionnel.  Pour expliquer clairement les principes de l'informatique quantique, il est nécessaire d'utiliser un autre langage - mathématique. <br><br>  Dans ce guide, je parlerai des outils mathématiques nécessaires pour modéliser et comprendre les systèmes informatiques quantiques, et comment illustrer et appliquer la logique de l'informatique quantique.  De plus, je vais donner un exemple d'algorithme quantique et dire quel est son avantage par rapport à un ordinateur traditionnel. <br><br>  Je ferai de mon mieux pour parler de tout cela dans un langage compréhensible, mais j'espère que les lecteurs de cet article auront des idées de base sur l'algèbre linéaire et la logique numérique (l'algèbre linéaire est décrite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , la logique numérique est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ). <br><br>  Pour commencer, passons en revue les principes de la logique numérique.  Il est basé sur l'utilisation de circuits électriques pour les calculs.  Pour rendre notre description plus abstraite, nous simplifions l'état du fil à «1» ou «0», ce qui correspondra aux états «on» ou «off».  Après avoir construit des transistors dans une certaine séquence, nous allons créer les soi-disant éléments logiques qui prennent une ou plusieurs valeurs des signaux d'entrée et les convertissent en un signal de sortie basé sur certaines règles de la logique booléenne. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/872/e40/4ec872e405490899e02ed8c8c9923055.png"></div><br><h2>  Éléments logiques communs et tables d'état </h2><br>  Sur la base de chaînes de ces éléments de base, vous pouvez créer des éléments plus complexes, et sur la base de chaînes d'éléments plus complexes, nous pouvons en fin de compte compter sur l'obtention d'un analogue du processeur central avec un haut degré d'abstraction. <br><br>  Comme je l'ai mentionné plus tôt, nous avons besoin d'un moyen de cartographier mathématiquement la logique numérique.  Tout d'abord, introduisons la logique mathématique traditionnelle.  En utilisant l'algèbre linéaire, les bits classiques avec les valeurs "1" et "0" peuvent être représentés comme deux vecteurs de colonne: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9c/434/3df/c9c4343df6118928be1a7bca294bbf9b.png" width="200"></div><br>  où les nombres à gauche sont la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">notation</a> vectorielle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Dirac</a> .  En représentant nos bits de cette manière, nous pouvons modéliser des opérations logiques sur des bits en utilisant des transformations vectorielles.  Remarque: malgré le fait que lorsque vous utilisez deux bits dans des éléments logiques, vous pouvez effectuer de nombreuses opérations («ET» (ET), «Non» (NON), «Exclure ou» (XOR), etc.), lorsque vous en utilisez un bits il est possible d'effectuer seulement quatre opérations: conversion d'identité, négation, calcul de la constante "0" et calcul de la constante "1".  Pendant la conversion identique, le bit reste inchangé, lorsqu'il est inversé, la valeur du bit est inversée (de "0" à "1" ou de "1" à "0"), et le calcul de la constante "1" ou "0" met le bit à "1" ou "0" quelle que soit sa valeur précédente. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a8/8bd/c76/7a88bdc760e2f03ffd3da0030335445c.png" width="400"></div><br><div class="scrollable-table"><table><tbody><tr><td>  Identité <br></td><td>  Transformation d'identité <br></td></tr><tr><td>  La négation <br></td><td>  Déni <br></td></tr><tr><td>  Constante-0 <br></td><td>  Calcul de la constante "0" <br></td></tr><tr><td>  Constante-1 <br></td><td>  Calcul de la constante "1" <br></td></tr></tbody></table></div><br>  Sur la base de notre nouvelle représentation d'un bit, il est assez facile d'effectuer des opérations sur le bit correspondant en utilisant la transformation vectorielle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3f/6f4/92d/a3f6f492dc62d70852f3be02a1323a69.png" width="400"></div><br><br>  Avant de poursuivre, examinons le concept de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">informatique réversible</a> , qui implique simplement que pour assurer la réversibilité d'une opération ou d'un élément logique, vous devez définir une liste de valeurs de signaux d'entrée en fonction des signaux de sortie et des noms des opérations utilisées.  Ainsi, nous pouvons conclure que la transformation d'identité et la négation sont réversibles, mais l'opération de calcul des constantes «1» et «0» ne l'est pas.  En raison de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">uniformité de</a> la mécanique quantique, les ordinateurs quantiques utilisent exclusivement des opérations réversibles, c'est pourquoi nous nous concentrerons sur elles.  Ensuite, nous convertirons les éléments irréversibles en éléments réversibles pour nous assurer qu'ils peuvent être utilisés par un ordinateur quantique. <br><br>  En utilisant le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">produit tensoriel de</a> bits individuels, de nombreux bits peuvent être représentés: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/07e/a5f/21c07ea5f6329faf6214fcff5fbbcc5e.png" width="400"></div><br>  Maintenant que nous avons presque tous les concepts mathématiques nécessaires, nous allons passer à notre premier élément de logique quantique.  Il s'agit de l'opérateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CNOT</a> , ou du «NOT» (NOT) contrôlé, qui est d'une grande importance dans l'informatique réversible et quantique.  L'élément CNOT est appliqué à deux bits et renvoie deux bits.  Le premier bit est affecté comme «contrôle», et le second - «contrôle».  Si le bit de commande est mis à "1", le bit de commande change sa valeur;  si le bit de commande est mis à "0", le bit de commande ne change pas. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2e/55a/f27/f2e55af2760a72e7389a1ce0777cc216.png"></div><br>  Cet opérateur peut être représenté comme le vecteur de transformation suivant: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/c12/c0a/c18c12c0a3d170ae5d6cc02726f9e24a.png"></div><br>  Pour démontrer tout ce que nous avons déjà traité, je vais vous montrer comment utiliser l'élément CNOT par rapport à plusieurs bits: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdb/1f0/ef0/bdb1f0ef078a62a045af5a3432ff5eaa.png"></div><br>  Nous résumons ce qui a déjà été dit: dans le premier exemple, nous décomposons | 10⟩ en parties de son produit tensoriel et utilisons la matrice CNOT pour obtenir un nouvel état correspondant du produit;  puis nous la factorisons à | 11⟩ selon le tableau des valeurs CNOT donné précédemment. <br><br>  Ainsi, nous nous sommes souvenus de toutes les règles mathématiques qui nous aideront à gérer les calculs traditionnels et les bits ordinaires, et enfin nous pouvons passer à l'informatique quantique et aux qubits modernes. <br><br>  Si vous lisez jusqu'à cet endroit, alors j'ai une bonne nouvelle pour vous: les qubits peuvent facilement être exprimés mathématiquement.  En général, si le bit classique (cbit) peut être réglé sur | 1⟩ ou | 0⟩, le qubit est simplement en superposition et peut être égal à | 0⟩ et | 1⟩ avant la mesure.  Après la mesure, il s'effondre à | 0⟩ ou | 1⟩.  En d'autres termes, un qubit peut être représenté comme une combinaison linéaire de | 0⟩ et | 1⟩ conformément à la formule ci-dessous: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd7/ec8/e2e/fd7ec8e2e1b3dd8167d584664a4bfa90.png" width="200"></div><br>  où <i>a₀</i> et <i>a₁</i> représentent respectivement les amplitudes | 0⟩ et | 1⟩.  Ils peuvent être considérés comme des «probabilités quantiques», qui représentent la probabilité qu'un qubit s'effondre dans l'un des états après sa mesure, car en mécanique quantique un objet en superposition s'effondre dans l'un des états après fixation.  Développez cette expression et obtenez ce qui suit: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c80/3ae/a51/c803aea51e4c1afa3d1fb2120f02333b.png" width="200"></div><br>  Pour simplifier mon explication, je vais utiliser cette notion même dans cet article. <br><br>  Pour ce qubit, la probabilité d'effondrement à <i>a₀</i> après la mesure est |  <i>a</i> ₀ | ², et le risque d'effondrement en <i>a</i> ₁ est égal à |  <i>un</i> ₁ | ².  Par exemple, pour le qubit suivant: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/d62/80d/b1ad6280d3eb193391b69bcd43fa28c7.png" width="200"></div><br>  le risque d'effondrement dans "1" est | 1 / √2 | ², ou ½, c'est-à-dire 50/50. <br><br>  Puisque dans le système classique, toutes les probabilités de la somme doivent donner l'unité (pour une distribution de probabilité complète), nous pouvons conclure que les carrés des valeurs absolues des amplitudes | 0⟩ et | 1⟩ doivent totaliser un.  Sur la base de ces informations, nous pouvons composer l'équation suivante: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74e/96b/6aa/74e96b6aa455eaab9c77562b3286648b.png"></div><br>  Si vous connaissez la trigonométrie, vous remarquerez que cette équation correspond au théorème de Pythagore (a² + b² = c²), c'est-à-dire que nous pouvons représenter graphiquement les états possibles du qubit sous forme de points sur le cercle unitaire, à savoir: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/792/666/ef3/792666ef38e24cb8ce453e802f2fac6e.png" width="400"></div><br>  Les opérateurs et éléments logiques sont appliqués aux qubits ainsi que dans le cas des bits classiques - basés sur la transformation matricielle.  Tous les opérateurs matriciels réversibles dont nous nous sommes souvenus jusqu'à présent, en particulier CNOT, peuvent être utilisés pour travailler avec des qubits.  De tels opérateurs matriciels permettent d'utiliser chacune des amplitudes d'un qubit sans le mesurer ni le réduire.  Permettez-moi de vous donner un exemple d'utilisation de l'opérateur de négation pour qubit: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/8f9/17b/fa48f917b87b850ee63c2d85abc95a83.png"></div><br>  Avant de continuer, je rappelle que les amplitudes <i>a</i> ₀ et <i>a</i> ₁ sont en fait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des nombres complexes</a> , de sorte que l'état qubit peut être affiché le plus précisément possible sur une sphère unitaire tridimensionnelle, également connue sous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le</a> nom de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sphère Bloch</a> : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12c/e7e/1b4/12ce7e1b4211732a27bcf4b9b45d1be4.png" width="400"></div><br>  Cependant, pour simplifier l'explication, nous nous limitons ici aux nombres réels. <br><br>  Il semble que le moment soit venu de discuter de certains éléments logiques qui ont un sens exclusivement dans le contexte de l'informatique quantique. <br><br>  L'un des opérateurs les plus importants est «l'élément Hadamard»: il prend un peu à l'état «0» ou «1» et le place dans la superposition correspondante avec 50% de chances de le réduire à «1» ou «0» après la mesure. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/587/3c7/11c/5873c711c538223c223588bb2767b080.png" width="400"></div><br>  Notez qu'il y a un nombre négatif dans le coin inférieur droit de l'opérateur Hadamard.  Cela est dû au fait que le résultat de l'utilisation de l'opérateur dépend de la valeur du signal d'entrée: - | 1⟩ ou | 0⟩, et donc le calcul est réversible. <br><br>  Un autre point important lié à l'élément Hadamard est sa réversibilité, c'est-à-dire qu'il peut prendre un qubit dans la superposition correspondante et le convertir en | 0⟩ ou | 1⟩. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/803/8e1/e67/8038e1e6747112de2a6f516e42932c5d.png" width="400"></div><br>  Ceci est très important car il nous permet de passer d'un état quantique sans déterminer l'état du qubit - et, par conséquent, sans l'effondrer.  Ainsi, nous pouvons structurer l'informatique quantique sur la base d'un principe déterministe plutôt que probabiliste. <br><br>  Les opérateurs quantiques contenant exclusivement des nombres réels sont l'opposé, nous pouvons donc présenter le résultat de l'application de l'opérateur à un qubit comme une transformation dans le cercle unitaire sous la forme d'une machine à états: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/505/c91/b24/505c91b2434b2d73e8738fbd31545718.png" width="400"></div><br>  Ainsi, le qubit, dont l'état est illustré dans le diagramme ci-dessus, après application de l'opération Hadamard, est converti dans l'état indiqué par la flèche correspondante.  De même, nous pouvons construire une autre machine à états qui illustrera la transformation d'un qubit en utilisant l'opérateur de négation, comme indiqué ci-dessus (également connu sous le nom d'opérateur de négation de Pauli, ou inversion de bits), comme indiqué ci-dessous: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/854/3d9/b1b/8543d9b1bf8a155b7a8945d814edfc00.png" width="400"></div><br>  Pour effectuer des opérations plus complexes avec notre qubit, vous pouvez utiliser une chaîne de nombreux opérateurs ou appliquer des éléments plusieurs fois.  Voici un exemple de transformation sérielle basée sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">représentation d'une chaîne quantique</a> : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/134/ef3/1cb/134ef31cb001fc1c9ff3c3854d32838b.png"></div><br>  Autrement dit, si nous commençons par le bit | 0⟩, appliquons l'inversion de bit, puis l'opération Hadamard, puis une autre inversion de bit, et à nouveau l'opération Hadamard, après quoi l'inversion de bit finale, nous obtenons le vecteur sur le côté droit de la chaîne.  En superposant plusieurs machines à états les unes sur les autres, nous pouvons commencer avec | 0⟩ et suivre les flèches colorées correspondant à chacune des transformations afin de comprendre comment tout cela fonctionne. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/d18/c3f/ad5d18c3f9158b0e90d72403ad04564e.png" width="400"></div><br>  Puisque nous sommes allés aussi loin, il est temps de considérer l'un des types d'algorithmes quantiques, à savoir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme Deutsch-Joji</a> , et de montrer son avantage sur un ordinateur classique.  Il convient de noter que l'algorithme Deutsch-Yogi est complètement déterministe, c'est-à-dire qu'il renvoie la bonne réponse dans 100% des cas (contrairement à de nombreux autres algorithmes quantiques basés sur la détermination probabiliste des qubits). <br><br>  Imaginons que vous ayez une boîte noire qui contient une fonction / opérateur sur un bit (rappelez-vous - lorsque vous utilisez un bit, seules quatre opérations sont possibles: transformer à l'identique, nier, calculer la constante "0" et calculer la constante "1").  Quelle fonction est exécutée dans une boîte?  Vous ne savez pas laquelle, cependant, vous pouvez trier autant de variantes de valeurs d'entrée que vous le souhaitez et évaluer les résultats à la sortie. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c5e/f24/938/c5ef249384466b29fb07ea99b2c1b000.png"></div><br>  Combien de signaux d'entrée et de sortie devront être pilotés à travers la boîte noire pour savoir quelle fonction est utilisée?  Pensez-y une seconde. <br><br>  Dans le cas d'un ordinateur classique, vous devrez effectuer 2 requêtes pour déterminer la fonction utilisée.  Par exemple, si lorsque vous entrez "1" nous obtenons "0" à la sortie, il devient clair que soit la fonction de calcul de la constante "0" soit la fonction de négation est utilisée, après quoi vous devrez changer la valeur du signal d'entrée à "0" et voir ce qui se passe à la sortie. <br><br>  Dans le cas d'un ordinateur quantique, vous aurez également besoin de deux requêtes, car vous avez toujours besoin de deux valeurs de sortie différentes pour déterminer la fonction exacte qui s'applique à la valeur d'entrée.  Cependant, si nous reformulons un peu la question, il s'avère que les ordinateurs quantiques ont toujours un sérieux avantage: si vous vouliez savoir si la fonction utilisée est constante ou variable, la supériorité serait du côté des ordinateurs quantiques. <br><br>  La fonction utilisée dans la boîte est une variable, si différentes valeurs du signal d'entrée donnent des résultats différents sur la sortie (par exemple, conversion et inversion identiques d'un bit), et si la valeur de sortie ne change pas quelle que soit la valeur d'entrée, la fonction est constante (par exemple, le calcul de la constante «1» ou le calcul de la constante «0»). <br><br>  En utilisant l'algorithme quantique, vous pouvez déterminer si une fonction dans une boîte noire est constante ou variable sur la base d'une seule demande.  Mais avant d'examiner en détail comment procéder, nous devons trouver un moyen qui nous permettra de structurer chacune de ces fonctions sur un ordinateur quantique.  Comme tout opérateur quantique doit être inversible, nous rencontrons immédiatement un problème: les fonctions de calcul des constantes «1» et «0» ne le sont pas. <br><br>  En informatique quantique, la solution suivante est souvent utilisée: un qubit de sortie supplémentaire est ajouté, qui renvoie toute valeur du signal d'entrée reçu par la fonction. <br><div class="scrollable-table"><table><tbody><tr><td>  À: <br></td><td>  Après: <br></td></tr><tr><td><img src="https://habrastorage.org/webt/xi/kq/k3/xikqk3njz-k-xetlo8efjhjsggk.png"><br></td><td><img src="https://habrastorage.org/webt/lj/rq/f9/ljrqf955o6xtubsf9mrrvridfko.png"><br></td></tr></tbody></table></div>  Ainsi, nous pouvons déterminer les valeurs d'entrée uniquement sur la base de la valeur obtenue à la sortie, et la fonction devient inversible.  La structure des circuits quantiques crée le besoin d'un bit d'entrée supplémentaire.  Pour développer les opérateurs correspondants, nous supposons que le qubit d'entrée supplémentaire est défini sur | 0⟩. <br><br>  En appliquant la même représentation de la chaîne quantique que nous avons utilisée précédemment, nous verrons comment chacun des quatre éléments (transformation d'identité, négation, calcul de la constante "0" et calcul de la constante "1") peut être mis en œuvre à l'aide d'opérateurs quantiques. <br><br>  Par exemple, vous pouvez implémenter la fonction de calcul de la constante "0": <br><br>  <b>Calcul de la constante "0":</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/395/b09/e52/395b09e5258ce87f8f9a873d573853c2.png"></div><br>  Ici, nous n'avons absolument pas besoin d'opérateurs.  Le premier qubit d'entrée (que nous avons pris égal à | 0⟩) ​​revient avec la même valeur, et la deuxième valeur d'entrée se retourne - comme d'habitude. <br><br>  Avec la fonction de calcul de la constante «1», la situation est légèrement différente: <br><br>  <b>Calcul de la constante "1":</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbe/82d/51e/fbe82d51e97a2c5cc8d7b4d5446555c8.png"></div><br>  Puisque nous avons accepté que le premier qubit d'entrée soit toujours réglé sur | 0⟩, suite à l'application de l'opérateur d'inversion de bits, il en donne toujours un à la sortie.  Et comme d'habitude, le deuxième qubit donne sa propre valeur en sortie. <br><br>  Lorsque l'opérateur de transformation d'identité s'affiche, la tâche commence à devenir plus compliquée.  Voici comment procéder: <br><br>  <b>Transformation d'identité:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bc/a2c/0c9/3bca2c0c97de2080ae979084924569a6.png"></div><br>  Le symbole utilisé ici désigne l'élément CNOT: la ligne supérieure indique le bit de commande et la ligne inférieure indique le bit de commande.  Permettez-moi de vous rappeler que lorsque vous utilisez l'opérateur CNOT, la valeur du bit de contrôle change si le bit de contrôle est | 1⟩, mais reste inchangée si le bit de contrôle est | 0⟩.  Puisque nous avons supposé que la valeur de la ligne supérieure est toujours égale à | 0⟩, sa valeur est toujours affectée à la ligne inférieure. <br><br>  De même, nous agissons avec l'opérateur de négation: <br><br>  <b>Refus:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e0/9ea/05e/3e09ea05eb3aa4509360adb50250a57d.png" width="400"></div><br>  Nous inversons simplement le bit à la fin de la ligne de sortie. <br><br>  Maintenant que nous avons compris la présentation préliminaire, regardons les avantages spécifiques d'un ordinateur quantique par rapport à un ordinateur traditionnel lorsqu'il s'agit de déterminer la constance ou la variabilité d'une fonction cachée dans une boîte noire en utilisant une seule requête. <br><br>  Pour résoudre ce problème en utilisant l'informatique quantique dans une seule demande, il est nécessaire de traduire les qubits d'entrée en superposition avant de les transférer dans la fonction, comme indiqué ci-dessous: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e76/ed6/9ca/e76ed69ca877e88a0cc269a5a3a27770.png"></div><br>  L'élément Hadamard est réappliqué au résultat de l'utilisation de la fonction pour dériver des qubits de la superposition et rendre l'algorithme déterministe.  On démarre le système dans l'état | 00⟩ et pour les raisons dont je vais parler maintenant, on obtient le résultat | 11⟩ si la fonction utilisée est constante.  Si la fonction à l'intérieur de la boîte noire est variable, le système retourne le résultat | 01⟩ après la mesure. <br><br>  Pour traiter le reste de l'article, passons à l'illustration que j'ai montrée précédemment: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad5/d18/c3f/ad5d18c3f9158b0e90d72403ad04564e.png" width="400"></div><br>  En utilisant l'opérateur d'inversion de bits, puis en appliquant l'élément Hadamard aux deux valeurs d'entrée égales à | 0⟩, nous assurerons leur traduction dans la même superposition | 0 | et | 1⟩, à savoir: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a0/f37/764/6a0f37764e197dc76be36173f72b2f7a.png" width="400"></div><br>  En utilisant l'exemple du transfert de cette valeur d'une fonction dans une boîte noire, il est facile de démontrer que les deux fonctions d'une valeur constante donnent | 11⟩ à la sortie. <br><br>  <b>Calcul de la constante "0":</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/959/675/2ca/9596752cadbc0194e1883322fed9ba2d.png" width="400"></div><br> ,  ,     «1»     |11⟩,  : <br><br> <b>  «1»:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/628/2d3/bd76282d39512c75f15d30cbc18ade2a.png" width="400"></div><br>  :       |1⟩,  -1² = 1. <br><br>      ,             |01⟩ (    ),     . <br><br> <b> :</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/771/51d/245/77151d245aa16fa8f8832ef4a4026576.png" width="400"></div><br>  CNOT   ,        ,                   CNOT    : <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/c25/1ee/d11c251ee0068742d7004e5fe2fe0fe8.png"></div><br>             |01⟩,       : <br><br> <b>:</b> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29b/9a3/120/29b9a31201cd3ce106480ba82f40970e.png" width="400"></div><br>  ,     ,       ,    . <br><br><h2>   ? </h2><br>    .     .    ,    , ,           ,   ,            . <br><br>            — , ,       ,      -     (,       !).        — ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> ,    |0⟩  |1⟩          . <br><br>           , <i></i>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«   » (An Introduction to Quantum Algorithms)</a>  :     ,         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr476444/">https://habr.com/ru/post/fr476444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr476428/index.html">Statistiques Nginx VTS, Mockify - Comparaison de l'API fictive, de Wiremock et de Mockify</a></li>
<li><a href="../fr476430/index.html">Comment créer le portefeuille technique parfait</a></li>
<li><a href="../fr476434/index.html">Nous écrivons des pilotes USB pour les appareils abandonnés</a></li>
<li><a href="../fr476436/index.html">Rapports de la première réunion en Russie des développeurs de robots sur Robot Operating System</a></li>
<li><a href="../fr476442/index.html">Donnez de l'espace ou un microcontrôleur comme un fréquencemètre</a></li>
<li><a href="../fr476446/index.html">Plugins Jira: quelques exemples de l'invention réussie du vélo</a></li>
<li><a href="../fr476448/index.html">Exploration du shader de sable du jeu Journey</a></li>
<li><a href="../fr476450/index.html">Présentation de cPanel - une console Web pour la gestion des sites et l'hébergement</a></li>
<li><a href="../fr476452/index.html">Stockage de valeur-clé ou comment nos applications sont devenues plus pratiques</a></li>
<li><a href="../fr476454/index.html">La 5G arrive: quelles entreprises assureront l'introduction de nouvelles technologies en 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>