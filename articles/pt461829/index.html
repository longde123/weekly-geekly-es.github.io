<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåßÔ∏è ü§∑üèº üé® TCP vs UDP ou o futuro dos protocolos de rede ‚ôâÔ∏è üë´ üîñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antes de cada servi√ßo gerar pelo menos 1 Mb / s de tr√°fego na Internet, surge a pergunta: ‚ÄúComo? sobre TCP ou sobre UDP? " Nas √°reas de aplica√ß√£o, inc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TCP vs UDP ou o futuro dos protocolos de rede</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461829/">  Antes de cada servi√ßo gerar pelo menos 1 Mb / s de tr√°fego na Internet, surge a pergunta: ‚ÄúComo?  sobre TCP ou sobre UDP? "  Nas √°reas de aplica√ß√£o, incluindo plataformas de entrega, as prefer√™ncias e tradi√ß√µes de tomar essas decis√µes j√° foram desenvolvidas. <br><br>  Em teoria, se, por exemplo, uma vez que um desenvolvedor pregui√ßoso n√£o tentasse implantar seu ML em Python (porque ele sabia disso), o mundo provavelmente nunca ficaria cheio de tanto amor pela desprez√≠vel linguagem dos "codificadores super-Java".  E hoje, os pontos fracos dessa linguagem no contexto passado de aplica√ß√£o fornecem incondicionalmente a primazia na implanta√ß√£o e no lan√ßamento de numerosos A / B. de minera√ß√£o. <br><br>  Voc√™ pode comparar muito: ARM com Intel, iOS e Android e Mortal Kombat com Injustice.  E entre em um holivar espacial, voltando ao t√≥pico de oferecer grandes volumes de conte√∫do em v√°rios formatos. <br><br>  Dez anos atr√°s, todo mundo tinha certeza absoluta de que o UDP era algo sobre entrega n√£o garantida.  Se voc√™ precisa de um protocolo confi√°vel, √© o TCP.  E, contrariamente √† tradi√ß√£o deste artigo, compararemos coisas aparentemente incompar√°veis ‚Äã‚Äãcomo TCP e UDP. <br><br><img src="https://habrastorage.org/webt/p5/tk/9z/p5tk9z_pumv5hmxly_ob3rvdikg.jpeg"><br>  <i>Cuidado, abaixo do corte 99 ilustra√ß√µes e diagramas e tudo importante.</i> <br><a name="habracut"></a><br>  A compara√ß√£o √© realizada pelo chefe de desenvolvimento das plataformas de v√≠deo e fita em OK <b>Alexander Tobol</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">alatobol</a> ).  Os servi√ßos de v√≠deo e feed de not√≠cias na rede social OK - exclusivamente sobre o conte√∫do e sua entrega a todas as plataformas de clientes existentes em quaisquer condi√ß√µes de rede ruins ou excelentes, e a quest√£o de como entreg√°-lo - via TCP ou UDP - √© crucial. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/aXYJlizk3CQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  TCP vs UDP.  Teoria m√≠nima </h2><br>  Para chegar √† compara√ß√£o, precisamos de um pouco de teoria b√°sica. <br><br><img src="https://habrastorage.org/webt/fd/2q/ko/fd2qkoeptll1vmmm0ptkscrhu9i.jpeg"><br><br>  O que sabemos sobre redes IP?  O fluxo de dados que voc√™ envia √© dividido em pacotes, algum tipo de caixa preta entrega esses pacotes ao cliente.  O cliente coleta pacotes e recebe um fluxo de dados.  Geralmente tudo isso √© transparente e n√£o h√° necessidade de pensar o que est√° nos n√≠veis mais baixos. <br><br><img src="https://habrastorage.org/webt/dj/6r/xm/dj6rxmcr3xayjlmfnblkxet-1le.jpeg"><br><br>  O diagrama mostra a pilha TCP / IP e UDP / IP.  Na parte inferior, existem pacotes Ethernet, pacotes IP e, al√©m disso, no n√≠vel do sistema operacional, TCP e UDP.  TCP e UDP nesta pilha n√£o s√£o muito diferentes um do outro.  Eles s√£o encapsulados em pacotes IP e os aplicativos podem us√°-los.  Para ver as diferen√ßas, √© necess√°rio olhar dentro dos pacotes TCP e UDP. <br><br><img src="https://habrastorage.org/webt/mz/pr/lt/mzprltftvytepznp_xufo63xb0g.jpeg"><br><br>  L√° e h√° portos.  Mas <strong>no UDP h√° apenas uma soma de verifica√ß√£o</strong> - o tamanho do pacote, esse protocolo √© o mais simples poss√≠vel.  E no TCP, existem muitos dados que indicam claramente a janela, confirma√ß√£o, sequ√™ncia, pacotes e assim por diante.  Obviamente, o <strong>TCP √© mais complexo</strong> . <br><br><blockquote>  Em termos gerais, o TCP √© um protocolo de entrega confi√°vel e o UDP n√£o √© confi√°vel. </blockquote><br>  E, no entanto, apesar da suposta falta de confiabilidade do UDP, descobriremos se √© poss√≠vel fornecer dados mais r√°pido e mais confi√°vel do que o uso do TCP.  Vamos tentar olhar para a rede por dentro e entender como ela funciona.  Ao longo do caminho, abordaremos as seguintes perguntas: <br><br><ul><li>  por que comparar o TCP ou o que h√° de errado com ele; </li><li>  com o que e com o que voc√™ deve comparar o TCP; </li><li>  o que o Google fez e que decis√£o tomou; </li><li>  o que o futuro dos protocolos de rede nos espera. </li></ul><br>  Este artigo n√£o ter√° uma teoria: n√≠veis e modelos OSI, modelos matem√°ticos complexos, embora tudo possa ser contado atrav√©s deles.  Analisaremos ao m√°ximo como tocar a rede n√£o em teoria, mas com nossas pr√≥prias m√£os. <br><br><h2>  Por que comparar o TCP ou o que h√° de errado com ele </h2><br>  O TCP foi inventado em 1974 e, 20 anos depois, quando fui para a escola, comprei placas de Internet, apaguei o c√≥digo e liguei para algum lugar.  Al√©m disso, se voc√™ telefonava de 2 noites √†s 7 da manh√£, a Internet era gratuita, mas era dif√≠cil passar. <br><br>  Outros 20 anos se passaram e os usu√°rios de redes m√≥veis sem fio come√ßaram a prevalecer sobre os usu√°rios "conectados", enquanto o TCP n√£o mudou conceitualmente. <br><br><blockquote>  O mundo m√≥vel venceu, os protocolos sem fio apareceram e o TCP ainda n√£o foi alterado. </blockquote><br>  Hoje, 80% dos usu√°rios usam Wi-Fi ou uma rede sem fio 3G-4G. <br><br><img src="https://habrastorage.org/webt/mw/a9/u4/mwa9u4ew7v6e1uevlbgrvf2jlrw.jpeg"><br><br>  Nas redes sem fio, existem: <br><br><ul><li>  perda de pacotes - aproximadamente 0,6% dos pacotes que enviamos s√£o perdidos ao longo do caminho; </li><li>  reordena√ß√£o - rearranjo de pacotes em locais, na vida real √© um fen√¥meno bastante raro, mas ocorre em 0,2% dos casos; </li><li>  tremula√ß√£o - quando os pacotes s√£o enviados uniformemente e chegam nas filas com um atraso de cerca de 50 ms. </li></ul><br>  O TCP oculta com √™xito todos os recursos de transfer√™ncia de dados em redes heterog√™neas e voc√™ n√£o precisa mergulhar nele. <br><br>  Abaixo no mapa est√° a taxa m√©dia de dados do TCP na R√∫ssia.  Se voc√™ remover a parte ocidental, fica claro que a velocidade √© medida mais em kilobits do que em megabits. <br><br><img src="https://habrastorage.org/webt/ck/a4/y5/cka4y5puk4gyorr-uaq2xcdtuom.jpeg"><br><br>  Ou seja, em m√©dia, para nossos usu√°rios (excluindo a parte ocidental da R√∫ssia): taxa de transfer√™ncia de 1,1 Mbps, perda de pacotes de 0,6%, RTT (tempo de ida e volta) da ordem de 200 ms. <br><br><h3>  Como calcular o RTT </h3><br>  Quando vi a m√©dia de 200ms, pensei que havia um erro nas estat√≠sticas e decidi medir o RTT para nossos servidores no MSC de uma maneira alternativa usando o RIPE Atlas.  Este √© um sistema para coletar dados sobre o estado da Internet.  A sonda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RIPE Atlas</a> est√° dispon√≠vel gratuitamente. <br><br><img src="https://habrastorage.org/webt/za/rj/3g/zarj3gndghr0wnxs4yqt_odm68a.jpeg"><br><br>  O ponto principal √© que voc√™ o conecta √† Internet da sua casa e coleta "karma".  Ela trabalha h√° dias, algumas pessoas cumprem alguns de seus pedidos.  Depois, voc√™ mesmo pode definir v√°rias tarefas.  Um exemplo dessa tarefa: pegue acidentalmente 30 pontos na Internet e pe√ßa para medir a RTT, ou seja, execute o comando ping no site do Odnoklassniki. <br><br><img src="https://habrastorage.org/webt/kb/qa/5k/kbqa5k7sgl6wt5modhjfpa2fg00.jpeg"><br><br>  Curiosamente, entre os pontos aleat√≥rios, existem muitos que t√™m ping de 200 a 300 ms. <br><br>  No total, <strong>as redes sem fio s√£o populares e inst√°veis</strong> (embora a √∫ltima seja geralmente ignorada, pois acredita-se que o TCP possa lidar com isso): <br><br><ul><li>  Mais de 80% dos usu√°rios usam internet sem fio; </li><li>  Os par√¢metros das redes sem fio mudam dinamicamente dependendo, por exemplo, do fato de o usu√°rio ter dobrado a esquina; </li><li>  As redes sem fio t√™m altas taxas de perda de pacotes, instabilidade, reordena√ß√£o; </li><li>  Canal assim√©trico fixo, mudan√ßa de endere√ßo IP. </li></ul><br><h3>  O consumo de conte√∫do depende da velocidade da Internet </h3><br>  Isso √© muito f√°cil de verificar - existem muitas estat√≠sticas.  Tirei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estat√≠sticas</a> do v√≠deo, que diz que quanto maior a velocidade da Internet no pa√≠s, mais usu√°rios assistem ao v√≠deo. <br><br><img src="https://habrastorage.org/webt/de/6q/_r/de6q_ruks-vpbgoo4yt5vokfkno.jpeg"><br><br>  Segundo essas estat√≠sticas, a R√∫ssia tem uma Internet bastante r√°pida, mas, de acordo com nossos dados internos, a velocidade m√©dia √© um pouco menor. <br><br>  A favor do fato de que a velocidade da Internet como um todo √© insuficiente, diz que todos os criadores de grandes aplicativos, redes sociais, servi√ßos de v√≠deo e outros est√£o otimizando seus servi√ßos para trabalhar em uma rede ruim.  Ap√≥s 10 Kb de dados recebidos, voc√™ pode ver um m√≠nimo de informa√ß√µes na fita e, a uma velocidade de 500 Kb, pode assistir ao v√≠deo. <br><br><h3>  Como acelerar o carregamento </h3><br>  No processo de desenvolvimento da plataforma de v√≠deo, percebemos que o TCP n√£o √© muito eficaz em redes sem fio.  Como voc√™ chegou a essa conclus√£o? <br><br>  Decidimos acelerar o download e fizemos o pr√≥ximo truque. <br><br><img src="https://habrastorage.org/webt/n2/gg/xf/n2ggxfu9tzoskihc7itlm28j7ui.jpeg"><br><br>  Baixamos o v√≠deo do cliente para o servidor em v√°rios fluxos, ou seja, 40 MB s√£o divididos em 4 partes de 10 MB e carregados em paralelo.  Iniciamos no Android e carregamos em paralelo mais r√°pido do que em uma conex√£o ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">demonstra√ß√£o</a> no relat√≥rio).  O mais interessante √© que, quando lan√ßamos downloads paralelos na produ√ß√£o, vimos que em algumas regi√µes a velocidade do download aumentou tr√™s vezes! <br><br><blockquote>  Quatro conex√µes TCP podem realmente carregar dados para o servidor tr√™s vezes mais r√°pido. </blockquote><br>  Por isso, aumentamos a velocidade de download do v√≠deo e conclu√≠mos que o download precisa ser paralelo. <br><br><h3>  TCP em redes inst√°veis </h3><br>  Um efeito incr√≠vel com paralelismo pode ser tocado.  Basta usar um medidor de velocidade para receber / enviar dados (por exemplo, Teste de velocidade) e modelador de tr√°fego (por exemplo, Condicionador de link de rede, se voc√™ tiver um Mac). Restringimos a rede a par√¢metros de 1 Mbps para upload e download e come√ßamos a aumentar a perda de pacotes. <br><br><img src="https://habrastorage.org/webt/lk/ki/j8/lkkij8appdgsvglvlp1rdt3em7s.jpeg"><br><br>  A tabela mostra RTT e perdas.  Pode-se observar que, no caso de perda de 0%, a rede √© utilizada 100%. <br><br>  Na pr√≥xima itera√ß√£o, aumentamos a perda de pacotes em 5% e vemos que a rede √© utilizada em apenas 74%.  Parece bom - com uma perda de pacotes de 5%, 26% da rede est√° perdida.  Mas se voc√™ tamb√©m aumentar o ping, <strong>menos da metade do canal</strong> permanecer√°. <br><br><blockquote>  Se o canal estiver com alta RTT e grande perda de pacotes, uma conex√£o TCP n√£o utilizar√° completamente a rede. </blockquote><br>  Um truque adicional mostra que, se voc√™ come√ßar a usar conex√µes TCP paralelas (poder√° executar v√°rios testes de velocidade ao mesmo tempo), poder√° ver o crescimento inverso da utiliza√ß√£o do canal. <br><br><img src="https://habrastorage.org/webt/co/n7/v_/con7v_t-dxmnrsxe6e0kkakbnwm.jpeg"><br><br>  Com um aumento no n√∫mero de conex√µes TCP paralelas, a utiliza√ß√£o da rede se torna quase igual √† taxa de transfer√™ncia, menos a porcentagem de perdas. <br><br>  Assim, descobriu-se: <br><br><ul><li>  As redes m√≥veis sem fio venceram e s√£o inst√°veis. </li><li>  O TCP n√£o utiliza totalmente o canal em redes inst√°veis. </li><li>  O consumo de conte√∫do depende da velocidade da Internet: quanto maior a velocidade da Internet, mais usu√°rios assistem, e n√≥s realmente amamos nossos usu√°rios e queremos que eles assistam mais. </li></ul><br>  Obviamente, voc√™ precisa se mudar para algum lugar e considerar alternativas ao TCP. <br><br><h2>  TCP vs n√£o TCP </h2><br>  Como comparar o quente?  Existem duas op√ß√µes. <br><br>  A primeira op√ß√£o - no n√≠vel do IP, h√° TCP e UDP, podemos pagar por outro protocolo acima.  Obviamente, se voc√™ iniciar seu pr√≥prio protocolo paralelamente ao TCP e UDP, o Firewall, Brandmauer, roteadores e o resto do mundo envolvido na entrega de pacotes n√£o saber√£o disso.  Como resultado, voc√™ ter√° que esperar anos quando todo o equipamento for atualizado e come√ßar a trabalhar com o novo protocolo. <br><br>  A segunda op√ß√£o √© criar seu pr√≥prio protocolo confi√°vel de entrega de dados, al√©m de UDP n√£o confi√°vel.  Obviamente, voc√™ pode esperar um longo tempo at√© que Linux, Android e iOS adicionem um novo protocolo ao seu kernel, portanto, √© necess√°rio cortar o protocolo no Espa√ßo do Usu√°rio. <br><br>  Esta solu√ß√£o parece interessante, chamaremos de protocolo UDP de fabrica√ß√£o pr√≥pria.  Para come√ßar a desenvolv√™-lo, voc√™ n√£o precisa de nada de especial: basta abrir o soquete UDP e enviar os dados. <br><br><img src="https://habrastorage.org/webt/zy/zt/sn/zyztsnsutwgufcqwlhxb6qslhpg.jpeg"><br><br>  Vamos desenvolv√™-lo, enquanto estudamos como a rede funciona. <br><br><h2>  TCP vs UDP auto-fabricado </h2><br>  Bem, e sobre o que comparar? <br><br>  Redes s√£o diferentes: <br><br><ul><li>  Com o congestionamento, quando h√° muitos pacotes e alguns deles caem devido ao congestionamento de canais ou equipamentos. </li><li>  Alta velocidade com ida e volta grande (por exemplo, quando o servidor est√° relativamente distante). </li><li>  Estranho - quando nada parece estar acontecendo na rede, mas os pacotes ainda desaparecem simplesmente porque o ponto de acesso Wi-Fi est√° atr√°s do muro. </li></ul><br>  Voc√™ sempre pode tocar em perfis de rede: selecione um ou outro perfil no seu telefone e execute o Teste de velocidade. <br><br><img src="https://habrastorage.org/webt/v1/0j/-p/v10j-p8absukvs6s4jn2ntd8qau.jpeg"><br><br>  Al√©m dos perfis de rede, voc√™ tamb√©m precisa determinar o perfil de consumo de tr√°fego.  Aqui est√£o os que usamos: <br><br><img src="https://habrastorage.org/webt/3k/dc/fb/3kdcfbeyhjpduwbumk1n1iz2-c0.jpeg"><br><br>  Como sou respons√°vel pelo v√≠deo e pelo fluxo, os perfis s√£o adequados: <br><br><ul><li>  Perfil de v√≠deo, quando voc√™ conecta e transmite este ou aquele conte√∫do.  A velocidade da conex√£o aumenta, como no gr√°fico superior.  Requisitos para este protocolo: baixa lat√™ncia e adapta√ß√£o √† taxa de bits. </li><li>  Op√ß√£o de exibi√ß√£o de fita: carregamento de dados por impulso, consultas em segundo plano, tempo de inatividade.  Requisitos para este protocolo: os dados recebidos s√£o multiplexados e priorizados, a prioridade do conte√∫do do usu√°rio √© superior aos processos em segundo plano, h√° um cancelamento do download. </li></ul><br>  Obviamente, voc√™ precisa comparar os protocolos no HTTP mais popular. <br><br><h3>  HTTP 1.1 e HTTP 2.0 </h3><br>  A pilha padr√£o dos anos 2000 parecia HTTP 1.1 sobre SSL.  A pilha moderna √© HTTP 2.0, TLS 1.3 e tudo em cima do TCP. <br><br><img src="https://habrastorage.org/webt/k9/yp/ng/k9ypngmth9i_4m8pqzx5n-kipf0.jpeg"><br><br>  A principal diferen√ßa √© que o HTTP 1.1 usa um conjunto limitado de conex√µes no navegador para um dom√≠nio, para que eles criem um dom√≠nio separado para imagens, dados e assim por diante.  O HTTP 2.0 oferece uma conex√£o multiplexada na qual todos esses dados s√£o transmitidos. <br><br><img src="https://habrastorage.org/webt/uo/aj/uu/uoajuubf2yfz_femlhzhvq6buty.jpeg"><br><br>  O HTTP 1.1 funciona assim: fa√ßa uma solicita√ß√£o, obtenha dados, fa√ßa uma solicita√ß√£o, obtenha dados. <br><br><img src="https://habrastorage.org/webt/1y/nv/xd/1ynvxdxpfkluduputf3szhfi75a.jpeg"><br><br>  Normalmente, um navegador ou um aplicativo m√≥vel √© um marcador, ou seja, uma conex√£o para receber imagens, dados pela API e voc√™ executa simultaneamente uma solicita√ß√£o de imagem, API, v√≠deo e assim por diante. <br><br><img src="https://habrastorage.org/webt/cn/ub/kl/cnubklsdxjrcuwpamcckap5_uu8.jpeg"><br><br>  O principal problema √© a concorr√™ncia.  Voc√™ n√£o tem controle sobre as solicita√ß√µes enviadas.  Voc√™ entende que o usu√°rio n√£o precisa mais da imagem que ele exibiu, mas n√£o pode fazer nada. <br><br><blockquote>  Com o HTTP 1.1, voc√™ ainda recebe o que solicitou, √© dif√≠cil cancelar o download. </blockquote><br>  A √∫nica chance de soquete √© fechar a conex√£o.  Ent√£o vamos ver por que isso √© ruim. <br><br><h3>  Diferen√ßas no HTTP 2.0 </h3><br>  O HTTP 2.0 resolve estes problemas: <br><br><ul><li>  bin√°rio, compacta√ß√£o de cabe√ßalho; </li><li>  multiplexa√ß√£o de dados; </li><li>  prioriza√ß√£o; </li><li>  cancelando o download; </li><li>  push do servidor </li></ul><br>  Vamos considerar pontos mais importantes para n√≥s. <br><br><img src="https://habrastorage.org/webt/tb/nl/ur/tbnlurtfdzcqaxpy6_hgcphtye0.jpeg"><br><br>  Solicite uma foto e API.  A imagem √© dada imediatamente, a API preparada depois de um tempo.  A API foi dada - a imagem foi dada at√© o fim.  Tudo isso acontece de forma transparente.  <strong>O conte√∫do de alta prioridade √© baixado anteriormente.</strong> <br><br><img src="https://habrastorage.org/webt/gw/ws/wp/gwwswpducmtjv2huz9jprbhwpha.jpeg"><br><br>  <strong>O envio de servidor</strong> √© uma coisa dessas quando voc√™ solicita algo espec√≠fico, como uma API, mas mesmo com a carga nas fotos do cliente em cache, isso seria definitivamente necess√°rio para exibir, por exemplo, uma fita. <br><br>  H√° tamb√©m um comando <strong>Redefinir fluxo</strong> que o navegador executa automaticamente se voc√™ alternar entre p√°ginas, etc.  Para um cliente m√≥vel, com sua ajuda, voc√™ pode recusar o recebimento de dados sem perder a conex√£o. <br><br>  Assim, compararemos o TCP em diferentes: <br><br><ul><li>  Perfis de rede: Wi-Fi, 3G, LTE. </li><li>  Perfis de consumo: streaming (v√≠deo), multiplexa√ß√£o e prioriza√ß√£o com o cancelamento do download (HTTP / 2) para receber o conte√∫do da fita. </li></ul><br><h3>  Modelo sem perdas </h3><br>  Vamos come√ßar a compara√ß√£o com uma rede simples, na qual existem apenas dois par√¢metros: tempo de ida e volta e largura de banda. <br><br>  <b>RTT</b> √© ping, o tempo de entrega de um pacote, o recebimento da confirma√ß√£o ou o tempo de eco da resposta. <br><br>  Para medir a <b>largura de banda</b> - <b>largura de banda da</b> rede - enviamos um pacote de pacotes e contamos o n√∫mero de pacotes transmitidos em um determinado intervalo de tempo. <br><br><img src="https://habrastorage.org/webt/6r/du/2l/6rdu2lwrhgztjekbwsfgvtuwdec.jpeg"><br><br>  Como trabalhamos com protocolos confi√°veis, √© claro, h√° um reconhecimento - enviamos pacotes e recebemos a confirma√ß√£o do recebimento. <br><br><h3>  O problema da Internet lenta </h3><br>  No in√≠cio do desenvolvimento do nosso servi√ßo de v√≠deo em 2013, meu amigo foi para a Calif√≥rnia e decidiu assistir a uma nova s√©rie de suas s√©ries favoritas no Odnoklassniki.  Ele tinha um RTT de 250 ms, Wi-Fi perfeito de 400 Mbps no campus do Google, queria ver a nova s√©rie em FullHD. <br><br>  Voc√™ acha que ele foi capaz de assistir ao v√≠deo?  A resposta depende da configura√ß√£o do buffer de envio / recv em nossos servidores. <br><br><img src="https://habrastorage.org/webt/qf/sk/qj/qfskqjvyygm-klersirdlmfdreo.jpeg"><br><br>  Como temos um protocolo com reconhecimento, todos os dados que n√£o receberam uma confirma√ß√£o de entrega s√£o armazenados em um buffer.  Se o buffer de envio estiver limitado a 128 Kb, esses 128 Kb ser√£o menores que para o RTT, n√£o poderemos enviar.  Assim, da nossa rede de 400 Mbit / s, restam 4 Mbit / s.  Isso n√£o √© suficiente para assistir a v√≠deos online em FullHD. <br><br>  Ent√£o puxei o tamanho do buffer e observei como a velocidade de sa√≠da de um segmento de v√≠deo realmente muda dependendo da altera√ß√£o no tamanho do buffer.  Fa√ßa imediatamente uma reserva de que o buffer de recv foi ajustado automaticamente, ou seja,  o que o servidor enviou, o cliente sempre poderia aceitar. <br><br><img src="https://habrastorage.org/webt/vj/yi/ef/vjyiefcatf55inm_ka-0b1vpake.jpeg"><br><br><blockquote>  Uma receita TCP √≥bvia: se voc√™ transmitir dados de alta velocidade por longas dist√¢ncias, precisar√° aumentar o buffer de envio. </blockquote><br>  Tudo parece estar bem.  Voc√™ pode acessar o servi√ßo fast.com, que mede a velocidade da sua Internet nos servidores Netflix.  Do escrit√≥rio, obtive uma velocidade de 210 Mbps.  E ent√£o, atrav√©s do shaper de rede, configurei as condi√ß√µes da tarefa e fui para este site novamente.  Magia - eu tenho exatamente 4 Mbps. <br><br><img src="https://habrastorage.org/webt/xx/sl/nr/xxslnr1m5syfgyludnghfp7d6yw.jpeg"><br><br>  N√£o importa como eu tor√ßa, a Netflix n√£o conseguiu obter um buffer maior que 128 KB. <br><br><h3>  Tamanho do buffer </h3><br>  Para descobrir o tamanho ideal do buffer, voc√™ precisa entender o que s√£o pacotes On-the-fly. <br><br><img src="https://habrastorage.org/webt/cl/ym/ws/clymwsmlyixceklwgevvv00izru.jpeg"><br><br>  H√° um status de rede: <br><br><ul><li>  os pacotes 1 e 2 j√° foram enviados, uma confirma√ß√£o foi recebida por eles; </li><li>  os pacotes 3, 4, 5, 6 foram enviados, mas o resultado da entrega √© desconhecido (pacotes on-the-fly); </li><li>  outros pacotes est√£o na fila. </li></ul><br><img src="https://habrastorage.org/webt/if/oh/m0/ifohm0lal6uotlodse6vrehnoqc.jpeg"><br><br>  Se o n√∫mero de pacotes On-the-fly for igual ao tamanho do buffer, ele n√£o ser√° grande o suficiente.  Nesse caso, a rede est√° passando fome, n√£o sendo totalmente utilizada. <br><br>  A situa√ß√£o inversa √© poss√≠vel - o buffer √© muito grande.  Nesse caso, o buffer aumenta.  Por que isso √© ruim? <br><br><img src="https://habrastorage.org/webt/m1/4y/fk/m14yfka8426esfgz8a8xeglxko4.jpeg"><br><br>  Se falamos sobre multiplexa√ß√£o de dados e enviamos v√°rias solicita√ß√µes ao mesmo tempo, por exemplo, imagens para a mesma conex√£o e API, quando toda a enorme imagem de megabytes entra no buffer e tentamos fazer o push da API de alta prioridade tamb√©m, o buffer aumenta.  Voc√™ tem que esperar muito tempo quando a imagem desaparecer. <br><br>  Uma solu√ß√£o simples √© ajustar automaticamente o tamanho do buffer.  Agora est√° dispon√≠vel em muitos clientes e funciona mais ou menos assim. <br><br><img src="https://habrastorage.org/webt/pm/dj/rj/pmdjrjtekrknmzgogzn6bzkgplq.jpeg"><br><br>  Se muitos pacotes podem ser enviados agora, o buffer est√° aumentando, a transfer√™ncia de dados est√° acelerando, o tamanho do buffer est√° aumentando, tudo parece √≥timo. <br><br>  Mas h√° um problema.  Se o buffer aumentou, n√£o pode ser reduzido com tanta facilidade.  Esta √© uma tarefa mais dif√≠cil.  Se a velocidade diminuir, ocorre o mesmo incha√ßo do buffer.  O buffer √© bastante grande e cheio, precisamos esperar at√© que todos os dados sejam enviados ao cliente. <br><br>  Se escrevermos nosso pr√≥prio protocolo UDP, tudo ser√° muito simples - teremos acesso ao buffer. <br><br><img src="https://habrastorage.org/webt/ow/lz/5m/owlz5m0em5dqvtz3ni14pgc3khm.jpeg"><br><br>  Se o TCP em tais situa√ß√µes simplesmente adicionar dados ao final e voc√™ n√£o puder fazer nada, em um protocolo criado por voc√™ poder√° colocar os dados, por exemplo, encaminhar imediatamente ap√≥s os pacotes din√¢micos. <br><br>  E se o cancelamento ocorrer, e o cliente disser que essa imagem n√£o √© mais necess√°ria, ele precisa dos dados da API, ele rolou o conte√∫do ainda mais, voc√™ pode jogar tudo isso fora do buffer e enviar a desejada. <br><br>  Como isso √© feito?  √â sabido que, para restaurar pacotes, gerenciar a entrega, receber confirma√ß√µes, voc√™ precisa de um sequence_id de pacotes.  Sequence_id, estamos gravados apenas para pacotes din√¢micos, ou seja, apenas o emitimos quando enviamos pacotes.  Tudo o mais no buffer pode ser movido como queremos at√© que os pacotes acabem. <br><br>  <strong>Conclus√£o:</strong> o buffer TCP deve estar configurado corretamente, pegar a balan√ßa para n√£o encostar na rede e n√£o inflar o buffer.  Para o seu pr√≥prio protocolo UDP, tudo √© simples - isso pode ser controlado. <br><br><h3>  Modelo de rede com perdas </h3><br>  Passamos para um n√≠vel superior, a rede se torna um pouco mais complicada, a perda de pacotes aparece nela.  Para redes m√≥veis, essa √© uma situa√ß√£o comum.  Alguns dos pacotes enviados n√£o chegam ao cliente.  O algoritmo de recupera√ß√£o de retransmiss√£o padr√£o funciona mais ou menos assim: <br><br><img src="https://habrastorage.org/webt/tg/z7/tv/tgz7tvr6zchscr49onnqepvjvje.jpeg"><br><br>  Envia pacotes, pois cada pacote recebe reconhecimento.   Retransmit timeout (RTO)  RTT     ,   . <br><br>     TCP,    5% ,     50%. <br><br><img src="https://habrastorage.org/webt/ob/vi/qf/obviqfawoiesuiex2yqf_idbvei.jpeg"><br><br>  retransmit,    ,      .    ,  ,   Congestion control. <br><br><h3> Congestion control </h3><br>      flow control,    . <br><br><img src="https://habrastorage.org/webt/bc/3k/g9/bc3kg9sb5k5sppttampxxaeaypu.jpeg"><br><br><ul><li> <b>Flow control</b> ‚Äî      .  ,           ,      .    flow control  recv window,      .  flow control ‚Äî  back pressure  ,    -    . </li><li>  <b>congestion control</b>   .  ,   ‚Äî    . </li></ul><br><img src="https://habrastorage.org/webt/mf/b5/9d/mfb59d5xp1ph_irk_rhkckjpbew.jpeg"><br><br>   ,     :  ,    ,    ,      .        ,     congestion control. <br><br>    TCP window. <br><br><img src="https://habrastorage.org/webt/tj/u0/9s/tju09sic8asow88ehlwsuyfjj6q.jpeg"><br><br>     flow control  congestion control,       . <br><br> : <br><br><ul><li>  TCP window = 1,       :  acknowledgement,     .. </li><li>  TCP window = 4,       ,  acknowledgement   . </li></ul><br>    ,    .  initial window  TCP = 10. <br><br><img src="https://habrastorage.org/webt/ar/jf/ja/arjfjayzxewtfl-iulsna677qa0.jpeg"><br><br>    ,  ,        . <br><br>     ? <br><br><img src="https://habrastorage.org/webt/yj/ck/_t/yjck_tpkuuze0pjmkdb5mhfrlri.jpeg"><br><br><ul><li>    ,    .     ,      . </li><li>      :   , acknowledgements   . </li><li>            -    , acknowledgements      ( ). </li></ul><br>       . <br><br><img src="https://habrastorage.org/webt/jp/6c/di/jp6cdirmtiqosalz9vw-mvkjkei.jpeg"><br><br>   ,    ,   .     :     ,     ..    ,      .   congestion control,  TCP window,    ,    . <br><br><img src="https://habrastorage.org/webt/__/w0/zg/__w0zgqdiycta2u7yla0svmhof4.jpeg"><br><br>     congestion control,   ,   ‚Äî   .      packet loss ‚Äî  ,   .        ,   ,         ‚Äî    ,    . <br><br> ,  TCP , ,   congestion control   loss-.    congestion control  loss delay,     ,   . <br><br><img src="https://habrastorage.org/webt/44/no/5k/44no5kuc601zfx2h8dm_kwoqete.jpeg"><br><br> : <br><br><ul><li> <b>Cubic</b> ‚Äî  Congestion Control  Linux 2.6.        :   ‚Äî  . </li><li> <b>BBR</b> ‚Äî   Congestion Control,    Google  2016 .   . </li></ul><br><h3> BBR Congestion Control </h3><br>   Cubic  BBR   feedback. <br><br><img src="https://habrastorage.org/webt/7u/5z/zr/7u5zzrcv5cr3eyywvi0ui75qxr8.jpeg"><br><br>       ,      ‚Äî   acknowledgement       .   : <br><br><ul><li> BBR ,    ,    ,    . </li><li> Cubic        . </li></ul><br>  Abaixo est√° um gr√°fico do atraso versus o tempo de conex√£o, que mostra o que acontece em diferentes controles de congestionamento. <br><br><img src="https://habrastorage.org/webt/xn/l5/c_/xnl5c_gfgpby_vchj-lt5ftptta.jpeg"><br><br>  O BBR detecta primeiro o tempo de ida e volta, envia mais e mais pacotes, percebe que o buffer est√° entupido e entra no modo de opera√ß√£o com um atraso m√≠nimo. <br><br>  O Cubic trabalha agressivamente - ele excede o buffer inteiro e, quando o buffer excede e a perda de pacotes ocorre, o cubic reduz a janela. <br><br>  Parece que com a ajuda do BBR seria poss√≠vel resolver todos os problemas, mas h√° <strong>instabilidade</strong> nas redes - os pacotes √†s vezes atrasam, outras vezes s√£o agrupados em pacotes.  Voc√™ os envia com uma certa frequ√™ncia, e eles v√™m em grupos.  Pior ainda, quando voc√™ recebe agradecimentos de volta a esses pacotes, e eles tamb√©m de alguma forma "tremem". <br><br>  Como prometi que tudo poderia ser tocado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">manualmente</a> , fazemos o ping, por exemplo, no site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HighLoad ++</a> , analisamos o ping e consideramos o jitter entre os pacotes. <br><br><img src="https://habrastorage.org/webt/be/pu/fj/bepufjz6mtygfhqppfkeyvi3phq.jpeg"><br><br>  Pode-se ver que os pacotes v√™m desigualmente, o jitter m√©dio √© de cerca de 50 ms.  Naturalmente, o BBR pode estar errado. <br><br>  O BBR √© bom porque distingue entre: perda real de congestionamento, perda de pacotes devido a estouros de buffer do dispositivo e perda aleat√≥ria devido a m√° rede sem fio.  Mas n√£o funciona bem em caso de tremula√ß√£o alta.  Como posso ajud√°-lo? <br><br><h3>  Como melhorar o controle de congestionamento </h3><br>  De fato, o TCP n√£o possui informa√ß√µes suficientes em reconhecimento, apenas os pacotes que viu.  H√° tamb√©m reconhecimento seletivo, que indica quais pacotes s√£o confirmados e que ainda n√£o chegaram.  Mas essa informa√ß√£o n√£o √© suficiente. <br><br><img src="https://habrastorage.org/webt/fs/9j/gm/fs9jgmfd67brdk7wynu6sqjprk8.jpeg"><br><br>  Se voc√™ tiver a oportunidade de aumentar o reconhecimento, ainda poder√° economizar o tempo todo - n√£o apenas enviando esses pacotes, mas tamb√©m chegando ao cliente.  Isso √©, de fato, no servidor para coletar o cliente jitter. <br><br>  Por que geralmente √© eficaz aumentar o reconhecimento?  Porque as redes m√≥veis s√£o assim√©tricas.  Por exemplo, geralmente com 3G ou LTE, 70% da largura de banda √© alocada para o download de dados e 30% para o upload.  O transmissor muda: upload - download, upload - download e voc√™ n√£o o afeta de forma alguma.  Se voc√™ n√£o descarregar nada, est√° simplesmente ocioso.  Portanto, se voc√™ tiver alguma id√©ia interessante, aumente o reconhecimento, n√£o seja t√≠mido - isso n√£o √© um problema. <br><br><img src="https://habrastorage.org/webt/cv/0t/gd/cv0tgdq9vzirpmrvzx4optqe0ik.jpeg"><br><br>  Um exemplo de como voc√™ pode usar uma confirma√ß√£o para dividir o tremor em envio e o tremor em receber e rastre√°-los separadamente.  Ent√£o nos tornamos mais flex√≠veis e entendemos quando ocorreu perda de congestionamento e quando ocorreu perda aleat√≥ria.  Por exemplo, voc√™ pode entender a quantidade de tremula√ß√£o em cada dire√ß√£o e configurar a janela com mais precis√£o. <br><br><img src="https://habrastorage.org/webt/ti/qj/zk/tiqjzkihljlcb2pn2oj-wdlbmkq.jpeg"><br><br><h3>  Qual controle de congestionamento escolher </h3><br>  Os colegas de classe s√£o uma grande rede com muito tr√°fego diferente: v√≠deo, API, fotos.  E h√° estat√≠sticas sobre qual controle de congestionamento √© melhor escolher. <br><br>  O BBR √© sempre eficaz para o v√≠deo, pois reduz os atrasos.  Em outros casos, o Cubic geralmente √© usado - √© bom para fotografias.  Mas existem outras op√ß√µes. <br><br><img src="https://habrastorage.org/webt/9m/ea/gd/9meagdum2m9dvmtn4eeawrmbtay.jpeg"><br><br>  Existem dezenas de op√ß√µes diferentes de controle de congestionamento.  Para escolher o melhor, voc√™ pode coletar estat√≠sticas no cliente e tentar um ou outro controle de congestionamento para diferentes tipos de perfis de carga. <br><br>  Por exemplo, esse √© o efeito de iniciar o BBR em um v√≠deo. <br><br><img src="https://habrastorage.org/webt/hy/h8/dh/hyh8dhiugrgtyl6vgaozjzitnxq.jpeg"><br><br>  Conseguimos aumentar seriamente a profundidade da visualiza√ß√£o.  O Google diz que eles t√™m cerca de 10% menos buffer no player ao usar o BBR. <br><br>  √ìtimo, mas e nossos clientes? <br><br><img src="https://habrastorage.org/webt/np/m1/uy/npm1uywvt78qoudkof3mkebqrj8.jpeg"><br><br>  Os clientes s√£o um pouco lentos, todos eles t√™m Cubic, e voc√™ n√£o pode influenci√°-lo.  Mas tudo bem, √†s vezes voc√™ pode paralelizar dados, e ser√° bom. <br><br>  <strong>Conclus√µes sobre o controle de congestionamentos:</strong> <br><br><ul><li>  BBR √© sempre bom para v√≠deo. </li><li>  Em outros casos, se usarmos nosso pr√≥prio protocolo UDP, voc√™ poder√° assumir o controle de congestionamento. </li><li>  Do ponto de vista do TCP, voc√™ pode usar apenas o controle de congestionamento, que est√° no kernel.  Se voc√™ deseja implementar seu controle de congestionamento no kernel, deve cumprir a especifica√ß√£o TCP.  √â imposs√≠vel inflar reconhecimento, fazer altera√ß√µes, porque elas simplesmente n√£o est√£o no cliente. </li></ul><br><blockquote>  Se voc√™ criar seu protocolo UDP, ter√° muito mais liberdade em termos de controle de congestionamento. </blockquote><br><h3>  Multiplexa√ß√£o e Prioriza√ß√£o </h3><br>  Esta √© uma nova tend√™ncia, todo mundo est√° fazendo isso agora.  Que problemas existem?  Se usarmos o TCP, certamente todos (ou quase todos) conhecer√£o a situa√ß√£o de bloqueio do cabe√ßalho da linha. <br><br><img src="https://habrastorage.org/webt/zv/rt/6t/zvrt6t3igpnzn4vea3lgdw7vb1e.jpeg"><br><br>  Existem v√°rias solicita√ß√µes que s√£o multiplexadas em uma √∫nica conex√£o TCP.  N√≥s os enviamos para a rede, mas faltava algum pacote.  Uma conex√£o TCP retransmitir√° esse pacote e retransmitir√° em um tempo pr√≥ximo ao RTT ou mais.  No momento, n√£o podemos obter nada, embora o buffer TCP contenha dados de outra solicita√ß√£o que esteja completamente pronta para ser selecionada. <br><br><blockquote>  Acontece que a multiplexa√ß√£o por TCP, se voc√™ usa HTTP 2.0, nem sempre √© eficaz em redes ruins. </blockquote><br>  O pr√≥ximo problema √© o incha√ßo do buffer. <br><br><img src="https://habrastorage.org/webt/fy/zh/rw/fyzhrwlr4mmtdgxwhp-mxfa9k-y.jpeg"><br><br>  Quando uma imagem √© enviada ao cliente, o buffer aumenta.  N√≥s o enviamos por um longo tempo e, em seguida, uma solicita√ß√£o de API √© exibida e n√£o pode ser priorizada.  Nesses casos, a prioriza√ß√£o de TCP n√£o funciona. <br><br>  Portanto, se a perda de pacotes ocorrer, haver√° um bloqueio no cabe√ßalho da linha e, quando o cliente tiver uma taxa de bits vari√°vel (e isso acontece frequentemente com clientes m√≥veis), o efeito bufferbloat ser√° exibido.  Como resultado, nem multiplexa√ß√£o, nem prioriza√ß√£o, nem envio de servidor, nem tudo o mais funciona, porque temos buffers ou o cliente est√° esperando alguma coisa. <br><br>  Se fizermos nossa pr√≥pria multiplexa√ß√£o, podemos colocar v√°rios dados l√°. <br><br><img src="https://habrastorage.org/webt/_g/er/5g/_ger5gqpdxllo3-p1eo7ytzupce.jpeg"><br><br>  Isso n√£o √© dif√≠cil, basta adicionar pacotes com n√∫meros ao buffer.  On-the-fly - n√£o toque no que j√° foi enviado, mas o que ainda n√£o foi enviado pode ser reorganizado.  Parece assim. <br><br><img src="https://habrastorage.org/webt/9g/_v/xr/9g_vxrrlkavxucnmocy3kggc-f8.jpeg"><br><br>  Eles enviaram fotos, dividiram-nos em pacotes, vieram uma solicita√ß√£o priorit√°ria da API: eles inseriram, enviaram a foto.  Mesmo se um pacote estiver faltando, podemos obter uma solicita√ß√£o de API pronta do buffer, √© de alta prioridade e chegar√° rapidamente ao cliente.  No TCP, por defini√ß√£o, a transfer√™ncia de dados por streaming n√£o √© poss√≠vel. <br><br><h3>  Estabelecer uma conex√£o </h3><br>  Se criarmos um perfil de nosso aplicativo, veremos que na maioria das vezes a rede est√° ociosa no in√≠cio do aplicativo, porque a conex√£o √© estabelecida antes da API, obtemos os dados e a conex√£o √© estabelecida antes das fotos, o download desses dados etc.  Isso sempre acontece - a rede √© utilizada por picos. <br><br><img src="https://habrastorage.org/webt/14/cn/ck/14cnckztbu1v-otwf__j9dqzahu.jpeg"><br><br>  Para lidar com isso, vamos ver como a conex√£o √© estabelecida. <br><br><img src="https://habrastorage.org/webt/ca/eb/ij/caebijcqzlqj0h5soblnfudqedo.jpeg"><br><br>  O primeiro √© resolver o DNS - n√£o podemos fazer nada com isso.  Em seguida, estabele√ßa uma conex√£o TCP, estabele√ßa uma conex√£o segura, execute a solicita√ß√£o e receba uma resposta.  O mais interessante √© que parte do trabalho que o servidor realiza ao responder a uma solicita√ß√£o geralmente leva menos tempo do que estabelecer uma conex√£o. <br><br>  Agora est√° na moda medir n√∫meros de lat√™ncia para mem√≥ria, discos e outras coisas.  Voc√™ pode medi-los para uma rede 3G, 4G e ver quanto tempo leva, no pior caso, para estabelecer uma conex√£o TCP com o TLS. <br><br><img src="https://habrastorage.org/webt/qe/ux/1p/qeux1p7brp9mvpxeptinhubywmc.jpeg"><br><br>  E isso pode ser segundos!  Mesmo em 4G de at√© 700 ms tamb√©m √© significativo.  Mas o TCP n√£o conseguiu viver t√£o facilmente esse tempo todo. <br><br>  A conex√£o √© baseada no algoritmo b√°sico <strong>de handshake de 3 vias TCP</strong> .  Fa√ßa syn, syn + ack e corrija a solicita√ß√£o mais tarde (√† esquerda no diagrama). <br><br><img src="https://habrastorage.org/webt/ty/mj/-a/tymj-amfsa1c4j8sirtaspnvq1o.jpeg"><br><br>  Existe o <strong>TCP Fast Open</strong> (√† direita).  Se voc√™ j√° tiver um handshake com este servidor, houver um cookie, poder√° enviar sua solicita√ß√£o imediatamente para zero-RTT.  Para usar isso, voc√™ precisa criar um soquete, fazer sendto () os primeiros dados, dizer que deseja FASTOPEN. <br><br><img src="https://habrastorage.org/webt/ab/kl/b9/abklb93dq3g__tw2rihxrhagkl8.jpeg"><br><br>  O Nginx pode fazer tudo isso - basta ativ√°-lo, tudo funcionar√° (ou ativ√°-lo no kernel). <br><br><h2>  TLS </h2><br>  Vamos verificar se o TLS est√° ruim. <br><br>  Eu configurei o shaper l√≠quido para 200 ms novamente, executei ping no google.com e vi que RTT = 220 √© o meu shaper RTT + RTT.  Ent√£o eu fiz uma solicita√ß√£o via HTTP e HTTPS.  Eu descobri que por HTTP √© poss√≠vel obter uma resposta durante o RTT, ou seja, o TFO funciona para o Google no meu computador.  Para HTTPS, isso levou mais tempo. <br><br><img src="https://habrastorage.org/webt/po/hl/kj/pohlkjs39dl7kk3rp5kzbxrwsna.jpeg"><br><br>  Essa √© uma sobrecarga TLS t√£o comum que requer mensagens para estabelecer uma conex√£o segura. <br><br><img src="https://habrastorage.org/webt/zf/j2/qn/zfj2qndcohpiok8cqpc82kiun3s.jpeg"><br><br>  Para fazer isso, eles pensaram para n√≥s, adicionou o TLS 1.3.  Tamb√©m √© f√°cil de incluir no nginx. <br><br><img src="https://habrastorage.org/webt/m5/eo/i0/m5eoi0z5a2rzb4hthqlbjchxhyi.jpeg"><br><br>  Tudo parece funcionar.  Mas vamos ver o que h√° em nossos clientes m√≥veis que aproveitam tudo isso. <br><br><h3>  O que h√° com os clientes </h3><br>  O TCP Fast Open √© uma coisa interessante.  Segundo as estat√≠sticas. <br><br><img src="https://habrastorage.org/webt/pq/yy/l8/pqyyl89jhtoulpwalg61q8pqbnw.jpeg"><br><br>  Existem muitos artigos que afirmam que o estabelecimento de uma conex√£o passa 10% mais r√°pido.  Mas no Android 8.1.0 (eu assisti v√°rios dispositivos) ningu√©m tem TFO.  No Android 9, vi o TFO no emulador, mas n√£o em dispositivos reais.  IOS √© um pouco melhor.  Aqui voc√™ pode ver: <br><br><pre><code class="plaintext hljs">sysctl -a | grep fast net.ipv4.tcp_fastopen = 0</code> </pre> <br>  Por que isso aconteceu?  O TCP Fast Open foi proposto em 2014, agora j√° √© um padr√£o, √© suportado no Linux e est√° tudo √≥timo.  Mas existe um problema t√£o grande que o aperto de m√£o do TFO come√ßou a desmoronar em algumas redes.  Isso ocorre porque alguns provedores (ou alguns dispositivos) est√£o acostumados a inspecionar o TCP, fazendo suas otimiza√ß√µes e n√£o esperavam que o handshake TFO estivesse l√°.  Portanto, sua implementa√ß√£o levou muito tempo e, at√© agora, os clientes m√≥veis n√£o a incluem por padr√£o, pelo menos no Android. <br><br>  Com o TLS 1.3, o que nos promete configura√ß√£o zero de conex√£o RTT √© ainda melhor.  N√£o encontrei nenhum dispositivo Android em que funcionasse.  Portanto, o Facebook criou a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fizz</a> .  H√° alguns meses, ele ficou dispon√≠vel em c√≥digo aberto, voc√™ pode arrast√°-lo com voc√™ e usar o TLS 1.3.  Acontece que mesmo a seguran√ßa precisa ser arrastada, nada aparece no centro disso. <br><br><img src="https://habrastorage.org/webt/07/qm/kf/07qmkfwywo3llz5nrrh04kg3a_o.jpeg"><br><br>  O diagrama mostra o uso de v√°rias vers√µes do Android por nossos clientes m√≥veis.  V 9.x √© bastante - onde TFO pode aparecer e TLS1.3 n√£o √© encontrado em nenhum outro lugar. <br><br>  <strong>Conclus√µes sobre o estabelecimento de uma conex√£o:</strong> <br><br><ul><li>  O TFO n√£o est√° dispon√≠vel para 95% dos dispositivos. </li><li>  O TLS1.3 precisa ser trazido consigo. </li><li>  Se voc√™ precisar repetir isso no UDP, transfira tudo para o UDP e repita. </li></ul><br><img src="https://habrastorage.org/webt/n2/tj/v1/n2tjv1g-04l2jfghy_6--uqaqjc.jpeg"><br><br>  Verificou-se que 97% das conex√µes criadas usam a chave existente, ou seja, 97% s√£o criadas para zero RTT e apenas 3% s√£o novas.  A chave √© armazenada no dispositivo por algum tempo. <br><br>  O TCP n√£o pode se gabar.  Em um m√°ximo de 5% dos casos, se voc√™ fizer tudo certo, poder√° obter o RTT zero zero real de que todos est√£o falando agora. <br><br><h2>  Altera√ß√£o de endere√ßo IP </h2><br>  Muitas vezes, quando voc√™ sai de casa, seu telefone muda de Wi-Fi para 4G. <br><br><blockquote>  O TCP funciona assim: o endere√ßo IP mudou - a conex√£o falhou. </blockquote><br><img src="https://habrastorage.org/webt/km/nu/u8/kmnuu8dtr8jeipuzx4bhpfezuwm.jpeg"><br><br>  Se voc√™ escrever seu protocolo UDP, √© muito simples, implementando um ID de conex√£o (CUID) em cada pacote, voc√™ poder√° identific√°-lo mesmo se vier de um endere√ßo IP diferente. <br><br><img src="https://habrastorage.org/webt/xu/ga/r_/xugar_l9pbltv6419btnrimfhv8.jpeg"><br><br>  √â claro que voc√™ precisa ter certeza de que possui a chave correta, tudo √© descriptografado etc.  Mas, em princ√≠pio, voc√™ pode come√ßar a responder a este endere√ßo, n√£o haver√° problemas com isso. <br><br><blockquote>  No TCP, a migra√ß√£o de IP √© uma coisa imposs√≠vel. </blockquote><br>  Se voc√™ criar seu UDP e vier para o mesmo servidor, precisar√° fazer um pouco de m√°gica, incluir o CID em cada pacote e poder√° usar a conex√£o estabelecida ao alterar o endere√ßo IP. <br><br><h2>  Reutiliza√ß√£o de conex√£o </h2><br>  Todo mundo diz que voc√™ precisa reutilizar conex√µes porque as conex√µes s√£o muito caras. <br><br><img src="https://habrastorage.org/webt/8-/lr/ot/8-lrot44ac9mwo6m7ue_ksezk0g.jpeg"><br><br>  Mas existem armadilhas na reutiliza√ß√£o de compostos. <br><br><img src="https://habrastorage.org/webt/_n/aa/z3/_naaz3uac-hwdd7uikndioiupry.jpeg"><br><br>  Provavelmente, muitas pessoas lembram (se n√£o, ent√£o veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ) que nem todo mundo tem endere√ßos p√∫blicos, mas existe o NAT, que normalmente armazena o mapeamento por algum tempo no roteador dom√©stico.  Para o TCP, √© claro quanto armazenar, mas para o UDP, n√£o √© claro.  O NAT opera com um tempo limite; se voc√™ medir cuidadosamente esse tempo limite, obtemos que em cerca de 15 a 30 segundos mais de 50% das conex√µes come√ßar√£o a falhar. <br><br>  Tudo bem - faremos um pacote de pingue-pongue por 15 s.  Nos casos em que a conex√£o ainda est√° interrompida, h√° a Migra√ß√£o de IP, que permite alterar de forma barata a porta no roteador. <br><br><img src="https://habrastorage.org/webt/7g/mu/bf/7gmubflfj-yenwqvgiqbkc8toa8.jpeg"><br><br><h2>  Ritmo de pacote </h2><br>  Isso √© muito importante se voc√™ estiver executando seu protocolo UDP. <br><br><img src="https://habrastorage.org/webt/cf/d5/97/cfd597jt4v7uopygyyu-dfsx_8s.jpeg"><br><br>  Se for muito simples, quanto mais voc√™ enviar pacotes continuamente para a rede, maior a probabilidade de perda de pacotes.  Se voc√™ filtrar pacotes, a perda de pacotes ser√° menor. <br><br>  Existem muitas teorias diferentes sobre como isso funciona, mas eu gosto dessa. <br><br><img src="https://habrastorage.org/webt/75/79/xl/7579xlvo70vmotoqjjp3zmmplr8.jpeg"><br><br>  Existem 3 conex√µes criadas ao mesmo tempo.  Voc√™ tem a chamada janela inicial - 10 pacotes criados ao mesmo tempo.  Obviamente, a largura de banda pode n√£o ser suficiente neste momento.  Mas se voc√™ distribu√≠-los cuidadosamente, separe-os, tudo ficar√° bem, como na figura certa. <br><br>  Portanto, se voc√™ definir uma taxa uniforme para o envio de pacotes, diminua-os, ent√£o a probabilidade de haver um estouro de buffer √∫nico ser√° menor.  Isso n√£o est√° provado, mas teoricamente acontece assim. <br><br><img src="https://habrastorage.org/webt/vw/mg/vw/vwmgvw6oyq3v_yaliklp4ilnocm.jpeg"><br><br>  Quando voc√™ precisar cortar pacotes (fa√ßa o ritmo): <br><br><ul><li>  Quando voc√™ cria uma janela. </li><li>  Quando voc√™ amplia a janela, por exemplo, √© recomend√°vel adicionar quantos pacotes podem ser enviados para o RTT / 2.  Isso n√£o prejudicar√° o tempo de entrega, mas reduzir√° a perda de pacotes. </li><li>  No caso de perda de congestionamento, para reduzir a janela, voc√™ precisa manchar os pacotes ainda mais.  4/5 RTT √© uma figura empiricamente selecionada. </li></ul><br><h2>  MTU </h2><br>  Ao escrever seu protocolo UDP, lembre-se do MTU.  MTU √© o tamanho dos dados que voc√™ pode encaminhar. <br><br><img src="https://habrastorage.org/webt/c2/7_/ow/c27_ow36h5amg3d4zkskjph_ama.jpeg"><br><br>  Enviamos pacotes do servidor para o cliente, por exemplo, com um tamanho de 1500. Se houver um roteador no caminho que n√£o suporte esse tamanho de MTU, ele ser√° fragmentado.  O √∫nico problema de fragmenta√ß√£o √© que, se um pacote for perdido, ambos ser√£o perdidos e tudo isso precisar√° ser retransmitido.  Portanto, o TCP possui um algoritmo para determinar o MTU - PMTU. <br><br><img src="https://habrastorage.org/webt/je/gs/ks/jegskszkwrb3pm2nghgfpplez8o.jpeg"><br><br>  Cada roteador examina o MTU de sua interface, envia para um cliente, o outro envia para seu cliente, todos sabem quantos MTU eles t√™m no cliente.  Em seguida, a fragmenta√ß√£o √© proibida pelo sinalizador e os pacotes de tamanho MTU s√£o enviados.  Se neste momento algu√©m dentro da rede perceber que ele tem menos MTU, ent√£o via ICMP ele dir√°: "Desculpe, o pacote foi perdido porque √© necess√°ria fragmenta√ß√£o" e indica o tamanho da MTU.  Alteraremos esse tamanho e continuaremos enviando.  Na pior das hip√≥teses, nossa pequena sobrecarga √© RTT / 2.  Isso est√° no TCP. <br><br><img src="https://habrastorage.org/webt/vl/br/fo/vlbrfo8a7p80neysmtjguosakww.jpeg"><br><br>  Se no UDP voc√™ n√£o quiser se preocupar com o ICMP, fa√ßa o seguinte: permita a fragmenta√ß√£o ao enviar dados normais.  Ou seja, para enviar pacotes fragmentados - deixe-os funcionar.  E, paralelamente, para iniciar um processo que pro√≠be a fragmenta√ß√£o, uma pesquisa bin√°ria selecionar√° o MTU ideal, para o qual iremos ent√£o.  Isso n√£o √© totalmente eficaz, porque a princ√≠pio o MTU parece aquecer. <br><br>  Uma op√ß√£o mais complicada √© observar a distribui√ß√£o do MTU entre clientes m√≥veis. <br><br><img src="https://habrastorage.org/webt/ie/a5/w8/iea5w8h3msrkprfxpgfhb2nkjyu.jpeg"><br><br>  De todos os clientes, enviamos pacotes de v√°rios tamanhos com a proibi√ß√£o de fragmenta√ß√£o.  Ou seja, se o pacote n√£o atingir, ele cair√° e o menor MTU dever√° atingir 100%.  Mas h√° uma pequena perda de pacotes, ent√£o existem dois slides no gr√°fico: <br><br><ol><li>  1350 bytes - em vez de 98%, obtemos 95% de entrega imediatamente. </li><li>  1500 bytes - MTU, ap√≥s o qual j√° 80% dos clientes n√£o receber√£o esses pacotes. </li></ol><br><blockquote>  De fato, podemos dizer o seguinte: negligenciamos 1-2% de nossos clientes, deixamos que eles vivam em pacotes fragmentados.  Mas come√ßaremos imediatamente do que precisamos - √© de 1350. </blockquote><br><h2>  Corre√ß√£o de erros (SACK, NACK, FEC) </h2><br>  Se voc√™ estiver criando seu protocolo, precisar√° corrigir os erros.  Se o pacote estiver ausente (isso √© normal para redes sem fio), ele precisar√° ser restaurado. <br><br>  No caso mais simples (mais detalhes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ), h√° um rel√© atrav√©s do Retransmit Time Out (RTO).  Se o pacote estiver faltando, aguarde o tempo de retransmiss√£o e envie-o novamente. <br><br>  O pr√≥ximo algoritmo √© a <b>retransmiss√£o r√°pida</b> .  Todos esses s√£o algoritmos TCP, mas podem ser facilmente portados para o UDP. <br><br><img src="https://habrastorage.org/webt/hm/s1/ee/hms1eey-ntpj2x0piswhxc4e5fa.jpeg"><br><br>  Quando o pacote acabar, continuamos a enviar - h√° uma transmiss√£o de outros pacotes.  No momento, o servidor diz que recebeu o pr√≥ximo pacote, mas n√£o havia um pacote anterior.  Para fazer isso, ele faz um reconhecimento complicado, que √© igual ao n√∫mero do pacote + 1, e define o sinalizador de confirma√ß√£o duplicado.  Ele envia esses dups assim, e no terceiro geralmente entendemos que o pacote desapareceu e o envia novamente. <br><br>  O que mais voc√™ deseja fazer com classe, o que n√£o est√° no TCP e o que eles sugerem fazer no UDP √© a <b>Corre√ß√£o de erro de encaminhamento</b> . <br><br><img src="https://habrastorage.org/webt/ex/_u/gg/ex_uggyt0-4ntdgzy-vn7hvmyzg.jpeg"><br><br>  Parece que se sabemos que os pacotes podem ser perdidos, podemos pegar um conjunto de pacotes, adicionar um pacote XOR e corrigir o problema sem retransmiss√µes adicionais imediatamente no cliente ao receber dados.  Mas h√° um problema se v√°rios pacotes desaparecerem.  Parece que pode ser resolvido atrav√©s da prote√ß√£o de paridade, Reed-Solomon, etc. <br><br>  Tentamos dessa maneira, e de fato os pacotes desaparecem em pacotes. <br><br><img src="https://habrastorage.org/webt/fg/qo/jj/fgqojj1gas9pgutyyyzkla_m5ze.jpeg"><br><br>  O intervalo m√©dio de pacotes acabou por ser 6. Este √© um intervalo muito inconveniente de pacotes - voc√™ precisa de muitos c√≥digos de corre√ß√£o de erros.  Ao mesmo tempo, h√° algum tipo de pico em 11 - n√£o sei por que, mas √†s vezes os pacotes desaparecem em pacotes de 11.  Devido a essa lacuna de pacote, isso n√£o funciona. <br><br>  O Google tamb√©m tentou isso, todo mundo sonha com o FEC, mas at√© agora ningu√©m trabalhou. <br><br>  H√° outra op√ß√£o quando o FEC pode ajudar. <br><br><img src="https://habrastorage.org/webt/d9/tb/tw/d9tbtwafxbt_t08_j9wvarw5icc.jpeg"><br><br>  Al√©m de retransmitir por Retransmit Time Out, Fast Retransmit, tamb√©m h√° uma <strong>sonda de perda de cauda</strong> .  Isso acontece quando voc√™ envia dados e a cauda desaparece.  Ou seja, voc√™ enviou parte dos dados, enviou o quinto pacote - ele chegou.  Os pacotes come√ßaram a desaparecer, por exemplo, porque a rede falhou.  Pacotes desaparecem, desaparecem e voc√™ recebeu uma confirma√ß√£o apenas para o quinto pacote. <br><br>  Para entender se esses dados chegaram, depois de um tempo voc√™ come√ßa a executar o TLP (probe de perda da cauda), pergunte se o final foi recebido.  O fato √© que a transfer√™ncia de dados terminou e voc√™ n√£o est√° enviando nada; a Retransmiss√£o R√°pida n√£o funcionar√°.  Para corrigir isso, fa√ßa um TLP. <br><br>  Voc√™ pode adicionar o FEC aos TLPs.  Voc√™ pode olhar para todos os pacotes que n√£o chegaram, contar com paridade e enviar TLPs com algum pacote de paridade. <br><br>  Tudo isso √© legal, parece funcionar.  Mas existe um problema. <br><br><img src="https://habrastorage.org/webt/pt/y5/qm/pty5qmye2nqwrocxnp3fv5-gll4.jpeg"><br><br>  Coletamos estat√≠sticas e verificamos que 98% dos erros s√£o reparados atrav√©s da Retransmiss√£o R√°pida.  O restante √© reparado via Retransmit Time Out e menos de 1% atrav√©s do TLP.  Se voc√™ consertar outra coisa, o FEC ser√° menor que 0,5%. <br><br><blockquote>  O TCP n√£o suporta FEC.  No UDP, n√£o √© dif√≠cil fazer isso, mas no caso geral, os algoritmos de recupera√ß√£o TCP padr√£o s√£o suficientes. </blockquote><br><h2>  Desempenho </h2><br>  Seria poss√≠vel n√£o prejudicar o desempenho comparando o TCP com o UDP. <br><br>  O TCP √© um protocolo muito antigo com v√°rias otimiza√ß√µes diferentes, por exemplo, LSO (descarga de grandes segmentos) e zeroc√≥pia.  Agora, para o UDP, tudo est√° indispon√≠vel.  Portanto, o desempenho do UDP √© de apenas 20% em rela√ß√£o ao TCP dos mesmos servidores.  Mas j√° existem solu√ß√µes prontas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UDP GSO</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">zerocopy</a> ) que permitem ao Linux suportar isso. <br><br>  O principal problema de suporte √† otimiza√ß√£o para zeroc√≥pia e LSO √© que a estimula√ß√£o √© perdida. <br><br><img src="https://habrastorage.org/webt/qu/6i/th/qu6ith66mowy_jm9iznjsstsadm.jpeg"><br><br><h2>  Tempo para o mercado ou o que matou o TCP </h2><br>  Recentemente, quando as redes sem fio m√≥veis se tornaram populares, surgiram muitos padr√µes TCP diferentes: TLP, TFO, novo controle de congestionamento, RACK, BBR e muito mais. <br><br><img src="https://habrastorage.org/webt/nq/lx/5a/nqlx5a_sq5zzvi2au81ulptczew.jpeg"><br><br><blockquote>  Mas o principal problema √© que muitos deles n√£o est√£o sendo implementados, porque se diz que o TCP √© ossificado.  Em muitos casos, os operadores examinam os pacotes TCP e esperam ver o que esperam.  Portanto, √© muito dif√≠cil mudar. </blockquote><br>  Al√©m disso, os clientes m√≥veis s√£o atualizados por um longo tempo e n√£o podemos fornecer essas atualiza√ß√µes.  Se voc√™ observar quais as atualiza√ß√µes recentes mais recentes est√£o dispon√≠veis no cliente e o que est√° no servidor, pode dizer que n√£o h√° quase nada no cliente. <br><br><img src="https://habrastorage.org/webt/au/57/iw/au57iwnkvrjzkvrpo2osdo7f49e.jpeg"><br><br>  Portanto, a decis√£o de escrever um protocolo no espa√ßo do usu√°rio, pelo menos desde que voc√™ acumule todos esses recursos, n√£o parece t√£o ruim. <br><br><img src="https://habrastorage.org/webt/6i/o6/po/6io6poew2qopzofy3vbflm3-5a8.jpeg"><br><br>  Com o TCP, os recursos v√™m rolando h√° anos.  Para o seu protocolo UDP, voc√™ pode atualizar a vers√£o literalmente em uma atualiza√ß√£o do cliente e do servidor.  Mas voc√™ precisar√° adicionar a negocia√ß√£o de vers√£o. <br><br><h2>  TCP vs UDP self-made.  Luta final </h2><br><img src="https://habrastorage.org/webt/fx/q6/ct/fxq6ctnz94vaf7pfr7jmrcbz7lu.jpeg"><br><br><ul><li>  Enviar / recuperar buffer: buffer mut√°vel pode ser feito para o seu protocolo, haver√° problemas com o incha√ßo do buffer com o TCP. </li><li>  Controle de congestionamento que voc√™ pode usar existente.  Na UDP eles s√£o. </li><li>  √â dif√≠cil adicionar o novo controle de congestionamento ao TCP, porque voc√™ precisa modificar a confirma√ß√£o, n√£o √© poss√≠vel fazer isso no cliente. </li><li>  A multiplexa√ß√£o √© uma quest√£o cr√≠tica.  O bloqueio do cabe√ßalho da linha acontece; quando voc√™ perde um pacote, n√£o pode multiplexar para o TCP.  Portanto, o HTTP2.0 sobre TCP n√£o deve dar um aumento s√©rio. </li><li>  Os casos em que voc√™ pode obter uma configura√ß√£o de conex√£o para 0-RTT no TCP s√£o extremamente raros, cerca de 5% e cerca de 97% para UDP auto-criado. </li></ul><br><img src="https://habrastorage.org/webt/4f/_f/oe/4f_foen6zvxf5mexl8p6jfu2izm.jpeg"><br><br><ul><li>  A migra√ß√£o de IP n√£o √© um recurso t√£o importante, mas, no caso de assinaturas complexas e estado de armazenamento no servidor, √© definitivamente necess√°rio, mas n√£o √© implementado no TCP de forma alguma. </li><li>  Nat unbinding n√£o √© a favor do UDP.  Nesse caso, o UDP geralmente precisa executar pacotes de ping-pong. </li><li>  O ritmo de pacotes no UDP √© simples, embora n√£o haja otimiza√ß√£o, no TCP essa op√ß√£o n√£o funciona. </li><li>  MTU e corre√ß√£o de erros s√£o compar√°veis. </li><li>  A velocidade do TCP, √© claro, √© mais r√°pida que o UDP agora, se voc√™ estiver distribuindo uma tonelada de tr√°fego.  Mas algumas otimiza√ß√µes levam muito tempo para serem entregues. </li></ul><br>  Se voc√™ coletar tudo o mais importante, o UDP, mais provavelmente, ter√° mais pr√≥s do que contras. <br><br><img src="https://habrastorage.org/webt/p4/7k/ys/p47kysilkuqtb-x-zc0cwhigeoe.jpeg"><br><br>  <b>Escolha UDP!</b> <br><br><h2>  Testando UDP auto-criado em usu√°rios </h2><br>  Reunimos uma bancada de testes. <br><br><img src="https://habrastorage.org/webt/rh/er/ec/rherec8kewip9-ycek5qimdgvuw.jpeg"><br><br>  H√° um cliente no TCP e UDP.  Normalizamos o tr√°fego por meio do modelador de rede, enviado √† Internet e ao servidor.  Um servi√ßo de API REST, o segundo com UDP.  E o UDP vai para a mesma API REST dentro do mesmo datacenter para verificar os dados.  Coletamos diferentes perfis de nossos clientes m√≥veis e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lan√ßamos o teste</a> . <br><br><img src="https://habrastorage.org/webt/sy/rf/nf/syrfnflhcgpr13bngr1y7cv5fle.jpeg"><br><br>  Medindo a m√©dia do portal, vimos que conseguimos reduzir o tempo de chamada da API em 10%, as imagens em 7%.  A atividade do usu√°rio cresceu apenas 1%, mas n√£o desistimos, achamos que ser√° melhor. <br><br><img src="https://habrastorage.org/webt/o9/wr/bj/o9wrbjk45dk58yjji6t8boe9-xw.jpeg"><br><br>  Em termos de cargas, agora temos cerca de 10 milh√µes de usu√°rios em nosso UDP de fabrica√ß√£o pr√≥pria, tr√°fego de at√© 80 Gb / s, 6 milh√µes de pacotes por segundo e 20 servidores todos atendem a isso. <br><br><h2>  Lista de verifica√ß√£o UDP <br></h2><br>  Se voc√™ escrever seu protocolo, precisar√° de uma lista de verifica√ß√£o: <br><br><ul><li>  Pacing </li><li>  Descoberta MTU. </li><li>  <strong>Corre√ß√µes de bugs necess√°rias</strong> . </li><li>  Controle de fluxo e controle de congestionamento. </li><li>  Opcionalmente, voc√™ pode oferecer suporte √† migra√ß√£o de IP, o TLP √© f√°cil. </li></ul><br>  Lembre-se de que os canais s√£o assim√©tricos e, enquanto voc√™ recebe dados do servidor, seu upload pode ficar ocioso, tente us√°-lo. <br><br><h2>  QUIC </h2><br>  Seria desonesto dizer que o Google n√£o. <br><br><img src="https://habrastorage.org/webt/z0/b9/-v/z0b9-v9kmmobln4nv2yado-rble.jpeg"><br><br>  Existe um protocolo QUIC que o Google implementou no HTTP 2.0, que suporta quase a mesma coisa. <br><br><h3>  Por que o QUIC n√£o √© t√£o r√°pido </h3><br>  Quando o QUIC foi lan√ßado, havia muito √≥dio pelo fato de o Google dizer que tudo funciona mais r√°pido e "eu o medi em casa em um computador - funciona mais devagar". <br><br><img src="https://habrastorage.org/webt/db/5a/vd/db5avdtu1zaito8ntcmg-hdvwy8.jpeg"><br><br>  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo tem v√°rias</a> fotos e medidas. <br><br>  Bem, acontece que fizemos tudo isso em v√£o, as pessoas mediram por n√≥s?  Existem medi√ß√µes dom√©sticas reais, mesmo com exemplos de c√≥digo. <br><br><img src="https://habrastorage.org/webt/id/wr/39/idwr39saesks74hbadevlunieua.jpeg"><br><br>  De fato, n√£o haver√° melhorias at√© que voc√™ paralelize solicita√ß√µes, trabalhe em redes reais e at√© que as perdas de pacotes sejam divididas em perda de congestionamento e perda aleat√≥ria.  Precisamos de uma emula√ß√£o real de uma rede real. <br><br>  Mas h√° um ponto positivo, dizem eles, QUIC n√£o √© nem melhor nem pior.  Assim, em redes perfeitas, o QUIC funciona bem. <br><br><h2>  O futuro </h2><br>  O Google recentemente nomeou HTTP 2.0 sobre o QUIC HTTP 3, para n√£o confundir, porque o HTTP 2.0 pode estar sobre o TCP e sobre o QUIC.  Agora √© HTTP 3. <br><br><img src="https://habrastorage.org/webt/go/ra/z4/goraz4ktgsje7ankwyipapzeow0.jpeg"><br><br>  Havia tamb√©m o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google QUIC</a> - este √© o QUIC, implementado no Chrome, e o iQUIC - um QUIC padronizado.  Na verdade, o QUIC padronizado nunca foi implementado em nenhum lugar; os servidores iQUIC padr√£o n√£o foram cumpridos com o Google QUIC.  Agora eles prometem resolver esse problema, e em breve ele estar√° dispon√≠vel. <br><br><h3>  QUIC est√° em toda parte </h3><br>  Se voc√™ ainda n√£o acredita que o TCP est√° morto, digo-lhe que quando voc√™ usa o Chrome, Android e em breve o iOS, e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">acessa o</a> google, youtube e assim por diante, usa QUIC e UDP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">prooflink</a> ). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">QUIC agora</a> √©: <br><br><ul><li>  1,9% de todos os sites; </li><li>  12% de todo o tr√°fego; </li><li>  30% do tr√°fego de v√≠deo em redes m√≥veis. </li></ul><br>  Como verificar se voc√™ usa o QUIC se n√£o acredita?  Abra no Chrome Wireshark.  Eu estava procurando pelo iQUIC, n√£o o encontrei em nenhum lugar, mas o GQUIC acontece. <br><br><img src="https://habrastorage.org/webt/t_/8v/9q/t_8v9qsq9jcgbjkf9vqqr67vw7k.jpeg"><br><br>  Voc√™ tamb√©m pode ficar online no seu navegador e tamb√©m ver o que o GQUIC est√° l√°. <br><br><img src="https://habrastorage.org/webt/av/ko/p5/avkop5nphmxm6ee3rqc2hi23wzu.jpeg"><br><br><h3>  Um pouco mais de futuro </h3><br>  Multipath est√° esperando por n√≥s em breve. <br><br><img src="https://habrastorage.org/webt/d8/bi/wo/d8biwobqjbdjqdn8g-wb7gegka0.jpeg"><br><br>  Quando voc√™ tem um cliente m√≥vel com Wi-Fi e 3G, pode usar os dois canais.  O TCP de caminhos m√∫ltiplos est√° agora em desenvolvimento e estar√° dispon√≠vel em breve no kernel do Linux.  Obviamente, n√£o chegar√° a clientes em breve, acho que isso pode ser feito no UDP muito mais rapidamente. <br><br><img src="https://habrastorage.org/webt/pb/7o/yt/pb7oytnkrhutg6qtqlwq0jf3p4o.jpeg"><br><br>  Como realizamos muitas tradu√ß√µes de 3 TB cada uma, frequentemente utilizamos tecnologias como a distribui√ß√£o CDN e p2p, quando o mesmo conte√∫do precisa ser entregue a muitos usu√°rios em todo o mundo. <br><br>  No IPv6, h√° multicast com UDP, o que permitir√° a entrega de pacotes a v√°rios usu√°rios inscritos ao mesmo tempo.  Portanto, acho que as tecnologias CDN e p2p n√£o ser√£o necess√°rias no futuro pr√≥ximo se entregarmos todo o conte√∫do usando multicast ao IPv6. <br><br><h2>  Conclus√µes </h2><br>  Espero que voc√™ entenda: <br><br><ul><li>  Como a rede realmente funciona e que o TCP pode ser repetido em UDP e feito melhor. </li><li>  Esse TCP n√£o √© t√£o ruim se voc√™ o configurar corretamente, mas realmente desistiu e quase n√£o est√° mais se desenvolvendo. </li><li>  N√£o confie nos odiadores de UDP que dizem que n√£o funcionar√£o no espa√ßo do usu√°rio.  Todos esses problemas podem ser resolvidos.  Experimente - este √© o futuro pr√≥ximo. </li><li>  Se voc√™ n√£o acredita, pode e deve tocar na rede com as m√£os.  Eu mostrei como quase tudo pode ser verificado. </li></ul><br>  Voc√™ leu tudo e descobriu o que vem depois? <br><br><ul><li>  Configure o protocolo (TCP, UDP - n√£o importa) para a situa√ß√£o (perfil de rede + perfil de carga). </li><li>  Use as receitas TCP que eu lhe disse: TFO, send / recv buffer, TLS1.3, CC ... </li><li>  Fa√ßa seus protocolos UDP se voc√™ tiver os recursos. </li><li>  Se voc√™ fez o seu UDP, verifique na lista de verifica√ß√£o do UDP que voc√™ fez tudo o que precisa.  Esquecendo qualquer bobagem como ritmo, n√£o vai funcionar. </li></ul><br>  Se voc√™ n√£o tiver os recursos, prepare sua infraestrutura para o QUIC.  Mais cedo ou mais tarde ele vir√° at√© voc√™. <br><br><blockquote>  Estamos determinando o futuro.  Decidimos quais protocolos usar.  Se voc√™ quiser usar o QUIC - use-o, se quiser o seu UDP ou permanecer no TCP - decida voc√™ mesmo o futuro. </blockquote><br><h3>  Links √∫teis </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Milh√µes de v√≠deo chamadas por dia ou "Ligue para a m√£e!"</a>  . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estamos escrevendo nosso protocolo sobre o UDP</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Podcast sobre otimiza√ß√£o de rede</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aumente a velocidade de transfer√™ncia de dados em redes ruins</a> . </li></ul><br><blockquote>  At√© 7 de setembro, voc√™ ainda pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">enviar uma inscri√ß√£o</a> para o Moscow <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HighLoad ++</a> e compartilhar como voc√™ prepara seus servi√ßos para altas cargas.  Mas o programa j√° est√° sendo gradualmente preenchido, dos relat√≥rios do Odnoklassniki foram recebidos na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nova arquitetura do</a> gr√°fico de amigos, na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">otimiza√ß√£o do servi√ßo de presentes</a> para altas cargas e no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que fazer</a> se voc√™ otimizou tudo e os dados n√£o chegam ao usu√°rio com rapidez suficiente. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461829/">https://habr.com/ru/post/pt461829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461817/index.html">CMake e C ++ - irm√£os para sempre</a></li>
<li><a href="../pt461819/index.html">Por que o design simples de sites √© melhor cientificamente</a></li>
<li><a href="../pt461821/index.html">Nova imunoterapia removeu todos os tumores de uma mulher com c√¢ncer de mama metast√°tico</a></li>
<li><a href="../pt461823/index.html">Quatro regras aprimoradas para design de software</a></li>
<li><a href="../pt461827/index.html">Desenvolvimento de aplicativos h√≠bridos PHP / Go usando RoadRunner</a></li>
<li><a href="../pt461831/index.html">StealthWatch: Implanta√ß√£o e Personaliza√ß√£o. Parte 2</a></li>
<li><a href="../pt461833/index.html">N√£o se perca em tr√™s pinheiros: uma representa√ß√£o egoc√™ntrica do meio ambiente</a></li>
<li><a href="../pt461835/index.html">Como os gr√°ficos de Gantt simplificam e capacitam o gerenciamento de projetos</a></li>
<li><a href="../pt461841/index.html">PVS-Studio olhou para o Bullet Engine do Red Dead Redemption</a></li>
<li><a href="../pt461845/index.html">Investimentos em bolsa como forma de preservar finan√ßas: 3 m√©todos de trabalho</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>