<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò™ üë®üèΩ‚Äçü§ù‚Äçüë®üèª üìá Bereaksi obrolan multi-pengguna dengan Chatix backend üå≥ üß¶ üêæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekarang saya akan menunjukkan kepada Anda bagaimana membuat obrolan untuk tim / pengguna / teman jika Anda tidak memiliki backend Anda atau tidak ing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bereaksi obrolan multi-pengguna dengan Chatix backend</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474492/"><p><img src="https://habrastorage.org/getpro/habr/post_images/d7e/212/ac4/d7e212ac471c99b0cd61dd0e75aab281.png" alt="Ruang obrolan Chatix"></p><br><p>  Sekarang saya akan menunjukkan kepada Anda bagaimana membuat obrolan untuk tim / pengguna / teman jika Anda tidak memiliki backend Anda atau tidak ingin menghabiskan waktu mengembangkannya.  Kami akan membuat obrolan teks sederhana dan itu akan memakan waktu sekitar satu jam. </p><br><p> Untuk menulis obrolan jaringan yang berfungsi tanpa backend hampir tidak mungkin, itu harus dalam satu atau lain bentuk.  Kami akan menggunakan Chatix dan JavaScript SDK-nya.  Chatix dan SDK akan terlibat dalam penyimpanan pesan dan tugas-tugas jaringan, dan kami akan berurusan dengan front-end. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode proyek yang sudah selesai tersedia di GitHub</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Demo</a> </p><a name="habracut"></a><br><h2 id="struktura-proekta">  Struktur proyek </h2><br><ul><li>  Aplikasi (komponen root dari aplikasi, bertindak sebagai penjaga negara, karena dalam pelajaran ini kami tidak akan menambahkan Redux atau manajer negara lainnya) <br><ul><li>  Header (tajuk aplikasi kami yang menampilkan logo, nama obrolan dan memungkinkan pengguna untuk menulis nama mereka) </li><li>  LogoHeader </li><li>  Roomtitle </li><li>  Main </li><li>  Daftar Anggota (daftar obrolan) <br><ul><li>  MemberItem [] </li></ul></li><li>  ChatField (wadah untuk semua yang berhubungan dengan pesan obrolan) <br><ul><li>  Messagecontainer </li><li>  Pesan [] (presentasi pesan; dalam pelajaran ini kami hanya akan bekerja dengan pesan teks) </li><li>  SendMessageForm (formulir untuk mengirim pesan obrolan baru) </li></ul></li><li>  ChatixSDK (komponen tanpa kepala yang bertanggung jawab untuk bekerja dengan backend) </li></ul></li></ul><br><blockquote> Catatan penting tentang penyimpanan negara.  Tentu saja, akan lebih mudah untuk menambahkan Redux di sini dan memproses perubahan keadaan melalui itu, tetapi untuk menghemat waktu, kami akan menyimpan status dalam komponen root dari App dan akan meneruskan data ke komponen anak dan memanggil orang tua mereka dari metode anak. <br>  Misalnya, ketika kita mendapatkan nama obrolan, kita akan menyimpannya dalam status komponen Aplikasi dan meneruskannya melalui <code>props</code> : <code>App ‚Üí Header ‚Üí RoomTitle</code> .  Ketika pengguna menulis pesan, kami akan mentransfernya dari SendMessageForm ke Aplikasi: <code>SendMessageForm ‚Üí ChatField ‚Üí Main ‚Üí App</code> . </blockquote><p>  Obrolan kami akan terlihat seperti ini dalam desain: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d1e/096/b73/d1e096b7349824c510542cc215ae437e.png" alt="chatix.io"></p><br><h2 id="vzaimodeystvie-mezhdu-komponentami">  Interaksi antar komponen </h2><br><p>  Komponen kita harus mengirimkan data satu sama lain dan agar semuanya berfungsi sebagaimana mestinya, mari kita tentukan sekarang bagaimana mereka akan saling berinteraksi. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fde/009/821/fde0098218938f714d32a58ad9776ec9.png" alt="Interaksi Komponen"></p><br><p>  Seperti yang Anda lihat pada gambar, komponen utama bagi kami adalah <code>App</code> , yang menyediakan data ke komponen anak (karena reaktivitas, kami cukup menetapkan <code>prop</code> dan komponen anak akan merespons perubahan), dan komponen anak berturut-turut meneruskan metode panggilan ke <code>App</code> .  Ini bukan arsitektur terbaik yang dapat (dan harus) dilakukan untuk proyek produksi, tetapi akan dilakukan untuk pelajaran kita. </p><br><h2 id="sozdanie-proekta">  Pembuatan proyek </h2><br><h3 id="sozdaem-vizualnye-komponenty">  Buat komponen visual </h3><br><h4 id="shapka">  Topi </h4><br><ol><li><p>  Pertama, Anda perlu membuat proyek baru, untuk ini kami akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">create-react-app</a> . </p><br><pre> <code class="plaintext hljs">npx create-react-app chatix-chatroom cd chatix-chatroom</code> </pre> <br><p>  Jalankan proyek dengan perintah </p><br><pre> <code class="plaintext hljs">npm start</code> </pre> <br></li><li><p>  Mari kita mulai dengan membuat tajuk. <br>  Pertama, tambahkan logo ke header.  Untuk melakukan ini, di dalam folder src, buat folder <strong>komponen</strong> , dan di dalamnya folder <strong>logo_header</strong> .  Kami mengunggah logo ke folder ini dan membuat 2 <strong>file LogoHeader.js</strong> dan <strong>LogoHeader.css</strong> </p><br></li></ol><br><p>  <strong>LogoHeader.js</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react' import logo from './chatix_logo.svg'; import './LogoHeader.css'; function LogoHeader(){ return ( &lt;div className="LogoHeader"&gt; &lt;img src={logo} className="App-logo" alt="Chatix logo" /&gt; &lt;/div&gt; ); } export default LogoHeader;</code> </pre> <br><p>  <strong>LogoHeader.css</strong> </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.LogoHeader</span></span>{ <span class="hljs-attribute"><span class="hljs-attribute">flex-basis</span></span>: <span class="hljs-number"><span class="hljs-number">200px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-grow</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-shrink</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Semuanya jelas di sini, dalam komponen ini file dengan logo dan gaya hanya diimpor. </p><br><p>  Saya tidak akan menambahkan kode untuk stylesheet di sini lagi, Anda dapat melihatnya di halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek yang sudah selesai</a> </p><br><p>  Sekarang tampilkan nama ruang obrolan.  Untuk melakukan ini, buat folder <strong>judul-kamar</strong> dan di dalamnya komponen <strong>RoomTitle</strong> .  Kami akan membuang nama ke komponen ini melalui alat peraga, jadi kami menulis <code>props.chatroomName</code> dan sekarang kami akan mentransfernya di sini. </p><br><p>  <strong>Roomtitle</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './RoomTitle.css'; function RoomTitle(props){ return ( &lt;div className="RoomTitle"&gt; &lt;h1&gt;{props.chatroomName}&lt;/h1&gt; &lt;/div&gt; ); } export default RoomTitle;</code> </pre> <br><p>  Lalu kita buat komponen tajuk itu sendiri dan tempat logo dan nama ruang obrolan di dalamnya.  Segera buang nama obrolan ke komponen anak melalui prop <code>chatroomName</code> . </p><br><p>  Saya mengingatkan Anda bahwa kami sepakat bahwa semua data (status aplikasi) akan disimpan oleh komponen root dari <strong>App</strong> .  Dari sini kita akan mentransfer header pertama ke <strong>Header</strong> dan dari <strong>Header</strong> ke <strong>RoomTitle</strong> . </p><br><p>  <strong>komponen \ header \ Header.js</strong> </p><br><p>  <strong>Header.js</strong> </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './Header.css' import LogoHeader from '../logo_header/LogoHeader'; import RoomTitle from '../room-title/RoomTitle'; function Header(props) { return ( &lt;header&gt; &lt;LogoHeader/&gt; &lt;RoomTitle chatroomName={props.chatroomName} /&gt; &lt;/header&gt; ); } export default Header;</code> </pre> <br><p>  Selanjutnya, buka file <strong>App.js</strong> dan tambahkan komponen <strong>Header.js</strong> ke <strong>dalamnya</strong> . <br>  Lalu kami menambahkan nama ke <strong>negara dan</strong> meneruskannya ke <strong>header</strong> melalui <strong>alat peraga</strong> . <br>  Juga di header Anda perlu menambahkan nama pengguna saat ini.  Untuk melakukan ini, tambahkan objek pengguna ke negara dan juga meneruskannya ke header </p><br><pre> <code class="plaintext hljs">import React from 'react'; import './App.css'; import Header from './components/header/Header'; class App extends React.Component { constructor(props){ super(props); chatroomName: '-', me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } } render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} /&gt; &lt;/div&gt; ); }; } export default App;</code> </pre> <br><p>  Sekarang di tajuk Anda perlu menambahkan input dengan nama pengguna saat ini dan menetapkan penangan untuk perubahan sehingga kami dapat mentransfer nama pengguna baru ke komponen <strong>Aplikasi</strong> . </p><br><p>  Untuk melakukan ini, kita menambahkan fungsi <code>handleChangeName</code> <code>props.updateVisitor</code> ke input dengan nama dan memanggil fungsi callback <code>props.updateVisitor</code> di mana kita melewati objek pengguna dengan nama yang diperbarui. </p><br><p>  <strong>Header.js</strong> </p><br><pre> <code class="plaintext hljs">function Header(props) { const [name, setName] = useState(props.me.name ? props.me.name : props.me.uuid.substr(-10)) const handleChangeName = (e) =&gt; { setName(e.target.value) let visitor = {...props.me}; visitor.name = e.target.value; props.updateVisitor(visitor) } return ( &lt;header&gt; &lt;LogoHeader/&gt; &lt;RoomTitle chatroomName={props.chatroomName}/&gt; { props.me ? &lt;input className='name-input' value={name} placeholder=' ' onChange={(e) =&gt; handleChangeName(e)} /&gt; : null } &lt;/header&gt; ); }</code> </pre> <br><p>  Sekarang tambahkan fungsi ini <code>props.updateVisitor</code> ke <strong>Aplikasi</strong> dan <code>props.updateVisitor</code> ke <code>props.updateVisitor</code> .  Sejauh ini, ia hanya memperbarui objek pengguna di negara bagian, tetapi kemudian melaluinya kami akan memperbarui pengguna di server. </p><br><pre> <code class="plaintext hljs">onUpdateVisitor = (visitor) =&gt; { this.setState({me: visitor}) }</code> </pre> <br><p>  Jadi, sekarang aplikasi kita terlihat seperti ini dan sejauh ini hanya tahu cara memperbarui nama.  Pindah </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/685/7ec/243/6857ec2435f476e8d6dad5201d7909a5.png" alt="Header ruang obrolan"></p><br><h4 id="saydbar">  Bilah samping </h4><br><p>  Sekarang mari kita mulai membuat sidebar. <br>  <strong>Bilah</strong> samping akan berada di dalam komponen utama pada halaman <strong>Main.js.</strong> <br>  Kami membuatnya <strong>komponen \ main \ Main.js</strong> , kemudian membuat komponen dengan daftar <strong>komponen</strong> pengguna <strong>\ anggota-daftar \ MemberList.js</strong> dan segera membuat komponen yang akan menampilkan <strong>komponen itu</strong> sendiri kepada pengguna <strong>\ komponen-anggota \ MemberItem.js</strong> . </p><br><p>  Untuk memperjelas bagaimana 3 komponen ini terkait, lihat garis besar proyek di awal artikel. </p><br><p>  Komponen dibuat, sekarang mari kita mulai. <br>  Pertama, tambahkan array pengguna ke status komponen <strong>App</strong> dan tambahkan komponen <strong>Utama</strong> .  Kemudian kami akan meneruskan pengguna ini ke dalamnya. </p><br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs">class App extends React.Component { constructor(props) { super(props); this.state = { chatroomName: '-', members: [ { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" }, { is_online: true, name: "", uuid: "mnzxcv97zx6chvo" }, { is_online: false, name: "", uuid: "kjuhv987ashdfoua" }, { is_online: false, name: "", uuid: "jdhnf978WEHJSNDL" }, ], me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } }; } render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} /&gt; &lt;Main members={this.state.members} me={this.state.me} /&gt; &lt;/div&gt; ); }; }</code> </pre> <br><p>  Di komponen <strong>utama</strong> , tambahkan komponen <strong>MemberList</strong> dan teruskan array pengguna ke dalamnya. </p><br><p>  <strong>Main.js</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList members={props.members} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  Dan dalam komponen <strong>MemberList,</strong> kita mengulangi semua pengguna dan untuk masing-masing mengembalikan komponen <strong>MemberItem</strong> dan meneruskan objek pengguna ke sana. </p><br><p>  <strong>MemberList.js</strong> </p><br><pre> <code class="plaintext hljs">function MemberList(props) { const members = props.members.map((member) =&gt; &lt;MemberItem key={member.uuid} member={member} /&gt; ); return ( &lt;section className="MemberList"&gt; {members} &lt;/section&gt; ); }</code> </pre> <br><p>  Komponen <strong>MemberItem</strong> sudah langsung menampilkan pengguna di sidebar.  Di dalamnya, kami memeriksa nama pengguna, jika tidak diinstal, kemudian menampilkan 10 karakter pertama dari pengidentifikasi.  Kami juga memeriksa status online / offline dan membandingkan pengidentifikasi dengan pengidentifikasi pengguna saat ini, sehingga di seberangnya dia akan menampilkan tanda "(Anda)". </p><br><pre> <code class="plaintext hljs">function MemberItem(props) { function getName(){ let name = '' if (props.member.uuid === props.me.uuid) { if(props.me.name) { name = props.me.name } else { name = props.me.uuid.substring(props.me.uuid.length-10, props.me.uuid.length); } } else { if(props.member.name){ name = props.member.name } else { name = props.member.uuid.substring(props.member.uuid.length-10, props.member.uuid.length); } } return name; } return( &lt;div className="MemberItem"&gt; &lt;img src={ icon } alt={ props.member.name }/&gt; &lt;span&gt; { getName() } { props.member.uuid === props.me.uuid &amp;&amp; " () " } &lt;/span&gt; { props.member.is_online &amp;&amp; &lt;span className="online"&gt;‚Ä¢&lt;/span&gt; } &lt;/div&gt; ); }</code> </pre> <br><p>  Selesai  Sekarang aplikasi sudah terlihat seperti ini </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eba/512/a8b/eba512a8bca7de4b1487567775f7742b.png" alt="Header ruang obrolan"></p><br><h4 id="spisok-soobscheniy-i-forma-otpravki">  Daftar Pesan dan Formulir Pengiriman </h4><br><p>  Sekarang kita akan berurusan dengan daftar pesan dan formulir pengiriman. <br>  Pertama, tambahkan array dengan pesan ke status komponen <strong>App</strong> . </p><br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs">this.state = { chatroomName: '-', messages: [ { content: " 1", sender_id: "mnzxcv97zx6chvo", uuid: "dg897sdfg" }, { content: " 2", sender_id: "98s7dfh9a8s7dhf", uuid: "8723hernm" }, { content: "  ", sender_id: "mnzxcv97zx6chvo", uuid: "435nbcv98234" } ], members: [ { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" }, { is_online: true, name: "", uuid: "mnzxcv97zx6chvo" }, { is_online: false, name: "", uuid: "kjuhv987ashdfoua" }, { is_online: false, name: "", uuid: "jdhnf978WEHJSNDL" }, ], me: { is_online: true, name: "", uuid: "98s7dfh9a8s7dhf" } };</code> </pre> <br><p>  Dan meneruskannya ke komponen <strong>Utama</strong> </p><br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs"> &lt;Main members={this.state.members} messages={this.state.messages} me={this.state.me} /&gt;</code> </pre> <br><p>  Sekarang buat komponen <strong>conponents / chat-field / ChatField.js</strong> <br>  Hubungkan ke <strong>Main</strong> dan teruskan pesan ke sana. </p><br><p>  <strong>Main</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList me={props.me} members={props.members} /&gt; &lt;ChatField messages={props.messages} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  Selanjutnya, buat komponen <strong>conponents / message-container / MessageContainer.js</strong> <br>  Hubungkan ke <strong>ChatField</strong> dan teruskan pesan ke sana. </p><br><p>  <strong>Bidang obrolan</strong> </p><br><pre> <code class="plaintext hljs">function Main(props) { return( &lt;section className="Main"&gt; &lt;MemberList me={props.me} members={props.members} /&gt; &lt;ChatField messages={props.messages} /&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  Kemudian kita akan mengulang semua pesan dan untuk masing-masing mengembalikan komponen yang akan menampilkannya. <br>  Mari kita buat itu <strong>conponents / message / Message.js</strong>  Di dalamnya kami menampilkan ikon pengunjung, namanya atau pengidentifikasi jika namanya tidak ditentukan dan teks pesan itu sendiri. </p><br><p>  <strong>Pesan</strong> </p><br><pre> <code class="plaintext hljs">function Message(props) { const getSenderName = () =&gt; { if (props.sender) { return props.sender.name ? props.sender.name : props.sender.uuid.substr(-10); } return "Unknown sender"; }; return( &lt;div className="Message"&gt; &lt;div className="message-sender-icon"&gt; &lt;img src={icon} alt="visitor icon"/&gt; &lt;/div&gt; &lt;div className="message-bubble"&gt; &lt;div className="message-sender-name"&gt;{getSenderName()}&lt;/div&gt; &lt;div className="message-content"&gt;{props.message.content}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); }</code> </pre> <br><p>  Sekarang, di <strong>MessageContainer, kita</strong> mengulang semua pesan dan untuk masing-masing mengembalikan komponen <strong>Pesan</strong> yang kita lewati objek pesan </p><br><p>  <strong>Messagecontainer</strong> </p><br><pre> <code class="plaintext hljs">function MessageContainer(props) { const messageList = props.messages.map(message =&gt; &lt;Message key={message.uuid} sender={props.members.find((member) =&gt; member.uuid === message.sender_id)} message={message} /&gt; ); return ( &lt;section className="MessageContainer" ref={messagesContainer}&gt; {messageList} &lt;/section&gt; ); }</code> </pre> <br><p>  Sekarang proyeknya terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/74d/cad/f22/74dcadf22a3086fa2d7182e1aa791cab.png" alt="Ruang obrolan pesan"></p><br><p>  Sekarang buat komponen dengan formulir untuk mengirim <strong>komponen</strong> pesan <strong>/ send-message-form / SendMessageForm.js</strong> .  Di dalamnya, kami akan membuat input dan tombol untuk mengirim.  Ketika input berubah, teks darinya ditulis ke status, dan saat Anda mengklik tombol, kami memanggil fungsi panggilan balik <code>onSendNewMessage</code> dan mentransfer pesan dari status ke status tersebut.  <code>onSendNewMessage</code> akan membuat fungsi <code>onSendNewMessage</code> sedikit kemudian di komponen <strong>App</strong> dan meneruskannya melalui alat peraga. </p><br><p>  <strong>Bentuk sendmessage</strong> </p><br><pre> <code class="plaintext hljs">class SendMessageForm extends React.Component { constructor(props) { super(props); this.state = { message: '' }; } currentMessageChanged = (e) =&gt; { this.setState({message: e.target.value }); } sendMessageClicked = async (e) =&gt; { e.preventDefault(); if (this.state.message.length &gt; 0) { await this.props.onSendNewMessage(this.state.message); this.setState({...this.state, ...{message : ''}}); } } render(){ return ( &lt;section className="SendMessageForm"&gt; &lt;form&gt; &lt;input type="text" value={this.state.message} onChange={this.currentMessageChanged} placeholder="Type message to send"/&gt; &lt;button type="submit" onClick={this.sendMessageClicked} &gt; Send &lt;/button&gt; &lt;/form&gt; &lt;/section&gt; ); } }</code> </pre> <br><p>  Sekarang tempatkan komponen <strong>SendMessageForm</strong> di dalam <strong>ChatField</strong> . </p><br><p>  <strong>Bidang obrolan</strong> </p><br><pre> <code class="plaintext hljs">function ChatField(props) { return( &lt;section className="ChatField"&gt; &lt;MessageContainer members={props.members} messages={props.messages} /&gt; &lt;SendMessageForm onSendNewMessage={props.onSendNewMessage}/&gt; &lt;/section&gt; ); }</code> </pre> <br><p>  Di komponen <strong>Utama</strong> , kami juga akan <code>onSendNewMessage</code> fungsi <code>onSendNewMessage</code> di <strong>ChatField</strong> . </p><br><p>  <strong>Main</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatField members={props.members} messages={props.messages} onSendNewMessage={props.onSendNewMessage} /&gt;</code> </pre> <br><p>  Sekarang buat fungsi ini di <strong>App</strong> dan teruskan ke <strong>Main</strong> . </p><br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs">onSendNewMessage = async (message) =&gt; { console.log(message) }</code> </pre> <br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs">&lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt;</code> </pre> <br><p>  Selesai  Sekarang, ketika Anda mengklik tombol kirim pesan, itu akan ditransfer ke komponen <strong>Aplikasi</strong> . <br>  Sekarang aplikasi terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e53/89e/d31/e5389ed317bd0fb4bf87db34b05f57a6.png" alt="Ruang obrolan akhir"></p><br><p>  Jadi, sekarang semuanya ditampilkan di aplikasi kami dan semuanya berfungsi sebagaimana mestinya, tetapi sejauh ini dengan data statis, dan untuk merevitalisasi obrolan kami, Anda harus menghubungkannya dengan backend. </p><br><h4 id="podklyuchenie-bekenda">  Koneksi backend </h4><br><p>  Untuk melakukan ini, hal pertama yang perlu Anda lakukan adalah menginstal paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">chatix-core</a> . </p><br><pre> <code class="plaintext hljs">npm i chatix-core</code> </pre> <br><p>  Kemudian buat akun di <strong>chatix</strong> dan buat ruang obrolan.  Untuk melakukan ini, buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">chatix.io</a> dan daftar. <br>  Setelah mendaftar, Anda dapat melihat <strong>pengidentifikasi</strong> situs <strong>webId</strong> di antarmuka admin pada halaman pengaturan obrolan. </p><br><p>  Sekarang kami membuat ruang obrolan baru yang dengannya kami akan bekerja. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/38b/26d/034/38b26d03464c1b236beff17c4118ba00.png" alt="Membuat ruang obrolan"></p><br><p>  Kami kembali ke proyek kami dan membuat komponen baru di mana kami akan bekerja dengan server. <br>  <strong>komponen \ chatix \ ChatixSDK.js</strong> </p><br><p>  Kami mengimpor <strong>ChatixCore di dalamnya.</strong> </p><br><pre> <code class="plaintext hljs">import ChatixCore from 'chatix-core';</code> </pre> <br><p>  Di komponen <strong>ChatixSDK,</strong> buat turunan dari kelas <strong>ChatixCore</strong> dan lulus situs <strong>webID</strong> sebagai argumen. </p><br><pre> <code class="plaintext hljs">const websiteId = "_WEBSITE_ID"; this.sdk = new ChatixCore(websiteId);</code> </pre> <br><p>  Sekarang di <strong>this.sdk</strong> Anda dapat menggunakan metode untuk bekerja dengan ruang obrolan.  Anda dapat melihat daftar metode pada halaman proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">chatix-core</a> </p><br><p>  Selanjutnya, kita perlu terhubung ke server dan mendapatkan data tentang ruang obrolan yang dibuat sebelumnya.  Ada metode asinkron <strong>mulai ()</strong> dan <strong>getChatroom () untuk ini</strong> . </p><br><p>  Setelah Anda menerima objek ruang obrolan, mari segera ambil namanya dan transfer ke <strong>Aplikasi</strong> .  Untuk melakukan ini, tambahkan fungsi callback <code>updateChatroomTitle(chatroom.title)</code> di <strong>App</strong> dan panggil di <strong>ChatixSDK</strong> . </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">class ChatixSDK extends React.Component { constructor(props){ super(props); const websiteId = "_WEBSITE_ID"; this.chatroomId = "_CHATROOM_ID"; this.sdk = new ChatixCore(websiteId); this.sdk.start() .then( async () =&gt; { try { // refresh information about chatroom and call passed handler const chatroom = await this.sdk.getChatroom(this.chatroomId); if (props.updateChatroomTitle) { props.updateChatroomTitle(chatroom.title); } } catch (err) { console.error(err); } }) .catch((e) =&gt; { console.error(e); }); } render(){ return null; } }</code> </pre> <br><p>  Anda dapat melihat <code>this.chatroomId</code> di antarmuka manajer dengan membuka ruang obrolan yang diinginkan. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/57d/309/a77/57d309a77bb226589ba225c52cfe37d6.png" alt="ChatroomID"></p><br><p>  Sekarang di <strong>Aplikasi</strong> kita akan menghubungkan komponen <strong>ChatixSDK</strong> dan membuang fungsi updateChatroomTitle ke dalamnya, yang akan memperbarui nama obrolan.  Kami juga menambahkan tautan <code>ref</code> ke dalamnya sehingga kami dapat mengakses komponen ini. </p><br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs">this.chatixSDK = React.createRef();</code> </pre> <br><pre> <code class="plaintext hljs">setChatroomTitle = (newName) =&gt; { const newStateFragment = { chatroomName: newName}; this.setState({...this.state, ...newStateFragment}); };</code> </pre> <br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs">render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} updateVisitor={this.onUpdateVisitor} /&gt; &lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt; &lt;ChatixSDK ref={this.chatixSDK} updateChatroomTitle={this.setChatroomTitle} /&gt; &lt;/div&gt; ); };</code> </pre> <br><p>  Selesai  Sekarang, segera setelah terhubung ke server, kami meminta data obrolan, mendapatkan namanya dan menuliskannya ke status komponen <strong>Aplikasi</strong> , dan karena perubahan status menyebabkan komponen dirender lagi, nama di header akan diperbarui secara otomatis.  Sekarang nama default di negara bagian dapat diganti dengan string kosong. </p><br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs">chatroomName: ''</code> </pre> <br><p>  Sekarang mari kita isi bilah sisi dengan pengguna nyata. <br>  Tetapi sebelum Anda mendapatkan daftar pengguna yang perlu Anda sambungkan ke obrolan, untuk ini, di <strong>ChatixSDK</strong> di dalam fungsi <code>this.sdk.start()</code> kami mendapatkan daftar semua ruang obrolan pengguna, periksa apakah itu terhubung ke obrolan saat ini dan jika tidak, maka sambungkan. </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">const myChatrooms = await this.sdk.getMyChatrooms(); if (myChatrooms.filter(x =&gt; x.id===this.chatroomId).length === 0) { await this.sdk.connectToChatroom(this.chatroomId); }</code> </pre> <br><p>  Setelah kami memastikan bahwa pengguna kami terhubung ke ruang obrolan, kami bisa mendapatkan daftar peserta dalam obrolan ini. </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">// lets get all chatroom members using infinite loop with break on empty server response let membersPage = 1; let allChatroomMembers = []; while(true) { let pagedMembers = await this.sdk.getChatroomMembers(this.chatroomId, membersPage++, 10); allChatroomMembers = [...allChatroomMembers, ...pagedMembers]; if (pagedMembers.length === 0) { break; } }</code> </pre> <br><p>  Di sini, dalam loop tak terbatas, kami meminta pengguna halaman demi halaman sampai kami mendapatkan semua orang, segera setelah kami mendapatkan semua orang, kami memutus loop.  Setelah itu, seperti nama ruang obrolan, kami meneruskannya ke komponen induk menggunakan fungsi panggilan balik. </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">if (props.setChatroomMembers) { props.setChatroomMembers(allChatroomMembers); }</code> </pre> <br><p>  Sekarang, di komponen <strong>App</strong> , buat fungsi callback ini <code>setChatroomMembers</code> yang akan mengurutkan pengguna berdasarkan status online / offline dan berdasarkan abjad dan merekamnya dalam keadaan. </p><br><p>  <strong>App.js</strong> </p><br><pre> <code class="plaintext hljs">setChatroomMembers = (members) =&gt; { members.sort(this.sortMembers); const newStateFragment = { members: members}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p>  Tambahkan fungsi sortir <strong>sortMembers</strong> .  Ini mengurutkan pengguna berdasarkan status dan abjad. </p><br><p>  <strong>App.js</strong> </p><br><pre> <code class="plaintext hljs">sortMembers(a, b) { if (a.is_online === true &amp;&amp; b.is_online === false) { return -1; } else if (b.is_online === true &amp;&amp; a.is_online === false) { return 1; } else { if (a.name &amp;&amp; b.name) { if (a.name.toLocaleUpperCase() &gt; b.name.toLocaleUpperCase()) { return 1; } else if (a.name.toLocaleUpperCase() &lt; b.name.toLocaleUpperCase()) { return -1; } } else if (a.name &amp;&amp; !b.name) { return -1; } else if (!a.name &amp;&amp; b.name) { return 1; } if (a.uuid &gt; b.uuid) { return -1; } else { return 1; } } }</code> </pre> <br><p>  Selanjutnya, kita meneruskan fungsi setChatroomMembers di <strong>ChatixSDK</strong> . </p><br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs">render() { return ( &lt;div className="App"&gt; &lt;Header chatroomName={this.state.chatroomName} me={this.state.me} updateVisitor={this.onUpdateVisitor} /&gt; &lt;Main members={this.state.members} messages={this.state.messages} onSendNewMessage={this.onSendNewMessage} me={this.state.me} /&gt; &lt;ChatixSDK ref={this.chatixSDK} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} /&gt; &lt;/div&gt; ); };</code> </pre> <br><p>  Sekarang, segera setelah terhubung ke server, kami, serta dengan tajuk, meminta daftar semua pengguna yang terhubung dan menuliskannya ke status komponen <strong>App</strong> .  Dan juga mengubah nilai default daftar pengguna di negara bagian. </p><br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs">members: []</code> </pre> <br><p>  Sekarang, dengan prinsip yang persis sama, kita mendapatkan objek dari pengguna saat ini dan berbagai pesan dan juga menuliskannya ke status <strong>Aplikasi</strong> </p><br><p>  <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">// lets load 100 last messages from current chatroom const lastMessages = await this.sdk.getChatroomMessages(this.chatroomId, null, 100); if (props.setChatroomMessages) { props.setChatroomMessages(lastMessages); } if (props.setMe) { const me = this.sdk.getVisitor(); this.props.setMe(me); }</code> </pre> <br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatixSDK ref={this.chatixSDK} setMe={this.setMe} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} setChatroomMessages={this.setChatroomMessages} /&gt;</code> </pre> <br><p>  Selanjutnya, kami akan mengirim pesan. </p><br><p>  Kami di <strong>App</strong> sudah memiliki fungsi <code>onSendNewMessage</code> yang menampilkan mengirim pesan ke konsol.  Sebagai gantinya, kami hanya akan memanggil metode <code>sendChatroomMessage</code> untuk mengirim pesan dari <strong>ChatixSDK</strong> . <br>  Ini adalah metode asinkron dan mengembalikan objek pesan yang dikirim dalam respons, yang segera kami tambahkan ke larik pesan di negara bagian.  Omong-omong, harap perhatikan bahwa kami <code>this.chatixSDK</code> tautan <code>this.chatixSDK</code> dibuat sebelumnya. </p><br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs">onSendNewMessage = async (message) =&gt; { let receivedMsg = await this.chatixSDK.current.sendChatroomMessage(message); const currentMessages = this.state.messages; currentMessages.push(receivedMsg); const newStateFragment = {messages: currentMessages}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p>  Karena perubahan dalam kondisi menyebabkannya dibuat ulang, daftar pesan akan diperbarui secara otomatis.  Tetapi kita perlu memastikan bahwa saat menambahkan pesan, gulir di blok pesan turun. </p><br><p>  Untuk melakukan ini, buka komponen <strong>MessageContainer</strong> dan gunakan hook <strong>useEffect,</strong> monitor array pesan untuk perubahan, dan segera setelah itu berubah dan pesan telah ditambahkan, kita mendapatkan blok <strong>scrollHeight</strong> dengan pesan dan gulir dengan jumlah yang sama </p><br><pre> <code class="plaintext hljs">function MessageContainer(props) { const messagesContainer = React.createRef(); useEffect(() =&gt; { messagesContainer.current.scrollTop = messagesContainer.current.scrollHeight }, [props, messagesContainer]); const messageList = props.messages.map(message =&gt; &lt;Message key={message.uuid} sender={props.members.find((member) =&gt; member.uuid === message.sender_id)} message={message} /&gt; ); return ( &lt;section className="MessageContainer" ref={messagesContainer}&gt; {messageList} &lt;/section&gt; ); }</code> </pre> <br><p>  Sekarang mari kita selesaikan memperbarui nama pengguna.  Kami telah membuat input di header dan ketika mengubahnya, kami meneruskan objek pengguna yang diperbarui ke komponen <strong>App</strong> dan di sana kami menampilkannya di konsol.  Mari selesaikan fungsi ini.  Untuk melakukan ini, tambahkan metode panggil <code>this.chatixSDK.current.updateVisitor(user)</code> ke dalamnya, ini akan memperbarui data di server.  Dan cukup perbarui data di negara bagian, untuk ini kami perbarui objek <code>this.state.me</code> dan dalam array <code>this.state.members</code> juga menemukan pengguna saat ini dan memperbaruinya.  Ini diperlukan untuk memperbarui nama pengguna saat ini dalam pesan yang dikirim kepada mereka. </p><br><p>  <strong>Aplikasi</strong> </p><br><pre> <code class="plaintext hljs">onUpdateVisitor = (user) =&gt; { this.chatixSDK.current.updateVisitor(user) this.setMe(user) let currentUser = this.state.members.find((member) =&gt; (member.uuid === user.uuid)) let currentUserIndex = this.state.members.indexOf(currentUser) let newMembers = [...this.state.members] newMembers[currentUserIndex] = user; this.setState({ members: newMembers }) }</code> </pre> <br><p>  Sekarang kita perlu belajar bagaimana menanggapi pesan yang masuk, menghubungkan / memutus pengguna dan mengubah informasi dan pengguna yang terhubung. </p><br><p>  Untuk melakukan ini, dalam file <strong>ChatixSDK.js</strong> di konstruktor, kita perlu mengganti fungsi callback.  Anda dapat melihat daftar lengkap fungsi dan argumen di halaman proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">chatix-core</a> . </p><br><p>  Kami <strong>saat ini</strong> tertarik pada <strong>onChatroomMessageReceived</strong> , <strong>onMemberConnectedToChatroom</strong> , <strong>onMemberDisconnectedFromChatroom</strong> dan <strong>onApplyVisitorInfo</strong> . </p><br><p>  Kami mendefinisikan ulang mereka dan untuk setiap fungsi kami memanggil panggilan balik kami yang akan kami buat di <strong>App</strong> . </p><br><pre> <code class="plaintext hljs">this.sdk.onChatroomMessageReceived = (chatroomId, message) =&gt; { if (chatroomId === this.chatroomId) { this.props.onNewMessageReceived(message); } }; this.sdk.onMemberConnectedToChatroom = (chatroomId, member) =&gt; { if (chatroomId === this.chatroomId &amp;&amp; props.addChatroomMember) { this.props.addChatroomMember(member); } }; this.sdk.onMemberDisconnectedFromChatroom = (chatroomId, member) =&gt; { if (chatroomId === this.chatroomId &amp;&amp; props.removeChatroomMember) { this.props.removeChatroomMember(member); } }; this.sdk.onApplyVisitorInfo = (visitor) =&gt; { this.props.onMemberUpdated(visitor) }</code> </pre> <br><p>  Selanjutnya, buka <strong>Aplikasi</strong> dan buat fungsi-fungsi ini. </p><br><p>  <strong>onNewMessageReceived (message)</strong> <br>  Fungsi ini mengambil objek pesan dan hanya menambahkannya untuk menyatakan dengan sisa pesan.          ,        . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">onNewMessageReceived = (message) =&gt; { const currentMessages = this.state.messages; currentMessages.push(message); const newStateFragment = {messages: currentMessages}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>App</strong> <br> <strong>addChatroomMember(member)</strong> <br>            state     members.              . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">addChatroomMember = (member) =&gt; { const newStateFragment = {}; const currentMembers = this.state.members; currentMembers.push(member); currentMembers.sort(this.sortMembers); newStateFragment.members = currentMembers; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>App</strong> <br> <strong>removeChatroomMember(memberId)</strong> <br>         state     <strong>members</strong>  <strong>state</strong> . </p><br><pre> <code class="plaintext hljs">removeChatroomMember = (memberId) =&gt; { const currentMembers = this.state.members; const filteredMembers = currentMembers.filter(x=&gt; x.uuid !== memberId); const newStateFragment = {members: filteredMembers}; this.setState({...this.state, ...newStateFragment}); }</code> </pre> <br><p> <strong>onMemberUpdated(updatedMember)</strong> <br>      .        .       <strong>state</strong>     . </p><br><p> <strong>App</strong> </p><br><pre> <code class="plaintext hljs">onMemberUpdated = (updatedMember) =&gt; { let oldMember = this.state.members.find(member =&gt; member.uuid === updatedMember.uuid); oldMember = this.state.members.indexOf(oldMember); let newStateMembers = this.state.members; newStateMembers[oldMember] = updatedMember; this.setState({ members: newStateMembers }) }</code> </pre> <br><p>      <strong>ChatixSDK</strong> </p><br><p> <strong>ChatixSDK</strong> </p><br><pre> <code class="plaintext hljs">&lt;ChatixSDK ref={this.chatixSDK} setMe={this.setMe} updateChatroomTitle={this.setChatroomTitle} setChatroomMembers={this.setChatroomMembers} addChatroomMember={this.addChatroomMember} removeChatroomMember={this.removeChatroomMember} setChatroomMessages={this.setChatroomMessages} onNewMessageReceived={this.onNewMessageReceived} onMemberUpdated={this.onMemberUpdated} /&gt;</code> </pre> <br><p>  Selesai!       \ ,   ,    /   . </p><br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">alekseyso</a> <br>  Bahan tambahan: <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SDK Chatix ()</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SDK Chatix (npm)</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">192   -</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id474492/">https://habr.com/ru/post/id474492/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id474478/index.html">Sinopsis tentang Pembelajaran Mesin. Statistik matematika. Metode kemungkinan maksimum</a></li>
<li><a href="../id474480/index.html">Bagaimana mendidik anak-anak untuk menggunakan teknologi dengan benar jika itu tidak terjadi di masa kecil Anda?</a></li>
<li><a href="../id474484/index.html">Mock bukan kruk, mock adalah spesifikasi</a></li>
<li><a href="../id474488/index.html">Siaran gratis DotNext dan HolyJS</a></li>
<li><a href="../id474490/index.html">Waktunya telah tiba: Tinjauan umum aspirator hidung Coclean</a></li>
<li><a href="../id474494/index.html">Bagaimana KTT Zabbix 2019</a></li>
<li><a href="../id474496/index.html">Database di HighLoad ++ 2019</a></li>
<li><a href="../id474498/index.html">Tutorial JavaFX: Hello World</a></li>
<li><a href="../id474500/index.html">Pengembangan plugin untuk Grafana: kisah kerucut penuh</a></li>
<li><a href="../id474502/index.html">Odnoklassniki parsing di Joker 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>