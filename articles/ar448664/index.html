<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚟 👼 👢 إنشاء بطاقات مثل Tinder على سويفت 👩🏻‍💻 🛀🏼 😖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tinder - نعلم جميعًا أن هذا هو تطبيق مواعدة حيث يمكنك ببساطة رفض أو قبول شخص ما عن طريق تمرير اليسار أو اليمين. تُستخدم الآن فكرة قارئ البطاقات في الع...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>إنشاء بطاقات مثل Tinder على سويفت</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448664/" style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/getpro/habr/post_images/2b7/15f/817/2b715f8176b64a1ccc7ec9afd35f7028.png" alt="صورة"><br><br>  Tinder - نعلم جميعًا أن هذا هو تطبيق مواعدة حيث يمكنك ببساطة رفض أو قبول شخص ما عن طريق تمرير اليسار أو اليمين.  تُستخدم الآن فكرة قارئ البطاقات في العديد من التطبيقات.  طريقة عرض البيانات هذه مناسبة لك إذا مللت من استخدام طرق عرض المجموعة والتجميع.  هناك العديد من الكتب المدرسية حول هذا الموضوع ، لكن هذا المشروع استغرقني كثيرًا من الوقت. <br><a name="habracut"></a><br>  يمكنك أن ترى المشروع الكامل على <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">جيثب</a> بلدي. <br><br>  بادئ ذي بدء ، أود أن أشيد <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">بوظيفة</a> Phill Farrugia بشأن هذه المسألة ، ثم إلى سلسلة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">YouTube</a> في استوديو Big Mountain حول موضوع مماثل.  فكيف نصنع هذه الواجهة؟  حصلت على مساعدة في نشر Phil حول هذا الموضوع.  في الأساس ، تتمثل الفكرة في إنشاء UIViews وإدراجها كعروض فرعية في عرض الحاوية.  بعد ذلك ، باستخدام الفهرس ، سنمنح كل UIView إدخالًا أفقيًا وعموديًا ونغير عرضه قليلاً.  علاوة على ذلك ، عندما نسحب إصبعًا على خريطة واحدة ، سيتم إعادة ترتيب جميع إطارات طرق العرض وفقًا لقيمة الفهرس الجديد. <br><br>  سنبدأ بإنشاء طريقة عرض حاوية في ViewController بسيط. <br><br><pre style=";text-align:right;direction:rtl"><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//MARK: - Properties var viewModelData = [CardsDataModel(bgColor: UIColor(red:0.96, green:0.81, blue:0.46, alpha:1.0), text: "Hamburger", image: "hamburger"), CardsDataModel(bgColor: UIColor(red:0.29, green:0.64, blue:0.96, alpha:1.0), text: "Puppy", image: "puppy"), CardsDataModel(bgColor: UIColor(red:0.29, green:0.63, blue:0.49, alpha:1.0), text: "Poop", image: "poop"), CardsDataModel(bgColor: UIColor(red:0.69, green:0.52, blue:0.38, alpha:1.0), text: "Panda", image: "panda"), CardsDataModel(bgColor: UIColor(red:0.90, green:0.99, blue:0.97, alpha:1.0), text: "Subway", image: "subway"), CardsDataModel(bgColor: UIColor(red:0.83, green:0.82, blue:0.69, alpha:1.0), text: "Robot", image: "robot")] var stackContainer : StackContainerView! //MARK: - Init override func loadView() { view = UIView() view.backgroundColor = UIColor(red:0.93, green:0.93, blue:0.93, alpha:1.0) stackContainer = StackContainerView() view.addSubview(stackContainer) configureStackContainer() stackContainer.translatesAutoresizingMaskIntoConstraints = false configureNavigationBarButtonItem() } override func viewDidLoad() { super.viewDidLoad() title = "Expense Tracker" stackContainer.dataSource = self } //MARK: - Configurations func configureStackContainer() { stackContainer.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true stackContainer.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: -60).isActive = true stackContainer.widthAnchor.constraint(equalToConstant: 300).isActive = true stackContainer.heightAnchor.constraint(equalToConstant: 400).isActive = true }</span></span></code> </pre> <br>  كما ترون ، قمتُ بإنشاء فصل خاص بي يسمى SwipeContainerView وقمت فقط بتكوين stackViewContainer باستخدام القيود التلقائية.  لا شيء يدعو للقلق.  سيكون حجم SwipeContainerView 300 × 400 وسيتم تركيزه على المحور X وفقط 60 بكسل فقط فوق منتصف المحور Y. <br><br>  الآن وبعد أن قمنا بتكوين stackContainer ، سننتقل إلى الفئة الفرعية من StackContainerView ونحمّل جميع أنواع الخرائط فيه.  قبل ذلك ، سنقوم بإنشاء بروتوكول يحتوي على ثلاث طرق: <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwipeCardsDataSource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">numberOfCardsToShow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">card</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emptyView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> }</code> </pre> <br>  فكر في هذا البروتوكول باعتباره TableViewDataSource.  يسمح توافق فئة ViewController لدينا مع هذا البروتوكول بنقل معلومات حول بياناتنا إلى فئة SwipeCardContainer.  لديها ثلاث طرق: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  <code>numberOfCardsToShow () -&gt; Int</code> : <code>numberOfCardsToShow () -&gt; Int</code> عدد البطاقات التي نحتاج إلى عرضها.  انها مجرد عداد مجموعة البيانات. </li><li style=";text-align:right;direction:rtl">  <code>card(at index: Int) -&gt; SwipeCardView</code> : بإرجاع SwipeCardView (سننشئ هذه الفئة في لحظة واحدة) </li><li style=";text-align:right;direction:rtl">  <code>EmptyView</code> -&gt; لن نفعل أي شيء معها ، ولكن بمجرد حذف جميع البطاقات ، فإن استدعاء طريقة التفويض هذه سيعود إلى طريقة عرض فارغة مع بعض الرسائل (لن أطبق هذا في هذا الدرس المحدد ، جربه بنفسك) </li></ol><br>  محاذاة وحدة تحكم العرض مع هذا البروتوكول: <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwipeCardsDataSource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">numberOfCardsToShow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewModelData.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">card</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> card = <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span>() card.dataSource = viewModelData[index] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> card } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">emptyView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  الطريقة الأولى ستُرجع عدد العناصر في صفيف البيانات.  في الطريقة الثانية ، قم بإنشاء مثيل SwipeCardView () جديد وإرسال بيانات الصفيف لهذا الفهرس ، ثم قم بإرجاع مثيل SwipeCardView. <br><br>  SwipeCardView هي فئة فرعية من UIView التي تحتوي على UIImage و UILabel ومعرف بالإيماءات.  المزيد عن هذا في وقت لاحق.  سوف نستخدم هذا البروتوكول للتواصل مع عرض الحاوية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs">stackContainer.dataSource = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span></code> </pre> <br>  عند إطلاق رمز أعلاه ، يتم استدعاء وظيفة reloadData ، والتي تستدعي وظائف مصدر البيانات هذه. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Class</span></span> <span class="hljs-type"><span class="hljs-type">StackViewContainer</span></span>: <span class="hljs-type"><span class="hljs-type">UIView</span></span> { . . <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataSource: <span class="hljs-type"><span class="hljs-type">SwipeCardsDataSource?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { reloadData() } } ....</code> </pre> <br>  وظيفة إعادة تحميل البيانات: <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reloadData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> datasource = dataSource <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } setNeedsLayout() layoutIfNeeded() numberOfCardsToShow = datasource.numberOfCardsToShow() remainingcards = numberOfCardsToShow <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(numberOfCardsToShow,cardsToBeVisible) { addCardView(cardView: datasource.card(at: i), atIndex: i ) } }</code> </pre> <br>  في وظيفة reloadData ، نحصل أولاً على عدد البطاقات ونخزنها في numberOfCardsToShow المتغير.  ثم نقوم بتعيين هذا إلى متغير آخر باسم باقي البطاقات.  في الحلقة for ، نقوم بإنشاء خريطة تمثل مثيل SwipeCardView باستخدام قيمة الفهرس. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..&lt;<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(numberOfCardsToShow,cardsToBeVisible) { addCardView(cardView: datasource.card(at: i), atIndex: i ) }</code> </pre> <br>  في الواقع ، نريد ظهور أقل من 3 بطاقات في وقت واحد.  لذلك ، نحن نستخدم وظيفة دقيقة.  CardsToBeVisible هو ثابت يساوي 3. إذا كان numberOfToShow أكبر من 3 ، فسيتم عرض ثلاث بطاقات فقط.  نقوم بإنشاء هذه البطاقات من البروتوكول: <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">card</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(at index: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span></code> </pre> <br>  يتم استخدام وظيفة addCardView () ببساطة لإدراج خرائط كقوائم فرعية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addCardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cardView: SwipeCardView, atIndex index: Int)</span></span></span></span> { cardView.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addCardFrame(index: index, cardView: cardView) cardViews.append(cardView) insertSubview(cardView, at: <span class="hljs-number"><span class="hljs-number">0</span></span>) remainingcards -= <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br>  في هذه الوظيفة ، نضيف cardView إلى التسلسل الهرمي لطرق العرض ، ونضيف البطاقات كمقابلة فرعية ، ونقوم بتقليل البطاقات المتبقية بمقدار 1. بمجرد أن نضيف cardView كطريقة عرض فرعية ، نقوم بتعيين إطار هذه البطاقات.  للقيام بذلك ، نستخدم وظيفة أخرى addCardFrame (): <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addCardFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index: Int, cardView: SwipeCardView)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cardViewFrame = bounds <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> horizontalInset = (<span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(index) * <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.horizontalInset) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> verticalInset = <span class="hljs-type"><span class="hljs-type">CGFloat</span></span>(index) * <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.verticalInset cardViewFrame.size.width -= <span class="hljs-number"><span class="hljs-number">2</span></span> * horizontalInset cardViewFrame.origin.x += horizontalInset cardViewFrame.origin.y += verticalInset cardView.frame = cardViewFrame }</code> </pre> <br>  يتم أخذ منطق addCardFrame () هذا مباشرةً من مشاركة Phil.  هنا نضع إطار الخريطة وفقًا لمؤشرها.  سيكون للبطاقة الأولى ذات الفهرس 0 إطار ، تمامًا مثل الحاوية.  ثم نغير أصل الإطار وعرض الخريطة وفقًا للإدراج.  وبالتالي ، نضيف البطاقة قليلاً إلى يمين البطاقة أعلاه ، ونخفض عرضها ، وأيضًا نسحب البطاقات إلى أسفل لإيجاد شعور بأن البطاقات مكدسة فوق بعضها البعض. <br><br>  بمجرد الانتهاء من ذلك ، سترى أن البطاقات مكدسة فوق بعضها البعض.  جيد جدا <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bee/8f0/83e/bee8f083e7dfc5e9dbc70ed6a95d398a.png" alt="صورة"><br><br>  ومع ذلك ، نحتاج الآن إلى إضافة لفتة انتقاد إلى عرض الخريطة.  دعونا الآن نحول انتباهنا إلى فئة SwipeCardView. <br><br><h3 style=";text-align:right;direction:rtl">  SwipeCardView </h3><br>  فئة swipeCardView هي فئة فرعية منتظمة من UIView.  ومع ذلك ، لأسباب معروفة فقط لمهندسي Apple ، من الصعب للغاية إضافة ظلال إلى UIView مع زاوية مستديرة.  لإضافة ظلال إلى طرق عرض الخريطة ، أقوم بإنشاء جهازي UIViews.  واحد منهم هو shadowView ، وبعد ذلك swipeView.  في الجوهر ، يحتوي shadowView على ظل وهذا كل شيء.  SwipeView له تقريب الزوايا.  في swipeView ، أضفت UIImageView ، UILabel لعرض البيانات والصور. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> swipeView : <span class="hljs-type"><span class="hljs-type">UIView!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shadowView : <span class="hljs-type"><span class="hljs-type">UIView!</span></span></code> </pre> <br>  إعداد shadowView و swipeView: <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureShadowView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { shadowView = <span class="hljs-type"><span class="hljs-type">UIView</span></span>() shadowView.backgroundColor = .clear shadowView.layer.shadowColor = <span class="hljs-type"><span class="hljs-type">UIColor</span></span>.black.cgColor shadowView.layer.shadowOffset = <span class="hljs-type"><span class="hljs-type">CGSize</span></span>(width: <span class="hljs-number"><span class="hljs-number">0</span></span>, height: <span class="hljs-number"><span class="hljs-number">0</span></span>) shadowView.layer.shadowOpacity = <span class="hljs-number"><span class="hljs-number">0.8</span></span> shadowView.layer.shadowRadius = <span class="hljs-number"><span class="hljs-number">4.0</span></span> addSubview(shadowView) shadowView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal"><span class="hljs-literal">false</span></span> shadowView.leftAnchor.constraint(equalTo: leftAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> shadowView.rightAnchor.constraint(equalTo: rightAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> shadowView.bottomAnchor.constraint(equalTo: bottomAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> shadowView.topAnchor.constraint(equalTo: topAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configureSwipeView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { swipeView = <span class="hljs-type"><span class="hljs-type">UIView</span></span>() swipeView.layer.cornerRadius = <span class="hljs-number"><span class="hljs-number">15</span></span> swipeView.clipsToBounds = <span class="hljs-literal"><span class="hljs-literal">true</span></span> shadowView.addSubview(swipeView) swipeView.translatesAutoresizingMaskIntoConstraints = <span class="hljs-literal"><span class="hljs-literal">false</span></span> swipeView.leftAnchor.constraint(equalTo: shadowView.leftAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> swipeView.rightAnchor.constraint(equalTo: shadowView.rightAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> swipeView.bottomAnchor.constraint(equalTo: shadowView.bottomAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> swipeView.topAnchor.constraint(equalTo: shadowView.topAnchor).isActive = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br>  ثم أضفت أداة التعرف على الإيماءات إلى هذا النوع من البطاقات وتسمى وظيفة المحدد عند التعرف.  وظيفة التحديد هذه لديها الكثير من المنطق للتمرير والإمالة ، إلخ.  لنرى: <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"> <span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handlePanGesture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sender: UIPanGestureRecognizer)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> card = sender.view <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = sender.translation(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> centerOfParentContainer = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x, y: centerOfParentContainer.y + point.y) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> sender.state { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .ended: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.center.x) &gt; <span class="hljs-number"><span class="hljs-number">400</span></span> { delegate?.swipeDidEnd(on: card) <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x + <span class="hljs-number"><span class="hljs-number">200</span></span>, y: centerOfParentContainer.y + point.y + <span class="hljs-number"><span class="hljs-number">75</span></span>) card.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> card.center.x &lt; -<span class="hljs-number"><span class="hljs-number">65</span></span> { delegate?.swipeDidEnd(on: card) <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x - <span class="hljs-number"><span class="hljs-number">200</span></span>, y: centerOfParentContainer.y + point.y + <span class="hljs-number"><span class="hljs-number">75</span></span>) card.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.transform = .identity card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .changed: <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rotation = tan(point.x / (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width * <span class="hljs-number"><span class="hljs-number">2.0</span></span>)) card.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(rotationAngle: rotation) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } }</code> </pre> <br>  الأسطر الأربعة الأولى في الكود أعلاه: <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> card = sender.view <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = sender.translation(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> centerOfParentContainer = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.height / <span class="hljs-number"><span class="hljs-number">2</span></span>) card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x, y: centerOfParentContainer.y + point.y)</code> </pre> <br>  أولاً ، حصلنا على الفكرة التي تم بها الإيماءة.  بعد ذلك ، نستخدم طريقة النقل لمعرفة عدد مرات ضرب المستخدم للبطاقة.  السطر الثالث يحصل بشكل أساسي على نقطة الوسط للحاوية الأصل.  السطر الأخير حيث نقوم بتثبيت card.center.  عندما يضرب المستخدم إصبعًا على البطاقة ، يتم زيادة مركز البطاقة بالقيمة المترجمة x والقيمة المترجمة y.  للحصول على هذا السلوك المفاجئ ، قمنا بتغيير نقطة مركز الخريطة بشكل كبير من الإحداثيات الثابتة.  عندما تنتهي ترجمة الإيماءات ، نعيدها إلى card.center. <br><br>  في حالة الحالة. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (card.center.x) &gt; <span class="hljs-number"><span class="hljs-number">400</span></span> { delegate?.swipeDidEnd(on: card) <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x + <span class="hljs-number"><span class="hljs-number">200</span></span>, y: centerOfParentContainer.y + point.y + <span class="hljs-number"><span class="hljs-number">75</span></span>) card.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> card.center.x &lt; -<span class="hljs-number"><span class="hljs-number">65</span></span> { delegate?.swipeDidEnd(on: card) <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>) { card.center = <span class="hljs-type"><span class="hljs-type">CGPoint</span></span>(x: centerOfParentContainer.x + point.x - <span class="hljs-number"><span class="hljs-number">200</span></span>, y: centerOfParentContainer.y + point.y + <span class="hljs-number"><span class="hljs-number">75</span></span>) card.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  نتحقق مما إذا كان card.center.x أكبر من 400 أو إذا كان card.center.x أقل من -65.  إذا كان الأمر كذلك ، فإننا نتجاهل هذه البطاقات ، ونغير المركز. <br><br>  إذا مرر إلى اليمين: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">card.center = CGPoint(x: centerOfParentContainer.x + point.x + 200, y: centerOfParentContainer.y + point.y + 75)</code> </pre> <br>  إذا مرر لليسار: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">card.center = CGPoint(x: centerOfParentContainer.x + point.x - 200, y: centerOfParentContainer.y + point.y + 75)</code> </pre> <br>  إذا أنهى المستخدم الإيماءة في الوسط ما بين 400 و -65 ، فسنقوم بإعادة تعيين مركز الخريطة.  نحن نسمي أيضًا طريقة التفويض عندما ينتهي التمرير السريع.  المزيد عن هذا في وقت لاحق. <br><br>  للحصول على هذا الميل عند تمرير الخريطة ؛  سأكون صادقا بوحشية.  لقد استخدمت هندسة صغيرة واستخدمت قيمًا مختلفة للعمودي والقاعدة ، ثم استخدمت الدالة tan للحصول على زاوية الدوران.  مرة أخرى ، كان هذا مجرد محاكمة والخطأ.  باستخدام point.x وعرض الحاوية كما يبدو أن محيطين يعملان بشكل جيد.  لا تتردد في تجربة هذه القيم. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .changed: <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> rotation = tan(point.x / (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.frame.width * <span class="hljs-number"><span class="hljs-number">2.0</span></span>)) card.transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(rotationAngle: rotation)</code> </pre> <br>  الآن دعونا نتحدث عن وظيفة مندوب.  سوف نستخدم وظيفة المفوض للتواصل بين SwipeCardView و ContainerView. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwipeCardsDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swipeDidEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(on view: SwipeCardView)</span></span></span></span> }</code> </pre> <br>  ستأخذ هذه الوظيفة في الاعتبار النوع الذي حدث فيه التمرير السريع ، وسنتخذ عدة خطوات لإزالته من المقاطع الفرعية ، ثم إعادة جميع الإطارات للبطاقات الموجودة تحتها.  إليك كيف: <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swipeDidEnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(on view: SwipeCardView)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> datasource = dataSource <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } view.removeFromSuperview() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> remainingcards &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newIndex = datasource.numberOfCardsToShow() - remainingcards addCardView(cardView: datasource.card(at: newIndex), atIndex: <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cardIndex, cardView) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visibleCards.reversed().enumerated() { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>, animations: { cardView.center = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addCardFrame(index: cardIndex, cardView: cardView) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() }) } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cardIndex, cardView) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visibleCards.reversed().enumerated() { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>, animations: { cardView.center = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addCardFrame(index: cardIndex, cardView: cardView) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() }) } } }</code> </pre> <br>  أولاً قم بإزالة هذا العرض من العرض الفائق.  بمجرد الانتهاء من ذلك ، تحقق مما إذا كانت هناك بطاقة متبقية.  إذا كان هناك ، سنقوم بإنشاء فهرس جديد للبطاقة المراد إنشاؤها.  سننشئ newIndex بطرح العدد الإجمالي للبطاقات لعرضها مع بقية البطاقات.  ثم سنضيف الخريطة كمقابلة فرعية.  ومع ذلك ، ستكون هذه البطاقة الجديدة هي الأقل بحيث تضمن البطاقة التي نرسلها أساسًا تطابق الإطار المضاف مع المؤشر 2 أو الأقل. <br><br>  لتحريك إطارات البطاقات المتبقية ، سوف نستخدم فهرس العرض الفرعي.  للقيام بذلك ، سنقوم بإنشاء صفيف visualCards ، والذي سيحتوي على جميع العروض الفرعية للحاوية كصفيف. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visibleCards: [<span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span>] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> subviews <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? [<span class="hljs-type"><span class="hljs-type">SwipeCardView</span></span>] ?? [] }</code> </pre> <br>  المشكلة ، مع ذلك ، هي أن صفيف visualCards سيكون له فهرس عرض فرعي معكوس.  وبالتالي ، ستكون البطاقة الأولى الثالثة ، وستبقى الثانية في المرتبة الثانية ، والثالثة ستكون في المركز الأول.  لمنع حدوث ذلك ، سنقوم بتشغيل مجموعة visualCards بالترتيب العكسي للحصول على فهرس العرض الفرعي الفعلي ، وليس كيفية تحديد موقعها في صفيف visualCards. <br><br><pre style=";text-align:right;direction:rtl"> <code class="swift hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cardIndex, cardView) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> visibleCards.reversed().enumerated() { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.animate(withDuration: <span class="hljs-number"><span class="hljs-number">0.2</span></span>, animations: { cardView.center = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.center <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addCardFrame(index: cardIndex, cardView: cardView) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layoutIfNeeded() }) }</code> </pre> <br>  حتى الآن سنقوم بتحديث إطارات بقية cardViews. <br><br>  هذا كل شيء.  هذه طريقة مثالية لتقديم كمية صغيرة من البيانات. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar448664/">https://habr.com/ru/post/ar448664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar448652/index.html">موزيلا WebThings على توت العليق بي - البدء</a></li>
<li><a href="../ar448654/index.html">موزيلا WebThings - إعداد بوابة</a></li>
<li><a href="../ar448656/index.html">الأخ الأكبر يراقب ... نفسه أو خريطة لها تاريخ الحركات في HomeAssistant</a></li>
<li><a href="../ar448658/index.html">ما الذي يمكن القيام به من خلال موصل OBD في السيارة</a></li>
<li><a href="../ar448662/index.html">"روسيا 404": خيار ليس للعرض</a></li>
<li><a href="../ar448666/index.html">كيف اخترنا خدمة لإدارة الوثائق الإلكترونية مع العملاء</a></li>
<li><a href="../ar448668/index.html">رشيق: أكبر قضية أيديولوجية في تكنولوجيا المعلومات</a></li>
<li><a href="../ar448670/index.html">جزءا لا يتجزأ من تصميم واجهة</a></li>
<li><a href="../ar448672/index.html">الويبينار - مصادقة ثنائية و ES في بنية VMware Horizon View باستخدام منتجات Aladdin R.D.</a></li>
<li><a href="../ar448674/index.html">طحالب وعجول (جزء 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>