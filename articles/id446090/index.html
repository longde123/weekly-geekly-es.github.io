<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐵 🐵 🗞️ Micropython pada modul GSM + GPS A9G 🌒 🤛🏼 👩🏾‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kali ini saya berpikir untuk menyembunyikan pelacak GPS di sepeda saya sebagai tindakan pencegahan. Ada banyak perangkat otonom di pasar untuk melacak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Micropython pada modul GSM + GPS A9G</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/446090/"><p>  Kali ini saya berpikir untuk menyembunyikan pelacak GPS di sepeda saya sebagai tindakan pencegahan.  Ada banyak perangkat otonom di pasar untuk melacak mobil, kargo, sepeda, koper, anak-anak dan hewan.  Sebagian besar dari mereka berinteraksi dengan pengguna melalui SMS.  Opsi yang lebih mahal menyediakan fitur Find my phone, tetapi terkait dengan layanan online tertentu. <br>  Idealnya, saya ingin memiliki kontrol penuh atas pelacak: menggunakannya dalam mode yang nyaman tanpa SMS dan pendaftaran.  Google dangkal membawakan saya beberapa modul dari China, salah satunya saya pesan (papan puding A9G) (~ $ 15). </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f7f/b34/fe0/f7fb34fe016bb3a6c532712b9b2e75e1.png" alt="Modul"></p><br><p>  Artikel ini adalah tentang bagaimana saya membuat python bekerja pada modul ini. </p><a name="habracut"></a><br><p>  Jika A9G adalah analog ESP (pabrikan, omong-omong, sama), maka papan puding itu sendiri adalah analog dari papan NodeMCU, kecuali bahwa papan puding tidak memiliki konverter USB-UART bawaan.  Tetapi ada banyak hal menarik lainnya.  Spesifikasi <a href="">produsen</a> : </p><br><ul><li>  32 bit core (RISC), hingga 312MHz </li><li>  29x GPIO (semua disolder, semua antarmuka termasuk dalam nomor ini) </li><li>  jam tangan dan anjing penjaga </li><li>  Antarmuka USB 1.1 1x (saya tidak menemukannya di sana, tetapi menyalin dari luar kantor) dan microUSB untuk daya </li><li>  2x UART (layanan +1) </li><li>  2x SPI (belum dicoba) </li><li>  3x I2C (belum dicoba) </li><li>  1x SDMMC (dengan slot fisik) </li><li>  2x input analog (10 bit, mungkin salah satunya digunakan oleh pengontrol baterai lithium) </li><li>  4 MB flash </li><li>  4Mb PSRAM </li><li>  ADC (mikrofon, secara fisik ada di papan) dan DAC (speaker, absen) </li><li>  pengontrol pengisian daya baterai (tidak ada baterai sendiri) </li><li>  Bahkan, GSM (800, 900, 1800, 1900 MHz) dengan SMS, suara dan GPRS </li><li>  GPS terhubung melalui UART2 (ada modul "A9" tanpa itu) </li><li>  Slot SIM (nanoSIM) </li><li>  dua tombol (satu reset, yang lain - fungsi inklusi dan diprogram) </li><li>  dua LED </li></ul><br><p>  Tegangan operasi adalah 3.3V, tegangan input 5-3.8V (tergantung pada koneksi).  Secara umum, modul memiliki semua perangkat keras yang diperlukan untuk merakitnya dari perangkat mobile tombol sederhana.  Tetapi dari contoh-contoh itu tampaknya orang Cina membelinya untuk dijual dari mesin slot atau mesin slot atau sesuatu seperti itu.  Alternatif untuk modul adalah modul SIM800 yang agak populer, yang, sayangnya, tidak memiliki SDK di domain publik (mis. Modul tersebut dijual sebagai modem AT). </p><br><h1>  SDK </h1><br><p> Modul ini dilengkapi dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SDK</a> dalam bahasa Inggris yang memuaskan.  Pemasangan di bawah Ubuntu, tetapi Windows dan kontainer lebih disukai.  Semuanya berfungsi melalui poking di GUI: ESPtool untuk modul ini belum dikembalikan.  Firmware itu sendiri dibangun oleh Makefile.  Debugger hadir: sebelum pembekuan, modul melempar jejak stack ke port layanan.  Tetapi secara pribadi, saya tidak bisa menerjemahkan alamat menjadi baris kode (gdb melaporkan bahwa alamat tidak sesuai dengan apa pun).  Ada kemungkinan bahwa ini karena dukungan yang buruk untuk Linux.  Dengan demikian, jika Anda ingin mengotak-atik modul - coba lakukan di Windows (dan berhenti berlangganan di github).  Kalau tidak, inilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi</a> untuk Linux.  Setelah instalasi, Anda perlu memeriksa kebenaran jalur di .bashrc dan menghapus (mengganti nama) semua file <code>CSDTK/lib/libQt*</code> : jika tidak, flasher (alias debugger) tidak akan mulai karena konflik dengan, mungkin, libQt yang diinstal. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a7/955/5bc/7a79555bca02e1ad6363b8da9559c91e.png" alt="Flasher"></p><br><p>  Untuk flasher ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi</a> . </p><br><h1>  Koneksi </h1><br><p>  Semuanya lebih rumit daripada di NodeMCU.  Modul terlihat mirip, tetapi tidak ada chip USB-TTY pada papan puding dan microUSB hanya digunakan untuk daya.  Karenanya, Anda akan membutuhkan USB-TTY di 3.3V.  Dua lebih baik: satu untuk port debug dan satu untuk UART1: yang pertama digunakan untuk mengunggah firmware dan yang kedua dapat Anda gunakan sebagai terminal reguler.  Agar tidak menyeret semua ingus ini ke komputer, saya juga membeli splitter USB 4-port dengan kabel dua meter dan catu daya eksternal (diperlukan).  Total biaya kit ini dengan modul itu sendiri adalah $ 25-30 (tanpa catu daya: gunakan dari telepon). </p><br><h1>  Firmware </h1><br><p>  Modul ini dilengkapi dengan AT firmware: Anda dapat terhubung ke Arduino 3.3V dan menggunakannya sebagai modem melalui UART1.  Firmware mereka ditulis dalam C. <code>make</code> membuat dua file firmware: satu dijahit sekitar satu menit, yang lain cukup cepat.  Hanya satu dari file ini yang dapat dijahit: pertama kali besar, kali berikutnya kecil.  Secara total, selama proses pengembangan, saya memiliki SDK Cina ( <code>coolwatcher</code> ) terbuka di desktop untuk mengelola modul, miniterm sebagai stdio dan editor kode. </p><br><h1>  API </h1><br><p>  Konten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API</a> mencerminkan daftar di atas dan menyerupai ESP8266 pada hari-hari awalnya: saya butuh sekitar 3 jam untuk meluncurkan HelloWorld.  Sayangnya, rangkaian fungsi yang tersedia bagi pengguna sangat terbatas: misalnya, tidak ada akses ke buku telepon pada kartu SIM, informasi tingkat rendah tentang menghubungkan ke jaringan seluler, dan sebagainya.  Dokumentasi API bahkan kurang lengkap, jadi Anda harus bergantung pada contoh (yang ada dua lusin) dan memasukkan file.  Namun demikian, modul ini dapat melakukan banyak hal hingga koneksi SSL: jelas, pabrikan fokus pada fungsi yang paling prioritas. </p><br><p>  Namun, pemrograman mikrokontroler Cina melalui API Cina harus dicintai.  Untuk semua orang, pabrikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mulai</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memasukkan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">port</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">micropython</a> ke modul ini.  Saya memutuskan untuk mencoba sendiri dalam proyek open-source dan melanjutkan kerja bagus ini (tautan di akhir artikel). </p><br><h1>  micropython </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9a1/b46/e00/9a1b46e00d290db2f478ebb54f7d9e74.jpg" alt="logo"></p><br><p>  Micropython adalah proyek open-source porting cPython ke mikrokontroler.  Pengembangan dilakukan dalam dua arah.  Yang pertama adalah dukungan dan pengembangan perpustakaan inti yang umum untuk semua mikrokontroler yang mendeskripsikan bekerja dengan tipe data utama dalam python: objek, fungsi, kelas, string, tipe atom, dan banyak lagi.  Yang kedua adalah, pada kenyataannya, port: untuk setiap mikrokontroler perlu untuk "mengajar" perpustakaan untuk bekerja dengan UART untuk input-output, pilih tumpukan untuk mesin virtual, tentukan satu set optimisasi.  Secara opsional, bekerja dengan perangkat keras dijelaskan: GPIO, daya, nirkabel, sistem file. <br>  Semua ini ditulis dalam C murni dengan makro: micropython memiliki satu set resep yang direkomendasikan dari mendeklarasikan string dalam ROM ke modul penulisan.  Selain itu, modul yang ditulis sendiri python didukung penuh (yang utama adalah jangan lupa tentang ukuran memori).  Para kurator proyek menetapkan sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesempatan mereka untuk meluncurkan dzhanga</a> (gambar dengan sepotong roti).  Sebagai iklan: proyek ini menjual papannya sendiri untuk siswa papan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">luncur</a> , tetapi port untuk modul ESP8266 dan ESP32 juga populer. </p><br><p>  Ketika firmware siap dan diunggah - Anda cukup menyambungkan ke mikrokontroler melalui UART dan masuk ke Python REPL. </p><br><pre> <code class="bash hljs">$ miniterm.py /dev/ttyUSB1 115200 --raw MicroPython cd2f742 on 2017-11-29; unicorn with Cortex-M3 Type <span class="hljs-string"><span class="hljs-string">"help()"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information. &gt;&gt;&gt; <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) hello</code> </pre> <br><p>  Setelah itu, Anda dapat mulai menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di python3 yang hampir normal</a> tanpa melupakan keterbatasan memori. </p><br><p>  Modul A9G tidak didukung secara resmi (daftar modul yang didukung secara resmi tersedia dalam <code>micropython/ports</code> , ada sekitar selusin dari mereka).  Namun demikian, pembuat besi itu bercabang micropython dan menciptakan lingkungan untuk port <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>micropython/ports/gprs_a9</code></a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>micropython/ports/gprs_a9</code></a> , yang banyak terima kasih kepadanya.  Pada saat saya tertarik dengan masalah ini, port berhasil dikompilasi dan mikrokontroler menyambut saya dengan REPL.  Tapi, sayangnya, dari modul pihak ketiga hanya ada yang berfungsi dengan sistem file dan GPIO: tidak ada yang terkait dengan jaringan nirkabel dan GPS tersedia.  Saya memutuskan untuk memperbaiki cacat ini dan menetapkan sendiri tujuan porting semua fungsi yang diperlukan untuk pelacak GPS.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi resmi</a> untuk kasus ini tidak perlu singkat: oleh karena itu, saya harus melihat-lihat kode. </p><br><h2>  Mulai dari mana </h2><br><p>  Pertama, pergi ke <code>micropython/ports</code> dan salin <code>micropython/ports/minimal</code> ke folder baru di mana port akan berada.  Kemudian, edit <code>main.c</code> untuk platform Anda.  Perlu diingat bahwa semua yummy berada di fungsi <code>main</code> , di mana Anda perlu memanggil <code>mp_init()</code> , setelah sebelumnya menyiapkan mikrokontroler dan menumpuk pengaturan untuk itu.  Kemudian, untuk API yang digerakkan oleh peristiwa, Anda perlu memanggil <code>pyexec_event_repl_init()</code> dan memberi makan karakter yang dimasukkan melalui UART ke fungsi <code>pyexec_event_repl_process_char(char)</code> .  Ini akan memberikan interoperabilitas melalui REPL.  File kedua, <code>micropython/ports/minimal/uart_core.c</code> menjelaskan pemblokiran input dan output di UART.  Saya membawa kode asli untuk STM32 bagi mereka yang terlalu malas untuk mencari. </p><br><p> <code>main.c</code> </p> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stack_dummy; stack_top = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)&amp;stack_dummy; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_ENABLE_GC gc_init(heap, heap + sizeof(heap)); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> mp_init(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_ENABLE_COMPILER #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MICROPY_REPL_EVENT_DRIVEN pyexec_event_repl_init(); for (;;) { int c = mp_hal_stdin_rx_chr(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (pyexec_event_repl_process_char(c)) { break; } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> pyexec_friendly_repl(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//do_str("print('hello world!', list(x+1 for x in range(10)), end='eol\\n')", MP_PARSE_SINGLE_INPUT); //do_str("for i in range(10):\r\n print(i)", MP_PARSE_FILE_INPUT); #else pyexec_frozen_module("frozentest.py"); #endif mp_deinit(); return 0; }</span></span></span></span></code> </pre> <br><p> <code>uart_core.c</code> </p> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Receive single character int mp_hal_stdin_rx_chr(void) { unsigned char c = 0; #if MICROPY_MIN_USE_STDOUT int r = read(0, &amp;c, 1); (void)r; #elif MICROPY_MIN_USE_STM32_MCU // wait for RXNE while ((USART1-&gt;SR &amp; (1 &lt;&lt; 5)) == 0) { } c = USART1-&gt;DR; #endif return c; } // Send string of given length void mp_hal_stdout_tx_strn(const char *str, mp_uint_t len) { #if MICROPY_MIN_USE_STDOUT int r = write(1, str, len); (void)r; #elif MICROPY_MIN_USE_STM32_MCU while (len--) { // wait for TXE while ((USART1-&gt;SR &amp; (1 &lt;&lt; 7)) == 0) { } USART1-&gt;DR = *str++; } #endif }</span></span></code> </pre> <br><p>  Setelah itu, Anda perlu menulis ulang Makefile menggunakan rekomendasi / kompiler dari pabrikan: semuanya individual di sini.  Semuanya, ini idealnya sudah cukup: kami mengumpulkan, mengisi firmware dan melihat REPL di UART. <br>  Setelah menghidupkan kembali <code>micropython</code> Anda perlu menjaga kesejahteraannya: mengatur pengumpul sampah, reaksi yang benar terhadap Ctrl-D (soft reset) dan beberapa hal lain yang tidak akan saya <code>mpconfigport.h</code> : lihat file <code>mpconfigport.h</code> . </p><br><h2>  Buat modul </h2><br><p>  Yang paling menarik adalah menulis modul Anda sendiri.  Jadi, modul (tidak perlu, tetapi diinginkan) dimulai dengan file <code>mod[].c</code> , yang ditambahkan oleh <code>Makefile</code> (variabel <code>SRC_C</code> jika Anda mengikuti konvensi).  Modul kosong adalah sebagai berikut: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// nlr - non-local return:  C  ,      goto-  . //  nlr_raise             . #include "py/nlr.h" //   .  ,  mp_map_elem_t,  ,   . #include "py/obj.h" //   . mp_raise_ValueError(char* msg)  mp_raise_OSError(int errorcode)   . //  ,   mp_call_function_*     Callable (  callback-). #include "py/runtime.h" #include "py/binary.h" //  header   :       #include "portmodules.h" //    --  .     MP_QSTR_[ ]. MP_OBJ_NEW_QSTR   . //             RAM. //      -      __name__ STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, }; //      STATIC MP_DEFINE_CONST_DICT (mp_module_mymodule_globals, mymodule_globals_table); //   :             const mp_obj_module_t mp_module_mymodule = { .base = { &amp;mp_type_module }, .globals = (mp_obj_dict_t*)&amp;mp_module_mymodule_globals, };</span></span></code> </pre> <br><p>  Tentu saja, port itu sendiri tidak mengenali konstanta <code>mp_module_mymodule</code> : ia harus ditambahkan ke variabel <code>MICROPY_PORT_BUILTIN_MODULES</code> dalam pengaturan port <code>mpconfigport.h</code> .  Ngomong-ngomong <del>  wallpaper membosankan </del>  nama chip dan nama port juga berubah di sana.  Setelah semua perubahan ini, Anda dapat mencoba mengkompilasi modul dan mengimpornya dari REPL.  Hanya satu atribut <code>__name__</code> dengan nama modul yang akan tersedia untuk modul (kasus yang bagus untuk memeriksa pelengkapan otomatis di REPL via Tab). </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.__name__ <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span></code> </pre> <br><h2>  Konstanta </h2><br><p>  Tahap selanjutnya dalam kompleksitas adalah menambahkan konstanta.  Konstanta sering diperlukan untuk pengaturan ( <code>INPUT</code> , <code>OUTPUT</code> , <code>HIGH</code> , <code>LOW</code> , dll.) Semuanya cukup sederhana di sini.  Di sini, sebagai contoh, konstanta <code>magic_number = 10</code> : </p><br><pre> <code class="cpp hljs">STATIC <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mp_map_elem_t</span></span> mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(<span class="hljs-number"><span class="hljs-number">10</span></span>) }, };</code> </pre> <br><p>  Pengujian: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.magic_number <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre> <br><h2>  Fungsi </h2><br><p>  Menambahkan fungsi ke modul mengikuti prinsip umum: menyatakan, membungkus, menambah (Saya memberikan contoh yang sedikit lebih kompleks daripada di dokumentasi). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  STATIC mp_obj_t conditional_add_one(mp_obj_t value) { //   int.         -  :   . int value_int = mp_obj_get_int(value); value_int ++; if (value_int == 10) { //  None return mp_const_none; } //   int return mp_obj_new_int(value); } //    .     // runtime.h   . STATIC MP_DEFINE_CONST_FUN_OBJ_1(conditional_add_one_obj, conditional_add_one); //  STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(10) }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;conditional_add_one_obj }, };</span></span></code> </pre> <br><p>  Tes: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mymodule &gt;&gt;&gt; mymodule.conditional_add_one(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">4</span></span> &gt;&gt;&gt; mymodule.conditional_add_one(<span class="hljs-number"><span class="hljs-number">9</span></span>) &gt;&gt;&gt;</code> </pre> <br><h2>  Kelas (Jenis) </h2><br><p>  Dengan kelas (tipe), semuanya juga relatif sederhana.  Berikut ini adalah contoh dari dokumentasi (well, hampir): </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     STATIC const mp_map_elem_t mymodule_hello_locals_dict_table[] = {}; //   STATIC MP_DEFINE_CONST_DICT(mymodule_hello_locals_dict, mymodule_hello_locals_dict_table); // ,  ,   const mp_obj_type_t mymodule_helloObj_type = { //    { &amp;mp_type_type }, // : helloObj .name = MP_QSTR_helloObj, //  .locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, }; //    STATIC const mp_map_elem_t mymodule_globals_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_mymodule) }, { MP_OBJ_NEW_QSTR(MP_QSTR_magic_number), MP_OBJ_NEW_SMALL_INT(10) }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;conditional_add_one_obj }, { MP_OBJ_NEW_QSTR(MP_QSTR_conditional_add_one), (mp_obj_t)&amp;mymodule_helloObj_type }, };</span></span></code> </pre> <br><p>  Tes: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>mymodule.helloObj &lt;type <span class="hljs-string"><span class="hljs-string">'helloObj'</span></span>&gt;</code> </pre> <br><p>  Jenis yang dihasilkan dapat diwariskan, dibandingkan, tetapi tidak memiliki konstruktor atau data terkait.  Data ditambahkan "di sebelah" konstruktor: diusulkan untuk membuat struktur terpisah di mana tipe Python akan disimpan secara terpisah dan terpisah - satu set data sewenang-wenang. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  -. ,    typedef struct _mymodule_hello_obj_t { //   mp_obj_base_t base; // -  uint8_t hello_number; } mymodule_hello_obj_t;</span></span></code> </pre> <br><p>  Bagaimana cara berinteraksi dengan data ini?  Salah satu cara tersulit adalah melalui konstruktor. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// -,   (,  ,   mymodule_helloObj_type //   ,     - ),   (args  kwargs)  //        : args, kwargs STATIC mp_obj_t mymodule_hello_make_new( const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args ) { //    mp_arg_check_num(n_args, n_kw, 1, 1, true); //   mymodule_hello_obj_t *self = m_new_obj(mymodule_hello_obj_t); //     self-&gt;base.type = &amp;mymodule_hello_type; //   self-&gt;hello_number = mp_obj_get_int(args[0]) //   return MP_OBJ_FROM_PTR(self); //    __init__, ,  } //      make_new const mp_obj_type_t mymodule_helloObj_type = { { &amp;mp_type_type }, .name = MP_QSTR_helloObj, .locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, //  .make_new = mymodule_hello_make_new, };</span></span></code> </pre> <br><p>  Dari bidang lain, ada juga <code>.print</code> , dan saya kira sisa sihir <code>Python3</code> . </p><br><p>  Tetapi <code>make_new</code> tidak diperlukan sama sekali untuk mendapatkan instance dari suatu objek: inisialisasi dapat dilakukan dalam fungsi arbitrer.  Berikut ini adalah contoh yang bagus dari <code>micropython/ports/esp32/modsocket.c</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   :       STATIC mp_obj_t get_socket(size_t n_args, const mp_obj_t *args) { socket_obj_t *sock = m_new_obj_with_finaliser(socket_obj_t); sock-&gt;base.type = &amp;socket_type; sock-&gt;domain = AF_INET; sock-&gt;type = SOCK_STREAM; sock-&gt;proto = 0; sock-&gt;peer_closed = false; if (n_args &gt; 0) { sock-&gt;domain = mp_obj_get_int(args[0]); if (n_args &gt; 1) { sock-&gt;type = mp_obj_get_int(args[1]); if (n_args &gt; 2) { sock-&gt;proto = mp_obj_get_int(args[2]); } } } sock-&gt;fd = lwip_socket(sock-&gt;domain, sock-&gt;type, sock-&gt;proto); if (sock-&gt;fd &lt; 0) { exception_from_errno(errno); } _socket_settimeout(sock, UINT64_MAX); return MP_OBJ_FROM_PTR(sock); } //     0-3  STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(get_socket_obj, 0, 3, get_socket);</span></span></code> </pre> <br><h2>  Metode terikat </h2><br><p>  Langkah selanjutnya adalah menambahkan metode terikat.  Namun, ini tidak jauh berbeda dari semua metode lain.  Kami kembali ke contoh dari dokumentasi: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    :     1 (self) STATIC mp_obj_t mymodule_hello_increment(mp_obj_t self_in) { mymodule_hello_obj_t *self = MP_OBJ_TO_PTR(self_in); self-&gt;hello_number += 1; return mp_const_none; } //     MP_DEFINE_CONST_FUN_OBJ_1(mymodule_hello_increment_obj, mymodule_hello_increment); //      'inc' STATIC const mp_map_elem_t mymodule_hello_locals_dict_table[] = { { MP_OBJ_NEW_QSTR(MP_QSTR_inc), (mp_obj_t)&amp;mymodule_hello_increment_obj }, }</span></span></code> </pre> <br><p>  Itu saja! </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = mymodule.helloObj(<span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; x.inc()</code> </pre> <br><h2>  Semua atribut lainnya: <strong>getattr</strong> , <strong>setattr</strong> </h2><br><p>  Bagaimana dengan menambahkan non-fungsi, menggunakan <code>@property</code> dan umumnya <code>__getattr__</code> Anda sendiri?  Tolong: ini dilakukan secara manual melewati <code>mymodule_hello_locals_dict_table</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     ... STATIC void mymodule_hello_attr(mp_obj_t self_in, qstr attr, mp_obj_t *dest) { mymodule_hello_obj_t *self = MP_OBJ_TO_PTR(self_in); if (dest[0] != MP_OBJ_NULL) { // __setattr__ if (attr == MP_QSTR_val) { self-&gt;val = dest[1]; dest[0] = MP_OBJ_NULL; } } else { // __getattr__ if (attr == MP_QSTR_val) { dest[0] = self-&gt;val; } } } // ...     attr const mp_obj_type_t mymodule_helloObj_type = { { &amp;mp_type_type }, .name = MP_QSTR_helloObj, //     //.locals_dict = (mp_obj_dict_t*)&amp;mymodule_hello_locals_dict, .make_new = mymodule_hello_make_new, //   - attr .attr = mymodule_hello_attr, };</span></span></code> </pre><br><p>  Ternyata sesuatu yang singkat dan menyakitkan, katamu.  Di mana semua <code>mp_raise_AttributeError</code> ini ( <em>catatan</em> : fungsi seperti itu tidak ada)?  Bahkan, sebuah <code>AttributeError</code> akan dipanggil secara otomatis.  Rahasianya adalah bahwa <code>dest</code> adalah array dari dua elemen.  Elemen pertama memiliki arti "output", hanya menulis: dibutuhkan nilai <code>MP_OBJ_SENTINEL</code> jika nilainya perlu ditulis dan <code>MP_OBJ_NULL</code> jika perlu dibaca.  Dengan demikian, pada saat keluar dari fungsi, <code>MP_OBJ_NULL</code> diharapkan dalam kasus pertama dan sesuatu <code>mp_obj_t</code> di yang kedua.  Elemen kedua adalah input, hanya-baca: mengambil nilai objek untuk ditulis jika nilainya perlu ditulis dan <code>MP_OBJ_NULL</code> jika perlu dibaca.  Anda tidak perlu mengubahnya. </p><br><p>  Itu saja, Anda dapat memeriksa: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>x = mymodule.helloObj(<span class="hljs-number"><span class="hljs-number">12</span></span>) &gt;&gt;&gt; x.val = <span class="hljs-number"><span class="hljs-number">3</span></span> &gt;&gt;&gt; x.val <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br><p>  Yang paling menarik adalah bahwa penyelesaian Tab di REPL masih berfungsi dan menawarkan <code>.val</code> !  Sejujurnya, saya bukan ahli C, jadi saya hanya bisa menebak bagaimana ini terjadi (dengan mendefinisikan ulang operator '=='). </p><br><h2>  Pelabuhan </h2><br><p>  Kembali ke modul A9G, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggambarkan</a> dukungan semua fungsi dasar, yaitu, SMS, GPRS (soket), GPS, manajemen daya.  Sekarang Anda dapat mengunggah sesuatu seperti ini ke modul dan itu akan berfungsi: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cellular <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usocket <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sock <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gps <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> machine <span class="hljs-comment"><span class="hljs-comment">#   print("Waiting network registration ...") while not c.is_network_registered(): time.sleep(1) time.sleep(2) #  GPRS print("Activating ...") c.gprs_activate("internet", "", "") print("Local IP:", sock.get_local_ip()) #  GPS gps.on() #    thingspeak host = "api.thingspeak.com" api_key = "some-api-key" fields = ('latitude', 'longitude', 'battery', 'sat_visible', 'sat_tracked') #  ,      ! fields = dict(zip(fields, map(lambda x: "field{}".format(x+1), range(len(fields))) )) x, y = gps.get_location() level = machine.get_input_voltage()[1] sats_vis, sats_tracked = gps.get_satellites() s = sock.socket() print("Connecting ...") s.connect((host, 80)) print("Sending ...") #      ,     HTTP.           HTTP, SSL   print("Sent:", s.send("GET /update?api_key={}&amp;{latitude}={:f}&amp;{longitude}={:f}&amp;{battery}={:f}&amp;{sat_visible}={:d}&amp;{sat_tracked}={:d} HTTP/1.1\r\nHost: {}\r\nConnection: close\r\n\r\n".format( api_key, x, y, level, sats_vis, sats_tracked, host, **fields ))) print("Receiving ...") print("Received:", s.recv(128)) s.close()</span></span></code> </pre> <br><p>  Proyek menerima bantuan yang layak.  Jika Anda menyukai proyek dan / atau artikel ini, jangan lupa untuk meninggalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">like di github</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446090/">https://habr.com/ru/post/id446090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446078/index.html">"Suara": mendiskusikan podcast tentang teknologi audio</a></li>
<li><a href="../id446080/index.html">Di AS, pengadilan merekomendasikan untuk melarang impor model iPhone tertentu karena melanggar paten Qualcomm Apple</a></li>
<li><a href="../id446082/index.html">Kisah Setengah Lingkaran</a></li>
<li><a href="../id446086/index.html">Sejarah Linux. Bagian III: pasar baru dan "musuh" lama</a></li>
<li><a href="../id446088/index.html">Hal-hal yang tidak saya ketahui pada tahun 2018</a></li>
<li><a href="../id446092/index.html">Hanya tanpa tangan! Robot yang tidak mengulangi tindakan pengguna</a></li>
<li><a href="../id446094/index.html">Dengan tabel periodik seumur hidup</a></li>
<li><a href="../id446096/index.html">Buku "TasteVill: Cara membuat revolusi di ritel, melakukan segala sesuatu yang salah"</a></li>
<li><a href="../id446098/index.html">Pusat kontrol penerbangan Soviet pada masa "Vostok" dan "Matahari Terbit"</a></li>
<li><a href="../id446100/index.html">Secara otomatis membuat file pelokalan Android dan iOS dari Excel spreadsheet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>