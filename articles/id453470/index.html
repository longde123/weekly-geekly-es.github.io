<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>▪️ 👩‍🔬 👩🏾‍🌾 Monolith Anda yang terdistribusi sedang merencanakan di belakang Anda 👎🏻 📁 💃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 

 Terjemahan hari ini tidak hanya menyentuh dan tidak terlalu banyak layanan mikro - sebuah topik yang dimiliki setiap orang saat ini - t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monolith Anda yang terdistribusi sedang merencanakan di belakang Anda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/453470/">  Halo, Habr! <br><br>  Terjemahan hari ini tidak hanya menyentuh dan tidak terlalu banyak layanan mikro - sebuah topik yang dimiliki setiap orang saat ini - tetapi juga mengingatkan betapa pentingnya menyebut sekop sekop.  Transisi ke arsitektur microservice kadang-kadang diperlukan, tetapi, seperti yang ditekankan oleh penulis sekali lagi, itu memerlukan pertimbangan yang cermat atas konsekuensinya.  Nikmati dan membaca bermanfaat! <br><br><img src="https://habrastorage.org/webt/im/q8/dr/imq8drim-mkatdxhbytwowus1ik.jpeg"><br><a name="habracut"></a><br>  Dari waktu ke waktu saya menanyakan pertanyaan yang sama. <br><blockquote>  Adakah kebenaran yang begitu penting sehingga hanya sedikit yang setuju dengan Anda?  - Peter Thiel </blockquote>  Sebelum saya duduk untuk posting ini, saya mencoba masalah ini untuk waktu yang lama untuk satu topik, yang hari ini dalam tren yang serius - ini tentang layanan mikro.  Saya pikir sekarang saya memiliki sesuatu untuk diceritakan;  beberapa temuan didasarkan pada refleksi, yang lain berdasarkan pengalaman praktis.  Jadi, saya katakan. <br>  Mari kita mulai dengan satu kebenaran penting yang akan berfungsi sebagai titik referensi bagi kita di sepanjang jalan seperti bintang kutub. <br><br>  Sebagian besar implementasi layanan-mikro tidak lebih dari monolit terdistribusi. <br><br><h4>  Era monolit </h4><br>  Sistem apa pun dimulai sebagai aplikasi monolitik.  Saya tidak akan membahas detail topik ini di sini - banyak yang sudah menulis tentang banyak hal.  Namun, bagian terbesar dari informasi tentang monolith dikhususkan untuk masalah-masalah seperti produktivitas dan skalabilitas pengembang, sementara meninggalkan kurung aset yang paling berharga dari perusahaan Internet: data. <br><br><img src="https://habrastorage.org/webt/83/75/yh/8375yhxrmoq8jmhfl-wz97u7slg.png"><br><br>  <i>Arsitektur aplikasi monolitik yang khas</i> <br><br>  Jika data sangat penting, lalu mengapa semua perhatian diberikan pada topik lain, tetapi tidak untuk mereka?  Jawabannya, secara umum, sederhana: karena mereka tidak sesulit pertanyaan data. <br>  Mungkin monolit adalah satu-satunya tahap dalam siklus hidup sistem tempat Anda: <br><br><ul><li>  Sepenuhnya memahami model data Anda; </li><li>  Anda dapat bekerja sama dengan data (diasumsikan bahwa database Anda dipilih dengan benar untuk aplikasi Anda). </li></ul><br>  Dalam hal data, monolit itu ideal.  Dan karena data adalah aset paling berharga dari perusahaan mana pun, lebih baik untuk tidak melanggar monolit, kecuali Anda memiliki alasan yang sangat bagus, atau kombinasi dari alasan tersebut.  Dalam kebanyakan kasus, alasan yang menentukan dari jenis ini adalah kebutuhan untuk skala (karena kita hidup di dunia nyata dengan keterbatasan fisik yang melekat). <br><br>  Ketika saat ini tiba, sistem Anda kemungkinan besar masuk ke hipostasis baru: itu <b>berubah menjadi monolit yang didistribusikan</b> . <br><br><h4>  Era monolit yang didistribusikan </h4><br>  Katakanlah semuanya berjalan baik di perusahaan Anda, dan aplikasi perlu tumbuh.  Anda memiliki semakin banyak pelanggan besar, dan persyaratan Anda untuk penagihan dan pelaporan telah berubah baik dalam hal serangkaian peluang maupun volumenya. <br><br>  Dengan serius mengambil pembongkaran monolit, khususnya, Anda akan mencoba menerapkan dua layanan kecil, satu di antaranya akan menyediakan pelaporan, dan tagihan kedua.  Kemungkinan besar, layanan baru ini akan menyediakan API HTTP dan memiliki basis data khusus untuk penyimpanan negara jangka panjang.  Setelah melakukan banyak hal, Anda, seperti kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unbabel</a> , mungkin mendapatkan sesuatu yang menyerupai ilustrasi berikut. <br><br><img src="https://habrastorage.org/webt/lg/js/9g/lgjs9grnmyupckoplo0to5q-kjm.png"><br><br>  <i>Pandangan umum tentang arsitektur sistem setelah memisahkan layanan penagihan dan pelaporan dari aplikasi monolitik utama</i> <br><br>  Semuanya berjalan sesuai rencana. <br><br><ul><li>  Tim terus membagi monolit menjadi sistem yang lebih kecil; </li><li>  Integrasi / konveyor pengiriman berkelanjutan berfungsi seperti jarum jam; </li><li>  Cluster Kubernetes sehat, para insinyur produktif dan senang dengan segalanya. </li></ul><br>  Hidup itu indah. <br><br>  Tetapi bagaimana jika saya mengatakan bahwa sekarang konspirasi keji menenun melawan Anda? <br><br>  Sekarang, melihat sistem Anda, Anda akan menemukan bahwa data telah didistribusikan di berbagai sistem.  Anda mulai dengan tahap ketika Anda memiliki database unik di mana semua objek data disimpan, dan sekarang objek data Anda telah menyebar ke berbagai tempat.  Anda mungkin berpikir bahwa ini bukan masalah, karena layanan microser diperlukan untuk membuat abstraksi dan menyegel data, menyembunyikan kompleksitas internal sistem. <br><br>  Anda benar sekali.  Tetapi dengan meningkatnya skala, masalah yang lebih kompleks muncul: sekarang, kapan saja, Anda dipaksa untuk memenuhi persyaratan bisnis (misalnya, untuk melacak beberapa metrik), yang membutuhkan akses ke data yang terletak di lebih dari satu sistem. <br><br>  Apa yang harus dilakukan  Padahal, ada banyak pilihan.  Tetapi dengan tergesa-gesa, Anda juga perlu melayani persaudaraan besar pelanggan yang baru saja terdaftar dengan Anda, jadi Anda harus menemukan keseimbangan antara "cepat" dan "baik".  Setelah membahas detailnya, Anda memutuskan untuk membangun sistem tambahan yang akan melakukan pekerjaan ETL tertentu, berkontribusi pada solusi tugas akhir.  Sistem ini harus memiliki akses ke semua replika baca yang berisi informasi yang Anda butuhkan.  Gambar berikut menunjukkan bagaimana sistem seperti itu bisa bekerja. <br><br><img src="https://habrastorage.org/webt/76/op/x0/76opx0yinpcv5fbxh9x8sais2hm.png"><br><br>  <i>Contoh umum dari sistem ETL analitik (di Unbabel kami menyebutnya Analisis Terjemahan Otomatis)</i> <br><br>  Di Unbabel, kami menggunakan pendekatan ini, karena: <br><br><ul><li>  Itu tidak mempengaruhi kinerja setiap layanan Microsoft terlalu banyak; </li><li>  Tidak memerlukan perubahan infrastruktur besar (cukup tambahkan microservice baru); </li><li>  Kami dapat dengan cepat memenuhi persyaratan bisnis kami. </li></ul><br>  Pengalaman menunjukkan bahwa untuk beberapa waktu pendekatan ini akan berhasil - hingga mencapai skala tertentu.  Di Unbabel, ia melayani kami dengan sangat baik hingga baru-baru ini, ketika kami mulai menghadapi tantangan yang semakin serius.  Berikut beberapa hal yang membuat kami pusing: <br><br>  <b>1. Perubahan data</b> <br><br>  Salah satu keunggulan utama layanan-mikro adalah enkapsulasi.  Representasi internal data dapat berubah, tetapi ini tidak mempengaruhi klien sistem, karena mereka berkomunikasi melalui API eksternal.  Namun, strategi kami membutuhkan akses langsung ke representasi internal data, dan oleh karena itu, segera setelah tim hanya membuat beberapa perubahan pada penyajian data (misalnya, mengganti nama bidang atau mengubah jenis dari <code>text</code> ke <code>uuid</code> ), kami juga harus mengubah dan memindahkan kembali ETL- kami. layanan. <br><br>  <b>2. Perlunya memproses banyak skema data yang berbeda</b> <br><br>  Karena jumlah sistem yang kami perlukan untuk terhubung, kami harus berurusan dengan cara penyajian data yang semakin heterogen.  Sudah jelas bahwa kami tidak dapat meningkatkan skala semua skema ini, hubungan antara mereka dan representasi mereka. <br><br>  <i><b>Akar semua kejahatan</b></i> <br><br>  Untuk mendapatkan gambaran lengkap tentang apa yang terjadi dalam sistem, kami harus berhenti pada pendekatan yang menyerupai monolit.  Seluruh perbedaannya adalah bahwa kami tidak memiliki satu sistem dan satu basis data, tetapi lusinan pasangan seperti itu, masing-masing dengan representasi data sendiri;  selain itu, dalam beberapa kasus, data yang sama direplikasi di beberapa sistem. <br><br>  Saya lebih suka menyebut sistem seperti itu sebagai monolit terdistribusi.  Mengapa  Karena sama sekali tidak cocok untuk melacak perubahan dalam sistem, dan satu-satunya cara untuk menampilkan keadaan sistem adalah dengan mengumpulkan layanan yang menghubungkan langsung ke gudang data semua layanan Microsoft.  Sangat menarik untuk melihat berapa banyak colossi Internet juga menghadapi tantangan serupa di beberapa titik dalam perkembangan mereka.  Contoh yang baik dalam hal ini yang selalu ingin saya berikan adalah jaringan LinkedIn. <br><br><img src="https://habrastorage.org/webt/bx/zv/l8/bxzvl8oaw7htdnldzu7fr3toxdm.png"><br><br>  <i>Ini adalah jenis kecelakaan data yang diwakili oleh aliran informasi Linkedin sekitar tahun 2011 - sumber</i> <br><br>  Pada saat ini, Anda mungkin bertanya-tanya: "apa yang akan kalian lakukan dengan semua ini?"  Jawabannya sederhana: Anda harus mulai melacak perubahan dan melacak tindakan penting saat terjadi. <br><br>  <b>Hancurkan monolit terdistribusi menggunakan Event Sourcing</b> <br><br>  Seperti hampir seluruh dunia, sistem di Internet responsif.  Jadi, permintaan ke API dapat menyebabkan penyisipan catatan baru ke dalam basis data.  Saat ini, dalam banyak kasus, perincian seperti itu tidak mengganggu kami, karena kami terutama tertarik untuk memperbarui keadaan basis data.  Memperbarui keadaan basis data adalah konsekuensi bersyarat dari beberapa peristiwa (dalam hal ini, permintaan API).  Fenomena peristiwa itu sederhana dan, bagaimanapun, potensi kejadiannya sangat besar - bahkan dapat digunakan untuk menghancurkan monolit yang didistribusikan. <br><br>  <b>Suatu peristiwa tidak lebih dari fakta yang tidak berubah dari beberapa modifikasi yang terjadi di sistem Anda</b> .  Dalam arsitektur layanan mikro, peristiwa menjadi penting dan membantu untuk memahami aliran data, dan atas dasar mereka untuk menyimpulkan keadaan agregat beberapa sistem.  Setiap microservice yang melakukan tindakan yang menarik dari sudut pandang seluruh sistem harus menghasilkan suatu peristiwa bersama dengan semua informasi penting yang terkait dengan fakta yang diwakili oleh peristiwa ini. <br><br>  Mungkin Anda punya pertanyaan: <br>  "Bagaimana layanan microser yang menghasilkan peristiwa dapat membantu saya memecahkan masalah monolit yang didistribusikan?" <br><br>  Jika Anda memiliki sistem yang menghasilkan peristiwa, maka mungkin ada log fakta dengan properti berikut: <br><br><ul><li>  Kurangnya pengikatan pada gudang data apa pun: acara biasanya diserialisasi menggunakan format biner seperti JSON, Avro atau Protobufs; </li><li>  Kekekalan: begitu suatu peristiwa dihasilkan, tidak mungkin untuk mengubahnya; </li><li>  Reproducibility: keadaan sistem pada suatu titik waktu dapat dipulihkan;  untuk ini, cukup dengan "memutar ulang" log peristiwa. </li></ul><br>  Menggunakan log ini, Anda dapat menampilkan negara menggunakan semua jenis logika di level aplikasi.  Anda tidak lagi dikaitkan dengan serangkaian layanan microser dan <i>N</i> cara di mana data disajikan.  Satu-satunya sumber kebenaran dan satu-satunya gudang data Anda sekarang adalah repositori tempat acara Anda disimpan. <br><br>  Berikut adalah beberapa alasan mengapa log peristiwa menurut saya menjadi cara untuk membantu memecahkan Monolith Terdistribusi: <br><br>  <b>1. Satu-Satunya Sumber Kebenaran</b> <br><br>  Alih-alih mempertahankan sumber data N yang mungkin diperlukan untuk terhubung ke (banyak) database heterogen, dalam skenario baru ini, kebenaran tertinggi disimpan dalam satu repositori: log peristiwa. <br><br>  <b>2. Format data universal</b> <br><br>  Dalam versi sistem sebelumnya, kami harus berurusan dengan banyak format data, karena kami terhubung langsung ke database.  Dalam tata letak baru, kita dapat bertindak jauh lebih fleksibel. <br><br>  Katakanlah Anda menyukai foto Instagram yang diposkan oleh salah satu teman Anda.  Tindakan semacam itu dapat dijelaskan: “ <i>Pengguna X menyukai gambar P</i> ”.  Dan ini adalah acara yang mewakili fakta ini: <br><br><img src="https://habrastorage.org/webt/ff/sp/2x/ffsp2xttqkwolrptkfa3bw66mdc.png"><br><br>  <i>Suatu peristiwa yang sesuai dengan pendekatan AVO (Aktor, Verb, Objek), mensimulasikan fakta bahwa pengguna memilih gambar yang mereka sukai.</i> <br><br>  <b>3. Melemahnya komunikasi antara produsen dan konsumen</b> <br><br>  Last but not least, salah satu keuntungan terbesar dari operasi acara adalah melemahnya komunikasi yang efektif antara produsen data dan konsumen.  Situasi ini tidak hanya menyederhanakan penskalaan, tetapi juga mengurangi jumlah dependensi di antara mereka.  Satu-satunya kontrak yang tersisa antara sistem dalam hal ini adalah diagram acara. <br><br><hr><br>  Di awal artikel ini muncul pertanyaan: Apakah ada kebenaran penting di mana hanya sedikit yang setuju dengan Anda? <br><br>  Biarkan saya kembali ke sana di akhir perjalanan ini.  Saya percaya bahwa sebagian besar perusahaan tidak mempertimbangkan data "entitas kelas satu" ketika mereka mulai migrasi ke arsitektur layanan mikro.  Dikatakan bahwa semua perubahan data masih dapat dilakukan melalui API, tetapi pendekatan ini pada akhirnya mengarah pada komplikasi konstan dari layanan itu sendiri. <br><br>  Saya percaya bahwa satu-satunya pendekatan yang benar untuk menangkap perubahan data dalam arsitektur layanan mikro adalah membuat sistem memancarkan peristiwa sesuai dengan kontrak yang ditentukan secara ketat.  Memiliki log peristiwa yang disusun dengan benar memungkinkan Anda untuk menampilkan banyak data berdasarkan set persyaratan bisnis apa pun.  Dalam hal ini, Anda hanya perlu menerapkan aturan berbeda untuk fakta yang sama.  Dalam beberapa kasus, fragmentasi data tersebut dapat dihindari jika perusahaan Anda (terutama manajer produk Anda) memperlakukan data sebagai produk.  Namun, ini adalah topik untuk artikel lain. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453470/">https://habr.com/ru/post/id453470/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453458/index.html">Pemrograman reaktif nyata di Svelte 3.0</a></li>
<li><a href="../id453460/index.html">Ketika bosan dengan virtual</a></li>
<li><a href="../id453464/index.html">Quantum Future (lanjutan)</a></li>
<li><a href="../id453466/index.html">HolyJS 2019: Pembekalan dari SEMrush (Bagian 2)</a></li>
<li><a href="../id453468/index.html">Evolusi aplikasi web Java</a></li>
<li><a href="../id453472/index.html">Sepeda dari monitor energi PZEM004T dan ESP8266, dengan People's Monitoring</a></li>
<li><a href="../id453474/index.html">Kontrol komputer melalui remote control dari amplifier menggunakan Arduino dan Node.js</a></li>
<li><a href="../id453478/index.html">Kami mempelajari kesehatan satelit Starlink Ilona Mask</a></li>
<li><a href="../id453482/index.html">Pengantar pembelajaran mendalam menggunakan TensorFlow</a></li>
<li><a href="../id453484/index.html">Penghitung BCD 4-bit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>