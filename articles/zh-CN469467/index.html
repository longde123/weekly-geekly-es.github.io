<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏩 📷 🙋🏿 C ++与C＃ 🧑🏾‍🤝‍🧑🏻 🍃 🐟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="每个人都知道，没有什么比争论“哪种语言更好”更愚蠢了。 例如，对什么更好？ 不同的语言在不同的领域都有成功的经验，没有考虑这一点就得出明确的结论是没有意义的。 

 但是，如果您求助于经验丰富的专家，他们自己了解所有这些，并要求他们安排C ++与C＃holivar，会发生什么？ 事实证明，您可以找到...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++与C＃</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469467/"><img src="https://habrastorage.org/webt/ud/4s/-_/ud4s-_jhcan8lv7ei9kfabnsszo.jpeg"><br><br> 每个人都知道，没有什么比争论“哪种语言更好”更愚蠢了。 例如，对什么更好？ 不同的语言在不同的领域都有成功的经验，没有考虑这一点就得出明确的结论是没有意义的。 <br><br> 但是，如果您求助于经验丰富的专家，他们自己了解所有这些，并要求他们安排C ++与C＃holivar，会发生什么？ 事实证明，您可以找到很多有趣的细节。  “跨平台”一词可以两种方式同时应用于两种语言，但这实际上意味着什么？  C ++现在正在积极开发吗？  C＃是否打破了向后兼容性？ 答案对那些已经同时沉迷于两种语言的人来说可能是显而易见的，但是这样的人很少-其他所有人都会学到新的东西。 <br><br> 来自C ++的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++俄罗斯</a>会议计划委员会主席<b>Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">sermp</a> Platonov</b>参加了会议。  C＃ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">端由</a> <b>Anatoly Kulakov</b>代表-他被包括在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DotNext</a>会议的PC中，并且是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DotNetRu</a>的领导人之一。 这两个世界并存的讨论领袖是<b>德米特里· <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">梅萨斯特尔</a> · <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">内斯特鲁克</a></b> （ <b>Dmitry <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">mezastel</a> Nesteruk）</b> 。 <br><br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/sn/rb/_i/snrb_ie2-dnmplhnbfnl_klnvca.jpeg"><br><br>  <b>德米特里：</b>下午好，同事们。 欢迎参加有关编程语言的非正式聚会。 在互联网上，我们不断提醒您，无法比较语言。 今天，我们将做您无法做的事情：将C ++与C＃和.NET及其优缺点进行比较。 请自我介绍。 <br><br>  <b>Anatoly：</b>我的名字叫Anatoly，今天我将被C＃淹死，因为我一直在学习这种语言的第一个版本，而且看来，我对此一无所知。 <br><br>  <b>Sergey：</b>嗨，我叫Sergey，我今天会被C ++淹死。 迪马正确地说，我们将比较优缺点。 每个人都称其为“加号”，众所周知，在本次讨论中，C＃将成为负号。 是这样吗，Anatoly？ <br><br>  <b>Anatoly：</b> C＃还有两个优点！ 因此，我认为这是优势的演进发展，这些优势已经过时并且几乎无法在任何地方竞争。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/wy/sj/_pwysj2lxe1ncg6lmuzqxfs2dg0.jpeg"></div><br><br><h2> 学历 </h2><br>  <b>德米特里：</b>我有第一个话题要讨论。 想象一下，新学生来到大学，他们需要第一语言。 您认为人们第一年应该使用的第一语言是C ++，C＃或一般的汇编器？ <br><br>  <b>谢尔盖：</b>我教了一段时间，所以我有一个确定的意见。 我了解到这里我们将讨论哪种语言更好，并且我代表C ++。但是要学习C ++，您需要了解计算机的体系结构。 因此，教学生（至少在我所教的大学中）是个大问题。 为了教授算法和东西，您可能需要某种语言本身不关注基础结构的东西。 埃菲尔（Eiffel）在这里尝试这样做，但也有很多魔术。 因此，我想说我们的两种语言都不适合。 <br><br> 编程是不同的，它不是算法，而是算法，数据结构等。 在每个主题上选择自己的乐器可能是有意义的。 了解某种Lisp数据结构。 因此，应在学生了解架构知识后使用C ++。 然后将有可能理解为什么所有这些痛苦和苦难。 我什至不认为优点是痛苦。 <br><br>  <b>Anatoly：</b>是的，我完全同意您需要分离对象，而不是将其放在“编程”中并用一种语言来敲打一切。 但是，如果您已经了解了基础知识，基础知识，算法并开始选择某种工业语言，那么C＃当然会更好。 因为它不会强迫您在体系结构，内存字节和其他“手工日落”级别上学习所有这些残渣。 它提供了一种可以立即理解的语言，简单的语法，从第一年或第二年开始使用这种语言，您可以赚到很多钱。 <br><br>  <b>德米特里（Dmitry）：</b>有人争辩说，不给初学者一些诸如指针之类的东西就是一种牺牲品。 如果一个人不了解，例如，链接实际上只是内存中变量的地址，它们将有一个巨大的漏洞。 您如何看待？ <br><br>  <b>Anatoly：</b> 20年前，当计算机没有足够的内存，磁盘和其他东西时，情况就是这样。 现在看这些javascript，它们将500 MB的库拖到每个“ hello world”中。 它们会占用多少内存？ 他们的表现如何？ 那里有什么链接？ 是的，没人在乎。 最主要的是在生产中快速滚动和发布某些内容。 我并不是说这是好方法，而是我认为有必要随着现实而改变。 也许现在，链接花费多少并不重要。 <br><br>  <b>谢尔盖：</b>大概取决于哪里。 据我了解，德米特里（Dmitry）对算法交易很感兴趣-我可以生动地想象他是如何在JS上建立库以向交易所发送订单的。 <br><br>  <b>德米特里：</b>嗯，是的，当然，实际上没有人在那里使用这种语言。 尽管从理论上讲这是可能的：但不要忘记，JS基础设施中并没有投入大量资金。 使JS编译成任何事物的引擎。 许多人认为这种语言是所有事物的一流语言。 <br><br> 当然，算法交易现在是与此类学科相距遥远的学科，但是总体上，算法交易和金融数学通常是特定领域。 它仅以C ++为主。 而且它部分地是由于惯性而仅由于历史原因而导致的：首先，每个人都使用C ++，并且这个领域很保守。 <br><br>  <b>谢尔盖：</b>我不同意。 我现在在金融科技公司工作，从算法交易开始就一直在这里的同事谈论的是最早用Java编写的大公司。 最初，Java应对算法交易，但是当市场开始增长并且出现了使用C ++的竞争对手时，在某些时候他们根本做不到，他们没有有效地做所有事情……因此，并不是每个算法交易的人都从C ++开始。 只是那些没有写它的人死了。 这样的自然选择。 <br><br>  <b>德米特里：</b>实际上，您可以将其扩大。 在许多示例中，甚至大型银行也将其算法保存在Excel文档中。 然后，他们还使用Excel作为服务器来计算所有这一切。 有一些令人毛骨悚然的刹车，但这都取决于您是否在进行高频交易（或者通常是高频交易）。 如果您是做市商，您自然需要高性能，并且那里的业务甚至不仅仅限于C ++，我们还涉及硬件和HDL语言。 <br><br> 但是我们的讨论不仅围绕算法交易，而且围绕简单事物。 这里我举一个例子。 与建筑相关，我需要编写几个小的应用程序来计算不同的事物：例如，如何在房屋的轮廓上铺砖。 而且我几乎无法想象如何在C ++中执行此类操作，因为在那里与UI相关的所有功能都较弱。  Qt只有一个框架，甚至很难编写。 如果我坐下来使用C＃和WinForms，那么我将立即创建该应用程序。 <br><br>  <b>Anatoly：</b>好吧，可视部分一直是C＃的优势。 微软在模具，甚至跨平台模具以及可视化方面投入了大量资金。 因此，如果我们谈论的是可视桌面应用程序，那么在我看来，优势通常相距甚远。 <br><br>  <b>谢尔盖：</b>嗯，这取决于往常。 我确实不喜欢UI，但是在优点方面，我经常需要这样做。 似乎带来了JS，并与专业人士进行了互动。 但是我从事嵌入式工作，所以很难。 人们购买了某种价格昂贵的快速引擎，但是它仍然无法应付用JS编写的UI的正常呈现。 在Qt上重写所有这些内容之后，结果证明是超频了。 普通的故事。 <br><br><img src="https://habrastorage.org/webt/kc/9t/uf/kc9tufwhjjwnla-uga_j8abdwqg.jpeg"><br><br><h2> 跨平台与跨平台 </h2><br>  <b>谢尔盖：</b>我想在这里澄清。 我对C＃不太了解，我很早以前在第一个版本中就碰到了它（当时我被破坏了向后兼容性）。 所以问题是：它是否仍仅由Microsoft开发？ <br><br>  <b>Anatoly：</b>不，现在它是跨平台的，可以通过ISO（ECMA-334和ISO / IEC 23270）认证。 顺便说一下，据我所知，C ++仍然没有开放的ISO规范，只是付费的。 与之相反，C＃是完全开放的。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">.NET Foundation是</a>由许多公司（包括Google，Amazon和Samsung）开发的。 现在，我什至不了解比C＃及其.NET平台更开放的语言。 <br><br>  <b>谢尔盖：</b>嗯，哈斯克尔。 <br><br>  <b>Anatoly：</b>顺便说一下，Haskell的作者在Microsoft Research工作，并做出了很多努力以使各种很酷的东西出现在C＃中-例如，静态检查，某种反射，您甚至可能梦dream以求。 <br><br>  <b>谢尔盖：</b>他们可以做梦，甚至朝这个方向努力。 但是很明显，所有东西都有自己的价格。 在C ++中，他们只是拒绝支付此价格。 <br><br>  <b>安</b>那<b>托利：</b>哪一个？ 它们被编译了两个小时，价格可能是多少？ <br><br>  <b>Sergey：</b>在C ++中，零成本抽象的原理。 好吧，也就是说，虚拟机不是零成本抽象，对吗？ 我们必须忍受这一点。 <br><br>  <b>德米特里（Dmitry）：</b>好吧，但是例如，虚拟机可能会使特定体系结构的代码晦涩难懂。 而在C ++中，如果我在没有AVX的计算机上使用AVX指令，则过程将关闭。 我会说这种说法并不完全正确，因为从理论上-我强调，从理论上讲-JIT可以完成C ++无法提供的工作。 即，在启动时进行优化。 <br><br>  <b>Sergey：</b>但是在C ++中，在编译过程中，您可以完全控制所需的指令。 在这种情况下，您无需用手控制它，而是放弃了乐器（编译器）。 看，关于此体系结构的指令是什么，指令集是什么... <br><br>  <b>德米特里：</b>这是可以理解的。 但是您可以这样来表述：既然有百万个平台，我们将永远找不到理想的选择，因为我们无法发布具有不同编译标志的百万个版本。 对不对 我们通常会发布x86和x64，但不要将其分解为一些子组。 <br><br>  <b>谢尔盖：</b>我们为什么不能？ 二十一世纪。 仅需使用不同的参数来容纳Docker。 <br><br>  <b>德米特里（Dmitry）：</b>当我们有一个最终客户端下载我们的应用程序时，他想下载特定的二进制文件。 在这种二进制文件中，如果可能的话，我们能做的最好的就是贴在任何地方。 就像“如果cpuid某某而avx支持又某某一样，那么我们使用算法版本25”。 结果，我们需要25种不同版本的同一算法，因为加速度取决于平台，因此它取决于平台。 <br><br>  <b>谢尔盖：</b>我可能同意。 坦白地说，就是我从未创造过非内部产品。 我主要在自己使用其产品的公司中。 <br><br>  <b>德米特里：</b>嗯，当然，最好的选择是当您可以预见地了解架构时。 严格来说，在这种情况下，没有人会强迫您使用x86指令。 您可以拿一张特定的卡（例如Nvidia Tesla），然后做您想做的任何事情。 这也是我的方法，我控制我的体系结构。 但是，当您为用户做出大众市场决策时……如果您选择一些有条件的ReSharper，他就不能仅将GPU加速用于任何任意索引。 因为GPU加速不是便携式的。 <br><br>  <b>Sergey：</b>实际上，有很多方法（现在您可能不需要详细介绍），有很多有趣的人（这种方法的作者似乎也已经转移到了Microsoft）。 前一年在我们的会议上，有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一份</a>关于如何编写这样一个程序的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告</a> ，它本身将了解什么在哪里（相对容易，同样，零成本抽象）。 这样一来，您就可以即时选择（如果有的话）以CUDA样式正确地重建代码... <br><br>  <b>德米特里：</b>实际上，CUDA本身正在尝试解决此问题，因为在CUDA中，有一定的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PTX</a>中间层可以处理此问题。 但是，这仍然非常困难，因为铁元素正在从根本上发生变化，并且很难跟上它的发展。 而且，例如，如果我们查看GPU加速在Adobe产品中的使用，则它们使用的可用技术范围非常狭窄。 如果您的卡是正确的-是的，那么一切都会正确。 但是，如果它有点异国情调，在这方面就无法保证。 <br><br>  <b>Anatoly：</b>在这次讨论中，我们谈到了一个相当重要的话题，如一个神话：C ++在多年前就被宣布为这种跨平台语言，但目前在C＃中跨平台的意义更大。 一个唯一的二进制文件在支持.NET的任何地方都有效，而且几乎在任何地方都可以。 <br><br>  <b>谢尔盖：</b>嗯，这也是没有根据的。 作为一生中大部分时间都在嵌入式领域工作的人，我很少看到.NET得到硬件制造商的工具链的支持。 生产铁的公司采用相同的G ++或Clang或使其开始为其平台生成代码。 <br><br>  <b>德米特里：</b>是的，但是问题是每次他们这样做都会从C ++中丢失一些东西。 例如，诺基亚使用了C ++的变体，但是他们的C ++疯狂的曲折和疯狂的API激怒了所有人。 也就是说，它不仅是C ++，而且是用于一个或另一平台的C ++。 然后问题开始了。 例如，使用相同的CUDA。 好像它应该让专业人士放任自己；它根本不是编译器，而仅仅是驱动程序。 但是尽管如此，她仍然感到困惑，因为她仍然使用某种框架将CUDA文件撕成GPU和CPU部件。 有时她没有成功。 <br><br>  <b>谢尔盖：</b>我不是那个意思。 只是当我听到“ .NET随处可见”时，我的大部分自传都开始了。 当您购买带有定制处理器的硬件时，它将随G ++交付捆绑在一起。 还有普通的C ++，G ++可以将其从工具链转换为该特定处理器支持的机器代码。 <br><br>  <b>德米特里：</b>但是再次，这必须重新组装... <br><br>  <b>谢尔盖：</b>当然可以。 <br><br>  <b>德米特里（Dmitry）：</b>我们采用现有的加号代码并将其拖到一块铁片上的想法-这个想法也行不通，因为您突然将常规的x86拖到某个地方，那里所有内容的总容量为8 GB，但并非如此扩展：例如，没有磁盘交换，因为没有磁盘可以访问。 这就是我们在谈论可移植性。 自然取决于目标。 <br><br>  <b>Anatoly：</b>专业人士可以在更多设备上工作，当然，嵌入式是最强大的部分之一。 但是通常您必须以某种方式使您的代码适应平台。 不好 我可以用一个代码涵盖大量的平台，体系结构，模型。 在优点方面，我必须考虑每个单独的平台：它将在哪里开始以及在什么条件下开始。 这是非常糟糕的，非常令人沮丧。 <br><br><img src="https://habrastorage.org/webt/f1/wn/1z/f1wn1zxi80gplsj3bpidl9fpr1i.jpeg"><br><br><h2> 稳定性，兼容性，语言发展 </h2><br>  <b>德米特里：</b>还提到了零成本抽象，但是问题是它的价格很高。 例如，在.NET中，存在枚举类型和IEnumerable接口的概念。 对于每种类型（例如数组），您都可以使用并遍历迭代器。 但是在C ++中没有这样的想法。 由于零成本抽象，要遍历整个集合，有几个begin（）和end（），它们的工作有规则，而这一切要复杂得多（特别是对于那些开始编程的人）。 这是一个直接的问题：如何将数组从A绕到Z。 <br><br>  <b>Sergey：</b>如果我正确理解了您在说什么……如果您只需要从头到尾地遍历一个容器，那么现在您就可以编写了，就像在某些Python中一样。 <br><br>  <b>德米特里：</b>这真是太好了。 但是，例如，您不要为此使用多态。 您不能说这里我有一个函数，该函数接收某个值，该值先验地枚举。 您不能说我有一个实现该接口的值，例如，该接口有一个迭代器。 <br><br>  <b>Sergey：</b>我们正在谈论哪种C ++？ 一般而言，关于C ++，将来的C ++，C ++，现在已被接受为标准？ <br><br>  <b>德米特里：</b>好吧，如果未来的优势会... <br><br>  <b>Sergey：</b>在C ++ 20中，这已经存在。 您已经可以说，甚至可以声明自己。 这些不是接口，而是说正确的方法……通常，您可以声明您的类型必须满足这样的条件。 例如，它具有开始和结束，返回一个迭代器。 在标准库中，迭代器就是这样准备好的概念。 他说这是什么，描述。 迭代器也不同。 总的来说，我们会尽力为人们带来更多便利。 <br><br>  <b>德米特里（Dmitry）：</b>在我看来，这是由于人们只是意识到没有对象的可迭代性而很难生活的事实。 因为不清楚如何编写概括性的东西。 是的，零成本抽象意味着我们在搜索时无需在v表中走动。例如，在.NET中，只有一种特定的方法。 而且，为了找到它，我们自然不得不付出努力，而优待者拒绝了。 但我要说，从可用性的角度来看，最终结果不是很好。 <br><br>  <b>谢尔盖：</b>自然，必须保持平衡。 您无法一次拥有所有东西。 <br><br>  <b>Anatoly：</b>这使您想知道已经过去了多少年。 替代语言不断发展，从一开始就出现了这些基本内容。 现在，他们正在追赶更重要和有趣的事情。 优点以相同的难以理解的语法，晦涩的抽象，难以理解的拐杖和不发达的技术坐了十年。 您可以将此作为缺点之一。 <br><br>  <b>谢尔盖：</b>好吧！  “欠发达”是什么意思？ <br><br> 您提到了一个委员会-C ++也有一个ISO委员会来开发它。 那里有包括Microsoft在内的代表，他们深深淹没了“您不能这样做，因为我们需要支持很多遗产”这一事实。 只是C ++是已经掌握的语言。 而且，当然，他走路要非常小心。 与C的兼容性是其中一项主要任务（Straustrup在创建时就已经声明了）。但是现在C的发展已经相当遥远，您必须指定与C兼容。 <br><br> 在我看来，现在C ++正在以惊人的速度发展。 关于概念等等-实际上，一切都在增长，当然，并非来自可迭代性。 实际上，该开发遵循Alexander Stepanov的描述-我们现在称为“通用编程”的作者之一，实际上是将模板，泛型等拖到C ++中的人。 老实说，我不知道委员会从这些想法中得到了多少启发，但是在我看来，它们之间肯定存在一些交集。 <br><br>  <b>Anatoly：</b>似乎所有这些元类，迭代器都是真正的灵感，这已经有几十年了。 即使您使用元编程，模板，宏-所有这些人长期经验丰富，精通并且有许多更简单，显而易见，可理解的概念。 在其他语言中，通过类型安全性，编译时间检查等，这一切都可以更快更好地完成一百万次。 <br><br>  <b>谢尔盖（Sergey）：</b>等等，您已经在谈论一些并非所有人都愿意支付的东西。 我不希望我的程序在我不知情的情况下在编译时检查某些内容。 你懂吗 <br><br>  <b>Anatoly：</b>我认为所有带有标志的东西都可以配置。 您设置优化级别，它会检查您是否选择。 这不是问题。 <br><br>  <b>谢尔盖：</b>通常，您需要用手控制一切。 确切知道发生了什么。 因为工具-好吧。 <br><br>  <b>德米特里：</b>甚至与工具无关。 在这里，像D和Rust这样的语言说：好，是的，当您访问数组元素时，可以检查它，但不能检查它。 他们只是将其提供给用户，也就是说，您可以说“但让我们关闭阵列检查”，“但让我们开启它”。 也就是说，在这方面进行某种控制。 <br><br>  <b>谢尔盖（Sergey）：</b>目前尚不清楚您是否拥有“不安全”和“安全”级别，例如在Rust中，例如，在这种情况下，我看不出C的不同之处。 <br><br>  <b>Anatoly：</b>区别在于您可以安全书写并且可以快速书写。 在C语言中，您必须危险地编写代码。 好吧，是的，也许很快。 稳定性有时比速度更重要。 <br><br>  <b>德米特里：</b>实际上，如果我们开始用新语言来研究这个主题，那么在C ++中，有些东西通常很难传达给人们。 一个简单的问题：int的大小是多少？ 在大多数语言中，您都知道该问题的答案。 您说：int是32位。 但是你不认识专家。 您知道特定计算机上的大小是因为您会记住它，但是严格来说，您甚至不想使用基本类型，因为它们是不确定的。 当存在一系列传统方法（例如int在不同平台上会有所不同）时，这些事情会激怒我。 现在我们已经知道这是不可能完成的。 为什么不比这更进一步，以某种方式解决这个问题呢？ <br><br>  <b>谢尔盖：</b>嗯，这是决定的。 有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STD</a> ，具有固定长度的必需类型。 现在，俄罗斯在委员会的代表正在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">拖动一个</a>可变长度<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a> int（同样，抽象成本为零）。 <br><br>  <b>Anatoly：</b>我是否正确记得一个方法的指针甚至没有确定的大小？ 也就是说，在不同的编译器和不同的平台下，指针是否不同？ <br><br>  <b>谢尔盖：</b>自然地，这就是建筑。 当您接近硬件时，如何保证指针的大小（如果您使用的是8位，然后使用64位）？ <br><br>  <b>Anatoly：</b>那之后如何对指针进行算术运算？ 太疯狂了 <br><br>  <b>谢尔盖：我的</b>意思是？ 好吧，小心点。 <br><br>  <b>阿纳托利：</b>我明白了。 该方法在任何地方都是清晰的，并使用句柄仔细控制所有内容。 <br><br>  <b>谢尔盖：</b>嗯，是的。 再次，现代C ++标准中已经开发出了方法。如果我们谈论选择，那么实际上在现代pluss中，是否可以使用垃圾收集器是一个选择。 只是GC建立在参考计数器上。 <br><br> 一般来说，用您的话来说，同事，对不起，我觉得您很长一段时间都没有更新关于现代加法器的知识。 <br><br> 现在，像Straustrup这样的人是加诸神的万神殿的一部分，他们来了很多电话来弄清楚如何教现代C ++。 问题在于人们在2003 C ++类别中的想法，并在相同类别中进行教学。 与此相关的还有一些有趣的新项目和方法，还有一些现代课程-可以说，来自Yandex的家伙做的很棒。 而现在，加上纯正new和delete被认为是一种不好的举止。 <br><br>  <b>德米特里（Dmitry）：</b>关于您对更新知识的评论...细微差别是，例如，我的方法是使用小的C ++增量，该增量一定可以为我工作，并且与我成为“朋友”。 您会看到，C ++用途广泛。 有模板元编程，一切都会好起来，有很多魔术，但是不幸的是，这种魔术是不可读的。 这是一个代码，非作者无法在没有任何特殊知识的情况下弄清楚该代码，在某种意义上说是黑匣子。 在职业选手中，有很多这样的黑匣子，在黑暗的地方无法消化……我想，我不知道，您的选择可以进行可预测的计算，而且没有任何花招。 <br><br> 最简单的示例是讨论范围（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">range-v3</a>和整个主题）。 一方面，这一切都是很棒的：有些事情已经在C＃中使用了几年了，例如，允许通过标准集合的任何转换来构建日历。 另一方面，与C＃相比，在C ++中实现它的方式简直令人不快：它笨重，不可读。 <br><br>  <b>谢尔盖：</b>这是调味。 相反，我喜欢它。 据我了解，您正在阅读Nibler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告</a>及其演示文稿... <br><br>  <b>德米特里：</b>您看到，当使用“或”运算符过滤集合时，我立即对此有疑问。  C＃和Java都通过常规方法通过点完成了所有操作。 <br><br>  <b>Sergey：</b>在我看来，这是受Bash启发的。 也就是说，它只是一个管道。 <br><br>  <b>德米特里：</b>嗯，是的，这可能解释了这种方法的某些方面。 <br><br>  <b>谢尔盖：</b>解释很多！ 让我们谈谈PowerShell，因为我们谈论的是Bash。 谁看过PowerShell？ <br><br>  <b>Anatoly：</b>我用一种很棒的语言PowerShell编写。 但是同样，需要将管道插入到适当的位置，所有架构都将其渗透。 不是您需要执行一项操作的地方，这在语法上是惯用法。 <br><br>  <b>谢尔盖：</b>在射程管中，它非常... <br><br>  <b>德米特里：</b>我认为，出于以下原因，在范围内使用它们……我要说的是：如果在C ++中有扩展方法或扩展函数，那么您当然会使用它们。 因为如果需要对集合进行排序，最自然的事情就是编写“ collection。filter（）”。 而不是“收藏| 查看:: filter（）“。 <br><br>  <b>Anatoly：</b>我还给您留下了这样的印象：您被击中腿部20年，被击中面部，将头撞在墙上，最后说：“好吧，现在我们已经按照20世纪标准做得很漂亮，现在让我们教优点是对的。” 是的，没有人想正确地教他们！ 也就是说，这是一个长期的痛苦。 <br><br>  <b>谢尔盖：</b>请不要教。 怎么了 用C＃编写-对其进行交易，嵌入进行编写。 我不介意。 <br><br>  <b>安纳托利：</b>好吧，专业人士还在那里，那里有狭窄的壁ni。 <br><br>  <b>谢尔盖（Sergey）：</b>嵌入式是一个“狭窄的利基市场” ​​...现在，在我的厨房里环顾四周，我看到了一堆计算机。 <br><br>  <b>德米特里（Dmitry）：</b>每当我乘飞机飞行时，我都会想：“该死，我希望这些优点能把一切写得很好。” <br><br>  <b>谢尔盖：</b>顺便说一句，据我所记得，主要是艾达。 <br><br>  <b>德米特里：</b>艾达在那霸占主导地位。 <br><br>  <b>Anatoly：</b>顺便说一句，我最近遇到了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一篇很棒的文章</a> ，其中的作者用不同的语言（大约10种）编写了一个低层驱动程序-10 Gb Intel卡的网络驱动程序。 从C到Swift，JS，Python以及自然的C＃。 如果我们看一下他得到的这些图，那么大批量的C＃（按发射成本进行平分）与C和Rust差不多。 <br><br><img src="https://habrastorage.org/webt/bk/bp/ur/bkbpuriesi98tzgy1eon4cek8vs.png"><br><br> 就是说，如果我们在谈论性​​能，那可能是一个误解，认为C＃在某处非常差。  Federico Luis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Scratched Metal的</a>报告也很时髦，他在其中展示了如何优化处理器分析器的C＃代码。 <br><br>  <b>谢尔盖：</b>好吧，它又开始了。 问题是，当您开始优化Java，C＃时，不清楚为什么不写加号。 因为您需要特定的知识。 而且，在我看来，C＃和Java之类的语言的优势已经得到体现-并不是很高的输入阈值。 据我了解，Dmitry所说的只是：代码可读性，学习很多，难以解释一些概念等等。 <br><br>  <b>Anatoly：</b>我有99％的时间都在使用“正常” C＃进行写作-安全，稳定并且一直在工作。 而且我有1％的时间想编写某种快速的低级代码。 这个C＃也允许我。 但是我的主要工具仍然稳定，可读，没有错误... <br><br>  <b>德米特里：</b>托里亚，让我给你举一个简单的例子：向量化。 使用.NET中的矢量化，尽管正在慢慢看到System.Numerics.Vectors，但一切都非常糟糕。 对我而言，这会导致什么？ 事实上，如果您正在市场中逛逛并购买.NET的数学库，那么它是由专业人士编写的（带有完整的包装）。 因为在.NET中，实际上无法访问硬件加速（AVX等），所以它现在处于萌芽阶段。 <br><br>  <b>Anatoly：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">.NET Core 3</a>中发布了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内部</a>函数，您可以在其中直接访问AVX。 他们确实处在婴儿期，但是有一些基本的东西，其余的都很动人。 <br><br>  <b>德米特里：</b>你知道，我们院子里有2019年。 作为所有这些数学加速产品的用户，我没有等到这一点。 结果，对我来说，如果我想快速考虑一下，C＃不再是候选人。 因为C ++库已经存在。 也许时间已经浪费了。 <br><br>  <b>Anatoly：</b>在我看来，C＃正朝着加价的方向发展，正在努力赢得他们的市场。 但是优点不再存在。 <br><br>  <b>谢尔盖：</b>这是哪里来的？  “加分加减价”是什么意思？ <br><br>  <b>Anatoly：</b>当他们在2019年告诉我标准中将有迭代器时，关于lambda将会有所进步，在我看来... <br><br>  <b>谢尔盖（Sergey）：</b>我不知道您为什么要谈论迭代器和lambda，我不知道这块石头是哪一种... <br><br>  <b>Anatoly：</b>与迭代器无关，我把它弄错了，我的意思是我们之前讨论过的可枚举的容器。 同时，我们得到了模式匹配。 <br><br>  <b>谢尔盖：</b>这完全取决于是否有必要。 我们正在讨论模式匹配。 但是到目前为止，对于专业人士是否需要它还没有争议。 <br><br>  <b>德米特里（Dmitry）：</b>我从优缺点中听到了许多类似的评论，他们说：“尽管这种方法或这种方法已经在其他语言中很明显地存在，但是它已经被制定出来了，人们喜欢它并在其上建立解决方案，我们仍然不希望这样，因为它不是惯用的优点。” 在我看来，Java陷入了同样的困境。  Java说：“没有人，我们不会有代表。” 在Java中，仍然没有委托的概念，但是在.NET中，所有这些工作正常。 <br><br>  <b>Sergey：</b>看，优点很简单。 再次，回到委员会。 有一个提示-这些人正在开发编译器。 对于他们来说，“零成本抽象”一词正是他们应遵循的指导。 不幸的是，还有“遗留”一词。 <br><br>  <b>德米特里：</b>嗯，零成本抽象是一个汇编程序。 如果我们通常想要零成本抽象，则需要在汇编器中编写所有内容。 <br><br>  <b>谢尔盖：</b>没有抽象。 <br><br>  <b>Dmitry：</b>汇编程序是对二进制代码的抽象。 这只是第二代，而不是第三代。 <br><br>  <b>谢尔盖（Sergey）：</b>因此，关于各种“方便的事情”，目前还不清楚如何使它们快速工作。 <br><br>  <b>德米特里：</b>让他们慢一点。 异步迭代器，协程程序以及所有这些的想法-在带有C＃的.NET中，yield关键字不再知道有多少版本可以正常工作。 是的，幕后正在建造巨大的状态机，仅仅是魔术。 但是异步/等待也会在迭代器中构建魔术。 但是每个人都使用它，真的很方便。 <br><br>  <b>谢尔盖：</b>协程增加了优点，你好。 <br><br>  <b>德米特里：</b>嗯，是的，正在取得进展。 但是协程正在出现，而不是十年前。 <br><br>  <b>谢尔盖：</b>再一次。 优点在于，我认为开发速度会随着代码库的积累而下降。 显然，这完全取决于是否需要维持旧版支持。 对于专业人士来说，这是原则上的立场。 也就是说，您在80年代编写的代码现在已由现代编译器编译。 <br><br>  <b>德米特里（Dmitry）：</b>是的，但是您使用现代编译器编译了用C＃1.0编写的代码。 <br><br>  <b>谢尔盖：</b>这不是事实。 在讨论的开始，我说我的早期版本的.NET已有更新，突然所有程序停止工作。 <br><br>  <b>德米特里：</b>也许您使用的API刚刚更改。 在这里，您需要将库和编程语言分开。 <br><br>  <b>谢尔盖：</b>我什么都没有，只有C＃。 我还年轻，那是头几年。 <br><br>  <b>德米特里：</b>我记得在C＃4中只有一个重大变化-foreach的行为有少许变化。 当然，在1.x版中，所有内容都可能更加动荡，但现在我们绝对不在某个人突然破坏某些东西的阶段。 <br><br>  <b>Anatoly：</b>好的，Microsoft正式坚持严格监控向后兼容性的立场，他们在大量机器和代码库上测试新版本。 也许您有一个错误或类似的东西。 <br><br>  <b>德米特里：</b> .NET通常还监视向后兼容性，但是进步的速度已经使C ++和Java跃升。 <br><br>  <b>谢尔盖：</b>在我看来，它起了很大的作用，起初所有这一切都是由一家公司推动的。 因为C ++最初是在委员会中-这是政治事务，所以每个人都在努力推动他们的决定，这就像是《星球大战》中的参议院会议。 <br><br>  <b>德米特里：</b>所以你的论点是我们都是委员会的人质，不是创新驱动的吗？ <br><br>  <b>谢尔盖（Sergey）：</b>问题是您选择的解决方案无法使所有人满意。 该工具分布广泛，许多公司都在使用它。 您还记得同样的协程：为什么他们迟到了？ 似乎是因为微软不同意Google。 有两种实现方式-我不记得谁在堆栈后面，谁在不堆栈后面，但不同意。 因为两家公司都很庞大，所以它们拥有庞大的代码库，它们已经包含解决方案，因此他们拒绝重写它。 <br><br>  <b>德米特里（Dmitry）：</b>从读者的角度来看，人们会感觉到他在高高的钟楼上spa之以鼻，因为有公司利益，他们参与了恋人，而这一切似乎都不在乎您-走吧，小伙子们，`` <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">让他们吃蛋糕''</a> 。 <br><br>  <b>谢尔盖：完全</b>相反。 该委员会试图选择让普通人不必受苦。 而且通常很难。 <br><br>  <b>德米特里（Dmitry）：</b>好吧，我可以为自己说，如果零成本直接流向某个地方，我将不会受苦，但是会有某种灵活的机会来遍历二叉树并以不同的方式迭代而没有时间变量。      yield,     -   - —    ,   ,      ,  ,     - . <br><br> <b>:</b> , ,           ,        ,      - . <br><br> <b>:</b>    ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Boost</a> . <br><br> <b>:</b> ,  . Boost , ,   , …  -        .    std::string,  ,    .    size(),  length(),      :  ,    -  ?    -  ,    ,     .   , .  ,  , ,       .      ,    ,        ,   -  . <br><br><img src="https://habrastorage.org/webt/nh/k7/cd/nhk7cdikdhqxbdfj52qibe_pybo.jpeg"><br><br><h2>  </h2><br> <b>:</b>            , , ,    .       ? <br><br> <b>:</b>      , ,      «»,    . <br><br> <b>:</b>  . <br><br> <b>:</b>    embedded-,      include,  ? <br><br> <b>:</b>       .   embedded  -. <br><br> ,     , -  ?   ,    ,     .     ? <br><br> <b>:</b>  .   150 .   -     ,   .  . <br><br> <b>:</b>      ,    ! <br><br> <b>:</b>   ,     Steam, , , 64 . ,  150   ? <br><br> <b>:</b> , , . <br><br> <b>:</b>       ,        -.         ?     ,  ,      ,   —  ,    zero cost abstractions  .       -? <br><br> <b>:</b>       ,  ,       ,   , ? <br><br> <b>:</b>    ,     .      ,    ,    . <br><br> <b>:</b> ,      ,    ,   .     — ,     .     ,    .     ,   ,  .     ,  .    -.      C. <br><br> <b>:</b>   .      «».       : ,            .  ,    ,   ,     .      .  ,       . <br><br> <b>:</b> ,   .     . ,  .      proposal.    . <br><br> <b>:</b>   ,    proposal.      ,       « »: ,  STL  ,    . ,  -   ,      . <br><br> <b>:</b> STL        . STL  .  ,    ,   STL  —  ,    ,      . <br><br> <b>:</b>  ,   —   ,    ?   ,     greenfield.    brownfield development,   .   — ,  .   —  .   ? <br><br> <b>:</b>  ,  .   ,   ,    .   ,   .      ,   ,     . G++  , Clang  .   . <br><br> <b>:</b>  , ,      ,     .  «    ,   A,  B».     ,      .NET,         .  ,  ,     ,         ,       ,       ? <br><br> <b>:</b>  ,  ,     . ,    C++ 2.0.  ++C++.      ,     C. <br><br> <b>:</b>  ,    .          ,   ,  . ,  , ,   ,  #include  #import  -    —   .  ,           . ,   ,    ,           , . <br><br>     .    ,       .    , ,       ,      C#  C++,             . <br><br> <b>:</b>    ,      ,     10  .     ,  ,   ,     ,    ,       ,   .         « »,      .      ,        . <br><br> C# ,      C++.   ,     C#     .       ,   ,   .      ,  ,     , ,  JIT' —  ,   ,         -   (    int).  ,     ,   ,     ,    . <br><br> <b>:</b> ,  ,   ,   C#       —     .  ,    ,   C++  .  ,     .  ( ,   ) —   cutting edge.    ,     UI-  C++,      ,   .   C# — .  C++   ,   . <br><br>       ,   . ,     ,       ,    C++   ,  ,   , . ,     . <br><br>         ,  C#     Microsoft.   ,    .NET Foundation,      ,   ,   Microsoft.   ,             . <br><br><hr><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C++ Russia</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DotNext</a> .  :    ? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN469467/">https://habr.com/ru/post/zh-CN469467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN469457/index.html">盛会的去向</a></li>
<li><a href="../zh-CN469459/index.html">在智慧城市中连接物联网设备</a></li>
<li><a href="../zh-CN469461/index.html">“献给星星”：反宇宙的“今日启示录”</a></li>
<li><a href="../zh-CN469463/index.html">自然语言处理的趋势和预测</a></li>
<li><a href="../zh-CN469465/index.html">现代C ++中的初始化</a></li>
<li><a href="../zh-CN469471/index.html">“ 5美分”谈排序</a></li>
<li><a href="../zh-CN469475/index.html">Flash的兴衰，是塑造现代网络的烦人插件</a></li>
<li><a href="../zh-CN469477/index.html">苹果该停止将iPad与PC进行比较了</a></li>
<li><a href="../zh-CN469479/index.html">量子概率从何而来</a></li>
<li><a href="../zh-CN469487/index.html">在GNU / Linux中配置top</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>