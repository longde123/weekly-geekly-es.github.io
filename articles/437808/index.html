<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßõ üë©üèª‚Äçü§ù‚Äçüë®üèæ ‚òùüèª Perf y flamegraphs üèº üå¥ üïã</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El tema de mejorar el rendimiento de los sistemas operativos y encontrar cuellos de botella est√° ganando una inmensa popularidad. En este art√≠culo, ha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perf y flamegraphs</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/selectel/blog/437808/"><img src="https://habrastorage.org/webt/pa/ue/x8/pauex8un6--wep6-1ehqvmciieg.png"><br><br>  El tema de mejorar el rendimiento de los sistemas operativos y encontrar cuellos de botella est√° ganando una inmensa popularidad.  En este art√≠culo, hablaremos sobre una herramienta para encontrar estos lugares utilizando el ejemplo de la pila de bloques en Linux y un caso de resoluci√≥n de problemas de un host. <br><br><h2>  Ejemplo 1. Prueba </h2><br><h3>  Nada funciona </h3><br>  Las pruebas en nuestro departamento son sint√©ticas en el hardware del producto y, m√°s tarde, pruebas de software de aplicaci√≥n.  Recibimos una unidad Intel Optane para realizar pruebas.  Ya escribimos sobre probar las unidades Optane <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en nuestro blog</a> . <br><br>  El disco se instal√≥ en un servidor est√°ndar construido durante un tiempo relativamente largo en uno de los proyectos en la nube. <br><a name="habracut"></a><br>  Durante la prueba, el disco no se mostr√≥ de la mejor manera: durante la prueba con la profundidad de la cola de 1 solicitud por 1 flujo, en bloques de 4Kbytes aproximadamente ~ 70Kiops.  Y esto significa que el tiempo de respuesta es enorme: ¬°aproximadamente 13 microsegundos por solicitud! <br><br>  Es extra√±o, porque la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaci√≥n</a> promete "Latencia - Leer 10 ¬µs", y obtuvimos un 30% m√°s, la diferencia es bastante significativa.  El disco se reorganiz√≥ a otra plataforma, un ensamblaje m√°s "nuevo" utilizado en otro proyecto. <br><br><h3>  Por que funciona </h3><br>  Es divertido, pero la unidad en la nueva plataforma funcion√≥ como deber√≠a.  Aumento del rendimiento, disminuci√≥n de la latencia, CPU por estante, 1 transmisi√≥n por solicitud, bloques de 4 Kbytes, ~ 106Kiops a ~ 9 microsegundos por solicitud. <br><br>  Y luego es hora de <s>comparar la configuraci√≥n</s> para obtener el <b>rendimiento</b> de las <b>piernas</b> anchas.  Despu√©s de todo, nos preguntamos por qu√©.  Con <b>perf,</b> puedes: <br><br><ul><li>  Tome las lecturas del contador de hardware: la cantidad de llamadas de instrucciones, errores de cach√©, ramas predichas incorrectamente, etc.  (Eventos de PMU) </li><li>  Eliminar informaci√≥n de puntos comerciales est√°ticos, el n√∫mero de ocurrencias </li><li>  Realizar rastreo din√°mico </li></ul><br>  Para la verificaci√≥n, usamos muestreo de CPU. <br><br>  La conclusi√≥n es que <b>perf</b> puede compilar todo el seguimiento de la pila de un programa en ejecuci√≥n.  Naturalmente, ejecutar <b>perf</b> introducir√° un retraso en la operaci√≥n de todo el sistema.  Pero tenemos la bandera <i>-F #</i> , donde <i>#</i> es la frecuencia de muestreo, medida en Hz. <br><br>  Es importante comprender que cuanto mayor sea la frecuencia de muestreo, m√°s probabilidades hay de capturar una llamada a una funci√≥n en particular, pero m√°s frenos trae el generador de perfiles al sistema.  Cuanto menor es la frecuencia, mayor es la posibilidad de que no veamos parte de la pila. <br><br>  Al elegir una frecuencia, debe guiarse por el sentido com√∫n y un truco: trate de no establecer una frecuencia uniforme, para no entrar en una situaci√≥n en la que un trabajo que se ejecuta en un temporizador con esta frecuencia ingresa a las muestras. <br><br>  Otro punto que es inicialmente enga√±oso: el software debe compilarse con el indicador <i>-fno-omit-frame-pointer</i> , si esto es posible, por supuesto.  De lo contrario, en la traza, en lugar de nombres de funciones, veremos valores s√≥lidos <i>desconocidos</i> .  Para algunos programas, los s√≠mbolos de depuraci√≥n vienen como un paquete separado, por ejemplo, <i>someutil-dbg</i> .  Se recomienda que los instale antes de ejecutar <b>perf</b> . <br><br>  Realizamos las siguientes acciones: <br><br><ul><li>  Tomado de fio de git: //git.kernel.dk/fio.git, etiqueta fio-3.9 </li><li>  Se agreg√≥ la <em>opci√≥n -fno-omit-frame-pointer</em> a CPPFLAGS en Makefile </li><li>  Lanzado <em>make -j8</em> </li></ul><br><pre><code class="bash hljs">perf record -g ~/fio/fio --name=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> --rw=randread --bs=4k --ioengine=pvsync2 --filename=/dev/nvme0n1 --direct=1 --hipri --filesize=1G</code> </pre> <br>  La opci√≥n -g es necesaria para capturar la pila de trazas. <br><br>  Puede ver el resultado con el comando: <br><br><pre> <code class="bash hljs">perf report -g fractal</code> </pre> <br>  La opci√≥n <i>fractal -g</i> es necesaria para que los porcentajes que reflejan el n√∫mero de muestras con esta funci√≥n y se muestren por <b>perf</b> sean relativos a la funci√≥n de llamada, cuyo n√∫mero de llamadas se toma como 100%. <br><br>  Hacia el final de la larga pila de llamadas fio en la plataforma de "nueva construcci√≥n", veremos: <br><br><img src="https://habrastorage.org/webt/_y/pn/jb/_ypnjb3xkf3urq140p0qssevtku.png"><br><br>  Y en la plataforma "old build": <br><br><img src="https://habrastorage.org/webt/gq/kx/ul/gqkxulpyxspbmfudoxhh7ysdv1e.png"><br><br>  Genial  Pero quiero bellos flamegrafs. <br><br><h3>  Construyendo flamegramas </h3><br>  Para ser bella, hay dos herramientas: <br><br><ul><li>  Relativamente m√°s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">flamegraph</a> est√°tico </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Flamescope</a> , que permite seleccionar un per√≠odo espec√≠fico de tiempo de las muestras recolectadas.  Esto es muy √∫til cuando el c√≥digo de b√∫squeda carga la CPU con r√°fagas cortas. </li></ul><br>  Estas utilidades aceptan <b>perf script&gt; result</b> como entrada. <br><br>  Descargue el <i>resultado</i> y env√≠elo a trav√©s de tuber√≠as a <i>svg</i> : <br><br><pre> <code class="bash hljs">FlameGraph/stackcollapse-perf.pl ./result | FlameGraph/flamegraph.pl &gt; ./result.svg</code> </pre> <br>  Abrir en un navegador y disfrutar de una imagen en la que se puede hacer clic <br><br>  Puedes usar otro m√©todo: <br><br><ol><li>  A√±adir <i>resultado</i> a flamescope / example / </li><li>  Ejecute python ./run.py </li><li>  Pasamos por el navegador hasta el puerto 5000 del host local. </li></ol><br><h3>  ¬øQu√© vemos al final? </h3><br>  Un buen fio pasa mucho tiempo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encuestando</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/o1/zg/wy/o1zgwy-l6idzwcxniq16ndbskvo.png"></div><br>  Un fio malo pasa tiempo en cualquier parte, pero no en encuestas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3z/er/bz/3zerbzvtrpwznzewdteyf6bexfq.png"></div><br>  A primera vista, parece que el sondeo no funciona en el host anterior, pero en todas partes el n√∫cleo 4.15 es del mismo ensamblaje y el sondeo est√° habilitado de forma predeterminada en los discos NVMe.  Compruebe si el sondeo est√° habilitado en <b>sysfs</b> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cat /sys/class/block/nvme0n1/queue/io_poll 1</span></span></code> </pre> <br>  Durante las pruebas, se <i>utilizan</i> llamadas <i>preadv2</i> con el indicador <i>RWF_HIPRI</i> , una condici√≥n necesaria para que el sondeo funcione.  Y, si estudia cuidadosamente el gr√°fico de la llama (o la captura de pantalla anterior de la salida del <b>informe de</b> rendimiento), puede encontrarlo, pero lleva una cantidad muy peque√±a de tiempo. <br><br>  La segunda cosa que es visible es la pila de llamadas diferente para la funci√≥n submit_bio () y la falta de llamadas io_schedule ().  Echemos un vistazo m√°s de cerca a la diferencia dentro de submit_bio (). <br><br>  Plataforma lenta "construcci√≥n anterior": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/ba/ew/sdbaewdxmxq2qqy7w6xwlkmpuia.png"></div><br>  Plataforma r√°pida "fresca": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_a/d2/_w/_ad2_wholhggbeewyuoxvqdpuas.png"></div><br>  Parece que en una plataforma lenta, la solicitud llega muy lejos al dispositivo, al mismo tiempo que <b>ingresa al programador de Kyber</b> .  Puede leer m√°s sobre los programadores de E / S en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestro art√≠culo</a> . <br><br>  Una vez que <b>kyber</b> se apag√≥, la misma prueba de fio mostr√≥ una latencia promedio de aproximadamente 10 microsegundos, tal como se indica en la especificaci√≥n.  Genial <br><br>  Pero, ¬øde d√≥nde viene la diferencia en otro microsegundo? <br><br><h3>  ¬øY si un poco m√°s profundo? </h3><br>  Como ya se mencion√≥, <b>perf le</b> permite recopilar estad√≠sticas de contadores de hardware.  Intentemos ver la cantidad de errores de cach√© e instrucciones por ciclo: <br><br><pre> <code class="bash hljs">perf <span class="hljs-built_in"><span class="hljs-built_in">stat</span></span> -e cycles,instructions,cache-references,cache-misses,bus-cycles /root/fio/fio --clocksource=cpu --name=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=10</code> </pre> <br><img src="https://habrastorage.org/webt/ue/pc/fo/uepcfo8up5ehpvqb1ophotqjzb8.png"><br><br><img src="https://habrastorage.org/webt/p5/ln/al/p5lnalg0u05xtvc5792ghegtv34.png"><br><br>  De los resultados se puede ver que una plataforma r√°pida ejecuta m√°s instrucciones para el ciclo de la CPU y tiene un menor porcentaje de errores de cach√© durante la ejecuci√≥n.  Por supuesto, no entraremos en detalles sobre el funcionamiento de diferentes plataformas de hardware en el marco de este art√≠culo. <br><br><h2>  Ejemplo 2. Tienda de comestibles </h2><br><h3>  Algo va mal </h3><br>  En el trabajo de un sistema de almacenamiento distribuido, se observ√≥ un aumento en la carga en la CPU en uno de los hosts con un aumento en el tr√°fico entrante.  Los hosts son pares, pares y tienen hardware y software id√©nticos. <br><br>  Veamos la carga de la CPU: <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># pidstat -p 1441734 1 Linux 3.13.0-96-generic (lol) 10/10/2018 _x86_64_ (24 CPU) 09:23:30 PM UID PID %usr %system %guest %CPU CPU Command 09:23:44 PM 0 1441734 23.00 1.00 0.00 24.00 4 ceph-osd 09:23:45 PM 0 1441734 85.00 34.00 0.00 119.00 4 ceph-osd 09:23:46 PM 0 1441734 0.00 130.00 0.00 130.00 4 ceph-osd 09:23:47 PM 0 1441734 121.00 0.00 0.00 121.00 4 ceph-osd 09:23:48 PM 0 1441734 28.00 82.00 0.00 110.00 4 ceph-osd 09:23:49 PM 0 1441734 4.00 13.00 0.00 17.00 4 ceph-osd 09:23:50 PM 0 1441734 1.00 6.00 0.00 7.00 4 ceph-osd</span></span></code> </pre> <br>  El problema surgi√≥ a las 09:23:46 y vemos que el proceso funcion√≥ en el espacio del n√∫cleo exclusivamente durante todo el segundo.  Veamos lo que estaba sucediendo adentro. <br><br><h3>  ¬øPor qu√© tan lento? </h3><br>  En este caso, tomamos muestras de todo el sistema: <br><br><pre> <code class="bash hljs">perf record -a -g -- sleep 22 perf script &gt; perf.results</code> </pre> <br>  Aqu√≠ se necesita la opci√≥n <i>-a</i> para que <b>perf</b> elimine los rastros de todas las CPU. <br><br>  Abra <b>perf.results</b> con <b>flamescope</b> para rastrear el momento de mayor carga de CPU. <br><br><div class="spoiler">  <b class="spoiler_title">Mapa de calor</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ao/db/hq/aodbhqbwotkcwaq99bvmbznkbrg.png"></div><br></div></div><br>  Ante nosotros hay un "mapa de calor", cuyos dos ejes (X e Y) representan el tiempo. <br><br>  En el eje X, el espacio se divide en segundos, y en el eje Y, en segmentos de 20 milisegundos en X segundos. El tiempo corre de abajo hacia arriba y de izquierda a derecha.  Los cuadrados m√°s brillantes tienen el mayor n√∫mero de muestras.  Es decir, la CPU en este momento trabaj√≥ m√°s activamente. <br><br>  En realidad, estamos interesados ‚Äã‚Äãen la mancha roja en el medio.  Selecci√≥nelo con el mouse, haga clic y vea qu√© oculta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gv/kk/ko/gvkkkomg9vl7u1ylpwx7h8pceqc.png"></div><br>  En general, ya es evidente que el problema es la operaci√≥n lenta <i>tcp_recvmsg</i> y <i>skb_copy_datagram_iovec</i> en √©l. <br><br>  Para mayor claridad, compare con muestras de otro host en el que la misma cantidad de tr√°fico entrante no causa problemas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v6/_j/72/v6_j72zqvscfolhkaipeoyx9lg8.png"></div><br>  Basado en el hecho de que tenemos la misma cantidad de tr√°fico entrante, plataformas id√©nticas que han estado funcionando durante mucho tiempo sin parar, podemos suponer que los problemas surgieron del lado del hierro.  La funci√≥n <i>skb_copy_datagram_iovec</i> copia datos de la estructura del n√∫cleo a la estructura en el espacio del usuario para pasar a la aplicaci√≥n.  Probablemente haya problemas con la memoria del host.  Al mismo tiempo, no hay errores en los registros. <br><br>  Reiniciamos la plataforma.  Al cargar el BIOS, vemos un mensaje sobre una barra de memoria rota.  Reemplazo, el host se inicia y el problema con una CPU sobrecargada ya no se reproduce. <br><br><h2>  Postdata </h2><br><h3>  Rendimiento del sistema con perf </h3><br>  En t√©rminos generales, en un sistema ocupado, ejecutar <b>perf</b> puede introducir un retraso en el procesamiento de solicitudes.  El tama√±o de estos retrasos tambi√©n depende de la carga en el servidor. <br><br>  Intentemos encontrar este retraso: <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /root/fio/fio --clocksource=cpu --name=test --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=1 test: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=pvsync2, iodepth=1 fio-3.9-dirty Starting 1 process Jobs: 1 (f=1): [r(1)][100.0%][r=413MiB/s][r=106k IOPS][eta 00m:00s] test: (groupid=0, jobs=1): err= 0: pid=109786: Wed Dec 12 17:25:56 2018 read: IOPS=106k, BW=414MiB/s (434MB/s)(4096MiB/9903msec) clat (nsec): min=8161, max=84768, avg=9092.68, stdev=1866.73 lat (nsec): min=8195, max=92651, avg=9127.03, stdev=1867.13 ‚Ä¶ ~# perf record /root/fio/fio --clocksource=cpu --name=test --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=1 test: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=pvsync2, iodepth=1 fio-3.9-dirty Starting 1 process Jobs: 1 (f=1): [r(1)][100.0%][r=413MiB/s][r=106k IOPS][eta 00m:00s] test: (groupid=0, jobs=1): err= 0: pid=109839: Wed Dec 12 17:27:50 2018 read: IOPS=106k, BW=413MiB/s (433MB/s)(4096MiB/9916msec) clat (nsec): min=8259, max=55066, avg=9102.88, stdev=1903.37 lat (nsec): min=8293, max=55096, avg=9135.43, stdev=1904.01</span></span></code> </pre> <br>  La diferencia no es muy notable, solo alrededor de ~ 8 nanosegundos. <br><br>  Veamos qu√© sucede si aumenta la carga: <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># /root/fio/fio --clocksource=cpu --name=test --numjobs=4 --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=1 test: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=pvsync2, iodepth=1 ... fio-3.9-dirty Starting 4 processes Jobs: 4 (f=4): [r(4)][100.0%][r=1608MiB/s][r=412k IOPS][eta 00m:00s] ~# perf record /root/fio/fio --clocksource=cpu --name=test --numjobs=4 --bs=4k --filename=/dev/nvme0n1p4 --direct=1 --ioengine=pvsync2 --hipri --rw=randread --filesize=4G --loops=1 test: (g=0): rw=randread, bs=(R) 4096B-4096B, (W) 4096B-4096B, (T) 4096B-4096B, ioengine=pvsync2, iodepth=1 ... fio-3.9-dirty Starting 4 processes Jobs: 4 (f=4): [r(4)][100.0%][r=1584MiB/s][r=405k IOPS][eta 00m:00s]</span></span></code> </pre> <br>  Aqu√≠ la diferencia ya se est√° haciendo notable.  Se puede decir que el sistema se desaceler√≥ en menos del 1%, pero esencialmente perder alrededor de 7 Kiops en un sistema muy cargado puede provocar problemas. <br><br>  Est√° claro que este ejemplo es sint√©tico, sin embargo es muy revelador. <br><br>  Intentemos ejecutar otra prueba sint√©tica que calcule n√∫meros primos - <i>sysbench</i> : <br><br><pre> <code class="bash hljs">~<span class="hljs-comment"><span class="hljs-comment"># sysbench --max-time=10 --test=cpu run --num-threads=10 --cpu-max-prime=100000 ... Test execution summary: total time: 10.0140s total number of events: 3540 total time taken by event execution: 100.1248 per-request statistics: min: 28.26ms avg: 28.28ms max: 28.53ms approx. 95 percentile: 28.31ms Threads fairness: events (avg/stddev): 354.0000/0.00 execution time (avg/stddev): 10.0125/0.00 ~# perf record sysbench --max-time=10 --test=cpu run --num-threads=10 --cpu-max-prime=100000 ‚Ä¶ Test execution summary: total time: 10.0284s total number of events: 3498 total time taken by event execution: 100.2164 per-request statistics: min: 28.53ms avg: 28.65ms max: 28.89ms approx. 95 percentile: 28.67ms Threads fairness: events (avg/stddev): 349.8000/0.40 execution time (avg/stddev): 10.0216/0.01</span></span></code> </pre> <br>  Aqu√≠ puede ver que incluso el tiempo m√≠nimo de procesamiento aument√≥ en 270 microsegundos. <br><br><h3>  En lugar de una conclusi√≥n </h3><br>  <b>Perf</b> es una herramienta muy poderosa para analizar el rendimiento del sistema y la depuraci√≥n.  Sin embargo, como con cualquier otra herramienta, debe mantenerse en control y recordar que cualquier sistema cargado bajo estrecha supervisi√≥n funciona peor. <br><br>  Enlaces relacionados: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejemplos de una sola l√≠nea con perf</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wiki wiki</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437808/">https://habr.com/ru/post/437808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437796/index.html">¬øAlphaStar implement√≥ la velocidad sobrehumana como un parche para el error de entrenamiento de simulaci√≥n?</a></li>
<li><a href="../437800/index.html">ScrumBut en el equipo de an√°lisis: antes del despegue</a></li>
<li><a href="../437802/index.html">Innovar tecnolog√≠a en la nube: nube catastr√≥fica</a></li>
<li><a href="../437804/index.html">¬øPuedo usar Redux en un servidor?</a></li>
<li><a href="../437806/index.html">EcmaScript 10 - JavaScript de este a√±o (ES2019)</a></li>
<li><a href="../437810/index.html">Realidad corporativa</a></li>
<li><a href="../437812/index.html">Xcode 10.2, macOS Mojave 10.14.4, iOS 12.1 y otras versiones beta</a></li>
<li><a href="../437814/index.html">Xcode 10.2, macOS Mojave 10.14.4, iOS 12.1 y otras versiones beta</a></li>
<li><a href="../437816/index.html">MPLS est√° en todas partes. ¬øC√≥mo es la infraestructura de red Yandex.Cloud</a></li>
<li><a href="../437818/index.html">Le ense√±amos a la computadora a distinguir los sonidos: conocer el concurso DCASE y armar su clasificador de audio en 30 minutos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>