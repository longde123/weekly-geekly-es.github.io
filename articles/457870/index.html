<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👱 😶 🖖🏼 Proyecto construir infraestructura con docker 🏉 🚣 🉑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya hay materiales en Habr sobre cómo configurar docker- container para la compilación del proyecto. Por ejemplo, Usar Docker para compilar y ejecutar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Proyecto construir infraestructura con docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457870/"><p>  Ya hay materiales en Habr sobre cómo configurar <strong>docker-</strong> container para la compilación del proyecto.  Por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Usar Docker para compilar y ejecutar un proyecto C ++</a> .  En este artículo, como en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anterior, se considerará</a> el tema de la construcción del proyecto, pero aquí me gustaría ir más allá del tutorial y considerar más profundamente los problemas del uso de contenedores en tales tareas, así como la construcción de la infraestructura de construcción con <strong>Docker</strong> . </p><a name="habracut"></a><br><h2 id="nemnogo-o-docker">  Un poco sobre docker </h2><br><p>  Para mayor claridad de la discusión adicional, es necesario proporcionar una descripción de algunos componentes de la <strong>ventana acoplable</strong> . </p><br><h3 id="image">  Imagen </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La imagen Docker</a> es una plantilla de <strong>solo lectura</strong> con instrucciones para crear un contenedor.  Para crear la <strong>imagen,</strong> debe crear un <strong>Dockerfile</strong> , que describe todos los pasos del ensamblaje.  Cada uno de estos pasos crea una capa separada dentro de la <strong>imagen</strong> .  Cada capa posterior se superpone a todas las anteriores y contiene solo los cambios que deben realizarse en la capa anterior. </p><br><p>  Por ejemplo, para un <strong>Dockerfile</strong> : </p><br><pre><code class="plaintext hljs">FROM ubuntu:18.04 ADD app.sh /app ENTRYPOINT /bin/bash /app/app.sh</code> </pre> <br><p>  <strong>La</strong> imagen del <strong>acoplador</strong> tendrá la siguiente estructura: </p><br><p><img src="https://habrastorage.org/webt/va/pv/rh/vapvrhrjuhirk1fw2up-_h-osau.png"></p><br><p>  Las capas dentro de la <strong>imagen se</strong> almacenan en caché y se pueden reutilizar si no se detectan cambios.  Si se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cambia</a> la capa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">(agregada / eliminada)</a> , todas las subsiguientes se crean desde cero.  Para realizar cambios en la imagen del contenedor (y, en consecuencia, en el entorno del proceso iniciado), es suficiente reparar el <strong>Dockerfile</strong> y comenzar a construir la imagen. </p><br><h3 id="konteyner">  Contenedor </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un contenedor docker</a> es una instancia de inicio de <strong>imagen</strong> .  Se puede crear, iniciar, detener, eliminar, etc. De manera predeterminada, los contenedores están aislados entre sí y del sistema host.  Al inicio, el contenedor inicia un comando, que se puede especificar en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ENTRYPOINT</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CMD</a> , y se detiene cuando se completa.  Una situación aceptable es cuando <strong>CMD</strong> y <strong>ENTRYPOINT están presentes</strong> , ya que interactúan como se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">describe en la documentación</a> . </p><br><p>  Cuando crea cada contenedor, se agrega una nueva capa encima de todas las existentes.  Se puede escribir en el contenedor actual y se destruye junto con el contenedor.  Todas las operaciones de escritura, creación de nuevos archivos durante la operación del contenedor se aplican a esta capa, la <strong>imagen</strong> siempre permanece sin cambios.  Por lo tanto, la estructura de capas del contenedor creado se verá así: </p><br><p><img src="https://habrastorage.org/webt/yj/eb/rk/yjebrku_12g3cuu3qnl6xfdtdbo.png"></p><br><p>  Al usar el <code>docker run</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, se</a> creará <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un <strong>nuevo</strong></a> contenedor cada vez, con <strong>su propia</strong> capa para escribir.  En las tareas de compilación, esto significa que cada vez que se inicia, creará un nuevo entorno limpio que no tiene nada que ver con ejecuciones anteriores.  La lista de contenedores creados se puede ver ejecutando el comando: <code>docker container ls -a</code> . </p><br><h2 id="sobiraem-proekt-v-konteynere">  Recogemos el proyecto en el contenedor. </h2><br><p>  Para mayor claridad, describimos brevemente el proceso de creación de una aplicación en un contenedor; este proceso se describe con más detalle en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo 1</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo 2</a> . </p><br><p>  Los pasos esquemáticamente posibles para construir la aplicación en <strong>Docker</strong> se pueden representar de la siguiente manera: <br><img src="https://habrastorage.org/webt/g_/ru/kt/g_ruktfloq-0loozoxjo9aafxga.png"></p><br><p>  Analicemos los pasos que se muestran: </p><br><ol><li>  Usamos el <strong>Dockerfile</strong> , que describe el entorno, los comandos para ensamblar y copiar los resultados, y en base a él creamos una imagen del contenedor. </li><li>  Usamos la imagen resultante para crear y lanzar el contenedor con el <code>docker run</code> .  Montamos la carpeta de origen y la carpeta donde se copiará el resultado del ensamblaje en el contenedor. </li><li>  Una vez que se completa el contenedor, los artefactos de ensamblaje se colocarán en el directorio montado. </li></ol><br><p>  Un ejemplo se da en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> . </p><br><p>  Dado que el <code>docker run</code> se usa aquí, para cada lanzamiento se creará un contenedor separado con su propia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">capa para escribir</a> , por lo que los archivos temporales de ensamblajes anteriores no entrarán en el actual.  Recuerde limpiar los contenedores detenidos. </p><br><p>  El montaje del directorio de origen facilita la depuración del ensamblaje.  Pero conlleva riesgos: puede recopilar una versión del código que no haya pasado el control de calidad o que no se haya agregado al sistema de control de versiones.  Para evitar esto, puede clonar el repositorio git dentro del contenedor en cada compilación, como, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el archivo</a> : </p><br><pre> <code class="plaintext hljs">FROM ubuntu:bionic RUN apt-get update \ &amp;&amp; apt-get install -y apt-utils RUN apt-get update \ &amp;&amp; apt-get install -y make gcc g++ qt5-default git RUN mkdir -p /app/src WORKDIR /app/build #       ENTRYPOINT git -C /app/src clone https://github.com/sqglobe/SimpleQtProject.git \ &amp;&amp; qmake /app/src/SimpleQtProject/SimpleQtProject.pro \ &amp;&amp; make \ &amp;&amp; cp SimpleQtProject /app/res/SimpleQtProject-ubuntu-bionic</code> </pre> <br><p>  Aquí, la clonación se realiza en <code>ENTRYPOINT</code> , no en la instrucción <code>RUN</code> , debido al almacenamiento en caché.  <code>ENTRYPOINT</code> <strong>siempre se</strong> ejecuta cuando se inicia el contenedor, y el resultado del comando <code>RUN</code> se puede <strong>tomar del caché</strong> . </p><br><h2 id="infrastruktura-dlya-sborki">  Construir infraestructura </h2><br><p>  Para construir un proyecto para diferentes sistemas operativos o <strong>distribuciones de</strong> Linux, se puede usar una determinada configuración de servidores (máquinas de compilación, servidores con un sistema de control de versiones, etc.).  En la práctica, tuve que lidiar con la siguiente infraestructura: </p><br><p><img src="https://habrastorage.org/webt/ue/0i/1w/ue0i1wmgapl-8x9h9-zw-bsrbi8.png"></p><br><p>  Aquí, el usuario accede al servidor <strong>web a</strong> través del cual se construye el proyecto en máquinas con <strong>Ubuntu</strong> y <strong>Red Hat</strong> .  A continuación, en cada máquina, el repositorio git se clona con el proyecto en un directorio temporal y se inicia el ensamblaje.  El usuario puede descargar los archivos resultantes desde la misma página desde la que inició todo el proceso. </p><br><p>  Tal ensamblaje es repetible porque los desarrolladores usan el mismo entorno. </p><br><p>  De las desventajas: es necesario mantener una infraestructura completa, administrar varios servidores, eliminar errores en scripts y aplicaciones <strong>web</strong> , etc. </p><br><h2 id="uproschaem-s-docker">  Simplifica con Docker </h2><br><p>  Apoyar la infraestructura que se muestra arriba requiere ciertos costos, tanto monetarios como humanos.  Si su equipo está trabajando en una pequeña startup, o si usted es el único desarrollador, puede usar contenedores <strong>acoplables</strong> para implementar su infraestructura de compilación. </p><br><p>  Considere un proyecto trivial de <strong>Qt</strong> que se construye usando <strong>qmake</strong> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SimpleQtProject</a> .  La carpeta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acoplable</a> del proyecto especificado contiene varios archivos: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">centos7.docker</a> : describe un contenedor para construir un proyecto para <strong>CentOS 7</strong> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ubuntu-bionic.docker</a> - un contenedor para construir bajo <strong>Ubuntu 18.04</strong> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ubuntu-xenial.docker</a> : describe un contenedor para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compilar</a> en <strong>Ubuntu 16.04</strong> . </li></ul><br><p>  Estos archivos implementan la idea de clonar el código fuente dentro de un contenedor. </p><br><p>  Todo el ensamblaje se inicia utilizando el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Makefile</a> .  Es muy corto y contiene suficientes comentarios.  Su base es la creación de una imagen y el lanzamiento del contenedor: </p><br><pre> <code class="plaintext hljs">%: %.docker docker build -t simple-qt-$(strip $(subst .docker,, $&lt; )) --file $&lt; . docker run --mount type=bind,source=$(RELEASE_DIR),target=/app/res simple-qt-$(strip $(subst .docker,, $&lt; ))</code> </pre> <br><p>  En esta etapa del ensamblaje, se crea una imagen del contenedor con el nombre que consiste en el prefijo <strong>simple-qt-</strong> y el nombre del sistema (para <strong>centos 7</strong> será <strong>simple-qt-centos7</strong> ).  Como <strong>Dockerfile</strong> , se <strong>utiliza</strong> el archivo correspondiente con el permiso <strong>.docker</strong> .  A continuación, el contenedor se inicia en función de la imagen creada y se monta una carpeta para copiar los artefactos de ensamblaje. </p><br><p>  Después de ejecutar el <code>make</code> en el directorio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">docker</a> , la carpeta <strong>docker / releases</strong> contendrá los resultados de la compilación para varias plataformas. </p><br><p>  Por lo tanto, nuestra infraestructura para construir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SimpleQtProject</a> se verá así: </p><br><p><img src="https://habrastorage.org/webt/bs/bg/ru/bsbgru5mo2bcrqb4z_31sdreyt8.png"></p><br><p>  Ventajas de esta configuración: </p><br><ol><li>  <strong>Localidad</strong> .  El desarrollador recopila un proyecto para varias plataformas en su máquina local, esto elimina la necesidad de contener una flota de servidores, configurar la copia de artefactos entre servidores a través de la red, enviar y procesar comandos de red. </li><li>  <strong>Aislamiento del medio ambiente</strong> .  El contenedor proporciona un entorno completamente aislado para construir una aplicación específica.  Es posible construir proyectos con entornos incompatibles en la misma máquina (por ejemplo, aquellos que requieren diferentes versiones de la misma biblioteca). </li><li>  <strong>Versionado</strong>  Al colocar el <strong>Dockerfile</strong> en el repositorio de git, puede realizar un seguimiento de los cambios en el entorno de compilación con el lanzamiento de nuevas versiones, volver a las versiones anteriores del entorno de compilación, etc. </li><li>  <strong>Movilidad</strong>  Si es necesario, esta infraestructura se implementa sin problemas en otra computadora.  La tecnología para crear <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una imagen de contenedor le</a> permite realizar cambios en la imagen en sí muy fácilmente, solo actualice el <strong>Dockerfile</strong> y comience a construir la imagen. </li><li>  <strong>Auto documentado</strong> .  Esencialmente, un <strong>Dockerfile</strong> contiene pasos para implementar un entorno de ensamblaje.  Por lo tanto, si es necesario, implemente dicho entorno, pero ya en un sistema normal, puede usar los comandos de él. </li><li>  <strong>Ligereza</strong>  El contenedor comienza en el momento en que comienza el ensamblaje y se detiene automáticamente al finalizar.  No desperdicia tiempo de CPU y RAM. </li></ol><br><p>  Sin embargo, hay un inconveniente significativo: el ensamblaje del proyecto requerirá el ensamblaje de la imagen del contenedor.  Cuando comienzas por primera vez, puede tomar mucho tiempo.  Pero con los repetidos, especialmente si el <strong>Dockerfile</strong> no <strong>ha</strong> cambiado, la imagen se ensambla usando el caché muchas veces más rápido. </p><br><p>  También es necesario recordar limpiar los contenedores detenidos. </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>  En conclusión, me gustaría señalar que <strong>Docker</strong> no es la única tecnología de contenedorización.  Pero hay algunas características que lo distinguen favorablemente para las tareas de ensamblaje del mismo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LXC</a> : </p><br><ol><li>  Puede crear un contenedor utilizando un texto <strong>Dockerfile</strong> .  Este es un archivo con sintaxis simple, puede agregarlo al repositorio del proyecto (como siempre lo hago) y tenerlo siempre a mano. </li><li>  Cada vez, al iniciar el contenedor <strong>Docker</strong> con el <code>docker run</code> obtenemos un entorno <em>limpio</em> , como si estuviéramos haciendo todo por primera vez.  Los archivos temporales entre ensamblajes no se guardan. </li><li>  El contenedor no inicia todo el sistema operativo, sino solo el proceso de ensamblaje necesario. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457870/">https://habr.com/ru/post/457870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457854/index.html">Hola de los programadores de los 80.</a></li>
<li><a href="../457860/index.html">Desarrollando una aplicación para streaming usando Node.js y React</a></li>
<li><a href="../457862/index.html">iOS Digest No. 8 (14 de junio - 27 de junio)</a></li>
<li><a href="../457864/index.html">Mitos y leyendas del análisis del sistema o lo que hace un analista en un banco</a></li>
<li><a href="../457866/index.html">Pruebas unitarias en Laravel</a></li>
<li><a href="../457872/index.html">¿Cómo administrar el tiempo y dejar de procrastinar?</a></li>
<li><a href="../457874/index.html">¿Por qué regresan los empleados? Historias de partida y regreso</a></li>
<li><a href="../457876/index.html">Traducción: IEEE 802.15.4z Standard. ¿Qué nos espera en el futuro?</a></li>
<li><a href="../457884/index.html">Internet soberano: órdenes aclaratorias</a></li>
<li><a href="../457886/index.html">Autenticación de dos factores en el sitio utilizando un token USB. Ahora para Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>