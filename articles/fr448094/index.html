<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🔬 ♾ 📰 Docker: comment déployer une application full-stack et ne pas devenir gris ✊🏿 🔶 🧕🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Nous avons besoin de DevOps!" 
 (la phrase la plus populaire à la fin de tout hackathon) 

 Tout d'abord, quelques paroles. 

 Quand un développeur e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker: comment déployer une application full-stack et ne pas devenir gris</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448094/"> <i>"Nous avons besoin de DevOps!"</i> <br>  <i>(la phrase la plus populaire à la fin de tout hackathon)</i> <br><img src="https://habrastorage.org/webt/yy/k1/0q/yyk10qsi8ayqzxsnwqua1nwyzrk.jpeg"><br>  Tout d'abord, quelques paroles. <br><br>  Quand un développeur est un excellent développeur qui peut déployer son idée sur n'importe quelle machine sous n'importe quel OC, c'est un plus.  Cependant, s'il ne comprend rien de plus que son IDE, ce n'est pas un inconvénient - au final, il est payé pour le code, et non pour la possibilité de le déployer.  Un spécialiste en profondeur étroit sur le marché est évalué plus haut que la compétence moyenne de «cric de tous les métiers».  Pour des gens comme nous, «utilisateurs IDE», de bonnes personnes ont proposé Docker. <br><br>  Le principe de Docker est le suivant: "ça marche pour moi - ça marche partout".  Docker est le seul programme nécessaire pour déployer une copie de votre application n'importe où.  Si vous exécutez votre application dans le docker de votre machine, elle est garantie de fonctionner avec le même succès dans n'importe quel autre docker.  Et rien d'autre qu'un docker doit être installé.  Par exemple, je n'ai même pas Java sur le serveur virtuel. <a name="habracut"></a><br><br><h2>  Comment fonctionne Docker? </h2><br>  Docker crée une image d'une machine virtuelle avec des applications installées.  De plus, cette image se déploie comme une machine virtuelle complètement autonome.  Une copie en cours d'exécution de l'image est appelée un «conteneur».  Vous pouvez exécuter un nombre illimité d'images sur le serveur et chacune d'entre elles sera une machine virtuelle distincte avec son propre environnement. <br><br>  Qu'est-ce qu'une machine virtuelle?  Il s'agit de l'emplacement encapsulé sur le serveur avec le système d'exploitation dans lequel les applications sont installées.  Dans tout système d'exploitation, un grand nombre d'applications tournent généralement, dans le nôtre il y en a une. <br><br>  Le schéma de déploiement de conteneur peut être représenté comme suit: <br><br><img src="https://habrastorage.org/webt/9p/vq/ya/9pvqyam6ckaxqvihopwdoynhf4y.jpeg"><br><br>  Pour chaque application, nous créons notre propre image, puis déployons chaque conteneur séparément.  En outre, vous pouvez mettre toutes les applications dans une image et les déployer en un seul conteneur.  De plus, afin de ne pas déployer chaque conteneur séparément, nous pouvons utiliser un utilitaire docker-compose séparé, qui configure les conteneurs et la relation entre eux via un fichier séparé.  La structure de l'application entière peut alors ressembler à ceci: <br><br><img src="https://habrastorage.org/webt/ga/ft/fm/gaftfmbyumgesqldxv1pphh6ati.jpeg"><br><br>  Je n'ai pas intentionnellement contribué à la base de données à l'assemblage Docker général, pour plusieurs raisons.  Premièrement, la base de données est complètement indépendante des applications qui fonctionnent avec elle.  Cela peut être loin d'une application, il peut s'agir de requêtes manuelles depuis la console.  Personnellement, je ne vois aucune raison de rendre la base de données dépendante de l'assemblage Docker dans lequel elle se trouve.  Par conséquent, je l'ai enduré.  Cependant, une approche est souvent pratiquée dans laquelle la base de données est placée dans une image distincte et lancée dans un conteneur séparé.  Deuxièmement, je veux montrer comment le conteneur Docker interagit avec les systèmes en dehors du conteneur. <br><br>  Cependant, tout à fait les paroles, écrivons le code.  Nous écrirons l'application la plus simple au printemps et réagirons, qui enregistrera nos appels à l'avant dans la base de données, et nous soulèverons tout cela via Docker.  La structure de notre application ressemblera à ceci: <br><br><img src="https://habrastorage.org/webt/k4/pp/lg/k4pplgvwba46vygymrasjctmrkm.jpeg"><br><br>  Il existe de nombreuses façons de mettre en œuvre une telle structure.  Nous mettons en œuvre l'un d'entre eux.  Nous allons créer deux images, en lancer deux conteneurs, et le backend se connectera à la base de données installée sur un serveur spécifique quelque part sur Internet (oui, de telles requêtes de base de données n'iront pas rapidement, mais nous ne sommes pas motivés par la soif d'optimisation, mais intérêt scientifique). <br><br>  Le poste sera divisé en plusieurs parties: <br><br>  0. Installez Docker. <br>  1. Nous rédigeons des candidatures. <br>  2. Nous collectons des images et lançons des conteneurs. <br>  3. Collectez des images et lancez des conteneurs sur un serveur distant. <br>  4. Résolvez les problèmes de réseau. <br><br><h2>  0. Installez Docker </h2><br>  Pour installer Docker, vous devez vous rendre sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site</a> et suivre ce qui y est écrit.  Lors de l'installation de Docker sur un serveur distant, préparez-vous au fait que Docker peut ne pas fonctionner avec des serveurs sur OpenVZ.  De plus, il peut y avoir des problèmes si vous n'avez pas activé iptables.  Il est conseillé de démarrer le serveur sur KVM avec iptables.  Mais ce sont mes recommandations.  Si tout fonctionne pour vous, et donc, je serai heureux que vous n'ayez pas passé beaucoup de temps à comprendre pourquoi cela ne fonctionne pas, comment je devais le faire. <br><br><h2>  1. Nous rédigeons des candidatures </h2><br>  Écrivons une application simple avec le backend le plus primitif sur Spring Boot, un frontend très simple sur ReactJS et une base de données MySQL.  L'application aura une page unique avec un seul bouton qui enregistrera l'heure à laquelle il a été cliqué dessus dans la base de données. <br><br>  J'espère que vous savez déjà comment écrire des applications au démarrage, mais sinon, vous pouvez cloner le projet terminé.  Tous les liens à la fin de l'article. <br><br><h3>  Backend sur Spring Boot </h3><br>  build.gradle: <br><br><pre><code class="java hljs">plugins { id <span class="hljs-string"><span class="hljs-string">'org.springframework.boot'</span></span> version <span class="hljs-string"><span class="hljs-string">'2.1.4.RELEASE'</span></span> id <span class="hljs-string"><span class="hljs-string">'java'</span></span> } apply plugin: <span class="hljs-string"><span class="hljs-string">'io.spring.dependency-management'</span></span> group = <span class="hljs-string"><span class="hljs-string">'ru.xpendence'</span></span> version = <span class="hljs-string"><span class="hljs-string">'0.0.2'</span></span> sourceCompatibility = <span class="hljs-string"><span class="hljs-string">'1.8'</span></span> repositories { mavenCentral() } dependencies { implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-jpa'</span></span> implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-web'</span></span> runtimeOnly <span class="hljs-string"><span class="hljs-string">'mysql:mysql-connector-java'</span></span> testImplementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span></span> }</code> </pre> <br>  Entité de journal: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.xpendence.rebounder.entity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.annotation.JsonFormat; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> javax.persistence.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.Serializable; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.time.LocalDateTime; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Objects; <span class="hljs-comment"><span class="hljs-comment">/** * Author: Vyacheslav Chernyshov * Date: 14.04.19 * Time: 21:20 * e-mail: 2262288@gmail.com */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"request_logs"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Log</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocalDateTime created; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Long </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> <span class="hljs-meta"><span class="hljs-meta">@JsonFormat</span></span>(shape = JsonFormat.Shape.STRING, pattern = <span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd HH:mm:ss.SSS"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LocalDateTime </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> created; } <span class="hljs-meta"><span class="hljs-meta">@PrePersist</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prePersist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.created = LocalDateTime.now(); } <span class="hljs-comment"><span class="hljs-comment">//setters, toString, equals, hashcode, constructors</span></span></code> </pre> <br>  LogController, qui fonctionne sur une logique simplifiée et écrit immédiatement dans la base de données.  Nous omettons le service. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> ru.xpendence.rebounder.controller; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.core.JsonProcessingException; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.fasterxml.jackson.databind.ObjectMapper; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.beans.factory.annotation.Autowired; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.http.ResponseEntity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.GetMapping; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.RequestMapping; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.web.bind.annotation.RestController; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ru.xpendence.rebounder.entity.Log; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ru.xpendence.rebounder.repository.LogRepository; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.logging.Logger; <span class="hljs-comment"><span class="hljs-comment">/** * Author: Vyacheslav Chernyshov * Date: 14.04.19 * Time: 22:24 * e-mail: 2262288@gmail.com */</span></span> <span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>(<span class="hljs-string"><span class="hljs-string">"/log"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Logger LOG = Logger.getLogger(LogController.class.getName()); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LogRepository repository; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LogRepository repository)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.repository = repository; } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ResponseEntity&lt;Log&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Log log = repository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Log()); LOG.info(<span class="hljs-string"><span class="hljs-string">"saved new log: "</span></span> + log.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ResponseEntity.ok(log); } }</code> </pre><br>  Tout, comme nous le voyons, est très simple.  Par une demande GET, nous écrivons dans la base de données et renvoyons le résultat. <br><br>  Nous discuterons séparément du fichier de paramètres d'application.  Il y en a deux. <br><br>  application.yml: <br><br><pre> <code class="java hljs">spring: profiles: active: remote</code> </pre> <br>  application-remote.yml: <br><br><pre> <code class="java hljs">spring: datasource: driver-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">com</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mysql</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cj</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jdbc</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">url</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">jdbc</span></span></span><span class="hljs-class">:</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mysql</span></span></span><span class="hljs-class">://</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">server</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">database</span></span></span><span class="hljs-class">:3306/</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rebounder_database</span></span></span><span class="hljs-class">?</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">useUnicode</span></span></span></span>=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&amp;useJDBCCompliantTimezoneShift=<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>&amp;useLegacyDatetimeCode=<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>&amp;serverTimezone=UTC username: admin password: <span class="hljs-number"><span class="hljs-number">12345</span></span> jpa: hibernate: ddl-auto: update show-sql: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> properties: hibernate.dialect: org.hibernate.dialect.MySQL5Dialect server: port: <span class="hljs-number"><span class="hljs-number">8099</span></span></code> </pre> <br>  Comment cela fonctionne, vous savez probablement que Spring scanne d'abord le fichier application.properties ou application.yml - celui qu'il trouve.  Nous y indiquons un seul paramètre - quel profil nous utiliserons.  Habituellement, pendant le développement, j'accumule plusieurs profils, et il est très pratique de les changer en utilisant le profil par défaut.  Ensuite, Spring trouve application.yml avec le suffixe souhaité et l'utilise. <br><br>  Nous avons spécifié la source de données, les paramètres JPA et, surtout, le port externe de notre backend. <br><br><h3>  ReactJS Frontend </h3><br>  Vous pouvez également voir l'interface dans un projet sur git, ou vous ne pouvez même pas regarder, mais le cloner et l'exécuter. <br><br>  Vous pouvez vérifier le travail individuel du frontend en téléchargeant le projet, en vous rendant dans le dossier racine du projet dans le terminal (où se trouve le fichier package.json) et en exécutant deux commandes en séquence: <br><br><pre> <code class="bash hljs">npm install //      ,  maven npm start //  </code> </pre> <br>  Bien sûr, pour cela, vous avez besoin du Node Package Manager (npm) installé, et c'est le moyen le plus difficile que nous évitons d'utiliser Docker.  Si vous avez toujours démarré le projet, vous verrez la fenêtre suivante: <br><br><img src="https://habrastorage.org/webt/aq/m7/t4/aqm7t4txa2g_rqbuswo3uiibjpq.png"><br><br>  Eh bien, il est temps de regarder le code.  Je n'indiquerai que la partie qui se réfère au backend. <br><br><pre> <code class="java hljs">export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Api</span></span></span><span class="hljs-class"> </span></span>{ _apiPath = <span class="hljs-string"><span class="hljs-string">'http://localhost:8099'</span></span>; _logUrl = <span class="hljs-string"><span class="hljs-string">'/log'</span></span>; getResource = async () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = <span class="hljs-function"><span class="hljs-function">await </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(`${</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._apiPath}${</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">._logUrl}`)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!res.ok) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(`Could not fetch ${<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._logUrl}` + `, received ${res.status}`) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> await res.json(); }; };</code> </pre> <br>  L'interface fonctionne de manière prévisible.  Nous suivons le lien, attendons la réponse et l'affiche à l'écran. <br><br><img src="https://habrastorage.org/webt/xz/vy/qd/xzvyqdrh7akd1c1flu-gnjhcxok.png"><br><br>  Il convient de se concentrer sur les points suivants: <br><br><ol><li>  La façade est ouverte sur le monde extérieur via le port 3000. Il s'agit du port par défaut pour React. </li><li>  L'arrière est ouvert sur le port 8099. Nous l'avons défini dans les paramètres de l'application. </li><li>  Le dos frappe à la base de données via Internet externe. </li></ol><br>  L'application est prête. <br><br><h2>  2. Collectez des images et lancez des conteneurs </h2><br>  La structure de notre assemblée sera la suivante.  Nous allons créer deux images - frontend et backend, qui communiqueront entre elles via des ports externes.  Pour la base, nous ne créerons pas d'image, nous l'installerons séparément.  Pourquoi  Pourquoi ne créons-nous pas une image pour la base?  Nous avons deux applications qui changent constamment et ne stockent pas de données en nous-mêmes.  La base de données stocke les données en soi, ce qui peut être le résultat de plusieurs mois de fonctionnement de l'application.  De plus, cette base de données est accessible non seulement par notre application backend, mais aussi par bien d'autres - pour cela c'est aussi une base de données, et nous ne la réassemblerons pas en permanence.  Encore une fois, c'est l'occasion de travailler avec une API externe, qui, bien sûr, est de se connecter à notre base de données. <br><br><h4>  Assemblage frontal </h4><br>  Pour exécuter chaque application (avant ou arrière), vous avez besoin d'une certaine séquence d'actions.  Pour exécuter l'application sur React, nous devons procéder comme suit (à condition que nous ayons déjà Linux): <br><br><ol><li>  Installez NodeJS. </li><li>  Copiez l'application dans un dossier spécifique. </li><li>  Installez les packages requis (commande npm install). </li><li>  Lancez l'application avec la commande npm start. </li></ol><br>  C'est cette séquence d'actions que nous devons effectuer dans le docker.  Pour ce faire, à la racine du projet (au même endroit que se trouve package.json), nous devons placer le Dockerfile avec le contenu suivant: <br><br><pre> <code class="javascript hljs">FROM node:alpine WORKDIR /usr/app/front EXPOSE <span class="hljs-number"><span class="hljs-number">3000</span></span> COPY ./ ./ RUN npm install CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>]</code> </pre> <br>  Voyons ce que signifie chaque ligne. <br><br><pre> <code class="javascript hljs">FROM node:alpine</code> </pre> <br>  Avec cette ligne, nous indiquons clairement au docker que lorsque vous démarrez le conteneur, la première chose que vous devez faire est de télécharger Docker à partir du référentiel et d'installer NodeJS, et la plus légère (toutes les versions les plus légères des frameworks et bibliothèques populaires dans docker sont généralement appelées alpines). <br><br><pre> <code class="javascript hljs">WORKDIR /usr/app/front</code> </pre> <br>  Dans le conteneur Linux, les mêmes dossiers standard seront créés comme dans les autres Linux - / opt, / home, / etc, / usr et ainsi de suite.  Nous avons défini le répertoire de travail avec lequel nous travaillerons - / usr / app / front. <br><br><pre> <code class="javascript hljs">EXPOSE <span class="hljs-number"><span class="hljs-number">3000</span></span></code> </pre> <br>  Nous ouvrons le port 3000. Une communication supplémentaire avec l'application exécutée dans le conteneur se fera via ce port. <br><br><pre> <code class="javascript hljs">COPY ./ ./</code> </pre> <br>  Copiez le contenu du projet source dans le dossier de travail du conteneur. <br><br><pre> <code class="javascript hljs">RUN npm install</code> </pre> <br>  Installez tous les packages nécessaires pour exécuter l'application. <br><br><pre> <code class="javascript hljs">CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>]</code> </pre> <br>  Nous démarrons l'application avec la commande npm start. <br><br>  Ce scénario sera exécuté dans notre application au démarrage du conteneur. <br><br>  Mettons le front droit.  Pour ce faire, dans le terminal, se trouvant dans le dossier racine du projet (où se trouve le Dockerfile), exécutez la commande: <br><br><pre> <code class="java hljs">docker build -t rebounder-chain-frontend .</code> </pre> <br>  Valeurs de commande: <br><br>  docker est un appel à l'application docker, eh bien, vous le savez. <br>  build - construire une image à partir de matériaux cibles. <br>  -t &lt;nom&gt; - à l'avenir, l'application sera disponible par la balise spécifiée ici.  Vous pouvez omettre cela, puis Docker générera sa propre balise, mais il sera impossible de la distinguer des autres. <br>  .  - indique que vous devez collecter le projet à partir du dossier actuel. <br><br><img src="https://habrastorage.org/webt/ro/fc/nz/rofcnzucfn0207jnqulzpjrgxw4.jpeg"><br><br>  Par conséquent, l'assemblage doit se terminer par le texte: <br><br><pre> <code class="java hljs">Step <span class="hljs-number"><span class="hljs-number">7</span></span>/<span class="hljs-number"><span class="hljs-number">7</span></span> : CMD [<span class="hljs-string"><span class="hljs-string">"npm"</span></span>, <span class="hljs-string"><span class="hljs-string">"start"</span></span>] ---&gt; Running in ee0e8a9066dc Removing intermediate container ee0e8a9066dc ---&gt; b208c4184766 Successfully built b208c4184766 Successfully tagged rebounder-chain-frontend:latest</code> </pre> <br>  Si nous voyons que la dernière étape est terminée et que tout est réussi, alors nous avons une image.  Nous pouvons le vérifier en l'exécutant: <br><br><pre> <code class="java hljs">docker run -p <span class="hljs-number"><span class="hljs-number">8080</span></span>:<span class="hljs-number"><span class="hljs-number">3000</span></span> rebounder-chain-frontend</code> </pre> <br>  Je pense que la signification de cette commande est généralement comprise, à l'exception de l'entrée -p 8080: 3000. <br>  docker run rebounder-chain-frontend - signifie que nous lançons une telle image de docker, que nous avons appelée rebounder-chain-frontend.  Mais un tel conteneur n'aura pas de sortie vers l'extérieur, il doit définir un port.  C'est l'équipe ci-dessous qui le définit.  Nous nous souvenons que notre application React s'exécute sur le port 3000. La commande -p 8080: 3000 indique au docker de prendre le port 3000 et de le transmettre au port 8080 (qui sera ouvert).  Ainsi, une application qui s'exécute sur le port 3000 sera ouverte sur le port 8080 et sera disponible sur la machine locale sur ce port. <br><br><pre> <code class="bash hljs">,       : Mac-mini-Vaceslav:rebounder-chain-frontend xpendence$ docker run -p 8080:3000 rebounder-chain-frontend &gt; rebounder-chain-frontend@0.1.0 start /usr/app/front &gt; react-scripts start Starting the development server... Compiled successfully! You can now view rebounder-chain-frontend <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the browser. Local: http://localhost:3000/ On Your Network: http://172.17.0.2:3000/ Note that the development build is not optimized. To create a production build, use npm run build.</code> </pre> <br>  Ne laissez pas le dossier vous déranger <br><br><pre> <code class="bash hljs"> Local: http://localhost:3000/ On Your Network: http://172.17.0.2:3000/</code> </pre> <br>  React le pense.  Il est vraiment disponible dans le conteneur sur le port 3000, mais nous avons transmis ce port au port 8080, et à partir du conteneur, l'application s'exécute sur le port 8080. Vous pouvez exécuter l'application localement et vérifier cela. <br><br>  Nous avons donc un conteneur prêt à l'emploi avec une application frontale, collectons maintenant le backend. <br><br><h4>  Construire un back-end. </h4><br>  Le script de lancement d'une application en Java est très différent de l'assemblage précédent.  Il se compose des éléments suivants: <br><br><ol><li>  Installez la JVM. </li><li>  Nous collectons des archives de pots. </li><li>  Nous le lançons. </li></ol><br>  Dans Dockerfile, ce processus ressemble à ceci: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># back #     JVM FROM openjdk:8-jdk-alpine #  . ,    .  . LABEL maintainer="2262288@gmail.com" #         (  ,  ) VOLUME /tmp #  ,        EXPOSE 8099 # ,       ARG JAR_FILE=build/libs/rebounder-chain-backend-0.0.2.jar #       rebounder-chain-backend.jar ADD ${JAR_FILE} rebounder-chain-backend.jar #    ENTRYPOINT ["java","-jar","/rebounder-chain-backend.jar"]</span></span></code> </pre> <br>  Le processus d'assemblage d'une image avec l'inclusion d'un dzharnik sur certains points ressemble à celui de notre front. <br><br>  Le processus d'assemblage et de lancement de la deuxième image est essentiellement le même que l'assemblage et le lancement de la première. <br><br><pre> <code class="bash hljs">docker build -t rebounder-chain-backend . docker run -p 8099:8099 rebounder-chain-backend</code> </pre> <br>  Maintenant, si vous avez les deux conteneurs en cours d'exécution et que le backend est connecté à la base de données, tout fonctionnera.  Je vous rappelle que vous devez vous-même enregistrer la connexion à la base de données depuis le backend, et qu'elle doit fonctionner via un réseau externe. <br><br><h2>  3. Collectez des images et exécutez des conteneurs sur un serveur distant </h2><br>  Pour que tout fonctionne sur le serveur distant, nous avons besoin de Docker déjà installé dessus, après quoi il suffit d'exécuter les images.  Nous irons dans le bon sens et engagerons nos images sur notre compte dans le cloud Docker, après quoi elles seront disponibles partout dans le monde.  Bien sûr, il existe de nombreuses alternatives à cette approche, ainsi que tout ce qui est décrit dans le post, mais poussons-le un peu plus et faisons bien notre travail.  Mauvais, comme l'a dit Andrei Mironov, nous avons toujours le temps de le faire. <br><br><h4>  Création d'un compte sur le hub Docker </h4><br>  La première chose que vous devez faire est d'obtenir un compte sur le hub Docker.  Pour ce faire, accédez au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">hub</a> et inscrivez-vous.  Ce n'est pas difficile. <br><br>  Ensuite, nous devons aller au terminal et nous connecter à Docker. <br><br><pre> <code class="bash hljs">docker login</code> </pre> <br>  Il vous sera demandé de saisir un nom d'utilisateur et un mot de passe.  Si tout va bien, une notification apparaîtra dans le terminal que la connexion a réussi. <br><br><h4>  Validation d'images sur le Docker Hub </h4><br>  Ensuite, nous devons étiqueter nos images et les valider sur le hub.  Ceci est fait par l'équipe selon le schéma suivant: <br><br><pre> <code class="bash hljs">docker tag   /_:</code> </pre> <br>  Ainsi, nous devons spécifier le nom de notre image, login / repository et la balise sous laquelle notre image sera validée sur le hub. <br><br>  Dans mon cas, cela ressemblait à ceci: <br><br><img src="https://habrastorage.org/webt/wu/pv/fh/wupvfhs3za_nws2wwsicgfgm2z4.jpeg"><br><br>  Nous pouvons vérifier la présence de cette image dans le référentiel local à l'aide de la commande: <br><br><pre> <code class="bash hljs">Mac-mini-Vaceslav:rebounder-chain-backend xpendence$ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE xpendence/rebounder-chain-backend 0.0.2 c8f5b99e15a1 About an hour ago 141MB</code> </pre> <br>  Notre image est prête à s'engager.  Commit: <br><br><pre> <code class="bash hljs">docker push xpendence/rebounder-chain-backend:0.0.2</code> </pre> <br>  Un enregistrement de validation réussi doit apparaître. <br>  Faites de même avec le frontend: <br><br><pre> <code class="bash hljs">docker tag rebounder-chain-frontend xpendence/rebounder-chain-frontend:0.0.1 docker push xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Maintenant, si nous allons sur hub.docker.com, nous verrons deux images verrouillées.  Qui sont disponibles de partout. <br><br><img src="https://habrastorage.org/webt/ur/zs/hk/urzshkc3j1ivikyhu4cxvcm43yk.png"><br><br><img src="https://habrastorage.org/webt/cr/if/rb/crifrbda12uxdq6habx6nfeablm.png"><br><br>  Félicitations  Il nous suffit de passer à la dernière partie de notre travail: lancer des images sur un serveur distant. <br><br><h4>  Exécuter des images sur un serveur distant </h4><br>  Maintenant, nous pouvons exécuter notre image sur n'importe quelle machine avec Docker en remplissant une seule ligne dans le terminal (dans notre cas, nous devons exécuter séquentiellement deux lignes dans différents terminaux - une pour chaque image). <br><br><pre> <code class="bash hljs">docker run -p 8099:8099 xpendence/rebounder-chain-backend:0.0.2 docker run -p 8080:3000 xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Ce lancement a cependant un inconvénient.  Lorsque le terminal est fermé, le processus se termine et l'application cesse de fonctionner.  Pour éviter cela, nous pouvons exécuter l'application en mode «détaché»: <br><br><pre> <code class="bash hljs">docker run -d -p 8099:8099 xpendence/rebounder-chain-backend:0.0.2 docker run -d -p 8080:3000 xpendence/rebounder-chain-frontend:0.0.1</code> </pre> <br>  Maintenant, l'application n'émettra pas de journal au terminal (cela peut, encore une fois, être configuré séparément), mais même lorsque le terminal est fermé, il ne s'arrêtera pas de fonctionner. <br><br><h2>  4. Résolution des problèmes de réseau </h2><br>  Si vous avez tout fait correctement, vous pouvez vous attendre à la plus grande déception en suivant ce post - il se pourrait bien que rien ne fonctionne.  Par exemple, tout fonctionnait parfaitement pour vous et fonctionnait sur la machine locale (comme, par exemple, sur mon Mac), mais lorsqu'ils étaient déployés sur un serveur distant, les conteneurs cessaient de se voir (comme, par exemple, sur mon serveur distant sous Linux).  Quel est le problème?  Mais le problème est le suivant, et au début j'y ai fait allusion.  Comme mentionné précédemment, lorsque le conteneur démarre, Docker crée une machine virtuelle distincte, y déploie Linux, puis installe l'application sur ce Linux.  Cela signifie que l'hôte local conditionnel pour le conteneur en cours d'exécution est limité au conteneur lui-même et que l'application n'a pas connaissance de l'existence d'autres réseaux.  Mais nous devons: <br><br>  a) les conteneurs se sont vus. <br>  b) le backend a vu la base de données. <br><br>  Il existe deux solutions au problème. <br><br>  1. Création d'un réseau interne. <br>  2. Amener les conteneurs au niveau de l'hôte. <br><br>  1. Au niveau Docker, vous pouvez créer des réseaux, en outre, trois d'entre eux par défaut - <i>pont</i> , <i>aucun</i> et <i>hôte</i> . <br><br>  <i>Bridge</i> est un réseau interne Docker isolé du réseau hôte.  Vous pouvez accéder aux conteneurs uniquement via les ports que vous ouvrez lorsque le conteneur démarre avec la commande <i>-p</i> .  Vous pouvez créer n'importe quel nombre de réseaux tels que des <i>ponts</i> . <br><br><img src="https://habrastorage.org/webt/ld/sp/pf/ldsppf06sqnpf6cumhqodzsiiga.jpeg"><br><br>  <i>Aucun</i> n'est un réseau distinct pour un conteneur spécifique. <br><br>  <i>Hôte</i> est le réseau hôte.  Lorsque vous choisissez ce réseau, votre conteneur est entièrement accessible via l'hôte - la commande <i>-p</i> ne fonctionne tout simplement pas ici, et si vous avez déployé le conteneur sur ce réseau, vous n'avez pas besoin de spécifier un port externe - le conteneur est accessible par son port interne.  Par exemple, si Dockerfile EXPOSE est défini sur 8090, c'est via ce port que l'application sera disponible. <br><br><img src="https://habrastorage.org/webt/ve/6r/rw/ve6rrwnis25uarwrfudc_xlps4o.jpeg"><br><br>  Étant donné que nous devons avoir accès à la base de données du serveur, nous utiliserons cette dernière méthode et disposerons les conteneurs sur le réseau du serveur distant. <br><br>  Cela se fait très simplement, nous supprimons la mention des ports de la commande de lancement de conteneur et spécifions le réseau hôte: <br><br><pre> <code class="bash hljs">docker run --net=host xpendence/rebounder-chain-frontend:0.0.8</code> </pre> <br>  Connexion à la base que j'ai indiquée <br><br><pre> <code class="bash hljs">localhost:3306</code> </pre> <br>  La connexion de l'avant à l'arrière devait être entièrement spécifiée, externe: <br><br><pre> <code class="bash hljs">http://&lt;__:__&gt;</code> </pre> <br>  Si vous transférez le port interne vers le port externe, ce qui est souvent le cas pour les serveurs distants, vous devez spécifier le port interne pour la base de données et le port externe pour le conteneur. <br><br>  Si vous voulez expérimenter avec des connexions, vous pouvez télécharger et construire un projet que j'ai spécialement écrit pour tester la connexion entre les conteneurs.  Entrez simplement l'adresse souhaitée, appuyez sur Envoyer et en mode débogage, voyez ce qui a volé en arrière. <br><br>  Le projet se trouve <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h2>  Conclusion </h2><br>  Il existe de nombreuses façons de créer et d'exécuter une image Docker.  Pour ceux qui sont intéressés, je vous conseille d'apprendre le docker-compose.  Ici, nous n'avons examiné qu'une des façons de travailler avec Docker.  Bien sûr, cette approche au premier abord ne semble pas si simple.  Mais voici un exemple - lors de la rédaction d'un article, j'avais des connexions sortantes sur un serveur distant.  Et pendant le processus de débogage, j'ai dû modifier plusieurs fois les paramètres de connexion à la base de données.  L'ensemble du montage et du déploiement s'inscrit dans mon ensemble de 4 lignes, après être entré dont j'ai vu le résultat sur un serveur distant.  En mode de programmation extrême, Docker est indispensable. <br><br>  Comme promis, je poste les sources d'application: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">backend</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">frontend</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448094/">https://habr.com/ru/post/fr448094/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448080/index.html">Joueur de football Robo de débutants. Concours au MIPT. Android et Arduino et Bluetooth</a></li>
<li><a href="../fr448082/index.html">[Avant lundi] Syndrome de sécheresse oculaire</a></li>
<li><a href="../fr448084/index.html">Photo d'un trou noir - sera-t-elle utile?</a></li>
<li><a href="../fr448088/index.html">Production de moteurs plasma en Russie</a></li>
<li><a href="../fr448090/index.html">Frontend Weekly Digest (8-14 avril 2019)</a></li>
<li><a href="../fr448096/index.html">Julia en latex</a></li>
<li><a href="../fr448098/index.html">GHIDRA, exécutables Playstation 1, signatures FLIRT et PsyQ</a></li>
<li><a href="../fr448100/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 360 (7-14 avril 2019)</a></li>
<li><a href="../fr448102/index.html">Une équipe de rêve à partir de rien: embauche de professionnels de l'informatique</a></li>
<li><a href="../fr448106/index.html">Formation des développeurs 1C-Bitrix: partagez notre approche de la "croissance" du personnel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>