<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕵🏻 ☦️ 🤥 Il n'y aura pas de collections immuables en Java - ni maintenant ni jamais 💂🏼 👨🏾‍🎤 🖕🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous! 

 Aujourd'hui, votre attention est invitée à la traduction d'un article soigneusement écrit sur l'un des problèmes de base de Java - ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Il n'y aura pas de collections immuables en Java - ni maintenant ni jamais</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/470149/">  Bonjour à tous! <br><br>  Aujourd'hui, votre attention est invitée à la traduction d'un article soigneusement écrit sur l'un des problèmes de base de Java - la mutabilité, et comment il affecte la structure des structures de données et comment travailler avec elles.  Le matériel est tiré du blog de Nicolai Parlog, dont nous avons vraiment essayé de garder le style littéraire brillant en traduction.  Nicolas lui-même est remarquablement caractérisé par un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">extrait du blog de la</a> société JUG.ru sur Habré;  citons ce passage dans son intégralité: <br><br><img src="https://habrastorage.org/webt/7l/mh/iy/7lmhiypudt5z093eme-wrlhzygq.jpeg"><br><blockquote>  Nikolay Parlog est un tel mec des médias qui fait des critiques sur les fonctionnalités Java.  Mais il n'est pas d'Oracle en même temps, donc les critiques sont étonnamment franches et compréhensibles.  Parfois après eux, quelqu'un est renvoyé, mais rarement.  Nikolay parlera de l'avenir de Java, ce qui sera dans la nouvelle version.  Il est bon pour parler des tendances et généralement du grand monde.  C'est un compagnon très bien lu et érudit.  Même les rapports simples sont agréables à écouter, tout le temps que vous apprenez quelque chose de nouveau.  De plus, Nicolas sait au-delà de ce qu'il raconte.  Autrement dit, vous pouvez venir à n'importe quel rapport et en profiter, même si ce n'est pas du tout votre sujet.  Il enseigne.  Il a écrit «The Java Module System» pour Manning Publishing House, tient des blogs sur le développement de logiciels sur codefx.org, et a longtemps été impliqué dans plusieurs projets open source.  Il peut être embauché dès la conférence, il est pigiste.  Certes, un pigiste très cher.  Voici le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport</a> . </blockquote><br>  Nous lisons et votons.  Qui aime particulièrement le message - nous vous recommandons également de consulter les commentaires du lecteur sur le message d'origine. <br><a name="habracut"></a><br>  La volatilité est mauvaise, non?  Par conséquent, l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">immuabilité est bonne</a> .  Les principales structures de données dans lesquelles l'immuabilité est particulièrement fructueuse sont les collections: en Java c'est une liste ( <code>List</code> ), un ensemble ( <code>Set</code> ) et un dictionnaire ( <code>Map</code> ).  Cependant, bien que le JDK soit livré avec des collections immuables (ou non modifiables?), Le système de type n'en sait rien.  Il n'y a pas d' <code>ImmutableList</code> dans le JDK, et ce type de Guava me semble complètement inutile.  Mais pourquoi?  Pourquoi ne pas simplement ajouter <code>Immutable...</code> à ce mélange et ne pas dire qu'il devrait l'être? <br><br><h4>  Qu'est-ce qu'une collection immuable? </h4><br>  Dans la terminologie JDK, la signification des mots « <i>immuable</i> » et « <i>non modifiable</i> » a changé au cours des dernières années.  Initialement, «non modifiable» était appelé une instance qui ne permettait pas la mutabilité (mutabilité): en réponse à l'évolution des méthodes, il a lancé <code>UnsupportedOperationException</code> .  Cependant, il pourrait être changé d'une autre manière - peut-être parce qu'il ne s'agissait que d'un wrapper autour d'une collection mutable.  Ces vues sont reflétées dans les méthodes <code>Collections::unmodifiableList</code> , <code>unmodifiableSet</code> et <code>unmodifiableMap</code> , ainsi que dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">leur JavaDoc</a> . <br><br>  Initialement, le terme " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">immuable</a> " fait référence aux collections retournées par les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">méthodes d'usine des collections Java 9</a> .  Les collections elles-mêmes ne pouvaient en aucun cas être modifiées (oui, il y a de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réflexion</a> , mais cela ne compte pas), il semble donc qu'elles justifient leur nom.  Hélas, la confusion survient souvent à cause de cela.  Supposons qu'il existe une méthode qui affiche tous les éléments d'une collection immuable à l'écran - donnera-t-elle toujours le même résultat?  Hein?  Ou pas? <br><br>  Si vous n’avez pas immédiatement répondu <i>non</i> , cela signifie que vous venez de voir exactement quelle confusion est possible ici.  Une « <i>collection immuable d'agents secrets</i> » - cela semblerait sacrément similaire à une « <i>collection immuable d'agents secrets immuables</i> », mais ces deux entités peuvent ne pas être identiques.  Une collection immuable ne peut pas être modifiée à l'aide des opérations d'insertion / suppression / nettoyage, etc., mais si les agents secrets sont mutables (bien que les traits de caractère dans les films d'espionnage soient si mauvais qu'ils n'y croient pas vraiment), cela ne signifie pas pour autant que toute la collection d'agents secrets est immuable.  Par conséquent, il y a maintenant un changement vers le fait de nommer de telles collections <i>non modifiables</i> , plutôt <i>qu'immuables</i> , qui est inscrit dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nouvelle édition de JavaDoc</a> . <br><br>  Les collections immuables discutées dans cet article peuvent contenir des éléments mutables. <br><br>  Personnellement, je n'aime pas une telle révision de la terminologie.  À mon avis, l'expression «collection immuable» ne devrait signifier que la collection elle-même ne peut pas être modifiée, mais ne doit pas caractériser les éléments qu'elle contient.  Dans ce cas, il y a un autre point positif: le terme «immuabilité» dans l'écosystème Java ne se transforme pas en un non-sens complet. <br><br>  D'une manière ou d'une autre, dans cet article, nous parlerons de <i>collections immuables</i> , où ... <br><br><ul><li>  Les instances contenues dans la collection sont déterminées au stade de la conception </li><li>  Ces copies - un montant égal, ni réduire ni ajouter </li><li>  Aucune déclaration n'est faite concernant la mutabilité de ces éléments. </li></ul><br>  Insistons sur le fait que maintenant nous allons pratiquer l'ajout de collections immuables.  Pour être précis - une liste immuable.  Tout ce qui sera dit sur les listes est également applicable aux collections d'autres types. <br><br>  Commencer à ajouter des collections immuables! <br><br>  Créons l'interface <code>ImmutableList</code> et faisons-la, par rapport à <code>List</code> , euh ... quoi?  Supertype ou sous-type?  Arrêtons-nous sur la première option. <br><br><img src="https://habrastorage.org/webt/sc/uv/yl/scuvyloeubhj5-wq36b7nzuzdu8.png"><br><br>  Magnifiquement, <code>ImmutableList</code> pas de méthodes <code>ImmutableList</code> , donc son utilisation est toujours sûre, non?  Alors?!  Non, monsieur. <br><br><pre> <code class="java hljs">List&lt;Agent&gt; agents = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ,  `List`  `ImmutableList` ImmutableList&lt;Agent&gt; section4 = agents; //    section4.forEach(System.out::println); //    `section4` agents.add(new Agent("Motoko"); //  "Motoko" – ,      ?! section4.forEach(System.out::println);</span></span></code> </pre> <br>  Cet exemple montre qu'il est possible de transférer une telle liste non entièrement immuable vers l'API, dont le fonctionnement peut être construit sur l'immuabilité et, par conséquent, annule toutes les garanties qu'un nom de ce type peut faire allusion.  Voici une recette pour vous qui pourrait conduire à un désastre. <br><br>  OK, puis <code>ImmutableList</code> étend la <code>List</code> .  Peut-être? <br><br><img src="https://habrastorage.org/webt/fr/sq/_r/frsq_rgj7rt0mp3u0f--zn8jlrs.png"><br><br>  Maintenant, si l'API attend une liste immuable, elle recevra alors une telle liste, mais il y a deux inconvénients: <br><br><ul><li>  Les listes immuables devraient toujours proposer des méthodes de modification (telles qu'elles sont définies dans le supertype), et la seule implémentation possible lèvera une exception </li><li>  <code>ImmutableList</code> instances <code>ImmutableList</code> également des instances <code>List</code> , et lorsqu'elles sont affectées à une telle variable, passées comme tel argument ou renvoyées de ce type, il est logique de supposer que la mutabilité est autorisée. </li></ul><br>  Ainsi, il s'avère que vous ne pouvez utiliser <code>ImmutableList</code> localement, car il passe les frontières de l'API sous forme de <code>List</code> , ce qui vous oblige à un niveau de précaution surhumain, ou explose au moment de l'exécution.  Ce n'est pas aussi mauvais qu'une <code>List</code> étendant une <code>ImmutableList</code> , mais une telle solution est encore loin d'être idéale. <br><br>  C'est exactement ce que j'avais en tête quand j'ai dit que le type <code>ImmutableList</code> de Goyave était pratiquement inutile.  Il s'agit d'un excellent exemple de code, très fiable lorsque vous travaillez avec des listes locales immuables (c'est pourquoi je l'utilise activement), mais, en y ayant recours, il est très facile d'aller au-delà de la citadelle compilée imprenable et garantie, dont les murs étaient composés de types immuables - et uniquement dans ce les types immuables peuvent révéler pleinement leur potentiel.  C'est mieux que rien, mais inefficace en tant que solution JDK. <br><br>  Si l' <code>ImmutableList</code> ne peut pas étendre la <code>List</code> et que la solution de contournement ne fonctionne toujours pas, alors comment est-il supposé que tout fonctionne? <br><br><h4>  L'immuabilité est une caractéristique </h4><br>  Le problème que nous avons rencontré lors des deux premières tentatives pour ajouter des types immuables était notre idée fausse que l'immuabilité est simplement l'absence de quelque chose: nous prenons une <code>List</code> , en supprimons le code changeant, nous obtenons une <code>ImmutableList</code> .  Mais, en fait, tout cela ne fonctionne pas de cette façon. <br><br>  Si nous supprimons simplement les méthodes de modification de la <code>List</code> , nous obtenons une liste en lecture seule.  Ou, en respectant la terminologie formulée ci-dessus, elle peut être appelée <code>UnmodifiableList</code> - elle peut encore changer, mais vous ne la modifierez pas. <br><br>  Maintenant, nous pouvons ajouter deux choses à cette image: <br><br><ul><li>  Nous pouvons le rendre mutable en ajoutant des méthodes appropriées </li><li>  Nous pouvons le rendre immuable en ajoutant des garanties appropriées. </li></ul><br>  L'immuabilité n'est pas l'absence de mutabilité, mais une garantie qu'il n'y aura pas de changements <br>  Dans ce cas, il est important de comprendre que dans les deux cas, nous parlons de fonctionnalités complètes - l'immuabilité n'est pas l'absence de changements, mais une garantie qu'il n'y aura pas de changements.  Une fonctionnalité existante peut ne pas être nécessairement utilisée à bon escient, elle peut également garantir que quelque chose de mauvais ne se produira pas dans le code - dans ce cas, pensez, par exemple, à la sécurité des threads. <br><br>  De toute évidence, la mutabilité et l'immuabilité entrent en conflit, et nous ne pouvons donc pas utiliser simultanément les deux hiérarchies d'héritage susmentionnées.  Les types héritent des capacités des autres types, donc peu importe comment vous les coupez, si l'un des types hérite de l'autre, il contiendra les deux fonctionnalités. <br><br>  Donc, <code>List</code> et <code>ImmutableList</code> ne peuvent pas s'étendre.  Mais nous avons été amenés ici en travaillant avec <code>UnmodifiableList</code> , et il s'avère vraiment que les deux types ont la même API, en lecture seule, ce qui signifie qu'ils doivent l'étendre. <br><br><img src="https://habrastorage.org/webt/bd/dp/7b/bddp7bjb5e9m6sddvp4slse0yfi.png"><br><br>  Bien que je n'appellerais pas les choses exactement de ces noms, la hiérarchie de ce type est raisonnable.  À Scala, par exemple, cela se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fait pratiquement</a> .  La différence est que le supertype partagé, que nous avons appelé <code>UnmodifiableList</code> , définit des méthodes mutables qui renvoient une collection modifiée et laissent l'original intact.  Ainsi, une liste immuable se révèle être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">persistante</a> et donne à une variante mutable deux ensembles de méthodes de modification - héritées pour recevoir des copies modifiées et les siennes pour les changements en place. <br><br>  Et Java?  Est-il possible de moderniser une telle hiérarchie en y ajoutant de nouveaux supertypes et frères et sœurs? <br><br>  Est-il possible d'améliorer les collections non modifiables et immuables? <br>  Bien sûr, il n'y a aucun problème à ajouter les <code>ImmutableList</code> et <code>ImmutableList</code> et à créer la hiérarchie d'héritage décrite ci-dessus.  Le problème est qu'à court et moyen terme, il sera pratiquement inutile.  Laisse-moi t'expliquer. <br><br>  Le <code>ImmutableList</code> d'avoir <code>UnmodifiableList</code> , <code>ImmutableList</code> et <code>List</code> comme types - dans ce cas, les API seront en mesure d'exprimer clairement ce dont elles ont besoin et ce qu'elles offrent. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">payAgents</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnmodifiableList&lt;Agent&gt; agents)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      , //         } public void sendOnMission(ImmutableList&lt;Agent&gt; agents) { //   ( ), //  ,     } public void downtime(List&lt;Agent&gt; agents) { //       , //        ,      } public UnmodifiableList&lt;Agent&gt; teamRoster() { //   ,     , //      ,     -  } public ImmutableList&lt;Agent&gt; teamOnMission() { //    ,      } public List&lt;Agent&gt; team() { //    ,    , //        }</span></span></code> </pre> <br>  Cependant, à moins que vous ne commenciez le projet à partir de zéro, vous aurez probablement une telle fonctionnalité, et elle ressemblera à ceci: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,  `Iterable&lt;Agent&gt;` //  ,   ,        public void payAgents(List&lt;Agent&gt; agents) { } public void sendOnMission(List&lt;Agent&gt; agents) { } public void downtime(List&lt;Agent&gt; agents) { } //      , //    ,  `List`     public List&lt;Agent&gt; teamRoster() { } // ,     `Stream&lt;Agent&gt;` public List&lt;Agent&gt; teamOnMission() { } public List&lt;Agent&gt; team() { }</span></span></code> </pre> <br>  Ce n'est pas bon, car pour que les nouvelles collections que nous venons de présenter soient utiles, nous devons travailler avec elles!  (ouf).  Ce qui précède n'est pas sans rappeler le code de l'application, par conséquent, la refactorisation <code>ImmutableList</code> <code>UnmodifiableList</code> et <code>ImmutableList</code> , et vous pouvez l'implémenter, comme indiqué dans la liste ci-dessus.  Cela peut être un gros morceau de travail, couplé à de la confusion lorsque vous devez organiser l'interaction du code ancien et mis à jour, mais au moins cela semble faisable. <br><br>  Qu'en est-il des frameworks, des bibliothèques et du JDK lui-même?  Ici, tout semble sombre.  Une tentative de modification du paramètre ou du type de retour de <code>List</code> à <code>ImmutableList</code> entraînera une <i>incompatibilité avec le code source</i> , c'est-à-dire  le code source existant ne sera pas compilé avec la nouvelle version, car ces types ne sont pas liés les uns aux autres.  De même, la modification du type de retour de <code>List</code> en un nouveau supertype <code>UnmodifiableList</code> entraînera des erreurs de compilation. <br><br>  Avec l'introduction de nouveaux types, il sera nécessaire de faire des changements et de recompiler dans tout l'écosystème. <br><br>  Cependant, même si nous développons le type de paramètre de <code>List</code> à <code>UnmodifiableList</code> , nous rencontrerons un problème, car une telle modification entraîne une <i>incompatibilité au niveau du bytecode</i> .  Lorsque le code source appelle une méthode, le compilateur convertit cet appel en bytecode qui référence la méthode cible en: <br><br><ul><li>  Le nom de la classe dont l'instance la cible est déclarée </li><li>  Nom de la méthode </li><li>  Types de paramètres de méthode </li><li>  Type de retour de méthode </li></ul><br>  Toute modification du paramètre ou du type de retour de la méthode entraînera le bytecode à indiquer la mauvaise signature lors de la référence à la méthode;  en conséquence, une erreur <code>NoSuchMethodError</code> se produit pendant l'exécution.  Si la modification que vous apportez est compatible avec le code source - par exemple, si vous parlez de restreindre le type de retour ou d'étendre le type du paramètre - alors la recompilation devrait être suffisante.  Cependant, avec des changements profonds, par exemple, avec l'introduction de nouvelles collections, tout n'est pas si simple: pour consolider ces changements, vous devez recompiler tout l'écosystème Java.  C'est une entreprise perdue. <br><br>  La seule façon envisageable de tirer parti de ces nouvelles collections sans rompre la compatibilité est de dupliquer chaque méthode existante avec un nouveau nom, de modifier l'API, puis de marquer l'ancienne version comme indésirable.  Pouvez-vous imaginer à quel point une telle tâche serait monumentale et pratiquement infinie?! <br><br><h4>  La réflexion </h4><br>  Bien sûr, les types de collection immuables sont une grande chose que j'aimerais avoir, mais nous ne verrons probablement pas quelque chose comme ça dans le JDK.  Les implémentations compétentes de <code>List</code> et d' <code>ImmutableList</code> ne <code>ImmutableList</code> jamais se développer (en fait, les deux étendent le même type de liste <code>UnmodifiableList</code> , qui est en lecture seule), ce qui rend difficile l'intégration de ces types dans les API existantes. <br><br>  En dehors du contexte de toute relation spécifique entre les types, la modification des signatures de méthode existantes est toujours lourde de problèmes, car ces modifications sont incompatibles avec le bytecode.  Lorsqu'ils sont introduits, au moins une recompilation est nécessaire, et il s'agit d'un changement dévastateur qui affectera l'ensemble de l'écosystème Java. <br><br>  Par conséquent, je crois que rien de tel ne se produira - jamais et jamais. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470149/">https://habr.com/ru/post/fr470149/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470127/index.html">Compositeur avec une longue mémoire à court terme</a></li>
<li><a href="../fr470129/index.html">Gestion de la mémoire déclarative</a></li>
<li><a href="../fr470133/index.html">Comment collecter des métriques non déformées par référence temporelle avec Prometheus</a></li>
<li><a href="../fr470135/index.html">Une application web interactive sans programmation? C'est facile! Mavo dans tes bras</a></li>
<li><a href="../fr470145/index.html">"Attention, SAF!": Pourquoi le ticket militaire est-il dangereux dans la publicité, pourquoi est-il important de connaître les mathématiques et si la vérité nue est toujours nécessaire</a></li>
<li><a href="../fr470153/index.html">Dictionnaire du modèle de données</a></li>
<li><a href="../fr470159/index.html">Prime Generation</a></li>
<li><a href="../fr470165/index.html">La philosophie de la division par ... ou la confession d'un fou</a></li>
<li><a href="../fr470167/index.html">Conférence pour ceux qui s'intéressent à la science avant qu'elle ne devienne un courant dominant</a></li>
<li><a href="../fr470169/index.html">Comment empêcher l'idée de mourir et de rassembler une équipe qui ne la tuera pas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>