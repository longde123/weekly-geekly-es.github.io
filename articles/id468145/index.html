<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ†™ ğŸš£ ğŸ‘¨â€ğŸ¨ Tes atau tipe? - Versi karat â˜ğŸ¼ ğŸ„ ğŸ‘ŠğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa hari yang lalu, 0xd34df00d menerbitkan terjemahan sebuah artikel di sini yang menjelaskan apa yang dapat Anda pelajari tentang suatu fungsi d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tes atau tipe? - Versi karat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468145/"><p> Beberapa hari yang lalu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">0xd34df00d</a> menerbitkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan sebuah</a> artikel di sini yang menjelaskan apa yang dapat Anda pelajari tentang suatu fungsi dalam berbagai bahasa, jika Anda menganggapnya sebagai "kotak hitam" tanpa menggunakan informasi tentang implementasinya (tetapi, tentu saja, tanpa menghentikannya menggunakan kompiler).  Tentu saja, informasi yang diterima sangat tergantung pada bahasa - empat contoh dipertimbangkan dalam artikel asli: </p><br><ul><li>  Python - diketik secara dinamis, informasi minimum, hanya tes yang memberikan beberapa petunjuk; </li><li>  C - diketik dengan lemah, tidak banyak informasi; </li><li>  Haskell - sangat diketik secara statis, dengan fungsi murni, lebih banyak informasi; </li><li>  Idris adalah bahasa dengan tipe dependen, ada cukup informasi untuk membuktikan kebenaran fungsi selama kompilasi. </li></ul><br><p>  "Ada C, ada Haskell, tapi di mana Rust?!"  - segera pertanyaan diajukan.  Jawabannya ada di bawah potongan. </p><a name="habracut"></a><br><p>  Ingat kondisi masalah: </p><br><blockquote>  Biarkan daftar dan beberapa makna diberikan.  Diperlukan untuk mengembalikan indeks nilai ini dalam daftar atau menunjukkan bahwa nilai ini tidak ada dalam daftar. </blockquote><p>  Untuk yang tidak sabar - semua opsi yang dibahas di bawah ini dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">taman bermain Rust</a> . <br>  Ayo pergi! </p><br><h4 id="prostoy-poisk">  Pencarian sederhana </h4><br><p>  Kita akan mulai dengan tanda tangan yang hampir naif, yang, pada kenyataannya, berbeda dari kode C hanya dalam beberapa elemen idiomatik: </p><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>], y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Apa yang kita ketahui tentang fitur ini?  Yah ... sebenarnya tidak terlalu banyak.  Tentu saja, memiliki <code>Option&lt;usize&gt;</code> dalam nilai yang dikembalikan jauh lebih baik daripada yang diberikan C kepada kami, tetapi kami masih tidak memiliki informasi tentang semantik fungsi.  Secara khusus, tidak ada jaminan bahwa tidak akan ada efek samping, juga tidak ada cara untuk memverifikasi perilaku yang diharapkan. </p><br><p>  Bisakah tes tertulis yang benar memperbaiki situasi?  Kami melihat: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(foo(&amp;[<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-literal"><span class="hljs-literal">None</span></span>); }</code> </pre> <br><p>  Secara umum, kami tidak mendapatkan sesuatu yang baru - semua pemeriksaan yang sama dapat dengan mudah kami lakukan dengan Python (dan, melihat ke depan, tes praktis tidak akan memberikan apa-apa di masa depan). </p><br><h4 id="use-the-generics-luke">  Gunakan obat generik, Luke! </h4><br><p>  Tetapi apakah benar-benar baik bahwa kita dipaksa untuk menggunakan nomor 32-bit yang sudah ditandatangani?  Kekacauan.  Kami memperbaiki: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Ya!  Ini sudah menjadi sesuatu.  Sekarang kita bisa mengambil irisan, yang terdiri dari elemen apa saja yang bisa kita bandingkan untuk kesetaraan.  Polimorfisme eksplisit hampir selalu lebih baik daripada implisit dan hampir selalu lebih baik daripada tidak ada, bukan? </p><br><p>  Namun, fungsi seperti itu secara tak terduga dapat lulus tes berikut untuk kita: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">refl</span></span></span></span>&lt;El: <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Copy</span></span>&gt;(el: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { foo(&amp;[el], el) <span class="hljs-comment"><span class="hljs-comment">// should always return Some(0), right? } #[test] fn dont_find_nan() { assert_eq!(refl(std::f64::NAN), None); }</span></span></code> </pre> <br><p>  Ini segera menunjukkan beberapa kelemahan pada bagian kami, karena sesuai dengan spesifikasi asli, panggilan seperti itu harus mengembalikan <code>Some(0)</code> .  Tentu saja, masalah di sini adalah karena kekhususan jenis dengan perbandingan yang didefinisikan sebagian secara umum dan mengapung pada khususnya. <br>  Misalkan sekarang kita ingin menyingkirkan masalah seperti itu - untuk ini kita hanya memperketat persyaratan untuk tipe El: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El&gt;(x: &amp;[El], y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Sekarang kami menuntut tidak hanya kemungkinan perbandingan untuk kesetaraan - kami mengharuskan perbandingan ini menjadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hubungan kesetaraan</a> .  Ini agak mempersempit kisaran parameter yang mungkin, tetapi sekarang kedua jenis dan tes menunjukkan (meskipun tidak secara eksplisit menunjukkan) bahwa perilaku yang diharapkan harus benar-benar masuk dalam spesifikasi. </p><br><div class="spoiler">  <b class="spoiler_title">Digresi: kami ingin LEBIH generik!</b> <div class="spoiler_text"><p>  Pilihan ini tidak terkait dengan tugas asli, tetapi, menurut pendapat saya, adalah ilustrasi yang bagus dari prinsip: "menjadi liberal dalam apa yang Anda terima, menjadi konservatif dalam apa yang Anda lakukan".  Dengan kata lain: jika ada peluang, tanpa mengurangi ergonomi dan kinerja, membuat jenis nilai yang diterima lebih umum - masuk akal untuk melakukan hal itu. </p><br><p>  Pertimbangkan opsi ini: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>, El: <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(x: <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">IntoIterator</span></span>&lt;Item = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> El&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Apa yang kita ketahui tentang fungsi ini sekarang?  Semuanya sama, hanya sekarang ia tidak menerima daftar atau irisan sebagai input, tetapi beberapa objek sewenang-wenang yang dapat dibuat untuk memberikan tautan secara bergantian ke objek tipe El dan membandingkannya dengan yang dicari: analog di Jawa, jika saya ingat dengan benar, adalah akan menjadi fungsi yang mengambil <code>Iterable&lt;Comparable&gt;</code> . </p></div></div><br><h4 id="kak-ranshe-tolko-strozhe">  Seperti sebelumnya, hanya lebih ketat </h4><br><p>  Namun, misalnya, jaminan yang ditawarkan oleh kompiler pada tahap yang sudah diketahui tidak cukup bagi kami.  Atau, katakanlah, kami tidak ingin (karena satu dan lain hal) masuk ke tumpukan, tetapi ingin bekerja di tumpukan, yang berarti bahwa kami memerlukan array alih-alih vektor, tetapi pada saat yang sama kami ingin kode kami digeneralisasikan ke berbagai ukuran array .  Atau kami ingin fungsi dioptimalkan sebanyak mungkin untuk setiap ukuran spesifik dari daftar input. <br><br>  Singkatnya, kita memerlukan array generik - dan Rust sudah memiliki paket yang menyediakannya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kata demi kata</a> . </p><br><p>  Sekarang kami memiliki kode berikut: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{GenericArray, ArrayLength}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  Apa yang kita ketahui dari kode ini?  Bahwa fungsi mengambil array dari beberapa ukuran tetap, tercermin dalam tipenya (dan dikompilasi secara independen untuk setiap ukuran tersebut).  Sejauh ini, ini tidak banyak berubah - pada akhirnya, jaminan yang persis sama, tidak hanya pada tahap monomorphization, tetapi dalam runtime, disediakan versi sebelumnya dengan potongan. </p><br><p>  Tapi kita bisa melangkah lebih jauh. </p><br><h4 id="arifmetika-urovnya-tipov">  Jenis Aritmatika Tingkat </h4><br><p>  Artikel asli menyebutkan beberapa jaminan yang kami terima dari Idris dan tidak bisa didapatkan dari orang lain.  Salah satunya - dan mungkin yang paling sederhana, karena untuk itu Anda bahkan tidak perlu menulis bukti lengkap atau tes penuh, tetapi cukup tentukan jenisnya sedikit, dikatakan bahwa nilai pengembaliannya, jika ada (mis. Jika bukan <code>Nothing</code> ), dijamin tidak melebihi panjang daftar input. <br><br>  Tampaknya syarat yang diperlukan untuk jaminan semacam itu adalah adanya tipe-tipe dependen, yah, atau setidaknya semacam kesamaan, dan akan aneh mengharapkan sesuatu seperti ini dari Rust, kan? </p><br><p>  Bertemu - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">typenum</a> .  Dengannya, fungsi kita dapat digambarkan seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> generic_array::{ArrayLength, GenericArray}; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> typenum::{IsLess, Unsigned, B1}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsignedLessThan</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;Less, More&gt; UnsignedLessThan&lt;More&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Less <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> Less: IsLess&lt;More, Output = B1&gt;, Less: Unsigned, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_usize</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> { &lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Unsigned&gt;::USIZE } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>&lt;El, Size&gt;(x: GenericArray&lt;El, Size&gt;, y: El) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;dyn UnsignedLessThan&lt;Size&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> El: <span class="hljs-built_in"><span class="hljs-built_in">Eq</span></span>, Size: ArrayLength&lt;El&gt;, { <span class="hljs-comment"><span class="hljs-comment">// 10000    }</span></span></code> </pre> <br><p>  "Apa-apaan ini sihir hitam?!"  - kamu bertanya.  Dan Anda pasti benar: tipenum adalah ilmu hitam itu, dan upaya untuk menggunakannya setidaknya entah bagaimana secara waras adalah dua kali lipat. <br><br>  Namun demikian, tanda tangan dari fungsi ini cukup jelas. </p><br><ul><li>  Fungsi menerima array elemen El ukuran panjang dan satu elemen tipe El. </li><li>  Fungsi mengembalikan nilai Opsi, yang, jika beberapa, <br><ul><li>  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek sifat</a> berdasarkan tipe <code>UnsignedLessThan&lt;T&gt;</code> , yang menerima tipe Ukuran sebagai parameter; </li><li>  pada gilirannya, sifat <code>UnsignedLessThan&lt;T&gt;</code> diimplementasikan untuk semua jenis yang menerapkan <code>Unsigned</code> dan <code>IsLess&lt;T&gt;</code> untuk mana <code>IsLess&lt;T&gt;</code> mengembalikan B1, mis.  benar </li></ul></li></ul><br><p>  Dengan kata lain, dengan cara ini kami menulis sebuah fungsi yang <em>dijamin untuk</em> mengembalikan nomor non-negatif (tidak bertanda) <em>lebih kecil</em> dari ukuran asli array (atau lebih tepatnya, tentu saja, mengembalikan objek sifat yang sama ini, yang kemudian harus kita panggil metode <code>as_usize</code> , dijamin untuk mengembalikan nomor tersebut) . </p><br><p>  Sebenarnya ada dua trik dalam pendekatan ini: </p><br><ol><li>  Kita dapat secara nyata kehilangan kinerja.  Jika tiba-tiba, karena alasan tertentu, fungsi kita seperti itu ada di bagian "panas" dari program, kebutuhan konstan untuk panggilan dinamis mungkin merupakan salah satu operasi yang paling lambat.  Namun, kelemahan ini mungkin tidak sepenting yang terlihat, tetapi ada yang kedua: </li><li>  Agar fungsi ini dapat dikompilasi dengan benar, kita harus benar-benar menulis di dalamnya bukti kebenaran pekerjaannya, atau untuk "mengelabui" sistem tipe melalui <code>unsafe</code> .  Yang pertama terlalu rumit untuk artikel hari Jumat, tetapi yang kedua hanyalah penipuan. </li></ol><br><h4 id="zaklyuchenie">  Kesimpulan </h4><br><p>  Tentu saja, dalam praktiknya, dalam kasus seperti itu, baik implementasi kedua (menerima sepotong tipe sewenang-wenang) atau implementasi di bawah spoiler (menerima objek iterable) akan digunakan.  Semua argumen berikutnya hampir pasti tidak memiliki kepentingan praktis dan hanya berfungsi sebagai latihan dalam bekerja dengan sistem tipe. </p><br><p>  Namun demikian, fakta bahwa pada sistem tipe Rust dapat dapat meniru salah satu fitur dari sistem tipe Idris yang jelas lebih kuat, menurut pendapat saya, cukup indikatif. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468145/">https://habr.com/ru/post/id468145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468127/index.html">Evolution CMS 2.0 pada komponen Laravel 6.0 - evolusi alami MODX Evolution</a></li>
<li><a href="../id468135/index.html">10 laporan JPoint 2019 teratas</a></li>
<li><a href="../id468139/index.html">Aftershokz Xtrainerz Berenang Headphone dengan Suara Berperforma Tulang - Keren</a></li>
<li><a href="../id468141/index.html">Tugas: untuk mengekstraksi ekspresi kunci dari teks dalam bahasa Rusia. Python NLP</a></li>
<li><a href="../id468143/index.html">466 terabit: lalu lintas Internet global terus bertambah, bisakah satelit bersaing dengan kabel bawah laut?</a></li>
<li><a href="../id468151/index.html">Kerentanan GeekBrains: Mengapa membayar uang untuk kursus jika Anda bisa mengunduhnya?</a></li>
<li><a href="../id468157/index.html">Perspektif EcmaScript pada teori umum OOP</a></li>
<li><a href="../id468161/index.html">Para termasyhur serakah: mengapa energi matahari tidak menaklukkan dunia dan bagaimana "mineral Rusia" dapat menyelamatkannya</a></li>
<li><a href="../id468163/index.html">Oracle VM Server untuk SPARC for Dummies (How-to)</a></li>
<li><a href="../id468165/index.html">Cara menggambar browser. Laporan Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>