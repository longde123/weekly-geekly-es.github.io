<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë≥ ü§Ωüèº üñêüèΩ Utilisation de l'apprentissage automatique dans l'analyse statique du code source du programme ü§î üëÜüèª üëî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'apprentissage automatique est profond√©ment enracin√© dans divers domaines de l'activit√© humaine: de la reconnaissance vocale au diagnostic m√©dical. L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation de l'apprentissage automatique dans l'analyse statique du code source du programme</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484208/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/0e0/738/38e0e0738ea8b928bdecb77040a207c1.png" alt="Utilisation de l'apprentissage automatique dans l'analyse statique du code source du programme"></div><br>  L'apprentissage automatique est profond√©ment enracin√© dans divers domaines de l'activit√© humaine: de la reconnaissance vocale au diagnostic m√©dical.  La popularit√© de cette approche est si grande qu'ils essaient de l'utiliser dans la mesure du possible.  Certaines tentatives pour remplacer les approches classiques par des r√©seaux de neurones ne r√©ussissent pas aussi bien.  Jetons un ≈ìil √† l'apprentissage automatique du point de vue de la cr√©ation d'analyseurs de code statique efficaces pour d√©tecter les bogues et les vuln√©rabilit√©s potentielles. <br><a name="habracut"></a><br>  On demande souvent √† l'√©quipe PVS-Studio si nous voulons commencer √† utiliser l'apprentissage automatique pour trouver des erreurs dans le code source des programmes.  R√©ponse courte: oui, mais tr√®s limit√©e.  Nous pensons qu'avec l'utilisation de l'apprentissage automatique dans les probl√®mes d'analyse de code, il existe de nombreux pi√®ges.  Dans la deuxi√®me partie de l'article, nous en parlerons.  Commen√ßons par un examen des nouvelles solutions et id√©es. <br><br><h2>  De nouvelles approches </h2><br>  Actuellement, il existe d√©j√† de nombreuses impl√©mentations d'analyseurs statiques bas√©s sur ou utilisant l'apprentissage automatique, y compris l'apprentissage en profondeur et la PNL pour la d√©tection d'erreurs.  Non seulement les passionn√©s, mais aussi les grandes entreprises, comme Facebook, Amazon ou Mozilla, ont attir√© l'attention sur le potentiel de l'apprentissage automatique lors de la recherche d'erreurs.  Certains projets ne sont pas des analyseurs statiques √† part enti√®re, mais seulement entre les deux, trouvent des erreurs sp√©cifiques lors des validations. <br><br>  Fait int√©ressant, presque tous sont positionn√©s comme des produits r√©volutionnaires qui, avec l'aide de l'intelligence artificielle, changeront le processus de d√©veloppement. <p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/cde/532/28ccde53241d54d5b927234ff729a19d.png"></div><br>  Prenons quelques exemples bien connus: <br><br><ol><li>  Deepcode </li><li>  Infer, Sapienz, SapFix </li><li>  Enhardir </li><li>  Source {d} </li><li>  Clever-Commit, Commit Assistant </li><li>  CodeGuru </li></ol><br><h3>  Deepcode </h3><br>  Deep Code est un outil de recherche de vuln√©rabilit√©s dans le code de programmes √©crits en Java, JavaScript, TypeScript et Python, dans lequel l'apprentissage automatique est pr√©sent en tant que composant.  Selon Boris Paskalev, plus de 250 000 r√®gles fonctionnent d√©j√†.  Cet outil est form√© sur la base des modifications apport√©es par les d√©veloppeurs au code source des projets ouverts (un million de r√©f√©rentiels).  La soci√©t√© elle-m√™me affirme que son projet est grammatical pour les d√©veloppeurs. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/f09/8df/0c0f098dfabd07a95df228b434ab3bfb.png"></div><br><br>  Essentiellement, cet analyseur compare votre solution avec sa base de donn√©es de projets et vous offre la meilleure solution estim√©e √† partir de l'exp√©rience d'autres d√©veloppeurs. <br><br>  En mai 2018, les d√©veloppeurs ont √©crit que la prise en charge du langage C ++ √©tait en cours de pr√©paration, mais ce langage n'est toujours pas pris en charge.  Bien qu'il soit indiqu√© sur le site lui-m√™me qu'une nouvelle langue peut √™tre ajout√©e en quelques semaines, car une seule √©tape d√©pend de la langue - l'analyse. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/68e/7e5/a3868e7e5efa50016e7a7858054da47a.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/984/4f5/1119844f5406645778271c64f12d0df9.png"></div><br><br>  Un groupe de publications sur les m√©thodes sur lesquelles l'analyseur est bas√© est √©galement publi√© sur le site. <br><br><h3>  Inf√©rer </h3><br>  Facebook essaie assez largement d'introduire de nouvelles approches dans ses produits.  Ils n'ont pas ignor√© leur attention et leur apprentissage automatique.  En 2013, ils ont achet√© une startup qui d√©veloppait un analyseur statique bas√© sur une machine.  Et en 2015, le code source du projet <a href="https://github.com/facebook/infer">est devenu ouvert</a> . <br><br>  Infer est un analyseur statique pour les projets √©crits en Java, C, C ++ et Objective-C, d√©velopp√© par Facebook.  Selon le site, il est √©galement utilis√© dans Amazon Web Services, Oculus, Uber et d'autres projets populaires. <br><br>  Infer est actuellement capable de d√©tecter les erreurs li√©es au d√©r√©f√©rencement d'un pointeur nul, les fuites de m√©moire.  Infer est bas√© sur la logique de Hoar, la logique de s√©paration et la bi-abduction, ainsi que sur la th√©orie de l'interpr√©tation abstraite.  L'utilisation de ces approches permet √† l'analyseur de diviser le programme en petits blocs (morceaux) et de les analyser ind√©pendamment les uns des autres. <br><br>  Vous pouvez essayer d'utiliser Infer sur vos projets, cependant, les d√©veloppeurs avertissent que bien que sur les projets Facebook, les hits utiles repr√©sentent 80% des r√©sultats, sur d'autres projets, un faible nombre de faux positifs n'est pas garanti.  Certaines des erreurs qu'Infer ne peut pas encore trouver, mais les d√©veloppeurs travaillent sur l'introduction de tels d√©clencheurs: <br><br><ul><li>  sortir du tableau; </li><li>  exceptions de transtypage; </li><li>  fuite de donn√©es non v√©rifi√©es; </li><li>  race race condition. </li></ul><br><h3>  Sapfix </h3><br>  SapFix est un outil d'√©dition automatis√©.  Il re√ßoit des informations de Sapienz, un outil d'automatisation des tests et de l'analyseur statique Infer, et sur la base des derniers changements et messages, Infer choisit l'une des nombreuses strat√©gies pour corriger les erreurs. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/de6/baa/547de6baa2d74f4e3be984a78c704d45.png"></div><br><br>  Dans certains cas, SapFix annule tout ou partie des modifications.  Dans d'autres cas, il essaie de r√©soudre le probl√®me en g√©n√©rant un correctif √† partir de son ensemble de mod√®les de correctifs.  Cet ensemble est form√© √† partir des mod√®les d'√©dition compil√©s par les programmeurs eux-m√™mes √† partir de l'ensemble des modifications d√©j√† effectu√©es une fois.  Si un tel mod√®le ne corrige pas l'erreur, SapFix essaie d'ajuster le mod√®le √† la situation, en apportant de petites modifications dans l'arborescence de syntaxe abstraite jusqu'√† ce qu'une solution potentielle soit trouv√©e. <br><br>  Mais une solution potentielle ne suffit pas, donc SapFix recueille plusieurs solutions qui sont s√©lectionn√©es sur la base de trois questions: y a-t-il des erreurs de compilation, y a-t-il un crash, la modification introduit-elle de nouveaux plantages.  Une fois les modifications enti√®rement test√©es, les correctifs sont envoy√©s pour examen au programmeur qui d√©cide laquelle des modifications r√©sout le mieux le probl√®me. <br><br><h3>  Enhardir </h3><br>  Embold est une plateforme de d√©marrage pour l'analyse statique du code source des programmes, qui avant le changement de nom s'appelait Gamma.  L'analyse statique est effectu√©e sur la base de nos propres diagnostics, ainsi que sur la base d'analyseurs int√©gr√©s tels que Cppheck, SpotBugs, SQL Check et autres. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/406/bd8/f40406bd824b5eeb1815de357d95565b.png"></div><br><br>  En plus des diagnostics eux-m√™mes, l'accent est mis sur la possibilit√© d'afficher visuellement des infographies par la charge de la base de code et de visualiser facilement les erreurs trouv√©es, ainsi que de rechercher la possibilit√© de refactoring.  De plus, cet analyseur dispose d'un ensemble d'anti-patterns qui vous permet de d√©tecter des probl√®mes dans la structure du code au niveau des classes et des m√©thodes, et de diverses m√©triques pour calculer la qualit√© du syst√®me. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/74f/abb/22074fabb8b67de2ce5d5427729387f7.png"></div><br><br>  L'un des principaux avantages est la solution intelligente et le syst√®me de suggestion de r√©vision qui, en plus des diagnostics habituels, v√©rifient les r√©visions en fonction des informations sur les modifications pr√©c√©dentes. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/122/c46/6e5122c462cd33320eafecd4deac2a49.png"></div><br><br>  √Ä l'aide de NLP, Embold d√©compose le code en parties et recherche les interconnexions et les d√©pendances entre les fonctions et les m√©thodes entre elles, ce qui √©conomise du temps de refactoring. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94e/129/3fe/94e1293fe9e031d4065beb9ea1b21932.png"></div><br><br>  Ainsi, Embold offre principalement une visualisation pratique des r√©sultats d'analyse de votre code source par divers analyseurs, ainsi que ses propres diagnostics, dont certains sont bas√©s sur l'apprentissage automatique. <br><br><h3>  Source {d} </h3><br>  La source {d} est la plus ouverte en termes de mise en ≈ìuvre √† partir des analyseurs que nous avons examin√©s.  C'est √©galement une <a href="https://github.com/src-d/sourced-ce">solution open source</a> .  Sur leur site Web, vous pouvez (en √©change de votre adresse e-mail) obtenir un livret avec une description des technologies qu'ils utilisent.  En outre, il contient un <a href="https://github.com/src-d/awesome-machine-learning-on-source-code">lien</a> vers la base de publications qu'ils ont collect√©e concernant l'utilisation du machine learning pour l'analyse de code, ainsi qu'un <a href="https://github.com/src-d/datasets/tree/master/PublicGitArchive">r√©f√©rentiel</a> avec un ensemble de donn√©es pour la formation sur le code.  Le produit lui-m√™me est une plate-forme enti√®re pour analyser le code source et le produit logiciel, et se concentre plut√¥t non pas sur les d√©veloppeurs, mais sur le lien des gestionnaires.  Parmi ses capacit√©s, il y a une fonction pour identifier le volume de la dette technique, les goulots d'√©tranglement dans le processus de d√©veloppement et d'autres statistiques mondiales sur le projet. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/b8c/425/af2b8c42537b1a2628c95773165ed190.png"></div><br><br>  Ils fondent leur approche de l'analyse de code assist√©e par machine sur l'hypoth√®se naturelle, formul√©e dans l'article " <a href="https://people.inf.ethz.ch/suz/publications/natural.pdf">Sur le caract√®re naturel du logiciel</a> ". <br><br>  <i>¬´Les langages de programmation, en th√©orie, sont complexes, flexibles et puissants, mais les programmes que les vraies personnes √©crivent sont en fait simples et assez r√©p√©titifs, et contiennent donc des propri√©t√©s statistiques utiles et pr√©visibles qui peuvent √™tre exprim√©es en statistiques mod√®les de langage et utilisation pour les t√¢ches de d√©veloppement logiciel. ‚Äù</i> <br><br>  Sur la base de cette hypoth√®se, plus la base de code pour la formation de l'analyseur est grande, plus les propri√©t√©s statistiques ressortent et plus les m√©triques obtenues avec la formation seront pr√©cises. <br><br>  Pour analyser le code, la source {d} utilise le service Babelfish, qui peut analyser un fichier de code dans n'importe quelle langue disponible, obtenir un arbre de syntaxe abstrait et le convertir en arbre de syntaxe universel. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/bbd/c4d/39ebbdc4d561895c1f7b9e251d44e17c.png"></div><br><br>  Cependant, la source {d} ne recherche pas d'erreurs dans le code.  Sur la base de l'arborescence, en utilisant l'apprentissage automatique sur la base de l'ensemble du projet, la source {d} r√©v√®le comment le code est format√©, quel style de codage est utilis√© dans le projet et lors de la validation, et si le nouveau code ne correspond pas au style de code du projet, il apporte les modifications appropri√©es. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/196/c0a/e7f196c0a742ba8f68436b157708c109.png"></div><br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/f51/7bd/debf517bd5d74c2553a9b7fbd112a1b2.png"></div><br><br>  La formation est guid√©e par plusieurs √©l√©ments de base: espaces, tabulations, sauts de ligne, etc. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/ade/8c5/39aade8c5ea77cb3bf89d4a0e999c5f7.png"></div><br><br>  Vous pouvez en savoir plus √† ce sujet dans leur publication: " <a href="https://arxiv.org/abs/1904.00935">STYLE-ANALYZER: correction des incoh√©rences de style de code avec des algorithmes interpr√©tables non supervis√©s</a> ". <br><br>  En g√©n√©ral, source {d} est une large plate-forme de collecte d'une grande vari√©t√© de statistiques sur le code source et le processus de d√©veloppement de projet, du calcul de l'efficacit√© des d√©veloppeurs √† l'identification des co√ªts de temps pour les r√©visions de code. <br><br><h3>  Engagement intelligent </h3><br>  Clever-Commit est un analyseur cr√©√© par Mozilla en collaboration avec Ubisoft.  Il est bas√© sur l' <a href="https://static-wordpress.akamaized.net/montreal.ubisoft.com/wp-content/uploads/2018/03/03172129/clever-commit-msr18.pdf">√©tude CLEVER</a> (Combining Levels of Bug Prevention and Resolution Techniques) d'Ubisoft, et son Commit Assistant bas√© sur le produit, qui identifie les validations suspectes susceptibles de contenir une erreur.  √âtant donn√© que CLEVER est bas√© sur la comparaison de codes, il indique non seulement un code dangereux, mais fait √©galement des suggestions sur d'√©ventuelles corrections.  Selon la description, dans 60 √† 70% des cas, Clever-Commit trouve des zones probl√©matiques et avec la m√™me fr√©quence propose des corrections correctes.  En g√©n√©ral, il y a peu d'informations sur ce projet et sur les erreurs qu'il peut trouver. <br><br><h3>  CodeGuru </h3><br>  Et plus r√©cemment, la liste des analyseurs utilisant le machine learning a √©t√© reconstitu√©e avec un produit d'Amazon appel√© CodeGuru.  Ce service est bas√© sur l'apprentissage automatique, ce qui vous permet de trouver des erreurs dans le code, ainsi que d'identifier des sections co√ªteuses.  Jusqu'√† pr√©sent, l'analyse est uniquement pour le code Java, mais ils √©crivent sur la prise en charge d'autres langages √† l'avenir.  Bien qu'il ait √©t√© annonc√© r√©cemment, le PDG d'AWS (Amazon Web Services) Andy Jassi dit qu'il l'utilise depuis longtemps sur Amazon lui-m√™me. <br><br>  Le site indique que la formation a √©t√© dispens√©e sur la base de code d'Amazon elle-m√™me, ainsi que sur plus de 10 000 projets open source. <br><br>  En fait, le service est divis√© en deux parties: CodeGuru Reviewer, form√© √† la recherche de r√®gles associatives et √† la recherche d'erreurs dans le code, et CodeGuru Profiler, qui surveille les performances des applications. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/662/3a6/ee06623a61ab3f1345d05f169f3325ac.png"></div><br><br>  En g√©n√©ral, peu d'informations ont √©t√© publi√©es sur ce projet.  Le site indique que pour apprendre √† d√©tecter les √©carts par rapport aux "meilleures pratiques", Reviewer analyse les bases de code Amazon et recherche les pull-requests contenant des appels d'API AWS.  Il examine ensuite les modifications apport√©es et les compare avec les donn√©es de la documentation, qui sont analys√©es en parall√®le.  Le r√©sultat est un mod√®le de ¬´meilleures pratiques¬ª. <br><br>  Il est √©galement dit que les recommandations de code personnalis√© s'am√©liorent apr√®s avoir re√ßu des commentaires sur les recommandations. <br><br>  La liste des erreurs auxquelles Reviewer r√©pond est plut√¥t floue, car aucune documentation sp√©cifique pour les erreurs n'a √©t√© publi√©e: <ul><li>  Meilleures pratiques AWS </li><li>  Acc√®s simultan√© </li><li>  Fuites de ressources </li><li>  Fuite d'informations confidentielles </li><li>  "Meilleures pratiques" communes pour le codage </li></ul><br><h2>  Notre scepticisme </h2><br>  Examinons maintenant le probl√®me de la recherche d'erreurs √† travers les yeux de notre √©quipe, qui d√©veloppe des analyseurs statiques depuis de nombreuses ann√©es.  Nous voyons un certain nombre de probl√®mes de haut niveau dans l'application de la formation, dont nous voulons parler.  Mais au d√©but, nous divisons grossi√®rement toutes les approches ML en deux types: <br><br><ol><li>  Entra√Ænez manuellement un analyseur statique √† rechercher divers probl√®mes √† l'aide d'exemples de code synth√©tique et r√©el; </li><li>  Entra√Ænez les algorithmes sur un grand nombre de codes open source (GitHub) et modifiez l'historique, apr√®s quoi l'analyseur lui-m√™me commencera √† d√©tecter les erreurs et m√™me √† sugg√©rer des corrections. </li></ol><br>  Nous parlerons de chaque direction s√©par√©ment, car elles pr√©senteront diverses lacunes inh√©rentes.  Apr√®s quoi, je pense, les lecteurs comprendront pourquoi nous ne nions pas la possibilit√© de l'apprentissage automatique, mais ne partageons pas non plus l'enthousiasme. <br><br>  <b>Remarque</b>  Nous regardons du point de vue du d√©veloppement d'un analyseur statique universel √† usage g√©n√©ral.  Nous nous concentrons sur le d√©veloppement d'un analyseur qui ne se concentre pas sur une base de code sp√©cifique, mais que toute √©quipe peut utiliser dans n'importe quel projet. <br><br><h3>  Formation sur les analyseurs statiques manuels </h3><br>  Supposons que nous voulions utiliser ML pour que l'analyseur commence √† rechercher des anomalies de la forme suivante dans le code: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == A)</code> </pre> <br>  Il est √©trange de comparer une variable avec elle-m√™me.  Nous pouvons √©crire de nombreux exemples de code correct et incorrect et entra√Æner l'analyseur √† rechercher de telles erreurs.  De plus, il est possible d'ajouter de vrais exemples d'erreurs d√©j√† trouv√©es aux tests.  La question, bien s√ªr, est de savoir o√π obtenir ces exemples.  Mais nous consid√©rerons que c'est possible.  Par exemple, nous avons accumul√© un certain nombre d'exemples de telles erreurs: <a href="https://www.viva64.com/ru/examples/v501/">V501</a> , <a href="https://www.viva64.com/ru/examples/v3001/">V3001</a> , <a href="https://www.viva64.com/ru/examples/v6001/">V6001</a> . <br><br>  Alors, est-il possible de rechercher de tels d√©fauts dans le code en utilisant des algorithmes d'apprentissage automatique?  Tu peux.  Mais ce n'est pas clair pourquoi faire √ßa! <br><br>  Voir, afin de former l'analyseur, nous devons consacrer beaucoup d'efforts √† la pr√©paration d'exemples pour la formation.  Ou balisez le code des applications r√©elles, indiquant o√π jurer et o√π non.  Dans tous les cas, beaucoup de travail devra √™tre fait, car il devrait y avoir des milliers d'exemples de formation.  Ou des dizaines de milliers. <br><br>  Apr√®s tout, nous voulons rechercher non seulement les cas (A == A), mais aussi: <br><br><ul><li>  si (X &amp;&amp; A == A) </li><li>  si (A + 1 == A + 1) </li><li>  si (A [i] == A [i]) </li><li>  si ((A) == (A)) </li><li>  et ainsi de suite. </li></ul><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/a51/95d/19ea5195d9075802dbdcd3feda3c4aad.png"></div><br><br>  Voyons maintenant comment un diagnostic aussi simple serait impl√©ment√© dans PVS-Studio: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RulePrototype_V501</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VivaWalker &amp;walker, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *right, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Ptree *operation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SafeEq(operation, <span class="hljs-string"><span class="hljs-string">"=="</span></span>) &amp;&amp; SafeEqual(left, right)) { walker.AddError(<span class="hljs-string"><span class="hljs-string">" , !"</span></span>, left, <span class="hljs-number"><span class="hljs-number">501</span></span>, Level_1, <span class="hljs-string"><span class="hljs-string">"CWE-571"</span></span>); } }</code> </pre> <br>  Et c'est tout.  Aucun exemple de base de formation n√©cessaire! <br><br>  √Ä l'avenir, les diagnostics devraient √™tre appris √† prendre en compte un certain nombre d'exceptions et √† comprendre que l'on devrait jurer (A [0] == A [1-1]).  Cependant, tout cela est tr√®s facile √† programmer.  Mais juste avec la base d'exemples de formation, tout ira mal. <br><br>  Notez que dans les deux cas, un syst√®me de test, la r√©daction de documentation, etc. seront toujours n√©cessaires.  Cependant, l'effort pour cr√©er un nouveau diagnostic est clairement du c√¥t√© de l'approche classique, o√π la r√®gle est simplement cod√©e en dur dans le code. <br><br>  Regardons maintenant une autre r√®gle.  Par exemple, que le r√©sultat de certaines fonctions doit √™tre utilis√©.  Cela n'a aucun sens de les appeler sans utiliser leur r√©sultat.  Voici certaines de ces fonctionnalit√©s: <ul><li>  malloc </li><li>  memcmp </li><li>  cha√Æne :: vide </li></ul><br>  En g√©n√©ral, c'est ce que font les diagnostics de <a href="https://www.viva64.com/ru/w/v530/">V530</a> impl√©ment√©s dans PVS-Studio. <br><br>  Donc, nous voulons rechercher des appels √† de telles fonctions o√π le r√©sultat de leur travail n'est pas utilis√©.  Pour ce faire, vous pouvez g√©n√©rer de nombreux tests.  Et nous pensons que tout fonctionnera bien.  Mais encore une fois, il n'est pas clair pourquoi cela est n√©cessaire. <br><br>  L'impl√©mentation des diagnostics V530 avec toutes les exceptions dans l'analyseur PVS-Studio comprend 258 lignes de code, dont 64 lignes sont des commentaires.  De plus, il y a un tableau avec des annotations de fonctions, o√π il est not√© que leur r√©sultat doit √™tre utilis√©.  Il est beaucoup plus facile de reconstituer ce tableau que de cr√©er des exemples synth√©tiques. <br><br>  La situation sera encore pire avec les diagnostics qui utilisent l'analyse de flux de donn√©es.  Par exemple, l'analyseur PVS-Studio peut suivre la valeur des pointeurs, ce qui permet de trouver une telle fuite de m√©moire: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* BnNew() { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>[kBigIntSize]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(result, <span class="hljs-number"><span class="hljs-number">0</span></span>, kBigIntSize * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AndroidRSAPublicKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(crypto::RSAPrivateKey* key)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>* n = BnNew(); .... RSAPublicKey pkey; pkey.len = kRSANumWords; pkey.exponent = <span class="hljs-number"><span class="hljs-number">65537</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Fixed public exponent pkey.n0inv = 0 - ModInverse(n0, 0x100000000LL); if (pkey.n0inv == 0) return kDummyRSAPublicKey; // &lt;= .... }</span></span></code> </pre> <br>  Un exemple est tir√© de l'article " <a href="https://www.viva64.com/ru/b/0555/">Chrome: fuites de m√©moire</a> ".  Si la condition <i>(pkey.n0inv == 0) est remplie</i> , alors la fonction se termine sans lib√©rer le tampon, dont le pointeur est stock√© dans la variable <i>n</i> . <br><br>  Du point de vue de PVS-Studio, rien de compliqu√©.  L'analyseur a √©tudi√© la fonction <i>BnNew</i> et s'est rappel√© qu'elle renvoie un pointeur sur un bloc de m√©moire allou√©e.  Dans une autre fonction, il a remarqu√© qu'une situation est possible o√π le tampon n'est pas lib√©r√© et le pointeur vers celui-ci est perdu lorsque la fonction se termine. <br><br>  Un algorithme g√©n√©ral de suivi des valeurs fonctionne.  Peu importe comment le code est √©crit.  Peu importe ce qu'il y a d'autre dans la fonction qui n'est pas li√© √† l'utilisation des pointeurs.  L'algorithme est universel et le diagnostic V773 trouve beaucoup d'erreurs dans divers projets.  Voyez √† quel point les <a href="https://www.viva64.com/ru/examples/v773/">fragments de code</a> sont diff√©rents l√† o√π les erreurs sont d√©tect√©es! <br><br>  Nous ne sommes pas des experts en apprentissage automatique, mais il semble qu'il y aura de gros probl√®mes.  Il existe une quantit√© incroyable de fa√ßons d'√©crire du code avec des fuites de m√©moire.  M√™me si la machine est form√©e pour suivre la valeur des variables, il sera n√©cessaire de la former pour comprendre qu'il existe des appels de fonction. <br><br>  On soup√ßonne que tant d'exemples seront n√©cessaires pour la formation que la t√¢che deviendra intimidante.  Nous ne disons pas qu'il est irr√©alisable.  Nous doutons que les co√ªts de cr√©ation d'un analyseur soient payants. <br><br>  <b>Analogie.</b>  Une analogie vient √† l'esprit avec une calculatrice, o√π au lieu de diagnostics, il est n√©cessaire de programmer des op√©rations arithm√©tiques.  Nous sommes s√ªrs que vous pouvez apprendre √† une calculatrice bas√©e sur ML √† bien additionner les nombres en introduisant une base de connaissances sur le r√©sultat des op√©rations 1 + 1 = 2, 1 + 2 = 3, 2 + 1 = 3, 100 + 200 = 300, etc.  Comme vous le savez, l'opportunit√© de d√©velopper une telle calculatrice est une grande question (si une subvention n'est pas allou√©e pour cela :).  Une calculatrice beaucoup plus simple, plus rapide, plus pr√©cise et plus fiable peut √™tre √©crite en utilisant l'op√©ration "+" ordinaire dans le code. <br><br>  <b>Conclusion</b>  La m√©thode fonctionnera.  Mais √† notre avis, cela n'a pas de sens pratique.  Le d√©veloppement prendra plus de temps et le r√©sultat sera moins fiable et pr√©cis, surtout s'il s'agit de la mise en ≈ìuvre de diagnostics complexes bas√©s sur l'analyse du flux de donn√©es. <br><br><h3>  Apprendre de beaucoup d'open source </h3><br>  Eh bien, nous avons trouv√© des exemples synth√©tiques manuels, mais il y a GitHub.  Vous pouvez suivre l'historique des validations et d√©river des mod√®les de modifications / corrections de code.  Ensuite, vous pouvez signaler non seulement des sections du code suspect, mais peut-√™tre m√™me sugg√©rer un moyen de le corriger. <br><br>  Si vous vous arr√™tez √† ce niveau de d√©tail, alors tout semble bien.  Le diable, comme toujours, est dans les d√©tails.  Parlons de ces d√©tails. <br><br>  <b>La premi√®re nuance.</b>  <b>Source de donn√©es.</b> <br><br>  Les modifications sur GitHub sont assez chaotiques et vari√©es.  Les gens sont souvent trop paresseux pour effectuer des validations atomiques et apporter plusieurs modifications au code √† la fois.  Vous savez vous-m√™me comment cela se produit: ils ont corrig√© l'erreur, et en m√™me temps refactoris√© un peu ("Et ici j'ajouterai le traitement d'un tel cas en m√™me temps ...").  M√™me alors, il peut ne pas √™tre clair pour une personne si ces changements sont li√©s les uns aux autres ou non. <br><br>  Le probl√®me est de savoir comment distinguer les erreurs r√©elles de l'ajout de nouvelles fonctionnalit√©s ou autre chose.  Vous pouvez, bien s√ªr, planter 1 000 personnes manuellement pour marquer les validations.  Les utilisateurs devront indiquer qu'ils ont corrig√© l'erreur ici, en effectuant une refactorisation ici, de nouvelles fonctionnalit√©s ici, des exigences modifi√©es ici, etc. <br><br>  Ce balisage est-il possible?  Possible.  Mais faites attention √† la rapidit√© avec laquelle le changement se produit.  Au lieu d '¬´apprendre l'algorithme lui-m√™me sur la base de GitHub¬ª, nous discutons d√©j√† de la fa√ßon de surprendre des centaines de personnes pendant longtemps.  Les co√ªts de main-d'≈ìuvre et le co√ªt de cr√©ation d'un outil augmentent fortement. <br><br>  Vous pouvez essayer d'identifier automatiquement o√π exactement les erreurs ont √©t√© corrig√©es.  Pour ce faire, vous devez analyser les commentaires sur les validations, faire attention aux petites modifications locales, qui sont tr√®s probablement exactement la r√©vision d'erreur.  Il est difficile de dire dans quelle mesure vous pouvez rechercher automatiquement les correctifs de bogues.  Dans tous les cas, il s'agit d'une t√¢che importante n√©cessitant une recherche et une programmation s√©par√©es. <br><br>  Donc, nous n'avons pas encore atteint la formation, mais il y a d√©j√† des nuances :). <br><br>  <b>La deuxi√®me nuance.</b>  <b>Lag en d√©veloppement.</b> <br><br>  Les analyseurs qui seront form√©s sur la base de bases de donn√©es telles que GitHub seront toujours sujets √† un syndrome tel que le ¬´retard mental¬ª.  En effet, les langages de programmation changent avec le temps. <br><br>  C # 8.0 a <a href="https://www.viva64.com/ru/b/0631/">introduit les</a> types de r√©f√©rence Nullable pour aider √† g√©rer les exceptions de r√©f√©rence Null (NRE).  JDK 12 introduit une nouvelle instruction switch ( <a href="https://openjdk.java.net/jeps/325">JEP 325</a> ).  En C ++ 17, il est devenu possible d'ex√©cuter des constructions conditionnelles au stade de la compilation ( <a href="https://www.bfilipek.com/2018/03/ifconstexpr.html">constexpr if</a> ).  Et ainsi de suite. <br><br>  Les langages de programmation √©voluent.  De plus, comme C ++ sont tr√®s rapides et actifs.  De nouveaux mod√®les y apparaissent, de nouvelles fonctions standard sont ajout√©es, etc.  Avec de nouvelles fonctionnalit√©s, de nouveaux mod√®les d'erreur apparaissent √©galement que nous aimerions √©galement identifier √† l'aide de l'analyse de code statique. <br><br>  Et ici, la m√©thode d'enseignement consid√©r√©e a un probl√®me: le motif d'erreur est peut-√™tre d√©j√† connu, il y a un d√©sir de l'identifier, mais il n'y a rien √† apprendre. <br><br>  Examinons ce probl√®me avec un exemple sp√©cifique.  La boucle for bas√©e sur une plage est apparue en C ++ 11.  Et vous pouvez √©crire le code suivant, en it√©rant sur tous les √©l√©ments du conteneur: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) foo(num);</code> </pre> <br>  Le nouveau cycle a entra√Æn√© un nouveau mod√®le d'erreur.  Si le conteneur est modifi√© √† l'int√©rieur de la boucle, cela entra√Ænera l'invalidation des it√©rateurs ¬´fant√¥mes¬ª. <br><br>  Consid√©rez le code incorrect suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Le compilateur le transformera en quelque chose comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> __begin = begin(numbers), __end = end(numbers); __begin != __end; ++__begin) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = *__begin; numbers.push_back(num * <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Pendant l'op√©ration <i>push_back</i> , l' <i>invalidation des</i> it√©rateurs <i>__begin</i> et <i>__end</i> peut se produire si l'allocation de m√©moire √† l'int√©rieur du vecteur se produit.  Le r√©sultat sera un comportement de programme non d√©fini. <br><br>  Ainsi, le mod√®le d'erreur est connu et d√©crit depuis longtemps dans la litt√©rature.  L'analyseur PVS-Studio le diagnostique √† l'aide des diagnostics <a href="https://www.viva64.com/ru/w/v789/">V789</a> et a d√©j√† trouv√© de <a href="https://www.viva64.com/ru/examples/v789/">vraies erreurs</a> dans les projets ouverts. <br><br>  Combien de temps y aura-t-il suffisamment de nouveau code sur GitHub pour remarquer ce mod√®le?  Bonne question ... Vous devez comprendre que si la boucle for bas√©e sur une plage appara√Æt, cela ne signifie pas que tous les programmeurs ont imm√©diatement commenc√© √† l'utiliser massivement.  Cela peut prendre des ann√©es avant que beaucoup de code n'apparaisse en utilisant une nouvelle boucle.  De plus, de nombreuses erreurs doivent √™tre commises, puis elles doivent √™tre corrig√©es afin que l'algorithme puisse remarquer le mod√®le dans les modifications. <br><br>  Combien d'ann√©es devraient s'√©couler?  Cinq?  Dix? <br><br>  Dix, c'est trop, et sommes-nous pessimistes?  Pas du tout.  Huit ans se sont √©coul√©s au moment o√π cet article a √©t√© √©crit, car la boucle bas√©e sur la plage est apparue en C ++ 11.  Mais jusqu'√† pr√©sent, seuls <a href="https://www.viva64.com/ru/examples/v789/">trois cas d'</a> une telle erreur ont √©t√© enregistr√©s dans notre base de donn√©es.  Trois erreurs, ce n'est pas beaucoup et pas peu.  Aucune conclusion ne doit √™tre tir√©e de leur nombre.  L'essentiel est que vous puissiez confirmer qu'un tel mod√®le d'erreur est r√©el et qu'il est logique de le d√©tecter. <br><br>  Comparez maintenant ce montant, par exemple, avec ce mod√®le d'erreur: le <a href="https://www.viva64.com/ru/examples/v595/">pointeur est d√©r√©f√©renc√© avant la v√©rification</a> .  Au total, lors de la v√©rification des projets open-source, nous avons d√©j√† identifi√© 1716 de ces cas. <br><br>  Peut-√™tre que vous ne devriez pas du tout chercher des erreurs de boucle bas√©es sur la plage?  Non.  Seuls les programmeurs sont inertiels, et cet op√©rateur gagne tr√®s lentement en popularit√©.  Progressivement, il y aura beaucoup de code avec sa participation, et, par cons√©quent, il y aura √©galement plus d'erreurs. <br><br>  Tr√®s probablement, cela ne se produira qu'apr√®s 10-15 ans √† partir du moment o√π C ++ 11 est apparu.  Et maintenant une question philosophique.  Connaissant d√©j√† le mod√®le d'erreur, nous attendrons simplement de nombreuses ann√©es jusqu'√† ce que de nombreuses erreurs s'accumulent dans les projets ouverts? <br><br>  Si la r√©ponse est ¬´oui¬ª, alors il est possible de diagnostiquer raisonnablement √† tous les analyseurs sur la base du ML le diagnostic de ¬´retard mental¬ª. <br><br>  Si la r√©ponse est non, que dois-je faire?  Il n'y a pas d'exemples.  Pour les √©crire manuellement?  Mais ensuite, nous revenons au chapitre pr√©c√©dent, o√π nous avons envisag√© d'√©crire √† une personne de nombreux exemples d'apprentissage. <br><br>  Cela peut √™tre fait, mais encore une fois la question de l'opportunit√© se pose.  L'impl√©mentation des diagnostics V789 avec toutes les exceptions dans l'analyseur PVS-Studio ne comprend que 118 lignes de code, dont 13 lignes sont des commentaires.  C'est-√†-dire  Il s'agit d'un diagnostic tr√®s simple qui peut √™tre facilement pris et programm√© de mani√®re classique. <br><br>  Une situation similaire sera avec toutes les autres innovations qui apparaissent dans toutes les autres langues.  Comme on dit, il y a quelque chose √† penser. <br><br>  <b>La troisi√®me nuance.</b>  <b>La documentation</b> <br><br>  Un √©l√©ment important de tout analyseur statique est la documentation qui d√©crit chaque diagnostic.  Sans lui, l'utilisation de l'analyseur sera extr√™mement difficile, voire impossible.  Dans la <a href="https://www.viva64.com/ru/w/">documentation</a> de PVS-Studio, nous avons une description de chaque diagnostic, qui fournit un exemple de code erron√© et comment le corriger.  Il existe √©galement un lien vers <a href="https://cwe.mitre.org/">CWE</a> o√π vous pouvez lire une autre description du probl√®me.  Et tout de m√™me, parfois quelque chose est incompr√©hensible pour les utilisateurs, et ils nous posent des questions de clarification. <br><br>  Dans le cas des analyseurs statiques, qui sont bas√©s sur des algorithmes d'apprentissage automatique, le probl√®me de documentation est en quelque sorte √©touff√©.  Il est suppos√© que l'analyseur indique simplement un endroit qui lui semble suspect et peut-√™tre m√™me sugg√®re comment le r√©parer.  La d√©cision d'apporter ou non un changement appartient √† la personne.  Et l√† ... ahem ... Ce n'est pas facile de prendre une d√©cision, de ne pas pouvoir lire, sur la base de quoi l'analyseur semble m√©fiant √† l'un ou l'autre endroit du code. <br><br>  Bien s√ªr, dans certains cas, tout sera √©vident.  Supposons que l'analyseur pointe vers ce code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src + <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Et proposera de le remplacer par: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(src) + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(p, src);</code> </pre> <br>  Il est imm√©diatement clair que le programmeur a scell√© et ajout√© 1 au mauvais endroit.  Par cons√©quent, moins de m√©moire sera allou√©e. <br><br>  Ici, sans documentation, tout est clair.  Mais ce ne sera pas toujours le cas. <br><br>  Imaginez que l'analyseur pointe silencieusement vers ce code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Et sugg√®re de changer le type de la valeur de retour de char en int: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint8 *hash_stage2)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memcmp</span></span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE); }</code> </pre> <br>  Il n'y a aucune documentation pour l'avertissement.  Et apparemment, le texte de l'avertissement lui-m√™me, tel que nous le comprenons, ne le sera pas non plus, si nous parlons d'un analyseur compl√®tement ind√©pendant. <br><br>  Que faire  Quelle est la diff√©rence?  Dois-je faire un tel remplacement? <br><br>  En principe, ici, vous pouvez tenter votre chance et accepter de corriger le code.  Bien qu'accepter des modifications sans les comprendre, c'est une pratique <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>banale</i></a> ... :) Vous pouvez regarder la description de la fonction <a href="http://www.cplusplus.com/reference/cstring/memcmp/"><i>memcmp</i></a> et lire que la fonction retourne des valeurs <i>int</i> : 0 sup√©rieures √† z√©ro et inf√©rieures √† z√©ro.  Mais tout de m√™me, il n'est peut-√™tre pas clair pourquoi apporter des modifications si le code fonctionne d√©j√† correctement. <br><br>  Maintenant, si vous ne savez pas √† quoi sert une telle modification, lisez la description des diagnostics du <a href="https://www.viva64.com/ru/w/v642/">V642</a> .  Il devient imm√©diatement clair qu'il s'agit d'une v√©ritable erreur.  De plus, cela peut entra√Æner une vuln√©rabilit√©. <br><br>  Peut-√™tre que l'exemple ne semblait pas convaincant.  Apr√®s tout, l'analyseur a propos√© un code susceptible d'√™tre meilleur.  Ok  Regardons un autre exemple de pseudocode, cette fois, pour un changement, en Java. <br><br><pre> <code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj.state = <span class="hljs-number"><span class="hljs-number">200</span></span>; out.writeObject(obj); out.close();</code> </pre> <br>  Il y a une sorte d'objet.  Il est s√©rialis√©.  Ensuite, l'√©tat de l'objet change et il est √† nouveau s√©rialis√©.  Tout semble aller bien.  Imaginez maintenant que l'analyseur, soudain, n'aime pas ce code, et il sugg√®re de le remplacer par: <br><br><pre> <code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ObjectOutputStream(....); SerializedObject obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); obj.state = <span class="hljs-number"><span class="hljs-number">100</span></span>; out.writeObject(obj); obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SerializedObject(); <span class="hljs-comment"><span class="hljs-comment">//    obj.state = 200; out.writeObject(obj); out.close();</span></span></code> </pre> <br>  Au lieu de modifier l'objet et de le r√©enregistrer, un nouvel objet est cr√©√© et il est d√©j√† s√©rialis√©. <br><br>  Il n'y a pas de description du probl√®me.  Pas de documentation.  Le code est devenu plus long.  Pour une raison quelconque, la cr√©ation d'un nouvel objet a √©t√© ajout√©e.  √ätes-vous pr√™t √† effectuer une telle modification dans votre code? <br><br>  Vous direz que ce n'est pas clair.  En effet, ce n'est pas clair.  Et donc ce sera tout le temps incompr√©hensible.  Travailler avec un tel analyseur "silencieux" sera une √©tude sans fin pour tenter de comprendre pourquoi l'analyseur n'aime pas quelque chose. <br><br>  S'il y a de la documentation, alors tout devient transparent.  La classe <i>java.io.ObjectOuputStream</i> , qui est utilis√©e pour la s√©rialisation, met en cache les objets accessibles en √©criture.  Cela signifie que le m√™me objet ne sera pas s√©rialis√© deux fois.  Une fois que la classe s√©rialise l'objet, et la deuxi√®me fois, elle √©crit simplement un lien vers le m√™me premier objet dans le flux.  En savoir plus: <a href="https://www.viva64.com/ru/w/v6076/">V6076</a> - La s√©rialisation r√©currente utilisera l'√©tat d'objet mis en cache √† partir de la premi√®re s√©rialisation. <br><br>  Nous esp√©rons avoir pu expliquer l‚Äôimportance de la documentation.  Et maintenant la question.  Comment la documentation d'un analyseur bas√© sur ML appara√Ætra-t-elle? <br><br>  Lorsqu'un analyseur de code classique est d√©velopp√©, tout est simple et clair.  Il y a un certain sch√©ma d'erreurs.  Nous le d√©crivons dans la documentation et impl√©mentons les diagnostics. <br><br>  Dans le cas de ML, l'inverse est vrai.  Oui, l'analyseur peut remarquer une anomalie dans le code et la signaler.  Mais il ne sait rien de l'essence du d√©faut.  Il ne comprend pas et ne dira pas pourquoi le code ne peut pas √™tre √©crit comme √ßa.  Ce sont des abstractions de trop haut niveau.  Ensuite, l'analyseur doit √©galement apprendre √† lire et √† <b>comprendre la</b> documentation des fonctions. <br><br>  Comme je l'ai dit, √©tant donn√© que le sujet de la documentation est trait√© dans des articles sur l'apprentissage automatique, nous ne sommes pas pr√™ts √† en parler davantage.  Juste une autre grande nuance que nous avons apport√©e pour examen. <br><br>  <b>Remarque</b>  On peut faire valoir que la documentation est facultative.  L'analyseur peut se r√©f√©rer √† de nombreux exemples de correctifs sur GitHub et une personne, en regardant les validations et les commentaires √† leur sujet, trouvera ce qui est quoi.  Oui.  Mais l'id√©e n'a pas l'air attrayante.  Au lieu d'un assistant, l'analyseur agit comme un outil qui va encore plus troubler le programmeur. <br><br>  <b>La quatri√®me nuance.</b>  <b>Langues hautement sp√©cialis√©es.</b> <br><br>  L'approche d√©crite n'est pas applicable aux langages hautement sp√©cialis√©s pour lesquels l'analyse statique peut √©galement √™tre extr√™mement utile.  La raison en est que GitHub et d'autres sources n'ont tout simplement pas une base de code source suffisamment grande pour fournir une formation efficace. <br><br>  Consid√©rez ceci avec un exemple sp√©cifique.  Pour commencer, acc√©dez √† GitHub et recherchez des r√©f√©rentiels pour le langage Java populaire. <br><br>  R√©sultat: langue: ¬´Java¬ª: 3 <b>128 884</b> r√©sultats de r√©f√©rentiel disponibles <br><br>  Prenons maintenant le langage sp√©cialis√© "1C Enterprise" utilis√© dans les applications comptables publi√©es par la soci√©t√© russe <a href="https://ru.wikipedia.org/wiki/1%25D0%25A1">1C</a> . <br><br>  R√©sultat: langue: ¬´1C Enterprise¬ª: <b>551</b> r√©sultats de r√©f√©rentiel disponibles <br><br>  Peut-√™tre que des analyseurs pour cette langue ne sont pas n√©cessaires?  Sont n√©cessaires.  Il existe un besoin pratique pour l'analyse de tels programmes, et des analyseurs correspondants existent d√©j√†.  Par exemple, il existe un plug-in SonarQube 1C (BSL) fabriqu√© par <a href="https://silverbulleters.org/">Silver Bullet</a> . <br><br> , -    ,          . <br><br> <b> . C, C++, #include</b> . <br><br> ,          ML,    ,  Java, JavaScript, Python.     .    C  C++ -  ,      . <br><br>    ,     /,   ,    C  C++  .    ¬´¬ª     . <br><br>  c/cpp-    .   ,      GitHub,  - cpp-    .   ,       ML. <br><br> ,    .    GitHub .     ,    .  ,         .  ,    .cpp-     . <br><br>     .    .    .     ,     ,        .       <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D1%2581%25D1%2581%25D0%25BE%25D1%2580_%25D0%25A1%25D0%25B8"></a> . <br><br>  .    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_name == <span class="hljs-string"><span class="hljs-string">"ML"</span></span>; }</code> </pre> <br>   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Class::IsMagicWord() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(m_name, <span class="hljs-string"><span class="hljs-string">"ML"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>        ,      <i>(x == ¬´y¬ª)</i>  strcmp(x, ¬´y¬ª)? <br><br>      ,  ,    <i>m_name</i>  .  , ,  : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_name; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_name; };</code> </pre> <br>      ,      .     ,          (  <i>std::string</i> ). <br><br>  ,  ,    .h .        ,     .  ,    C  C++. <br><br>  - ,     ,    ,       C  C++. <br><br>     ,    .    ,      ,      .    ,    cpp-. <br><br>     .       (,   ,     ).  ,    .      ,      ,      . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/be0/9dd/e95be09ddb94d84555c134d961ce9566.png"></div><br><br>  ,     GitHub  .     ,    ,   .    -        .   -   ,    .     .           ¬´ ¬ª.    ,    ,     .cpp    (.i) .      . <br><br>  , ,     ,   .      ,   .       .      ,    -  , ,   . <br><br>  ,     .          .   C  C++  ,   GitHub,      .    ,     . <br><br>  <b>Remarque</b>      ,      .   GitHub   C++       ,     .cpp    .         :). <br><br>       ,   C  C++   . <br><br> <b> .    .</b> <br><br>            ,    . <br><br>       <a href="https://www.viva64.com/ru/w/v789/">V789</a> ,     Range-based for loop. ,       ,      .  ,     ,      ,     .     ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num : numbers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) { numbers.push_back(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">// , , return } }</span></span></code> </pre> <br> ,  .         .  PVS-Studio      26  . <br><br>       ,      . ,   ,      ,    . <br><br>      ,   .  ,      ,   ,      ML.  C'est-√†-dire           . <br><br> <b> .      .</b> <br><br>     ,         .       (, WinAPI,     ..). <br><br>        C,  <i>strcmp</i> ,      . GitHub, available code results: <br><br><ul><li> strcmp ‚Äî 40,462,158 </li><li> stricmp ‚Äî 1,256,053 </li></ul><br> ,   . ,   , ,  : <ul><li> ,     .  . </li><li> ,     NULL.  . </li><li> ,       .  . </li><li>  Et ainsi de suite. </li></ul><br>  ?  Non.     ¬´ ¬ª.    ¬´ ¬ª  .       Top50      . ,     , ,  100  ,      .       , ,  ,   . , - Amazon.com      ,     130  ¬´  ¬ª. <br><br>      .  ,   . ,        : <br><br><ul><li> g_ascii_strncasecmp ‚Äî 35,695 </li><li> lstrcmpiA ‚Äî 27,512 </li><li> _wcsicmp_l ‚Äî 5,737 </li><li> _strnicmp_l ‚Äî 5,848 </li><li> _mbscmp_l ‚Äî 2,458 </li><li>  etc. </li></ul><br>  ,    ,          .      .      .     ,         ,   .       ¬´ ¬ª. <br><br>  PVS-Studio    . ,  C  ++      7200 .  : <br><br><ul><li> WinAPI </li><li>   C, </li><li>    (STL), </li><li> glibc (GNU C Library) </li><li>  Qt </li><li> MFC </li><li> zlib </li><li> libpng </li><li> OpenSSL </li><li>  etc. </li></ul><br>   ,    .   .   ,  . <br><br>  .     ML?    ,   . <br><br>  ,  ,   ML,            . ,  .         ,  <i>strcmp</i>  <i>malloc</i> . <br><br> C     .  ,   .       ,  ,        ,     . <br><br>     ,  <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a> . ,   ,  <i>fread</i> .          . ,     .      ,       .        : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> buffer[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n = _fread_nolock(buffer, size_of(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>), <span class="hljs-number"><span class="hljs-number">100</span></span>, stream);</code> </pre> <br>        PVS-Studio: <br><br><pre> <code class="cpp hljs">C_<span class="hljs-string"><span class="hljs-string">"size_t _fread_nolock"</span></span> <span class="hljs-string"><span class="hljs-string">"(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);"</span></span> ADD(HAVE_STATE | RET_SKIP | F_MODIFY_PTR_1, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, <span class="hljs-string"><span class="hljs-string">"_fread_nolock"</span></span>, POINTER_1, BYTE_COUNT, COUNT, POINTER_2). Add_Read(from_2_3, to_return, buf_1). Add_DataSafetyStatusRelations(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>        , ,   ,    ,   .   ,   write-only .   .   . <br><br>         ML. GitHub   .   15000   .     .      : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> fread_unlocked _fread_nolock</span></span></code> </pre> <br>   ? <br><br><ol><li>   .    . </li><li>  ,        ,          . ,   ,    .    . </li><li>   ,  ,       . ,  .   ML       :).        . </li></ol><br>  , ML         . <br><br>  ,    ML,    ,     ,       ,   . , ,     ,     . <br><br>     . ,    ,   WinAPI.     ,    ,   ?   ,        Google,   ,   <b> </b> .  ,      .   <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fread-nolock"><i>_fread_nolock</i></a>        ,    .       ,        ,    C++. ,            20. <br><br>     ,       .   ,  <i>memmove</i> .    - : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memmove</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __builtin___memmove_chk(dest, src, len, __builtin_object_size(dest, <span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre> <br>    <i>__builtin___memmove_chk</i> ?  intrinsic ,     .      . <br><br>  <i>memmove</i>   - : <a href="">    </a> .         ,  -   . <br><br> Ok,     .  ,        .  ,    ML   ,     ,     . <br><br>        .    .      . ,        ,   .    ,        AI? ,  AI    ,    .       ,               . ,      20   . <br><br> <b> </b> <br><br>    ,      ,       .     .      ,     . <ul><li> <b> </b> .   ,  ,      .           ,    -     .  Un exemple.  C++         <a href="http://www.cplusplus.com/reference/memory/auto_ptr/"><i>auto_ptr</i></a> .          <i>unique_ptr</i> . </li><li> <b> </b> .  ,   C  C++   ,  <a href="https://www.viva64.com/ru/t/0012/"> </a> .  ,         .    ,     . ,  <i>long</i>  Windows 32/64    32 .    Linux       32/64      .    ,           .       -.  , ,  .       ,      (   ).     ,       . </li><li> <b> </b> .     ML,   ,  ,    .  C'est-√†-dire     ,   ‚Äî ,    ,   .     ,       .    ,     ,   ‚Äî ,  .          .      ,    /  , ,   ,       .        .   : " <a href="https://www.viva64.com/ru/b/0612/">   PVS-Studio:    </a> ".       ,   , . </li></ul><br><h2>  Conclusions </h2><br>       ,   ,     .    ML    ,    ,    (   )     .       ,   ,  ML    . <br><br>      ,    ,     ML.           ,  ,            . <br><br>  ,     ML      . ,   .  ML    ¬´¬ª               . <br><br>    ,       ,    ,     ,     . <br><br>         ML,       . <br><br><h2>  PS </h2><br>       ,  -  ,       <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D1%2583%25D0%25B4%25D0%25B4%25D0%25B8%25D1%2582%25D1%258B"></a>   ML,      . <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/659/1f4/7fa/6591f47faa384c2ac9472bc1f5eeacb9.png" alt="Licornes luddites"></div><br><br> ,   .               PVS-Studio.          ML.  ,         .          ,     ,   ,     if- :).      ,     :). <br><br>      ,            -,     . <br><br>  Merci de votre attention.      " <a href="https://www.viva64.com/ru/b/0687/">        PVS-Studio</a> ". <br><br><p> <a href="https://habr.com/en/company/pvs-studio/blog/484202/"><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a> </p><br><br>        ,      : Andrey Karpov, Victoria Khanieva. <a href="https://habr.com/en/company/pvs-studio/blog/484202/">Machine Learning in Static Analysis of Program Source Code</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr484208/">https://habr.com/ru/post/fr484208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr484198/index.html">Revers de la m√©daille: qui a gagn√© et perdu sur la croissance des actions Tesla</a></li>
<li><a href="../fr484200/index.html">Comment fixer des objectifs pour les atteindre</a></li>
<li><a href="../fr484202/index.html">Apprentissage automatique dans l'analyse statique du code source du programme</a></li>
<li><a href="../fr484204/index.html">Le ransomware sans fichier FTCODE vole d√©sormais les comptes</a></li>
<li><a href="../fr484206/index.html">Utilisation de mixins dans Dart</a></li>
<li><a href="../fr484212/index.html">Des trucs gratuits pour le karma - l'histoire d'une startup bi√©lorusse qui change le principe de la consommation</a></li>
<li><a href="../fr484214/index.html">Tenseurs dans TensorFlow</a></li>
<li><a href="../fr484216/index.html">Deuxi√®me conf√©rence Zabbix en Russie: inscription et dates importantes</a></li>
<li><a href="../fr484218/index.html">Nous optimisons l'automatisation: comment nous avons acc√©l√©r√© les autotests de 3 √† 4 fois, en pr√©servant les anciens d√©veloppements</a></li>
<li><a href="../fr484220/index.html">Avez-vous command√© la livraison? Comment Crossroads livre 6 000 commandes par jour</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>