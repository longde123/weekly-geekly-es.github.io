<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∂üèª üè¥‚Äç‚ò†Ô∏è üòí Pers√∂nliche Erfahrung: √úbergang von der Low-Level-C-Entwicklung zur Java-Programmierung üë®‚Äçüéì üìè üë®‚Äçüë®‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Artikel spiegelt die pers√∂nlichen Erfahrungen des Autors wider - eines begeisterten Mikrocontroller-Programmierers, der nach langj√§hriger Erfahrun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pers√∂nliche Erfahrung: √úbergang von der Low-Level-C-Entwicklung zur Java-Programmierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412775/"><img src="https://habrastorage.org/webt/vn/27/lu/vn27lubocfjfz-oiaqgsy7eig5o.jpeg"><br><br>  Der Artikel spiegelt die pers√∂nlichen Erfahrungen des Autors wider - eines begeisterten Mikrocontroller-Programmierers, der nach langj√§hriger Erfahrung in der Entwicklung von Mikrocontrollern in C (und ein wenig in C ++) die Gelegenheit hatte, an einem gro√üen Java-Projekt zur Entwicklung von Software f√ºr TV-Set-Top-Boxen mit Android teilzunehmen.  W√§hrend dieses Projekts konnte ich Notizen √ºber interessante Unterschiede zwischen den Sprachen Java und C / C ++ sammeln und verschiedene Ans√§tze zum Schreiben von Programmen bewerten.  Der Artikel gibt nicht vor, eine Referenz zu sein, und untersucht nicht die Effizienz und Produktivit√§t von Java-Programmen.  Es ist eher eine Sammlung pers√∂nlicher Beobachtungen.  Sofern nicht anders angegeben, handelt es sich um eine Java SE 7-Version. <br><a name="habracut"></a><br><h2>  Syntaxunterschiede und Kontrollkonstrukte </h2><br>  Kurz gesagt - die Unterschiede sind minimal, die Syntax ist sehr √§hnlich.  Codebl√∂cke werden auch durch ein Paar geschweifter Klammern {} gebildet.  Die Regeln zum Kompilieren von Bezeichnern sind dieselben wie f√ºr C / C ++.  Die Liste der Schl√ºsselw√∂rter ist fast dieselbe wie in C / C ++.  Integrierte Datentypen - √§hnlich wie in C / C ++.  Arrays - Alle werden auch in eckigen Klammern deklariert. <br><br>  Das Steuerelement if-else, while, do-while, for, switch ist ebenfalls fast vollst√§ndig identisch.  Es ist bemerkenswert, dass es in Java Bezeichnungen gab, die C-Programmierern vertraut waren (solche, die mit dem Schl√ºsselwort goto verwendet werden und von deren Verwendung dringend abgeraten wird).  Java schloss jedoch die M√∂glichkeit aus, mit goto zu einem Label zu wechseln.  Beschriftungen sollten nur zum Verlassen verschachtelter Schleifen verwendet werden: <br><br><pre><code class="java hljs">outer: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { inner: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> inner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> outer; } }</code> </pre> <br>  Um die Lesbarkeit von Programmen in Java zu verbessern, wurde eine interessante M√∂glichkeit hinzugef√ºgt, die Bits langer Zahlen mit einem Unterstrich zu trennen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value1 = <span class="hljs-number"><span class="hljs-number">1_500_000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value2 = <span class="hljs-number"><span class="hljs-number">0xAA_BB_CC_DD</span></span>;</code> </pre> <br>  Extern unterscheidet sich ein Java-Programm nicht wesentlich von einem bekannten C-Programm. Der visuelle Hauptunterschied besteht darin, dass Java keine Funktionen, Variablen, Definitionen neuer Typen (Strukturen), Konstanten usw. zul√§sst, die sich "frei" in der Quelldatei befinden.  Java ist eine objektorientierte Sprache, daher m√ºssen alle Programmentit√§ten zu einer Klasse geh√∂ren.  Ein weiterer wesentlicher Unterschied ist das Fehlen eines Pr√§prozessors.  Diese beiden Unterschiede werden nachstehend ausf√ºhrlicher beschrieben. <br><br><h2>  Objektansatz in C-Sprache </h2><br>  Wenn wir gro√üe Programme in C schreiben, m√ºssen wir grunds√§tzlich mit Objekten arbeiten.  Die Rolle des Objekts wird von einer Struktur √ºbernommen, die eine bestimmte Essenz der ‚Äûrealen Welt‚Äú beschreibt: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   ‚Äì ¬´¬ª struct Data { int field; char *str; /* ... */ };</span></span></code> </pre> <br>  Auch in C gibt es Methoden zur Verarbeitung von "Objekten" -Strukturen - Funktionen.  Funktionen werden jedoch nicht im Wesentlichen mit Daten zusammengef√ºhrt.  Ja, sie werden normalerweise in einer Datei abgelegt, aber jedes Mal muss ein Zeiger auf das zu verarbeitende Objekt in die "typische" Funktion √ºbergeben werden: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result_code; }</code> </pre> <br>  Sie k√∂nnen das "Objekt" erst verwenden, nachdem Sie Speicher zum Speichern zugewiesen haben: <br><br><pre> <code class="java hljs">Data *data = malloc(sizeof(Data));</code> </pre> <br>  In einem C-Programm wird normalerweise eine Funktion definiert, die f√ºr die Initialisierung des ‚ÄûObjekts‚Äú vor seiner ersten Verwendung verantwortlich ist: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;field = <span class="hljs-number"><span class="hljs-number">1541</span></span>; data-&gt;str = NULL; }</code> </pre> <br>  Dann ist der Lebenszyklus eines ‚ÄûObjekts‚Äú in C normalerweise so: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*    "" */</span></span> struct Data *data = malloc(sizeof(Data)); <span class="hljs-comment"><span class="hljs-comment">/*  "" */</span></span> init(data); <span class="hljs-comment"><span class="hljs-comment">/*   "" */</span></span> process(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"string"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*  ,  ""     . */</span></span> free(data);</code> </pre> <br>  Nun listen wir die m√∂glichen Laufzeitfehler auf, die der Programmierer im Lebenszyklus des ‚ÄûObjekts‚Äú machen kann: <br><br><ol><li>  Vergessen Sie, Speicher f√ºr das "Objekt" zuzuweisen </li><li>  Geben Sie die falsche Menge des zugewiesenen Speichers an </li><li>  Vergessen Sie das "Objekt" zu initialisieren </li><li>  Vergessen Sie, nach der Verwendung des Objekts Speicher freizugeben </li></ol><br>  Es kann √§u√üerst schwierig sein, solche Fehler zu erkennen, da sie vom Compiler nicht erkannt werden und w√§hrend des Programmbetriebs auftreten.  Dar√ºber hinaus kann ihre Wirkung sehr unterschiedlich sein und andere Variablen und ‚ÄûObjekte‚Äú des Programms beeinflussen. <br><br><h2>  Java-Objektansatz </h2><br>  Angesichts der objektorientierten Programmierung von OOP haben Sie wahrscheinlich von einem der OOP-Wale geh√∂rt - der Kapselung.  In Java werden im Gegensatz zu C Daten und Methoden zu ihrer Verarbeitung miteinander kombiniert und sind ‚Äûechte‚Äú Objekte.  In Bezug auf OOP wird dies als Kapselung bezeichnet.  Eine Klasse ist eine Beschreibung eines Objekts. Das n√§chste Analogon einer Klasse in C besteht darin, einen neuen Typ mit typedef struct zu definieren.  In Java werden die Funktionen, die zu einer Klasse geh√∂ren, als Methoden bezeichnet. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Entity { public int field; //   public String str; //   //  public int process(int arg1, String arg2) { /* ... */ return resultCode; } //  public Entity() { field = 1541; str = "value"; } }</span></span></code> </pre> <br>  Die Ideologie der Java-Sprache basiert auf der Aussage "Alles ist ein Objekt".  Daher ist es nicht verwunderlich, dass Java die Erstellung von Methoden (Funktionen) und Datenfeldern (Variablen) getrennt von der Klasse verbietet.  Auch die bekannte main () -Methode, von der aus das Programm startet, muss zu einer der Klassen geh√∂ren. <br><br>  Eine Klassendefinition in Java ist analog zu einer Strukturdeklaration in C. Durch die Beschreibung einer Klasse erstellen Sie nichts im Speicher.  Ein Objekt dieser Klasse wird zum Zeitpunkt seiner Erstellung durch den neuen Operator angezeigt.  Das Erstellen eines Objekts in Java ist ein Analogon zum Zuweisen von Speicher in der Sprache C, aber im Gegensatz zu letzterem wird bei der Objekterstellung automatisch eine spezielle Methode aufgerufen - der Konstruktor des Objekts.  Der Konstruktor √ºbernimmt die Rolle der anf√§nglichen Initialisierung des Objekts - ein Analogon der zuvor diskutierten Funktion init ().  Der Name des Konstruktors muss mit dem Namen der Klasse √ºbereinstimmen.  Der Konstruktor kann keinen Wert zur√ºckgeben. <br><br>  Der Lebenszyklus eines Objekts in einem Java-Programm ist wie folgt: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   (   ,  ) Entity entity = new Entity(); //    entity.process(123, "argument");</span></span></code> </pre> <br>  Beachten Sie, dass die Anzahl der m√∂glichen Fehler im Java-Programm viel geringer ist als im C-Programm. Ja, Sie k√∂nnen immer noch vergessen, das Objekt vor der ersten Verwendung zu erstellen (was jedoch zu einer leicht zu debuggenden NullPointerException f√ºhrt), aber was die anderen inh√§renten Fehler betrifft C-Programme √§ndert sich die Situation grundlegend: <br><br><ol><li>  In Java gibt es keinen Operator sizeof ().  Der Java-Compiler selbst berechnet die Speichermenge zum Speichern des Objekts.  Daher ist es nicht m√∂glich, die falsche Gr√∂√üe der Auswahl anzugeben. </li><li>  Die Initialisierung des Objekts erfolgt zum Zeitpunkt der Erstellung.  Es ist unm√∂glich, die Initialisierung zu vergessen. </li><li>  Der vom Objekt belegte Speicher muss nicht freigegeben werden, der Garbage Collector erledigt diese Arbeit.  Es ist nicht zu vergessen, ein Objekt nach der Verwendung zu l√∂schen - es besteht eine geringere Wahrscheinlichkeit eines ‚ÄûSpeicherverlust‚Äú -Effekts. </li></ol><br>  Alles in Java ist also ein Objekt der einen oder anderen Klasse.  Ausnahmen sind Grundelemente, die der Sprache hinzugef√ºgt wurden, um die Leistung und den Speicherverbrauch zu verbessern.  Mehr √ºber Primitive finden Sie weiter unten. <br><br><h2>  Speicher- und Speicherbereinigung </h2><br>  Java beh√§lt die bekannten Konzepte von Heap und Stack f√ºr C / C ++, einen Programmierer, bei.  Beim Erstellen eines Objekts mit dem neuen Operator wird der Speicher zum Speichern des Objekts vom Heap ausgeliehen.  Eine Verkn√ºpfung zu einem Objekt (eine Verkn√ºpfung ist ein Analogon eines Zeigers) wird jedoch auf dem Stapel platziert, wenn das erstellte Objekt nicht Teil eines anderen Objekts ist.  Auf dem Heap werden die "K√∂rper" von Objekten gespeichert, und auf dem Stapel befinden sich lokale Variablen: Verweise auf Objekte und primitive Typen.  Wenn der Heap w√§hrend der Ausf√ºhrung des Programms vorhanden ist und f√ºr alle Threads des Programms verf√ºgbar ist, geh√∂rt der Stapel zur Methode und existiert nur w√§hrend seiner Ausf√ºhrung und ist auch f√ºr andere Threads des Programms nicht zug√§nglich. <br><br>  Java ist unn√∂tig und vor allem - Sie k√∂nnen den von einem Objekt belegten Speicher nicht manuell freigeben.  Diese Arbeit erledigt der Garbage Collector im automatischen Modus.  Die Laufzeit √ºberwacht, ob es m√∂glich ist, jedes Objekt im Heap vom aktuellen Speicherort des Programms aus zu erreichen, indem sie den Links von Objekt zu Objekt folgt.  Wenn nicht, wird ein solches Objekt als "M√ºll" erkannt und wird zum L√∂schkandidaten. <br><br>  Es ist wichtig zu beachten, dass das L√∂schen selbst nicht in dem Moment erfolgt, in dem das Objekt ‚Äûnicht mehr ben√∂tigt wird‚Äú - der Garbage Collector entscheidet √ºber das L√∂schen, und das L√∂schen kann beliebig verz√∂gert werden, bis das Programm endet. <br><br>  Nat√ºrlich erfordert die Arbeit des Garbage Collector Prozessor-Overhead.  Im Gegenzug entlastet er den Programmierer von gro√üen Kopfschmerzen, die mit der Notwendigkeit verbunden sind, nach dem Ende der Verwendung von "Objekten" Speicher freizugeben.  Tats√§chlich ‚Äûnehmen‚Äú wir das Ged√§chtnis, wenn wir es brauchen, und nutzen es, ohne zu denken, dass wir es nach uns selbst befreien m√ºssen. <br><br>  Wenn wir √ºber lokale Variablen sprechen, sollten wir uns an den Ansatz von Java zu ihrer Initialisierung erinnern.  Wenn in C / C ++ eine nicht initialisierte lokale Variable einen zuf√§lligen Wert enth√§lt, l√§sst der Java-Compiler einfach nicht zu, dass sie nicht initialisiert wird: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">//  . System.out.println("" + i); //  !</span></span></code> </pre><br><h2>  Links - Ersatzzeiger </h2><br>  Java hat keine Zeiger, dementsprechend kann ein Java-Programmierer keinen der vielen Fehler machen, die beim Arbeiten mit Zeigern auftreten.  Wenn Sie ein Objekt erstellen, erhalten Sie einen Link zu diesem Objekt: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  entity ‚Äì  . Entity entity = new Entity();</span></span></code> </pre><br>  In C hatte der Programmierer die Wahl: Wie soll beispielsweise eine Struktur an eine Funktion √ºbergeben werden?  Sie k√∂nnten nach Wert √ºbergeben: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    . int func(Data data);    ‚Äì   : //    . void process(Data *data);</span></span></code> </pre> <br>  Durch die √úbergabe des Werts wurde garantiert, dass die Funktion die Daten in der Struktur nicht √§ndert, jedoch hinsichtlich der Leistung ineffektiv ist. Zum Zeitpunkt des Aufrufs der Funktion wurde eine Kopie der Struktur erstellt.  Das Durchlaufen eines Zeigers ist viel effizienter: Tats√§chlich wurde die Adresse im Speicher, an der sich die Struktur befindet, an die Funktion √ºbergeben. <br><br>  In Java gab es nur eine M√∂glichkeit, ein Objekt an eine Methode zu √ºbergeben - als Referenz.  Das √úbergeben als Referenz in Java entspricht dem √úbergeben eines Zeigers in C: <br><ul><li>  Das Kopieren (Klonen) von Speicher erfolgt nicht. </li><li>  Tats√§chlich wird die Adresse des Ortes dieses Objekts √ºbertragen. </li></ul><br>  Im Gegensatz zum C-Sprachzeiger kann eine Java-Verbindung jedoch nicht inkrementiert / dekrementiert werden.  Das "Durchlaufen" der Elemente eines Arrays mithilfe eines Links dazu in Java funktioniert nicht.  Mit einem Link k√∂nnen Sie ihm lediglich einen anderen Wert geben. <br><br>  Nat√ºrlich reduziert das Fehlen von Zeigern als solche die Anzahl m√∂glicher Fehler, jedoch bleibt das Analogon des Nullzeigers in der Sprache - eine Nullreferenz, die durch das Schl√ºsselwort null gekennzeichnet ist. <br><br>  Eine Nullreferenz bereitet einem Java-Programmierer Kopfschmerzen  Erzwingt, dass die Objektreferenz vor der Verwendung entweder auf null √ºberpr√ºft wird oder dass NullPointerException-Ausnahmen behandelt werden.  Ist dies nicht der Fall, st√ºrzt das Programm ab. <br><br>  Alle Objekte in Java werden also √ºber Links √ºbergeben.  Primitive Datentypen (int, long, char ...) werden als Wert √ºbergeben (weitere Informationen zu Primitiven finden Sie weiter unten). <br><br><h2>  Java Link-Funktionen </h2><br>  Der Zugriff auf ein Objekt im Programm erfolgt √ºber einen Link - dies wirkt sich eindeutig positiv auf die Leistung aus, kann jedoch einen Neuling √ºberraschen: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   entity1   . Entity entity1 = new Entity(); entity1.field = 123; //   entity2,     entity1. //    !   ! Entity entity2 = entity1; //   entity1  entity2         . entity2.field = 777; //  entity1.field  777. System.out.println(entity1.field);</span></span></code> </pre> <br>  Methodenargumente und R√ºckgabewerte - alles wird √ºber den Link √ºbergeben.  Zus√§tzlich zu den Vorteilen gibt es einen Nachteil im Vergleich zu C / C ++ - Sprachen, bei denen wir Funktionen ausdr√ºcklich daran hindern k√∂nnen, den durch einen Zeiger √ºbergebenen Wert mithilfe eines const-Qualifikators zu √§ndern: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct Data* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! //    ,    ! data-&gt;field = 0; }</span></span></code> </pre> <br>  Das hei√üt, mit der Sprache C k√∂nnen Sie diesen Fehler in der Kompilierungsphase verfolgen.  Java hat auch das Schl√ºsselwort const, ist jedoch f√ºr zuk√ºnftige Versionen reserviert und wird derzeit √ºberhaupt nicht verwendet.  Bis zu einem gewissen Grad muss das endg√ºltige Schl√ºsselwort seine Rolle erf√ºllen.  Das an die Methode √ºbergebene Objekt wird jedoch nicht vor √Ñnderungen gesch√ºtzt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Entity data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . //    final,    . data.field = 0; } }</span></span></code> </pre> <br>  Die Sache ist, dass das letzte Schl√ºsselwort in diesem Fall auf den Link angewendet wird und nicht auf das Objekt, auf das der Link verweist.  Wenn final auf das Grundelement angewendet wird, verh√§lt sich der Compiler wie erwartet: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . value = 0; }</span></span></code> </pre> <br>  Java-Links sind C ++ - Sprachlinks sehr √§hnlich. <br><br><h2>  Java-Grundelemente </h2><br>  Jedes Java-Objekt enth√§lt neben Datenfeldern unterst√ºtzende Informationen.  Wenn wir beispielsweise in separaten Bytes arbeiten m√∂chten und jedes Byte durch ein Objekt dargestellt wird, kann der Speicher-Overhead bei einem Array von Bytes die verwendbare Gr√∂√üe um ein Vielfaches √ºberschreiten. <br>  Damit Java in den oben beschriebenen F√§llen effizient genug bleibt, wurde der Sprache die Unterst√ºtzung f√ºr primitive Typen - Primitive - hinzugef√ºgt. <br><table><tbody><tr><th>  Primitiv </th><th>  Anzeigen </th><th>  Bittiefe </th><th>  M√∂gliches Analogon in C. </th></tr><tr><td>  Byte </td><td rowspan="5">  Ganzzahl </td><td>  8 </td><td>  char </td></tr><tr><td>  kurz </td><td>  16 </td><td>  kurz </td></tr><tr><td>  char </td><td>  16 </td><td>  wchar_t </td></tr><tr><td>  int </td><td>  32 </td><td>  int (lang) </td></tr><tr><td>  lang </td><td>  64 </td><td>  lang </td></tr><tr><td>  float </td><td>  Gleitkommazahlen </td><td>  32 </td><td>  float </td></tr><tr><td>  doppelt </td><td></td><td>  64 </td><td>  doppelt </td></tr><tr><td>  Boolescher Wert </td><td>  Logisch </td><td>  - - </td><td>  int (C89) / bool (C99) </td></tr></tbody></table><br>  Alle Grundelemente haben ihre Analoga in der C-Sprache. Der C-Standard bestimmt jedoch nicht die genaue Gr√∂√üe von Ganzzahltypen, sondern der Wertebereich, den dieser Typ speichern kann.  Oft m√∂chte der Programmierer die gleiche Bittiefe f√ºr verschiedene Maschinen sicherstellen, was dazu f√ºhrt, dass Typen wie uint32_t im Programm angezeigt werden, obwohl f√ºr alle Bibliotheksfunktionen nur Argumente vom Typ int erforderlich sind. <br>  Diese Tatsache kann nicht auf die Vorteile der Sprache zur√ºckgef√ºhrt werden. <br><br>  Java Integer Primitive haben im Gegensatz zu C feste Bittiefen.  Sie m√ºssen sich also keine Gedanken √ºber die tats√§chliche Bittiefe des Computers machen, auf dem das Java-Programm ausgef√ºhrt wird, sowie √ºber die Bytereihenfolge ("Netzwerk" oder "Intel").  Diese Tatsache hilft, das Prinzip ‚Äûes ist einmal geschrieben - es wird √ºberall erf√ºllt‚Äú zu verwirklichen. <br><br>  Au√üerdem sind in Java alle ganzzahligen Grundelemente signiert (der Sprache fehlt das vorzeichenlose Schl√ºsselwort).  Dies beseitigt die Schwierigkeit, vorzeichenbehaftete und vorzeichenlose Variablen in einem einzelnen Ausdruck zu verwenden, der C innewohnt. <br><br>  Zusammenfassend ist die Bytereihenfolge in Mehrbyte-Grundelementen in Java festgelegt (niedriges Byte bei niedriger Adresse, Little-Endian, umgekehrte Reihenfolge). <br><br>  Zu den Nachteilen der Implementierung von Operationen mit Grundelementen in Java geh√∂rt die Tatsache, dass hier wie im C / C ++ - Programm der √úberlauf des Bitgitters auftreten kann, ohne dass Ausnahmen ausgel√∂st werden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = (i1 + i2); <span class="hljs-comment"><span class="hljs-comment">// r = -16</span></span></code> </pre> <br>  Daten in Java werden also durch zwei Arten von Entit√§ten dargestellt: Objekte und Grundelemente.  Primitive verletzen das Konzept ‚ÄûAlles ist ein Objekt‚Äú, aber in einigen Situationen sind sie zu effektiv, um sie nicht zu verwenden. <br><br><h2>  Vererbung </h2><br>  Vererbung ist ein weiterer OOP-Wal, von dem Sie wahrscheinlich geh√∂rt haben.  Wenn Sie kurz die Frage beantworten, warum Vererbung √ºberhaupt erforderlich ist, lautet die Antwort ‚ÄûWiederverwendung von Code‚Äú. <br><br>  Angenommen, Sie programmieren in C und haben eine gut geschriebene und debuggte ‚ÄûKlasse‚Äú - eine Struktur und Funktionen f√ºr deren Verarbeitung.  Als n√§chstes besteht die Notwendigkeit, eine √§hnliche "Klasse" zu erstellen, jedoch mit erweiterter Funktionalit√§t, und die grundlegende "Klasse" wird weiterhin ben√∂tigt.  Bei der C-Sprache haben Sie nur einen Weg, um dieses Problem zu l√∂sen - die Komposition.  Es geht darum, eine neue erweiterte Struktur zu erstellen - "Klasse", die einen Zeiger auf die Basisstruktur "Klasse" enthalten sollte: <br><br><pre> <code class="java hljs">struct Base { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field1; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *field2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baseMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Base *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; struct Extended { struct Base *base; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> auxField; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extendedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Extended *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ baseMethod(obj-&gt;base, <span class="hljs-number"><span class="hljs-number">123</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Mit Java als objektorientierte Sprache k√∂nnen Sie die Funktionalit√§t vorhandener Klassen mithilfe des Vererbungsmechanismus erweitern: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Base { protected int baseField; private int hidden; public void baseMethod() { } } //   -   . class Extended extends Base { public void extendedMethod() { //    public  protected     . baseField = 123; baseMethod(); // !   private  ! hidden = 123; } }</span></span></code> </pre> <br>  Es ist zu beachten, dass Java die Verwendung von Kompositionen zur Erweiterung der Funktionalit√§t bereits geschriebener Klassen in keiner Weise verbietet.  Dar√ºber hinaus ist in vielen Situationen die Zusammensetzung der Vererbung vorzuziehen. <br><br>  Dank der Vererbung sind Klassen in Java in einer hierarchischen Struktur angeordnet. Jede Klasse hat notwendigerweise nur ein "Elternteil" und kann eine beliebige Anzahl von "Kindern" haben.  Im Gegensatz zu C ++ kann eine Klasse in Java nicht von mehr als einem √ºbergeordneten Element erben (dies l√∂st das Problem der "Diamantvererbung"). <br><br>  W√§hrend der Vererbung erh√§lt die abgeleitete Klasse alle √∂ffentlichen und gesch√ºtzten Felder und Methoden ihrer Basisklasse sowie die Basisklasse ihrer Basisklasse usw. an ihren Speicherort usw. in der Vererbungshierarchie. <br><br>  An der Spitze der Vererbungshierarchie steht der gemeinsame Vorl√§ufer aller Java-Klassen - die Object-Klasse, die einzige, die kein √ºbergeordnetes Element hat. <br><br><h2>  Dynamische Typidentifikation </h2><br>  Einer der wichtigsten Punkte der Java-Sprache ist die Unterst√ºtzung der dynamischen Typidentifikation (RTTI).  Mit einfachen Worten, mit RTTI k√∂nnen Sie ein Objekt einer abgeleiteten Klasse ersetzen, f√ºr das ein Verweis auf die Basis erforderlich ist: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     Base link; //         link = new Extended();</span></span></code> </pre><br>  Mit einem Link zur Laufzeit k√∂nnen Sie den wahren Typ des Objekts bestimmen, auf das sich der Link bezieht - mithilfe des Operators instanceof: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Base) { <span class="hljs-comment"><span class="hljs-comment">// false } else if (link instanceof Extended) { // true }</span></span></code> </pre> <br><h2>  Methoden√ºberschreibungen </h2><br>  Eine Methode oder Funktion neu zu definieren bedeutet, ihren K√∂rper in der Programmausf√ºhrungsphase zu ersetzen.  C-Programmierer sind sich der F√§higkeit einer Sprache bewusst, das Verhalten einer Funktion w√§hrend der Programmausf√ºhrung zu √§ndern.  Es geht darum, Funktionszeiger zu verwenden.  Beispielsweise k√∂nnen Sie einen Zeiger auf eine Funktion in die Struktur der Struktur aufnehmen und dem Zeiger verschiedene Funktionen zuweisen, um den Datenverarbeitungsalgorithmus dieser Struktur zu √§ndern: <br><br><pre> <code class="java hljs">struct Object { <span class="hljs-comment"><span class="hljs-comment">//   . void (*process)(struct Object *); int data; }; void divideByTwo(struct Object *obj) { obj-&gt;data = obj-&gt;data / 2; } void square(struct Object *obj) { obj-&gt;data = obj-&gt;data * obj-&gt;data; } struct Object obj; obj.data = 123; obj.process = divideByTwo; obj.process(&amp;obj); // 123 / 2 = 61 obj.process = square; obj.process(&amp;obj); // 61 * 61 = 3721</span></span></code> </pre> <br>  In Java wie auch in anderen OOP-Sprachen sind √ºberschreibende Methoden untrennbar mit der Vererbung verbunden.  Eine abgeleitete Klasse erh√§lt Zugriff auf die √∂ffentlichen und gesch√ºtzten Methoden der Basisklasse.  Neben der Tatsache, dass er sie aufrufen kann, k√∂nnen Sie das Verhalten einer der Methoden der Basisklasse √§ndern, ohne deren Signatur zu √§ndern.  Dazu reicht es aus, eine Methode mit genau derselben Signatur in der abgeleiteten Klasse zu definieren: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   . class Extended extends Base { //  . public void method() { /* ... */ } //     ! // E      . //     . public void method(int i) { /* ... */ } }</span></span></code> </pre> <br>  Es ist sehr wichtig, dass die Signatur (Methodenname, R√ºckgabewert, Argumente) genau √ºbereinstimmt.  Wenn der Methodenname √ºbereinstimmt und die Argumente unterschiedlich sind, wird die Methode √ºberladen, mehr dazu weiter unten. <br><br><h2>  Polymorphismus </h2><br>  Wie die Einkapselung und Vererbung hat auch der dritte OOP-Wal - der Polymorphismus - eine Art Analogon in der prozedural orientierten C-Sprache. <br><br>  Angenommen, wir haben mehrere "Klassen" von Strukturen, mit denen Sie dieselbe Art von Aktion ausf√ºhren m√∂chten, und die Funktion, die diese Aktion ausf√ºhrt, muss universell sein - muss "in der Lage" sein, mit jeder "Klasse" als Argument zu arbeiten.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine m√∂gliche L√∂sung ist wie folgt: </font></font><br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Ids { ID_A, ID_B }; struct ClassA { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassA obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_A; } struct ClassB { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassB obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_B; } <span class="hljs-comment"><span class="hljs-comment">/* klass -   ClassA, ClassB, ... */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commonFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *klass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)klass; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_A: ClassA *obj = (ClassA *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_B: ClassB *obj = (ClassB *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die L√∂sung sieht umst√§ndlich aus, aber das Ziel ist erreicht - die universelle Funktion commonFunc () akzeptiert das "Objekt" einer beliebigen "Klasse" als Argument. </font><font style="vertical-align: inherit;">Voraussetzung ist, dass eine ‚ÄûKlassen‚Äú -Struktur im ersten Feld einen Bezeichner enth√§lt, anhand dessen die tats√§chliche ‚ÄûKlasse‚Äú des Objekts bestimmt wird. </font><font style="vertical-align: inherit;">Eine solche L√∂sung ist aufgrund der Verwendung des Arguments mit dem Typ "void *" m√∂glich. </font><font style="vertical-align: inherit;">Ein Zeiger eines beliebigen Typs kann jedoch an eine solche Funktion √ºbergeben werden, z. B. "int *". </font><font style="vertical-align: inherit;">Dies f√ºhrt nicht zu Kompilierungsfehlern, aber zur Laufzeit verh√§lt sich das Programm unvorhersehbar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun wollen wir sehen, wie Polymorphismus in Java aussieht (jedoch wie in jeder anderen OOP-Sprache). </font><font style="vertical-align: inherit;">Angenommen, wir haben viele Klassen, die von einer Methode auf dieselbe Weise verarbeitet werden sollten. </font><font style="vertical-align: inherit;">Im Gegensatz zu der oben vorgestellten L√∂sung f√ºr Sprache C MUSS diese polymorphe Methode in allen Klassen des angegebenen Satzes enthalten sein, und alle ihre Versionen M√úSSEN dieselbe Signatur haben.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Als N√§chstes m√ºssen Sie den Compiler zwingen, genau die Version der Methode aufzurufen, die zur entsprechenden Klasse geh√∂rt. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_set_of_class_ klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das hei√üt, die executor () -Methode, die sich an einer beliebigen Stelle im Programm befinden kann, muss mit jeder Klasse aus der Menge (A, B oder C) arbeiten k√∂nnen. </font><font style="vertical-align: inherit;">Wir m√ºssen dem Compiler irgendwie "sagen", dass _set_of_class_ unsere vielen Klassen bezeichnet. </font><font style="vertical-align: inherit;">Hier ist die Vererbung n√ºtzlich - es ist notwendig, alle Klassen aus den Mengenableitungen einer Basisklasse zu erstellen, die eine polymorphe Methode enth√§lt:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }   executor()   : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Base klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und jetzt kann jede Klasse, die ein Erbe von Base ist (dank dynamischer Typidentifikation), als Argument an sie √ºbergeben werden: </font></font><br><br><pre> <code class="java hljs">executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abh√§ngig davon, welches Klassenobjekt als Argument √ºbergeben wird, wird eine zu dieser Klasse geh√∂rende Methode aufgerufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Schl√ºsselwort abstract k√∂nnen Sie den Hauptteil der Methode ausschlie√üen (in Bezug auf OOP abstrakt machen). </font><font style="vertical-align: inherit;">Tats√§chlich teilen wir dem Compiler mit, dass diese Methode in den daraus abgeleiteten Klassen √ºberschrieben werden muss. </font><font style="vertical-align: inherit;">Ist dies nicht der Fall, tritt ein Kompilierungsfehler auf. </font><font style="vertical-align: inherit;">Eine Klasse, die mindestens eine abstrakte Methode enth√§lt, wird auch als abstrakt bezeichnet. </font><font style="vertical-align: inherit;">Der Compiler muss solche Klassen auch mit dem Schl√ºsselwort abstract markieren.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Java-Projektstruktur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Java haben alle Quelldateien die Erweiterung * .java. </font><font style="vertical-align: inherit;">Sowohl die * .h-Headerdateien als auch die Prototypen von Funktionen oder Klassen fehlen. </font><font style="vertical-align: inherit;">Jede Java-Quelldatei muss mindestens eine Klasse enthalten. </font><font style="vertical-align: inherit;">Der Name der Klasse ist √ºblich und beginnt mit einem Gro√übuchstaben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrere Dateien mit Quellcode k√∂nnen zu einem Paket kombiniert werden. </font><font style="vertical-align: inherit;">Dazu m√ºssen folgende Bedingungen erf√ºllt sein:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dateien mit Quellcode m√ºssen sich im selben Verzeichnis im Dateisystem befinden. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Name dieses Verzeichnisses muss mit dem Namen des Pakets √ºbereinstimmen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Am Anfang jeder Quelldatei sollte das Paket angegeben werden, zu dem diese Datei geh√∂rt, zum Beispiel: </font></font></li></ol><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.company.pkg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Eindeutigkeit von Paketnamen innerhalb des Globus sicherzustellen, wird vorgeschlagen, den "invertierten" Domainnamen des Unternehmens zu verwenden. </font><font style="vertical-align: inherit;">Dies ist jedoch keine Voraussetzung und im lokalen Projekt k√∂nnen beliebige Namen verwendet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird auch empfohlen, Paketnamen in Kleinbuchstaben anzugeben. </font><font style="vertical-align: inherit;">So k√∂nnen sie leicht von Klassennamen unterschieden werden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschleierung der Umsetzung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer Aspekt der Kapselung ist die Trennung von Schnittstelle und Implementierung. Wenn die Schnittstelle f√ºr die externen Teile des Programms zug√§nglich ist (au√üerhalb des Moduls oder der Klasse), ist die Implementierung ausgeblendet. In der Literatur wird h√§ufig eine Black-Box-Analogie gezogen, wenn die interne Implementierung von au√üen ‚Äûnicht sichtbar‚Äú ist, aber was in den Eingang der Box eingespeist wird und was sie ausgibt, ‚Äûsichtbar‚Äú ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C werden Implementierungen innerhalb eines Moduls ausgeblendet, wobei Funktionen, die von au√üen nicht sichtbar sein sollten, mit dem Schl√ºsselwort static markiert werden. Die Prototypen der Funktionen, aus denen die Schnittstelle des Moduls besteht, werden in die Header-Datei eingef√ºgt. Ein Modul in C bedeutet ein Paar: eine Quelldatei mit der Erweiterung * .c und einen Header mit der Erweiterung * .h.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java hat auch das statische Schl√ºsselwort, hat jedoch keinen Einfluss auf die ‚ÄûSichtbarkeit‚Äú der Methode oder des Felds von au√üen. </font><font style="vertical-align: inherit;">Um die "Sichtbarkeit" zu steuern, gibt es 3 Zugriffsmodifikatoren: privat, gesch√ºtzt, √∂ffentlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Felder und Methoden einer als privat gekennzeichneten Klasse sind nur darin verf√ºgbar. </font><font style="vertical-align: inherit;">Gesch√ºtzte Felder und Methoden sind auch f√ºr Klassennachkommen zug√§nglich. </font><font style="vertical-align: inherit;">Der √∂ffentliche Modifikator bedeutet, dass auf das markierte Element von au√üerhalb der Klasse zugegriffen werden kann, dh dass es Teil der Schnittstelle ist. </font><font style="vertical-align: inherit;">Es ist auch m√∂glich, dass es keinen Modifikator gibt. In diesem Fall wird der Zugriff auf das Klassenelement durch das Paket eingeschr√§nkt, in dem sich die Klasse befindet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird empfohlen, beim Schreiben einer Klasse zun√§chst alle Felder der Klasse als privat zu markieren und die Zugriffsrechte nach Bedarf zu erweitern.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methoden√ºberladung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine der nervigen Eigenschaften der C-Standardbibliothek ist das Vorhandensein eines ganzen Zoos von Funktionen, die im Wesentlichen dasselbe ausf√ºhren, sich jedoch in der Art des Arguments unterscheiden, zum Beispiel: fabs (), fabsf (), fabsl () - Funktionen zum Erhalten des Absolutwerts f√ºr double, float und long Doppeltypen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java (sowie C ++) unterst√ºtzt einen Methoden√ºberladungsmechanismus. Innerhalb einer Klasse gibt es m√∂glicherweise mehrere Methoden mit einem v√∂llig identischen Namen, die sich jedoch in Typ und Anzahl der Argumente unterscheiden. </font><font style="vertical-align: inherit;">Anhand der Anzahl der Argumente und ihres Typs w√§hlt der Compiler die erforderliche Version der Methode selbst aus - dies ist sehr praktisch und verbessert die Lesbarkeit des Programms. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Java k√∂nnen Operatoren im Gegensatz zu C ++ nicht √ºberladen werden. </font><font style="vertical-align: inherit;">Die Ausnahme bilden die Operatoren "+" und "+ =", die anf√§nglich f√ºr String-Strings √ºberladen sind.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeichen und Zeichenfolgen in Java </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In C m√ºssen Sie mit nullterminalen Zeichenfolgen arbeiten, die durch Zeiger auf das erste Zeichen dargestellt werden: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str; <span class="hljs-comment"><span class="hljs-comment">//  ASCII  wchar_t *strw; //   "" </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solche Zeilen m√ºssen mit einem Nullzeichen enden. </font><font style="vertical-align: inherit;">Wenn es versehentlich "gel√∂scht" wird, wird eine Zeichenfolge als eine Folge von Bytes im Speicher bis zum ersten Nullzeichen betrachtet. </font><font style="vertical-align: inherit;">Das hei√üt, wenn andere Programmvariablen nach der Zeile im Speicher abgelegt werden, k√∂nnen (und werden h√∂chstwahrscheinlich) ihre Werte nach dem √Ñndern einer solchen besch√§digten Zeile verzerrt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich ist ein C-Programmierer nicht verpflichtet, klassische Null-Terminal-Zeichenfolgen zu verwenden, sondern eine Drittanbieter-Implementierung anzuwenden. Hierbei ist jedoch zu beachten, dass f√ºr alle Funktionen aus der Standardbibliothek Null-Terminal-Zeichenfolgen als Argumente erforderlich sind. </font><font style="vertical-align: inherit;">Dar√ºber hinaus definiert der C-Standard nicht die verwendete Codierung, dieser Punkt sollte auch vom Programmierer gesteuert werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Java repr√§sentiert der primitive Zeichentyp (sowie der Zeichen-Wrapper √ºber die folgenden Wrapper) ein einzelnes Zeichen gem√§√ü dem Unicode-Standard. Es wird jeweils eine UTF-16-Codierung verwendet. Ein Zeichen belegt 2 Byte im Speicher, sodass Sie fast alle Zeichen der derzeit verwendeten Sprachen codieren k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichen k√∂nnen durch ihren Unicode angegeben werden:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch1 = <span class="hljs-string"><span class="hljs-string">'\u20BD'</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Unicode eines Zeichens das Maximum von 216 f√ºr char √ºberschreitet, muss ein solches Zeichen durch int dargestellt werden. In der Zeichenfolge werden 2 Zeichen mit 16 Bit belegt, aber auch hier werden Zeichen mit einem Code von mehr als 216 √§u√üerst selten verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java-Zeichenfolgen werden von der integrierten String-Klasse implementiert und speichern 16-Bit-Zeichen. Die String-Klasse enth√§lt alle oder fast alles, was f√ºr die Arbeit mit Strings erforderlich sein kann. Es besteht keine Notwendigkeit, dar√ºber nachzudenken, dass die Zeile notwendigerweise mit Null enden muss. Hier ist es unm√∂glich, dieses Null-Abschlusszeichen unmerklich zu "l√∂schen" oder auf den Speicher jenseits der Zeile zuzugreifen. Bei der Arbeit mit Zeichenfolgen in Java denkt der Programmierer im Allgemeinen nicht dar√ºber nach, wie die Zeichenfolge im Speicher gespeichert wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie oben erw√§hnt, erlaubt Java kein √úberladen von Operatoren (wie in C ++), jedoch ist die String-Klasse eine Ausnahme - nur f√ºr sie werden die Zeilenzusammenf√ºhrungsoperatoren "+" und "+ =" anf√§nglich √ºberladen. </font></font><br><br><pre> <code class="java hljs">String str1 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + <span class="hljs-string"><span class="hljs-string">"World!"</span></span>; String str2 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span>; str2 += <span class="hljs-string"><span class="hljs-string">"World!"</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist bemerkenswert, dass Zeichenfolgen in Java unver√§nderlich sind - einmal erstellt, erlauben sie ihre √Ñnderung nicht. </font><font style="vertical-align: inherit;">Wenn wir beispielsweise versuchen, die Zeile wie folgt zu √§ndern:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; str.toUpperCase(); System.out.println(str); <span class="hljs-comment"><span class="hljs-comment">//   "Hello, World!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die urspr√ºngliche Zeichenfolge √§ndert sich also nicht wirklich. </font><font style="vertical-align: inherit;">Stattdessen wird eine ge√§nderte Kopie der urspr√ºnglichen Zeichenfolge erstellt, die wiederum unver√§nderlich ist:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; String str2 = str.toUpperCase(); System.out.println(str2); <span class="hljs-comment"><span class="hljs-comment">//   "HELLO, WORLD!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somit f√ºhrt jede √Ñnderung einer Zeichenfolge in der Realit√§t zur Erstellung eines neuen Objekts (tats√§chlich kann der Compiler beim Zusammenf√ºhren von Zeilen den Code optimieren und die StringBuilder-Klasse verwenden, die sp√§ter erl√§utert wird). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kommt vor, dass das Programm h√§ufig dieselbe Zeile √§ndern muss. </font><font style="vertical-align: inherit;">In solchen F√§llen k√∂nnen Sie die Optimierung neuer Zeilenobjekte verhindern, um die Geschwindigkeit des Programms und den Speicherverbrauch zu optimieren. </font><font style="vertical-align: inherit;">F√ºr diese Zwecke sollte die StringBuilder-Klasse verwendet werden:</font></font><br><br><pre> <code class="java hljs">String sourceString = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(sourceString); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.append(<span class="hljs-string"><span class="hljs-string">"!!"</span></span>); String changedString = builder.toString(); System.out.println(changedString); <span class="hljs-comment"><span class="hljs-comment">//   "Hell0, W0rld!!!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separat ist der Vergleich von Strings zu erw√§hnen. </font><font style="vertical-align: inherit;">Ein typischer Fehler eines unerfahrenen Java-Programmierers ist das Vergleichen von Zeichenfolgen mit dem Operator "==":</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    "Yes" // ! if (usersInput == "Yes") { //    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein solcher Code enth√§lt formal keine Fehler in der Kompilierungsphase oder Laufzeitfehler, funktioniert jedoch anders als erwartet. </font><font style="vertical-align: inherit;">Da alle Objekte und Zeichenfolgen, einschlie√ülich in Java, durch Links dargestellt werden, f√ºhrt der Vergleich mit dem Operator "==" zu einem Vergleich von Links und nicht von Werten von Objekten. </font><font style="vertical-align: inherit;">Das hei√üt, das Ergebnis ist nur dann wahr, wenn 2 Links wirklich auf dieselbe Zeile verweisen. </font><font style="vertical-align: inherit;">Wenn es sich bei den Zeichenfolgen um unterschiedliche Objekte im Speicher handelt und Sie deren Inhalt vergleichen m√ºssen, m√ºssen Sie die Methode equals () verwenden:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (usersInput.equals(<span class="hljs-string"><span class="hljs-string">"Yes"</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das √úberraschendste ist, dass in einigen F√§llen der Vergleich mit dem Operator ‚Äû==‚Äú korrekt funktioniert: </font></font><br><br><pre> <code class="java hljs">String someString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, anotherString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   "true": System.out.println(someString == anotherString);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies liegt daran, dass sich someString und anotherString in Wirklichkeit auf dasselbe Objekt im Speicher beziehen. </font><font style="vertical-align: inherit;">Der Compiler platziert die gleichen String-Literale im String-Pool - die sogenannte Internierung erfolgt. </font><font style="vertical-align: inherit;">Jedes Mal, wenn dasselbe Zeichenfolgenliteral im Programm angezeigt wird, wird ein Link zur Zeichenfolge aus dem Pool verwendet. </font><font style="vertical-align: inherit;">Die Internierung von Saiten ist aufgrund der Eigenschaft der Unver√§nderlichkeit von Saiten genau m√∂glich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl das Vergleichen des Inhalts von Zeichenfolgen nur mit der Methode equals () zul√§ssig ist, ist es in Java m√∂glich, Zeichenfolgen in Switch-Case-Konstruktionen korrekt zu verwenden (beginnend mit Java 7):</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(); <span class="hljs-comment"><span class="hljs-comment">// ... switch (str) { case "string_value_1": // ... break; case "string_value_2": // ... break; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seltsamerweise kann jedes Java-Objekt in eine Zeichenfolge konvertiert werden. </font><font style="vertical-align: inherit;">Die entsprechende toString () -Methode ist in der Basisklasse f√ºr alle Klassen der Object-Klasse definiert.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ansatz zur Fehlerbehandlung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie in C programmieren, haben Sie m√∂glicherweise den folgenden Ansatz zur Fehlerbehandlung. Jede Funktion einer Bibliothek gibt einen int-Typ zur√ºck. Wenn die Funktion erfolgreich ist, ist dieses Ergebnis 0. Wenn das Ergebnis ungleich Null ist, weist dies auf einen Fehler hin. Meistens wird der Fehlercode durch den von der Funktion zur√ºckgegebenen Wert geleitet. Da die Funktion nur einen Wert zur√ºckgeben kann und bereits vom Fehlercode belegt ist, muss das tats√§chliche Ergebnis der Funktion √ºber das Argument beispielsweise als Zeiger zur√ºckgegeben werden:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data **result, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> errorCode; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist √ºbrigens einer der F√§lle, in denen in einem C-Programm ein Zeiger auf einen Zeiger verwendet werden muss. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manchmal verwenden sie einen anderen Ansatz. Die Funktion gibt keinen Fehlercode zur√ºck, sondern direkt das Ergebnis ihrer Ausf√ºhrung, normalerweise in Form eines Zeigers. Eine Fehlersituation wird mit einem Nullzeiger angezeigt. Dann enth√§lt die Bibliothek normalerweise eine separate Funktion, die den Code des letzten Fehlers zur√ºckgibt:</font></font><br><br><pre> <code class="java hljs">struct Data* function(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *arg); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLastError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf die eine oder andere Weise verschachteln sich beim Programmieren in C der Code, der die ‚Äûn√ºtzliche‚Äú Arbeit erledigt, und der Code, der f√ºr die Behandlung von Fehlern verantwortlich ist, gegenseitig, was das Programm offensichtlich nicht leicht lesbar macht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie m√∂chten, k√∂nnen Sie in Java die oben beschriebenen Ans√§tze verwenden. Hier k√∂nnen Sie jedoch eine v√∂llig andere Methode zum Umgang mit Fehlern anwenden - die Ausnahmebehandlung (jedoch wie in C ++). Der Vorteil der Ausnahmebehandlung besteht darin, dass in diesem Fall der ‚Äûn√ºtzliche‚Äú Code und der Code, der f√ºr die Behandlung von Fehlern und Eventualit√§ten verantwortlich ist, logisch voneinander getrennt sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies wird mithilfe von Try-Catch-Konstruktionen erreicht: Der ‚Äûn√ºtzliche‚Äú Code wird im Try-Abschnitt und der Fehlerbehandlungscode im Catch-Abschnitt platziert.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//       try (FileReader reader = new FileReader("path\\to\\file.txt")) { //    -   . while (reader.read() != -1){ // ... } } catch (IOException ex) { //     }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt Situationen, in denen es nicht m√∂glich ist, den Fehler am Ort seines Auftretens korrekt zu verarbeiten. </font><font style="vertical-align: inherit;">In solchen F√§llen wird in der Methodensignatur angegeben, dass die Methode diese Art von Ausnahme verursachen kann:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt muss der Aufruf dieser Methode notwendigerweise in einem Try-Catch-Block eingerahmt sein, oder die aufrufende Methode muss auch markiert sein, damit sie diese Ausnahme ausl√∂sen kann. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehlender Pr√§prozessor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unabh√§ngig davon, wie bequem der Pr√§prozessor ist, der C / C ++ - Programmierern vertraut ist, fehlt er in der Java-Sprache. </font><font style="vertical-align: inherit;">Java-Entwickler haben wahrscheinlich entschieden, dass es nur verwendet wird, um die Portabilit√§t von Programmen sicherzustellen, und da Java (fast) √ºberall ausgef√ºhrt wird, wird kein Pr√§prozessor darin ben√∂tigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen das Fehlen eines Pr√§prozessors mithilfe eines statischen Flagfelds kompensieren und gegebenenfalls dessen Wert im Programm √ºberpr√ºfen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir √ºber die Organisation von Tests sprechen, ist es m√∂glich, Anmerkungen in Verbindung mit Reflexion (Reflexion) zu verwenden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Array ist auch ein Objekt. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Arbeit mit Arrays in C ist der Indexausgang √ºber die Grenzen des Arrays hinaus ein sehr heimt√ºckischer Fehler. </font><font style="vertical-align: inherit;">Der Compiler meldet dies in keiner Weise und w√§hrend der Ausf√ºhrung wird das Programm nicht mit der entsprechenden Meldung gestoppt:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> array[<span class="hljs-number"><span class="hljs-number">5</span></span>]; array[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">666</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√∂chstwahrscheinlich setzt das Programm die Ausf√ºhrung fort, aber der Wert der Variablen, die sich im obigen Beispiel nach dem Array-Array befand, wird verzerrt. Das Debuggen dieser Art von Fehler ist m√∂glicherweise nicht einfach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Java ist der Programmierer vor solchen schwer zu diagnostizierenden Fehlern gesch√ºtzt. Wenn Sie versuchen, die Grenzen des Arrays zu √ºberschreiten, wird eine ArrayIndexOutOfBoundsException ausgel√∂st. Wenn der Ausnahmefang nicht mit dem Try-Catch-Konstrukt programmiert wurde, st√ºrzt das Programm ab und eine entsprechende Nachricht wird an den Standardfehlerstrom gesendet, in der die Datei mit dem Quellcode und der Zeilennummer angegeben ist, in der das Array √ºberschritten wurde. Das hei√üt, die Diagnose solcher Fehler wird zu einer trivialen Angelegenheit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Verhalten des Java-Programms wird erm√∂glicht, weil das Array in Java durch ein Objekt dargestellt wird. </font><font style="vertical-align: inherit;">Die Gr√∂√üe des Java-Arrays kann nicht ge√§ndert werden, da seine Gr√∂√üe zum Zeitpunkt der Speicherzuweisung fest codiert ist. </font><font style="vertical-align: inherit;">Zur Laufzeit ist das Abrufen der Gr√∂√üe des Arrays so einfach wie das Sch√§len von Birnen:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arraySize = array.length; <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir √ºber mehrdimensionale Arrays sprechen, bietet Java im Vergleich zur C-Sprache eine interessante M√∂glichkeit, "Ladder" -Arrays zu organisieren. </font><font style="vertical-align: inherit;">F√ºr den Fall eines zweidimensionalen Arrays kann sich die Gr√∂√üe jeder einzelnen Zeile von den anderen unterscheiden:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) { array[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie in C befinden sich die Elemente des Arrays nacheinander im Speicher, sodass der Zugriff auf das Array als am effizientesten angesehen wird. Wenn Sie Einf√ºge- / L√∂schvorg√§nge f√ºr Elemente ausf√ºhren oder komplexere Datenstrukturen erstellen m√ºssen, m√ºssen Sie Sammlungen verwenden, z. B. einen Satz (Satz), eine Liste (Liste), eine Karte (Karte). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund des Fehlens von Zeigern und der Unf√§higkeit, Verkn√ºpfungen zu erh√∂hen, ist der Zugriff auf die Elemente des Arrays mithilfe von Indizes m√∂glich.</font></font><br><br><h2>  Sammlungen </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oft reicht die Funktionalit√§t von Arrays nicht aus - dann m√ºssen Sie dynamische Datenstrukturen verwenden. Da die Standard-C-Bibliothek keine vorgefertigte Implementierung dynamischer Datenstrukturen enth√§lt, m√ºssen Sie die Implementierung in Quellcodes oder in Form von Bibliotheken verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Gegensatz zu C enth√§lt die Standard-Java-Bibliothek eine Vielzahl von Implementierungen dynamischer Datenstrukturen oder Sammlungen, ausgedr√ºckt in Java. Alle Sammlungen sind in 3 gro√üe Klassen unterteilt: Listen, Sets und Karten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listen - dynamische Arrays - erm√∂glichen das Hinzuf√ºgen / Entfernen von Elementen. Viele stellen die Reihenfolge der hinzugef√ºgten Elemente nicht sicher, garantieren jedoch, dass keine doppelten Elemente vorhanden sind. Karten oder assoziative Arrays arbeiten mit Schl√ºssel-Wert-Paaren, und der Schl√ºsselwert ist eindeutig - es d√ºrfen nicht zwei Paare mit denselben Schl√ºsseln auf der Karte vorhanden sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr Listen, Mengen und Karten gibt es viele Implementierungen, von denen jede f√ºr eine bestimmte Operation optimiert ist. Beispielsweise werden Listen von den Klassen ArrayList und LinkedList implementiert, wobei ArrayList eine bessere Leistung beim Zugriff auf ein beliebiges Element bietet und LinkedList effizienter beim Einf√ºgen / L√∂schen von Elementen in der Mitte der Liste ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Sammlungen k√∂nnen nur vollst√§ndige Java-Objekte gespeichert werden (Verweise auf Objekte). Daher ist es unm√∂glich, eine Sammlung von Grundelementen direkt zu erstellen (int, char, byte usw.). </font><font style="vertical-align: inherit;">In diesem Fall sollten die entsprechenden Wrapper-Klassen verwendet werden:</font></font><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Primitiv </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verpackungsklasse </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Byte </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Byte </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kurz </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurz </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> char </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Charakter </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> int </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ganzzahl </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lang </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lang </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> float </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Float </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doppelt </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Doppel </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boolescher Wert </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boolescher Wert </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gl√ºcklicherweise ist es beim Programmieren in Java nicht erforderlich, die genaue √úbereinstimmung des primitiven Typs und seines "Wrappers" zu verfolgen. </font><font style="vertical-align: inherit;">Wenn die Methode beispielsweise ein Argument vom Typ Integer empf√§ngt, kann ihr der Typ int √ºbergeben werden. </font><font style="vertical-align: inherit;">Und umgekehrt, wo der Typ int erforderlich ist, k√∂nnen Sie Integer sicher verwenden. </font><font style="vertical-align: inherit;">M√∂glich wurde dies durch den in Java integrierten Mechanismus zum Packen / Entpacken von Grundelementen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von den unangenehmen Momenten sollte erw√§hnt werden, dass die Standard-Java-Bibliothek alte Auflistungsklassen enth√§lt, die in den ersten Versionen von Java nicht erfolgreich implementiert wurden und nicht in neuen Programmen verwendet werden sollten. </font><font style="vertical-align: inherit;">Dies sind die Klassen Aufz√§hlung, Vektor, Stapel, W√∂rterbuch, Hashtabelle, Eigenschaften.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verallgemeinerungen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sammlungen werden √ºblicherweise als generische Datentypen verwendet. </font><font style="vertical-align: inherit;">Das Wesentliche der Verallgemeinerungen in diesem Fall ist, dass wir den Haupttyp der Auflistung angeben, z. B. ArrayList, und in spitzen Klammern den Parametertyp angeben, der in diesem Fall den Typ der in der Liste gespeicherten Elemente bestimmt:</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf diese Weise kann der Compiler den Versuch verfolgen, ein Objekt eines anderen Typs als des angegebenen Typparameters hinzuzuf√ºgen: </font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  ! list.add("First");</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist sehr wichtig, dass der Typparameter w√§hrend der Programmausf√ºhrung gel√∂scht wird, und es gibt keinen Unterschied zwischen beispielsweise einem Objekt der Klasse </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;Integer&gt; </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Klassenobjekt </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;String&gt;. </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daher gibt es keine M√∂glichkeit, den Typ der Sammlungselemente w√§hrend der Programmausf√ºhrung herauszufinden: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! if (list instanceof List&lt;Integer&gt;) { return true; } return false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine Teill√∂sung kann folgender Ansatz sein: Nehmen Sie das erste Element der Sammlung und bestimmen Sie dessen Typ: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!list.isEmpty() &amp;&amp; list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Integer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Ansatz funktioniert jedoch nicht, wenn die Liste leer ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Hinsicht sind Java-Generalisierungen C ++ - Generalisierungen erheblich unterlegen. </font><font style="vertical-align: inherit;">Java-Verallgemeinerungen dienen tats√§chlich dazu, einige der potenziellen Fehler in der Kompilierungsphase abzuschneiden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durchlaufen Sie alle Elemente eines Arrays oder einer Sammlung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beim Programmieren in C m√ºssen Sie h√§ufig alle Elemente des Arrays durchlaufen: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SIZE; i++) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um hier einen Fehler zu machen, ist es einfacher, einfach die falsche Gr√∂√üe des SIZE-Arrays anzugeben oder "&lt;=" anstelle von "&lt;" einzugeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Java gibt es zus√§tzlich zur ‚Äû√ºblichen‚Äú Form der for-Anweisung ein Formular zum Durchlaufen aller Elemente eines Arrays oder einer Sammlung (in anderen Sprachen h√§ufig foreach genannt):</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ... for (Integer i : list) { // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier wird garantiert, dass wir alle Elemente der Liste durchlaufen, wobei die Fehler, die der ‚Äû√ºblichen‚Äú Form der for-Anweisung inh√§rent sind, beseitigt werden. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschiedene Sammlungen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da alle Objekte vom Stammobjekt geerbt werden, bietet Java eine interessante M√∂glichkeit, Listen mit verschiedenen tats√§chlichen Elementtypen zu erstellen: </font></font><br><br><pre> <code class="java hljs">List list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"First"</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">2</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Double(<span class="hljs-number"><span class="hljs-number">3.0</span></span>));         <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object o : list) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String) { <span class="hljs-comment"><span class="hljs-comment">// ... } else if (o instanceof Integer) { // ... } else if (o instanceof Double) { // ... } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transfers </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Vergleich von C / C ++ und Java ist es unm√∂glich, nicht zu bemerken, wie viel mehr funktionale Aufz√§hlungen in Java implementiert sind. </font><font style="vertical-align: inherit;">Hier ist die Aufz√§hlung eine vollwertige Klasse, und Aufz√§hlungselemente sind Objekte dieser Klasse. </font><font style="vertical-align: inherit;">Auf diese Weise kann ein Aufz√§hlungselement mehrere Felder eines beliebigen Typs in Korrespondenz setzen:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Colors { <span class="hljs-comment"><span class="hljs-comment">//     -   . RED ((byte)0xFF, (byte)0x00, (byte)0x00), GREEN ((byte)0x00, (byte)0xFF, (byte)0x00), BLUE ((byte)0x00, (byte)0x00, (byte)0xFF), WHITE ((byte)0xFF, (byte)0xFF, (byte)0xFF), BLACK ((byte)0x00, (byte)0x00, (byte)0x00); //  . private byte r, g, b; //  . private Colors(byte r, byte g, byte b) { this.r = r; this.g = g; this.b = b; } //  . public double getLuma() { return 0.2126 * r + 0.7152 * g + 0.0722 * b; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als vollwertige Klasse kann eine Aufz√§hlung Methoden haben, und mit einem privaten Konstruktor k√∂nnen Sie die Feldwerte einzelner Aufz√§hlungselemente festlegen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es besteht die regelm√§√üige M√∂glichkeit, eine Zeichenfolgendarstellung eines Aufz√§hlungselements, eine Seriennummer sowie ein Array aller Elemente abzurufen:</font></font><br><br><pre> <code class="java hljs">Colors color = Colors.BLACK; String str = color.toString(); <span class="hljs-comment"><span class="hljs-comment">// "BLACK" int i = color.ordinal(); // 4 Colors[] array = Colors.values(); // [RED, GREEN, BLUE, WHITE, BLACK]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und umgekehrt - durch die Zeichenfolgendarstellung k√∂nnen Sie ein Aufz√§hlungselement erhalten und auch seine Methoden aufrufen: </font></font><br><br><pre> <code class="java hljs">Colors red = Colors.valueOf(<span class="hljs-string"><span class="hljs-string">"RED"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Colors.RED Double redLuma = red.getLuma(); // 0.2126 * 255</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nat√ºrlich k√∂nnen Aufz√§hlungen in Switch-Case-Konstrukten verwendet werden. </font></font><br><br><h2>  Schlussfolgerungen </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich sind die Sprachen C und Java darauf ausgelegt, v√∂llig unterschiedliche Probleme zu l√∂sen. Wenn wir jedoch den Softwareentwicklungsprozess in diesen beiden Sprachen vergleichen, √ºbertrifft die Java-Sprache nach den subjektiven Eindr√ºcken des Autors C in Bezug auf die Bequemlichkeit und Geschwindigkeit des Schreibens von Programmen erheblich. Die Entwicklungsumgebung (IDE) spielt eine wichtige Rolle bei der Bereitstellung von Komfort. Der Autor arbeitete mit der IntelliJ IDEA IDE. Wenn Sie in Java programmieren, m√ºssen Sie nicht st√§ndig Angst haben, einen Fehler zu machen. Oft sagt Ihnen die Entwicklungsumgebung, was behoben werden muss, und manchmal erledigt sie dies f√ºr Sie. Wenn ein Laufzeitfehler aufgetreten ist, werden die Art des Fehlers und der Ort seines Auftretens im Quellcode immer im Protokoll angegeben - der Kampf gegen solche Fehler wird zu einer trivialen Angelegenheit. Ein C-Programmierer muss keine unmenschlichen Anstrengungen unternehmen, um zu Java zu wechseln, und das alles, weil sich die Syntax der Sprache geringf√ºgig ge√§ndert hat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn diese Erfahrung f√ºr Leser interessant sein wird, werden wir im n√§chsten Artikel √ºber die Erfahrung mit der Verwendung des JNI-Mechanismus (Ausf√ºhren von nativem C / C ++ - Code aus einer Java-Anwendung) sprechen. </font><font style="vertical-align: inherit;">Der JNI-Mechanismus ist unverzichtbar, wenn Sie die Bildschirmaufl√∂sung und das Bluetooth-Modul steuern m√∂chten, und in anderen F√§llen, wenn die Funktionen von Android-Diensten und -Managern nicht ausreichen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412775/">https://habr.com/ru/post/de412775/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412763/index.html">Verwenden des Firefly-RK3288-Reload-Boards mit dem RockChip RK3288-SoC Mikrochip Digitaler I2C-W√§rmesensor - MCP9808</a></li>
<li><a href="../de412765/index.html">Einf√ºhrung in das neue Unity-Kachelkartensystem</a></li>
<li><a href="../de412767/index.html">CMG Impact 2016 Konferenzr√ºckblick</a></li>
<li><a href="../de412769/index.html">Ich habe PWA gemacht und es in drei App Stores gestellt. Und hier ist, was ich herausgefunden habe</a></li>
<li><a href="../de412773/index.html">Minsk Astro-Luft- und Raumfahrt</a></li>
<li><a href="../de412777/index.html">Meisterwerke der Welts√§ulenkonstruktion: QUAD 11L - die besten ‚ÄûRegale‚Äú des zweitausendsten</a></li>
<li><a href="../de412779/index.html">SSLH: Verstecken Sie SSH / HTTPS / OpenVPN / Telegram hinter einem einzelnen Port 443</a></li>
<li><a href="../de412783/index.html">Installieren des MTProto Telegram-Proxys von der Quelle auf Centos 7</a></li>
<li><a href="../de412785/index.html">Master of Management und Freiberufler. Die Geschichte in drei Teilen</a></li>
<li><a href="../de412787/index.html">Einbetten von Git in ein Unternehmensentwicklungssystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>