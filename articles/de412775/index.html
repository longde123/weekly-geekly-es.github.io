<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏻 🏴‍☠️ 😒 Persönliche Erfahrung: Übergang von der Low-Level-C-Entwicklung zur Java-Programmierung 👨‍🎓 📏 👨‍👨‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Artikel spiegelt die persönlichen Erfahrungen des Autors wider - eines begeisterten Mikrocontroller-Programmierers, der nach langjähriger Erfahrun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Persönliche Erfahrung: Übergang von der Low-Level-C-Entwicklung zur Java-Programmierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412775/"><img src="https://habrastorage.org/webt/vn/27/lu/vn27lubocfjfz-oiaqgsy7eig5o.jpeg"><br><br>  Der Artikel spiegelt die persönlichen Erfahrungen des Autors wider - eines begeisterten Mikrocontroller-Programmierers, der nach langjähriger Erfahrung in der Entwicklung von Mikrocontrollern in C (und ein wenig in C ++) die Gelegenheit hatte, an einem großen Java-Projekt zur Entwicklung von Software für TV-Set-Top-Boxen mit Android teilzunehmen.  Während dieses Projekts konnte ich Notizen über interessante Unterschiede zwischen den Sprachen Java und C / C ++ sammeln und verschiedene Ansätze zum Schreiben von Programmen bewerten.  Der Artikel gibt nicht vor, eine Referenz zu sein, und untersucht nicht die Effizienz und Produktivität von Java-Programmen.  Es ist eher eine Sammlung persönlicher Beobachtungen.  Sofern nicht anders angegeben, handelt es sich um eine Java SE 7-Version. <br><a name="habracut"></a><br><h2>  Syntaxunterschiede und Kontrollkonstrukte </h2><br>  Kurz gesagt - die Unterschiede sind minimal, die Syntax ist sehr ähnlich.  Codeblöcke werden auch durch ein Paar geschweifter Klammern {} gebildet.  Die Regeln zum Kompilieren von Bezeichnern sind dieselben wie für C / C ++.  Die Liste der Schlüsselwörter ist fast dieselbe wie in C / C ++.  Integrierte Datentypen - ähnlich wie in C / C ++.  Arrays - Alle werden auch in eckigen Klammern deklariert. <br><br>  Das Steuerelement if-else, while, do-while, for, switch ist ebenfalls fast vollständig identisch.  Es ist bemerkenswert, dass es in Java Bezeichnungen gab, die C-Programmierern vertraut waren (solche, die mit dem Schlüsselwort goto verwendet werden und von deren Verwendung dringend abgeraten wird).  Java schloss jedoch die Möglichkeit aus, mit goto zu einem Label zu wechseln.  Beschriftungen sollten nur zum Verlassen verschachtelter Schleifen verwendet werden: <br><br><pre><code class="java hljs">outer: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { inner: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> inner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> outer; } }</code> </pre> <br>  Um die Lesbarkeit von Programmen in Java zu verbessern, wurde eine interessante Möglichkeit hinzugefügt, die Bits langer Zahlen mit einem Unterstrich zu trennen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value1 = <span class="hljs-number"><span class="hljs-number">1_500_000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> value2 = <span class="hljs-number"><span class="hljs-number">0xAA_BB_CC_DD</span></span>;</code> </pre> <br>  Extern unterscheidet sich ein Java-Programm nicht wesentlich von einem bekannten C-Programm. Der visuelle Hauptunterschied besteht darin, dass Java keine Funktionen, Variablen, Definitionen neuer Typen (Strukturen), Konstanten usw. zulässt, die sich "frei" in der Quelldatei befinden.  Java ist eine objektorientierte Sprache, daher müssen alle Programmentitäten zu einer Klasse gehören.  Ein weiterer wesentlicher Unterschied ist das Fehlen eines Präprozessors.  Diese beiden Unterschiede werden nachstehend ausführlicher beschrieben. <br><br><h2>  Objektansatz in C-Sprache </h2><br>  Wenn wir große Programme in C schreiben, müssen wir grundsätzlich mit Objekten arbeiten.  Die Rolle des Objekts wird von einer Struktur übernommen, die eine bestimmte Essenz der „realen Welt“ beschreibt: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   – «» struct Data { int field; char *str; /* ... */ };</span></span></code> </pre> <br>  Auch in C gibt es Methoden zur Verarbeitung von "Objekten" -Strukturen - Funktionen.  Funktionen werden jedoch nicht im Wesentlichen mit Daten zusammengeführt.  Ja, sie werden normalerweise in einer Datei abgelegt, aber jedes Mal muss ein Zeiger auf das zu verarbeitende Objekt in die "typische" Funktion übergeben werden: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result_code; }</code> </pre> <br>  Sie können das "Objekt" erst verwenden, nachdem Sie Speicher zum Speichern zugewiesen haben: <br><br><pre> <code class="java hljs">Data *data = malloc(sizeof(Data));</code> </pre> <br>  In einem C-Programm wird normalerweise eine Funktion definiert, die für die Initialisierung des „Objekts“ vor seiner ersten Verwendung verantwortlich ist: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data *data)</span></span></span><span class="hljs-function"> </span></span>{ data-&gt;field = <span class="hljs-number"><span class="hljs-number">1541</span></span>; data-&gt;str = NULL; }</code> </pre> <br>  Dann ist der Lebenszyklus eines „Objekts“ in C normalerweise so: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/*    "" */</span></span> struct Data *data = malloc(sizeof(Data)); <span class="hljs-comment"><span class="hljs-comment">/*  "" */</span></span> init(data); <span class="hljs-comment"><span class="hljs-comment">/*   "" */</span></span> process(data, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"string"</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*  ,  ""     . */</span></span> free(data);</code> </pre> <br>  Nun listen wir die möglichen Laufzeitfehler auf, die der Programmierer im Lebenszyklus des „Objekts“ machen kann: <br><br><ol><li>  Vergessen Sie, Speicher für das "Objekt" zuzuweisen </li><li>  Geben Sie die falsche Menge des zugewiesenen Speichers an </li><li>  Vergessen Sie das "Objekt" zu initialisieren </li><li>  Vergessen Sie, nach der Verwendung des Objekts Speicher freizugeben </li></ol><br>  Es kann äußerst schwierig sein, solche Fehler zu erkennen, da sie vom Compiler nicht erkannt werden und während des Programmbetriebs auftreten.  Darüber hinaus kann ihre Wirkung sehr unterschiedlich sein und andere Variablen und „Objekte“ des Programms beeinflussen. <br><br><h2>  Java-Objektansatz </h2><br>  Angesichts der objektorientierten Programmierung von OOP haben Sie wahrscheinlich von einem der OOP-Wale gehört - der Kapselung.  In Java werden im Gegensatz zu C Daten und Methoden zu ihrer Verarbeitung miteinander kombiniert und sind „echte“ Objekte.  In Bezug auf OOP wird dies als Kapselung bezeichnet.  Eine Klasse ist eine Beschreibung eines Objekts. Das nächste Analogon einer Klasse in C besteht darin, einen neuen Typ mit typedef struct zu definieren.  In Java werden die Funktionen, die zu einer Klasse gehören, als Methoden bezeichnet. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Entity { public int field; //   public String str; //   //  public int process(int arg1, String arg2) { /* ... */ return resultCode; } //  public Entity() { field = 1541; str = "value"; } }</span></span></code> </pre> <br>  Die Ideologie der Java-Sprache basiert auf der Aussage "Alles ist ein Objekt".  Daher ist es nicht verwunderlich, dass Java die Erstellung von Methoden (Funktionen) und Datenfeldern (Variablen) getrennt von der Klasse verbietet.  Auch die bekannte main () -Methode, von der aus das Programm startet, muss zu einer der Klassen gehören. <br><br>  Eine Klassendefinition in Java ist analog zu einer Strukturdeklaration in C. Durch die Beschreibung einer Klasse erstellen Sie nichts im Speicher.  Ein Objekt dieser Klasse wird zum Zeitpunkt seiner Erstellung durch den neuen Operator angezeigt.  Das Erstellen eines Objekts in Java ist ein Analogon zum Zuweisen von Speicher in der Sprache C, aber im Gegensatz zu letzterem wird bei der Objekterstellung automatisch eine spezielle Methode aufgerufen - der Konstruktor des Objekts.  Der Konstruktor übernimmt die Rolle der anfänglichen Initialisierung des Objekts - ein Analogon der zuvor diskutierten Funktion init ().  Der Name des Konstruktors muss mit dem Namen der Klasse übereinstimmen.  Der Konstruktor kann keinen Wert zurückgeben. <br><br>  Der Lebenszyklus eines Objekts in einem Java-Programm ist wie folgt: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   (   ,  ) Entity entity = new Entity(); //    entity.process(123, "argument");</span></span></code> </pre> <br>  Beachten Sie, dass die Anzahl der möglichen Fehler im Java-Programm viel geringer ist als im C-Programm. Ja, Sie können immer noch vergessen, das Objekt vor der ersten Verwendung zu erstellen (was jedoch zu einer leicht zu debuggenden NullPointerException führt), aber was die anderen inhärenten Fehler betrifft C-Programme ändert sich die Situation grundlegend: <br><br><ol><li>  In Java gibt es keinen Operator sizeof ().  Der Java-Compiler selbst berechnet die Speichermenge zum Speichern des Objekts.  Daher ist es nicht möglich, die falsche Größe der Auswahl anzugeben. </li><li>  Die Initialisierung des Objekts erfolgt zum Zeitpunkt der Erstellung.  Es ist unmöglich, die Initialisierung zu vergessen. </li><li>  Der vom Objekt belegte Speicher muss nicht freigegeben werden, der Garbage Collector erledigt diese Arbeit.  Es ist nicht zu vergessen, ein Objekt nach der Verwendung zu löschen - es besteht eine geringere Wahrscheinlichkeit eines „Speicherverlust“ -Effekts. </li></ol><br>  Alles in Java ist also ein Objekt der einen oder anderen Klasse.  Ausnahmen sind Grundelemente, die der Sprache hinzugefügt wurden, um die Leistung und den Speicherverbrauch zu verbessern.  Mehr über Primitive finden Sie weiter unten. <br><br><h2>  Speicher- und Speicherbereinigung </h2><br>  Java behält die bekannten Konzepte von Heap und Stack für C / C ++, einen Programmierer, bei.  Beim Erstellen eines Objekts mit dem neuen Operator wird der Speicher zum Speichern des Objekts vom Heap ausgeliehen.  Eine Verknüpfung zu einem Objekt (eine Verknüpfung ist ein Analogon eines Zeigers) wird jedoch auf dem Stapel platziert, wenn das erstellte Objekt nicht Teil eines anderen Objekts ist.  Auf dem Heap werden die "Körper" von Objekten gespeichert, und auf dem Stapel befinden sich lokale Variablen: Verweise auf Objekte und primitive Typen.  Wenn der Heap während der Ausführung des Programms vorhanden ist und für alle Threads des Programms verfügbar ist, gehört der Stapel zur Methode und existiert nur während seiner Ausführung und ist auch für andere Threads des Programms nicht zugänglich. <br><br>  Java ist unnötig und vor allem - Sie können den von einem Objekt belegten Speicher nicht manuell freigeben.  Diese Arbeit erledigt der Garbage Collector im automatischen Modus.  Die Laufzeit überwacht, ob es möglich ist, jedes Objekt im Heap vom aktuellen Speicherort des Programms aus zu erreichen, indem sie den Links von Objekt zu Objekt folgt.  Wenn nicht, wird ein solches Objekt als "Müll" erkannt und wird zum Löschkandidaten. <br><br>  Es ist wichtig zu beachten, dass das Löschen selbst nicht in dem Moment erfolgt, in dem das Objekt „nicht mehr benötigt wird“ - der Garbage Collector entscheidet über das Löschen, und das Löschen kann beliebig verzögert werden, bis das Programm endet. <br><br>  Natürlich erfordert die Arbeit des Garbage Collector Prozessor-Overhead.  Im Gegenzug entlastet er den Programmierer von großen Kopfschmerzen, die mit der Notwendigkeit verbunden sind, nach dem Ende der Verwendung von "Objekten" Speicher freizugeben.  Tatsächlich „nehmen“ wir das Gedächtnis, wenn wir es brauchen, und nutzen es, ohne zu denken, dass wir es nach uns selbst befreien müssen. <br><br>  Wenn wir über lokale Variablen sprechen, sollten wir uns an den Ansatz von Java zu ihrer Initialisierung erinnern.  Wenn in C / C ++ eine nicht initialisierte lokale Variable einen zufälligen Wert enthält, lässt der Java-Compiler einfach nicht zu, dass sie nicht initialisiert wird: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">//  . System.out.println("" + i); //  !</span></span></code> </pre><br><h2>  Links - Ersatzzeiger </h2><br>  Java hat keine Zeiger, dementsprechend kann ein Java-Programmierer keinen der vielen Fehler machen, die beim Arbeiten mit Zeigern auftreten.  Wenn Sie ein Objekt erstellen, erhalten Sie einen Link zu diesem Objekt: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  entity –  . Entity entity = new Entity();</span></span></code> </pre><br>  In C hatte der Programmierer die Wahl: Wie soll beispielsweise eine Struktur an eine Funktion übergeben werden?  Sie könnten nach Wert übergeben: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    . int func(Data data);    –   : //    . void process(Data *data);</span></span></code> </pre> <br>  Durch die Übergabe des Werts wurde garantiert, dass die Funktion die Daten in der Struktur nicht ändert, jedoch hinsichtlich der Leistung ineffektiv ist. Zum Zeitpunkt des Aufrufs der Funktion wurde eine Kopie der Struktur erstellt.  Das Durchlaufen eines Zeigers ist viel effizienter: Tatsächlich wurde die Adresse im Speicher, an der sich die Struktur befindet, an die Funktion übergeben. <br><br>  In Java gab es nur eine Möglichkeit, ein Objekt an eine Methode zu übergeben - als Referenz.  Das Übergeben als Referenz in Java entspricht dem Übergeben eines Zeigers in C: <br><ul><li>  Das Kopieren (Klonen) von Speicher erfolgt nicht. </li><li>  Tatsächlich wird die Adresse des Ortes dieses Objekts übertragen. </li></ul><br>  Im Gegensatz zum C-Sprachzeiger kann eine Java-Verbindung jedoch nicht inkrementiert / dekrementiert werden.  Das "Durchlaufen" der Elemente eines Arrays mithilfe eines Links dazu in Java funktioniert nicht.  Mit einem Link können Sie ihm lediglich einen anderen Wert geben. <br><br>  Natürlich reduziert das Fehlen von Zeigern als solche die Anzahl möglicher Fehler, jedoch bleibt das Analogon des Nullzeigers in der Sprache - eine Nullreferenz, die durch das Schlüsselwort null gekennzeichnet ist. <br><br>  Eine Nullreferenz bereitet einem Java-Programmierer Kopfschmerzen  Erzwingt, dass die Objektreferenz vor der Verwendung entweder auf null überprüft wird oder dass NullPointerException-Ausnahmen behandelt werden.  Ist dies nicht der Fall, stürzt das Programm ab. <br><br>  Alle Objekte in Java werden also über Links übergeben.  Primitive Datentypen (int, long, char ...) werden als Wert übergeben (weitere Informationen zu Primitiven finden Sie weiter unten). <br><br><h2>  Java Link-Funktionen </h2><br>  Der Zugriff auf ein Objekt im Programm erfolgt über einen Link - dies wirkt sich eindeutig positiv auf die Leistung aus, kann jedoch einen Neuling überraschen: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   entity1   . Entity entity1 = new Entity(); entity1.field = 123; //   entity2,     entity1. //    !   ! Entity entity2 = entity1; //   entity1  entity2         . entity2.field = 777; //  entity1.field  777. System.out.println(entity1.field);</span></span></code> </pre> <br>  Methodenargumente und Rückgabewerte - alles wird über den Link übergeben.  Zusätzlich zu den Vorteilen gibt es einen Nachteil im Vergleich zu C / C ++ - Sprachen, bei denen wir Funktionen ausdrücklich daran hindern können, den durch einen Zeiger übergebenen Wert mithilfe eines const-Qualifikators zu ändern: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct Data* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! //    ,    ! data-&gt;field = 0; }</span></span></code> </pre> <br>  Das heißt, mit der Sprache C können Sie diesen Fehler in der Kompilierungsphase verfolgen.  Java hat auch das Schlüsselwort const, ist jedoch für zukünftige Versionen reserviert und wird derzeit überhaupt nicht verwendet.  Bis zu einem gewissen Grad muss das endgültige Schlüsselwort seine Rolle erfüllen.  Das an die Methode übergebene Objekt wird jedoch nicht vor Änderungen geschützt: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Entity data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . //    final,    . data.field = 0; } }</span></span></code> </pre> <br>  Die Sache ist, dass das letzte Schlüsselwort in diesem Fall auf den Link angewendet wird und nicht auf das Objekt, auf das der Link verweist.  Wenn final auf das Grundelement angewendet wird, verhält sich der Compiler wie erwartet: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    . value = 0; }</span></span></code> </pre> <br>  Java-Links sind C ++ - Sprachlinks sehr ähnlich. <br><br><h2>  Java-Grundelemente </h2><br>  Jedes Java-Objekt enthält neben Datenfeldern unterstützende Informationen.  Wenn wir beispielsweise in separaten Bytes arbeiten möchten und jedes Byte durch ein Objekt dargestellt wird, kann der Speicher-Overhead bei einem Array von Bytes die verwendbare Größe um ein Vielfaches überschreiten. <br>  Damit Java in den oben beschriebenen Fällen effizient genug bleibt, wurde der Sprache die Unterstützung für primitive Typen - Primitive - hinzugefügt. <br><table><tbody><tr><th>  Primitiv </th><th>  Anzeigen </th><th>  Bittiefe </th><th>  Mögliches Analogon in C. </th></tr><tr><td>  Byte </td><td rowspan="5">  Ganzzahl </td><td>  8 </td><td>  char </td></tr><tr><td>  kurz </td><td>  16 </td><td>  kurz </td></tr><tr><td>  char </td><td>  16 </td><td>  wchar_t </td></tr><tr><td>  int </td><td>  32 </td><td>  int (lang) </td></tr><tr><td>  lang </td><td>  64 </td><td>  lang </td></tr><tr><td>  float </td><td>  Gleitkommazahlen </td><td>  32 </td><td>  float </td></tr><tr><td>  doppelt </td><td></td><td>  64 </td><td>  doppelt </td></tr><tr><td>  Boolescher Wert </td><td>  Logisch </td><td>  - - </td><td>  int (C89) / bool (C99) </td></tr></tbody></table><br>  Alle Grundelemente haben ihre Analoga in der C-Sprache. Der C-Standard bestimmt jedoch nicht die genaue Größe von Ganzzahltypen, sondern der Wertebereich, den dieser Typ speichern kann.  Oft möchte der Programmierer die gleiche Bittiefe für verschiedene Maschinen sicherstellen, was dazu führt, dass Typen wie uint32_t im Programm angezeigt werden, obwohl für alle Bibliotheksfunktionen nur Argumente vom Typ int erforderlich sind. <br>  Diese Tatsache kann nicht auf die Vorteile der Sprache zurückgeführt werden. <br><br>  Java Integer Primitive haben im Gegensatz zu C feste Bittiefen.  Sie müssen sich also keine Gedanken über die tatsächliche Bittiefe des Computers machen, auf dem das Java-Programm ausgeführt wird, sowie über die Bytereihenfolge ("Netzwerk" oder "Intel").  Diese Tatsache hilft, das Prinzip „es ist einmal geschrieben - es wird überall erfüllt“ zu verwirklichen. <br><br>  Außerdem sind in Java alle ganzzahligen Grundelemente signiert (der Sprache fehlt das vorzeichenlose Schlüsselwort).  Dies beseitigt die Schwierigkeit, vorzeichenbehaftete und vorzeichenlose Variablen in einem einzelnen Ausdruck zu verwenden, der C innewohnt. <br><br>  Zusammenfassend ist die Bytereihenfolge in Mehrbyte-Grundelementen in Java festgelegt (niedriges Byte bei niedriger Adresse, Little-Endian, umgekehrte Reihenfolge). <br><br>  Zu den Nachteilen der Implementierung von Operationen mit Grundelementen in Java gehört die Tatsache, dass hier wie im C / C ++ - Programm der Überlauf des Bitgitters auftreten kann, ohne dass Ausnahmen ausgelöst werden: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i1 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = <span class="hljs-number"><span class="hljs-number">2_147_483_640</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = (i1 + i2); <span class="hljs-comment"><span class="hljs-comment">// r = -16</span></span></code> </pre> <br>  Daten in Java werden also durch zwei Arten von Entitäten dargestellt: Objekte und Grundelemente.  Primitive verletzen das Konzept „Alles ist ein Objekt“, aber in einigen Situationen sind sie zu effektiv, um sie nicht zu verwenden. <br><br><h2>  Vererbung </h2><br>  Vererbung ist ein weiterer OOP-Wal, von dem Sie wahrscheinlich gehört haben.  Wenn Sie kurz die Frage beantworten, warum Vererbung überhaupt erforderlich ist, lautet die Antwort „Wiederverwendung von Code“. <br><br>  Angenommen, Sie programmieren in C und haben eine gut geschriebene und debuggte „Klasse“ - eine Struktur und Funktionen für deren Verarbeitung.  Als nächstes besteht die Notwendigkeit, eine ähnliche "Klasse" zu erstellen, jedoch mit erweiterter Funktionalität, und die grundlegende "Klasse" wird weiterhin benötigt.  Bei der C-Sprache haben Sie nur einen Weg, um dieses Problem zu lösen - die Komposition.  Es geht darum, eine neue erweiterte Struktur zu erstellen - "Klasse", die einen Zeiger auf die Basisstruktur "Klasse" enthalten sollte: <br><br><pre> <code class="java hljs">struct Base { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> field1; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *field2; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baseMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Base *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; struct Extended { struct Base *base; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> auxField; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extendedMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Extended *obj, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>{ baseMethod(obj-&gt;base, <span class="hljs-number"><span class="hljs-number">123</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Mit Java als objektorientierte Sprache können Sie die Funktionalität vorhandener Klassen mithilfe des Vererbungsmechanismus erweitern: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   class Base { protected int baseField; private int hidden; public void baseMethod() { } } //   -   . class Extended extends Base { public void extendedMethod() { //    public  protected     . baseField = 123; baseMethod(); // !   private  ! hidden = 123; } }</span></span></code> </pre> <br>  Es ist zu beachten, dass Java die Verwendung von Kompositionen zur Erweiterung der Funktionalität bereits geschriebener Klassen in keiner Weise verbietet.  Darüber hinaus ist in vielen Situationen die Zusammensetzung der Vererbung vorzuziehen. <br><br>  Dank der Vererbung sind Klassen in Java in einer hierarchischen Struktur angeordnet. Jede Klasse hat notwendigerweise nur ein "Elternteil" und kann eine beliebige Anzahl von "Kindern" haben.  Im Gegensatz zu C ++ kann eine Klasse in Java nicht von mehr als einem übergeordneten Element erben (dies löst das Problem der "Diamantvererbung"). <br><br>  Während der Vererbung erhält die abgeleitete Klasse alle öffentlichen und geschützten Felder und Methoden ihrer Basisklasse sowie die Basisklasse ihrer Basisklasse usw. an ihren Speicherort usw. in der Vererbungshierarchie. <br><br>  An der Spitze der Vererbungshierarchie steht der gemeinsame Vorläufer aller Java-Klassen - die Object-Klasse, die einzige, die kein übergeordnetes Element hat. <br><br><h2>  Dynamische Typidentifikation </h2><br>  Einer der wichtigsten Punkte der Java-Sprache ist die Unterstützung der dynamischen Typidentifikation (RTTI).  Mit einfachen Worten, mit RTTI können Sie ein Objekt einer abgeleiteten Klasse ersetzen, für das ein Verweis auf die Basis erforderlich ist: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     Base link; //         link = new Extended();</span></span></code> </pre><br>  Mit einem Link zur Laufzeit können Sie den wahren Typ des Objekts bestimmen, auf das sich der Link bezieht - mithilfe des Operators instanceof: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Base) { <span class="hljs-comment"><span class="hljs-comment">// false } else if (link instanceof Extended) { // true }</span></span></code> </pre> <br><h2>  Methodenüberschreibungen </h2><br>  Eine Methode oder Funktion neu zu definieren bedeutet, ihren Körper in der Programmausführungsphase zu ersetzen.  C-Programmierer sind sich der Fähigkeit einer Sprache bewusst, das Verhalten einer Funktion während der Programmausführung zu ändern.  Es geht darum, Funktionszeiger zu verwenden.  Beispielsweise können Sie einen Zeiger auf eine Funktion in die Struktur der Struktur aufnehmen und dem Zeiger verschiedene Funktionen zuweisen, um den Datenverarbeitungsalgorithmus dieser Struktur zu ändern: <br><br><pre> <code class="java hljs">struct Object { <span class="hljs-comment"><span class="hljs-comment">//   . void (*process)(struct Object *); int data; }; void divideByTwo(struct Object *obj) { obj-&gt;data = obj-&gt;data / 2; } void square(struct Object *obj) { obj-&gt;data = obj-&gt;data * obj-&gt;data; } struct Object obj; obj.data = 123; obj.process = divideByTwo; obj.process(&amp;obj); // 123 / 2 = 61 obj.process = square; obj.process(&amp;obj); // 61 * 61 = 3721</span></span></code> </pre> <br>  In Java wie auch in anderen OOP-Sprachen sind überschreibende Methoden untrennbar mit der Vererbung verbunden.  Eine abgeleitete Klasse erhält Zugriff auf die öffentlichen und geschützten Methoden der Basisklasse.  Neben der Tatsache, dass er sie aufrufen kann, können Sie das Verhalten einer der Methoden der Basisklasse ändern, ohne deren Signatur zu ändern.  Dazu reicht es aus, eine Methode mit genau derselben Signatur in der abgeleiteten Klasse zu definieren: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   . class Extended extends Base { //  . public void method() { /* ... */ } //     ! // E      . //     . public void method(int i) { /* ... */ } }</span></span></code> </pre> <br>  Es ist sehr wichtig, dass die Signatur (Methodenname, Rückgabewert, Argumente) genau übereinstimmt.  Wenn der Methodenname übereinstimmt und die Argumente unterschiedlich sind, wird die Methode überladen, mehr dazu weiter unten. <br><br><h2>  Polymorphismus </h2><br>  Wie die Einkapselung und Vererbung hat auch der dritte OOP-Wal - der Polymorphismus - eine Art Analogon in der prozedural orientierten C-Sprache. <br><br>  Angenommen, wir haben mehrere "Klassen" von Strukturen, mit denen Sie dieselbe Art von Aktion ausführen möchten, und die Funktion, die diese Aktion ausführt, muss universell sein - muss "in der Lage" sein, mit jeder "Klasse" als Argument zu arbeiten.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine mögliche Lösung ist wie folgt: </font></font><br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Ids { ID_A, ID_B }; struct ClassA { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassA obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_A; } struct ClassB { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassB obj)</span></span></span><span class="hljs-function"> </span></span>{ obj-&gt;id = ID_B; } <span class="hljs-comment"><span class="hljs-comment">/* klass -   ClassA, ClassB, ... */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commonFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *klass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)klass; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_A: ClassA *obj = (ClassA *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ID_B: ClassB *obj = (ClassB *) klass; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Lösung sieht umständlich aus, aber das Ziel ist erreicht - die universelle Funktion commonFunc () akzeptiert das "Objekt" einer beliebigen "Klasse" als Argument. </font><font style="vertical-align: inherit;">Voraussetzung ist, dass eine „Klassen“ -Struktur im ersten Feld einen Bezeichner enthält, anhand dessen die tatsächliche „Klasse“ des Objekts bestimmt wird. </font><font style="vertical-align: inherit;">Eine solche Lösung ist aufgrund der Verwendung des Arguments mit dem Typ "void *" möglich. </font><font style="vertical-align: inherit;">Ein Zeiger eines beliebigen Typs kann jedoch an eine solche Funktion übergeben werden, z. B. "int *". </font><font style="vertical-align: inherit;">Dies führt nicht zu Kompilierungsfehlern, aber zur Laufzeit verhält sich das Programm unvorhersehbar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun wollen wir sehen, wie Polymorphismus in Java aussieht (jedoch wie in jeder anderen OOP-Sprache). </font><font style="vertical-align: inherit;">Angenommen, wir haben viele Klassen, die von einer Methode auf dieselbe Weise verarbeitet werden sollten. </font><font style="vertical-align: inherit;">Im Gegensatz zu der oben vorgestellten Lösung für Sprache C MUSS diese polymorphe Methode in allen Klassen des angegebenen Satzes enthalten sein, und alle ihre Versionen MÜSSEN dieselbe Signatur haben.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Als Nächstes müssen Sie den Compiler zwingen, genau die Version der Methode aufzurufen, die zur entsprechenden Klasse gehört. </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_set_of_class_ klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das heißt, die executor () -Methode, die sich an einer beliebigen Stelle im Programm befinden kann, muss mit jeder Klasse aus der Menge (A, B oder C) arbeiten können. </font><font style="vertical-align: inherit;">Wir müssen dem Compiler irgendwie "sagen", dass _set_of_class_ unsere vielen Klassen bezeichnet. </font><font style="vertical-align: inherit;">Hier ist die Vererbung nützlich - es ist notwendig, alle Klassen aus den Mengenableitungen einer Basisklasse zu erstellen, die eine polymorphe Methode enthält:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>} }   executor()   : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">executor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Base klass)</span></span></span><span class="hljs-function"> </span></span>{ klass.method(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und jetzt kann jede Klasse, die ein Erbe von Base ist (dank dynamischer Typidentifikation), als Argument an sie übergeben werden: </font></font><br><br><pre> <code class="java hljs">executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B()); executor(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> C());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abhängig davon, welches Klassenobjekt als Argument übergeben wird, wird eine zu dieser Klasse gehörende Methode aufgerufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem Schlüsselwort abstract können Sie den Hauptteil der Methode ausschließen (in Bezug auf OOP abstrakt machen). </font><font style="vertical-align: inherit;">Tatsächlich teilen wir dem Compiler mit, dass diese Methode in den daraus abgeleiteten Klassen überschrieben werden muss. </font><font style="vertical-align: inherit;">Ist dies nicht der Fall, tritt ein Kompilierungsfehler auf. </font><font style="vertical-align: inherit;">Eine Klasse, die mindestens eine abstrakte Methode enthält, wird auch als abstrakt bezeichnet. </font><font style="vertical-align: inherit;">Der Compiler muss solche Klassen auch mit dem Schlüsselwort abstract markieren.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Java-Projektstruktur </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Java haben alle Quelldateien die Erweiterung * .java. </font><font style="vertical-align: inherit;">Sowohl die * .h-Headerdateien als auch die Prototypen von Funktionen oder Klassen fehlen. </font><font style="vertical-align: inherit;">Jede Java-Quelldatei muss mindestens eine Klasse enthalten. </font><font style="vertical-align: inherit;">Der Name der Klasse ist üblich und beginnt mit einem Großbuchstaben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrere Dateien mit Quellcode können zu einem Paket kombiniert werden. </font><font style="vertical-align: inherit;">Dazu müssen folgende Bedingungen erfüllt sein:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dateien mit Quellcode müssen sich im selben Verzeichnis im Dateisystem befinden. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Name dieses Verzeichnisses muss mit dem Namen des Pakets übereinstimmen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Am Anfang jeder Quelldatei sollte das Paket angegeben werden, zu dem diese Datei gehört, zum Beispiel: </font></font></li></ol><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.company.pkg;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Eindeutigkeit von Paketnamen innerhalb des Globus sicherzustellen, wird vorgeschlagen, den "invertierten" Domainnamen des Unternehmens zu verwenden. </font><font style="vertical-align: inherit;">Dies ist jedoch keine Voraussetzung und im lokalen Projekt können beliebige Namen verwendet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird auch empfohlen, Paketnamen in Kleinbuchstaben anzugeben. </font><font style="vertical-align: inherit;">So können sie leicht von Klassennamen unterschieden werden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschleierung der Umsetzung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiterer Aspekt der Kapselung ist die Trennung von Schnittstelle und Implementierung. Wenn die Schnittstelle für die externen Teile des Programms zugänglich ist (außerhalb des Moduls oder der Klasse), ist die Implementierung ausgeblendet. In der Literatur wird häufig eine Black-Box-Analogie gezogen, wenn die interne Implementierung von außen „nicht sichtbar“ ist, aber was in den Eingang der Box eingespeist wird und was sie ausgibt, „sichtbar“ ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C werden Implementierungen innerhalb eines Moduls ausgeblendet, wobei Funktionen, die von außen nicht sichtbar sein sollten, mit dem Schlüsselwort static markiert werden. Die Prototypen der Funktionen, aus denen die Schnittstelle des Moduls besteht, werden in die Header-Datei eingefügt. Ein Modul in C bedeutet ein Paar: eine Quelldatei mit der Erweiterung * .c und einen Header mit der Erweiterung * .h.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java hat auch das statische Schlüsselwort, hat jedoch keinen Einfluss auf die „Sichtbarkeit“ der Methode oder des Felds von außen. </font><font style="vertical-align: inherit;">Um die "Sichtbarkeit" zu steuern, gibt es 3 Zugriffsmodifikatoren: privat, geschützt, öffentlich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Felder und Methoden einer als privat gekennzeichneten Klasse sind nur darin verfügbar. </font><font style="vertical-align: inherit;">Geschützte Felder und Methoden sind auch für Klassennachkommen zugänglich. </font><font style="vertical-align: inherit;">Der öffentliche Modifikator bedeutet, dass auf das markierte Element von außerhalb der Klasse zugegriffen werden kann, dh dass es Teil der Schnittstelle ist. </font><font style="vertical-align: inherit;">Es ist auch möglich, dass es keinen Modifikator gibt. In diesem Fall wird der Zugriff auf das Klassenelement durch das Paket eingeschränkt, in dem sich die Klasse befindet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird empfohlen, beim Schreiben einer Klasse zunächst alle Felder der Klasse als privat zu markieren und die Zugriffsrechte nach Bedarf zu erweitern.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methodenüberladung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine der nervigen Eigenschaften der C-Standardbibliothek ist das Vorhandensein eines ganzen Zoos von Funktionen, die im Wesentlichen dasselbe ausführen, sich jedoch in der Art des Arguments unterscheiden, zum Beispiel: fabs (), fabsf (), fabsl () - Funktionen zum Erhalten des Absolutwerts für double, float und long Doppeltypen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java (sowie C ++) unterstützt einen Methodenüberladungsmechanismus. Innerhalb einer Klasse gibt es möglicherweise mehrere Methoden mit einem völlig identischen Namen, die sich jedoch in Typ und Anzahl der Argumente unterscheiden. </font><font style="vertical-align: inherit;">Anhand der Anzahl der Argumente und ihres Typs wählt der Compiler die erforderliche Version der Methode selbst aus - dies ist sehr praktisch und verbessert die Lesbarkeit des Programms. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Java können Operatoren im Gegensatz zu C ++ nicht überladen werden. </font><font style="vertical-align: inherit;">Die Ausnahme bilden die Operatoren "+" und "+ =", die anfänglich für String-Strings überladen sind.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeichen und Zeichenfolgen in Java </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In C müssen Sie mit nullterminalen Zeichenfolgen arbeiten, die durch Zeiger auf das erste Zeichen dargestellt werden: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str; <span class="hljs-comment"><span class="hljs-comment">//  ASCII  wchar_t *strw; //   "" </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solche Zeilen müssen mit einem Nullzeichen enden. </font><font style="vertical-align: inherit;">Wenn es versehentlich "gelöscht" wird, wird eine Zeichenfolge als eine Folge von Bytes im Speicher bis zum ersten Nullzeichen betrachtet. </font><font style="vertical-align: inherit;">Das heißt, wenn andere Programmvariablen nach der Zeile im Speicher abgelegt werden, können (und werden höchstwahrscheinlich) ihre Werte nach dem Ändern einer solchen beschädigten Zeile verzerrt werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich ist ein C-Programmierer nicht verpflichtet, klassische Null-Terminal-Zeichenfolgen zu verwenden, sondern eine Drittanbieter-Implementierung anzuwenden. Hierbei ist jedoch zu beachten, dass für alle Funktionen aus der Standardbibliothek Null-Terminal-Zeichenfolgen als Argumente erforderlich sind. </font><font style="vertical-align: inherit;">Darüber hinaus definiert der C-Standard nicht die verwendete Codierung, dieser Punkt sollte auch vom Programmierer gesteuert werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Java repräsentiert der primitive Zeichentyp (sowie der Zeichen-Wrapper über die folgenden Wrapper) ein einzelnes Zeichen gemäß dem Unicode-Standard. Es wird jeweils eine UTF-16-Codierung verwendet. Ein Zeichen belegt 2 Byte im Speicher, sodass Sie fast alle Zeichen der derzeit verwendeten Sprachen codieren können. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichen können durch ihren Unicode angegeben werden:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch1 = <span class="hljs-string"><span class="hljs-string">'\u20BD'</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Unicode eines Zeichens das Maximum von 216 für char überschreitet, muss ein solches Zeichen durch int dargestellt werden. In der Zeichenfolge werden 2 Zeichen mit 16 Bit belegt, aber auch hier werden Zeichen mit einem Code von mehr als 216 äußerst selten verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java-Zeichenfolgen werden von der integrierten String-Klasse implementiert und speichern 16-Bit-Zeichen. Die String-Klasse enthält alle oder fast alles, was für die Arbeit mit Strings erforderlich sein kann. Es besteht keine Notwendigkeit, darüber nachzudenken, dass die Zeile notwendigerweise mit Null enden muss. Hier ist es unmöglich, dieses Null-Abschlusszeichen unmerklich zu "löschen" oder auf den Speicher jenseits der Zeile zuzugreifen. Bei der Arbeit mit Zeichenfolgen in Java denkt der Programmierer im Allgemeinen nicht darüber nach, wie die Zeichenfolge im Speicher gespeichert wird.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie oben erwähnt, erlaubt Java kein Überladen von Operatoren (wie in C ++), jedoch ist die String-Klasse eine Ausnahme - nur für sie werden die Zeilenzusammenführungsoperatoren "+" und "+ =" anfänglich überladen. </font></font><br><br><pre> <code class="java hljs">String str1 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span> + <span class="hljs-string"><span class="hljs-string">"World!"</span></span>; String str2 = <span class="hljs-string"><span class="hljs-string">"Hello, "</span></span>; str2 += <span class="hljs-string"><span class="hljs-string">"World!"</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist bemerkenswert, dass Zeichenfolgen in Java unveränderlich sind - einmal erstellt, erlauben sie ihre Änderung nicht. </font><font style="vertical-align: inherit;">Wenn wir beispielsweise versuchen, die Zeile wie folgt zu ändern:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; str.toUpperCase(); System.out.println(str); <span class="hljs-comment"><span class="hljs-comment">//   "Hello, World!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die ursprüngliche Zeichenfolge ändert sich also nicht wirklich. </font><font style="vertical-align: inherit;">Stattdessen wird eine geänderte Kopie der ursprünglichen Zeichenfolge erstellt, die wiederum unveränderlich ist:</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; String str2 = str.toUpperCase(); System.out.println(str2); <span class="hljs-comment"><span class="hljs-comment">//   "HELLO, WORLD!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somit führt jede Änderung einer Zeichenfolge in der Realität zur Erstellung eines neuen Objekts (tatsächlich kann der Compiler beim Zusammenführen von Zeilen den Code optimieren und die StringBuilder-Klasse verwenden, die später erläutert wird). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kommt vor, dass das Programm häufig dieselbe Zeile ändern muss. </font><font style="vertical-align: inherit;">In solchen Fällen können Sie die Optimierung neuer Zeilenobjekte verhindern, um die Geschwindigkeit des Programms und den Speicherverbrauch zu optimieren. </font><font style="vertical-align: inherit;">Für diese Zwecke sollte die StringBuilder-Klasse verwendet werden:</font></font><br><br><pre> <code class="java hljs">String sourceString = <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>; StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(sourceString); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.setCharAt(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>); builder.append(<span class="hljs-string"><span class="hljs-string">"!!"</span></span>); String changedString = builder.toString(); System.out.println(changedString); <span class="hljs-comment"><span class="hljs-comment">//   "Hell0, W0rld!!!"</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separat ist der Vergleich von Strings zu erwähnen. </font><font style="vertical-align: inherit;">Ein typischer Fehler eines unerfahrenen Java-Programmierers ist das Vergleichen von Zeichenfolgen mit dem Operator "==":</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    "Yes" // ! if (usersInput == "Yes") { //    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein solcher Code enthält formal keine Fehler in der Kompilierungsphase oder Laufzeitfehler, funktioniert jedoch anders als erwartet. </font><font style="vertical-align: inherit;">Da alle Objekte und Zeichenfolgen, einschließlich in Java, durch Links dargestellt werden, führt der Vergleich mit dem Operator "==" zu einem Vergleich von Links und nicht von Werten von Objekten. </font><font style="vertical-align: inherit;">Das heißt, das Ergebnis ist nur dann wahr, wenn 2 Links wirklich auf dieselbe Zeile verweisen. </font><font style="vertical-align: inherit;">Wenn es sich bei den Zeichenfolgen um unterschiedliche Objekte im Speicher handelt und Sie deren Inhalt vergleichen müssen, müssen Sie die Methode equals () verwenden:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (usersInput.equals(<span class="hljs-string"><span class="hljs-string">"Yes"</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Überraschendste ist, dass in einigen Fällen der Vergleich mit dem Operator „==“ korrekt funktioniert: </font></font><br><br><pre> <code class="java hljs">String someString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, anotherString = <span class="hljs-string"><span class="hljs-string">"abc"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   "true": System.out.println(someString == anotherString);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies liegt daran, dass sich someString und anotherString in Wirklichkeit auf dasselbe Objekt im Speicher beziehen. </font><font style="vertical-align: inherit;">Der Compiler platziert die gleichen String-Literale im String-Pool - die sogenannte Internierung erfolgt. </font><font style="vertical-align: inherit;">Jedes Mal, wenn dasselbe Zeichenfolgenliteral im Programm angezeigt wird, wird ein Link zur Zeichenfolge aus dem Pool verwendet. </font><font style="vertical-align: inherit;">Die Internierung von Saiten ist aufgrund der Eigenschaft der Unveränderlichkeit von Saiten genau möglich. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl das Vergleichen des Inhalts von Zeichenfolgen nur mit der Methode equals () zulässig ist, ist es in Java möglich, Zeichenfolgen in Switch-Case-Konstruktionen korrekt zu verwenden (beginnend mit Java 7):</font></font><br><br><pre> <code class="java hljs">String str = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(); <span class="hljs-comment"><span class="hljs-comment">// ... switch (str) { case "string_value_1": // ... break; case "string_value_2": // ... break; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seltsamerweise kann jedes Java-Objekt in eine Zeichenfolge konvertiert werden. </font><font style="vertical-align: inherit;">Die entsprechende toString () -Methode ist in der Basisklasse für alle Klassen der Object-Klasse definiert.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ansatz zur Fehlerbehandlung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie in C programmieren, haben Sie möglicherweise den folgenden Ansatz zur Fehlerbehandlung. Jede Funktion einer Bibliothek gibt einen int-Typ zurück. Wenn die Funktion erfolgreich ist, ist dieses Ergebnis 0. Wenn das Ergebnis ungleich Null ist, weist dies auf einen Fehler hin. Meistens wird der Fehlercode durch den von der Funktion zurückgegebenen Wert geleitet. Da die Funktion nur einen Wert zurückgeben kann und bereits vom Fehlercode belegt ist, muss das tatsächliche Ergebnis der Funktion über das Argument beispielsweise als Zeiger zurückgegeben werden:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct Data **result, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> errorCode; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist übrigens einer der Fälle, in denen in einem C-Programm ein Zeiger auf einen Zeiger verwendet werden muss. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manchmal verwenden sie einen anderen Ansatz. Die Funktion gibt keinen Fehlercode zurück, sondern direkt das Ergebnis ihrer Ausführung, normalerweise in Form eines Zeigers. Eine Fehlersituation wird mit einem Nullzeiger angezeigt. Dann enthält die Bibliothek normalerweise eine separate Funktion, die den Code des letzten Fehlers zurückgibt:</font></font><br><br><pre> <code class="java hljs">struct Data* function(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *arg); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLastError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf die eine oder andere Weise verschachteln sich beim Programmieren in C der Code, der die „nützliche“ Arbeit erledigt, und der Code, der für die Behandlung von Fehlern verantwortlich ist, gegenseitig, was das Programm offensichtlich nicht leicht lesbar macht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie möchten, können Sie in Java die oben beschriebenen Ansätze verwenden. Hier können Sie jedoch eine völlig andere Methode zum Umgang mit Fehlern anwenden - die Ausnahmebehandlung (jedoch wie in C ++). Der Vorteil der Ausnahmebehandlung besteht darin, dass in diesem Fall der „nützliche“ Code und der Code, der für die Behandlung von Fehlern und Eventualitäten verantwortlich ist, logisch voneinander getrennt sind. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies wird mithilfe von Try-Catch-Konstruktionen erreicht: Der „nützliche“ Code wird im Try-Abschnitt und der Fehlerbehandlungscode im Catch-Abschnitt platziert.</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//       try (FileReader reader = new FileReader("path\\to\\file.txt")) { //    -   . while (reader.read() != -1){ // ... } } catch (IOException ex) { //     }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt Situationen, in denen es nicht möglich ist, den Fehler am Ort seines Auftretens korrekt zu verarbeiten. </font><font style="vertical-align: inherit;">In solchen Fällen wird in der Methodensignatur angegeben, dass die Methode diese Art von Ausnahme verursachen kann:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt muss der Aufruf dieser Methode notwendigerweise in einem Try-Catch-Block eingerahmt sein, oder die aufrufende Methode muss auch markiert sein, damit sie diese Ausnahme auslösen kann. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fehlender Präprozessor </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unabhängig davon, wie bequem der Präprozessor ist, der C / C ++ - Programmierern vertraut ist, fehlt er in der Java-Sprache. </font><font style="vertical-align: inherit;">Java-Entwickler haben wahrscheinlich entschieden, dass es nur verwendet wird, um die Portabilität von Programmen sicherzustellen, und da Java (fast) überall ausgeführt wird, wird kein Präprozessor darin benötigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können das Fehlen eines Präprozessors mithilfe eines statischen Flagfelds kompensieren und gegebenenfalls dessen Wert im Programm überprüfen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir über die Organisation von Tests sprechen, ist es möglich, Anmerkungen in Verbindung mit Reflexion (Reflexion) zu verwenden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Array ist auch ein Objekt. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Arbeit mit Arrays in C ist der Indexausgang über die Grenzen des Arrays hinaus ein sehr heimtückischer Fehler. </font><font style="vertical-align: inherit;">Der Compiler meldet dies in keiner Weise und während der Ausführung wird das Programm nicht mit der entsprechenden Meldung gestoppt:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> array[<span class="hljs-number"><span class="hljs-number">5</span></span>]; array[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">666</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Höchstwahrscheinlich setzt das Programm die Ausführung fort, aber der Wert der Variablen, die sich im obigen Beispiel nach dem Array-Array befand, wird verzerrt. Das Debuggen dieser Art von Fehler ist möglicherweise nicht einfach. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Java ist der Programmierer vor solchen schwer zu diagnostizierenden Fehlern geschützt. Wenn Sie versuchen, die Grenzen des Arrays zu überschreiten, wird eine ArrayIndexOutOfBoundsException ausgelöst. Wenn der Ausnahmefang nicht mit dem Try-Catch-Konstrukt programmiert wurde, stürzt das Programm ab und eine entsprechende Nachricht wird an den Standardfehlerstrom gesendet, in der die Datei mit dem Quellcode und der Zeilennummer angegeben ist, in der das Array überschritten wurde. Das heißt, die Diagnose solcher Fehler wird zu einer trivialen Angelegenheit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Verhalten des Java-Programms wird ermöglicht, weil das Array in Java durch ein Objekt dargestellt wird. </font><font style="vertical-align: inherit;">Die Größe des Java-Arrays kann nicht geändert werden, da seine Größe zum Zeitpunkt der Speicherzuweisung fest codiert ist. </font><font style="vertical-align: inherit;">Zur Laufzeit ist das Abrufen der Größe des Arrays so einfach wie das Schälen von Birnen:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arraySize = array.length; <span class="hljs-comment"><span class="hljs-comment">// 10</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir über mehrdimensionale Arrays sprechen, bietet Java im Vergleich zur C-Sprache eine interessante Möglichkeit, "Ladder" -Arrays zu organisieren. </font><font style="vertical-align: inherit;">Für den Fall eines zweidimensionalen Arrays kann sich die Größe jeder einzelnen Zeile von den anderen unterscheiden:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[][] array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">10</span></span>][]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; array.length; i++) { array[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie in C befinden sich die Elemente des Arrays nacheinander im Speicher, sodass der Zugriff auf das Array als am effizientesten angesehen wird. Wenn Sie Einfüge- / Löschvorgänge für Elemente ausführen oder komplexere Datenstrukturen erstellen müssen, müssen Sie Sammlungen verwenden, z. B. einen Satz (Satz), eine Liste (Liste), eine Karte (Karte). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufgrund des Fehlens von Zeigern und der Unfähigkeit, Verknüpfungen zu erhöhen, ist der Zugriff auf die Elemente des Arrays mithilfe von Indizes möglich.</font></font><br><br><h2>  Sammlungen </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oft reicht die Funktionalität von Arrays nicht aus - dann müssen Sie dynamische Datenstrukturen verwenden. Da die Standard-C-Bibliothek keine vorgefertigte Implementierung dynamischer Datenstrukturen enthält, müssen Sie die Implementierung in Quellcodes oder in Form von Bibliotheken verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Gegensatz zu C enthält die Standard-Java-Bibliothek eine Vielzahl von Implementierungen dynamischer Datenstrukturen oder Sammlungen, ausgedrückt in Java. Alle Sammlungen sind in 3 große Klassen unterteilt: Listen, Sets und Karten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listen - dynamische Arrays - ermöglichen das Hinzufügen / Entfernen von Elementen. Viele stellen die Reihenfolge der hinzugefügten Elemente nicht sicher, garantieren jedoch, dass keine doppelten Elemente vorhanden sind. Karten oder assoziative Arrays arbeiten mit Schlüssel-Wert-Paaren, und der Schlüsselwert ist eindeutig - es dürfen nicht zwei Paare mit denselben Schlüsseln auf der Karte vorhanden sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für Listen, Mengen und Karten gibt es viele Implementierungen, von denen jede für eine bestimmte Operation optimiert ist. Beispielsweise werden Listen von den Klassen ArrayList und LinkedList implementiert, wobei ArrayList eine bessere Leistung beim Zugriff auf ein beliebiges Element bietet und LinkedList effizienter beim Einfügen / Löschen von Elementen in der Mitte der Liste ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Sammlungen können nur vollständige Java-Objekte gespeichert werden (Verweise auf Objekte). Daher ist es unmöglich, eine Sammlung von Grundelementen direkt zu erstellen (int, char, byte usw.). </font><font style="vertical-align: inherit;">In diesem Fall sollten die entsprechenden Wrapper-Klassen verwendet werden:</font></font><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Primitiv </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verpackungsklasse </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Byte </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Byte </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kurz </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurz </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> char </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Charakter </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> int </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ganzzahl </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lang </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lang </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> float </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Float </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doppelt </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Doppel </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boolescher Wert </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boolescher Wert </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glücklicherweise ist es beim Programmieren in Java nicht erforderlich, die genaue Übereinstimmung des primitiven Typs und seines "Wrappers" zu verfolgen. </font><font style="vertical-align: inherit;">Wenn die Methode beispielsweise ein Argument vom Typ Integer empfängt, kann ihr der Typ int übergeben werden. </font><font style="vertical-align: inherit;">Und umgekehrt, wo der Typ int erforderlich ist, können Sie Integer sicher verwenden. </font><font style="vertical-align: inherit;">Möglich wurde dies durch den in Java integrierten Mechanismus zum Packen / Entpacken von Grundelementen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von den unangenehmen Momenten sollte erwähnt werden, dass die Standard-Java-Bibliothek alte Auflistungsklassen enthält, die in den ersten Versionen von Java nicht erfolgreich implementiert wurden und nicht in neuen Programmen verwendet werden sollten. </font><font style="vertical-align: inherit;">Dies sind die Klassen Aufzählung, Vektor, Stapel, Wörterbuch, Hashtabelle, Eigenschaften.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verallgemeinerungen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sammlungen werden üblicherweise als generische Datentypen verwendet. </font><font style="vertical-align: inherit;">Das Wesentliche der Verallgemeinerungen in diesem Fall ist, dass wir den Haupttyp der Auflistung angeben, z. B. ArrayList, und in spitzen Klammern den Parametertyp angeben, der in diesem Fall den Typ der in der Liste gespeicherten Elemente bestimmt:</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf diese Weise kann der Compiler den Versuch verfolgen, ein Objekt eines anderen Typs als des angegebenen Typparameters hinzuzufügen: </font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  ! list.add("First");</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es ist sehr wichtig, dass der Typparameter während der Programmausführung gelöscht wird, und es gibt keinen Unterschied zwischen beispielsweise einem Objekt der Klasse </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;Integer&gt; </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Klassenobjekt </font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ArrayList &lt;String&gt;. </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daher gibt es keine Möglichkeit, den Typ der Sammlungselemente während der Programmausführung herauszufinden: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ! if (list instanceof List&lt;Integer&gt;) { return true; } return false; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eine Teillösung kann folgender Ansatz sein: Nehmen Sie das erste Element der Sammlung und bestimmen Sie dessen Typ: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsInteger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List list)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!list.isEmpty() &amp;&amp; list.get(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Integer) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Ansatz funktioniert jedoch nicht, wenn die Liste leer ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Hinsicht sind Java-Generalisierungen C ++ - Generalisierungen erheblich unterlegen. </font><font style="vertical-align: inherit;">Java-Verallgemeinerungen dienen tatsächlich dazu, einige der potenziellen Fehler in der Kompilierungsphase abzuschneiden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durchlaufen Sie alle Elemente eines Arrays oder einer Sammlung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beim Programmieren in C müssen Sie häufig alle Elemente des Arrays durchlaufen: </font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SIZE; i++) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um hier einen Fehler zu machen, ist es einfacher, einfach die falsche Größe des SIZE-Arrays anzugeben oder "&lt;=" anstelle von "&lt;" einzugeben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Java gibt es zusätzlich zur „üblichen“ Form der for-Anweisung ein Formular zum Durchlaufen aller Elemente eines Arrays oder einer Sammlung (in anderen Sprachen häufig foreach genannt):</font></font><br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// ... for (Integer i : list) { // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier wird garantiert, dass wir alle Elemente der Liste durchlaufen, wobei die Fehler, die der „üblichen“ Form der for-Anweisung inhärent sind, beseitigt werden. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verschiedene Sammlungen </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Da alle Objekte vom Stammobjekt geerbt werden, bietet Java eine interessante Möglichkeit, Listen mit verschiedenen tatsächlichen Elementtypen zu erstellen: </font></font><br><br><pre> <code class="java hljs">List list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"First"</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">2</span></span>)); list.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Double(<span class="hljs-number"><span class="hljs-number">3.0</span></span>));         <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Object o : list) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> String) { <span class="hljs-comment"><span class="hljs-comment">// ... } else if (o instanceof Integer) { // ... } else if (o instanceof Double) { // ... } }</span></span></code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transfers </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Vergleich von C / C ++ und Java ist es unmöglich, nicht zu bemerken, wie viel mehr funktionale Aufzählungen in Java implementiert sind. </font><font style="vertical-align: inherit;">Hier ist die Aufzählung eine vollwertige Klasse, und Aufzählungselemente sind Objekte dieser Klasse. </font><font style="vertical-align: inherit;">Auf diese Weise kann ein Aufzählungselement mehrere Felder eines beliebigen Typs in Korrespondenz setzen:</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Colors { <span class="hljs-comment"><span class="hljs-comment">//     -   . RED ((byte)0xFF, (byte)0x00, (byte)0x00), GREEN ((byte)0x00, (byte)0xFF, (byte)0x00), BLUE ((byte)0x00, (byte)0x00, (byte)0xFF), WHITE ((byte)0xFF, (byte)0xFF, (byte)0xFF), BLACK ((byte)0x00, (byte)0x00, (byte)0x00); //  . private byte r, g, b; //  . private Colors(byte r, byte g, byte b) { this.r = r; this.g = g; this.b = b; } //  . public double getLuma() { return 0.2126 * r + 0.7152 * g + 0.0722 * b; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als vollwertige Klasse kann eine Aufzählung Methoden haben, und mit einem privaten Konstruktor können Sie die Feldwerte einzelner Aufzählungselemente festlegen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es besteht die regelmäßige Möglichkeit, eine Zeichenfolgendarstellung eines Aufzählungselements, eine Seriennummer sowie ein Array aller Elemente abzurufen:</font></font><br><br><pre> <code class="java hljs">Colors color = Colors.BLACK; String str = color.toString(); <span class="hljs-comment"><span class="hljs-comment">// "BLACK" int i = color.ordinal(); // 4 Colors[] array = Colors.values(); // [RED, GREEN, BLUE, WHITE, BLACK]</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und umgekehrt - durch die Zeichenfolgendarstellung können Sie ein Aufzählungselement erhalten und auch seine Methoden aufrufen: </font></font><br><br><pre> <code class="java hljs">Colors red = Colors.valueOf(<span class="hljs-string"><span class="hljs-string">"RED"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Colors.RED Double redLuma = red.getLuma(); // 0.2126 * 255</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Natürlich können Aufzählungen in Switch-Case-Konstrukten verwendet werden. </font></font><br><br><h2>  Schlussfolgerungen </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natürlich sind die Sprachen C und Java darauf ausgelegt, völlig unterschiedliche Probleme zu lösen. Wenn wir jedoch den Softwareentwicklungsprozess in diesen beiden Sprachen vergleichen, übertrifft die Java-Sprache nach den subjektiven Eindrücken des Autors C in Bezug auf die Bequemlichkeit und Geschwindigkeit des Schreibens von Programmen erheblich. Die Entwicklungsumgebung (IDE) spielt eine wichtige Rolle bei der Bereitstellung von Komfort. Der Autor arbeitete mit der IntelliJ IDEA IDE. Wenn Sie in Java programmieren, müssen Sie nicht ständig Angst haben, einen Fehler zu machen. Oft sagt Ihnen die Entwicklungsumgebung, was behoben werden muss, und manchmal erledigt sie dies für Sie. Wenn ein Laufzeitfehler aufgetreten ist, werden die Art des Fehlers und der Ort seines Auftretens im Quellcode immer im Protokoll angegeben - der Kampf gegen solche Fehler wird zu einer trivialen Angelegenheit. Ein C-Programmierer muss keine unmenschlichen Anstrengungen unternehmen, um zu Java zu wechseln, und das alles, weil sich die Syntax der Sprache geringfügig geändert hat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn diese Erfahrung für Leser interessant sein wird, werden wir im nächsten Artikel über die Erfahrung mit der Verwendung des JNI-Mechanismus (Ausführen von nativem C / C ++ - Code aus einer Java-Anwendung) sprechen. </font><font style="vertical-align: inherit;">Der JNI-Mechanismus ist unverzichtbar, wenn Sie die Bildschirmauflösung und das Bluetooth-Modul steuern möchten, und in anderen Fällen, wenn die Funktionen von Android-Diensten und -Managern nicht ausreichen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412775/">https://habr.com/ru/post/de412775/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412763/index.html">Verwenden des Firefly-RK3288-Reload-Boards mit dem RockChip RK3288-SoC Mikrochip Digitaler I2C-Wärmesensor - MCP9808</a></li>
<li><a href="../de412765/index.html">Einführung in das neue Unity-Kachelkartensystem</a></li>
<li><a href="../de412767/index.html">CMG Impact 2016 Konferenzrückblick</a></li>
<li><a href="../de412769/index.html">Ich habe PWA gemacht und es in drei App Stores gestellt. Und hier ist, was ich herausgefunden habe</a></li>
<li><a href="../de412773/index.html">Minsk Astro-Luft- und Raumfahrt</a></li>
<li><a href="../de412777/index.html">Meisterwerke der Weltsäulenkonstruktion: QUAD 11L - die besten „Regale“ des zweitausendsten</a></li>
<li><a href="../de412779/index.html">SSLH: Verstecken Sie SSH / HTTPS / OpenVPN / Telegram hinter einem einzelnen Port 443</a></li>
<li><a href="../de412783/index.html">Installieren des MTProto Telegram-Proxys von der Quelle auf Centos 7</a></li>
<li><a href="../de412785/index.html">Master of Management und Freiberufler. Die Geschichte in drei Teilen</a></li>
<li><a href="../de412787/index.html">Einbetten von Git in ein Unternehmensentwicklungssystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>