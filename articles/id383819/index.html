<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèº üßíüèΩ ‚úä Membuat detektor logam pada ATtiny24A üßò üì§ üññüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya bermain dengan papan seperti Arduino untuk waktu yang lama, tetapi sepanjang waktu saya ingin "kurang, lebih murah dan lebih dekat ke perangkat k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat detektor logam pada ATtiny24A</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/383819/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya bermain dengan papan seperti Arduino untuk waktu yang lama, tetapi sepanjang waktu saya ingin "kurang, lebih murah dan lebih dekat ke perangkat keras!", Dan di sini adalah pengalaman pertama pemrograman ATtiny murni. </font><font style="vertical-align: inherit;">Artikel ini tidak akan menjadi beberapa rangkaian detektor logam yang sangat efektif. </font><font style="vertical-align: inherit;">Ini hanya demonstrasi dari apa yang mampu dilakukan mikrokontroler selama 47 sen + jalur ketel dalam hal ini, ternyata, sama sekali bukan masalah yang sulit untuk beralih dari Arduino ke tingkat yang lebih rendah.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemilihan besi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah analisis singkat, pilihan jatuh pada ATtiny24A-SSU (paket SOIC 14-pin). Mengapa? Alasannya sederhana: harga + inti AVR. Ya, saya tahu bahwa STM8S103F3P6 yang lebih kuat lebih murah ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">39,5 sen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dibandingkan dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">47 untuk ATtiny</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), tetapi memiliki pengalaman dengan AVR di Arduino, saya ingin AVR untuk percobaan pertama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari AVR yang tersedia, kami memilih ATtiny sebagai yang termurah, dan kemudian saya ingin paket DIP lebih mudah disolder. Tetapi chip dalam paket DIP ternyata jauh lebih mahal ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">54 sen untuk ATtiny13A 8 kaki</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATtiny23A 14 kaki dalam paket DIP adalah 95 sen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Saya tidak suka gagasan menggunakan ATtiny13A karena guritanya. 6 kaki akan ditempati oleh programmer dan hanya 2 yang tetap gratis, yang tidak cukup.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diputuskan untuk membeli ATtiny24A-SSU seharga 47 sen dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lain </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">seharga 30 sen</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Secara total, kami mendapatkan 77 sen per perangkat versus 95 untuk paket DIP dan, sebagai bonus, dalam perangkat sederhana menggunakan adaptor sebagai papan dengan kabel solder langsung ke sana, yang tidak mungkin dilakukan dengan paket DIP. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Programmer dipilih oleh prinsip yang sama (termurah): </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USBasp seharga $ 1,86</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiba!</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya harus segera mengatakan bahwa saya tidak pernah menyolder kasus SOIC sebelumnya, jadi ada kekhawatiran bahwa itu tidak akan berhasil ... Ternyata tidak sulit, tidak mudah ... secara umum, saya harus melakukan beberapa upaya, tetapi pada akhirnya ternyata! </font><font style="vertical-align: inherit;">Tampaknya disarankan untuk melakukan pemanasan bukan dengan satu kesimpulan, tetapi langsung dengan kelompok - cara ini lebih cepat dan mudah.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/78b/4f2/1e9/78b4f21e967344348ffb2130de618ff5.JPG" alt="gambar"></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana cara memprogram?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ATtiny24A secara default clock dari generator internal dan beroperasi pada frekuensi 1 MHz. Yah, biarkan itu bekerja, itu cocok untukku. Tetapi agar USBasp dapat bekerja dengannya pada frekuensi seperti itu, ia harus menyolder jumper tambahan (posting di foto): Ada </font><font style="vertical-align: inherit;">
tempat di papan tulis, tetapi orang Cina tidak repot-repot menyolder jumper ... mereka harus melakukannya untuk mereka. </font><font style="vertical-align: inherit;">
Dalam hal lingkungan pengembangan, pilihan ada di Atmel Studio, tetapi itu tidak mendukung USBasp kami ... tetapi itu tidak masalah! Bahkan ketika memilih seorang programmer, direncanakan untuk memutakhirkannya ke AVR-Doper, yang kompatibel dengan STK500, yang berarti didukung oleh Atmel Studio kami. Secara umum, saya mem-flashnya berkali-kali dengan firmware berbeda, tetapi Atmel Studio tidak ingin melihatnya ... kesedihan ... pada akhirnya saya putus asa, mem-flash-nya kembali ke USBasp dan melakukannya dengan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">alat</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/2ed/bc9/af0/2edbc9af064a4278a47cd7e78c724f00.JPG" alt="gambar"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Setelah itu, saya berhasil mem-flash ATtiny saya, berkedip dengan LED dan menikmati betapa sedikit memori flash yang dibutuhkan dibandingkan dengan Arduino.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detektor logam</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan ketika saya mencoba-coba Arduino, saya membuat detektor logam yang bekerja pada prinsip gangguan resonansi. Sensitivitasnya mengerikan, tetapi prinsip operasinya sangat sederhana dan mudah diterapkan pada MK mana pun. Sinyal persegi panjang diterapkan pada rangkaian osilasi paralel melalui resistor pada frekuensi resonansi sirkuit ini. Ketika benda logam memasuki medan magnet koil, faktor kualitas sirkuit menurun, amplitudo sinyal yang diukur oleh ADC berkurang, perangkat menyenangkan kita secara visual dan akustik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Detektor memiliki 2 mode: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Cari resonansi rangkaian. Pada saat yang sama, ia mengirimkan sinyal persegi panjang dari frekuensi yang berbeda ke sirkuit dan mengingat frekuensi di mana amplitudo osilasi akan menjadi yang terbesar (kami juga ingat amplitudo terbesar ini).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Mode operasi. </font><font style="vertical-align: inherit;">Kami mengirim sinyal dengan frekuensi resonansi ke sirkuit dan membandingkan amplitudo dengan maksimum yang ada di mode pertama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rumit? </font><font style="vertical-align: inherit;">- Tidak! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haruskah saya mengambil banyak memori? </font><font style="vertical-align: inherit;">- Tidak! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah kita memiliki banyak memori (2 KB flash + 128 byte RAM)? </font><font style="vertical-align: inherit;">- Juga tidak! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah cocok? </font><font style="vertical-align: inherit;">Ayo coba - kita akan mencari tahu! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasilnya, bugar.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode firmware utama</font></font></b><div class="spoiler_text"><pre>#include &lt;avr/io.h&gt;<font></font>
#include &lt;avr/interrupt.h&gt;<font></font>
#include "mySerial.cpp"<font></font>
<font></font>
MySerial ms(&amp;PORTB, &amp;PINB, &amp;DDRB, 0, &amp;PORTB, &amp;PINB, &amp;DDRB, 1);<font></font>
<font></font>
volatile uint16_t maxAdc = 0; //    (    )<font></font>
volatile uint8_t dispMode = 0; // 0 -  , 1 -  <font></font>
volatile uint8_t flags0 = 0; // [0] - need setRes<font></font>
volatile uint16_t adcSource = 0;<font></font>
//volatile bool needADC = false;<font></font>
#define ADC_SOURCE_ARRAY_SIZE_POWER 5<font></font>
#define ADC_SOURCE_ARRAY_SIZE (1 &lt;&lt; ADC_SOURCE_ARRAY_SIZE_POWER)<font></font>
uint16_t adcSourceArray[ADC_SOURCE_ARRAY_SIZE];<font></font>
uint8_t adcSourceArrayLastWrited = 0;<font></font>
void showVal(void);<font></font>
<font></font>
ISR(ADC_vect){<font></font>
	//adcSourceArrayLastWrited++;<font></font>
	if(++adcSourceArrayLastWrited &gt;= ADC_SOURCE_ARRAY_SIZE)<font></font>
		adcSourceArrayLastWrited = 0;<font></font>
	adcSourceArray[adcSourceArrayLastWrited] = ADCL | (ADCH &lt;&lt; 8);<font></font>
	uint16_t adcSourceTmp = 0;<font></font>
	for(uint8_t i = 0; i &lt; ADC_SOURCE_ARRAY_SIZE; i++)<font></font>
		adcSourceTmp += adcSourceArray[adcSourceArrayLastWrited];<font></font>
	adcSource = (adcSourceTmp &gt;&gt; ADC_SOURCE_ARRAY_SIZE_POWER);<font></font>
	//adcSource = ADCL | (ADCH &lt;&lt; 8);<font></font>
	//needADC = false;<font></font>
}<font></font>
<font></font>
volatile uint8_t pinaChanged = 0;<font></font>
volatile uint8_t tim0_ovf_counter = 0;<font></font>
//uint32_t ticks = 0;<font></font>
volatile uint16_t ticks10ms = 0;<font></font>
//volatile uint16_t ticks = 0;<font></font>
ISR(TIM0_OVF_vect)<font></font>
{		<font></font>
	//ticks++;<font></font>
	//if(255 == tim0_ovf_counter++){ // ticks every 65.5 ms<font></font>
	if(39 == (tim0_ovf_counter++)){ // ticks every 10 ms<font></font>
		tim0_ovf_counter = 0;<font></font>
		ticks10ms++;<font></font>
		if(pinaChanged &gt; 0)<font></font>
			pinaChanged--;<font></font>
	}<font></font>
}<font></font>
<font></font>
uint16_t dist16(uint16_t lo, uint16_t hi){<font></font>
	return (lo &lt;= hi) ? (hi - lo) : (0xFFFF - lo + hi);<font></font>
}<font></font>
/*void delayTicks(uint16_t val){<font></font>
	uint16_t tim0_ovf_counter0 = tim0_ovf_counter;<font></font>
	while(dist16(tim0_ovf_counter0, tim0_ovf_counter) &lt; val)<font></font>
		showVal();<font></font>
}*/<font></font>
void delay10ms(uint16_t val){<font></font>
	uint16_t ticks10ms0 = ticks10ms;<font></font>
	while(dist16(ticks10ms0, ticks10ms) &lt; val)<font></font>
		showVal();<font></font>
}<font></font>
<font></font>
void showVal(void){<font></font>
	ms.sendByte(adcSource &gt;&gt; 2);<font></font>
	switch(dispMode){<font></font>
		case 0:<font></font>
			OCR0A = adcSource &gt;&gt; 2;<font></font>
		break;<font></font>
		case 1:<font></font>
			uint16_t maxAdcPlus = maxAdc + 2;<font></font>
			uint16_t dispVal = (maxAdcPlus &gt; adcSource) ? ((maxAdcPlus - adcSource)) : 0;<font></font>
			dispVal &lt;&lt;= 4;<font></font>
			if(dispVal &gt; 255)<font></font>
				dispVal = 255;<font></font>
			OCR0A = dispVal;<font></font>
		break;<font></font>
	}<font></font>
}<font></font>
<font></font>
void setRes(void)<font></font>
{<font></font>
	dispMode = 0;<font></font>
	uint16_t maxOCR = 0;<font></font>
	maxAdc = 0;<font></font>
	for(uint16_t curOCR = 35; curOCR &lt; 50; curOCR++){<font></font>
		OCR1A = curOCR;<font></font>
		OCR1B = (curOCR &gt;&gt; 1);<font></font>
		//uint32_t ticks0 = ticks;<font></font>
		//uint16_t ticks0 = ticks;		<font></font>
		//while(dist16(ticks0, ticks) &lt; 20)<font></font>
		//	showVal();<font></font>
		delay10ms(30);<font></font>
		if(adcSource &gt; maxAdc){<font></font>
			maxAdc = adcSource;<font></font>
			maxOCR = curOCR;<font></font>
		}<font></font>
	}<font></font>
	OCR1A = maxOCR;<font></font>
	OCR1B = (maxOCR &gt;&gt; 1);<font></font>
	dispMode = 1;<font></font>
}<font></font>
<font></font>
ISR(PCINT0_vect)<font></font>
{	<font></font>
	if(pinaChanged &gt; 0)<font></font>
		return;<font></font>
	pinaChanged = 5;<font></font>
	if(0 == (PINA &amp; (1 &lt;&lt; 7)))<font></font>
		flags0 |= 1;<font></font>
}<font></font>
<font></font>
<font></font>
int main(void)<font></font>
{<font></font>
	// init PWM:<font></font>
	DDRB |= 4;  // OC0A as output<font></font>
	//TIMSK0 |= 7; //  TIM0_OVF_vect, TIM0_COMPA_vect, TIM0_COMPB_vect<font></font>
	TIMSK0 |= 1; //  TIM0_OVF_vect<font></font>
	TCCR0B |= 1; // no prescaling. OVF  256  (3.91 )<font></font>
	//TCCR0B |= 2; // clk/8<font></font>
	//TCCR0B |= 3; // clk/64<font></font>
	//TCCR0B |= 5; // clk/1024. OVF  262  (3.815 )<font></font>
	TCCR0A |= (3 | (1 &lt;&lt; 7)); //WGM0[2:0] = 3 - fawt PWM mode. bit7 -  <font></font>
	//OCR0A = 150;<font></font>
	//OCR0B = 100;<font></font>
	// :init PWM<font></font>
	<font></font>
	// init ADC:<font></font>
	//ADMUX |= (1 &lt;&lt; 7); // internal 1.1V reference. Comment this to use VCC as reference<font></font>
	//ADMUX |= (1 &lt;&lt; 3) | 1; // MUX[5:0] = 001001. Res = ADC0 - ADC1. Gain = 20<font></font>
	ADMUX |= (1 &lt;&lt; 3); // MUX[5:0] = 001000. Res = ADC0 - ADC1. Gain = 1<font></font>
	ADCSRA |= ((1 &lt;&lt; 7) // enable ADC<font></font>
		| (1 &lt;&lt; 5) // ADC Auto Trigger Enable.  <font></font>
		| (1 &lt;&lt; 6) //  1 <font></font>
		| (1 &lt;&lt; 3)   // ADC interrupt enable<font></font>
		| (1 &lt;&lt; 2)); // prescaller = 16 ( 50-200 kHz)<font></font>
	// :init ADC<font></font>
	<font></font>
	// init 16-bit timer: // pin7 = MOSI = PA6 = OC1A<font></font>
	//DDRA |= (1 &lt;&lt; 6); // OC1A as output<font></font>
	DDRA |= (1 &lt;&lt; 5); // OC1B as output<font></font>
	//TCCR1A |= (1 &lt;&lt; 6); // Toggle OC1A/OC1B on Compare Match<font></font>
	TCCR1A |= (1 &lt;&lt; 5) // Clear OC1B on Compare Match, set OC1B at BOTTOM (non-inverting mode)<font></font>
		| (3); // set WGM10 and WGM11 // WGM1[3:0] = 1111 - Fast PWM, TOP = OCR1A.	<font></font>
//	TCCR1A |= (1 &lt;&lt; 6) | (1 &lt;&lt; 7) // Set OC1A on Compare Match (Set output to high level).<font></font>
//			| (1 &lt;&lt; 5); // Clear OC1B on Compare Match	(Set output to low level)<font></font>
	TCCR1B |= 1 // no prescalling<font></font>
			| (1 &lt;&lt; 3) | (1 &lt;&lt; 4); // set WGM12 and WGM13<font></font>
	//TIMSK1 |= (1 &lt;&lt; 2) | (1 &lt;&lt; 1) | 1; // enable all interrupts<font></font>
	OCR1B = 21;<font></font>
	OCR1A = 42;<font></font>
	//for(;;){;};<font></font>
	// :init 16-bit timer<font></font>
	<font></font>
	// init button:<font></font>
	PORTA |= (1 &lt;&lt; 7); //     6- . PA7 = PCINT7<font></font>
	GIMSK |= (1 &lt;&lt; 4); // Pin Change Interrupt Enable 0<font></font>
	PCMSK0 |= (1 &lt;&lt; 7); //   PCINT7<font></font>
	// :init button<font></font>
	<font></font>
	sei();<font></font>
	flags0 = 1; //   22       !<font></font>
	while(1){<font></font>
		showVal();<font></font>
		//ms.sendByte(0x99);<font></font>
		if(0 != (1 &amp; flags0)){<font></font>
			setRes();<font></font>
			flags0 &amp;= ~1;<font></font>
		}<font></font>
	}<font></font>
}<font></font>
</pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan mySerial.cpp</font></font></b><div class="spoiler_text"><pre>#include &lt;avr/io.h&gt;<font></font>
#include &lt;avr/interrupt.h&gt;<font></font>
<font></font>
class MySerial{<font></font>
	public:<font></font>
	volatile uint8_t *dataPort;<font></font>
	volatile uint8_t *dataPin;<font></font>
	volatile uint8_t *dataDDR;<font></font>
	volatile uint8_t *clockPort;<font></font>
	volatile uint8_t *clockPin;<font></font>
	volatile uint8_t *clockDDR;<font></font>
	uint8_t dataPinMask, clockPinMask;<font></font>
	uint8_t rBit,<font></font>
		lastState, // (dataPin &lt;&lt; 1) | clockPin<font></font>
		inData;<font></font>
	// MySerial ms(&amp;PORTD, &amp;PIND, &amp;DDRD, 2, &amp;PORTD, &amp;PIND, &amp;DDRD, 3);<font></font>
	MySerial(<font></font>
		volatile uint8_t *_dataPort,<font></font>
		volatile uint8_t *_dataPin,<font></font>
		volatile uint8_t *_dataDDR,<font></font>
		uint8_t _dataPinN,<font></font>
		volatile uint8_t *_clockPort,<font></font>
		volatile uint8_t *_clockPin,<font></font>
		volatile uint8_t *_clockDDR,<font></font>
		uint8_t _clockPinN<font></font>
	){<font></font>
		rBit = 255;<font></font>
		lastState = 3;<font></font>
		inData = 0;<font></font>
		dataPort = _dataPort;<font></font>
		dataPin = _dataPin;<font></font>
		dataDDR = _dataDDR;<font></font>
		dataPinMask = (1 &lt;&lt; _dataPinN);<font></font>
		clockPort = _clockPort;<font></font>
		clockPin = _clockPin;<font></font>
		clockDDR = _clockDDR;<font></font>
		clockPinMask = (1 &lt;&lt; _clockPinN);<font></font>
	}<font></font>
	void dataZero() {<font></font>
		*dataPort &amp;= ~dataPinMask; //digitalWrite(pinData, 0);<font></font>
		*dataDDR |= dataPinMask;   //pinMode(pinData, OUTPUT);<font></font>
	}<font></font>
	void dataRelease() {<font></font>
		*dataDDR &amp;= ~dataPinMask; //pinMode(pinData, INPUT);<font></font>
		*dataPort |= dataPinMask; //digitalWrite(pinData, 1);<font></font>
	}<font></font>
	void clockZero() {<font></font>
		*clockPort &amp;= ~clockPinMask; //digitalWrite(pinClock, 0);<font></font>
		*clockDDR |= clockPinMask;  //pinMode(pinClock, OUTPUT);<font></font>
	}<font></font>
	void clockRelease() {<font></font>
		*clockDDR &amp;= ~clockPinMask; //pinMode(pinClock, INPUT);<font></font>
		*clockPort |= clockPinMask; //digitalWrite(pinClock, 1);<font></font>
	}<font></font>
	void pause() {<font></font>
		//delay(v * 1);<font></font>
		//unsigned long time = micros();<font></font>
		//while(v-- &gt; 0)<font></font>
		for(uint16_t i = 0; i &lt; 250; i++)<font></font>
			__asm__ __volatile__(<font></font>
				"nop"<font></font>
			);<font></font>
		//time = micros() - time;<font></font>
		//LOG("Paused "); LOG(time); LOGLN("us");<font></font>
	}<font></font>
	void sendByte(uint8_t data){<font></font>
		//LOG("Sending byte: "); LOGLN(data);<font></font>
		//   data  clock = 1:<font></font>
		dataRelease();<font></font>
		clockRelease();<font></font>
		pause();<font></font>
		dataZero();<font></font>
		pause();<font></font>
		<font></font>
		//LOGLN("Going to loop...");<font></font>
		for(uint8_t i = 0; i &lt; 8; i++){<font></font>
			clockZero();<font></font>
			pause();<font></font>
			if( 0 == (data &amp; (1 &lt;&lt; 7)) )<font></font>
				dataZero();<font></font>
			else<font></font>
				dataRelease();<font></font>
			//LOG("Sending bit "); LOGLN((data &amp; (1 &lt;&lt; 7)));<font></font>
			pause();<font></font>
			clockRelease();<font></font>
			pause();<font></font>
<font></font>
			data = data &lt;&lt; 1;<font></font>
		}<font></font>
		<font></font>
		//   data  clock = 1:<font></font>
		dataZero();<font></font>
		pause();<font></font>
		dataRelease();<font></font>
		pause();<font></font>
	}	<font></font>
	void tick(){<font></font>
		//uint8_t curState = (digitalRead(pinData) &lt;&lt; 1) | digitalRead(pinClock);<font></font>
		dataRelease();<font></font>
		clockRelease();<font></font>
		uint8_t curState = 0;<font></font>
		if(0 != (*dataPin &amp; dataPinMask))<font></font>
			curState |= 2;<font></font>
		if(0 != (*clockPin &amp; clockPinMask))<font></font>
			curState |= 1;<font></font>
<font></font>
		//LOGLN(curState);<font></font>
		if((3 == lastState) &amp;&amp; (1 == curState)) //  <font></font>
		rBit = 7;<font></font>
		if(255 != rBit)<font></font>
		if( (0 == (lastState &amp; 1)) &amp;&amp; (1 == (curState &amp; 1)) ) { //    clock<font></font>
			//LOG("Getted bit "); LOGLN((curState &gt;&gt; 1));<font></font>
			if( 0 == (curState &gt;&gt; 1) )<font></font>
				inData &amp;= ~(1 &lt;&lt; rBit);<font></font>
			else<font></font>
				inData |= (1 &lt;&lt; rBit);<font></font>
			rBit--;<font></font>
		}<font></font>
		<font></font>
		if( (1 == lastState) &amp;&amp; (3 == curState) ){ //  <font></font>
			//LOG("Recieved byte: "); LOGLN(inData);<font></font>
			rBit = 255;<font></font>
			//delay(5000);<font></font>
		}<font></font>
		lastState = curState;<font></font>
	}<font></font>
};<font></font>
</pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan tidak hanya itu yang pas, sehingga hanya dibutuhkan 1044 bytes dalam flash dari 2048 yang tersedia! </font><font style="vertical-align: inherit;">Dan ini terlepas dari fakta bahwa selain fungsi utama, ia juga mengirimkan informasi debug (MySerial)! </font><font style="vertical-align: inherit;">
Saya akan menjelaskan sedikit mengapa di sini (dari kiri ke kanan):</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/091/e65/170/091e651703154a0ca3ec7abe8e6fa678.JPG" alt="gambar"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gulungan kawat adalah gulungan sensitif detektor logam;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tombol di sebelah kiri papan tempat memotong roti - memanggil fungsi deteksi resonansi;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dioda + resistor + kapasitor adalah detektor amplitudo;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Green shawl - adapter dengan ATtiny24A di atasnya;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED dengan resistor dan kotak hitam besar (ini adalah microammeter kuno) - Indikasi PWM;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arduino Nano dihubungkan oleh dua kabel - penerima untuk informasi debug.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Skema:</font></font><br>
<img src="https://habrastorage.org/files/13b/2ef/e39/13b2efe390ef4b298e7600f056a4b856.png" alt="gambar"><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1, C1 - sirkuit berosilasi;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D1, C2, R2 - detektor amplitudo.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sensitivitas ternyata terlalu rendah untuk penggunaan praktis. </font><font style="vertical-align: inherit;">Bobot 0,5 kg dapat dirasakan dari 7 sentimeter, dan koin umumnya hanya jika dilemparkan ke dalam koil. </font><font style="vertical-align: inherit;">Namun, secara umum, perangkat berfungsi:</font></font><br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.youtube.com/embed/CW1kqXtIVEo%3Ffeature%3Doembed&amp;usg=ALkJrhjhO4oENK6rm1vqrXwUsKeK54giQg" frameborder="0" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rekaman menunjukkan bagaimana, ketika benda logam ditempatkan di koil, pembacaan ADC jatuh (di layar) dan MK meningkatkan arus melalui indikator.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa berikutnya?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tugas "bermain dengan ATtiny" telah selesai. </font><font style="vertical-align: inherit;">Semuanya berfungsi, semuanya baik-baik saja. </font><font style="vertical-align: inherit;">Penggaruk di jalan bahkan lebih kecil dari yang diharapkan. </font><font style="vertical-align: inherit;">Tetapi karena fakta yang ditunjukkan di awal (bahwa STM8S103F3P6 yang lebih kuat lebih murah), saya hanya melihat dua alasan untuk melakukan sesuatu pada AVR: kesederhanaan dan dokumentasi yang baik. </font><font style="vertical-align: inherit;">Yah, mungkin bahkan dua kali lipat dari arus keluaran maksimum yang diijinkan dalam beberapa kasus dapat menjadi argumen.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id383819/">https://habr.com/ru/post/id383819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id383805/index.html">Perusahaan mulai menawarkan panel surya transparan, bukan kaca</a></li>
<li><a href="../id383807/index.html">Bunker bawah tanah London sekarang tumbuh selada</a></li>
<li><a href="../id383811/index.html">Hari ini menandai 38 tahun sejak peluncuran Voyager 1</a></li>
<li><a href="../id383815/index.html">Foto Silver ThinkPad Yoga 260 Eksklusif</a></li>
<li><a href="../id383817/index.html">Pencetakan 3D mengantarkan era baru dalam sejarah mainan</a></li>
<li><a href="../id383821/index.html">Suara definisi tinggi baru yang lama</a></li>
<li><a href="../id383823/index.html">Suara, desain, dan psikologi: Bagaimana restoran membuat pengunjung membayar lebih</a></li>
<li><a href="../id383829/index.html">Tes mesin lain untuk penguat SLS berat berhasil</a></li>
<li><a href="../id383831/index.html">Chrome telah mempelajari cara menipu pemblokir iklan</a></li>
<li><a href="../id383835/index.html">Lawrence Lessig mencalonkan diri sebagai presiden sementara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>