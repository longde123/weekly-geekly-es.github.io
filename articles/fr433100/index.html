<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🏫 🥒 👴🏽 Travailler avec une base de données depuis une application 🕵️ 🤳🏾 💤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au début, je décrirai certains problèmes et fonctionnalités lors de l'utilisation de la base de données, je montrerai des trous dans les abstractions....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Travailler avec une base de données depuis une application</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433100/"><p>  Au début, je décrirai certains problèmes et fonctionnalités lors de l'utilisation de la base de données, je montrerai des trous dans les abstractions.  Ensuite, nous analyserons une abstraction plus simple basée sur l'immunité. </p><br><p>  Le lecteur est censé être un peu familier avec les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">schémas</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Active Record</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Data Maper</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Identity Map</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Unit of Work</a> . </p><br><p>  Les problèmes et les solutions sont envisagés dans le contexte de projets suffisamment importants qui ne peuvent pas être jetés et réécrits rapidement. </p><a name="habracut"></a><br><h2 id="identity-map">  Carte d'identité </h2><br><p>  Le premier problème est le problème du maintien de l'identité.  L'identité est quelque chose qui identifie de manière unique une entité.  Dans la base de données, il s'agit de la clé primaire et en mémoire, du lien (pointeur).  C'est bien lorsque les liens pointent vers un seul objet. </p><br><p>  Pour les bibliothèques <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ruby ActiveRecord</a> , ce n'est pas le cas: </p><br><pre><code class="ruby hljs">post_a = Post.find <span class="hljs-number"><span class="hljs-number">1</span></span> post_b = Post.find <span class="hljs-number"><span class="hljs-number">1</span></span> post_a.object_id != post_b.object_id <span class="hljs-comment"><span class="hljs-comment"># true post_a.title = "foo" post_b.title != "foo" # true</span></span></code> </pre> <br><p>  C'est-à-dire  on obtient 2 références à 2 objets différents en mémoire. </p><br><p>  Ainsi, nous pouvons perdre des modifications si nous commençons par inadvertance à travailler avec la même entité, mais représentée par des objets différents. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hibernate</a> a une session, en fait un cache de premier niveau qui stocke le mappage d'un identifiant d'entité à un objet en mémoire.  Si nous demandons à nouveau la même entité, nous obtiendrons un lien vers un objet existant.  C'est-à-dire  Hibernate implémente le modèle de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">carte d'identité</a> . </p><br><h2 id="dolgie-tranzakcii">  Transactions longues </h2><br><p>  Mais que se passe-t-il si nous ne sélectionnons pas par identifiant?  Pour éviter que l'état des objets et l'état de la base de données ne soient désynchronisés, Hibernate <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vider</a> avant de demander une sélection. <br>  c'est-à-dire  vide les objets sales dans la base de données afin que la demande lise les données convenues. </p><br><p>  Cette approche vous oblige à garder la transaction de base de données ouverte pendant que la transaction commerciale est en cours. <br>  Si la transaction commerciale est longue, le processus responsable de la connexion dans la base de données elle-même est également inactif.  Par exemple, cela peut se produire si une transaction commerciale demande des données sur le réseau ou effectue des calculs complexes. </p><br><h2 id="n1">  N + 1 </h2><br><p>  Le plus gros «trou» dans l'abstraction ORM est peut-être le problème de requête N + 1. </p><br><p>  Exemple sur ruby ​​pour la bibliothèque ActiveRecord: </p><br><pre> <code class="ruby hljs">posts = Post.all <span class="hljs-comment"><span class="hljs-comment"># select * from posts posts.each do |post| like = post.likes.order(id: :desc).first # SELECT * FROM likes WHERE post_id = ? ORDER BY id DESC LIMIT 1 # ... end</span></span></code> </pre> <br><p>  ORM conduit le programmeur à l'idée qu'il travaille simplement avec des objets en mémoire.  Mais cela fonctionne avec un service disponible sur le réseau, et sur l'établissement de connexions et de transfert de données <br>  cela prend du temps.  Même si la requête est exécutée 50 ms, 20 requêtes seront exécutées pendant une seconde. </p><br><h2 id="dopolnitelnye-dannye">  Données supplémentaires </h2><br><p>  Dites pour éviter le problème N + 1 décrit ci-dessus, vous écrivez <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">demande</a> : </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> posts <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> likes <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> post_id = posts.id <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> likes.id <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> last_like <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br><p>  C'est-à-dire  en plus des attributs du post, tous les attributs du dernier like sont également sélectionnés.  À quelle entité ces données correspondent-elles?  Dans ce cas, vous pouvez renvoyer un couple de la poste et aimer, car  le résultat contient tous les attributs nécessaires. </p><br><p>  Mais que se passe-t-il si nous sélectionnons seulement une partie des champs, ou des champs sélectionnés qui ne sont pas dans le modèle, par exemple, le nombre de publications aiment?  Doivent-ils être mappés sur des entités?  Peut-être ne leur laisser que des données? </p><br><h2 id="state--identity">  État et identité </h2><br><p>  Considérez le code js: </p><br><pre> <code class="plaintext hljs">const alice = { id: 0, name: 'Alice' };</code> </pre> <br><p>  Ici, la référence à l'objet a reçu le nom d' <code>alice</code> .  Parce que  c'est une constante, alors il n'y a aucun moyen d'appeler Alice un autre objet.  Dans le même temps, l'objet lui-même est resté mutable. </p><br><p>  Par exemple, nous pouvons attribuer un identifiant existant: </p><br><pre> <code class="plaintext hljs">const bob = { id: 1, name: 'Bob' }; alice.id = bob.id;</code> </pre> <br><p>  Permettez-moi de vous rappeler qu'une entité a 2 identités: un lien et une clé primaire dans la base de données.  Et les constantes ne peuvent pas arrêter de créer Alice Bob, même après avoir enregistré. </p><br><p>  L'objet, le lien auquel nous avons appelé <code>alice</code> , remplit 2 fonctions: il modélise simultanément l'identité et l'état.  Un état est une valeur qui décrit une entité à un moment donné. </p><br><p>  Mais que se passe-t-il si nous séparons ces 2 responsabilités et utilisons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des structures immuables</a> pour l'État? </p><br><pre> <code class="plaintext hljs">function Ref(initialState, validator) { let state = initialState; this.deref = () =&gt; state; this.swap = (updater) =&gt; { const newState = updater(state); if (! validator(state, newState) ) throw "Invalid state"; state = newState; return newState; }; } const UserState = Immutable.Record({ id: null, name: '' }); const aliceState = new UserState({id: 0, name: 'Alice'}); const alice = new Ref( aliceState, (oldS, newS) =&gt; oldS.id === newS.id ); alice.swap( oldS =&gt; oldS.set('name', 'Queen Alice') ); alice.swap( oldS =&gt; oldS.set('id', 1) ); // BOOM!</code> </pre> <br><p>  <code>Ref</code> - un conteneur pour un état immuable, permettant son remplacement contrôlé.  <code>Ref</code> modèles de <code>Ref</code> identifient tout comme nous nommons des objets.  Nous appelons la Volga, mais à chaque instant, elle a un état immuable différent. </p><br><h2 id="storage">  Stockage </h2><br><p>  Considérez l'API suivante: </p><br><pre> <code class="plaintext hljs">storage.tx( t =&gt; { const alice = t.get(0); const bobState = new UserState({id: 1, name: 'Bob'}); const bob = t.create(bobState); alice.swap( oldS =&gt; oldS.update('friends', old =&gt; old.push(bob.deref.id)) ); });</code> </pre> <br><p>  <code>t.get</code> et <code>t.create</code> renvoient une instance de <code>Ref</code> . </p><br><p>  Nous ouvrons la transaction commerciale, trouvons Alice par son identifiant, créons Bob et indiquons qu'Alice considère Bob son ami. </p><br><p>  L'objet <code>t</code> contrôle la création de <code>ref</code> . </p><br><p>  <code>t</code> peut stocker en lui-même le mappage des identifiants d'entité à l'état <code>ref</code> les contenant.  C'est-à-dire  peut implémenter Identity Map.  Dans ce cas, <code>t</code> agit comme un cache; à la demande répétée d'Alice, il n'y aura pas de demande à la base de données. </p><br><p>  On peut se souvenir de l'état initial des entités afin de suivre à la fin de la transaction les changements qui doivent être écrits dans la base de données.  C'est-à-dire  peut mettre en œuvre l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">unité de travail</a> .  Ou, si le support d'observateur est ajouté à <code>Ref</code> , il devient possible de réinitialiser les modifications apportées à la base de données à chaque modification de <code>ref</code> .  Ce sont des approches optimistes et pessimistes pour fixer les changements. </p><br><p>  Avec une approche optimiste, vous devez suivre les versions d'état des entités. <br>  Lors de la modification de la base de données, nous devons nous souvenir de la version et lors de la validation des modifications, vérifier que la version de l'entité dans la base de données ne diffère pas de la version initiale.  Sinon, vous devez répéter la transaction commerciale.  Cette approche permet d'utiliser des opérations d'insertion et de suppression de groupe et des transactions de base de données très courtes, ce qui économise des ressources. </p><br><p>  Avec une approche pessimiste, une transaction de base de données est entièrement cohérente avec une transaction commerciale.  C'est-à-dire  nous sommes obligés de retirer la connexion du pool au moment de la conclusion de la transaction commerciale. </p><br><p>  L'API vous permet d'extraire des entités une par une, ce qui n'est pas très optimal.  Parce que  nous avons implémenté le modèle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Identity Map</a> , puis nous pouvons entrer la méthode de <code>preload</code> dans l'API: </p><br><pre> <code class="plaintext hljs">storage.tx( t =&gt; { t.preload([0, 1, 2, 3]); const alice = t.get(0); // from cache });</code> </pre> <br><h2 id="queries">  Requêtes </h2><br><p>  Si nous ne voulons pas de transactions longues, nous ne pouvons pas effectuer de sélections par une clé arbitraire, car  la mémoire peut contenir des objets sales et la sélection renverra un résultat inattendu. </p><br><p>  Nous pouvons utiliser Query et récupérer toutes les données (état) en dehors de la transaction et relire les données pendant la transaction. </p><br><pre> <code class="plaintext hljs">const aliceId = userQuery.findByEmail('alice@mail.com'); storage.tx( t =&gt; { const alice = t.getOne(aliceId); });</code> </pre> <br><p>  Il y a donc une division des responsabilités.  Pour les requêtes, nous pouvons utiliser des moteurs de recherche pour mettre à l'échelle la lecture à l'aide de répliques.  Et l'API de stockage fonctionne toujours avec le stockage principal (maître).  Naturellement, les répliques contiendront des données obsolètes, la relecture des données dans la transaction résout ce problème. </p><br><h2 id="commands">  Commandes </h2><br><p>  Il existe des situations où une opération peut être effectuée sans lire de données.  Par exemple, déduisez des frais mensuels des comptes de tous les clients.  Ou insérez et mettez à jour les données (upsert) en cas de conflit. </p><br><p>  En cas de problèmes de performances, le bundle de Storage and Query peut être remplacé par une telle commande. </p><br><h2 id="svyazi">  Les communications </h2><br><p>  Si les entités se réfèrent de manière aléatoire, il est difficile d'assurer la cohérence lors de leur modification.  Les relations tentent de simplifier, de rationaliser, d'abandonner inutiles. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les agrégats</a> sont un moyen d'organiser les relations.  Chaque agrégat a une entité racine et des entités imbriquées.  Toute entité externe ne peut se référer qu'à la racine de l'agrégat.  La racine garantit l'intégrité de l'ensemble de l'unité.  Une transaction ne peut pas franchir une frontière d'agrégation; en d'autres termes, l'ensemble de l'agrégat est impliqué dans la transaction. </p><br><p>  Un agrégat peut, par exemple, être composé du Carême (racine) et de ses traductions.  Ou l'Ordre et ses Positions. </p><br><p>  Notre API fonctionne avec des agrégats entiers.  Dans le même temps, l'intégrité référentielle entre les agrégats dépend de l'application.  L'API ne prend pas en charge le chargement paresseux des liens. <br>  Mais nous pouvons choisir la direction des relations.  Considérez la relation un à plusieurs Utilisateur - Publication.  Nous pouvons stocker l'ID utilisateur dans la publication, mais sera-t-il pratique?  Nous obtiendrons beaucoup plus d'informations si nous stockons un tableau d'identificateurs de publication dans l'utilisateur. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  J'ai souligné les problèmes lors de l'utilisation de la base de données, montré la possibilité d'utiliser l'immunité. <br>  Le format de l'article ne permet pas de révéler le sujet en détail. </p><br><p>  Si vous êtes intéressé par cette approche, alors faites attention à mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application de</a> livre à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partir de zéro</a> , qui décrit la création d'une application Web à partir de zéro en mettant l'accent sur l'architecture.  Il comprend SOLID, Clean Architecture, les modèles de travail avec la base de données.  Les exemples de code dans le livre et l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">application</a> elle-même sont écrits dans le langage Clojure, qui est imprégné des idées d'immunité et de la commodité du traitement des données. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr433100/">https://habr.com/ru/post/fr433100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr433088/index.html">Comment aimez-vous cela, Elon Musk: BMW et Porsche ont développé une recharge qui ajoute 100 km de voyage en 3 minutes</a></li>
<li><a href="../fr433090/index.html">Techniques d'indexation bitmap Oracle</a></li>
<li><a href="../fr433092/index.html">Modélisation CG de niveau 80: personnages photoréalistes réalistes dans Unreal</a></li>
<li><a href="../fr433094/index.html">Modélisation numérique dans une grande entreprise industrielle</a></li>
<li><a href="../fr433098/index.html">L'histoire de DDR3, SPD et des fabricants chinois originaux</a></li>
<li><a href="../fr433102/index.html">Pourquoi les scientifiques croient que la neuvième planète n'existe pas</a></li>
<li><a href="../fr433104/index.html">Le défi Foobar: le test secret de Google pour les développeurs</a></li>
<li><a href="../fr433106/index.html">SpaceX et la NASA réaffirment leurs intentions de lancer le premier lancement du navire Crew Dragon en janvier 2019</a></li>
<li><a href="../fr433108/index.html">ld -z code séparé</a></li>
<li><a href="../fr433114/index.html">Certification PMP: préparation aux examens de style banlieue</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>