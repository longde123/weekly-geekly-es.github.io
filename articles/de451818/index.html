<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏻 👩🏻‍⚖️ 👨🏾‍🤝‍👨🏼 Turm oder nicht Turm - das ist die Frage 🧛🏼 🏳️‍🌈 🈷️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anfang dieses Monats, am 3. Mai, wurde eine Hauptversion des „Managementsystems für verteilte Data Warehouses in Kubernetes“ angekündigt - Rook 1.0.0 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Turm oder nicht Turm - das ist die Frage</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/451818/"><img src="https://habrastorage.org/webt/pp/71/45/pp7145_00rhowbftvzhds-h7bkk.png"><br><br>  Anfang dieses Monats, am 3. Mai, wurde eine Hauptversion des „Managementsystems für verteilte Data Warehouses in Kubernetes“ angekündigt - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>Rook 1.0.0</b></a> .  Vor mehr als einem Jahr haben wir bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen</a> allgemeinen Überblick über Rook veröffentlicht.  Dann wurden wir gebeten, über die Erfahrungen mit seiner <b>praktischen Anwendung</b> zu sprechen - und jetzt, rechtzeitig für einen so bedeutenden Meilenstein in der Geschichte des Projekts, freuen wir uns, unsere gesammelten Eindrücke zu teilen. <br><br>  Kurz gesagt, Rook ist eine Gruppe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operatoren</a> für Kubernetes, die die vollständige Kontrolle über die Bereitstellung, Verwaltung und automatische Wiederherstellung von Speicherlösungen wie Ceph, EdgeFS, Minio, Cassandra und CockroachDB übernehmen. <a name="habracut"></a><br><br>  Derzeit ist der <a href="">Turm-Ceph-Operator</a> die am weitesten entwickelte (und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nur</a> in einem <b>stabilen</b> Stadium) Lösung. <br><br>  <i><b>Hinweis</b> : Unter den signifikanten Änderungen in der Version von Rook 1.0.0 in Bezug auf Ceph sind die Unterstützung von Ceph Nautilus und die Möglichkeit, NFS für CephFS- oder RGW-Buckets zu verwenden, zu vermerken.</i>  <i>Unter anderem fällt die "Reifung" der EdgeFS-Unterstützung auf Beta-Ebene auf.</i> <br><br>  Also, in diesem Artikel haben wir: <br><br><ul><li>  Beantworten Sie die Frage, welche Vorteile sich aus der Verwendung von Rook für die Bereitstellung von Ceph im Kubernetes-Cluster ergeben. </li><li>  Erfahrungen und Eindrücke über die Verwendung von Rook in der Produktion teilen; </li><li>  Wir werden Ihnen sagen, warum wir Rook und unseren Plänen für ihn "Ja" sagen. </li></ul><br>  Beginnen wir mit allgemeinen Konzepten und Theorien. <br><br><h2>  "Ich habe einen Vorteil in einem Turm!"  (unbekannter Schachspieler) </h2><br><img src="https://habrastorage.org/webt/qb/su/7j/qbsu7jt4qtrayeg5vg21-wilmrw.png"><br><br>  Einer der Hauptvorteile von Rook ist, dass die Interaktion mit Data Warehouses über Kubernetes-Mechanismen erfolgt.  Dies bedeutet, dass Sie die Befehle zum Konfigurieren von Ceph nicht mehr aus der Broschüre in die Konsole kopieren müssen. <br><br>  <i>- Möchten Sie in einem CephFS-Cluster bereitstellen?</i>  <i>Schreiben Sie einfach eine Yaml-Datei!</i> <i><br></i>  <i>- Was?</i>  <i>Möchten Sie einen Objektspeicher mit der S3-API bereitstellen?</i>  <i>Schreiben Sie einfach eine zweite Yaml-Datei!</i> <br><br>  Rook wird nach allen Regeln eines typischen Operators erstellt.  Die Interaktion damit erfolgt mithilfe von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CRD (Custom Resource Definitions)</a> , in denen wir die Merkmale der von uns benötigten Ceph-Entitäten beschreiben <i>(da dies die einzige stabile Implementierung ist, wird in dem Artikel standardmäßig über Ceph gesprochen, sofern nicht ausdrücklich anders angegeben)</i> .  Entsprechend den angegebenen Parametern führt der Bediener automatisch die zum Einrichten erforderlichen Befehle aus. <br><br>  Schauen wir uns die Besonderheiten am Beispiel des Erstellens eines Objektspeichers bzw. <code>CephObjectStoreUser</code> . <br><br><pre> <code class="plaintext hljs">apiVersion: ceph.rook.io/v1 kind: CephObjectStore metadata: name: {{ .Values.s3.crdName }} namespace: kube-rook spec: metadataPool: failureDomain: host replicated: size: 3 dataPool: failureDomain: host erasureCoded: dataChunks: 2 codingChunks: 1 gateway: type: s3 sslCertificateRef: port: 80 securePort: instances: 1 allNodes: false --- apiVersion: ceph.rook.io/v1 kind: CephObjectStoreUser metadata: name: {{ .Values.s3.crdName }} namespace: kube-rook spec: store: {{ .Values.s3.crdName }} displayName: {{ .Values.s3.username }}</code> </pre> <br>  Die in der Auflistung angegebenen Parameter sind ziemlich Standard und benötigen wahrscheinlich keine Kommentare. Sie sollten jedoch besonders auf diejenigen achten, die in den Vorlagenvariablen hervorgehoben sind. <br><br>  Das allgemeine Arbeitsschema beruht auf der Tatsache, dass wir über die YAML-Datei Ressourcen „bestellen“, für die der Bediener die erforderlichen Befehle ausführt und uns das „nicht echte“ Geheimnis zurückgibt, mit dem wir weiterarbeiten können <i>(siehe unten)</i> .  Und aus den oben angegebenen Variablen werden der Befehl und der Name des Geheimnisses zusammengesetzt. <br><br>  Was für ein Team ist das?  Wenn Sie einen Benutzer für die Objektspeicherung erstellen, führt die Rook-Anweisung im Pod Folgendes aus: <br><br><pre> <code class="plaintext hljs">radosgw-admin user create --uid="rook-user" --display-name="{{ .Values.s3.username }}"</code> </pre> <br>  Das Ergebnis dieses Befehls ist eine JSON-Struktur: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"rook-user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"display_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{ .Values.s3.username }}"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"keys"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"rook-user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"access_key"</span></span>: <span class="hljs-string"><span class="hljs-string">"NRWGT19TWMYOB1YDBV1Y"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"secret_key"</span></span>: <span class="hljs-string"><span class="hljs-string">"gr1VEGIV7rxcP3xvXDFCo4UDwwl2YoNrmtRlIAty"</span></span> } ], ... }</code> </pre> <br>  <code>Keys</code> sind das, was zukünftige Anwendungen benötigen, um über die S3-API auf den Objektspeicher zuzugreifen.  Der Rook-Operator wählt sie freundlicherweise aus und legt sie als Geheimnis mit dem Namen <code>rook-ceph-object-user-{{ $.Values.s3.crdName }}-{{ $.Values.s3.username }}</code> in seinem Namespace ab. <br><br>  Um Daten aus diesem Geheimnis zu verwenden, fügen Sie sie einfach als Umgebungsvariablen zum Container hinzu.  Als Beispiel gebe ich eine Vorlage für Job an, in der wir automatisch Buckets für jede Benutzerumgebung erstellen: <br><br><pre> <code class="plaintext hljs">{{- range $bucket := $.Values.s3.bucketNames }} apiVersion: batch/v1 kind: Job metadata: name: create-{{ $bucket }}-bucket-job annotations: "helm.sh/hook": post-install "helm.sh/hook-weight": "2" spec: template: metadata: name: create-{{ $bucket }}-bucket-job spec: restartPolicy: Never initContainers: - name: waitdns image: alpine:3.6 command: ["/bin/sh", "-c", "while ! getent ahostsv4 rook-ceph-rgw-{{ $.Values.s3.crdName }}; do sleep 1; done" ] - name: config image: rook/ceph:v1.0.0 command: ["/bin/sh", "-c"] args: ["s3cmd --configure --access_key=$(ACCESS-KEY) --secret_key=$(SECRET-KEY) -s --no-ssl --dump-config | tee /config/.s3cfg"] volumeMounts: - name: config mountPath: /config env: - name: ACCESS-KEY valueFrom: secretKeyRef: name: rook-ceph-object-user-{{ $.Values.s3.crdName }}-{{ $.Values.s3.username }} key: AccessKey - name: SECRET-KEY valueFrom: secretKeyRef: name: rook-ceph-object-user-{{ $.Values.s3.crdName }}-{{ $.Values.s3.username }} key: SecretKey containers: - name: create-bucket image: rook/ceph:v1.0.0 command: - "s3cmd" - "mb" - "--host=rook-ceph-rgw-{{ $.Values.s3.crdName }}" - "--host-bucket= " - "s3://{{ $bucket }}" ports: - name: s3-no-sll containerPort: 80 volumeMounts: - name: config mountPath: /root volumes: - name: config emptyDir: {} --- {{- end }}</code> </pre> <br>  Alle in diesem Job aufgeführten Aktivitäten wurden durchgeführt, ohne über Kubernetes hinauszugehen.  Die in den YAML-Dateien beschriebenen Strukturen werden in das Git-Repository gefaltet und wiederholt wiederverwendet.  Darin sehen wir ein großes Plus für die DevOps-Ingenieure und den gesamten CI / CD-Prozess. <br><br><h2>  Mit Turm und Rados zur Freude </h2><br>  Die Verwendung einer Reihe von Ceph + RBD unterwirft bestimmte Einschränkungen für das Mounten von Volumes an Pods. <br><br>  Insbesondere muss der Namespace ein Geheimnis haben, um auf Ceph zugreifen zu können, damit statusbehaftete Anwendungen funktionieren können.  Es ist in Ordnung, wenn Sie 2-3 Umgebungen in Ihren Namespaces haben: Sie können das Geheimnis manuell kopieren.  Was aber, wenn jede Entwicklerfunktion eine separate Umgebung mit einem eigenen Namespace erstellt? <br><br>  Wir haben dieses Problem mit Hilfe eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Shell-Operators</a> gelöst, der Geheimnisse automatisch in den neuen Namespace kopierte (ein Beispiel für einen solchen Hook wird in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel beschrieben</a> ). <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#! /bin/bash if [[ $1 == “--config” ]]; then cat &lt;&lt;EOF {"onKubernetesEvent":[ {"name": "OnNewNamespace", "kind": "namespace", "event": ["add"] } ]} EOF else NAMESPACE=$(kubectl get namespace -o json | jq '.items | max_by( .metadata.creationTimestamp ) | .metadata.name') kubectl -n ${CEPH_SECRET_NAMESPACE} get secret ${CEPH_SECRET_NAME} -o json | jq ".metadata.namespace=\"${NAMESPACE}\"" | kubectl apply -f - fi</span></span></code> </pre> <br>  Bei Verwendung von Rook besteht dieses Problem jedoch einfach nicht.  Der Montageprozess erfolgt mit Ihren eigenen Treibern, die auf <a href="">Flexvolume</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSI</a> basieren (noch in der Beta) und erfordert daher keine Geheimnisse. <br><br>  Rook löst automatisch viele Probleme, was uns ermutigt, es in neuen Projekten zu verwenden. <br><br><h2>  Belagerung des Turmes </h2><br>  Wir vervollständigen den praktischen Teil mit dem Einsatz von Rook und Ceph für die Möglichkeit, eigene Experimente durchzuführen.  Um diesen uneinnehmbaren Turm zu stürmen, war es einfacher, die Entwickler haben ein Helm-Paket vorbereitet.  Laden wir es herunter: <br><br><pre> <code class="bash hljs">$ helm fetch rook-master/rook-ceph --untar --version 1.0.0</code> </pre> <br>  In der Datei <code>rook-ceph/values.yaml</code> finden Sie viele verschiedene Einstellungen.  Geben Sie vor allem Toleranzen für Agenten und die Suche an.  Warum Sie den Mechanismus für Verschmutzungen / Toleranzen verwenden können, haben wir in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> ausführlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beschrieben</a> . <br><br>  Kurz gesagt, wir möchten nicht, dass sich Pods mit der Clientanwendung auf denselben Knoten befinden, auf denen sich die Datenträger für die Datenspeicherung befinden.  Der Grund ist einfach: Auf diese Weise wirkt sich die Arbeit der Rook-Agenten nicht auf die Anwendung selbst aus. <br><br>  Öffnen Sie also die Datei <code>rook-ceph/values.yaml</code> bevorzugten Editor und fügen Sie am Ende den folgenden Block hinzu: <br><br><pre> <code class="plaintext hljs">discover: toleration: NoExecute tolerationKey: node-role/storage agent: toleration: NoExecute tolerationKey: node-role/storage mountSecurityMode: Any</code> </pre> <br>  Fügen Sie für jeden für die Datenspeicherung reservierten Knoten den entsprechenden Makel hinzu: <br><br><pre> <code class="bash hljs">$ kubectl taint node <span class="hljs-variable"><span class="hljs-variable">${NODE_NAME}</span></span> node-role/storage=<span class="hljs-string"><span class="hljs-string">""</span></span>:NoExecute</code> </pre> <br>  Installieren Sie dann die Helmkarte mit dem Befehl: <br><br><pre> <code class="bash hljs">$ helm install --namespace <span class="hljs-variable"><span class="hljs-variable">${ROOK_NAMESPACE}</span></span> ./rook-ceph</code> </pre> <br>  Jetzt müssen Sie einen Cluster erstellen und den Speicherort des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OSD</a> angeben: <br><br><pre> <code class="plaintext hljs">apiVersion: ceph.rook.io/v1 kind: CephCluster metadata: clusterName: "ceph" finalizers: - cephcluster.ceph.rook.io generation: 1 name: rook-ceph spec: cephVersion: image: ceph/ceph:v13 dashboard: enabled: true dataDirHostPath: /var/lib/rook/osd mon: allowMultiplePerNode: false count: 3 network: hostNetwork: true rbdMirroring: workers: 1 placement: all: tolerations: - key: node-role/storage operator: Exists storage: useAllNodes: false useAllDevices: false config: osdsPerDevice: "1" storeType: filestore resources: limits: memory: "1024Mi" requests: memory: "1024Mi" nodes: - name: host-1 directories: - path: "/mnt/osd" - name: host-2 directories: - path: "/mnt/osd" - name: host-3 directories: - path: "/mnt/osd"</code> </pre> <br>  Überprüfen Sie den Ceph-Status - erwarten Sie <code>HEALTH_OK</code> : <br><br><pre> <code class="bash hljs">$ kubectl -n <span class="hljs-variable"><span class="hljs-variable">${ROOK_NAMESPACE}</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> $(kubectl -n <span class="hljs-variable"><span class="hljs-variable">${ROOK_NAMESPACE}</span></span> get pod -l app=rook-ceph-operator -o name -o jsonpath=<span class="hljs-string"><span class="hljs-string">'{.items[0].metadata.name}'</span></span>) -- ceph -s</code> </pre> <br>  Überprüfen Sie gleichzeitig, ob Pods mit der Clientanwendung nicht zu den für Ceph reservierten Knoten gelangen: <br><br><pre> <code class="bash hljs">$ kubectl -n <span class="hljs-variable"><span class="hljs-variable">${APPLICATION_NAMESPACE}</span></span> get pods -o custom-columns=NAME:.metadata.name,NODE:.spec.nodeName</code> </pre> <br>  Weitere optionale Komponenten sind konfiguriert.  Weitere Informationen dazu finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> .  Für die Verwaltung empfehlen wir dringend, das Dashboard und die Toolbox zu installieren. <br><br><h2>  Türme und Haken: Ist Turm genug für alles? </h2><br>  Wie Sie sehen können, ist die Entwicklung von Rook in vollem Gange.  Dennoch gibt es Probleme, die es uns nicht ermöglichen, die manuelle Konfiguration von Ceph vollständig aufzugeben: <br><br><ul><li>  Kein Rook-Treiber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann</a> Metriken zur Verwendung von montierten Blöcken exportieren, was uns die Überwachung entzieht. </li><li>  Flexvolume und CSI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wissen nicht, wie</a> die Größe von Volumes geändert werden soll (im Gegensatz zu derselben RBD), daher verliert Rook ein nützliches (und manchmal kritisch notwendiges!) Tool. </li><li>  Rook ist immer noch nicht so flexibel wie reguläres Ceph.  Wenn Sie den Pool für CephFS-Metadaten zum Speichern auf der SSD und die Daten selbst auf der Festplatte konfigurieren möchten, müssen Sie einzelne Gerätegruppen manuell in CRUSH-Maps registrieren. </li><li>  Trotz der Tatsache, dass der Turm-Ceph-Operator als stabil angesehen wird, gibt es derzeit bestimmte Probleme beim Aktualisieren von Ceph von Version 13 auf 14. </li></ul><br><h2>  Schlussfolgerungen </h2><br>  <i>"Jetzt ist Rook durch Bauern von der Außenwelt verschlossen, aber wir glauben, dass sie eines Tages eine entscheidende Rolle in der Partei spielen wird!"</i>  <i>(Ein Zitat wurde speziell für diesen Artikel erfunden)</i> <br><br>  Das Rook-Projekt hat zweifellos unsere Herzen erobert - wir glauben, dass es [mit all seinen Vor- und Nachteilen] definitiv Ihre Aufmerksamkeit verdient. <br><br>  Unsere weiteren Pläne bestehen darin, rook-ceph zu einem Modul für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Addon-Operatoren zu machen</a> , das die Verwendung in unseren vielen Kubernetes-Clustern noch einfacher und bequemer macht. <br><br><h2>  PS </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rook ist ein Self-Service-Data-Warehouse für Kubernetes</a> “. </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir schaffen dauerhaften Speicher mit Bereitstellung in Kubernetes basierend auf Ceph</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenbanken und Kubernetes (Überprüfung und Videobericht)</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einführung des Shell-Operators: Bediener für Kubernetes noch einfacher machen</a> “; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Operatoren für Kubernetes: So führen Sie Stateful-Anwendungen aus</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451818/">https://habr.com/ru/post/de451818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451802/index.html">Die .Net Community der Raiffeisenbank lädt zu UPD mitap Broadcast ein</a></li>
<li><a href="../de451806/index.html">iOS Digest Nr. 5 (27. April - 16. Mai)</a></li>
<li><a href="../de451812/index.html">Jetzt werden gute Entwickler an Ansichten und Abonnenten gemessen - und das ist schlecht</a></li>
<li><a href="../de451814/index.html">RBKmoney Zahlungen unter der Haube - Infrastruktur der Zahlungsplattform</a></li>
<li><a href="../de451816/index.html">Fuzzing im 2000er-Stil in modernen Windows 10-Anwendungen</a></li>
<li><a href="../de451820/index.html">Thematisches Habramitap # 1: Backend-Entwicklung</a></li>
<li><a href="../de451822/index.html">Mieten und engagieren: Beantworten Sie Fragen von zwei Seiten</a></li>
<li><a href="../de451826/index.html">Steigerung der Marketing-Absurdität: Bewährte Fälle</a></li>
<li><a href="../de451828/index.html">Das Hauptgeheimnis von Google I / O 2019, das im Internet nicht zu finden ist</a></li>
<li><a href="../de451830/index.html">Kurz mit der Umsetzung der AES 128 EZB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>