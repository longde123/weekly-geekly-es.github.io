<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∑üèº üë®üèΩ‚Äçüíª üßëüèø‚Äçü§ù‚Äçüßëüèº ¬øHaskell es realmente el lenguaje de los genios y la academia? üéÖüèø ‚úä üåÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una vez tuve una discusi√≥n con un fundador de una startup israel√≠ que desarrollaba una base de datos basada en GPU con un enfoque en la velocidad. La ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øHaskell es realmente el lenguaje de los genios y la academia?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441350/"><img src="https://habrastorage.org/webt/o6/qs/0d/o6qs0dg9mgydyepqfcn6kpobfnc.jpeg"><br><br>  Una vez tuve una discusi√≥n con un fundador de una startup israel√≠ que desarrollaba una base de datos basada en GPU con un enfoque en la velocidad.  La pila de trabajo inclu√≠a a Haskell y C ++, entre otros, y el fundador se quejaba de lo dif√≠cil que es encontrar programadores competentes.  Lo cual era parte de la raz√≥n por la que vino a Mosc√∫. <br><br>  Pregunt√© cuidadosamente si consideraban usar algo m√°s popular y nuevo.  Y aunque la respuesta fue bastante educada y bien apoyada con argumentos, todav√≠a sonaba como "Vamos, ni siquiera traigas estos juguetes". <br><br>  Hasta entonces, todo lo que escuch√© sobre Haskell podr√≠a resumirse como "ten MUY cuidado al tratarlo".  Para conocer mejor a los programadores de Haskell, llegu√© a un chat de Telegram con algunas preguntas.  Al principio ten√≠a bastante miedo, y result√≥ que ten√≠a raz√≥n. <br><br>  Haskell no se presta a la explicaci√≥n popular, y la gente aparentemente ni siquiera lo intenta.  Si alguna vez se menciona el tema, solo se habla en profundidad y de la manera m√°s objetiva posible.  Alguien me escribi√≥: ‚ÄúUna de las caracter√≠sticas definitorias tanto de Haskell como de su comunidad es que no intentaron lograr ning√∫n tipo de reconocimiento general.  En cambio, se centraron en construir una forma l√≥gica y principal de resolver problemas reales en lugar de tratar de apaciguar a la audiencia m√°s amplia posible " <br><br>  Sin embargo, un par de personas me contaron sobre sus experiencias, que se muestran a continuaci√≥n. <br><a name="habracut"></a><br>  <b>Denis Mirzoev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">nolane</a> )</b> : Cuando estaba en la universidad, me ofrecieron hacer un curso de Coursera en Haskell para obtener cr√©dito adicional.  Luego tambi√©n tuvimos un curso de programaci√≥n funcional que inclu√≠a a Haskell.  He escrito uno de mis trabajos finales, m√°s el trabajo de graduaci√≥n, sobre GHC.  Luego encontr√© un trabajo como programador de Haskell. <br><br>  Fue y sigue siendo dif√≠cil.  Cuando comienzas a aprender Haskell, tienes que meter muchos conceptos nuevos en tu mente.  Es como aprender a codificar desde cero de nuevo. <br><br>  Las personas tienden a olvidar (o suavizar) sus recuerdos anteriores: como cuando luchaban por comprender qu√© era un "puntero", una "funci√≥n" o una "clase".  Tal vez por eso es tan dif√≠cil para ellos aprender Haskell: cada vez es m√°s dif√≠cil aprender cosas nuevas con la edad. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Una vez que fall√© mi per√≠odo de prueba en un trabajo debido a un error de Redux, trat√© de sentirme un poco m√°s c√≥modo viendo videos de su creador.  Primero practiqu√© en JavaScript, pero luego aprend√≠ sobre Haskell, considerado el lenguaje funcional "verdadero".  Me fascinaron sus conceptos √∫nicos y lo ordenado que era. <br><br>  Sin embargo, los tutoriales no son demasiado f√°ciles de usar, adem√°s de que su fondo imperativo evita que surjan nuevos conceptos. <br><br>  <b>Yuri Syrovetskiy ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">cblp</a> )</b> : lo m√°s dif√≠cil es aprender Haskell como su segundo idioma, cuando los recuerdos de aprender el primero a√∫n est√°n frescos, <br><br><h2>  ¬øQu√© es Haskell bueno y malo? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Es conciso, elegante y flexible.  No es de extra√±ar que la mitad de las bibliotecas que hay en EDSL (o al menos as√≠ lo parezca). <br><br>  <b>Yuri Syrovetskiy</b> : Es (subjetivamente) f√°cil adaptar sus pensamientos al c√≥digo, tiene un gran equilibrio de paradigmas imperativos y funcionales.  Construir abstracciones de datos y algoritmos es bastante simple, lo que permite pensar en la tarea en cuesti√≥n sin distraerse demasiado con peque√±as molestias. <br><br>  <b>John Doe</b> : tipificaci√≥n estricta, fuerte (incluso fascista, dir√≠a yo). <br><br>  <b>Igor Shevnin ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">interphx</a> )</b> : un gran sistema de tipos.  No es tan poderoso como en Idris o Agda, pero a√∫n as√≠ alcanza ese punto medio conveniente donde puede describir casi cualquier cosa, y sin embargo, la inferencia de tipos funciona bien.  No tiene que marcarlos manualmente cada vez. <br><br>  Pero un sistema de tipo poderoso te obliga a prestar m√°s atenci√≥n a los valores transmitidos.  Un mont√≥n de definiciones de tipo podr√≠a parecer una repetitiva.  Cada comando tiene su propio conjunto de extensiones, o no los tiene en absoluto.  El c√≥digo es "m√°s denso": cada cadena a menudo contiene m√°s informaci√≥n que en otros idiomas, por lo que es m√°s dif√≠cil de leer para un desarrollador inexperto. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Al aprender Haskell, probablemente te topar√°s con este dicho: "Si se compila, probablemente sea correcto".  No existe nulo, el paradigma funcional en s√≠ mismo es muy estricto y lo mantiene dentro de ciertas pautas, que en la mayor√≠a de los casos conducen a un mejor dise√±o. <br><br>  Por ejemplo, Haskell no tiene variables, solo constantes.  No tiene que hacer un seguimiento de lo que est√° asignado a d√≥nde.  Haskell incentiva el uso de funciones "puras", que no tienen efectos secundarios.  El dise√±o funcional obliga al programa a funcionar como un todo, a diferencia de los lenguajes orientados a objetos, donde muchos objetos intentan comunicarse entre s√≠ mediante estos efectos secundarios, convirtiendo la aplicaci√≥n en un desastre impredecible.  Hemos sufrido esto en C # y Unity mucho en el trabajo. <br><br>  <b>Denis Mirzoev</b> : Cuando el lenguaje es naturalmente "vago", generalmente es m√°s expresivo.  Los algoritmos se vuelven m√°s simples.  Si no se utilizan resultados intermedios, aumenta en gran medida el rendimiento. <br><br>  <b>Igor Shevnin</b> : La "pereza" a menudo ayuda, pero cuando el orden de las llamadas de funci√≥n es importante, a veces es muy dif√≠cil entender lo que est√° sucediendo. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Si cumple, probablemente sea bastante r√°pido. <br><br>  <b>Denis Mirzoev</b> : En cuanto al rendimiento, es comparable a Java, pero no tan r√°pido como C. <br><br>  <b>Igor Shevnin</b> : tiene soporte de extensi√≥n <b>listo para usar</b> , lo que le permite adaptar el idioma y el sistema de tipos a su gusto.  Hay muchas extensiones que son ampliamente utilizadas por la comunidad y tienen muestras y documentaci√≥n decentes. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : La biblioteca est√°ndar de Prelude tiene muchas funciones malas como read, head, readFile, que puede generar una excepci√≥n y bloquear la aplicaci√≥n en lugar de devolver Quiz√°s.  Entonces tengo que usar alternativas o escribir la m√≠a. <br><br>  <b>Igor Shevnin</b> : el mayor problema es la falta de est√°ndares, hasta el punto en que mucha gente reemplaza la biblioteca est√°ndar con una de las alternativas, que de ninguna manera son compatibles entre s√≠.  La divisi√≥n de la comunidad sobre lo que deber√≠a ser la biblioteca est√°ndar, lo que debe incluirse en la distribuci√≥n principal y lo que puede descargarse a las extensiones ... En mi opini√≥n, ahoga el desarrollo del lenguaje. <br><br>  <b>Denis Mirzoev</b> : Carece de herramientas: no hay un IDE adecuado, muy pocos puntos de referencia de rendimiento, ni depuraci√≥n "paso a paso", es un problema fundamental. <br><br><h2>  ¬øPara qu√© proyectos se adapta mejor Haskell? </h2><br>  <b>YS</b> : Para tareas complejas, relacionadas con la seguridad y las finanzas, donde los errores son caros. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : para todo lo que necesita para calcular, convertir y analizar.  Me sorprende que Haskell sea menos popular en las aplicaciones de Data Science que Python. <br><br>  <b>IS</b> : No me arriesgar√≠a a usarlo para sistemas embebidos (es r√°pido, pero todav√≠a hay una sobrecarga de memoria significativa debido a la computaci√≥n "perezosa") o peque√±os scripts (donde no se necesita su naturaleza estricta).  Tambi√©n es importante comprender lo dif√≠cil que es encontrar desarrolladores en comparaci√≥n con los idiomas principales. <br><br>  <b>John Doe</b> : Para escribir c√≥digo industrial que ser√° le√≠do por otros, pero luego se necesita un equipo completo de desarrolladores de Haskell.  No hay muchos de ellos. <br><br>  <b>IS</b> : Pero gracias a su naturaleza concisa y estricta, puedes usar Haskell para casi cualquier cosa. <br><br><h2>  ¬øEs una buena idea comenzar su carrera de desarrollo con Haskell? </h2><br>  <b>IS</b> : Probablemente no, porque la abrumadora mayor√≠a de las bases de c√≥digo con las que un desarrollador tiene que trabajar no est√° escrito en √©l. <br><br>  <b>John Doe</b> : ¬°Mala idea!  Los idiomas que no son de ML, que es casi todo en aplicaciones industriales, ser√≠an un shock para usted. <br><br>  <b>DS</b> : A menudo las personas aprenden matem√°ticas primero y luego cambian a programaci√≥n.  Entonces, te√≥ricamente, aprender un lenguaje que requiere muchos conceptos matem√°ticos (tipos de datos algebraicos, funciones puras) deber√≠a ser m√°s f√°cil que los lenguajes imperativos.  Creo que es una buena idea. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Todos los desarrolladores novatos con los que trabajo primero los presento a Haskell.  Las personas que no tienen el bagaje del estilo imperativo son mucho m√°s r√°pidas para aprender c√≥digo funcional, e incluso cuando trabajan con lenguajes orientados a objetos m√°s tarde, tienden a utilizar buenas soluciones arquitect√≥nicas porque est√°n acostumbradas a ellos. <br><br>  <b>YS</b> : Es mejor comenzar con un par de lenguajes fundamentalmente diferentes, por ejemplo, C, Haskell y Smalltalk, en cualquier orden.  Ning√∫n idioma puede darte una comprensi√≥n total del paisaje. <br><br><h2>  Haskell es un idioma bastante antiguo.  ¬øEs bueno o malo? </h2><br>  <b>YS</b> : El lenguaje se desarrolla de manera muy activa, no arrastra el peso de la compatibilidad con versiones anteriores por el simple hecho de hacerlo. <br><br>  <b>John Doe</b> : fue estandarizado en 1998, pero no lo notar√≠as: hasta el d√≠a de hoy, aproximadamente cada 6 meses hay una nueva versi√≥n del compilador que puede romper la compatibilidad con versiones anteriores. <br><br>  <b>DS</b> : Haskell no es viejo, es simplemente probado.  No (y nunca) introducir√° cambios sin sentido.  Por lo tanto, probablemente sea bueno para la salud de la comunidad. <br><br><h2>  A menudo se dice que Haskell es uno de los idiomas m√°s dif√≠ciles de aprender.  ¬øEs realmente? </h2><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Como lenguaje en s√≠ mismo, no.  La parte m√°s dif√≠cil son las abstracciones que usa.  Una persona que nunca antes haya visto un c√≥digo Haskell podr√≠a volverse loco por la cantidad de informaci√≥n nueva y las instrucciones extra√±as.  Lo que no ayuda es que el lenguaje "restringe" muchas cosas que no se ajustan a su concepto funcional. <br><br>  <b>John Doe</b> : Me llev√≥ dos meses de libros de texto, manuales y tutoriales antes de acostarse solo para obtener mi primer proyecto para compilar.  Pensamientos, una vez que finalmente compil√≥, funcion√≥ de inmediato a plena carga (6k RPS promedio, con picos de 15k) durante medio a√±o sin ning√∫n tipo de cambio. <br><br>  <b>DS</b> : Apuesto a que si le das a Haskell a un estudiante universitario como primer idioma y √©l llega lejos con √©l, entonces la programaci√≥n imperativa parecer√≠a complicada y menos intuitiva para √©l. <br><br>  <b>IS</b> : Todo es relativo.  Fuera de los lenguajes principales, considero que C ++ es el m√°s dif√≠cil.  Los lenguajes de prueba de teoremas (como Agda o Coq) son m√°s dif√≠ciles que Haskell conceptualmente.  Haskell no es un lenguaje dif√≠cil, pero lleva tiempo aprender su patr√≥n y sus bibliotecas (tanto est√°ndar como de terceros). <br><br><h2>  ¬øEst√° justificada su complejidad? </h2><br>  <b>IS</b> : Los patrones y un alto nivel de abstracci√≥n est√°n justificados, ya que hace que el c√≥digo sea m√°s corto y m√°s duradero.  Pero creo que los operadores, los nombres de funciones y muchas otras cosas podr√≠an haber sido un poco m√°s f√°ciles de usar. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Muchas veces la complejidad de Haskell le permite hacer soluciones muy cortas, flexibles y modulares. <br><br>  <b>YS</b> : Yo dir√≠a que solo el control de efectos es un poco inestable, aunque casi siempre es preferible a ning√∫n control.  Y hay un proyecto en curso para simplificarlo. <br><br>  <b>John Doe</b> : Para las personas acostumbradas a Python / PHP / lo que sea, Haskell se siente alejado de la realidad.  Para aquellos que a√∫n no estaban interesados ‚Äã‚Äãen la teor√≠a de las categor√≠as, es muy dif√≠cil aprender desde cero.  Pero cuando lo entiendes, encuentras un nuevo enfoque para resolver un problema. <br><br><h2>  A menudo se dice que Haskell no es un lenguaje para desarrolladores, sino para matem√°ticos.  ¬øEs esta la raz√≥n por la que no es convencional? </h2><br>  <b>DS</b> : Muestra la idea principal de los principales desarrolladores de Haskell: "evitar el √©xito a toda costa".  No significa "evitar el √©xito", sino "evitar un √©xito demasiado costoso". <br><br>  Podr√≠an haber hecho popular a Haskell.  Por ejemplo, Microsoft admite el idioma.  Podr√≠an haberlo hecho m√°s imperativo, sacrificar la rigidez por la popularidad.  Hay muchos trucos sucios que podr√≠an haber usado, pero nunca lo hicieron. <br><br>  Claro, el lenguaje no es popular, pero eso significa que su calidad no sufre.  Las ventajas de Haskell en comparaci√≥n con los lenguajes imperativos son obvias para m√≠ y todos sus problemas pueden resolverse, por lo que creo que se volver√° popular m√°s adelante. <br><br>  <b>YS</b> : Solo las personas que no saben nada al respecto lo dicen.  Haskell se usa mucho en el desarrollo del "mundo real", probablemente pueda encontrar ejemplos en su motor de b√∫squeda favorito.  En particular, nosotros en Kaspersky Labs estamos muy contentos con Haskell y no lo cambiar√≠amos por nada m√°s. <br><br>  <b>IS</b> : ¬øQu√© es un "lenguaje matem√°tico"?  Es R / MatLab / Mathematica creado espec√≠ficamente para estad√≠sticas y c√°lculos, o Python porque es m√°s simple y no requiere tanta experiencia en ingenier√≠a.  Pero no Haskell.  Tiene material de √°lgebra, como monoides, pero tiene una aplicaci√≥n pr√°ctica. <br><br>  La raz√≥n por la cual C / C ++ / Java es tan popular es porque hist√≥ricamente han estado muy extendidos en el espacio empresarial.  Llenaron un nicho.  Pero hoy en d√≠a muchas empresas comienzan a usar Haskell y otros lenguajes funcionales. <br><br><h2>  ¬øCon qu√© PL comparar√≠as a Haskell? </h2><br>  <b>John Doe</b> : fuera de los populares, probablemente con Erlang.  Pero Erlang es m√°s simple de aprender y escribir. <br><br>  <b>DS</b> : S√© C, C ++, Java y Haskell.  C ++ es horrible y no se puede comparar con nada.  C es excelente para el desarrollo de bajo nivel.  En todas las dem√°s aplicaciones, preferir√≠a Haskell. <br><br>  Elegir entre Java y Haskell es m√°s dif√≠cil, pero depende de la aplicaci√≥n.  Por ejemplo, Java es mejor para Android, pero en las aplicaciones de servidor son casi iguales.  Si el entorno (herramientas, bibliotecas) lo permite, a menudo elijo Haskell. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : lo comparo con C #.  Simplemente Google "c√≥mo hacer Quiz√°s en C # y Haskell".  Es extra√±o que un lenguaje tan estrictamente funcional como Haskell se sienta mucho m√°s flexible y gratuito.  Pero en realidad, son los polos opuestos. <br><br>  C # es uno de los lenguajes m√°s orientados a objetos, y sus ventajas contrastan con Haskell.  C # siempre te obliga a escribir muchas cosas adicionales, lo que ralentiza el c√≥digo y a menudo lo hace menos elegante.  Despu√©s de las soluciones cortas y ordenadas de Haskell, es dif√≠cil regresar. <br><br>  <b>IS</b> : Con Rust, y hasta ahora Rust probablemente gana.  Toma mucho de Haskell y otros lenguajes funcionales, pero combina enfoques funcionales e imperativos, adem√°s los desarrolladores han manejado su desarrollo de manera mucho m√°s inteligente. <br><br><h2>  ¬øCu√°l es tu opini√≥n sobre la comunidad de Haskell? </h2><br>  <b>John Doe</b> : La gran mayor√≠a de las personas son muy amigables y est√°n listas para ayudar, lo cual es un buen contraste con muchos otros idiomas. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Las comunidades de Haskell a menudo est√°n llenas de personas terriblemente inteligentes.  Los memes locales sobre doctorados y acad√©micos existen por alguna raz√≥n.  En otras comunidades, la mayor√≠a de las personas discuten problemas de producci√≥n regulares y estructuras de datos, mientras que en un chat de Haskell las personas discuten m√≥nadas, ficticios aplicadores, tipos locos y cosas as√≠. <br><br>  Siempre aprendes algo en lo que nunca antes hab√≠as pensado. <br><br><h2>  Se dice que los desarrolladores de Haskell est√°n demasiado llenos de s√≠ mismos.  ¬øEs verdad? </h2><br>  <b>DS</b> : s√≠.  Siento que es porque realmente les gusta su idioma y est√°n decepcionados de lo impopular que es. <br><br>  <b>John Doe</b> : Nada de eso. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : La gente probablemente dice eso porque muchos desarrolladores convencionales se molestan con un Haskellist y comienza a hablar sobre programaci√≥n funcional y sus ventajas.  El Haskellist, mientras tanto, se molesta porque nadie lo escucha y comienza a tirar terminolog√≠a, y por lo tanto se etiqueta como "lleno de s√≠ mismo". <br><br>  <b>IS</b> : Es un poco duro llamarlos as√≠.  Probablemente se deba a que la programaci√≥n funcional, OOP, las diferencias entre las clases de OOP y los tipos de uni√≥n, el problema de extensi√≥n y muchas otras definiciones se incorporan lentamente en una imagen coherente, y luego es dif√≠cil entender a las personas que contin√∫an las guerras santas de OOP vs FP. <br><br><h2>  ¬øPor qu√© los lenguajes FP son tan espec√≠ficos? </h2><br>  <b>DS</b> : Sus ventajas no son suficientes para interesar a los programadores.  Ser dif√≠cil de aprender tampoco ayuda.  Los problemas de herramientas tambi√©n ahuyentan a las personas, aunque ese problema probablemente se resolver√≠a si hubiera m√°s personas interesadas.  Es un c√≠rculo vicioso. <br><br>  <b>IS</b> : Bueno, los conceptos de FP se abren paso lentamente en otros idiomas ... <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Doctor_Ryner</a></b> : Los principios b√°sicos de FP y sus lenguajes ya est√°n bastante extendidos.  Incluso Sharp tiene Linq y algunas otras bibliotecas similares.  Pero los lenguajes puramente funcionales probablemente solo tienen demasiados conceptos nuevos para ser populares. <br><br>  No olvide que hace 20 a√±os el hardware a√∫n no era lo suficientemente r√°pido como para manejar lenguajes funcionales, por lo que solo ingres√≥ a la corriente principal recientemente, y Haskell en s√≠ solo est√° creciendo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441350/">https://habr.com/ru/post/441350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441338/index.html">C√≥mo hicimos un sistema de pago de criptomonedas: cinco problemas principales</a></li>
<li><a href="../441340/index.html">El patrimonio cultural de Kazajst√°n en modelos 3D</a></li>
<li><a href="../441344/index.html">Entra al cielo. Una historia honesta sobre una seria pasi√≥n por el paracaidismo.</a></li>
<li><a href="../441346/index.html">Conozca a un estratega de contenido: una entrevista con Dmitry Kabanov, curador de Startup Digest de Techstars y asesor de SXSW</a></li>
<li><a href="../441348/index.html">Enrutamiento directo y equilibrio con NFT vs Nginx</a></li>
<li><a href="../441352/index.html">Patrones de CI / CD y antipatrones. Parte 2</a></li>
<li><a href="../441356/index.html">¬øC√≥mo entender el c√≥digo "extranjero" y unirme a un nuevo equipo?</a></li>
<li><a href="../441358/index.html">Lanz√≥ el primer m√≥dulo de aterrizaje lunar comercial Beresheet</a></li>
<li><a href="../441360/index.html">OpenShift - manualidades de sombrero rojo</a></li>
<li><a href="../441362/index.html">Gu√≠a del usuario de Kibana. Visualizaci√≥n. Parte 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>