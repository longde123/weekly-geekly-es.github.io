<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëë üõçÔ∏è üö∂üèæ Learning Rust: Wie ich UDP-Chat mit Azul gemacht habe üë± üôèüèø ü§æüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich lerne weiter Rust. Ich wei√ü immer noch nicht viel, deshalb mache ich viele Fehler. Das letzte Mal habe ich versucht, ein Snake- Spiel zu machen. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Learning Rust: Wie ich UDP-Chat mit Azul gemacht habe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433624/"><img src="https://habrastorage.org/webt/zl/na/ih/zlnaihhfzb9dcso-bkwp_extqd4.jpeg"><br><br>  Ich lerne weiter Rust.  Ich wei√ü immer noch nicht viel, deshalb mache ich viele Fehler.  Das letzte Mal habe ich versucht, ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Snake-</a> Spiel zu machen.  Ich habe Zyklen und Sammlungen ausprobiert und mit 3D <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Three.rs gearbeitet</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich</a> habe etwas √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ggez</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amethyst</a> gelernt.  Diesmal habe ich versucht, einen Client und einen Server f√ºr den Chat zu erstellen.  F√ºr GUI verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Azul</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sah</a> auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Conrod</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yew</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Orbtk</a> .  Ich habe Multithreading, Kan√§le und Networking ausprobiert.  Ich habe die Fehler des vorherigen Artikels ber√ºcksichtigt und versucht, dies detaillierter zu gestalten.  F√ºr Details willkommen bei Katze. <a name="habracut"></a><br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen, funktioniert unter Windows 10 x64</a> <br><br>  F√ºr die Vernetzung habe ich UDP verwendet, weil ich mein n√§chstes Projekt mit diesem Protokoll erstellen und hier damit trainieren wollte.  F√ºr die GUI habe ich schnell Projekte auf Rust googelt, mir die grundlegenden Beispiele f√ºr sie angesehen und Azul hat mich begeistert, weil sie ein Dokumentobjektmodell und eine Engine im CSS-Stil verwendet, und ich war lange Zeit mit der Webentwicklung besch√§ftigt.  Im Allgemeinen habe ich das Framework subjektiv gew√§hlt.  Bisher ist es in Deep Alpha: Scrollen funktioniert nicht, Eingabefokus funktioniert nicht, es gibt keinen Cursor.  Um Daten in ein Textfeld einzugeben, m√ºssen Sie den Mauszeiger dar√ºber halten und sie w√§hrend der Eingabe direkt dar√ºber halten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Details ...</a> <br><br>  Tats√§chlich besteht der gr√∂√üte Teil des Artikels aus Codekommentaren. <br><br><h2>  Azul </h2><br>  GUI-Framework mit funktionalem Stil, DOM, CSS.  Ihre Schnittstelle besteht aus einem Stammelement mit vielen Nachkommen, die ihre eigenen Nachkommen haben k√∂nnen, z. B. in HTML und XML.  Die gesamte Schnittstelle wird basierend auf Daten aus einem einzelnen DataModel erstellt.  Darin werden im Allgemeinen alle Daten zur Pr√§sentation √ºbertragen.  Wenn jemand mit ASP.NET vertraut ist, sind Azul und sein DataModel wie Razor und sein ViewModel.  Wie in HTML k√∂nnen Sie Funktionen an Ereignisse von DOM-Elementen binden.  Sie k√∂nnen Elemente mithilfe des CSS-Frameworks formatieren.  Dies ist nicht dasselbe CSS wie HTML, aber sehr √§hnlich.  Es gibt auch eine bidirektionale Bindung wie in Angular oder MVVM in WPF, UWP.  Weitere Informationen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Website</a> . <br><br><h2>  Ein kurzer √úberblick √ºber den Rest der Frameworks </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Orbtk</a> - Fast das gleiche wie Azul und auch in Deep Alpha </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Conrod</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> Sie k√∂nnen plattform√ºbergreifende Desktop-Anwendungen erstellen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yew</a> ist WebAssembly und √§hnelt React.  F√ºr die Webentwicklung. </li></ul><br><h2>  Kunde </h2><br><h3>  Die Struktur, in der Hilfsfunktionen zum Lesen und Schreiben in einen Socket gruppiert sind </h3><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatService</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ChatService { <span class="hljs-comment"><span class="hljs-comment">//1 fn read_data(socket: &amp;Option&lt;UdpSocket&gt;) -&gt; Option&lt;String&gt; { //2 let mut buf = [0u8; 4096]; match socket { Some(s) =&gt; { //3 match s.recv(&amp;mut buf) { //4 Ok(count) =&gt; Some(String::from_utf8(buf[..count].into()) .expect("can't parse to String")), Err(e) =&gt; { //5 println!("Error {}", e); None } } } _ =&gt; None, } } //6 fn send_to_socket(message: String, socket: &amp;Option&lt;UdpSocket&gt;) { match socket { //7 Some(s) =&gt; { s.send(message.as_bytes()).expect("can't send"); } _ =&gt; return, } } }</span></span></code> </pre> <br><ol><li>  Lesen Sie Daten aus der Steckdose </li><li>  Puffer f√ºr Daten, die aus dem Socket gelesen werden sollen. </li><li>  Anruf blockieren.  Hier stoppt der Ausf√ºhrungsthread, bis Daten gelesen werden oder eine Zeit√ºberschreitung auftritt. </li><li>  Wir erhalten eine Zeichenfolge aus einem Byte-Array in UTF8-Codierung. </li><li>  Wir kommen hierher, wenn die Verbindung durch ein Timeout unterbrochen wurde oder ein anderer Fehler aufgetreten ist. </li><li>  Sendet eine Zeichenfolge an einen Socket. </li><li>  Konvertieren Sie die Zeichenfolge in Bytes in UTF8-Codierung und senden Sie die Daten an den Socket.  Das Schreiben von Daten in einen Socket blockiert nicht, d.h.  Der Ausf√ºhrungsthread setzt seine Arbeit fort.  Wenn die Daten nicht gesendet werden konnten, unterbrechen wir das Programm mit der Meldung "Kann nicht senden". </li></ol><br><h3>  Eine Struktur, die Funktionen zum Behandeln von Ereignissen des Benutzers und zum √Ñndern unseres DataModel gruppiert </h3><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span></span> {} <span class="hljs-comment"><span class="hljs-comment">//1 const TIMEOUT_IN_MILLIS: u64 = 2000; impl Controller { //2 fn send_pressed(app_state: &amp;mut azul::prelude::AppState&lt;ChatDataModel&gt;, _event: azul::prelude::WindowEvent&lt;ChatDataModel&gt;) -&gt; azul::prelude::UpdateScreen { //3 let data = app_state.data.lock().unwrap(); //4 let message = data.messaging_model.text_input_state.text.clone(); data.messaging_model.text_input_state.text = "".into(); //5 ChatService::send_to_socket(message, &amp;data.messaging_model.socket); //6 azul::prelude::UpdateScreen::Redraw } //7 fn login_pressed(app_state: &amp;mut azul::prelude::AppState&lt;ChatDataModel&gt;, _event: azul::prelude::WindowEvent&lt;ChatDataModel&gt;) -&gt; azul::prelude::UpdateScreen { //8 use std::time::Duration; //9 if let Some(ref _s) = app_state.data.clone().lock().unwrap().messaging_model.socket { return azul::prelude::UpdateScreen::DontRedraw; } //10 app_state.add_task(Controller::read_from_socket_async, &amp;[]); //11 app_state.add_daemon(azul::prelude::Daemon::unique(azul::prelude::DaemonCallback(Controller::redraw_daemon))); //12 let mut data = app_state.data.lock().unwrap(); //13 let local_address = format!("127.0.0.1:{}", data.login_model.port_input.text.clone().trim()); //14 let socket = UdpSocket::bind(&amp;local_address) .expect(format!("can't bind socket to {}", local_address).as_str()); //15 let remote_address = data.login_model.address_input.text.clone().trim().to_string(); //16 socket.connect(&amp;remote_address) .expect(format!("can't connect to {}", &amp;remote_address).as_str()); //17 socket.set_read_timeout(Some(Duration::from_millis(TIMEOUT_IN_MILLIS))) .expect("can't set time out to read"); // 18 data.logged_in = true; // 19 data.messaging_model.socket = Option::Some(socket); //20 azul::prelude::UpdateScreen::Redraw } //21 fn read_from_socket_async(app_data: Arc&lt;Mutex&lt;ChatDataModel&gt;&gt;, _: Arc&lt;()&gt;) { //22 let socket = Controller::get_socket(app_data.clone()); loop { //23 if let Some(message) = ChatService::read_data(&amp;socket) { //24 app_data.modify(|state| { //25 state.messaging_model.has_new_message = true; //26 state.messaging_model.messages.push(message); }); } } } //27 fn redraw_daemon(state: &amp;mut ChatDataModel, _repres: &amp;mut azul::prelude::Apprepres) -&gt; (azul::prelude::UpdateScreen, azul::prelude::TerminateDaemon) { //28 if state.messaging_model.has_new_message { state.messaging_model.has_new_message = false; (azul::prelude::UpdateScreen::Redraw, azul::prelude::TerminateDaemon::Continue) } else { (azul::prelude::UpdateScreen::DontRedraw, azul::prelude::TerminateDaemon::Continue) } } //29 fn get_socket(app_data: Arc&lt;Mutex&lt;ChatDataModel&gt;&gt;) -&gt; Option&lt;UdpSocket&gt; { //30 let ref_model = &amp;(app_data.lock().unwrap().messaging_model.socket); //31 match ref_model { Some(s) =&gt; Some(s.try_clone().unwrap()), _ =&gt; None } } }</span></span></code> </pre><br><ol><li>  Das Zeitlimit in Millisekunden, nach dem der Blockiervorgang des Lesens vom Socket unterbrochen wird. </li><li>  Die Funktion wird erf√ºllt, wenn der Benutzer eine neue Nachricht an den Server senden m√∂chte. </li><li>  Wir nehmen den Mutex mit unserem Datenmodell in Besitz.  Dies blockiert den Schnittstellen-Thread zum erneuten Zeichnen der Schnittstelle, bis der Mutex freigegeben wird. </li><li>  Wir erstellen eine Kopie des vom Benutzer eingegebenen Textes, um ihn weiter zu √ºbertragen und das Texteingabefeld zu l√∂schen. </li><li>  Wir senden eine Nachricht. </li><li>  Wir informieren das Framework, dass wir nach der Verarbeitung dieses Ereignisses die Schnittstelle neu zeichnen m√ºssen. </li><li>  Die Funktion funktioniert, wenn der Benutzer eine Verbindung zum Server herstellen m√∂chte. </li><li>  Wir verbinden die Struktur, um die Zeitdauer aus der Standardbibliothek darzustellen. </li><li>  Wenn wir bereits mit dem Server verbunden sind, unterbrechen wir die Ausf√ºhrung der Funktion und teilen dem Framework mit, dass die Schnittstelle nicht neu gezeichnet werden muss. </li><li>  F√ºgen Sie eine Aufgabe hinzu, die asynchron im Thread aus dem Thread-Pool des Azul Framework ausgef√ºhrt wird.  Der Zugriff auf den Mutex mit dem Datenmodell blockiert die Aktualisierung der Benutzeroberfl√§che, bis der Mutex freigegeben wird. </li><li>  F√ºgen Sie eine wiederkehrende Aufgabe hinzu, die im Hauptthread ausgef√ºhrt wird.  Alle langwierigen Berechnungen in diesem Daemon werden durch die Schnittstellenaktualisierung blockiert. </li><li>  Wir gelangen in den Besitz des Mutex. </li><li>  Wir lesen den vom Benutzer eingegebenen Port und erstellen darauf basierend eine lokale Adresse. Wir werden abh√∂ren. </li><li>  Erstellen Sie einen UDP-Socket, der Pakete liest, die an der lokalen Adresse ankommen. </li><li>  Wir lesen die vom Benutzer eingegebene Serveradresse. </li><li>  Wir weisen unseren UDP-Socket an, nur Pakete von diesem Server zu lesen. </li><li>  Stellen Sie das Zeitlimit f√ºr den Lesevorgang am Socket ein.  Das Schreiben in den Socket erfolgt ohne Wartezeit, dh wir schreiben einfach Daten und erwarten nichts. Der Lesevorgang vom Socket blockiert den Stream und wartet, bis die lesbaren Daten eintreffen.  Wenn Sie kein Timeout festlegen, wartet der Lesevorgang vom Socket auf unbestimmte Zeit. </li><li>  Setzen Sie ein Flag, das angibt, dass der Benutzer bereits eine Verbindung zum Server hergestellt hat. </li><li>  Wir √ºbergeben den erstellten Socket an das Datenmodell. </li><li>  Wir informieren das Framework, dass wir nach der Verarbeitung dieses Ereignisses die Schnittstelle neu zeichnen m√ºssen. </li><li>  Eine asynchrone Operation, die im Thread-Pool des Azul Framework ausgef√ºhrt wird. </li><li>  Holen Sie sich eine Kopie des Sockets aus unserem Datenmodell. </li><li>  Es wird versucht, Daten aus einem Socket zu lesen.  Wenn Sie keine Kopie des Sockets erstellen und hier direkt warten, bis eine Nachricht von dem Socket eingeht, der sich in unserem Datenmodell im Mutex befindet, wird die gesamte Schnittstelle nicht mehr aktualisiert, bis wir den Mutex freigeben. </li><li>  Wenn wir eine Nachricht erhalten, √§ndert das √Ñndern unseres Datenmodells und √Ñndern dasselbe wie lock (). Unwrap (), indem das Ergebnis an das Lambda √ºbergeben und der Mutex nach dem Ende des Lambda-Codes freigegeben wird. </li><li>  Setzen Sie ein Flag, um anzuzeigen, dass wir eine neue Nachricht haben. </li><li>  F√ºgen Sie dem Array aller Chat-Nachrichten eine Nachricht hinzu. </li><li>  Eine sich wiederholende synchrone Operation, die im Haupt-Thread ausgef√ºhrt wird. </li><li>  Wenn wir eine neue Nachricht haben, teilen wir dem Framework mit, dass wir die Schnittstelle von Grund auf neu zeichnen und mit diesem D√§mon weiterarbeiten m√ºssen. Andernfalls wird die Schnittstelle nicht von Anfang an gezeichnet, sondern diese Funktion im n√§chsten Zyklus aufgerufen. </li><li>  Erstellt eine Kopie unseres Sockets, um den Mutex nicht mit unserem Datenmodell zu sperren. </li><li>  Wir bekommen den Mutex und bekommen einen Link zum Socket. </li><li>  Erstellen Sie eine Kopie des Sockets.  Mutex wird beim Beenden einer Funktion automatisch freigegeben. </li></ol><br><h3>  Asynchrone Datenverarbeitung und Daemons in Azul </h3><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Problem - blocks UI :( fn start_connection(app_state: &amp;mut AppState&lt;MyDataModel&gt;, _event: WindowEvent&lt;MyDataModel&gt;) -&gt; UpdateScreen { //   app_state.add_task(start_async_task, &amp;[]); //  app_state.add_daemon(Daemon::unique(DaemonCallback(start_daemon))); UpdateScreen::Redraw } fn start_daemon(state: &amp;mut MyDataModel, _repres: &amp;mut Apprepres) -&gt; (UpdateScreen, TerminateDaemon) { // UI    thread::sleep(Duration::from_secs(10)); state.counter += 10000; (UpdateScreen::Redraw, TerminateDaemon::Continue) } fn start_async_task(app_data: Arc&lt;Mutex&lt;MyDataModel&gt;&gt;, _: Arc&lt;()&gt;) { // simulate slow load app_data.modify(|state| { // UI    thread::sleep(Duration::from_secs(10)); state.counter += 10000; }); }</span></span></code> </pre><br>  Der Daemon wird immer im Hauptthread ausgef√ºhrt, sodass dort ein Blockieren unvermeidlich ist.  Wenn Sie dies beispielsweise bei einer asynchronen Aufgabe tun, wird 10 Sekunden lang keine Sperre angezeigt. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_async_task</span></span></span></span>(app_data: Arc&lt;Mutex&lt;MyDataModel&gt;&gt;, _: Arc&lt;()&gt;) { <span class="hljs-comment"><span class="hljs-comment">//  UI.  . thread::sleep(Duration::from_secs(10)); app_data.modify(|state| { state.counter += 10000; }); }</span></span></code> </pre><br>  Die √Ñnderungsfunktion ruft lock () auf und der Mutex mit dem Datenmodell blockiert daher die Aktualisierung der Schnittstelle f√ºr die Dauer ihrer Ausf√ºhrung. <br><br><h3>  Unsere Stile </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CUSTOM_CSS: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">" .row { height: 50px; } .orange { background: linear-gradient(to bottom, #f69135, #f37335); font-color: white; border-bottom: 1px solid #8d8d8d; }"</span></span>;</code> </pre><br><h3>  Tats√§chlich Funktionen zum Erstellen unseres DOM, die dem Benutzer angezeigt werden sollen </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> azul::prelude::Layout <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ChatDataModel { <span class="hljs-comment"><span class="hljs-comment">//1 fn layout(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //2 if self.logged_in { self.chat_form(info) } else { self.login_form(info) } } } impl ChatDataModel { //3 fn login_form(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //4 let button = azul::widgets::button::Button::with_label("Login") //5 .dom() //6 .with_class("row") //7 .with_class("orange") //8 .with_callback( azul::prelude::On::MouseUp, azul::prelude::Callback(Controller::login_pressed)); //9 let port_label = azul::widgets::label::Label::new("Enter port to listen:") .dom() .with_class("row"); //10 let port = azul::widgets::text_input::TextInput::new() //11 .bind(info.window, &amp;self.login_model.port_input, &amp;self) .dom(&amp;self.login_model.port_input) .with_class("row"); // 9 let address_label = azul::widgets::label::Label::new("Enter server address:") .dom() .with_class("row"); //10 let address = azul::widgets::text_input::TextInput::new() //11 .bind(info.window, &amp;self.login_model.address_input, &amp;self) .dom(&amp;self.login_model.address_input) .with_class("row"); //12 azul::prelude::Dom::new(azul::prelude::NodeType::Div) .with_child(port_label) .with_child(port) .with_child(address_label) .with_child(address) .with_child(button) } //13 fn chat_form(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //14 let button = azul::widgets::button::Button::with_label("Send") .dom() .with_class("row") .with_class("orange") .with_callback(azul::prelude::On::MouseUp, azul::prelude::Callback(Controller::send_pressed)); //15 let text = azul::widgets::text_input::TextInput::new() .bind(info.window, &amp;self.messaging_model.text_input_state, &amp;self) .dom(&amp;self.messaging_model.text_input_state) .with_class("row"); //12 let mut dom = azul::prelude::Dom::new(azul::prelude::NodeType::Div) .with_child(text) .with_child(button); //16 for i in &amp;self.messaging_model.messages { dom.add_child(azul::widgets::label::Label::new(i.clone()).dom().with_class("row")); } dom } }</span></span></code> </pre><br><ol><li>  Die Funktion, die das endg√ºltige DOM erstellt und jedes Mal aufgerufen wird, wenn Sie die Schnittstelle neu zeichnen m√ºssen. </li><li>  Wenn wir bereits mit dem Server verbunden sind, wird das Formular zum Senden und Lesen von Nachrichten angezeigt. Andernfalls wird das Formular zum Herstellen einer Verbindung zum Server angezeigt. </li><li>  Erstellt ein Formular zur Eingabe der Daten, die f√ºr die Verbindung zum Server erforderlich sind. </li><li>  Erstellen Sie eine Schaltfl√§che mit der Textbeschriftung Login. </li><li>  Konvertieren Sie es in ein DOM-Objekt. </li><li>  F√ºgen Sie die Zeilenklasse hinzu. </li><li>  F√ºgen Sie die CSS-Klasse Orange hinzu. </li><li>  F√ºgen Sie einen Ereignishandler hinzu, um auf die Schaltfl√§che zu klicken. </li><li>  Erstellen Sie eine Textbeschriftung mit Text, der dem Benutzer und der CSS-Klassenzeile angezeigt werden soll. </li><li>  Wir erstellen ein Textfeld f√ºr die Eingabe von Text mit Text aus der Eigenschaft unserer Modell- und CSS-Klassenzeile. </li><li>  Binden Sie das Textfeld an die Eigenschaft unseres DataModel.  Dies ist eine Zwei-Wege-Bindung.  Wenn Sie jetzt TextInput bearbeiten, wird der Text in der Eigenschaft unseres Modells automatisch ge√§ndert, und das Gegenteil ist auch der Fall.  Wenn wir den Text in unserem Modell √§ndern, √§ndert sich der Text in TextInput. </li><li>  Wir erstellen ein Root-DOM-Element, in das wir unsere UI-Elemente einf√ºgen. </li><li>  Erstellt ein Formular zum Senden und Lesen von Nachrichten. </li><li>  Erstellen Sie eine Schaltfl√§che mit dem Text "Senden" und CSS mit den Klassen "Zeile", "Orange" und einem Ereignishandler, wenn Sie darauf klicken. </li><li>  Wir erstellen ein Texteingabefeld mit bidirektionaler Bindung mit der Modelleigenschaft self.messaging_model.text_input_state und css mit der Klasse "row". </li><li>  F√ºgen Sie Textbeschriftungen hinzu, die Nachrichten anzeigen, die im Chat geschrieben wurden. </li></ol><br><h3>  Unser Modell, das den Status unserer Schnittstelle speichert </h3><br>  In der Azul-Dokumentation hei√üt es, dass alle Anwendungsdaten, einschlie√ülich der Verbindung zur Datenbank, gespeichert werden sollen. Daher habe ich einen UDP-Socket eingef√ºgt. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//1 #[derive(Debug)] //2 struct ChatDataModel { //3 logged_in: bool, //4 messaging_model: MessagingDataModel, //5 login_model: LoginDataModel, } #[derive(Debug, Default)] struct LoginDataModel { //6 port_input: azul::widgets::text_input::TextInputState, //7 address_input: azul::widgets::text_input::TextInputState, } #[derive(Debug)] struct MessagingDataModel { //8 text_input_state: azul::widgets::text_input::TextInputState, //9 messages: Vec&lt;String&gt;, //10 socket: Option&lt;UdpSocket&gt;, //11 has_new_message: bool, }</span></span></code> </pre><br><ol><li>  Auf diese Weise k√∂nnen wir unsere Struktur als Zeichenfolge in einer Vorlage des Formulars {:?} Anzeigen. </li><li>  Unser Datenmodell.  Damit es in Azul verwendet werden kann.  Sie muss das Layout-Merkmal implementieren. </li><li>  Ein Flag, mit dem √ºberpr√ºft wird, ob der Benutzer mit dem Server verbunden ist oder nicht. </li><li>  Ein Modell zum Anzeigen eines Formulars zum Senden von Nachrichten an den Server und zum Speichern von vom Server empfangenen Nachrichten. </li><li>  Modell zum Anzeigen des Formulars f√ºr die Verbindung zum Server. </li><li>  Der Port, den der Benutzer eingegeben hat.  Wir werden es mit unserer Steckdose h√∂ren. </li><li>  Die vom Benutzer eingegebene Serveradresse.  Wir werden uns damit verbinden. </li><li>  Benutzermeldung.  Wir werden es an den Server senden. </li><li>  Ein Array von Nachrichten, die vom Server kamen. </li><li>  Der Socket, √ºber den wir mit dem Server kommunizieren. </li><li>  Ein Flag, mit dem √ºberpr√ºft wird, ob eine neue Nachricht vom Server eingegangen ist. </li></ol><br><h3>  Und schlie√ülich der Haupteinstiegspunkt f√ºr die Anwendung.  Startet einen Zyklus aus der GUI-Zeichnung und der Verarbeitung von Benutzereingaben </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//1 let app = azul::prelude::App::new(ChatDataModel { logged_in: false, messaging_model: MessagingDataModel { text_input_state: azul::widgets::text_input::TextInputState::new(""), messages: Vec::new(), socket: None, has_new_message: false, }, login_model: LoginDataModel::default(), }, azul::prelude::AppConfig::default()); // 2 let mut style = azul::prelude::css::native(); //3 style.merge(azul::prelude::css::from_str(CUSTOM_CSS).unwrap()); //4 let window = azul::prelude::Window::new(azul::prelude::WindowCreateOptions::default(), style).unwrap(); //5 app.run(window).unwrap(); }</span></span></code> </pre><br><ol><li>  Wir erstellen eine Anwendung mit Startdaten. </li><li>  Die von der Anwendung standardm√§√üig verwendeten Stile. </li><li>  F√ºgen Sie ihnen unsere eigenen Stile hinzu. </li><li>  Wir erstellen ein Fenster, in dem unsere Anwendung angezeigt wird. </li><li>  Starten Sie die Anwendung in diesem Fenster. </li></ol><br><h2>  Server </h2><br><h3>  Der Haupteinstiegspunkt f√ºr die Anwendung </h3><br>  Hier haben wir normalerweise eine Konsolenanwendung. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//1 let socket = create_socket(); //2 let (sx, rx) = mpsc::channel(); //3 start_sender_thread(rx, socket.try_clone().unwrap()); loop { //4 sx.send(read_data(&amp;socket)).unwrap(); } }</span></span></code> </pre><br><ol><li>  Erstellen Sie einen Socket. </li><li>  Wir erstellen einen Einwegkanal mit einem SX-Nachrichtensender und vielen RX-Empf√§ngern. </li><li>  Wir senden Nachrichten an alle Empf√§nger in einem separaten Stream. </li><li>  Wir lesen die Daten vom Socket und senden sie an den Stream, der Nachrichten an mit dem Server verbundene Clients sendet. </li></ol><br><h3>  Funktion zum Erstellen eines Streams zum Senden von Nachrichten an Clients </h3><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_sender_thread</span></span></span></span>(rx: mpsc::Receiver&lt;(<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;, SocketAddr)&gt;, socket: UdpSocket) { <span class="hljs-comment"><span class="hljs-comment">//1 thread::spawn(move || { //2 let mut addresses = Vec::&lt;SocketAddr&gt;::new(); //3 loop { //4 let (bytes, pre) = rx.recv().unwrap(); // 5 if !addresses.contains(&amp;pre) { println!(" {} connected to server", pre); addresses.push(pre.clone()); } //6 let result = String::from_utf8(bytes) .expect("can't parse to String") .trim() .to_string(); println!("received {} from {}", result, pre); //7 let message = format!("FROM: {} MESSAGE: {}", pre, result); let data_to_send = message.as_bytes(); //8 addresses .iter() .for_each(|s| { //9 socket.send_to(data_to_send, s) //10 .expect(format!("can't send to {}", pre).as_str()); }); } }); }</span></span></code> </pre><br><ol><li>  Starten Sie einen neuen Thread.  Verschieben bedeutet, dass die Variablen das Lambda bzw. den Fluss √ºbernehmen.  Insbesondere wird unser neuer Thread die RX- und Socket-Variablen "absorbieren". </li><li>  Eine Sammlung von Adressen, die von Kunden mit uns verbunden wurden.  Wir werden allen unsere Nachrichten senden.  Im Allgemeinen w√§re es in einem realen Projekt erforderlich, einen Client von uns zu trennen und seine Adresse aus diesem Array zu entfernen. </li><li>  Wir starten eine Endlosschleife. </li><li>  Wir lesen die Daten aus dem Kanal.  Hier wird der Stream blockiert, bis neue Daten eintreffen. </li><li>  Wenn unser Array keine solche Adresse enth√§lt, f√ºgen Sie sie dort hinzu. </li><li>  Dekodieren Sie eine UTF8-Zeichenfolge aus einem Byte-Array. </li><li>  Wir erstellen eine Reihe von Bytes, die wir an alle unsere Kunden senden werden. </li><li>  Wir gehen die Adressensammlung durch und senden Daten an alle. </li><li>  Der Schreibvorgang in den UDP-Socket ist nicht blockierend, daher wartet die Funktion hier nicht, bis die Nachricht beim Empf√§nger eintrifft und fast sofort ausgef√ºhrt wird. </li><li>  Erwarten Sie im Fehlerfall einen Notausgang aus dem Programm mit der angegebenen Meldung. </li></ol><br><h3>  Die Funktion erstellt einen Socket basierend auf Benutzereingaben </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIMEOUT_IN_MILLIS: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span> = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_socket</span></span></span></span>() -&gt; UdpSocket { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Enter port to listen"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1 let local_port: String = read!("{}\n"); let local_address = format!("127.0.0.1:{}", local_port.trim()); println!("server address {}", &amp;local_address); //2 let socket = UdpSocket::bind(&amp;local_address.trim()) .expect(format!("can't bind socket to {}", &amp;local_address).as_str()); //3 socket.set_read_timeout(Some(Duration::from_millis(TIMEOUT_IN_MILLIS))) .expect("can't set time out to read"); //4 socket }</span></span></code> </pre><br><ol><li>  Wir lesen den Port, den unser Server abh√∂rt, und erstellen darauf basierend eine lokale Serveradresse. </li><li>  Erstellen Sie einen UDP-Socket, der diese Adresse √ºberwacht. </li><li>  Stellen Sie das Zeitlimit f√ºr den Lesevorgang ein.  Der Lesevorgang blockiert und blockiert den Stream, bis neue Daten eintreffen oder eine Zeit√ºberschreitung auftritt. </li><li>  Wir geben den erstellten Socket von der Funktion zur√ºck. </li><li>  Die Funktion liest Daten aus dem Socket und gibt sie zusammen mit der Absenderadresse zur√ºck. </li></ol><br><h3>  Funktion zum Lesen von Daten aus einem Socket </h3><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_data</span></span></span></span>(socket: &amp;UdpSocket) -&gt; (<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;, SocketAddr) { <span class="hljs-comment"><span class="hljs-comment">//1 let mut buf = [0u8; 4096]; //2 loop { match socket.recv_from(&amp;mut buf) { //3 Ok((count, address)) =&gt; { //4 return (buf[..count].into(), address); } //5 Err(e) =&gt; { println!("Error {}", e); continue; } }; } }</span></span></code> </pre><br><ol><li>  Der Puffer ist der Ort, an dem wir die Daten lesen werden. </li><li>  Startet eine Schleife, die ausgef√ºhrt wird, bis g√ºltige Daten gelesen werden. </li><li>  Wir erhalten die Anzahl der gelesenen Bytes und die Absenderadresse. </li><li>  Wir schneiden das Array von Anfang an auf die Anzahl der gelesenen Bytes und konvertieren es in einen Bytevektor. </li><li>  Wenn ein Timeout oder ein anderer Fehler auftritt, fahren Sie mit der n√§chsten Iteration der Schleife fort. </li></ol><br><h2>  Informationen zu Ebenen in der Anwendung </h2><br><div class="spoiler">  <b class="spoiler_title">Offtopic: Ein kleines Bildungsprogramm f√ºr zwei Juni bei der Arbeit.</b>  <b class="spoiler_title">Ich habe beschlossen, es hier zu platzieren, vielleicht wird jemand n√ºtzlich sein.</b>  <b class="spoiler_title">June Sharp-Poets sind Beispiele in C # und wir sprechen √ºber ASP.NET</b> <div class="spoiler_text">  Es gab also nichts zu tun, es war am Abend, und ich beschloss, ein kleines Bildungsprogramm √ºber Architektur f√ºr Artem und Victor zu schreiben.  Nun, lass uns gehen. <br><br>  Eigentlich habe ich hier hinzugef√ºgt, weil der Modus Aufkl√§rung ist und ich nur einmal pro Woche Artikel schreiben kann und das Material bereits da ist und ich n√§chste Woche etwas anderes auf Habr hochladen wollte. <br><br>  In der Regel wird eine Anwendung geschichtet.  In jeder Ebene gibt es Objekte, die die Verhaltenscharakteristik der Ebene implementieren, in der sie sich befinden.  Und so.  Das sind die Schichten. <br><br><ol><li>  Pr√§sentationsschicht. </li><li>  Layer-Gesch√§ftslogik. </li><li>  Datenzugriffsschicht. </li><li>  Entit√§ten (Benutzer, Tier usw.) </li></ol><br><br>  Jede Schicht kann ein eigenes DTO und vollst√§ndig beliebige Klassen mit beliebigen Methoden enthalten.  Die Hauptsache ist, dass sie die Funktionalit√§t ausf√ºhren, die der Ebene zugeordnet ist, in der sie sich befinden.  In einfachen Anwendungen fehlen m√∂glicherweise einige der Ebenen.  Beispielsweise kann eine Ebenenansicht √ºber das MVC-, MVP- und MVVM-Muster implementiert werden.  Welches ist v√∂llig optional.  Die Hauptsache ist, dass die Klassen in dieser Schicht die der Schicht zugewiesene Funktionalit√§t implementieren.  Denken Sie daran, Muster und Architektur sind nur Empfehlungen, keine Anweisungen.  Muster und Architektur sind kein Gesetz, dies ist ein Ratschlag. <br><br>  Daher betrachten wir jede Ebene am Beispiel einer Standard-ASP.NET-Anwendung unter Verwendung des Standard-Entity-Frameworks. <br><br><h3>  Pr√§sentationsschicht </h3><br>  Wir haben MVC hier.  Dies ist die Ebene, die die Benutzerinteraktion erm√∂glicht.  Befehle kommen hierher und Benutzer erhalten Daten von hier.  Nicht unbedingt Menschen, wenn wir eine API haben, dann ist unser Benutzer ein anderes Programm.  Autos kommunizieren mit Autos. <br><br><h3>  Gesch√§ftslogikschicht </h3><br>  Hier werden Klassen normalerweise als Service bezeichnet, z. B. UserService, obwohl es sich um alles handeln kann.  Nur eine Reihe von Klassen mit Methoden.  Hauptsache, hier finden die Berechnungen und Berechnungen unserer Anwendung statt.  Dies ist die dickste und sperrigste Schicht.  Es gibt den gr√∂√üten Teil des Codes und verschiedene Klassen.  Dies ist in der Tat unsere Anwendung. <br><br><h3>  Datenzugriffsschicht </h3><br>  Normalerweise implementiert EF hier Unit Of Work- und Repository-Muster.  Also ja, DbContext ist, sagen Sie, Unit Of Work, und DB legt fest, dass es sich um ein Repository handelt.  Dies ist in der Tat der Ort, an dem wir die Daten ablegen und von dem wir sie beziehen.  Unabh√§ngig davon, ob die Datenquelle eine Datenbank, eine API einer anderen Anwendung, ein Cache im Speicher oder nur eine Art Zufallszahlengenerator ist.  Beliebige Datenquelle. <br><br><h3>  Entit√§ten </h3><br>  Ja, nur alle Arten von Benutzern, Tieren und mehr.  Ein wichtiger Punkt - sie haben m√∂glicherweise nur ein Verhalten, das f√ºr sie charakteristisch ist.  Zum Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LastName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FullName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FirstName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + LastName; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">User user</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FullName == user.FullName; } }</code> </pre> <br><h3>  Nun, und ein sehr einfaches Beispiel.  Shoba war </h3><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-comment"><span class="hljs-comment">//Entities class User { public int Id { get; set; } public string Name { get; set; } } //Data Access Layer class UserRepository { private readonly Dictionary&lt;int, User&gt; _db; public UserRepository() { _db = new Dictionary&lt;int, User&gt;(); } public User Get(int id) { return _db[id]; } public void Save(User user) { _db[user.Id] = user; } } //Business Logic Layer class UserService { private readonly UserRepository _repo; private int _currentId = 0; public UserService() { _repo = new UserRepository(); } public void AddNew() { _currentId++; var user = new User { Id = _currentId, Name = _currentId.ToString() }; _repo.Save(user); } public string GetAll() { StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= _currentId; i++) { sb.AppendLine($"Id: {i} Name: {_repo.Get(i).Name}"); } return sb.ToString(); } } //presentation Layer aka Application Layer class UserController { private readonly UserService _service; public UserController() { _service = new UserService(); } public string RunExample() { _service.AddNew(); _service.AddNew(); return _service.GetAll(); } } namespace ConsoleApp1 { class Program { static void Main(string[] args) { var controller = new UserController(); Console.WriteLine(controller.RunExample()); Console.ReadLine(); } } }</span></span></code> </pre> <br></div></div><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, sho, ich m√∂chte mich bei meiner Nastya f√ºr die Behebung von Grammatikfehlern im Artikel bedanken. </font><font style="vertical-align: inherit;">Also ja, Nastya, du bist nicht umsonst mit einem roten Diplom und im Allgemeinen cool. </font><font style="vertical-align: inherit;">Ich liebe dich &lt;3.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433624/">https://habr.com/ru/post/de433624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433610/index.html">Notizen eines Phytochemikers. Persimmon</a></li>
<li><a href="../de433612/index.html">FCC: SpaceX-Satelliten im Orbit - eine Quelle von Tr√ºmmern, die f√ºr die Bewohner der Erde gef√§hrlich sind</a></li>
<li><a href="../de433614/index.html">So √ºbernehmen Sie die Kontrolle √ºber Ihre Netzwerkinfrastruktur. Kapitel Eins Aufbewahrung</a></li>
<li><a href="../de433618/index.html">"Warm Tube" Sound mit eigenen H√§nden. Was ist, wenn Sie ein Gesch√§ft, einen Club und eine Werkstatt durchqueren?</a></li>
<li><a href="../de433620/index.html">Wie SystemUI in Android funktioniert</a></li>
<li><a href="../de433628/index.html">Feedback-Kultur: Wie man nicht in Anschuldigungen ger√§t</a></li>
<li><a href="../de433630/index.html">Ein Schritt n√§her am HIV-Impfstoff: Affentiter von serumneutralisierenden Antik√∂rpern</a></li>
<li><a href="../de433632/index.html">Eine andere mobile Anwendung "leckte" die Daten ihrer Benutzer</a></li>
<li><a href="../de433634/index.html">Bienenstock√ºberwachung | Ich Dadan und Halbukrainer | Datenredundanz</a></li>
<li><a href="../de433636/index.html">Taschenlampen-Lade-Kubotan: eine gute Idee oder ein Dummy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>