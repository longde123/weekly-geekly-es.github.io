<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👑 🛍️ 🚶🏾 Learning Rust: Wie ich UDP-Chat mit Azul gemacht habe 👱 🙏🏿 🤾🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich lerne weiter Rust. Ich weiß immer noch nicht viel, deshalb mache ich viele Fehler. Das letzte Mal habe ich versucht, ein Snake- Spiel zu machen. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Learning Rust: Wie ich UDP-Chat mit Azul gemacht habe</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433624/"><img src="https://habrastorage.org/webt/zl/na/ih/zlnaihhfzb9dcso-bkwp_extqd4.jpeg"><br><br>  Ich lerne weiter Rust.  Ich weiß immer noch nicht viel, deshalb mache ich viele Fehler.  Das letzte Mal habe ich versucht, ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Snake-</a> Spiel zu machen.  Ich habe Zyklen und Sammlungen ausprobiert und mit 3D <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Three.rs gearbeitet</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ich</a> habe etwas über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ggez</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amethyst</a> gelernt.  Diesmal habe ich versucht, einen Client und einen Server für den Chat zu erstellen.  Für GUI verwendet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Azul</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sah</a> auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Conrod</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yew</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Orbtk</a> .  Ich habe Multithreading, Kanäle und Networking ausprobiert.  Ich habe die Fehler des vorherigen Artikels berücksichtigt und versucht, dies detaillierter zu gestalten.  Für Details willkommen bei Katze. <a name="habracut"></a><br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quellen, funktioniert unter Windows 10 x64</a> <br><br>  Für die Vernetzung habe ich UDP verwendet, weil ich mein nächstes Projekt mit diesem Protokoll erstellen und hier damit trainieren wollte.  Für die GUI habe ich schnell Projekte auf Rust googelt, mir die grundlegenden Beispiele für sie angesehen und Azul hat mich begeistert, weil sie ein Dokumentobjektmodell und eine Engine im CSS-Stil verwendet, und ich war lange Zeit mit der Webentwicklung beschäftigt.  Im Allgemeinen habe ich das Framework subjektiv gewählt.  Bisher ist es in Deep Alpha: Scrollen funktioniert nicht, Eingabefokus funktioniert nicht, es gibt keinen Cursor.  Um Daten in ein Textfeld einzugeben, müssen Sie den Mauszeiger darüber halten und sie während der Eingabe direkt darüber halten.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Details ...</a> <br><br>  Tatsächlich besteht der größte Teil des Artikels aus Codekommentaren. <br><br><h2>  Azul </h2><br>  GUI-Framework mit funktionalem Stil, DOM, CSS.  Ihre Schnittstelle besteht aus einem Stammelement mit vielen Nachkommen, die ihre eigenen Nachkommen haben können, z. B. in HTML und XML.  Die gesamte Schnittstelle wird basierend auf Daten aus einem einzelnen DataModel erstellt.  Darin werden im Allgemeinen alle Daten zur Präsentation übertragen.  Wenn jemand mit ASP.NET vertraut ist, sind Azul und sein DataModel wie Razor und sein ViewModel.  Wie in HTML können Sie Funktionen an Ereignisse von DOM-Elementen binden.  Sie können Elemente mithilfe des CSS-Frameworks formatieren.  Dies ist nicht dasselbe CSS wie HTML, aber sehr ähnlich.  Es gibt auch eine bidirektionale Bindung wie in Angular oder MVVM in WPF, UWP.  Weitere Informationen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf der Website</a> . <br><br><h2>  Ein kurzer Überblick über den Rest der Frameworks </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Orbtk</a> - Fast das gleiche wie Azul und auch in Deep Alpha </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Conrod</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> Sie können plattformübergreifende Desktop-Anwendungen erstellen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yew</a> ist WebAssembly und ähnelt React.  Für die Webentwicklung. </li></ul><br><h2>  Kunde </h2><br><h3>  Die Struktur, in der Hilfsfunktionen zum Lesen und Schreiben in einen Socket gruppiert sind </h3><br><pre><code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatService</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ChatService { <span class="hljs-comment"><span class="hljs-comment">//1 fn read_data(socket: &amp;Option&lt;UdpSocket&gt;) -&gt; Option&lt;String&gt; { //2 let mut buf = [0u8; 4096]; match socket { Some(s) =&gt; { //3 match s.recv(&amp;mut buf) { //4 Ok(count) =&gt; Some(String::from_utf8(buf[..count].into()) .expect("can't parse to String")), Err(e) =&gt; { //5 println!("Error {}", e); None } } } _ =&gt; None, } } //6 fn send_to_socket(message: String, socket: &amp;Option&lt;UdpSocket&gt;) { match socket { //7 Some(s) =&gt; { s.send(message.as_bytes()).expect("can't send"); } _ =&gt; return, } } }</span></span></code> </pre> <br><ol><li>  Lesen Sie Daten aus der Steckdose </li><li>  Puffer für Daten, die aus dem Socket gelesen werden sollen. </li><li>  Anruf blockieren.  Hier stoppt der Ausführungsthread, bis Daten gelesen werden oder eine Zeitüberschreitung auftritt. </li><li>  Wir erhalten eine Zeichenfolge aus einem Byte-Array in UTF8-Codierung. </li><li>  Wir kommen hierher, wenn die Verbindung durch ein Timeout unterbrochen wurde oder ein anderer Fehler aufgetreten ist. </li><li>  Sendet eine Zeichenfolge an einen Socket. </li><li>  Konvertieren Sie die Zeichenfolge in Bytes in UTF8-Codierung und senden Sie die Daten an den Socket.  Das Schreiben von Daten in einen Socket blockiert nicht, d.h.  Der Ausführungsthread setzt seine Arbeit fort.  Wenn die Daten nicht gesendet werden konnten, unterbrechen wir das Programm mit der Meldung "Kann nicht senden". </li></ol><br><h3>  Eine Struktur, die Funktionen zum Behandeln von Ereignissen des Benutzers und zum Ändern unseres DataModel gruppiert </h3><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span></span> {} <span class="hljs-comment"><span class="hljs-comment">//1 const TIMEOUT_IN_MILLIS: u64 = 2000; impl Controller { //2 fn send_pressed(app_state: &amp;mut azul::prelude::AppState&lt;ChatDataModel&gt;, _event: azul::prelude::WindowEvent&lt;ChatDataModel&gt;) -&gt; azul::prelude::UpdateScreen { //3 let data = app_state.data.lock().unwrap(); //4 let message = data.messaging_model.text_input_state.text.clone(); data.messaging_model.text_input_state.text = "".into(); //5 ChatService::send_to_socket(message, &amp;data.messaging_model.socket); //6 azul::prelude::UpdateScreen::Redraw } //7 fn login_pressed(app_state: &amp;mut azul::prelude::AppState&lt;ChatDataModel&gt;, _event: azul::prelude::WindowEvent&lt;ChatDataModel&gt;) -&gt; azul::prelude::UpdateScreen { //8 use std::time::Duration; //9 if let Some(ref _s) = app_state.data.clone().lock().unwrap().messaging_model.socket { return azul::prelude::UpdateScreen::DontRedraw; } //10 app_state.add_task(Controller::read_from_socket_async, &amp;[]); //11 app_state.add_daemon(azul::prelude::Daemon::unique(azul::prelude::DaemonCallback(Controller::redraw_daemon))); //12 let mut data = app_state.data.lock().unwrap(); //13 let local_address = format!("127.0.0.1:{}", data.login_model.port_input.text.clone().trim()); //14 let socket = UdpSocket::bind(&amp;local_address) .expect(format!("can't bind socket to {}", local_address).as_str()); //15 let remote_address = data.login_model.address_input.text.clone().trim().to_string(); //16 socket.connect(&amp;remote_address) .expect(format!("can't connect to {}", &amp;remote_address).as_str()); //17 socket.set_read_timeout(Some(Duration::from_millis(TIMEOUT_IN_MILLIS))) .expect("can't set time out to read"); // 18 data.logged_in = true; // 19 data.messaging_model.socket = Option::Some(socket); //20 azul::prelude::UpdateScreen::Redraw } //21 fn read_from_socket_async(app_data: Arc&lt;Mutex&lt;ChatDataModel&gt;&gt;, _: Arc&lt;()&gt;) { //22 let socket = Controller::get_socket(app_data.clone()); loop { //23 if let Some(message) = ChatService::read_data(&amp;socket) { //24 app_data.modify(|state| { //25 state.messaging_model.has_new_message = true; //26 state.messaging_model.messages.push(message); }); } } } //27 fn redraw_daemon(state: &amp;mut ChatDataModel, _repres: &amp;mut azul::prelude::Apprepres) -&gt; (azul::prelude::UpdateScreen, azul::prelude::TerminateDaemon) { //28 if state.messaging_model.has_new_message { state.messaging_model.has_new_message = false; (azul::prelude::UpdateScreen::Redraw, azul::prelude::TerminateDaemon::Continue) } else { (azul::prelude::UpdateScreen::DontRedraw, azul::prelude::TerminateDaemon::Continue) } } //29 fn get_socket(app_data: Arc&lt;Mutex&lt;ChatDataModel&gt;&gt;) -&gt; Option&lt;UdpSocket&gt; { //30 let ref_model = &amp;(app_data.lock().unwrap().messaging_model.socket); //31 match ref_model { Some(s) =&gt; Some(s.try_clone().unwrap()), _ =&gt; None } } }</span></span></code> </pre><br><ol><li>  Das Zeitlimit in Millisekunden, nach dem der Blockiervorgang des Lesens vom Socket unterbrochen wird. </li><li>  Die Funktion wird erfüllt, wenn der Benutzer eine neue Nachricht an den Server senden möchte. </li><li>  Wir nehmen den Mutex mit unserem Datenmodell in Besitz.  Dies blockiert den Schnittstellen-Thread zum erneuten Zeichnen der Schnittstelle, bis der Mutex freigegeben wird. </li><li>  Wir erstellen eine Kopie des vom Benutzer eingegebenen Textes, um ihn weiter zu übertragen und das Texteingabefeld zu löschen. </li><li>  Wir senden eine Nachricht. </li><li>  Wir informieren das Framework, dass wir nach der Verarbeitung dieses Ereignisses die Schnittstelle neu zeichnen müssen. </li><li>  Die Funktion funktioniert, wenn der Benutzer eine Verbindung zum Server herstellen möchte. </li><li>  Wir verbinden die Struktur, um die Zeitdauer aus der Standardbibliothek darzustellen. </li><li>  Wenn wir bereits mit dem Server verbunden sind, unterbrechen wir die Ausführung der Funktion und teilen dem Framework mit, dass die Schnittstelle nicht neu gezeichnet werden muss. </li><li>  Fügen Sie eine Aufgabe hinzu, die asynchron im Thread aus dem Thread-Pool des Azul Framework ausgeführt wird.  Der Zugriff auf den Mutex mit dem Datenmodell blockiert die Aktualisierung der Benutzeroberfläche, bis der Mutex freigegeben wird. </li><li>  Fügen Sie eine wiederkehrende Aufgabe hinzu, die im Hauptthread ausgeführt wird.  Alle langwierigen Berechnungen in diesem Daemon werden durch die Schnittstellenaktualisierung blockiert. </li><li>  Wir gelangen in den Besitz des Mutex. </li><li>  Wir lesen den vom Benutzer eingegebenen Port und erstellen darauf basierend eine lokale Adresse. Wir werden abhören. </li><li>  Erstellen Sie einen UDP-Socket, der Pakete liest, die an der lokalen Adresse ankommen. </li><li>  Wir lesen die vom Benutzer eingegebene Serveradresse. </li><li>  Wir weisen unseren UDP-Socket an, nur Pakete von diesem Server zu lesen. </li><li>  Stellen Sie das Zeitlimit für den Lesevorgang am Socket ein.  Das Schreiben in den Socket erfolgt ohne Wartezeit, dh wir schreiben einfach Daten und erwarten nichts. Der Lesevorgang vom Socket blockiert den Stream und wartet, bis die lesbaren Daten eintreffen.  Wenn Sie kein Timeout festlegen, wartet der Lesevorgang vom Socket auf unbestimmte Zeit. </li><li>  Setzen Sie ein Flag, das angibt, dass der Benutzer bereits eine Verbindung zum Server hergestellt hat. </li><li>  Wir übergeben den erstellten Socket an das Datenmodell. </li><li>  Wir informieren das Framework, dass wir nach der Verarbeitung dieses Ereignisses die Schnittstelle neu zeichnen müssen. </li><li>  Eine asynchrone Operation, die im Thread-Pool des Azul Framework ausgeführt wird. </li><li>  Holen Sie sich eine Kopie des Sockets aus unserem Datenmodell. </li><li>  Es wird versucht, Daten aus einem Socket zu lesen.  Wenn Sie keine Kopie des Sockets erstellen und hier direkt warten, bis eine Nachricht von dem Socket eingeht, der sich in unserem Datenmodell im Mutex befindet, wird die gesamte Schnittstelle nicht mehr aktualisiert, bis wir den Mutex freigeben. </li><li>  Wenn wir eine Nachricht erhalten, ändert das Ändern unseres Datenmodells und Ändern dasselbe wie lock (). Unwrap (), indem das Ergebnis an das Lambda übergeben und der Mutex nach dem Ende des Lambda-Codes freigegeben wird. </li><li>  Setzen Sie ein Flag, um anzuzeigen, dass wir eine neue Nachricht haben. </li><li>  Fügen Sie dem Array aller Chat-Nachrichten eine Nachricht hinzu. </li><li>  Eine sich wiederholende synchrone Operation, die im Haupt-Thread ausgeführt wird. </li><li>  Wenn wir eine neue Nachricht haben, teilen wir dem Framework mit, dass wir die Schnittstelle von Grund auf neu zeichnen und mit diesem Dämon weiterarbeiten müssen. Andernfalls wird die Schnittstelle nicht von Anfang an gezeichnet, sondern diese Funktion im nächsten Zyklus aufgerufen. </li><li>  Erstellt eine Kopie unseres Sockets, um den Mutex nicht mit unserem Datenmodell zu sperren. </li><li>  Wir bekommen den Mutex und bekommen einen Link zum Socket. </li><li>  Erstellen Sie eine Kopie des Sockets.  Mutex wird beim Beenden einer Funktion automatisch freigegeben. </li></ol><br><h3>  Asynchrone Datenverarbeitung und Daemons in Azul </h3><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Problem - blocks UI :( fn start_connection(app_state: &amp;mut AppState&lt;MyDataModel&gt;, _event: WindowEvent&lt;MyDataModel&gt;) -&gt; UpdateScreen { //   app_state.add_task(start_async_task, &amp;[]); //  app_state.add_daemon(Daemon::unique(DaemonCallback(start_daemon))); UpdateScreen::Redraw } fn start_daemon(state: &amp;mut MyDataModel, _repres: &amp;mut Apprepres) -&gt; (UpdateScreen, TerminateDaemon) { // UI    thread::sleep(Duration::from_secs(10)); state.counter += 10000; (UpdateScreen::Redraw, TerminateDaemon::Continue) } fn start_async_task(app_data: Arc&lt;Mutex&lt;MyDataModel&gt;&gt;, _: Arc&lt;()&gt;) { // simulate slow load app_data.modify(|state| { // UI    thread::sleep(Duration::from_secs(10)); state.counter += 10000; }); }</span></span></code> </pre><br>  Der Daemon wird immer im Hauptthread ausgeführt, sodass dort ein Blockieren unvermeidlich ist.  Wenn Sie dies beispielsweise bei einer asynchronen Aufgabe tun, wird 10 Sekunden lang keine Sperre angezeigt. <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_async_task</span></span></span></span>(app_data: Arc&lt;Mutex&lt;MyDataModel&gt;&gt;, _: Arc&lt;()&gt;) { <span class="hljs-comment"><span class="hljs-comment">//  UI.  . thread::sleep(Duration::from_secs(10)); app_data.modify(|state| { state.counter += 10000; }); }</span></span></code> </pre><br>  Die Änderungsfunktion ruft lock () auf und der Mutex mit dem Datenmodell blockiert daher die Aktualisierung der Schnittstelle für die Dauer ihrer Ausführung. <br><br><h3>  Unsere Stile </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CUSTOM_CSS: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">" .row { height: 50px; } .orange { background: linear-gradient(to bottom, #f69135, #f37335); font-color: white; border-bottom: 1px solid #8d8d8d; }"</span></span>;</code> </pre><br><h3>  Tatsächlich Funktionen zum Erstellen unseres DOM, die dem Benutzer angezeigt werden sollen </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> azul::prelude::Layout <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ChatDataModel { <span class="hljs-comment"><span class="hljs-comment">//1 fn layout(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //2 if self.logged_in { self.chat_form(info) } else { self.login_form(info) } } } impl ChatDataModel { //3 fn login_form(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //4 let button = azul::widgets::button::Button::with_label("Login") //5 .dom() //6 .with_class("row") //7 .with_class("orange") //8 .with_callback( azul::prelude::On::MouseUp, azul::prelude::Callback(Controller::login_pressed)); //9 let port_label = azul::widgets::label::Label::new("Enter port to listen:") .dom() .with_class("row"); //10 let port = azul::widgets::text_input::TextInput::new() //11 .bind(info.window, &amp;self.login_model.port_input, &amp;self) .dom(&amp;self.login_model.port_input) .with_class("row"); // 9 let address_label = azul::widgets::label::Label::new("Enter server address:") .dom() .with_class("row"); //10 let address = azul::widgets::text_input::TextInput::new() //11 .bind(info.window, &amp;self.login_model.address_input, &amp;self) .dom(&amp;self.login_model.address_input) .with_class("row"); //12 azul::prelude::Dom::new(azul::prelude::NodeType::Div) .with_child(port_label) .with_child(port) .with_child(address_label) .with_child(address) .with_child(button) } //13 fn chat_form(&amp;self, info: azul::prelude::WindowInfo&lt;Self&gt;) -&gt; azul::prelude::Dom&lt;Self&gt; { //14 let button = azul::widgets::button::Button::with_label("Send") .dom() .with_class("row") .with_class("orange") .with_callback(azul::prelude::On::MouseUp, azul::prelude::Callback(Controller::send_pressed)); //15 let text = azul::widgets::text_input::TextInput::new() .bind(info.window, &amp;self.messaging_model.text_input_state, &amp;self) .dom(&amp;self.messaging_model.text_input_state) .with_class("row"); //12 let mut dom = azul::prelude::Dom::new(azul::prelude::NodeType::Div) .with_child(text) .with_child(button); //16 for i in &amp;self.messaging_model.messages { dom.add_child(azul::widgets::label::Label::new(i.clone()).dom().with_class("row")); } dom } }</span></span></code> </pre><br><ol><li>  Die Funktion, die das endgültige DOM erstellt und jedes Mal aufgerufen wird, wenn Sie die Schnittstelle neu zeichnen müssen. </li><li>  Wenn wir bereits mit dem Server verbunden sind, wird das Formular zum Senden und Lesen von Nachrichten angezeigt. Andernfalls wird das Formular zum Herstellen einer Verbindung zum Server angezeigt. </li><li>  Erstellt ein Formular zur Eingabe der Daten, die für die Verbindung zum Server erforderlich sind. </li><li>  Erstellen Sie eine Schaltfläche mit der Textbeschriftung Login. </li><li>  Konvertieren Sie es in ein DOM-Objekt. </li><li>  Fügen Sie die Zeilenklasse hinzu. </li><li>  Fügen Sie die CSS-Klasse Orange hinzu. </li><li>  Fügen Sie einen Ereignishandler hinzu, um auf die Schaltfläche zu klicken. </li><li>  Erstellen Sie eine Textbeschriftung mit Text, der dem Benutzer und der CSS-Klassenzeile angezeigt werden soll. </li><li>  Wir erstellen ein Textfeld für die Eingabe von Text mit Text aus der Eigenschaft unserer Modell- und CSS-Klassenzeile. </li><li>  Binden Sie das Textfeld an die Eigenschaft unseres DataModel.  Dies ist eine Zwei-Wege-Bindung.  Wenn Sie jetzt TextInput bearbeiten, wird der Text in der Eigenschaft unseres Modells automatisch geändert, und das Gegenteil ist auch der Fall.  Wenn wir den Text in unserem Modell ändern, ändert sich der Text in TextInput. </li><li>  Wir erstellen ein Root-DOM-Element, in das wir unsere UI-Elemente einfügen. </li><li>  Erstellt ein Formular zum Senden und Lesen von Nachrichten. </li><li>  Erstellen Sie eine Schaltfläche mit dem Text "Senden" und CSS mit den Klassen "Zeile", "Orange" und einem Ereignishandler, wenn Sie darauf klicken. </li><li>  Wir erstellen ein Texteingabefeld mit bidirektionaler Bindung mit der Modelleigenschaft self.messaging_model.text_input_state und css mit der Klasse "row". </li><li>  Fügen Sie Textbeschriftungen hinzu, die Nachrichten anzeigen, die im Chat geschrieben wurden. </li></ol><br><h3>  Unser Modell, das den Status unserer Schnittstelle speichert </h3><br>  In der Azul-Dokumentation heißt es, dass alle Anwendungsdaten, einschließlich der Verbindung zur Datenbank, gespeichert werden sollen. Daher habe ich einen UDP-Socket eingefügt. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//1 #[derive(Debug)] //2 struct ChatDataModel { //3 logged_in: bool, //4 messaging_model: MessagingDataModel, //5 login_model: LoginDataModel, } #[derive(Debug, Default)] struct LoginDataModel { //6 port_input: azul::widgets::text_input::TextInputState, //7 address_input: azul::widgets::text_input::TextInputState, } #[derive(Debug)] struct MessagingDataModel { //8 text_input_state: azul::widgets::text_input::TextInputState, //9 messages: Vec&lt;String&gt;, //10 socket: Option&lt;UdpSocket&gt;, //11 has_new_message: bool, }</span></span></code> </pre><br><ol><li>  Auf diese Weise können wir unsere Struktur als Zeichenfolge in einer Vorlage des Formulars {:?} Anzeigen. </li><li>  Unser Datenmodell.  Damit es in Azul verwendet werden kann.  Sie muss das Layout-Merkmal implementieren. </li><li>  Ein Flag, mit dem überprüft wird, ob der Benutzer mit dem Server verbunden ist oder nicht. </li><li>  Ein Modell zum Anzeigen eines Formulars zum Senden von Nachrichten an den Server und zum Speichern von vom Server empfangenen Nachrichten. </li><li>  Modell zum Anzeigen des Formulars für die Verbindung zum Server. </li><li>  Der Port, den der Benutzer eingegeben hat.  Wir werden es mit unserer Steckdose hören. </li><li>  Die vom Benutzer eingegebene Serveradresse.  Wir werden uns damit verbinden. </li><li>  Benutzermeldung.  Wir werden es an den Server senden. </li><li>  Ein Array von Nachrichten, die vom Server kamen. </li><li>  Der Socket, über den wir mit dem Server kommunizieren. </li><li>  Ein Flag, mit dem überprüft wird, ob eine neue Nachricht vom Server eingegangen ist. </li></ol><br><h3>  Und schließlich der Haupteinstiegspunkt für die Anwendung.  Startet einen Zyklus aus der GUI-Zeichnung und der Verarbeitung von Benutzereingaben </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//1 let app = azul::prelude::App::new(ChatDataModel { logged_in: false, messaging_model: MessagingDataModel { text_input_state: azul::widgets::text_input::TextInputState::new(""), messages: Vec::new(), socket: None, has_new_message: false, }, login_model: LoginDataModel::default(), }, azul::prelude::AppConfig::default()); // 2 let mut style = azul::prelude::css::native(); //3 style.merge(azul::prelude::css::from_str(CUSTOM_CSS).unwrap()); //4 let window = azul::prelude::Window::new(azul::prelude::WindowCreateOptions::default(), style).unwrap(); //5 app.run(window).unwrap(); }</span></span></code> </pre><br><ol><li>  Wir erstellen eine Anwendung mit Startdaten. </li><li>  Die von der Anwendung standardmäßig verwendeten Stile. </li><li>  Fügen Sie ihnen unsere eigenen Stile hinzu. </li><li>  Wir erstellen ein Fenster, in dem unsere Anwendung angezeigt wird. </li><li>  Starten Sie die Anwendung in diesem Fenster. </li></ol><br><h2>  Server </h2><br><h3>  Der Haupteinstiegspunkt für die Anwendung </h3><br>  Hier haben wir normalerweise eine Konsolenanwendung. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//1 let socket = create_socket(); //2 let (sx, rx) = mpsc::channel(); //3 start_sender_thread(rx, socket.try_clone().unwrap()); loop { //4 sx.send(read_data(&amp;socket)).unwrap(); } }</span></span></code> </pre><br><ol><li>  Erstellen Sie einen Socket. </li><li>  Wir erstellen einen Einwegkanal mit einem SX-Nachrichtensender und vielen RX-Empfängern. </li><li>  Wir senden Nachrichten an alle Empfänger in einem separaten Stream. </li><li>  Wir lesen die Daten vom Socket und senden sie an den Stream, der Nachrichten an mit dem Server verbundene Clients sendet. </li></ol><br><h3>  Funktion zum Erstellen eines Streams zum Senden von Nachrichten an Clients </h3><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_sender_thread</span></span></span></span>(rx: mpsc::Receiver&lt;(<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;, SocketAddr)&gt;, socket: UdpSocket) { <span class="hljs-comment"><span class="hljs-comment">//1 thread::spawn(move || { //2 let mut addresses = Vec::&lt;SocketAddr&gt;::new(); //3 loop { //4 let (bytes, pre) = rx.recv().unwrap(); // 5 if !addresses.contains(&amp;pre) { println!(" {} connected to server", pre); addresses.push(pre.clone()); } //6 let result = String::from_utf8(bytes) .expect("can't parse to String") .trim() .to_string(); println!("received {} from {}", result, pre); //7 let message = format!("FROM: {} MESSAGE: {}", pre, result); let data_to_send = message.as_bytes(); //8 addresses .iter() .for_each(|s| { //9 socket.send_to(data_to_send, s) //10 .expect(format!("can't send to {}", pre).as_str()); }); } }); }</span></span></code> </pre><br><ol><li>  Starten Sie einen neuen Thread.  Verschieben bedeutet, dass die Variablen das Lambda bzw. den Fluss übernehmen.  Insbesondere wird unser neuer Thread die RX- und Socket-Variablen "absorbieren". </li><li>  Eine Sammlung von Adressen, die von Kunden mit uns verbunden wurden.  Wir werden allen unsere Nachrichten senden.  Im Allgemeinen wäre es in einem realen Projekt erforderlich, einen Client von uns zu trennen und seine Adresse aus diesem Array zu entfernen. </li><li>  Wir starten eine Endlosschleife. </li><li>  Wir lesen die Daten aus dem Kanal.  Hier wird der Stream blockiert, bis neue Daten eintreffen. </li><li>  Wenn unser Array keine solche Adresse enthält, fügen Sie sie dort hinzu. </li><li>  Dekodieren Sie eine UTF8-Zeichenfolge aus einem Byte-Array. </li><li>  Wir erstellen eine Reihe von Bytes, die wir an alle unsere Kunden senden werden. </li><li>  Wir gehen die Adressensammlung durch und senden Daten an alle. </li><li>  Der Schreibvorgang in den UDP-Socket ist nicht blockierend, daher wartet die Funktion hier nicht, bis die Nachricht beim Empfänger eintrifft und fast sofort ausgeführt wird. </li><li>  Erwarten Sie im Fehlerfall einen Notausgang aus dem Programm mit der angegebenen Meldung. </li></ol><br><h3>  Die Funktion erstellt einen Socket basierend auf Benutzereingaben </h3><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TIMEOUT_IN_MILLIS: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span> = <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create_socket</span></span></span></span>() -&gt; UdpSocket { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Enter port to listen"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//1 let local_port: String = read!("{}\n"); let local_address = format!("127.0.0.1:{}", local_port.trim()); println!("server address {}", &amp;local_address); //2 let socket = UdpSocket::bind(&amp;local_address.trim()) .expect(format!("can't bind socket to {}", &amp;local_address).as_str()); //3 socket.set_read_timeout(Some(Duration::from_millis(TIMEOUT_IN_MILLIS))) .expect("can't set time out to read"); //4 socket }</span></span></code> </pre><br><ol><li>  Wir lesen den Port, den unser Server abhört, und erstellen darauf basierend eine lokale Serveradresse. </li><li>  Erstellen Sie einen UDP-Socket, der diese Adresse überwacht. </li><li>  Stellen Sie das Zeitlimit für den Lesevorgang ein.  Der Lesevorgang blockiert und blockiert den Stream, bis neue Daten eintreffen oder eine Zeitüberschreitung auftritt. </li><li>  Wir geben den erstellten Socket von der Funktion zurück. </li><li>  Die Funktion liest Daten aus dem Socket und gibt sie zusammen mit der Absenderadresse zurück. </li></ol><br><h3>  Funktion zum Lesen von Daten aus einem Socket </h3><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_data</span></span></span></span>(socket: &amp;UdpSocket) -&gt; (<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>&gt;, SocketAddr) { <span class="hljs-comment"><span class="hljs-comment">//1 let mut buf = [0u8; 4096]; //2 loop { match socket.recv_from(&amp;mut buf) { //3 Ok((count, address)) =&gt; { //4 return (buf[..count].into(), address); } //5 Err(e) =&gt; { println!("Error {}", e); continue; } }; } }</span></span></code> </pre><br><ol><li>  Der Puffer ist der Ort, an dem wir die Daten lesen werden. </li><li>  Startet eine Schleife, die ausgeführt wird, bis gültige Daten gelesen werden. </li><li>  Wir erhalten die Anzahl der gelesenen Bytes und die Absenderadresse. </li><li>  Wir schneiden das Array von Anfang an auf die Anzahl der gelesenen Bytes und konvertieren es in einen Bytevektor. </li><li>  Wenn ein Timeout oder ein anderer Fehler auftritt, fahren Sie mit der nächsten Iteration der Schleife fort. </li></ol><br><h2>  Informationen zu Ebenen in der Anwendung </h2><br><div class="spoiler">  <b class="spoiler_title">Offtopic: Ein kleines Bildungsprogramm für zwei Juni bei der Arbeit.</b>  <b class="spoiler_title">Ich habe beschlossen, es hier zu platzieren, vielleicht wird jemand nützlich sein.</b>  <b class="spoiler_title">June Sharp-Poets sind Beispiele in C # und wir sprechen über ASP.NET</b> <div class="spoiler_text">  Es gab also nichts zu tun, es war am Abend, und ich beschloss, ein kleines Bildungsprogramm über Architektur für Artem und Victor zu schreiben.  Nun, lass uns gehen. <br><br>  Eigentlich habe ich hier hinzugefügt, weil der Modus Aufklärung ist und ich nur einmal pro Woche Artikel schreiben kann und das Material bereits da ist und ich nächste Woche etwas anderes auf Habr hochladen wollte. <br><br>  In der Regel wird eine Anwendung geschichtet.  In jeder Ebene gibt es Objekte, die die Verhaltenscharakteristik der Ebene implementieren, in der sie sich befinden.  Und so.  Das sind die Schichten. <br><br><ol><li>  Präsentationsschicht. </li><li>  Layer-Geschäftslogik. </li><li>  Datenzugriffsschicht. </li><li>  Entitäten (Benutzer, Tier usw.) </li></ol><br><br>  Jede Schicht kann ein eigenes DTO und vollständig beliebige Klassen mit beliebigen Methoden enthalten.  Die Hauptsache ist, dass sie die Funktionalität ausführen, die der Ebene zugeordnet ist, in der sie sich befinden.  In einfachen Anwendungen fehlen möglicherweise einige der Ebenen.  Beispielsweise kann eine Ebenenansicht über das MVC-, MVP- und MVVM-Muster implementiert werden.  Welches ist völlig optional.  Die Hauptsache ist, dass die Klassen in dieser Schicht die der Schicht zugewiesene Funktionalität implementieren.  Denken Sie daran, Muster und Architektur sind nur Empfehlungen, keine Anweisungen.  Muster und Architektur sind kein Gesetz, dies ist ein Ratschlag. <br><br>  Daher betrachten wir jede Ebene am Beispiel einer Standard-ASP.NET-Anwendung unter Verwendung des Standard-Entity-Frameworks. <br><br><h3>  Präsentationsschicht </h3><br>  Wir haben MVC hier.  Dies ist die Ebene, die die Benutzerinteraktion ermöglicht.  Befehle kommen hierher und Benutzer erhalten Daten von hier.  Nicht unbedingt Menschen, wenn wir eine API haben, dann ist unser Benutzer ein anderes Programm.  Autos kommunizieren mit Autos. <br><br><h3>  Geschäftslogikschicht </h3><br>  Hier werden Klassen normalerweise als Service bezeichnet, z. B. UserService, obwohl es sich um alles handeln kann.  Nur eine Reihe von Klassen mit Methoden.  Hauptsache, hier finden die Berechnungen und Berechnungen unserer Anwendung statt.  Dies ist die dickste und sperrigste Schicht.  Es gibt den größten Teil des Codes und verschiedene Klassen.  Dies ist in der Tat unsere Anwendung. <br><br><h3>  Datenzugriffsschicht </h3><br>  Normalerweise implementiert EF hier Unit Of Work- und Repository-Muster.  Also ja, DbContext ist, sagen Sie, Unit Of Work, und DB legt fest, dass es sich um ein Repository handelt.  Dies ist in der Tat der Ort, an dem wir die Daten ablegen und von dem wir sie beziehen.  Unabhängig davon, ob die Datenquelle eine Datenbank, eine API einer anderen Anwendung, ein Cache im Speicher oder nur eine Art Zufallszahlengenerator ist.  Beliebige Datenquelle. <br><br><h3>  Entitäten </h3><br>  Ja, nur alle Arten von Benutzern, Tieren und mehr.  Ein wichtiger Punkt - sie haben möglicherweise nur ein Verhalten, das für sie charakteristisch ist.  Zum Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LastName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FullName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FirstName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + LastName; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">User user</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FullName == user.FullName; } }</code> </pre> <br><h3>  Nun, und ein sehr einfaches Beispiel.  Shoba war </h3><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-comment"><span class="hljs-comment">//Entities class User { public int Id { get; set; } public string Name { get; set; } } //Data Access Layer class UserRepository { private readonly Dictionary&lt;int, User&gt; _db; public UserRepository() { _db = new Dictionary&lt;int, User&gt;(); } public User Get(int id) { return _db[id]; } public void Save(User user) { _db[user.Id] = user; } } //Business Logic Layer class UserService { private readonly UserRepository _repo; private int _currentId = 0; public UserService() { _repo = new UserRepository(); } public void AddNew() { _currentId++; var user = new User { Id = _currentId, Name = _currentId.ToString() }; _repo.Save(user); } public string GetAll() { StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= _currentId; i++) { sb.AppendLine($"Id: {i} Name: {_repo.Get(i).Name}"); } return sb.ToString(); } } //presentation Layer aka Application Layer class UserController { private readonly UserService _service; public UserController() { _service = new UserService(); } public string RunExample() { _service.AddNew(); _service.AddNew(); return _service.GetAll(); } } namespace ConsoleApp1 { class Program { static void Main(string[] args) { var controller = new UserController(); Console.WriteLine(controller.RunExample()); Console.ReadLine(); } } }</span></span></code> </pre> <br></div></div><br><h2>  PS </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun, sho, ich möchte mich bei meiner Nastya für die Behebung von Grammatikfehlern im Artikel bedanken. </font><font style="vertical-align: inherit;">Also ja, Nastya, du bist nicht umsonst mit einem roten Diplom und im Allgemeinen cool. </font><font style="vertical-align: inherit;">Ich liebe dich &lt;3.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de433624/">https://habr.com/ru/post/de433624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de433610/index.html">Notizen eines Phytochemikers. Persimmon</a></li>
<li><a href="../de433612/index.html">FCC: SpaceX-Satelliten im Orbit - eine Quelle von Trümmern, die für die Bewohner der Erde gefährlich sind</a></li>
<li><a href="../de433614/index.html">So übernehmen Sie die Kontrolle über Ihre Netzwerkinfrastruktur. Kapitel Eins Aufbewahrung</a></li>
<li><a href="../de433618/index.html">"Warm Tube" Sound mit eigenen Händen. Was ist, wenn Sie ein Geschäft, einen Club und eine Werkstatt durchqueren?</a></li>
<li><a href="../de433620/index.html">Wie SystemUI in Android funktioniert</a></li>
<li><a href="../de433628/index.html">Feedback-Kultur: Wie man nicht in Anschuldigungen gerät</a></li>
<li><a href="../de433630/index.html">Ein Schritt näher am HIV-Impfstoff: Affentiter von serumneutralisierenden Antikörpern</a></li>
<li><a href="../de433632/index.html">Eine andere mobile Anwendung "leckte" die Daten ihrer Benutzer</a></li>
<li><a href="../de433634/index.html">Bienenstocküberwachung | Ich Dadan und Halbukrainer | Datenredundanz</a></li>
<li><a href="../de433636/index.html">Taschenlampen-Lade-Kubotan: eine gute Idee oder ein Dummy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>