<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📅 👧🏼 😬 9 conseils pour utiliser la bibliothèque Cats à Scala 👃🏽 🚵🏻 👃🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La programmation fonctionnelle dans Scala peut être difficile à maîtriser en raison de certaines caractéristiques syntaxiques et sémantiques du langag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>9 conseils pour utiliser la bibliothèque Cats à Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/448128/">  La programmation fonctionnelle dans Scala peut être difficile à maîtriser en raison de certaines caractéristiques syntaxiques et sémantiques du langage.  En particulier, certains des outils linguistiques et des moyens de mettre en œuvre ce que vous avez planifié avec l'aide des bibliothèques principales semblent évidents lorsque vous les connaissez - mais au tout début des études, en particulier par vous-même, il n'est pas si facile de les reconnaître. <br><br>  Pour cette raison, j'ai décidé qu'il serait utile de partager quelques conseils de programmation fonctionnelle dans Scala.  Les exemples et les noms correspondent aux chats, mais la syntaxe dans scalaz devrait être similaire en raison de la base théorique générale. <br><br><img src="https://habrastorage.org/webt/wf/n0/92/wfn0925sgvde-jv71ogsic_xuwk.jpeg"><br><a name="habracut"></a><br><h3>  <b>9) Constructeurs de méthode d'extension</b> </h3><br>  Commençons par, peut-être, l'outil le plus basique - les méthodes d'extension de tout type qui transforment une instance en Option, Soit, etc., en particulier: <br><br><ul><li> <code>.some</code> et la méthode correspondante du constructeur <code>none</code> pour <code>Option</code> ; </li><li>  <code>.asRight</code> , <code>.asLeft</code> pour <code>Either</code> ; </li><li>  <code>.valid</code> , <code>.invalid</code> , <code>.validNel</code> , <code>.invalidNel</code> pour <code>Validated</code> </li></ul><br>  Deux principaux avantages de leur utilisation: <br><br><ol><li>  Il est plus compact et plus compréhensible (puisque la séquence d'appels de méthode est enregistrée). </li><li>  Contrairement aux options de constructeur, les types de retour de ces méthodes sont étendus à un supertype, à savoir: </li></ol><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-string"><span class="hljs-string">"a"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Some[String] "a".some //Option[String]</span></span></code> </pre> <br>  Bien que l'inférence de type se soit améliorée au fil des ans et que le nombre de situations possibles dans lesquelles ce comportement aide le programmeur à rester calme a diminué, des erreurs de compilation dues à une frappe trop spécialisée sont toujours possibles dans Scala aujourd'hui.  Très souvent, le désir de se cogner la tête contre une table se manifeste lorsque vous travaillez avec <code>Either</code> (voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>Scala avec les chats,</u></a> chapitre 4.4.2). <br><br>  Une dernière chose sur le sujet: <code>.asRight</code> et <code>.asLeft</code> ont encore un paramètre de type supplémentaire.  Par exemple, <code>"1".asRight[Int]</code> est <code>Either[Int, String]</code> .  Si ce paramètre n'est pas fourni, le compilateur essaiera de le sortir et n'obtiendra <code>Nothing</code> .  Néanmoins, c'est plus pratique que de fournir les deux paramètres à chaque fois ou de ne pas en fournir non plus, comme dans le cas des constructeurs. <br><br><h3>  <b>8) Cinquante teintes *&gt;</b> </h3><br>  L'opérateur *&gt; défini dans n'importe quelle méthode <code>Apply</code> (c'est-à-dire dans <code>Applicative</code> , <code>Monad</code> , etc.) signifie simplement «traiter le calcul initial et remplacer le résultat par ce qui est spécifié dans le deuxième argument».  Dans la langue du code (dans le cas de <code>Monad</code> ): <br><br><pre> <code class="scala hljs">fa.flatMap(_ =&gt; fb)</code> </pre> <br>  Pourquoi utiliser un opérateur symbolique obscur pour une opération qui n'a pas d'effet notable?  En commençant à utiliser ApplicativeError et / ou MonadError, vous constaterez que l'opération conserve l'effet d'erreur pour l'ensemble du flux de travail.  Prenez <code>Either</code> comme exemple: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> success1 = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> success2 = <span class="hljs-string"><span class="hljs-string">"b"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> failure = <span class="hljs-number"><span class="hljs-number">400.</span></span>asLeft[<span class="hljs-type"><span class="hljs-type">String</span></span>] success1 *&gt; success2 <span class="hljs-comment"><span class="hljs-comment">//Right(b) success2 *&gt; success1 //Right(a) success1 *&gt; failure //Left(400) failure *&gt; success1 //Left(400)</span></span></code> </pre> <br>  Comme vous pouvez le constater, même en cas d'erreur, le calcul reste court-circuité.  *&gt; vous aidera à travailler avec des calculs différés dans les <code>Monix</code> , <code>IO</code> et similaires. <br><br>  Il y a une opération symétrique, &lt;*.  Donc, dans le cas de l'exemple précédent: <br><br><pre> <code class="scala hljs">success1 &lt;* success2 <span class="hljs-comment"><span class="hljs-comment">//Right(a)</span></span></code> </pre> <br>  Enfin, si l'utilisation des symboles vous est étrangère, il n'est pas nécessaire d'y recourir.  *&gt; Est juste un alias pour <code>productR</code> , et * &lt;est un alias pour <code>productL</code> . <br><br><h3>  <b>Remarque</b> </h3><br>  Dans une conversation personnelle, Adam Warski (merci, Adam!) A fait remarquer à juste titre qu'en plus de *&gt; ( <code>productR</code> ) il y a aussi &gt;&gt; de <code>FlatMapSyntax</code> .  &gt;&gt; est défini de la même manière que <code>fa.flatMap(_ =&gt; fb)</code> , mais avec deux nuances: <br><br><ul><li>  il est défini indépendamment de <code>productR</code> , et donc, si pour une raison quelconque le contrat de cette méthode change (théoriquement, il peut être changé sans violer les lois monadiques, mais je ne suis pas sûr de <code>MonadError</code> ), vous ne souffrirez pas; </li><li>  plus important encore, &gt;&gt; a un deuxième opérande appelé par appel par nom, c'est-à-dire  <code>fb: =&gt; F[B]</code> .  La différence de sémantique devient fondamentale si vous effectuez des calculs qui peuvent conduire à une explosion de pile. </li></ul><br>  Sur cette base, j'ai commencé à utiliser *&gt; plus souvent.  D'une manière ou d'une autre, n'oubliez pas les facteurs énumérés ci-dessus. <br><br><h3>  <b>7) Levez les voiles!</b> </h3><br>  Beaucoup prennent le temps de mettre le concept d' <code>lift</code> dans leur tête.  Mais quand vous réussirez, vous constaterez qu'il est partout. <br><br>  Comme de nombreux termes planant dans l'air de la programmation fonctionnelle, l' <code>lift</code> est venu de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">théorie des catégories</a> .  Je vais essayer d'expliquer: prendre une opération, changer la signature de son type pour qu'elle soit directement liée au type abstrait F. <br><br>  Dans Cats, l'exemple le plus simple est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Functor</a> : <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lift</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">B</span></span>](f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = map(_)(f)</code> </pre> <br>  Cela signifie: modifiez cette fonction pour qu'elle agisse sur le type de foncteur F. <br><br>  La fonction lift est souvent synonyme de constructeurs imbriqués pour un type donné.  Ainsi, <code>EitherT.liftF</code> est essentiellement <code>EitherT.right.</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exemple de Scaladoc</a> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data.<span class="hljs-type"><span class="hljs-type">EitherT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-type"><span class="hljs-type">EitherT</span></span>.liftF(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some) <span class="hljs-comment"><span class="hljs-comment">//EitherT(Some(Right(a))) EitherT.liftF(none[String]) //EitherT(None)</span></span></code> </pre> <br>  Cerise sur le gâteau: l' <code>lift</code> présent partout dans la bibliothèque standard de Scala.  L'exemple le plus populaire (et peut-être le plus utile dans le travail quotidien) est <code>PartialFunction</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intMatcher: <span class="hljs-type"><span class="hljs-type">PartialFunction</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"jak się masz!"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> liftedIntMatcher: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = intMatcher.lift liftedIntMatcher(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Some(jak się masz!) liftedIntMatcher(0) //None intMatcher(1) //jak się masz! intMatcher(0) //Exception in thread "main" scala.MatchError: 0</span></span></code> </pre> <br>  Nous pouvons maintenant passer à des questions plus urgentes. <br><br><h3>  <b>6) mapN</b> </h3><br>  <code>mapN</code> est une fonction d'aide utile pour travailler avec des tuples.  Encore une fois, ce n'est pas une nouveauté, mais un remplacement pour le bon vieil opérateur <code>|@|</code>  C'est un cri. <br><br>  Voici à quoi ressemble mapN dans le cas d'un tuple de deux éléments: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">// where t2: Tuple2[F[A0], F[A1]] def mapN[Z](f: (A0, A1) =&gt; Z)(implicit functor: Functor[F], semigroupal: Semigroupal[F]): F[Z] = Semigroupal.map2(t2._1, t2._2)(f)</span></span></code> </pre> <br>  En substance, cela nous permet de mapper des valeurs à l'intérieur d'un tuple de n'importe quel F qui sont un semi-groupe (produit) et un foncteur (carte).  Donc: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ (<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some, <span class="hljs-string"><span class="hljs-string">"b"</span></span>.some).mapN(_ ++ _) <span class="hljs-comment"><span class="hljs-comment">//Some(ab) (List(1, 2), List(3, 4), List(0, 2).mapN(_ * _ * _)) //List(0, 6, 0, 8, 0, 12, 0, 16)</span></span></code> </pre> <br>  Soit dit en passant, n'oubliez pas qu'avec les chats, vous obtenez une carte et une carte de <code>leftmap</code> pour les tuples: <br><br><pre> <code class="scala hljs">(<span class="hljs-string"><span class="hljs-string">"a"</span></span>.some, <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-string"><span class="hljs-string">"b"</span></span>,<span class="hljs-string"><span class="hljs-string">"c"</span></span>).mapN(_ ++ _)) <span class="hljs-comment"><span class="hljs-comment">//won't compile, because outer type is not the same ("a".some, List("b", "c")).leftMap(_.toList).mapN(_ ++ _) //List(ab, ac)</span></span></code> </pre> <br>  Une autre fonction <code>.mapN</code> utile <code>.mapN</code> instancier des classes de cas: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mead</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, honeyRatio: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span><span class="hljs-class"><span class="hljs-params">, agingYears: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Double</span></span></span></span></span><span class="hljs-class">) (</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">"półtorak".some, 0.5.some, 3d.some</span></span></span><span class="hljs-class">).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mapN</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Mead</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//Some</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Mead</span></span></span></span><span class="hljs-class"><span class="hljs-params">(półtorak,0.5,3.0</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br>  Bien sûr, vous utilisez plutôt l'opérateur de boucle for pour cela, mais mapN évite les transformateurs monadiques dans les cas simples. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.effect.<span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-comment"><span class="hljs-comment">//interchangable with eg Monix's Task type Query[T] = IO[Option[T]] def defineMead(qName: Query[String], qHoneyRatio: Query[Double], qAgingYears: Query[Double]): Query[Mead] = (for { name &lt;- OptionT(qName) honeyRatio &lt;- OptionT(qHoneyRatio) agingYears &lt;- OptionT(qAgingYears) } yield Mead(name, honeyRatio, agingYears)).value def defineMead2(qName: Query[String], qHoneyRatio: Query[Double], qAgingYears: Query[Double]): Query[Mead] = for { name &lt;- qName honeyRatio &lt;- qHoneyRatio agingYears &lt;- qAgingYears } yield (name, honeyRatio, agingYears).mapN(Mead)</span></span></code> </pre> <br>  Les méthodes ont des résultats similaires, mais cette dernière se passe de transformateurs monadiques. <br><br><h3>  <b>5) imbriqué</b> </h3><br>  <code>Nested</code> est essentiellement un double généralisé de transformateurs monades.  Comme son nom l'indique, il vous permet d'effectuer des opérations de pièce jointe sous certaines conditions.  Voici un exemple pour <code>.map(_.map( :</code> <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data.<span class="hljs-type"><span class="hljs-type">Nested</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someValue: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]] = <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight.some <span class="hljs-type"><span class="hljs-type">Nested</span></span>(someValue).map(_ * <span class="hljs-number"><span class="hljs-number">3</span></span>).value <span class="hljs-comment"><span class="hljs-comment">//Some(Right(aaa))</span></span></code> </pre> <br>  En plus de <code>Functor</code> , <code>Functor</code> généralise <code>Applicative</code> , <code>ApplicativeError</code> et <code>Traverse</code> .  Des informations supplémentaires et des exemples sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h3>  <b>4) .recover / .recoverWith / .handleError / .handleErrorWith / .valueOr</b> </h3><br>  La programmation fonctionnelle dans Scala a beaucoup à voir avec la gestion de l'effet d'erreur.  <code>ApplicativeError</code> et <code>MonadError</code> ont quelques méthodes utiles, et il peut être utile pour vous de découvrir les différences subtiles entre les quatre principales.  Donc, avec <code>ApplicativeError F[A]:</code> <br><br><ul><li>  <code>handleError</code> convertit <u>toutes les</u> erreurs au point d'appel en A selon la fonction spécifiée. </li><li>  <code>recover</code> actes d'une manière similaire, mais accepte des fonctions partielles, et peut donc convertir les erreurs que vous avez sélectionnées en A. </li><li>  <code>handleErrorWith</code> est similaire à <code>handleError</code> , mais son résultat devrait ressembler à <code>F[A]</code> , ce qui signifie qu'il vous aide à convertir les erreurs. </li><li>  <code>recoverWith</code> agit comme récupérer, mais nécessite également <code>F[A]</code> comme résultat. </li></ul><br>  Comme vous pouvez le voir, vous pouvez vous limiter à <code>handleErrorWith</code> et <code>recoverWith</code> , qui couvrent toutes les fonctions possibles.  Cependant, chaque méthode a ses avantages et est pratique à sa manière. <br><br>  En général, je vous conseille de vous familiariser avec l'API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ApplicativeError</a> , qui est l'une des plus riches en chats et héritée de MonadError - ce qui signifie qu'elle est prise en charge dans <code>cats.effect.IO</code> , <code>monix.Task</code> , etc. <br><br>  Il existe une autre méthode pour <code>Either/EitherT</code> , <code>Validated</code> et <code>Ior</code> - <code>.valueOr</code> .  Essentiellement, il fonctionne comme <code>.getOrElse</code> pour <code>Option</code> , mais est générique pour les classes contenant quelque chose «à gauche». <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> failure = <span class="hljs-number"><span class="hljs-number">400.</span></span>asLeft[<span class="hljs-type"><span class="hljs-type">String</span></span>] failure.valueOr(code =&gt; <span class="hljs-string"><span class="hljs-string">s"Got error code </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$code</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//"Got error code 400"</span></span></code> </pre> <br><h3>  <b>3) chats de ruelle</b> </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">alley-cats</a> est une solution pratique pour deux cas: <br><br><ul><li>  instances de classes de tuiles qui ne respectent pas leurs lois à 100%; </li><li>  Typklassy auxiliaire inhabituel, qui peut être utilisé correctement. </li></ul><br>  Historiquement, l'instance de monade pour <code>Try</code> plus populaire de ce projet, car <code>Try</code> , comme vous le savez, ne satisfait pas à toutes les lois monadiques en termes d'erreurs fatales.  Maintenant, il est vraiment présenté aux chats. <br><br>  Malgré cela, je vous recommande de vous familiariser avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><u>ce module</u></a> , il peut vous sembler utile. <br><br><h3>  <b>2) Traiter de manière responsable les importations</b> </h3><br>  Vous devez savoir - à partir de la documentation, du livre ou d'ailleurs - que les chats utilisent une hiérarchie d'importation spécifique: <br><br>  <code>cats.x</code> pour les <code>cats.x</code> de base (noyau); <br>  <code>cats.data</code> pour les types de données comme Validated, transformateurs <code>cats.data</code> , etc.; <br>  cats.syntax.x._ pour prendre en charge les méthodes d'extension afin que vous puissiez appeler sth.asRight, sth.pure, etc. <br> <code>cats.instances.x.</code>  _ d'importer directement l'implémentation de diverses classes de types dans la portée implicite de types concrets individuels afin que lors de l'appel, par exemple, sth.pure, l'erreur "implicite introuvable" ne se produise pas. <br><br>  Bien sûr, vous avez remarqué l'importation de <code>cats.implicits._</code> , qui importe toute la syntaxe et toutes les instances de la classe type dans une portée implicite. <br><br>  En principe, lors du développement avec Cats, vous devez commencer par une certaine séquence d'importations de la FAQ, à savoir: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.data._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.implicits._</code> </pre> <br>  Si vous apprenez à mieux connaître la bibliothèque, vous pouvez la combiner à votre goût.  Suivez une règle simple: <br><br><ul><li>  <code>cats.syntax.x</code> fournit une syntaxe d'extension liée à x; </li><li>  <code>cats.instances.x</code> fournit des classes d'instance. </li></ul><br>  Par exemple, si vous avez besoin de <code>.asRight</code> , qui est une méthode d'extension pour <code>Either</code> , procédez comme suit: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.syntax.either._ <span class="hljs-string"><span class="hljs-string">"a"</span></span>.asRight[<span class="hljs-type"><span class="hljs-type">Int</span></span>] <span class="hljs-comment"><span class="hljs-comment">//Right[Int, String](a)</span></span></code> </pre> <br>  En revanche, pour obtenir <code>Option.pure</code> vous devez importer <code>cats.syntax.monad</code> <b>ET</b> <code>cats.instances.option</code> : <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.syntax.applicative._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cats.instances.option._ <span class="hljs-string"><span class="hljs-string">"a"</span></span>.pure[<span class="hljs-type"><span class="hljs-type">Option</span></span>] <span class="hljs-comment"><span class="hljs-comment">//Some(a)</span></span></code> </pre> <br>  En optimisant manuellement votre importation, vous limiterez les étendues implicites dans vos fichiers Scala et réduirez ainsi le temps de compilation. <br><br>  Cependant, veuillez ne pas le faire si les conditions suivantes ne sont pas remplies: <br><br><ul><li>  vous avez déjà bien maîtrisé les chats </li><li>  votre équipe possède la bibliothèque au même niveau </li></ul><br>  Pourquoi?  Parce que: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   `pure`, //    import cats.implicits._ import cats.instances.option._ "a".pure[Option] //could not find implicit value for parameter F: cats.Applicative[Option]</span></span></code> </pre> <br>  En effet, les <code>cats.implicits</code> et <code>cats.instances.option</code> sont des extensions de <code>cats.instances.OptionInstances</code> .  En fait, nous importons sa portée implicite deux fois, que nous confondons le compilateur. <br><br>  De plus, il n'y a pas de magie dans la hiérarchie des implicites - c'est une séquence claire d'extensions de type.  Il vous suffit de vous référer à la définition de <code>cats.implicits</code> et d'examiner la hiérarchie des types. <br><br>  Pendant 10 à 20 minutes, vous pouvez l'étudier suffisamment pour éviter de tels problèmes - croyez-moi, cet investissement sera certainement payant. <br><br><h3>  <b>1) N'oubliez pas les mises à jour des chats!</b> </h3><br>  Vous pourriez penser que votre bibliothèque FP est intemporelle, mais en fait, les <code>cats</code> et les <code>scalaz</code> à jour activement.  Prenons l'exemple des chats.  Voici juste les derniers changements: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous n'avez plus besoin d'attribuer d'exception Throwable lors de l'utilisation de raiseError</a> ; </li><li>  Il existe maintenant des instances pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Duration</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FiniteDuration</a> , ce qui signifie que vous pouvez utiliser d1&gt; d2 sans utiliser de bibliothèques externes; </li><li>  ainsi qu'un tas d'autres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">petites et grandes innovations</a> . </li></ul><br>  Par conséquent, lorsque vous travaillez avec des projets, n'oubliez pas de vérifier la version de la bibliothèque, de lire les notes des nouvelles versions et de les mettre à jour à temps. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448128/">https://habr.com/ru/post/fr448128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448118/index.html">SEO et publicité contextuelle - conduit pour 175 mille roubles par jour à Izhevsk</a></li>
<li><a href="../fr448120/index.html">À propos de la proximité des sommets</a></li>
<li><a href="../fr448122/index.html">Comment ReactJS fonctionne Forfait React</a></li>
<li><a href="../fr448124/index.html">Mikrotik. Contrôle SMS à l'aide du serveur WEB</a></li>
<li><a href="../fr448126/index.html">Secrets de l'API des appareils Android. Rapport Yandex</a></li>
<li><a href="../fr448130/index.html">Conception de deckbuilding de jeux vidéo</a></li>
<li><a href="../fr448136/index.html">Instructions: comment tester les rôles ansibles et découvrir les problèmes avant la production</a></li>
<li><a href="../fr448140/index.html">SNA Hackathon 2019 - résultats</a></li>
<li><a href="../fr448142/index.html">Où convergent preuves, faits et imagination</a></li>
<li><a href="../fr448144/index.html">NASA: les changements génétiques causés par les voyages dans l'espace sont temporaires</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>