<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐗 👩🏽‍🤝‍👩🏼 🙋🏽 PVS-Studio代码分析器中用于搜索错误和潜在漏洞的技术 👩🏼‍🎓 🙏🏼 💑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="简要描述了PVS-Studio工具中使用的技术，这些技术可以有效地检测大量错误模式和潜在漏洞。 本文介绍了用于C和C ++代码的分析器的实现，但是，以上信息对于负责分析C＃和Java代码的模块也有效。 

 引言 
 人们误解为静态代码分析器是非常简单的程序，它基于使用正则表达式搜索代码模式。 这与...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio代码分析器中用于搜索错误和潜在漏洞的技术</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/430604/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a1/4fa/337/7a14fa3372efbf1ac176cf551b982a81.png" alt="技术与魔力"></div><br> 简要描述了PVS-Studio工具中使用的技术，这些技术可以有效地检测大量错误模式和潜在漏洞。 本文介绍了用于C和C ++代码的分析器的实现，但是，以上信息对于负责分析C＃和Java代码的模块也有效。 <br><a name="habracut"></a><br><h2> 引言 </h2><br> 人们误解为静态代码分析器是非常简单的程序，它基于使用正则表达式搜索代码模式。 这与事实相去甚远。 此外，根本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不可能</a>使用正则表达式来识别绝大多数错误。 <br><br> 该错误是根据程序员在使用10到20年前存在的某些工具时的经验得出的。 实际上，工具的工作往往归结为寻找危险的代码和功能模式，例如<i>strcpy</i> ， <i>strcat</i>等。 作为此类工具的代表，可以称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RATS</a> 。 <br><br> 尽管这些工具可能有用，但它们通常是愚蠢且无效的。 正是从那个时候开始，许多程序员仍然记忆犹新，静态分析器是非常无用的工具，对工作的干扰大于帮助。 <br><br> 随着时间的流逝，静态分析器开始构成复杂的解决方案，这些解决方案可以进行深入的代码分析，即使经过仔细的代码审查，也可以发现代码中仍然存在的错误。 不幸的是，由于过去的负面经验，许多程序员仍然认为静态分析方法没有用，并且不急于将其引入开发过程。 <br><br> 在本文中，我将尝试解决此问题。 我要求读者花15分钟来熟悉PVS-Studio静态代码分析器中用于检测错误的技术。 也许之后，您将重新研究静态分析工具，并希望将其应用到您的工作中。 <br><br><h2> 数据流分析 </h2><br> 通过分析数据流，您可以发现各种错误。 其中包括：超出数组范围，内存泄漏，始终为true / false条件，取消引用空指针等。 <br><br> 此外，数据分析可用于搜索使用从外部进入程序的未经验证的数据时的情况。 攻击者可以准备这样的一组输入数据，以使程序按其所需的方式运行。 换句话说，它可以将输入控制不足的错误用作漏洞。 为了在PVS-Studio中搜索未经验证的数据的使用， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">已</a>实施了专门的诊断程序<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V1010，</a>并将继续对其进行改进。 <br><br> 数据流分析（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Data-Flow Analysis</a> ）是为了计算计算机程序中各个点上变量的可能值。 例如，如果指针已取消引用，并且已知此时它可以为零，则这是一个错误，并且静态分析器将报告该错误。 <br><br> 让我们看一个使用数据流分析查找错误的实际示例。 摆在我们面前的是协议缓冲区（protobuf）项目的功能，该功能旨在检查日期的正确性。 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDateTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DateTime&amp; time)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.year &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.year &gt; <span class="hljs-number"><span class="hljs-number">9999</span></span> || time.month &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.month &gt; <span class="hljs-number"><span class="hljs-number">12</span></span> || time.day &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> || time.day &gt; <span class="hljs-number"><span class="hljs-number">31</span></span> || time.hour &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.hour &gt; <span class="hljs-number"><span class="hljs-number">23</span></span> || time.minute &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.minute &gt; <span class="hljs-number"><span class="hljs-number">59</span></span> || time.second &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || time.second &gt; <span class="hljs-number"><span class="hljs-number">59</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.month &lt;= kDaysInMonth[time.month]; } }</code> </pre> <br>  PVS-Studio分析仪立即检测到该功能中的两个逻辑错误，并显示以下消息： <br><br><ul><li>  V547 / CWE-571表达式'time.month &lt;= kDaysInMonth [time.month] + 1'始终为true。  time.cc 83 </li><li>  V547 / CWE-571表达式'time.month &lt;= kDaysInMonth [time.month]'始终为true。  time.cc 85 </li></ul><br> 注意子表达式“ time.month &lt;1 ||  time.month&gt; 12“。 如果<i>月份</i>值超出[1..12]范围，则​​该函数停止工作。 分析器对此进行了考虑，并且知道如果第二条<i>if语句</i>开始执行，那么<i>月份</i>值恰好在[1..12]范围内。 同样，他知道其他变量的范围（年，日等），但现在对我们来说这些变量已不再引起我们的兴趣。 <br><br> 现在，让我们看一下用于访问数组元素的两个相同的运算符： <i>kDaysInMonth [time.month]</i> 。 <br><br> 该数组是静态设置的，分析器知道其所有元素的值： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kDaysInMonth[<span class="hljs-number"><span class="hljs-number">13</span></span>] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span> };</code> </pre> <br> 由于月份从1开始编号，因此分析仪不会在数组开头考虑0。 事实证明，可以从数组中提取[28..31]范围内的值。 <br><br> 视年份是否为a年而定，天数加1，但这对我们来说现在也没有意义。 比较本身很重要： <br><br><pre> <code class="cpp hljs">time.month &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; time.month &lt;= kDaysInMonth[time.month];</code> </pre> <br> 将范围[1..12]（月数）与一个月中的天数进行比较。 <br><br> 考虑到在第一种情况下，月份始终是2月（ <i>time.month == 2</i> ），我们得到了以下范围的比较： <br><br><ul><li>  2 &lt;= 29 </li><li>  [1..12] &lt;= [28..31] </li></ul><br> 如您所见，比较结果始终是真实的，这就是PVS-Studio分析仪所警告的。 实际上，该代码包含两个相同的错字。 表达式的左侧应使用<i>day</i>类的成员，而不是<i>一个月</i> 。 <br><br> 正确的代码应如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (time.month == <span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; IsLeapYear(time.year)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month] + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> time.day &lt;= kDaysInMonth[time.month]; }</code> </pre> <br> 前面在文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2月31日</a> ”中也描述了此处讨论的错误<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">。</a> <br><br><h2> 符号执行 </h2><br> 在上一节中，我们考虑了一种分析器计算变量的可能值的方法。 但是，要发现一些错误，就不必知道变量的值。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">符号执行</a>意味着以符号形式求解方程式。 <br><br> 我在我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">错误数据库中</a>找不到合适的演示，因此请考虑一个综合代码示例。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> B)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == B) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / (A - B); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  PVS-Studio分析仪会生成警告V609 / CWE-369除以零。 分母'A-B'== 0. test.cpp 12 <br><br> 分析器未知变量<i>A</i>和<i>B</i>的值。 但是分析器知道在计算表达式<i>10 /（A-B）时，</i>变量<i>A</i>和<i>B</i>相等。 因此，将被0除。 <br><br> 我说过<i>A</i>和<i>B</i>的值<i>是</i>未知的。 对于一般情况，这是正确的。 但是，如果分析器看到带有特定实际参数值的函数调用，则它将对此加以考虑。 考虑一个例子： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Div</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> / X; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i) Div(i); }</code> </pre> <br>  PVS-Studio分析仪警告除以零：V609 CWE-628除以零。 分母'X'==0。'Div'函数处理值'[0..4]'。 检查第一个参数。 检查行：106、110。consoleapplication2017.cpp 106 <br><br> 混合技术已经在这里起作用：数据流分析，符号执行和自动方法注释（我们将在下一节中讨论该技术）。 分析器发现变量<i>X</i>在<i>Div</i>函数中用作除数。 基于此，将自动为<i>Div</i>函数构建一个特殊的注释。 还应考虑将值范围[0..4]作为参数<i>X</i>传递给函数<i>。</i> 分析仪得出结论认为应该除以0。 <br><br><h2> 方法注释 </h2><br> 我们的团队已经注释了数千种功能和提供的类： <br><br><ul><li>  Winapi </li><li>  C标准库 </li><li> 标准模板库（STL）， </li><li>  glibc（GNU C库） </li><li>  t </li><li> 制造商 </li><li>  zlib </li><li>  libpng </li><li>  Openssl </li><li> 依此类推 </li></ul><br> 所有功能均手动注释，这使您可以设置许多对于发现错误很重要的特征。 例如，指定传递给<i>fread</i>函数的缓冲区的大小应不小于计划从文件读取的字节数。 还指出了第二，第三自变量与函数可以返回的值之间的关系。 一切看起来像这样： <br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d4/a9c/684/4d4a9c6844fcfa694009f2ccace9d436.png" alt="PVS-Studio：功能标记"></div><br> 由于有了这个注释，下面使用<i>fread</i>函数的代码将立即显示两个错误。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FILE *f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = fread(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>), <span class="hljs-number"><span class="hljs-number">1000</span></span>, f); buf[i] = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  PVS-Studio警告： <ul><li>  V512 CWE-119调用'fread'函数将导致缓冲区'buf'溢出。  test.cpp 116 </li><li>  V557 CWE-787阵列可能超限。  “ i”索引的值可能达到1000。test.cpp 117 </li></ul><br> 首先，分析器将第二个和第三个实际参数相乘，然后计算出该函数最多可以读取1000个字节的数据。 在这种情况下，缓冲区大小仅为100字节，并且可能会溢出。 <br><br> 其次，由于该函数最多可以读取1000个字节，因此变量<i>i</i>的可能值的范围为[0..1000]。 因此，对数组的访问可能在错误的索引处发生。 <br><br> 让我们看一个错误的另一个简单示例，由于<i>memset</i>函数的标记，使得检测错误成为可能。 这是CryEngine V.项目的代码片段 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnableFloatExceptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... CONTEXT ctx; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;ctx, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ctx), <span class="hljs-number"><span class="hljs-number">0</span></span>); .... }</code> </pre> <br>  PVS-Studio分析仪发现了一个错字：V575'memset'函数处理'0'元素。 检查第三个论点。  crythreadutil_win32.h 294 <br><br> 混淆了函数的第二和第三参数。 结果，该函数处理0个字节且不执行任何操作。 分析仪会注意到此异常，并警告程序员。 我们先前在文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">期待已久的CryEngine V验证</a> ”中描述了此错误。 <br><br>  PVS-Studio分析仪不仅限于我们手动设置的注释。 此外，他通过研究功能主体独立尝试创建注释。 这使您可以发现错误使用功能的错误。 例如，分析器记住一个函数可以返回nullptr。 如果不经初步检查就使用了此函数返回的指针，则分析仪将对此发出警告。 一个例子： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GlobalInt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (rand() % <span class="hljs-number"><span class="hljs-number">2</span></span>) ? <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> : &amp;GlobalInt; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Use</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *Get() = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br> 警告：V522 CWE-690可能会取消引用潜在的空指针“ Get（）”。  test.cpp 129 <br><br>  <b>注意事项</b> 您可以采用相反的方法来寻找刚刚检查过的错误。 什么都不记得了，每次遇到对<i>Get</i>函数的调用时，都要在知道实际参数的情况下对其进行分析。 从理论上讲，这种算法可让您发现更多错误，但它具有指数级的复杂性。 程序分析时间增长了十万倍，从实际的角度来看，我们认为这种方法是死胡同。 在PVS-Studio中，我们正在开发自动标注功能的方向。 <br><br><h2> 模式匹配 </h2><br> 乍一看，与模式匹配的技术似乎是对正则表达式的搜索。 实际上，事实并非如此，而且一切都更加复杂。 <br><br> 首先，正如我已经<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说过的</a> ，正则表达式通常毫无价值。 其次，分析器不使用文本行，而是使用语法树，这使人们可以识别更复杂和更高级的错误模式。 <br><br> 考虑两个例子，一个简单，一个复杂。 我在检查Android的源代码时发现的第一个错误。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TagMonitor::parseTagsToMonitor(String8 tagNames) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; lock(mMonitorMutex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> end = tagNames.find(<span class="hljs-string"><span class="hljs-string">","</span></span>, idx); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* start = tagNames.lockBuffer(tagNames.size()); start[idx] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; .... } .... }</code> </pre> <br>  PVS-Studio分析器可以识别与程序员对C ++中操作优先级的误解有关的经典错误模式：V593 / CWE-783考虑查看“ A = B！= C”类型的表达式。 该表达式的计算公式如下：“ A =（B！= C）”。  TagMonitor.cpp 50 <br><br> 仔细看看这一行： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> idx = tagNames.find(<span class="hljs-string"><span class="hljs-string">"3a"</span></span>) != <span class="hljs-number"><span class="hljs-number">-1</span></span>) {</code> </pre> <br> 程序员假定在开始时执行了赋值，然后才与<i>-1</i>进行比较。 实际上，比较是第一位的。 经典版 有关Android验证的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章中</a>对此错误进行了更详细的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述</a> （请参见“其他错误”一章）。 <br><br> 现在考虑更高级别的模式匹配选项。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  PVS-Studio警告：V597 CWE-14编译器可能会删除“ memset”函数调用，该函数调用用于刷新“ chunkBuffer”缓冲区。  RtlSecureZeroMemory（）函数应用于擦除私有数据。 第189章 <br><br> 问题的实质是使用<i>memset</i>函数将缓冲区填充为零后，此缓冲区在任何地方都不会使用。 在编译带有优化标志的代码时，编译器将确定此函数调用是多余的，并将其删除。 他有权这样做，因为从C ++语言的角度来看，调用函数在程序上没有任何可观察到的行为。 填充<i>chunkBuffer</i>缓冲区后， <i>sha1ProcessChunk</i>函数立即结束。 由于缓冲区是在堆栈上创建的，因此退出函数后，它将无法使用。 因此，从编译器的角度来看，用零填充是没有意义的。 <br><br> 结果，堆栈上的某个地方将保留私有数据，这可能会导致麻烦。 在文章“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安全清除私有数据</a> ”中将详细讨论此主题。 <br><br> 这是高级模式匹配的示例。 首先，分析器应意识到此安全漏洞的存在，该漏洞根据“常见漏洞枚举”分类为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CWE-14：清除代码的编译器删除缓冲区</a> 。 <br><br> 其次，它必须在代码中找到在堆栈上创建缓冲区的所有位置，并使用<i>memset</i>函数将其擦除，并且不能在其他任何地方使用它。 <br><br><h2> 结论 </h2><br> 如您所见，静态分析是一种非常有趣且有用的方法。 它使您可以尽早消除大量错误和潜在漏洞（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SAST</a> ）。 如果您仍然不完全了解静态分析，那么我邀请您阅读我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客</a> ，我们在其中定期分析使用PVS-Studio在各个项目中发现的错误。 您根本不能保持冷漠。 <br><br> 我们很高兴在您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的客户中</a>看到您的公司，并帮助您改善应用程序，使其更可靠，更安全。 <br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br> 如果您想与说英语的读者分享这篇文章，请使用以下链接：Andrey Karpov。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PVS-Studio代码分析器中用于查找错误和潜在漏洞的技术</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430604/">https://habr.com/ru/post/zh-CN430604/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430590/index.html">在德国，制定了家用路由器的要求</a></li>
<li><a href="../zh-CN430592/index.html">QEMU隔离虚拟机中的客户端Internet使用SPICE通道上的端口隧道</a></li>
<li><a href="../zh-CN430596/index.html">如何制定产品策略？ 产品经理指南</a></li>
<li><a href="../zh-CN430600/index.html">火星-从巧克力到机器人</a></li>
<li><a href="../zh-CN430602/index.html">Etherium智能合约中的漏洞。 代码示例</a></li>
<li><a href="../zh-CN430606/index.html">IB组网络研讨会：“对Windows上的RDP工件进行法医调查”</a></li>
<li><a href="../zh-CN430610/index.html">如何安全摆脱电子设备</a></li>
<li><a href="../zh-CN430612/index.html">在1980年代，人们如何从电台下载游戏</a></li>
<li><a href="../zh-CN430614/index.html">Madrobots黑色星期五2018年。</a></li>
<li><a href="../zh-CN430616/index.html">11月27日，莫斯科“测试与监视”研讨会</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>