<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧔🏼 🤾 💇🏻 Comment Typescript m'a-t-il déçu et cela en vaut-il la peine? 🖼️ 👩🏼 👶🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Avant de commencer, je tiens à mentionner que je suis un fan de TypeScript. C'est mon langage de programmation principal pour les projets front-end su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment Typescript m'a-t-il déçu et cela en vaut-il la peine?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vdsina/blog/485206/"><img src="https://habrastorage.org/webt/3w/bb/rv/3wbbrvcbnytxte0qcz54gsibk10.png"><br><br>  Avant de commencer, je tiens à mentionner que je suis un fan de TypeScript.  C'est mon langage de programmation principal pour les projets front-end sur React et pour tout travail backend que je fais dans Node.  Je suis complètement pour Typescript, mais il y a des moments qui me dérangent et dont je voulais raconter cet article. <br><a name="habracut"></a><br>  J'ai écrit exclusivement sur TypeScript au cours des trois dernières années pour de nombreuses entreprises différentes, donc à mon avis, TypeScript fait au moins quelque chose de bien ou ferme certains besoins. <br><br>  Malgré son imperfection, TypeScript est entré dans le développement frontal principal et se classe septième dans la liste des langages de programmation les plus populaires selon le <a href="https://research.hackerrank.com/developer-skills/2019">rapport sur les compétences des développeurs HackerRank</a> . <br><br>  Toute équipe de développement, qu'elle soit grande ou petite, écrit en TypeScript ou non, en vaut toujours la peine pour la sécurité: <br><br><ul><li>  Assurez-vous que les tests unitaires bien écrits couvrent autant de code que possible en production. </li><li>  Utilisez la programmation par paires: une paire d'yeux supplémentaire aidera à détecter des choses plus graves que de simples erreurs de syntaxe </li><li>  Construisez qualitativement un processus de révision de code et identifiez les erreurs que la machine ne peut pas trouver </li><li>  Utilisez linter - comme eslint </li></ul><br>  Bien que TypeScript ajoute un niveau de sécurité supplémentaire en plus de tout cela, mais à mon avis, il est très loin derrière les autres langages à cet égard.  Je vais vous expliquer pourquoi. <br><br><h2>  TypeScript n'est pas un système de type fiable </h2><br>  Je pense que cela peut être le principal problème avec TypeScript, mais permettez-moi d'abord de déterminer quels <i>sont les systèmes de type</i> <i>fiables</i> et <i>non fiables</i> . <br><br><h3>  Système de type robuste </h3><br>  <i>Un</i> système de type <i>fiable</i> garantit que votre programme ne se retrouve pas dans des états non valides.  Par exemple, si le type statique d'une expression est une <i>chaîne</i> , lorsqu'elle est évaluée au moment de l'exécution, vous êtes assuré d'obtenir uniquement une <i>chaîne</i> . <br><br>  Dans un système de type fiable, vous ne serez jamais dans une situation où l'expression ne correspond pas au type attendu, ni au moment de la compilation ni au moment de l'exécution. <br><br>  Bien sûr, il existe différents degrés de fiabilité, ainsi que diverses interprétations de la fiabilité.  TypeScript est quelque peu fiable et détecte les erreurs de type: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Type 'string' is not assignable to type 'number' const increment = (i: number): number =&gt; { return i + "1"; } // Argument of type '"98765432"' is not assignable to parameter of type 'number'. const countdown: number = increment("98765432");</span></span></code> </pre> <br><h3>  Système de type non sécurisé </h3><br>  Tapuscrit déclare ouvertement que la fiabilité à 100% n'est pas son objectif.  Même le numéro «non cible» 3 sur la liste «non cible» de <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals">TypeScript</a> indique clairement: <br><blockquote>  Avoir un système de type fiable ou «prouvablement correct» n'est pas notre objectif.  Au lieu de cela, nous nous efforçons de trouver un équilibre entre précision et performances. </blockquote><br>  Cela signifie qu'il n'y a aucune garantie que la variable est d'un type spécifique au moment de l'exécution.  Je peux illustrer cela avec l'exemple un peu artificiel suivant: <br><br><pre> <code class="javascript hljs">interface A { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: number; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a: A = {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b: {<span class="hljs-attr"><span class="hljs-attr">x</span></span>: number | string} = a; bx = <span class="hljs-string"><span class="hljs-string">"unsound"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: number = ax; <span class="hljs-comment"><span class="hljs-comment">// unsound axtoFixed(0); // WTF is it?</span></span></code> </pre> <br>  Le code ci-dessus ne fonctionne pas, car il est connu que <i>ax</i> est un nombre de l'interface <i>A.</i>  Malheureusement, après quelques feintes avec réaffectation, il se transforme en chaîne et ce code se compile, mais avec des erreurs au moment de l'exécution. <br><br>  Malheureusement, cette expression se compile sans erreur: <br><br><pre> <code class="javascript hljs">axtoFixed(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Cette fiabilité n'est pas l'objectif du langage est probablement l'un des plus gros problèmes de TypeScript.  Je reçois toujours beaucoup d'erreurs d'erreur d'exécution lors de l'exécution que le compilateur <i>tsc</i> ne <i>détecte</i> pas, mais que le compilateur aurait remarqué si un système de type fiable existait dans TypeScript.  TypeScript est maintenant un pied dans le camp des langages "fiables", et l'autre dans le "peu fiable".  Cette approche de demi-mesure est basée sur <i>n'importe quel</i> type, dont je parlerai plus tard. <br><br>  Je suis frustré par le fait que le nombre de tests que j'écris n'a pas diminué du tout avec la transition vers TypeScript.  Quand je viens de commencer, j'ai décidé par erreur que je pouvais réduire la routine fastidieuse d'écrire un grand nombre de tests unitaires. <br><br>  TypeScript conteste l'état actuel des choses en faisant valoir que la réduction des coûts cognitifs lors de l'utilisation de types est plus importante que la fiabilité. <br><br>  Je comprends pourquoi TypesScript a choisi un tel chemin et il y a une opinion que TypeScript ne serait pas si populaire si la fiabilité du système de type était garantie à 100%.  Cette opinion n'a pas résisté au test - <a href="https://dart.dev/">le langage Dart</a> gagne rapidement en popularité, ainsi que l'utilisation généralisée de Flutter.  Et <a href="https://dart.dev/guides/language/sound-dart">on fait valoir</a> que la fiabilité des types est l'objectif de Dart. <br><br>  L'insécurité et les différentes façons dont TypeScript fournit une «sortie d'urgence» de la frappe forte le rendent moins efficace et, malheureusement, le rendent <b>«mieux que rien»</b> pour le moment.  Je serais heureux si à mesure que TypeScript gagnait en popularité, davantage d'options de compilateur devenaient disponibles, permettant aux utilisateurs expérimentés de rechercher une fiabilité à 100%. <br><br><h2>  TypeScript ne garantit aucune vérification de type lors de l'exécution </h2><br>  La vérification de type à l'exécution n'est pas l'objectif de TypeScript, donc mon souhait ne se réalisera probablement jamais.  La vérification du type au moment de l'exécution est utile, par exemple, lorsque vous travaillez avec des données JSON renvoyées par des appels d'API.  Il serait possible de se débarrasser de toute une catégorie d'erreurs et de nombreux tests unitaires, si nous pouvions contrôler ces processus au niveau du système de type. <br><br>  Comme nous ne pouvons rien garantir lors de l'exécution, cela peut facilement se produire: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFullName = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (): <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person: AxiosResponse = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> api(); <span class="hljs-comment"><span class="hljs-comment">//response.name.fullName may result in undefined at runtime return response.name.fullName }</span></span></code> </pre><br>  Il existe quelques bibliothèques d'assistance comme <a href="https://github.com/gcanti/io-ts">io-ts</a> , ce qui est génial, mais cela peut signifier que vous devez dupliquer vos modèles. <br><br><h2>  Type effrayant toute option stricte </h2><br>  Le type any signifie "any" et le compilateur autorise toute opération ou affectation d'une variable de ce type. <br><br>  TypeScript fonctionne bien pour les petites choses, mais les gens ont tendance à mettre le type any sur tout ce qui prend plus d'une minute.  J'ai récemment travaillé sur un projet Angular et j'ai vu beaucoup de code comme celui-ci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ public _id: any; public name: any; public icon: any;</code> </pre> <br>  TypeScript vous permet d'oublier le système de type. <br><br>  Vous pouvez casser le type de n'importe quoi avec <i>n'importe quel</i> : <br><br><pre> <code class="javascript hljs">(<span class="hljs-string"><span class="hljs-string">"oh my goodness"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> any).ToFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// remember what I said about soundness?</span></span></code> </pre> <br>  L'option <i>stricte</i> inclut les options de compilation suivantes, qui rendent tout plus fiable: <br><br><ul><li>  --strictNullChecks </li><li>  --noImplicitAny </li><li>  --noImplicitThis </li><li>  --toujoursStrict </li></ul><br>  Il existe également une règle eslint <a href="">@ typescript-eslint / no-explicit-any</a> . <br><br>  La distribution de <i>tout</i> peut ruiner la fiabilité de votre code. <br><br><h2>  Conclusion </h2><br>  Je dois répéter que je suis un fan de TypeScript et que je l'utilise dans mon travail quotidien, mais je pense qu'il est imparfait et que le battage médiatique qui l'entoure n'est pas entièrement justifié.  Airbnb <a href="https://www.reddit.com/r/typescript/comments/aofcik/38_of_bugs_at_airbnb_could_have_been_prevented_by/">affirme que TypeScript a permis d'éviter 38% des erreurs</a> .  Je suis très sceptique quant au pourcentage si précisément indiqué.  TypeScript n'améliore pas ou ne combine pas toutes les pratiques existantes de bon code.  Je dois encore écrire une tonne de tests.  Vous pourriez dire que j'écris plus de code, donc je dois écrire autant de tests.  Je reçois toujours beaucoup d'erreurs d'exécution inattendues. <br><br>  TypeScript n'offre que la vérification de type de base, et le fait que la fiabilité et la vérification de type à l'exécution ne sont pas leur objectif laisse TypeScript dans le monde des demi-mesures, à mi-chemin entre le meilleur monde et celui dans lequel nous codons maintenant. <br><br>  TypeScript est génial grâce au bon support des IDE tels que vscode, où nous obtenons un retour visuel pendant le processus d'impression. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3y/r3/j7/3yr3j7emqikwnbmhj97et9c2wpk.png"></div><br>  <i>Erreur TypeScript dans vscode</i> <br><br>  TypeScript améliore également le refactoring et les changements de rupture de code (tels que les changements dans les signatures de méthode) qui sont instantanément identifiés au démarrage du compilateur TypeScript. <br>  TypeScript fournit une bonne vérification de type et c'est certainement mieux que pas de vérification de type ou un simple eslint, mais je pense que TypeScript peut être beaucoup mieux et les options de compilation nécessaires pourraient plaire à ceux qui veulent plus du langage. <br><br> <a href="https://vdsina.ru/%3Fpartner%3D7d159c89hz"><img src="https://habrastorage.org/webt/ud/xv/wf/udxvwfcz80j3nug11rxaguqelww.png"><br></a> <br><h3>  Abonnez-vous à notre développeur Instagram </h3><br> <a href="http://bit.ly/34w4T9B"><img src="https://habrastorage.org/webt/e5/as/-l/e5as-ltfnotkemk2dsqngygimra.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr485206/">https://habr.com/ru/post/fr485206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr485196/index.html">AvitoTech On Tour: rendez-vous et rendez-vous frontend à Kazan</a></li>
<li><a href="../fr485198/index.html">Une autre façon de mesurer les performances des méthodes d'application .NET</a></li>
<li><a href="../fr485200/index.html">Désordre au départ: post-mortem sur la vitesse de lancement d'une application iOS</a></li>
<li><a href="../fr485202/index.html">Système de suppression</a></li>
<li><a href="../fr485204/index.html">Retour en haut: pourquoi la capitalisation d'Amazon dépassera bientôt encore 1 billion de dollars</a></li>
<li><a href="../fr485208/index.html">Création d'une infrastructure informatique tolérante aux pannes. Partie 2. Installation et configuration du cluster oVirt 4.3</a></li>
<li><a href="../fr485210/index.html">Tireur de zombies simple sur Unity</a></li>
<li><a href="../fr485214/index.html">CLRium # 7: Pratique. Séminaire, devoirs avec vérification, mentorat</a></li>
<li><a href="../fr485218/index.html">Réservation de constantes et de crochets Git en C #</a></li>
<li><a href="../fr485220/index.html">L'évolution du pare-feu d'applications Web: des pare-feu aux systèmes de sécurité basés sur le cloud d'apprentissage automatique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>