<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎌 🐜 ⏹️ Cambiar a Next.js y acelerar la carga de la página de inicio de manifold.co 7.5 veces ☔️ 👍🏽 🎮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy estamos publicando una traducción de una historia sobre cómo la transición de React Boilerplate a Next.js , un marco para desarrollar aplicaciones...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cambiar a Next.js y acelerar la carga de la página de inicio de manifold.co 7.5 veces</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442654/">  Hoy estamos publicando una traducción de una historia sobre cómo la transición de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">React Boilerplate</a> a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Next.js</a> , un marco para desarrollar aplicaciones web progresivas basadas en React, ha acelerado la carga de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">página</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inicio</a> del proyecto manifold.co en 7.5 veces.  No se hicieron otros cambios al proyecto, y esta transición, en general, resultó ser completamente invisible para otras partes del sistema.  Lo que resultó al final resultó ser incluso mejor de lo esperado. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/ci/bc/g5/cibcg5cgvkbkyimgtleiv21hmgy.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Resumen de resultados</font> </h2><br>  De hecho, podemos decir que la transición a Next.js nos dio algo así como "un aumento de la productividad del proyecto que surgió de la nada".  Así es como se ve el tiempo de carga del proyecto cuando se utilizan varios recursos de hardware y conexiones de red. <br><table><tbody><tr><td>  Conexión <br></td><td width="130">  CPU <br></td><td width="130">  A segundos <br></td><td width="130">  Después de segundos <br></td><td width="130">  % De mejora <br></td></tr><tr><td>  Rápido (200 Mbps) <br></td><td>  Rápido <br></td><td>  1,5 <br></td><td>  0.2 0.2 <br></td><td>  750 <br></td></tr><tr><td>  Mediano (3G) <br></td><td>  Rápido <br></td><td>  5.6 <br></td><td>  1.1 <br></td><td>  500 <br></td></tr><tr><td>  Mediano (3G) <br></td><td>  Medio <br></td><td>  7.5 <br></td><td>  1.3 <br></td><td>  570 <br></td></tr><tr><td>  Lento (conexión 3G lenta) <br></td><td>  Medio <br></td><td>  22 <br></td><td>  4 4 <br></td><td>  550 <br></td></tr></tbody></table><br>  Cuando se usa una conexión rápida y un dispositivo con un procesador rápido, el tiempo de carga del sitio cayó de 1.5 s.  hasta 0.2 s., es decir, este indicador mejoró 7.5 veces.  En una conexión de calidad media y en un dispositivo con un rendimiento promedio, el tiempo de carga del sitio cayó de 7,5 s.  hasta 1.3 s <br><br><h2>  <font color="#3AC1EF">¿Qué sucede después de que un usuario hace clic en una URL?</font> </h2><br>  Para comprender las características del trabajo de las aplicaciones web progresivas (Progressive Web App, PWA), primero debe comprender lo que sucede entre el momento en que el usuario hace clic en la URL (en la dirección de nuestro sitio web) y el momento en que ve algo en una ventana del navegador (en este caso, nuestra aplicación React). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c6/f9b/060/8c6f9b060a4fd4ff13cd525b62c98477.jpg"></div><br>  <i><font color="#999999">Etapas de aplicación</font></i> <br><br>  Considere las 5 etapas de trabajar con la aplicación, cuyo diagrama se proporciona arriba. <br><br><ol><li>  El usuario accede a la URL, el sistema descubre la dirección del servidor utilizando DNS y accede al servidor.  Todo esto se hace extremadamente rápido, por lo general toma menos de 100 milisegundos, pero este paso lleva algo de tiempo, por eso se menciona aquí. </li><li>  Ahora el servidor devuelve el código HTML de la página, pero la página en el navegador permanece vacía hasta que se cargan los recursos necesarios para su visualización (a menos que los recursos se carguen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">asincrónicamente</a> ).  En realidad, se están llevando a cabo más acciones en esta etapa de las que se muestran en el diagrama, pero una revisión conjunta de todos estos procesos también nos conviene. </li><li> Después de cargar el código HTML y los recursos más importantes, el navegador comienza a mostrar lo que puede mostrar y continúa cargando todo lo demás (imágenes, por ejemplo) en segundo plano.  ¿Te has preguntado alguna vez por qué las imágenes a veces "aparecen" repentinamente en una página, obviamente, más rápido de lo necesario, y otras veces se cargan demasiado?  Esto es precisamente por qué sucede esto.  Este enfoque le permite crear rápidamente una página terminada. </li><li>  El código JavaScript se puede analizar y ejecutar solo después de cargarlo.  Dependiendo del tamaño del código JS utilizado en la página (y esto puede ser, para una aplicación React típica, bastante grande si el código está empaquetado en un solo archivo), esto puede llevar varios segundos o incluso más (tenga en cuenta que JS el código no necesita, para comenzar a ejecutarse, esperar la carga de todos los demás recursos, a pesar de que en el diagrama se ve exactamente así). </li><li>  En el caso de una aplicación React, ahora llega el momento en que el código modifica el DOM, lo que hace que el navegador redibuje la página ya mostrada.  Entonces comienza otro ciclo de carga de recursos.  El tiempo que tome este paso dependerá de la complejidad de la página. </li></ol><br><h2>  <font color="#3AC1EF">Cuanto más rápido, mejor.</font> </h2><br>  Dado que una aplicación web progresiva toma el código React y produce código estático HTML y CSS, esto significa que el usuario ve la aplicación React ya en el paso 3 del esquema anterior, y no en el paso 5. En nuestras pruebas, esto toma 0.2-4 segundos , que depende de la velocidad de conexión del usuario a Internet y de su dispositivo.  Esto es mucho mejor que los 1.5-22 segundos anteriores.  Las aplicaciones web progresivas son una forma confiable de entregar aplicaciones React más rápido al usuario. <br><br>  La razón por la cual las aplicaciones web progresivas y los frameworks relacionados como Next.js aún no son muy populares es porque, tradicionalmente, los frameworks JS no son particularmente exitosos en la generación de código HTML estático.  Hoy, todo ha cambiado mucho debido al hecho de que los frameworks como React, Vue y Angular, y otros, tienen un excelente soporte para la representación del lado del servidor.  Sin embargo, para utilizar estas herramientas, aún necesita un conocimiento profundo de las características del trabajo de los agrupadores y las herramientas para crear proyectos.  Trabajar con todo esto no está exento de problemas. <br><br>  La reciente aparición de marcos de PWA como Next.js y Gatsby (ambos aparecieron a fines de 2016 - principios de 2017) se ha convertido en un paso serio hacia la adopción generalizada de PWA debido a las barreras de entrada más bajas y al hecho de que el uso de dichos marcos es una tarea simple y agradable. <br><br>  Aunque no todas las aplicaciones se pueden transferir a Next.js, para muchas aplicaciones React esta transición significa el mismo "rendimiento de la nada" del que estamos hablando aquí, complementado por un uso aún más eficiente de los recursos de la red. <br><br><h2>  <font color="#3AC1EF">¿Qué tan difícil es migrar a Next.js?</font> </h2><br>  En general, se puede notar que traducir nuestra página de inicio a Next.js no fue muy difícil.  Sin embargo, encontramos algunas dificultades causadas por las características de arquitectura de nuestra aplicación. <br><br><h3>  <font color="#3AC1EF">▍ Rechazar un enrutador React</font> </h3><br>  Tuvimos que abandonar el enrutador React porque Next.js tiene su propio enrutador incorporado, que se combina mejor con optimizaciones con respecto a la separación de código realizada sobre la arquitectura PWA.  Esto permite que este enrutador proporcione una carga de página mucho más rápida de lo que esperaría de cualquier enrutador del lado del cliente. <br><br>  El enrutador Next.js es un enrutador React de alta velocidad, pero todavía no es un enrutador React. <br><br>  En la práctica, dado que no aprovechamos las características particularmente avanzadas que ofrece el enrutador React, la transición al enrutador Next.js para nosotros fue simplemente reemplazar el componente enrutador React estándar con el componente Next.js correspondiente: <br><br><pre><code class="plaintext hljs">/*   ( React) */ &lt;Link to="/my/page"&gt;  A link &lt;/Link&gt; /*   ( Next.js) */ &lt;Link href="/my/page" passHref&gt;  &lt;a&gt;    A link  &lt;/a&gt; &lt;/Link&gt;</code> </pre> <br>  En general, todo resultó no ser tan malo.  Tuvimos que cambiar el nombre de la propiedad y agregar una etiqueta para fines de representación del servidor.  Como también utilizamos la biblioteca de <code>styled-components</code> , resultó que en la mayoría de los casos necesitábamos agregar la propiedad <code>passHref</code> para garantizar que el sistema se comporta de tal manera que <code>href</code> siempre apunte a la etiqueta generada. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/5dd/e79/d7c5dde797101c30c2cf0e6507e07881.png"></div><br>  <i><font color="#999999">Solicitudes de red para manifold.co</font></i> <br><br>  Para ver con sus propios ojos la optimización del enrutador Next.js en acción, abra la pestaña Red de las herramientas de desarrollo del navegador al ver la página <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manifold.co</a> y haga clic en algún enlace.  La figura anterior muestra el resultado de hacer clic en el enlace <code>/services</code> .  Como puede ver, conduce a la ejecución de la solicitud para cargar <code>services.js</code> lugar de la solicitud habitual. <br><br>  No estoy hablando solo del enrutamiento del lado del cliente; el enrutador React también es adecuado para resolver este problema.  Estoy hablando de una pieza real de código JavaScript que se extrajo del resto del código y se cargó a pedido.  Esto se hace usando el estándar Next.js.  Y esto es mucho mejor que lo que teníamos antes.  Es decir, estamos hablando de un gran paquete de código JS con un tamaño de 1.7 MB, que el cliente, antes de que pudiera ver algo, tuvo que descargar y procesar. <br><br>  Aunque la solución presentada aquí no es perfecta, está mucho más cerca que la anterior a la idea de que los usuarios solo descargan código para las páginas que ven. <br><br><h3>  <font color="#3AC1EF">▍ Características del uso de Redux</font> </h3><br>  Continuando con el tema de las dificultades asociadas con la transición a Next.js, se puede observar que todas las optimizaciones interesantes que Next.js experimenta la aplicación tienen un cierto impacto en esta aplicación.  Es decir, dado que Next.js realiza la separación del código a nivel de página, evita que el desarrollador acceda al componente raíz <code>React</code> o al método <code>render()</code> de la biblioteca <code>react-dom</code> .  Si ya ha estado involucrado en la configuración de Redux, entonces puede notar que todo esto nos dice que para la operación normal con Redux necesitamos resolver el problema, que es que no está claro exactamente dónde buscar Redux. <br><br>  Next.js proporciona un componente especial de orden superior, con <code>withRedux</code> , que <code>withRedux</code> como un contenedor para todos los componentes de nivel superior en cada página: <br><br><pre> <code class="plaintext hljs">export default withRedux(HomePage);</code> </pre> <br>  Aunque todo esto no es tan malo, pero si necesita métodos <code>createStore()</code> , como cuando usa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">inyectores reductor-reductor</a> , espere que necesitará tiempo adicional para depurar el envoltorio (y por cierto, nunca intente use algo como <code>redux-reducer-injectors</code> ). <br><br>  Además, debido al hecho de que Redux ahora es una "caja negra", el uso de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Inmutable</a> se vuelve problemático.  Aunque el hecho de que Immutable funcione con Redux parece bastante obvio, me encontré con un problema.  Entonces, o el estado de nivel superior no era inmutable (el <code>get is not a function</code> error de <code>get is not a function</code> ), o el componente contenedor intentó usar la notación de puntos para trabajar con objetos JS en lugar del método <code>.get()</code> ( <code>Can't get catalog of undefined</code> errores <code>Can't get catalog of undefined</code> ).  Para depurar este problema, tuve que referirme al código fuente.  Después de todo, Next.js obliga al desarrollador a usar sus propios mecanismos por una razón. <br><br>  En general, se puede observar que el principal problema asociado con Next.js es que muy poco en este marco está bien documentado.  Hay muchos ejemplos en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> sobre la base de los cuales puede crear algo propio, pero si entre ellos no hay uno que refleje las características de su proyecto, solo puede desear buena suerte. <br><br><h3>  <font color="#3AC1EF">▍Fetch rechazo</font> </h3><br>  Utilizamos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">biblioteca react-inlinesvg</a> , que ofrece opciones de estilo para imágenes SVG incrustadas y almacenamiento en caché de consultas.  Pero aquí tuvimos un problema: al realizar la representación del servidor, no existen las solicitudes XHR (al menos no en el sentido de las URL generadas por Webpack, como es de esperar).  Los intentos de ejecutar tales solicitudes interfieren con la representación del servidor. <br><br>  Aunque hay otras bibliotecas para trabajar con datos SVG incrustados que admiten SSR, decidí abandonar esta función, ya que los archivos SVG todavía rara vez se usaban.  Los reemplacé con imágenes normales, etiquetas <code>&lt;img&gt;</code> , si no necesitaba estilo al mostrar las imágenes correspondientes, o las inserté en el código en forma de React JSX.  Probablemente, todo mejoró, ya que las ilustraciones de JSX ahora llegaron al navegador cuando se cargó la página por primera vez y el paquete JS enviado al cliente tenía 1 biblioteca menos. <br><br>  Si necesita usar mecanismos de carga de datos (necesitaba esta característica para otra biblioteca), puede configurarlo con <code>next.config.js</code> , usando <code>whatwg-fetch</code> y <code>node-fetch</code> : <br><br><pre> <code class="plaintext hljs">module.exports = { webpack: (config, options) =&gt;   Object.assign(config, {     plugins: config.plugins.concat([       new webpack.ProvidePlugin(         config.isServer           ? {}           : { fetch: 'imports-loader?this=&gt;global!exports-loader?global.fetch!whatwg-fetch' }       ),     ]),   resolve: Object.assign(config.resolve, {     alias: Object.assign(       config.resolve.alias,       config.isServer ? {} : { fetch: 'node-fetch' }     ),   }), }), };</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Cliente y servidor JS</font> </h3><br>  La última característica de Next.js, que me gustaría mencionar aquí, es que este marco se inicia dos veces, una para el servidor y otra para el cliente.  Esto difumina ligeramente la línea entre el código JavaScript del lado del cliente y el código Node.js en la misma base de código, lo que provoca errores inusuales como <code>fs is undefined</code> cuando se intenta aprovechar las características de Node.js en el cliente. <br><br>  Como resultado, tenemos que construir tales construcciones en <code>next.js.config</code> : <br><br><pre> <code class="plaintext hljs">module.exports = { webpack: (config, options) =&gt;   Object.assign(config, {     node: config.isServer ? undefined : { fs: 'empty' },   }), };</code> </pre> <br>  El indicador <code>config.isServer</code> en Webpack será su mejor amigo si necesita ejecutar el mismo código en diferentes entornos. <br><br>  Además, Next.js admite, además de los métodos estándar para el ciclo de vida de los componentes React, el método <code>getInitialProps()</code> , que se llama solo cuando el código se <code>getInitialProps()</code> en modo servidor: <br><br><pre> <code class="plaintext hljs">class HomePage extends React.Component { static getInitialProps() {   //         } componentDidMount() {   //     ,    } … }</code> </pre> <br>  Sí, y no olvidemos que nuestro buen amigo, el objeto de <code>window</code> , necesario para organizar la escucha de eventos, para determinar el tamaño de la ventana del navegador y dar acceso a muchas funciones útiles, no está disponible en Node.js: <br><br><pre> <code class="plaintext hljs">if (typeof window !== 'undefined') { // ,     `window`      }</code> </pre> <br>  Cabe señalar que incluso Next.js no puede salvar al desarrollador de la necesidad de resolver problemas asociados con la ejecución del mismo código en el servidor y en el cliente.  Pero al resolver tales problemas, <code>config.isServer</code> y <code>getInitialProps()</code> son muy útiles. <br><br><h2>  <font color="#3AC1EF">Resultados: ¿qué pasará después de Next.js?</font> </h2><br>  A corto plazo, el marco Next.js coincide perfectamente, en términos de rendimiento, con nuestros requisitos para la representación del servidor y la capacidad de ver nuestro sitio en dispositivos que tienen JavaScript deshabilitado.  Además, ahora le permite usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">metaetiquetas</a> avanzadas (ricas). <br><br>  Quizás en el futuro consideremos otras opciones en caso de que nuestra aplicación necesite tanto la representación del servidor como una lógica de servidor más compleja (por ejemplo, consideramos la posibilidad de implementar tecnología de inicio de sesión único en manifold.co y dashboard.manifold.co )  Pero hasta entonces usaremos Next.js, ya que este marco, con pequeños costos de tiempo, nos trajo enormes beneficios. <br><br>  <b>Estimados lectores!</b>  ¿Usas Next.js en tus proyectos? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442654/">https://habr.com/ru/post/442654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442644/index.html">La mayoría de las habilidades que no son de programación aumentan el valor del desarrollador</a></li>
<li><a href="../442646/index.html">Redes de Kubernetes: entrada</a></li>
<li><a href="../442648/index.html">Ir mecanismos de asignación</a></li>
<li><a href="../442650/index.html">Análisis y optimización de aplicaciones React.</a></li>
<li><a href="../442652/index.html">Uso de Fastify y Preact para prototipar rápidamente aplicaciones web</a></li>
<li><a href="../442658/index.html">8 trucos para trabajar con CSS: paralaje, pie de página adhesivo y otros</a></li>
<li><a href="../442660/index.html">Matemáticas reconciliando a Newton con el mundo cuántico</a></li>
<li><a href="../442662/index.html">Cómo ver SDDL y no romper los ojos en punto y coma</a></li>
<li><a href="../442664/index.html">QIWI Kitchen 6 de febrero: cómo estuvo + presentaciones de oradores</a></li>
<li><a href="../442666/index.html">Post-post, meta-meta. Aprendemos a escribir en Habr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>