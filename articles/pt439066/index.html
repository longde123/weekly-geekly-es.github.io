<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê≠ üèòÔ∏è ü§∑üèª Sistema operacional no Rust. Mem√≥ria de p√°gina: Avan√ßado üå©Ô∏è üìó üë®üèº‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo explica como o kernel do sistema operacional pode acessar os quadros de mem√≥ria f√≠sica. Estudaremos a fun√ß√£o de convers√£o de endere√ßos vir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sistema operacional no Rust. Mem√≥ria de p√°gina: Avan√ßado</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439066/">  Este artigo explica como o kernel do sistema operacional pode acessar os quadros de mem√≥ria f√≠sica.  Estudaremos a fun√ß√£o de convers√£o de endere√ßos virtuais em f√≠sicos.  Tamb√©m descobriremos como criar novos mapeamentos nas tabelas de p√°ginas. <br><br>  Este blog est√° publicado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .  Se voc√™ tiver alguma d√∫vida ou problema, abra o ticket correspondente l√°.  Todas as fontes do artigo est√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br><h1>  1. Introdu√ß√£o </h1><br>  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√∫ltimo artigo,</a> aprendemos sobre os princ√≠pios da mem√≥ria de pagina√ß√£o e como funcionam as tabelas de p√°gina de quatro n√≠veis no x86_64.  Tamb√©m descobrimos que o carregador j√° configurou a hierarquia da tabela de p√°ginas para nosso kernel, portanto, o kernel √© executado em endere√ßos virtuais.  Isso melhora a seguran√ßa, mas surge o problema: como acessar endere√ßos f√≠sicos reais armazenados nas entradas da tabela de p√°ginas ou no <code>CR3</code> ? <br><a name="habracut"></a><br>  Na primeira se√ß√£o do artigo, discutiremos o problema e as diferentes abordagens para resolv√™-lo.  Em seguida, implementamos uma fun√ß√£o que percorre a hierarquia das tabelas de p√°ginas para converter endere√ßos virtuais em f√≠sicos.  Por fim, aprenda como criar novos mapeamentos nas tabelas de p√°ginas e encontre os quadros de mem√≥ria n√£o utilizados para criar novas tabelas. <br><br><h2>  Atualiza√ß√µes de depend√™ncia </h2><br>  Para funcionar, voc√™ precisa do <code>x86_64</code> vers√£o 0.4.0 ou posterior.  Atualize a depend√™ncia em nosso <code>Cargo.toml</code> : <br><br><pre> <code class="rust hljs">[dependencies] x86_64 = <span class="hljs-string"><span class="hljs-string">"0.4.0"</span></span> # or later</code> </pre> <br><h1>  Acesso a tabelas de p√°ginas </h1><br>  Acessar tabelas de p√°ginas do kernel n√£o √© t√£o f√°cil quanto parece.  Para entender o problema, d√™ uma olhada na hierarquia de tabela de quatro n√≠veis do artigo anterior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  O importante √© que cada entrada da p√°gina armazene o endere√ßo <i>f√≠sico</i> da pr√≥xima tabela.  Isso evita a tradu√ß√£o desses endere√ßos, o que reduz o desempenho e leva facilmente a loops sem fim. <br><br>  O problema √© que n√£o podemos acessar diretamente endere√ßos f√≠sicos do kernel, pois ele tamb√©m funciona em endere√ßos virtuais.  Por exemplo, quando vamos para o endere√ßo <code>4 KiB</code> , obtemos acesso ao endere√ßo <i>virtual</i> <code>4 KiB</code> , e n√£o ao endere√ßo <i>f√≠sico</i> onde a tabela de p√°ginas do 4¬∫ n√≠vel est√° armazenada.  Se queremos acessar o endere√ßo f√≠sico de <code>4 KiB</code> , precisamos usar um endere√ßo virtual, que √© traduzido para ele. <br><br>  Portanto, para acessar os quadros das tabelas de p√°ginas, √© necess√°rio mapear algumas p√°ginas virtuais para esses quadros.  Existem diferentes maneiras de criar esses mapeamentos. <br><br>  1. Uma solu√ß√£o simples √© a <b>exibi√ß√£o id√™ntica de todas as tabelas de p√°ginas</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  Neste exemplo, vemos a exibi√ß√£o id√™ntica de quadros.  Os endere√ßos f√≠sicos das tabelas de p√°ginas s√£o ao mesmo tempo endere√ßos virtuais v√°lidos, para que possamos acessar facilmente as tabelas de p√°ginas de todos os n√≠veis, come√ßando com o registro CR3. <br><br>  No entanto, essa abordagem confunde o espa√ßo de endere√ßo virtual e dificulta a descoberta de grandes √°reas cont√≠guas de mem√≥ria livre.  Digamos que queremos criar uma √°rea de mem√≥ria virtual de 1000 KiB na figura acima, por exemplo, para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exibir um arquivo na mem√≥ria</a> .  N√£o podemos come√ßar com a regi√£o de <code>28  KiB</code> , porque ela fica em uma p√°gina j√° ocupada em <code>1004  KiB</code> .  Portanto, voc√™ precisar√° procurar mais at√© encontrarmos um fragmento grande e adequado, por exemplo, com <code>1008  KiB</code> .  H√° o mesmo problema de fragmenta√ß√£o da mem√≥ria segmentada. <br><br>  Al√©m disso, a cria√ß√£o de novas tabelas de p√°ginas √© muito mais complicada, pois precisamos encontrar quadros f√≠sicos cujas p√°ginas correspondentes ainda n√£o foram usadas.  Por exemplo, para o nosso arquivo, reservamos uma √°rea de 1000 KiB de mem√≥ria <i>virtual</i> , come√ßando no endere√ßo <code>1008  KiB</code> .  Agora n√£o podemos mais usar nenhum quadro com um endere√ßo f√≠sico entre <code>1000  KiB</code> e <code>2008  KiB</code> , porque ele n√£o pode ser exibido de forma id√™ntica. <br><br>  2. Outra op√ß√£o √© <b>transmitir tabelas de p√°ginas apenas temporariamente</b> quando voc√™ precisar acess√°-las.  Para compara√ß√µes tempor√°rias, √© necess√°ria uma exibi√ß√£o id√™ntica apenas da tabela de primeiro n√≠vel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84e/177/978/84e177978079c02224d4032fa02f053b.png"></div><br><br>  Nesta figura, uma tabela de n√≠vel 1 gerencia os 2 primeiros MiB de espa√ßo de endere√ßo virtual.  Isso √© poss√≠vel porque o acesso √© realizado a partir do registro CR3 atrav√©s de entradas nulas nas tabelas dos n√≠veis 4, 3 e 2. O registro com o √≠ndice <b>8</b> converte a p√°gina virtual em <code>32 KiB</code> em um quadro f√≠sico em <code>32 KiB</code> , identificando a pr√≥pria tabela de n√≠vel 1. Na figura, isso √© mostrado por uma seta horizontal. <br><br>  Ao escrever na tabela de n√≠vel 1 mapeada de forma id√™ntica, nosso kernel pode criar at√© 511 compara√ß√µes de tempo (512 menos o registro necess√°rio para o mapeamento de identidade).  No exemplo acima, o kernel correspondia ao registro nulo de uma tabela de n√≠vel 1 com um quadro em <code>24 KiB</code> .  Isso criou um mapeamento tempor√°rio da p√°gina virtual em <code>0 KiB</code> para o quadro f√≠sico da tabela de n√≠vel da p√°gina 2 indicada pela seta pontilhada.  Agora o kernel pode acessar a tabela de n√≠vel 2 gravando em uma p√°gina que come√ßa com <code>0 KiB</code> . <br><br>  Portanto, o acesso a um quadro arbitr√°rio da tabela de p√°ginas com mapeamentos tempor√°rios consiste nas seguintes a√ß√µes: <br><br><ul><li>  Encontre uma entrada gratuita na tabela de n√≠vel 1 exibida de forma id√™ntica. <br></li><li>  Mapeie essa entrada para o quadro f√≠sico da tabela de p√°ginas que queremos acessar. <br></li><li>  Acesse esse quadro atrav√©s da p√°gina virtual associada √† entrada. <br></li><li>  Defina o registro novamente como n√£o utilizado, removendo o mapeamento tempor√°rio. </li></ul><br>  Com essa abordagem, o espa√ßo de endere√ßo virtual permanece limpo, pois as mesmas 512 p√°ginas virtuais s√£o usadas constantemente.  A desvantagem √© uma certa dificuldade, especialmente porque uma nova compara√ß√£o pode exigir a altera√ß√£o de v√°rios n√≠veis da tabela, ou seja, precisamos repetir o processo descrito v√°rias vezes. <br><br>  3. Embora ambas as abordagens acima funcionem, existe um terceiro m√©todo: <b>tabelas de p√°ginas recursivas</b> .  Ele combina as vantagens de ambas as abordagens: compara constantemente todos os quadros das tabelas de p√°ginas sem exigir compara√ß√µes tempor√°rias e tamb√©m mant√©m as p√°ginas mapeadas lado a lado, evitando a fragmenta√ß√£o do espa√ßo de endere√ßo virtual.  Este √© o m√©todo que vamos usar. <br><br><h2>  Tabelas de p√°ginas recursivas </h2><br>  A id√©ia √© traduzir alguns registros da tabela de quarto n√≠vel para ela mesma.  Assim, reservamos uma parte do espa√ßo de endere√ßo virtual e mapeamos todos os quadros de tabela atuais e futuros para esse espa√ßo. <br><br>  Vejamos um exemplo para entender como tudo isso funciona: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  A √∫nica diferen√ßa do exemplo no in√≠cio do artigo √© um registro adicional com o √≠ndice <code>511</code> na tabela de n√≠vel 4, que √© mapeado para o quadro f√≠sico <code>4 KiB</code> , localizado nesta tabela em si. <br><br>  Quando a CPU entra nesse registro, ela n√£o se refere √† tabela de n√≠vel 3, mas novamente √† tabela de n√≠vel 4. Isso √© semelhante a uma fun√ß√£o recursiva que se chama.  √â importante que o processador suponha que cada registro na tabela de n√≠vel 4 aponte para uma tabela de n√≠vel 3. Portanto, agora ele trate a tabela de n√≠vel 4 como uma tabela de n√≠vel 3. Isso funciona porque as tabelas de todos os n√≠veis em x86_64 t√™m a mesma estrutura. <br><br>  Seguindo um registro recursivo uma ou mais vezes antes de iniciar a convers√£o real, podemos reduzir efetivamente o n√∫mero de n√≠veis pelos quais o processador passa.  Por exemplo, se seguirmos o registro recursivo uma vez e depois formos para a tabela de n√≠vel 3, o processador achar√° que a tabela de n√≠vel 3 √© uma tabela de n√≠vel 2. Seguindo em frente, ele considera a tabela de n√≠vel 2 como uma tabela de n√≠vel 1 e a tabela de n√≠vel 1 como mapeada quadro na mem√≥ria f√≠sica.  Isso significa que agora podemos ler e gravar na tabela de n√≠vel 1 da p√°gina, porque o processador pensa que esse √© um quadro mapeado.  A figura abaixo mostra as cinco etapas dessa tradu√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  Da mesma forma, podemos seguir uma entrada recursiva duas vezes antes de iniciar a convers√£o para reduzir o n√∫mero de n√≠veis passados ‚Äã‚Äãpara dois: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Vamos seguir este procedimento passo a passo.  Primeiro, a CPU segue uma entrada recursiva na tabela de n√≠vel 4 e pensa que alcan√ßou a tabela de n√≠vel 3. Em seguida, segue o registro recursivo novamente e pensa que alcan√ßou o n√≠vel 2. Mas, na realidade, ainda est√° no n√≠vel 4. Em seguida, a CPU vai para o novo endere√ßo e entra na tabela de n√≠vel 3, mas acha que j√° est√° na tabela de n√≠vel 1. Por fim, no pr√≥ximo ponto de entrada da tabela de n√≠vel 2, o processador acha que acessou o quadro de mem√≥ria f√≠sica.  Isso nos permite ler e gravar em uma tabela de n√≠vel 2. <br><br>  Tamb√©m s√£o acessadas as tabelas dos n√≠veis 3 e 4. Para acessar a tabela do n√≠vel 3, seguimos um registro recursivo tr√™s vezes: o processador pensa que j√° est√° na tabela do n√≠vel 1 e, na pr√≥xima etapa, atingimos o n√≠vel 3, que a CPU considera como um quadro mapeado.  Para acessar a tabela de n√≠vel 4, basta seguir o registro recursivo quatro vezes at√© que o processador processe a tabela de n√≠vel 4 como um quadro mapeado (em azul na figura abaixo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  O conceito √© dif√≠cil de entender a princ√≠pio, mas, na pr√°tica, funciona muito bem. <br><br><h4>  C√°lculo de endere√ßo </h4><br>  Assim, podemos acessar tabelas de todos os n√≠veis seguindo um registro recursivo uma ou mais vezes.  Como os √≠ndices em tabelas de quatro n√≠veis s√£o derivados diretamente do endere√ßo virtual, endere√ßos virtuais especiais devem ser criados para esse m√©todo.  Como lembramos, os √≠ndices da tabela de p√°ginas s√£o extra√≠dos do endere√ßo da seguinte maneira: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Suponha que desejamos acessar uma tabela de n√≠vel 1 que exibe uma p√°gina espec√≠fica.  Como aprendemos acima, voc√™ precisa passar por um registro recursivo uma vez e depois pelos √≠ndices do 4¬∫, 3¬∫ e 2¬∫ n√≠veis.  Para fazer isso, movemos todos os blocos de endere√ßo um bloco para a direita e configuramos o √≠ndice do registro recursivo para o local do √≠ndice inicial do n√≠vel 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Para acessar a tabela de n√≠vel 2 desta p√°gina, movemos todos os blocos de √≠ndice dois blocos para a direita e configuramos o √≠ndice recursivo no local dos dois blocos de origem: n√≠vel 4 e n√≠vel 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Para acessar a tabela de n√≠vel 3, fazemos o mesmo, apenas mudamos para a direita, j√° com tr√™s blocos de endere√ßos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Finalmente, para acessar a tabela de n√≠vel 4, mova todos os quatro blocos para a direita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Agora voc√™ pode calcular endere√ßos virtuais para tabelas de p√°ginas dos quatro n√≠veis.  Podemos at√© calcular um endere√ßo que aponte exatamente para uma entrada espec√≠fica da tabela de p√°ginas multiplicando seu √≠ndice por 8, o tamanho da entrada da tabela de p√°ginas. <br><br>  A tabela abaixo mostra a estrutura de endere√ßos para acessar v√°rios tipos de quadros: <br><br><table><thead><tr><th>  Endere√ßo virtual para </th><th>  Estrutura de endere√ßo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">octal</a> ) </th></tr></thead><tbody><tr><td>  Page </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Entrada na tabela de n√≠vel 1 </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Entrada em uma tabela de n√≠vel 2 </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Entrada em uma tabela de n√≠vel 3 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Entrada na tabela de n√≠vel 4 </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Aqui, <code></code> √© o √≠ndice de n√≠vel 4, <code></code> √© o n√≠vel 3, <code></code> √© o n√≠vel 2 e <code>DDD</code> √© o √≠ndice de n√≠vel 1 para o quadro exibido, <code>EEEE</code> √© o seu deslocamento.  <code>RRR</code> √© o √≠ndice do registro recursivo.  Um √≠ndice (tr√™s d√≠gitos) √© convertido em um deslocamento (quatro d√≠gitos) multiplicando por 8 (o tamanho da entrada da tabela da p√°gina).  Com esse deslocamento, o endere√ßo resultante aponta diretamente para a entrada da tabela de p√°ginas correspondente. <br><br>  <code>SSSS</code> s√£o bits de expans√£o do d√≠gito assinado, ou seja, s√£o c√≥pias do bit 47. Esse √© um requisito especial para endere√ßos v√°lidos na arquitetura x86_64, que discutimos em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> . <br><br>  Os endere√ßos s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">octais</a> , pois cada caractere octal representa tr√™s bits, o que permite separar claramente os √≠ndices de 9 bits das tabelas em diferentes n√≠veis.  Isso n√£o √© poss√≠vel no sistema hexadecimal, onde cada caractere representa quatro bits. <br><br><h2>  Implementa√ß√£o </h2><br>  Depois de toda essa teoria, podemos finalmente prosseguir com a implementa√ß√£o.  Convenientemente, o carregador gerou n√£o apenas tabelas de p√°ginas, mas tamb√©m uma exibi√ß√£o recursiva no √∫ltimo registro da tabela de n√≠vel 4. O carregador fez isso porque, caso contr√°rio, haveria um problema de galinha ou ovo: precisamos acessar a tabela de n√≠vel 4 para criar um mapa recursivo mas n√£o podemos acess√°-lo sem nenhuma exibi√ß√£o. <br><br>  J√° usamos esse mapeamento recursivo no final do artigo anterior para acessar a tabela de n√≠vel 4 atrav√©s do endere√ßo codificado <code>0xffff_ffff_ffff_f000</code> .  Se convertermos esse endere√ßo em octal e compar√°-lo com a tabela acima, veremos que ele corresponde exatamente √† estrutura do registro na tabela de n√≠vel 4 com <code>RRR</code> = <code>0o777</code> , <code>AAAA</code> = <code>0</code> e os bits de extens√£o do sinal <code>1</code> : <br><br><pre>  estrutura: 0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA
 endere√ßo: 0o_177777_777_777_777_777_0000 </pre><br>  Gra√ßas ao conhecimento de tabelas recursivas, agora podemos criar endere√ßos virtuais para acessar todas as tabelas ativas.  E fa√ßa a fun√ß√£o de transmiss√£o. <br><br><h3>  Tradu√ß√£o de endere√ßos </h3><br>  Como primeira etapa, crie uma fun√ß√£o que converta um endere√ßo virtual em um endere√ßo f√≠sico, passando pela hierarquia das tabelas de p√°ginas: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::PhysAddr; use x86_64::structures::paging::PageTable; /// Returns the physical address for the given virtual address, or `None` if the /// virtual address is not mapped. pub fn translate_addr(addr: usize) -&gt; Option&lt;PhysAddr&gt; { // introduce variables for the recursive index and the sign extension bits // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Don't hardcode these values let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12); // check that level 4 entry is mapped let level_4_table = unsafe { &amp;*(level_4_table_addr as *const PageTable) }; if level_4_table[l4_idx].addr().is_null() { return None; } // check that level 3 entry is mapped let level_3_table = unsafe { &amp;*(level_3_table_addr as *const PageTable) }; if level_3_table[l3_idx].addr().is_null() { return None; } // check that level 2 entry is mapped let level_2_table = unsafe { &amp;*(level_2_table_addr as *const PageTable) }; if level_2_table[l2_idx].addr().is_null() { return None; } // check that level 1 entry is mapped and retrieve physical address from it let level_1_table = unsafe { &amp;*(level_1_table_addr as *const PageTable) }; let phys_addr = level_1_table[l1_idx].addr(); if phys_addr.is_null() { return None; } Some(phys_addr + page_offset) }</span></span></code> </pre> <br>  Primeiro, introduzimos vari√°veis ‚Äã‚Äãpara o √≠ndice recursivo (511 = <code>0o777</code> ) e os bits de extens√£o de sinal (cada um √© 1).  Em seguida, calculamos os √≠ndices das tabelas de p√°ginas e o deslocamento por meio de opera√ß√µes bit a bit, conforme indicado na ilustra√ß√£o: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  A pr√≥xima etapa √© calcular os endere√ßos virtuais das tabelas de quatro p√°ginas, conforme descrito na se√ß√£o anterior.  Em seguida, na fun√ß√£o, convertemos cada um desses endere√ßos em links de <code>PageTable</code> .  Essas s√£o opera√ß√µes inseguras porque o compilador n√£o pode saber que esses endere√ßos s√£o v√°lidos. <br><br>  Ap√≥s o c√°lculo do endere√ßo, usamos o operador de indexa√ß√£o para exibir o registro na tabela de n√≠vel 4. Se esse registro for zero, n√£o haver√° tabela de n√≠vel 3 para esse registro de n√≠vel 4. Isso significa que <code>addr</code> n√£o <code>addr</code> mapeado para nenhuma mem√≥ria f√≠sica.  Ent√£o, retornamos <code>None</code> .  Caso contr√°rio, sabemos que existe uma tabela de n√≠vel 3.  Em seguida, repetimos o procedimento, como no n√≠vel anterior. <br><br>  Depois de verificar tr√™s p√°ginas de um n√≠vel superior, podemos finalmente ler o registro da tabela de n√≠vel 1, que indica o quadro f√≠sico com o qual o endere√ßo √© mapeado.  Como a √∫ltima etapa, adicione o deslocamento da p√°gina e retorne o endere√ßo. <br><br>  Se tiv√©ssemos certeza de que o endere√ßo estava mapeado, poder√≠amos acessar diretamente a tabela de n√≠vel 1 sem consultar as p√°ginas de um n√≠vel superior.  Mas como n√£o sabemos disso, primeiro precisamos verificar se existe uma tabela de n√≠vel 1; caso contr√°rio, nossa fun√ß√£o retornar√° um erro de falta de p√°gina para endere√ßos n√£o correspondentes. <br><br><h4>  Experimente </h4><br>  Vamos tentar usar a fun√ß√£o de tradu√ß√£o para endere√ßos virtuais em nossa fun√ß√£o <code>_start</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><br>  Ap√≥s o in√≠cio, vemos o seguinte resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bd/e62/054/1bde620549428279e6c1f1647d88a062.png"></div><br><br>  Como esperado, o endere√ßo 0xb8000 associado ao identificador √© convertido no mesmo endere√ßo f√≠sico.  A p√°gina de c√≥digo e a pilha s√£o convertidas em alguns endere√ßos f√≠sicos arbitr√°rios, que dependem de como o carregador criou o mapeamento inicial para o nosso kernel. <br><br><h4> <code> RecursivePageTable</code> </h4> <br>  x86_64 fornece um tipo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>RecursivePageTable</code></a> que implementa abstra√ß√µes seguras para v√°rias opera√ß√µes da tabela de p√°ginas.  Usando esse tipo, voc√™ pode implementar a fun√ß√£o <code>translate_addr</code> muito mais concisa: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. /// /// This function is unsafe because it can break memory safety if an invalid /// address is passed. pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap() } /// Returns the physical address for the given virtual address, or `None` if /// the virtual address is not mapped. pub fn translate_addr(addr: u64, recursive_page_table: &amp;RecursivePageTable) -&gt; Option&lt;PhysAddr&gt; { let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br>  O tipo <code>RecursivePageTable</code> encapsula totalmente os rastreamentos inseguros da tabela da p√°gina, portanto, o c√≥digo <code>unsafe</code> na fun√ß√£o <code>translate_addr</code> n√£o √© mais necess√°rio.  A fun√ß√£o <code>init</code> permanece insegura devido √† necessidade de garantir a corre√ß√£o do <code>level_4_table_addr</code> passado. <br><br>  Nossa fun√ß√£o <code>_start</code> deve ser atualizada para assinar novamente a fun√ß√£o da seguinte maneira: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::{self, translate_addr}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000, &amp;recursive_page_table)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a, &amp;recursive_page_table)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48, &amp;recursive_page_table)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>  Agora, em vez de passar <code>LEVEL_4_TABLE_ADDR</code> para <code>translate_addr</code> e acessar as tabelas de p√°ginas por meio de ponteiros brutos n√£o seguros, passamos refer√™ncias ao tipo <code>RecursivePageTable</code> .  Assim, agora temos uma abstra√ß√£o segura e uma sem√¢ntica clara de propriedade.  Isso garante que n√£o seremos capazes de alterar acidentalmente a tabela de p√°ginas no acesso compartilhado, pois a altera√ß√£o requer a posse exclusiva de <code>RecursivePageTable</code> . <br><br>  Esta fun√ß√£o fornece o mesmo resultado que a fun√ß√£o de tradu√ß√£o original escrita manualmente. <br><br><h4>  Tornando os recursos n√£o seguros mais seguros </h4><br> <code>memory::init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© uma fun√ß√£o insegura: requer um bloco para cham√°-lo </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque o chamador deve garantir que certos requisitos sejam atendidos. No nosso caso, o requisito √© que o endere√ßo transmitido seja mapeado com precis√£o para o quadro f√≠sico da tabela de p√°ginas de n√≠vel 4. </font><font style="vertical-align: inherit;">Todo o corpo da fun√ß√£o insegura √© colocado </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no bloco </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que todos os tipos de opera√ß√µes sejam executados sem a cria√ß√£o de blocos adicionais </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Portanto, n√£o precisamos de um bloco n√£o seguro para desreferenciar </font></font><code>level_4_table_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(level_4_table_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; RecursivePageTable&lt;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table_ptr = level_4_table_addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PageTable; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *level_4_table_ptr; <span class="hljs-comment"><span class="hljs-comment">// &lt;- this operation is unsafe RecursivePageTable::new(level_4_table).unwrap() }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O problema √© que n√£o vemos imediatamente quais partes s√£o inseguras. </font><font style="vertical-align: inherit;">Por exemplo, sem olhar para a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defini√ß√£o de uma fun√ß√£o,</font></font></a> <code>RecursivePageTable::new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√£o podemos dizer se √© segura ou n√£o. </font><font style="vertical-align: inherit;">Portanto, √© muito f√°cil ignorar acidentalmente algum c√≥digo n√£o seguro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar esse problema, voc√™ pode adicionar uma fun√ß√£o interna segura:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { /// Rust currently treats the whole body of unsafe functions as an unsafe /// block, which makes it difficult to see which operations are unsafe. To /// limit the scope of unsafe we use a safe inner function. fn init_inner(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = unsafe { &amp;mut *level_4_table_ptr }; RecursivePageTable::new(level_4_table).unwrap() } init_inner(level_4_table_addr) }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, o bloco √© </font></font><code>unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">novamente necess√°rio para desreferenciar </font></font><code>level_4_table_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e imediatamente vemos que essas s√£o as √∫nicas opera√ß√µes inseguras. </font><font style="vertical-align: inherit;">Atualmente, o Rust possui uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aberta </font><font style="vertical-align: inherit;">para alterar essa propriedade malsucedida de fun√ß√µes n√£o seguras.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crie um novo mapeamento </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando lemos as tabelas de p√°ginas e criamos a fun√ß√£o de convers√£o, o pr√≥ximo passo √© criar um novo mapeamento na hierarquia de tabelas de p√°ginas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A complexidade desta opera√ß√£o depende da p√°gina virtual que queremos exibir. No caso mais simples, j√° existe uma tabela de p√°ginas de n√≠vel 1 para esta p√°gina e precisamos apenas fazer uma entrada. No caso mais dif√≠cil, a p√°gina est√° na √°rea de mem√≥ria para a qual o n√≠vel 3 ainda n√£o existe; portanto, primeiro voc√™ precisa criar novas tabelas de n√≠vel 3, n√≠vel 2 e n√≠vel 1.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos come√ßar com um caso simples, quando voc√™ n√£o precisa criar novas tabelas. O carregador √© carregado no primeiro megabyte do espa√ßo de endere√ßo virtual, portanto, sabemos que para esta regi√£o h√° uma tabela v√°lida de n√≠vel 1. No nosso exemplo, podemos selecionar qualquer p√°gina n√£o utilizada nesta √°rea de mem√≥ria, por exemplo, a p√°gina no endere√ßo </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Usamos o </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quadro do buffer de texto VGA </font><font style="vertical-align: inherit;">como o quadro desejado </font><font style="vertical-align: inherit;">. √â muito f√°cil verificar como funciona a tradu√ß√£o de endere√ßos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s o implementamos em uma nova fun√ß√£o </font></font><code>create_maping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no m√≥dulo </font></font><code>memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{FrameAllocator, PhysFrame, Size4KiB}; pub fn create_example_mapping( recursive_page_table: &amp;mut RecursivePageTable, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let page: Page = Page::containing_address(VirtAddr::new(0x1000)); let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { recursive_page_table.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fun√ß√£o aceita uma refer√™ncia mut√°vel para </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ela ser√° alterada) e </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, explicada abaixo. Em seguida, aplica a fun√ß√£o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>map_to</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">na bandeja </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Mapper</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para mapear a p√°gina no endere√ßo </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o quadro f√≠sico no endere√ßo </font></font><code>0xb8000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A fun√ß√£o n√£o √© segura, porque √© poss√≠vel violar a seguran√ßa da mem√≥ria com argumentos inv√°lidos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m dos argumentos </font></font><code>page</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a fun√ß√£o </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recebe mais dois argumentos. O terceiro argumento √© o conjunto de sinalizadores para a tabela de p√°ginas. Definimos o sinalizador </font></font><code>PRESENT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necess√°rio para todas as entradas v√°lidas e o sinalizador </font></font><code>WRITABLE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para gravabilidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O quarto argumento deve ser alguma estrutura que implemente a caracter√≠stica </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este argumento √© necess√°rio pelo m√©todo</font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">porque a cria√ß√£o de novas tabelas de p√°ginas pode exigir quadros n√£o utilizados. A implementa√ß√£o requer o tra√ßo argumento </font></font><code>Size4KiB</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como tipos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>Page</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>PhysFrame</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√£o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">universal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para a caracter√≠stica </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>PageSize</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, trabalhando com 4 p√°ginas padr√£o KiB e com enormes p√°ginas 2 MiB / 1 IB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A fun√ß√£o </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode falhar e, portanto, retorna </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como este √© apenas um exemplo de c√≥digo que n√£o deve ser confi√°vel, simplesmente o usamos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>expect</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com p√¢nico quando ocorre um erro. Se for bem-sucedida, a fun√ß√£o retornar√° um tipo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MapperFlush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que fornece uma maneira f√°cil de limpar a p√°gina correspondida recentemente do m√©todo TLB (associative translation buffer) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>flush</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Curtir</font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o tipo usa o atributo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>#[must_use]</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e emite um aviso se esquecermos acidentalmente de aplic√°-lo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como sabemos que o endere√ßo </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o requer novas tabelas de p√°ginas, ele </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sempre pode retornar </font></font><code>None</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para testar a fun√ß√£o, crie isto </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Se o erro 'o m√©todo </font></font><code>allocate_frame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o √© um membro da caracter√≠stica </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">' </font><font style="vertical-align: inherit;">aparecer </font><font style="vertical-align: inherit;">, voc√™ precisar√° atualizar </font></font><code>x86_64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para a vers√£o 0.4.0.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos testar a nova fun√ß√£o de convers√£o:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::{create_example_mapping, EmptyFrameAllocator}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let mut recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; create_example_mapping(&amp;mut recursive_page_table, &amp;mut EmptyFrameAllocator); unsafe { (0x1900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, criamos um mapeamento para a p√°gina no endere√ßo </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, chamando a fun√ß√£o </font></font><code>create_example_mapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um link mut√°vel para a inst√¢ncia </font></font><code>RecursivePageTable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso traduz a p√°gina </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em um buffer de texto VGA, portanto veremos algum resultado na tela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, escrevemos um valor nesta p√°gina </font></font><code>0xf021f077f065f04e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que corresponde √† linha </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Novo!" </font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sobre um fundo branco </font><font style="vertical-align: inherit;">S√≥ n√£o √© necess√°rio escrever esse valor diretamente na parte superior da p√°gina </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque a linha superior se mover√° a seguir da tela </font></font><code>println</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e gravar√° no deslocamento </font></font><code>0x900</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, localizado aproximadamente no meio da tela. </font><font style="vertical-align: inherit;">Como sabemos no artigo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Modo de texto VGA"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a grava√ß√£o no buffer VGA deve ser vol√°til, por isso usamos o m√©todo </font></font><code>write_volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quando o executamos no QEMU, vemos o seguinte: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef9/1bc/672/ef91bc672e33cbec8847b77028b7624e.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A inscri√ß√£o na tela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O c√≥digo funcionou porque j√° havia uma tabela de n√≠vel 1 para exibir a p√°gina </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se tentarmos traduzir uma p√°gina para a qual essa tabela ainda n√£o existe, a fun√ß√£o </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retornar√° um erro, porque tentar√° selecionar quadros para criar novas tabelas de p√°ginas </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Veremos isso se tentarmos traduzir a p√°gina em </font></font><code>0xdeadbeaf000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez de </font></font><code>0x1000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub fn create_example_mapping(‚Ä¶) { [‚Ä¶] let page: Page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); [‚Ä¶] } // in src/main.rs #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ao iniciar, um p√¢nico come√ßa com a seguinte mensagem de erro: </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entre em p√¢nico em 'map_to falhou: FrameAllocationFailed', /.../result.rs:999haps </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para exibir p√°ginas que ainda n√£o possuem uma tabela de n√≠vel 1, √© necess√°rio criar a correta </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mas como voc√™ sabe quais quadros s√£o gratuitos e quanta mem√≥ria f√≠sica est√° dispon√≠vel?</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Informa√ß√µes de inicializa√ß√£o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Computadores diferentes t√™m quantidades diferentes de mem√≥ria f√≠sica e √°reas diferentes reservadas por dispositivos como VGA. Somente o firmware BIOS ou UEFI sabe exatamente quais √°reas de mem√≥ria podem ser usadas e quais s√£o reservadas. Os dois padr√µes de firmware fornecem fun√ß√µes para obter um cart√£o de aloca√ß√£o de mem√≥ria, mas s√≥ podem ser chamados no in√≠cio do download. Portanto, nosso gerenciador de inicializa√ß√£o j√° solicitou essas (e outras) informa√ß√µes do BIOS. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para passar informa√ß√µes ao kernel do sistema operacional, o carregador como argumento ao chamar a fun√ß√£o </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece um link para a estrutura de informa√ß√µes da inicializa√ß√£o. Adicione este argumento √† nossa fun√ß√£o:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::bootinfo::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument [‚Ä¶] }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A estrutura </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>BootInfo</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ainda </font><font style="vertical-align: inherit;">est√° </font><font style="vertical-align: inherit;">sendo finalizada, portanto, n√£o se surpreenda com falhas ao atualizar para vers√µes futuras do gerenciador de inicializa√ß√£o que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√£o </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">compat√≠veis com o semver</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">No momento em que tem tr√™s campos </font></font><code>p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>package</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O campo </font></font><code>p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cont√©m um endere√ßo virtual recursivo da tabela de p√°ginas de n√≠vel 4. Gra√ßas a isso, n√£o √© necess√°rio registrar o endere√ßo com for√ßa </font></font><code>0o_177777_777_777_777_777_0000</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O campo </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© de maior interesse, pois cont√©m uma lista de todas as √°reas de mem√≥ria e seu tipo (n√£o utilizado, reservado ou outros).</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O campo </font></font><code>package</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© a fun√ß√£o atual para associar dados adicionais ao carregador. </font><font style="vertical-align: inherit;">A implementa√ß√£o n√£o est√° conclu√≠da, portanto podemos ignor√°-la por enquanto.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de usar o campo </font></font><code>memory_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para criar o caminho certo </font></font><code>FrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, queremos garantir o tipo correto de argumento </font></font><code>boot_info</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Macro </font></font><code>entry_point</code> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© chamada externamente, a assinatura da fun√ß√£o n√£o √© verificada. </font><font style="vertical-align: inherit;">Isso significa que argumentos arbitr√°rios n√£o levar√£o a erros de compila√ß√£o, mas podem causar uma falha ou comportamento indefinido do tempo de execu√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para verificar a assinatura, a caixa </font></font><code>bootloader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para definir a fun√ß√£o Rust como um ponto de entrada usa uma macro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>entry_point</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com tipos validados. </font><font style="vertical-align: inherit;">Reescrevemos nossa fun√ß√£o para esta macro:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{bootinfo::BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; [‚Ä¶] // create and test example mapping println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ponto de entrada, voc√™ n√£o precisa mais usar </font></font><code>extern "C"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>no_mangle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, uma vez que a macro define o ponto de entrada real de baixo n√≠vel </font></font><code>_start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A fun√ß√£o </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agora se tornou uma fun√ß√£o Rust completamente normal, para que possamos escolher um nome arbitr√°rio para ela. </font><font style="vertical-align: inherit;">√â importante que ele j√° esteja digitado, para que ocorra um erro de compila√ß√£o se voc√™ alterar a assinatura da fun√ß√£o, por exemplo, adicionando um argumento ou alterando seu tipo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que agora estamos enviando para um </font></font><code>memory::init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">endere√ßo codificado, mas </font></font><code>boot_info.p4_table_addr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Portanto, o c√≥digo funcionar√° mesmo que a vers√£o futura do carregador de inicializa√ß√£o selecione outra entrada na tabela da tabela no n√≠vel 4 da p√°gina para exibi√ß√£o recursiva.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sele√ß√£o de quadro </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, gra√ßas √†s informa√ß√µes do BIOS, temos acesso ao cart√£o de aloca√ß√£o de mem√≥ria, para que voc√™ possa fazer um distribuidor de quadros normal. </font><font style="vertical-align: inherit;">Vamos come√ßar com o esqueleto geral:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O campo √© </font></font><code>frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inicializado por um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iterador de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quadro </font><font style="vertical-align: inherit;">arbitr√°rio </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Isso permite que voc√™ simplesmente delegue chamadas </font></font><code>alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o m√©todo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator :: next</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A inicializa√ß√£o </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ocorre em uma nova fun√ß√£o </font></font><code>init_frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.into_iter().step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esta fun√ß√£o, usando um combinador, converte o mapa de aloca√ß√£o de mem√≥ria original em um iterador dos quadros f√≠sicos usados: </font></font><br><br><ul><li>    <code>iter</code>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>MemoryRegion</code></a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>filter</code></a> ,      .          ,  ,    (,   )     ,    <code>InUse</code>  .  ,    ,      - . <br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>map</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> range</a> Rust          . <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A terceira etapa √© a mais dif√≠cil: convertemos cada intervalo em um iterador usando o m√©todo </font></font><code>into_iter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, em seguida, selecionamos cada 4096¬∫ endere√ßo com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>step_by</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como o tamanho da p√°gina √© de 4096 bytes (4 KiB), obtemos o endere√ßo do in√≠cio de cada quadro. </font><font style="vertical-align: inherit;">A p√°gina do carregador alinha todas as √°reas de mem√≥ria usadas, portanto, n√£o precisamos de um c√≥digo de alinhamento ou arredondamento. </font><font style="vertical-align: inherit;">Substituindo </font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><code>flat_map</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, chegamos ao </font></font><code>Iterator&lt;Item = u64&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inv√©s </font></font><code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No est√°gio final, converteremos os endere√ßos iniciais em tipos </font></font><code>PhysFrame</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para criar o necess√°rio </font></font><code>Iterator&lt;Item = PhysFrame&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Em seguida, use esse iterador para criar e retornar um novo </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora n√≥s podemos mudar a nossa fun√ß√£o </font></font><code>kernel_main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para transmitir sua inst√¢ncia </font></font><code>BootInfoFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vez </font></font><code>EmptyFrameAllocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use x86_64::structures::paging::{PageTable, RecursivePageTable}; let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; // new let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); blog_os::memory::create_mapping(&amp;mut recursive_page_table, &amp;mut frame_allocator); unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora a tradu√ß√£o do endere√ßo foi bem-sucedida - e novamente vemos a mensagem em preto e branco </font><i><font style="vertical-align: inherit;">‚ÄúNovo!‚Äù</font></i><font style="vertical-align: inherit;"> Na tela</font></font><i><font style="vertical-align: inherit;"></font></i>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos bastidores, o m√©todo </font></font><code>map_to</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cria tabelas de p√°ginas ausentes da seguinte maneira:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extrai um quadro n√£o utilizado de </font></font><code>frame_allocator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corresponde a uma entrada da tabela de n√≠vel superior com esse quadro. </font><font style="vertical-align: inherit;">O quadro agora est√° acess√≠vel atrav√©s de uma tabela de p√°ginas recursiva.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zera o quadro para criar uma nova tabela de p√°ginas vazia. </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vai para a pr√≥xima tabela de n√≠vel. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora nossa fun√ß√£o </font></font><code>create_maping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seja apenas um exemplo, agora podemos criar novos mapeamentos para p√°ginas arbitr√°rias. </font><font style="vertical-align: inherit;">Isso √© muito √∫til ao alocar mem√≥ria e implementar multithreading em artigos futuros.</font></font><br><br><h1>  Sum√°rio </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste artigo, voc√™ aprendeu como usar uma tabela recursiva de n√≠vel 4 para converter todos os quadros em endere√ßos virtuais comput√°veis. </font><font style="vertical-align: inherit;">Usamos esse m√©todo para implementar a fun√ß√£o de convers√£o de endere√ßo e criar um novo mapeamento nas tabelas de p√°ginas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vimos que a cria√ß√£o de novos mapeamentos requer quadros n√£o utilizados para novas tabelas. </font><font style="vertical-align: inherit;">Esse distribuidor de quadros pode ser implementado com base nas informa√ß√µes do BIOS que o gerenciador de inicializa√ß√£o passa para o nosso kernel.</font></font><br><br><h1>  O que vem a seguir </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No pr√≥ximo artigo, criaremos uma √°rea de mem√≥ria heap para o nosso kernel, que permitir√° </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alocar mem√≥ria</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e usar diferentes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipos de cole√ß√µes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439066/">https://habr.com/ru/post/pt439066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439050/index.html">Treinamento Cisco 200-125 CCNA v3.0. Cisco Certified Network Specialist (CCNA). Dia 2. Modelos OSI e TCP-IP</a></li>
<li><a href="../pt439056/index.html">Integra√ß√£o da marca de cimento</a></li>
<li><a href="../pt439060/index.html">7 tipos de clientes</a></li>
<li><a href="../pt439062/index.html">Anisoprint Composer: Impress√£o 3D de alta resist√™ncia</a></li>
<li><a href="../pt439064/index.html">Um erro de grade t√≠pico (Bootstrap Grid) ou por que o designer e o designer de layout n√£o se entendem</a></li>
<li><a href="../pt439068/index.html">Campanha de spam "Te amo" redirecionada para o Jap√£o</a></li>
<li><a href="../pt439070/index.html">China abandonar√° o Zero AI do sistema anti-corrup√ß√£o por causa de sua alta efici√™ncia</a></li>
<li><a href="../pt439072/index.html">Manifesto do Smart Home Developer: 15 princ√≠pios</a></li>
<li><a href="../pt439076/index.html">Em quais aplicativos aguardar c√≥digo malicioso desconhecido?</a></li>
<li><a href="../pt439078/index.html">Programador Perm preso por criar aplicativo m√≥vel atrav√©s do qual ped√≥filo agia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>