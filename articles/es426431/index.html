<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🔬 ➗ 🎺 Desmontaje del motor de novela visual Qlie 🥤 👨🏼‍💻 🌋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una traducción aficionada de cuentos visuales, en comparación con las traducciones de otros juegos, tiene varias características e implica trabajar co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desmontaje del motor de novela visual Qlie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426431/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/bb/sq/zf/bbsqzfse3pqjvnyef8jnfv3lecy.png"></div><br><br>  Una traducción aficionada de cuentos visuales, en comparación con las traducciones de otros juegos, tiene varias características e implica trabajar con mucho texto.  Quizás la gran mayoría de todas las novelas visuales fueron lanzadas en japonés, solo unas pocas fueron traducidas al inglés (oficialmente o por aficionados), y aún menos fueron traducidas a otros idiomas. <br><br>  Por lo tanto, al trabajar con la traducción, debe tratar con motores japoneses, muchos de los cuales no son muy amigables con los localizadores.  Debido a esto, rápidamente nos damos cuenta de que la presencia de habilidades de traducción, conocimiento del idioma, mucho entusiasmo y tiempo libre no significa en absoluto que la versión traducida del juego pronto verá la luz del día. <br><a name="habracut"></a><br>  En términos generales, el proceso de traducir cualquier juego (no solo historias cortas visuales) implica: <br><br><ul><li>  Desempaquetar recursos del juego (si no están en el dominio público) </li><li>  Traducción de partes necesarias </li><li>  Transferencia de embalaje inverso </li></ul><br>  Sin embargo, en el caso de las historias cortas visuales japonesas, esto generalmente se ve así: <br><br><ul><li>  Desempaquetar recursos del juego </li><li>  Traducción de la parte de texto del juego (guión del juego) </li><li>  Traducción de la parte gráfica del juego. </li><li>  Transferencia de embalaje inverso </li><li>  Alteración del motor para que funcione con contenido traducido </li></ul><br>  Espero que nuestra experiencia sea útil para alguien. <br><br>  En 2013 (y posiblemente antes) decidí traducir del japonés la novela visual Bishoujo Mangekyou-Norowareshi Densetsu no Shoujo- (美 少女 万 華 鏡 - 呪 わ れ し 伝 説 の 少女 -).  Ya tenía experiencia en la traducción de juegos, pero antes tenía que traducir solo historias cortas en motores relativamente simples y conocidos como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kirikiri</a> . <br><br>  Aquí, nuestro equipo de traductores tuvo que abrir el motor de esta historia corta, incluso antes de llegar al texto en sí. <br><br>  Comencemos con una descripción del archivo .exe, donde se mencionan las palabras QLIE e IMOSURUME.  El archivo en sí contiene la línea FastMM Borland Edition 2004, 2005 Pierre le Riche, lo que significa que el motor probablemente esté escrito en Delphi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kx/ss/sg/kxsssg_foyhzeykfu1e4s5pneok.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/ge/zc/zogezc8m47t1cflh-yqpzl85fby.png"></div><br>  Una búsqueda rápida en Google revela que Qlie es el nombre del motor de novela visual lanzado por Warmth Entertainment.  Aparentemente, IMOSURUME es el nombre interno del motor de script, y Qlie es el nombre comercial.  Hay un sitio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">qlie.net</a> , que enumera los juegos lanzados en este motor y el sitio web oficial de Warmth Entertainment. <br><br>  Pero en ninguna parte del dominio público no hay herramientas oficiales para trabajar con el motor, ni documentación para ello, lo que se espera. <br><br>  Por lo tanto, debes lidiar con el juego tú mismo, confiando en utilidades no oficiales.  Para empezar, debes encontrar todas las partes del juego que necesitan ser traducidas. <br><br>  Los archivos del juego se encuentran en los archivos data0.pack, data1.pack y data7.pack en la subcarpeta \ GameData.  Los protectores de pantalla están en la carpeta \ GameData \ Movie, pero aún puede dejarlos solos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/fh/on/grfhont7xq1rascbvzu8v1mhkec.png"></div><br>  El editor hexadecimal muestra que no hay encabezados reconocibles para los archivos .pack del juego, pero al final del archivo hay una pieza similar a la tabla de contenido y la etiqueta FilePackVer3.0 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yf/qd/1q/yfqd1qyy7ozx0ygvq_bj_tmkms4.png"></div><br>  Afortunadamente, para este formato, ya hay un desempacador y ni siquiera uno.  Utilizamos la consola exfp3_v3 de asmodean. <br><br>  Desempacar no es tan fácil como parece.  Dado que el motor admite varios formatos de archivo (FilePackVer1.0, FilePackVer1.0, FilePackVer3.0), y en este caso se utiliza FilePackVer3.0, para el desempaquetado correcto también necesitará un archivo de clave especial key.fkey, que cifró el archivo.  Se encuentra en la subcarpeta \ Dll <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fa/fq/qe/fafqqeqgfwisqr1ijhg9qpcmsm4.png"></div><br>  Además, exfp3_v3 debería aclarar el archivo desde el que se está descomprimiendo el juego. <br>  Por lo tanto, también debe especificar el número de juego de la lista propuesta por el desempacador (los juegos de la serie Bishoujo Mangekyou están bajo el número 15), o especificar el archivo ejecutable del juego como el tercer parámetro para el desempacador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9r/nr/-z/9rnr-zngqxajz8pysxwv3v8u8gk.png"></div><br>  Ya después de desempaquetar los archivos del juego, surgió un pensamiento lógico: ¿cómo en el futuro cómo empacar el juego con una traducción lista?  Después de todo, el desempacador no admite la operación inversa. <br>  A petición nuestra, w8m (muchas gracias por eso) agregó la capacidad de empaquetar archivos del juego en su programa arc_conv.exe.  Es suficiente empacar todos los archivos modificados en un nuevo archivo (por ejemplo, data8.pack), colocarlo en la carpeta GameData y se incorporarán automáticamente al juego. <br><br>  Volver a los recursos desempaquetados.  Los archivos de script del juego del archivo data0.pack se pueden encontrar en la subcarpeta \ escenario \ ks_01 \ <br><br>  Todos los archivos de script con la extensión .s están codificados lejos de la codificación Shift Jis más conveniente, y el motor no admite codificaciones Unicode.  Las líneas para la traducción se parecen aproximadamente a estas: <br><br><pre><code class="python hljs">【キリエ】 ％<span class="hljs-number"><span class="hljs-number">1</span></span>_kiri1478％ 「へえ……分かっているじゃない」 私が献上したロシアンティーを見て、キリエは嬉しそうに目を細める。 ^cface,,赤目微笑<span class="hljs-number"><span class="hljs-number">01</span></span> 【キリエ】 ％<span class="hljs-number"><span class="hljs-number">1</span></span>_kiri1479％ 「日本人は、ジャムを紅茶に入れて飲むのが、ロシアンティーだと勘違いしている人が多いのだけれど……」</code> </pre> <br>  Puede notar que cada frase en japonés está precedida por el nombre del héroe entre paréntesis japoneses.  (【】), Que pronuncia esta frase (en el juego se muestra en la parte superior de la ventana con texto).  O, si estas son las palabras del autor, entonces el nombre no se agrega. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ws/d_/dz/wsd_dzwzrz-sjk_0shl7zw3ov5k.png"></div><br>  Pero todavía hay equipos de servicio. <br><br>  Los comandos del motor en el script recuerdan un poco el lenguaje de marcado TeX, pero son mucho más intuitivos e inconvenientes en comparación con los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comandos</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kirikiri</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RenPy</a> . <br><br>  Aquí hay algunos de ellos: <br><br>  <code>@@@</code> es un perro triple.  A menudo, los archivos de comandos comienzan con este comando.  Aparentemente cargando definiciones de archivos de terceros. <br><br>  Por ejemplo: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@@@Library\Avg\header.s</span></span></code> </pre> <br>  <code>@@</code> es un perro doble.  La etiqueta en el archivo de script.  Puedes cambiarlo más tarde. <br><br>  <code>％1_kiri1478％</code> : reproduce el archivo de voz.  Estos comandos se insertan entre el nombre del héroe y el texto que se muestra en la pantalla.  “1_kiri1478”: en este caso, el nombre del archivo de la carpeta \ voice \ del archivo data1.pack Es interesante que el equipo use el porcentaje japonés (％), en lugar del habitual. <br><br>  <code>^savedate, ^saveroute, ^savescene,</code> - tres equipos que probablemente se usan en el sistema de guardado del juego y deben ingresar información sobre el lugar y la hora en que el jugador se guardó en el juego guardado. <br><br>  Por ejemplo: <br><br><pre> <code class="python hljs">^savedate,<span class="hljs-string"><span class="hljs-string">"現在"</span></span> ^saveroute,<span class="hljs-string"><span class="hljs-string">"美少女万華鏡－１－"</span></span> ^savescene,<span class="hljs-string"><span class="hljs-string">"呪われし伝説の少女 オープニング"</span></span></code> </pre> <br>  Es decir, fecha: presente, rama: Bishoujo Mangekyou -1-, escena: Norowareshi Densetsu no Shoujo Opening.  Estos datos deberían haberse mostrado en la ranura de guardado, pero aparentemente los desarrolladores decidieron abandonarlos.  Como resultado, <code>^saveroute</code> en todas las partes del guión, <code>^savedate</code> cambia de "el momento presente" a "sueños", y en <code>^savescene</code> días (o más bien las noches) en el juego. <br><br>  <code>^facewindow,</code> - estado del cuadro de texto con el texto que se muestra en la pantalla.  (Se muestra - 1 o no - 0) <br><br>  <code>^sload,</code> - reproduce sonidos en el juego desde la carpeta \ sound \ en el canal correspondiente. <br><br><pre> <code class="python hljs">sload,Env1,◆セミ<span class="hljs-number"><span class="hljs-number">01</span></span>アブラゼミ</code> </pre> <br>  Tocando cigarras en Env1 <br><br>  El equipo tiene dos parámetros opcionales, el primero es responsable de reproducir el sonido y el segundo sigue siendo un misterio, pero rara vez se usa en el juego. <br><br><pre> <code class="python hljs">^sload,SE1,■クチュ音<span class="hljs-number"><span class="hljs-number">01</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Reproducción de sonido loopback en el canal SE1. <br><br>  <code>^eeffect</code> : muestra un efecto especial en la pantalla durante un cierto número de segundos.  Aparentemente, admite salida secuencial de varios efectos. <br><br><pre> <code class="python hljs">^eeffect,WhiteFlash</code> </pre> <br>  El efecto de un destello blanco. <br><br>  <code>^ffade</code> - efecto de transición al cambiar la pantalla. <br>  Tiene un montón de parámetros adicionales, pero solo unos pocos son realmente útiles: el nombre del efecto de transición, una imagen adicional, si es necesario, y el tiempo de finalización de la transición. <br><br><pre> <code class="python hljs">^ffade,Overlap,,<span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br>  Disolviendo una imagen en otra, en 1 segundo. <br><br>  <code>^iload</code> : carga la imagen de fondo en la pantalla.  A la imagen se le puede asignar una identificación para hacer referencia en el futuro. <br><br><pre> <code class="python hljs">^iload,BG1,<span class="hljs-number"><span class="hljs-number">0</span></span>_black.png</code> </pre> <br>  Archivo de salida 0_black.png como fondo con id BG1 <br><br>  <code>^we</code> and <code>^wd</code> : <code>^wd</code> y desactiva la imagen en la ventana. <br><br>  <code>^facewindow,1</code> y <code>^facewindow,0</code> Activa y desactiva la imagen del héroe en el cuadro de diálogo. <br><br>  <code>^mload</code> : reproduce música en un canal específico. <br><br><pre> <code class="python hljs">^mload,BGM1,nbgm13</code> </pre> <br>  Reproduciendo la pista nbgm13 en el canal BGM1 <br><br>  Algunos de los equipos más importantes: <br>  <code>\jmp</code> : salta a la etiqueta con el nombre especificado. <br><br>  <code>^select</code> : muestra la ventana de selección en la pantalla, donde el jugador debe elegir una de las opciones. <br><br>  Por ejemplo: <br><br><pre> <code class="python hljs">^select, ,  \jmp,<span class="hljs-string"><span class="hljs-string">"@@route01a"</span></span>+ResultBtnInt[<span class="hljs-number"><span class="hljs-number">0</span></span>] @@route01a0</code> </pre> <br>  Aquí la transición se realizará después de la respuesta a la pregunta, y el número de respuesta (0 o 1) se devuelve desde ResultBtnInt [0].  Como resultado, <code>\jmp</code> moverá la historia a la etiqueta @@ route01a + número de respuesta.  Es decir, @@ route01a0 o @@ route01a1 <br><br>  Una característica desagradable es que la coma habitual en estos comandos sirve como separador y no se puede usar en las opciones de respuesta.  Los japoneses no tienen ese problema, usan la coma japonesa (、).  En este caso, podemos reemplazar la coma con ‚(U + 201A SINGLE LOW-9 COOT MARK). <br><br>  Por ejemplo: <br><br><pre> <code class="python hljs">^select, ‚  , ‚ </code> </pre> <br>  Los equipos restantes no son tan importantes en la primera aproximación. <br><br>  Por supuesto, antes de traducir el script, debe transcodificarlo en algo más conveniente, por ejemplo, en UTF-8, para combinar caracteres cirílicos y japoneses. <br><br>  Después de cambiar el motor (sobre la siguiente parte), el juego percibe tanto el texto ruso como el japonés.  Pero por ahora, por compatibilidad, debe codificar los caracteres japoneses en Shift Jis y los caracteres cirílicos en la codificación cp1251. <br><br>  Esbozamos rápidamente un programa en Python para transcodificar teniendo en cuenta el alfabeto cirílico: <br><br><div class="spoiler">  <b class="spoiler_title">UTF8 a cp1251 y ShiftJIS</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # UTF8 to cp1251 and ShiftJIS recoder # by Chtobi and Nazon, 2016 import codecs import argparse from os import path JAPANESE_CODEPAGE = 'shift_jis' UTF_CODEPAGE = 'utf-8' RUS_CODEPAGE = 'cp1251' def nonrus_handler(e): if e.object[e.start:e.end] == '～': # UTF-8: 0xEFBD9E -&gt; SHIFT-JIS: 0x8160 japstr_byte = b'\x81\x60' elif e.object[e.start:e.end] == '－': # UTF-8: 0xEFBC8D -&gt; SHIFT-JIS: 0x817C japstr_byte = b'\x81\x7c' else: japstr_byte = (e.object[e.start:e.end]).encode(JAPANESE_CODEPAGE) return japstr_byte, e.end if __name__ == '__main__': arg_parser = argparse.ArgumentParser(prog="Recode to cp1251 and ShiftJIS", description="Program to encode UTF8 text file to " "cp1251 for all cyrillic symbols and ShiftJIS for others. " "Output file will be inputfilename.s", usage="recode_to_cp1251_shiftjis.py file_name") arg_parser.add_argument('file_name', nargs=1, type=argparse.FileType(mode='r', bufsize=-1), help="Input text file name. Only files coded in UTF8 are allowed.\n") codecs.register_error('nonrus_handler', nonrus_handler) input_name = arg_parser.parse_args().file_name[0].name output_name = path.splitext(input_name)[0] + ".s" with open(input_name, 'rt', encoding=UTF_CODEPAGE) as input_file: with open(output_name, 'wb') as output_file: for line in input_file: for char1 in line: bytes_out = bytes(line, UTF_CODEPAGE) output_file.write(char1.encode(RUS_CODEPAGE, "nonrus_handler")) print("Done.")</span></span></code> </pre><br></div></div><br>  Sin embargo, hubo algunos problemas.  El programa, al intentar recodificar el símbolo de "tilde" U (U + FF5E FULLWIDTH TILDE), generó un error "UnicodeEncodeError: el códec 'Shift Jis' no puede codificar el carácter '\ uff5e' en la posición 0: secuencia multibyte ilegal" <br><br>  Al principio, pequé en Python, pero al final descubrí un matiz bastante inusual.  Existe una incertidumbre entre los métodos de correlación de codificaciones japonesas Unicode y no Unicode dependiendo de la implementación específica. <br><br>  Como resultado, Windows asocia el carácter Shift Jis con el código 0x8160 con el unicode ～ (U + FF5E FULLWIDTH TILDE) y otros transcodificadores (por ejemplo, la utilidad iconv) correlacionan el mismo carácter con 〜 (U + 301C WAVE DASH), de acuerdo con la tabla oficial de relaciones Unicode - <a href="">ftp://ftp.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/JIS/SHIFT JIS.TXT</a> <br><br>  Para determinar la correspondencia entre los personajes, Microsoft aparentemente decidió usar los esquemas de su codificación cp932, que es una versión extendida de Shift Jis. <br><br>  La misma situación ocurre con el código de carácter 0x817C, que se transcodifica a UTF8 como - (U + FF0D FULLWIDTH HYPHEN-MINUS) en Windows, o como - (U + 2212 SIGNO MENOS) en iconv. <br><br>  Dado que todos los archivos de script se convirtieron por primera vez de Shift Jis a UTF8 usando Notepad ++ (y usa la tabla de correspondencia adoptada en Windows), al volver a convertir de UTF8 a Shift Jis a través de nuestro programa Python, apareció el notorio error de conversión. <br><br>  Por lo tanto, era necesario tener en cuenta la aparición de ～ y - condiciones separadas. <br><br>  Hubo otros defectos menores, por ejemplo, la elipsis ... (U + 2026 ELIPSIS HORIZONTAL) fue reemplazada por la elipsis cirílica de cp1251, y no los japoneses de Shift Jis. <br><br>  Después de traducir el texto, puede continuar trabajando con los gráficos del juego. <br><br>  Los archivos gráficos del juego se encuentran en los mismos archivos del paquete, pero después de desempaquetar, todavía tienen que trabajar duro.  Por ejemplo, casi todas las imágenes png se descomprimen en forma de archivos del tipo de muestra + DPNG000 + x32y0.png En otras palabras, las imágenes png se cortan en tiras horizontales con un grosor de 88 píxeles y cada tira se graba en un archivo separado.  El nombre del archivo muestra el número de serie de la tira (DPNG000 ... 009) y las coordenadas x, y. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gj/ak/x_/gjakx_76ep3syu_gf9qfobolmj8.png"></div><br>  Todavía me pregunto por qué esto era necesario.  Si por la dificultad de extraer recursos del juego, claramente este no es el mejor método. <br><br>  Para pegar los archivos png cortados, se creó un pequeño script merge_dpng en Pearl desde asmodeus, que usa ImageMagick, al mismo tiempo.  Desafortunadamente, hubo problemas con él.  En primer lugar, necesitaba Pearl, que no usé, e incluso después de instalarlo, resultó que el script no funcionaba correctamente. <br><br>  Por esta razón, escribimos un programa similar en python: <br><br><div class="spoiler">  <b class="spoiler_title">Qlie motor dpng fusión de archivos</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Qlie engine dpng files merger # by Chtobi and Nazon, 2016 # Requires ImageMagick magick.exe on the path. import os import glob import re import argparse import subprocess IMGMAGIC = os.path.dirname(os.path.abspath(__file__)) + '\\' + 'magick.exe' IMGMAGIC_PARAMS1 = ['-background', 'rgba(0,0,0,0)'] IMGMAGIC_PARAMS2 = ['-mosaic'] INPUT_FILES_MASK = '*+DPNG[0-9][0-9][0-9]+*.png' SPLIT_MASK = '+DPNG' x_y_ajusts_re = re.compile('(.+)\+DPNG[0-9][0-9][0-9]\+x(\d+)y(\d+)\.') if __name__ == '__main__': arg_parser = argparse.ArgumentParser(prog="DPNG Merger\n" "Program to merge sliced png files from QLIE engine. " "All files with mask *+DPNG[0-9][0-9][0-9]+*.png" "into the input directory will be merged and copied to the" "output directory.\n", usage="connect_png.py input_dir [output_dir]\n") arg_parser.add_argument("input_dir_param", nargs=1, help="Full path to the input directory.\n") arg_parser.add_argument("output_dir_param", nargs='?', default=os.path.dirname(os.path.abspath(__file__)), help="Full path to the output directory. " "It would be a script parent directory if not specified.\n") input_dir = arg_parser.parse_args().input_dir_param[0] output_dir = arg_parser.parse_args().output_dir_param[0] os.chdir(input_dir) all_append_files = glob.glob(INPUT_FILES_MASK) # Select only files with DPNG prep_bunches = [] for file_in_dir in all_append_files: # Check all files and put all splices that should be connected in separate list for num, bunch in enumerate(prep_bunches): name_first_part = bunch[0].partition(SPLIT_MASK)[0] # Part of the filename before +DPNG should be unique if name_first_part == file_in_dir.partition(SPLIT_MASK)[0]: prep_bunches[num].append(file_in_dir) break else: prep_bunches.append([file_in_dir]) os.chdir(os.path.dirname(os.path.abspath(__file__))) # Go to the script parent dir for prepared_bunch in prep_bunches: sorted_bunch = sorted(prepared_bunch) # Prepare -page params for imgmagic png_pages_params = [["(", "-page", "+{0}+{1}".format(*[(x_y_ajusts_re.match(part_file).group(2)), x_y_ajusts_re.match(part_file).group(3)]), input_dir+part_file, ")"] for part_file in sorted_bunch] connect_png_list = \ [imgmagick_page for imgmagick_pages in png_pages_params for imgmagick_page in imgmagick_pages] output_file = output_dir + sorted_bunch[0].partition(SPLIT_MASK)[0] + ".png" subprocess.check_output([IMGMAGIC] + IMGMAGIC_PARAMS1 + connect_png_list + IMGMAGIC_PARAMS2 + [output_file])</span></span></code> </pre> <br></div></div><br>  ¿Parece que ahora tenemos todo el conjunto de imágenes que aparecen en el juego?  Para nada: si mira todas las imágenes conectadas de todos los archivos, todavía encontrará que faltan algunas, aunque están en el juego.  El hecho es que hay otro tipo de archivo en el motor, con la extensión .b.  Es una especie de animación con imágenes y sonidos grabados en su interior. <br><br>  Es bastante fácil obtener los recursos almacenados en su interior, pero, desafortunadamente, ninguno de los desempacadores de archivos .b ya funcionaba en nuestro caso como debería.  O algunos archivos permanecieron sin empaquetar, o hubo errores debido a nombres japoneses, y no quería arrancar desde la configuración regional japonesa. <br><br>  Aquí uno más nuestro script fue útil.  Desde entonces no estábamos familiarizados con algo como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Kaitai Struct</a> , tuvimos que actuar casi desde cero. <br><br>  El formato de los archivos .b resultó ser simple y, además, nuestro descomprimidor debía poder descomprimir recursos solo de este juego.  En otros juegos en el motor Qlie, aparecieron tipos adicionales de recursos dentro de los archivos .b, pero no nos detendremos en ellos en detalle. <br><br>  Entonces, abra cualquier archivo .b en un editor hexadecimal y mire hacia el principio.  Antes de evaluar, tenga en cuenta que el orden de bytes de todos los valores numéricos será Little-endian. <br><br><ul><li>  Encabezado de archivo abmp12 </li><li>  Diez bytes 0x00 </li><li>  El título de la primera sección abdata12 con información general. </li><li>  Ocho bytes 0x00 </li><li>  Tamaño de sección abdata12, entero de cuatro bytes.  Puedes saltartelo con seguridad. </li><li>  Encabezado de sección Abimage10 </li><li>  Siete bytes 0x00 </li><li>  Número de archivos en una sección, entero de un solo byte.  En este caso, hay un archivo en la sección. </li><li>  Encabezado de sección abgimgdat13 </li><li>  Seis bytes 0x00 </li><li>  La longitud del nombre del archivo dentro de la sección, un entero de dos bytes.  En este caso, la longitud es de 4 bytes. </li><li>  Shift Jis nombre de archivo codificado </li><li>  Longitud de registro de suma de comprobación de archivo, entero de doble byte. </li><li>  La suma de comprobación del archivo en sí. </li><li>  El byte desconocido parece ser siempre 0x03 o 0x02 </li><li>  Doce bytes desconocidos, posiblemente relacionados con la animación. </li><li>  El tamaño del archivo png dentro de la sección es un entero de cuatro bytes. </li></ul><br>  Y finalmente, el archivo png en sí. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/64/v4/yc/64v4ycd37hyu-pyqsxyb2g1ahqa.png"></div><br>  La sección de absound es similar en estructura a abimage. <br><br><div class="spoiler">  <b class="spoiler_title">Extractor animado de BMP</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Extract b # AnimatedBMP extractor for Bishoujo Mangekyou game files # by Chtobi and Nazon, 2016 import glob import os import struct import argparse from collections import namedtuple b_hdr = b'abmp12'+bytes(10) signa_len = 16 b_abdata = (b'abdata10'+bytes(8), b'abdata11'+bytes(8), b'abdata12'+bytes(8), b'abdata13'+bytes(8)) b_imgdat = (b'abimgdat10'+bytes(6), b'abimgdat11'+bytes(6), b'abimgdat14'+bytes(6)) b_img = (b'abimage10'+bytes(7), b'abimage11'+bytes(7), b'abimage12'+bytes(7), b'abimage13'+bytes(7), b'abimage14'+bytes(7)) b_sound = (b'absound10'+bytes(7), b'absound11'+bytes(7), b'absound12'+bytes(7)) # not sure about structure of sound11 and sound12 b_snd = (b'absnddat11'+bytes(7), b'absnddat10'+bytes(7), b'absnddat12'+bytes(7)) Abimgdat13_pattern = namedtuple('Abimgdat13', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'unknown2_len', 'data_size_len']) Abimgdat13 = Abimgdat13_pattern(signa=b'abimgdat13'+bytes(6), name_size_len=2, hash_size_len=2, unknown1_len=1, unknown2_len=12, data_size_len=4) Abimgdat14_pattern = namedtuple('Abimgdat14', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) Abimgdat14 = Abimgdat14_pattern(signa=b'abimgdat14'+bytes(6), name_size_len=2, hash_size_len=2, unknown1_len=77, data_size_len=4) Abimgdat_pattern = namedtuple('Abimgdat', ['name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) # probably, abimgdat10,abimgdat11 and others Other_imgdat = Abimgdat_pattern(name_size_len=2, hash_size_len=2, unknown1_len=1, data_size_len=4) Absnddat11_pattern = namedtuple('Absnddat11', ['signa', 'name_size_len', 'hash_size_len', 'unknown1_len', 'data_size_len']) Absnddat11 = Absnddat11_pattern(signa=b'absnddat11'+bytes(7), name_size_len=2, hash_size_len=2, unknown1_len=1, data_size_len=4) def create_parser(): arg_parser = argparse.ArgumentParser(prog='AnimatedBMP extractor\n', usage='extract_b input_file_name output_dir\n', description='AnimatedBMP extractor for QLIE engine *.b files.\n') arg_parser.add_argument('input_file_name', nargs='+', help="Input file with full path(wildcards are supported).\n") arg_parser.add_argument('output_dir', nargs=1, help="Output directory.\n") return arg_parser def check_type(file_buf): if file_buf.startswith(b'\x89' + b'PNG'): return '.png' elif file_buf.startswith(b'BM'): return '.bmp' elif file_buf.startswith(b'JFIF', 6): return '.jpg' elif file_buf.startswith(b'IMOAVI'): return '.imoavi' elif file_buf.startswith(b'OggS'): return '.ogg' elif file_buf.startswith(b'RIFF'): return '.wav' else: return '' def bytes_shiftjis_to_utf8(shiftjis_bytes): shiftjis_str = shiftjis_bytes.decode('shift_jis', 'strict') utf_str = shiftjis_str.encode('utf-8', 'strict').decode('utf-8', 'strict') return utf_str def check_signa(f_buffer): if f_buffer.endswith(b_abdata): return 'abdata' elif f_buffer.endswith(b_img): return 'abimgdat' elif f_buffer.endswith(b_sound): return 'absound' def prepare_filename(out_file_name, out_dir, postfix=''): ready_name = out_dir + os.path.basename(out_file_name) + postfix return ready_name def create_file(file_name_hndl, out_buffer): if len(out_buffer) != 0: with open(file_name_hndl, 'wb') as ext_file: ext_file.write(out_buffer) else: print("Zero file. Skipped.") def check_file_header(file_handle, bytes_num): file_handle.seek(0) readed_bytes = file_handle.read(bytes_num) if readed_bytes == b_hdr: print("File is valid abmp") return True else: print("Can't read header. Probably, wrong file...") return False if __name__ == '__main__': parser = create_parser() arguments = parser.parse_args() all_b_files = glob.glob(arguments.input_file_name[0]) output_dir = arguments.output_dir[0] for b_file in all_b_files: file_buffer = bytearray(b'') with open(b_file, 'rb') as bfile_h: check_file_header(bfile_h, len(b_hdr)) read_byte = bfile_h.read(1) file_buffer.extend(read_byte) while read_byte: read_byte = bfile_h.read(1) file_buffer.extend(read_byte) # Finding content sections signature check_result = check_signa(file_buffer) if check_result: if check_result == 'abdata': file_buffer = bytearray(b'') read_length = bfile_h.read(4) size = struct.unpack('&lt;L', read_length)[0] file_buffer.extend(bfile_h.read(size)) # Adding _abdata to separate from other parts outfile_name = prepare_filename(b_file, output_dir, '_abdata') create_file(outfile_name, file_buffer) elif check_result == 'abimgdat': images_number = struct.unpack('B', bfile_h.read(1))[0] # Number of pictures in section for i1 in range(images_number): file_buffer = bytearray(b'') file_name = '' imgsec_hdr = bfile_h.read(signa_len) if imgsec_hdr == Abimgdat13.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat13.name_size_len))[0] # Decode filename to utf8 file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) # CRC size hash_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat13.hash_size_len))[0] # Picture CRC (don't need it) pic_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Abimgdat13.unknown1_len) unknown2 = bfile_h.read(Abimgdat13.unknown2_len) pic_size = struct.unpack('&lt;L', bfile_h.read(Abimgdat13.data_size_len))[0] print("pic_size:", pic_size) file_buffer.extend(bfile_h.read(pic_size)) elif imgsec_hdr == Abimgdat14.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat14.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Abimgdat14.hash_size_len))[0] pic_hash = bfile_h.read(hash_size) bfile_h.seek(Abimgdat14.unknown1_len, os.SEEK_CUR) pic_size = struct.unpack('&lt;L', bfile_h.read(Abimgdat14.data_size_len))[0] file_buffer.extend(bfile_h.read(pic_size)) else: # probably abimgdat10, abimgdat11... file_name_size = struct.unpack('&lt;H', bfile_h.read(Other_imgdat.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Other_imgdat.hash_size_len))[0] pic_hash = bfile_h.read(hash_size) bfile_h.seek(Other_imgdat.unknown1_len, os.SEEK_CUR) pic_size = struct.unpack('&lt;L', bfile_h.read(Other_imgdat.data_size_len))[0] file_buffer.extend(bfile_h.read(pic_size)) for i, letter in enumerate(file_name): # Replace any unusable symbols from filename with _ if letter == '&lt;' or letter == '&gt;' or letter == '*' or letter == '/': file_name = file_name.replace(letter, "_") # Checking file signature and adding proper extension outfile_name = prepare_filename(b_file, output_dir, '_' + file_name + check_type(file_buffer)) create_file(outfile_name, file_buffer) file_buffer = bytearray(b'') elif check_result == 'absound': sound_files_number = struct.unpack('B', bfile_h.read(1))[0] for i2 in range(sound_files_number): file_buffer = bytearray(b'') file_name = '' sndsec_hdr = bfile_h.read(signa_len) if sndsec_hdr == Absnddat11.signa: file_name_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.hash_size_len))[0] snd_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Absnddat11.unknown1_len) snd_size = struct.unpack('&lt;L', bfile_h.read(Absnddat11.data_size_len))[0] file_buffer.extend(bfile_h.read(snd_size)) else: file_name_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.name_size_len))[0] file_name = bytes_shiftjis_to_utf8(bfile_h.read(file_name_size)) hash_size = struct.unpack('&lt;H', bfile_h.read(Absnddat11.hash_size_len))[0] snd_hash = bfile_h.read(hash_size) unknown1 = bfile_h.read(Absnddat11.unknown1_len) snd_size = struct.unpack('&lt;L', bfile_h.read(Absnddat11.data_size_len))[0] file_buffer.extend(bfile_h.read(snd_size)) for i, letter in enumerate(file_name): if letter == '&lt;' or letter == '&gt;' or letter == '*' or letter == '/': file_name[i] = '_' outfile_name = prepare_filename(b_file, output_dir, '_' + file_name + check_type(file_buffer)) print("create absound") create_file(outfile_name, file_buffer) file_buffer = bytearray(b'')</span></span></code> </pre><br></div></div><br>  El script debe descomprimir automáticamente los archivos png, jpg, bmp, ogg y wav encontrados.  Pero además de esto, también se encuentran archivos imoavi desconocidos en su interior. <br><br>  La conclusión es que en el juego todas las animaciones se realizan como un video completo en formato ogv, o como imágenes animadas del motor que se graban en archivos .b, o como secuencias animadas de archivos jpg en formato imoavi. <br><br>  En este caso, también estábamos interesados ​​en las imágenes jpg, por lo que también tuvimos que lidiar con ellas. <br><br>  Hay dos secciones en imoavi: SOUND y MOVIE.  En la sección MOVIE, 47 bytes después del encabezado, hay cuatro bytes del tamaño del archivo jpg.  Los archivos se escriben uno tras otro en su forma original, separados por una secuencia de 19 bytes, donde se registra el tamaño del siguiente archivo. <br><br>  El imoavi sonoro en el juego no apareció, por lo que la sección de SONIDO siempre está vacía. <br><br>  Bueno, desde que comenzamos a extraer todos los recursos del juego, al mismo tiempo se escribió un pequeño guión para extraer jpg de imoavi. <br><br><div class="spoiler">  <b class="spoiler_title">Extractor de Imoavi</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># -*- coding: utf-8 -*- # Extract imoavi # Imoavi extractor for Bishoujo Mangekyou game files # by Chtobi and Nazon, 2016 import glob import os import struct import argparse imoavi_hdr = b'IMOAVI' hdr_len = len(imoavi_hdr) def create_file(file_name, out_buffer, wr_mode='wb'): if len(out_buffer) != 0: with open(file_name, wr_mode) as ext_file: ext_file.write(out_buffer) else: print("Zero file. Skipped.") def prepare_filename(file_name, out_dir, postfix=''): ready_name = out_dir + os.path.basename(file_name) + postfix return ready_name def create_parser(): arg_parser = argparse.ArgumentParser(prog='Imoavi extractor\n', usage='extract_imoavi input_file_name output_dir\n', description='Imoavi extractor for QLIE engine *.imoavi files.\n') arg_parser.add_argument('input_file_name', nargs='+', help="Input file with full path(wildcards are supported).\n") arg_parser.add_argument('output_dir', nargs='+', help="Output directory.\n") return arg_parser if __name__ == '__main__': parser = create_parser() arguments = parser.parse_args() all_imoavi = glob.glob(arguments.input_file_name[0]) output_dir = arguments.output_dir[0] for imoavi_f in all_imoavi: file_buffer = bytearray(b'') with open(imoavi_f, 'rb') as imoavi_h: # Read imoavi file header imoavi_h.read(hdr_len) imoavi_h.seek(2, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(3, os.SEEK_CUR) # 0x00 imoavi_h.seek(5, os.SEEK_CUR) # SOUND imoavi_h.seek(3, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(11, os.SEEK_CUR) imoavi_h.seek(5, os.SEEK_CUR) # Movie imoavi_h.seek(3, os.SEEK_CUR) # 00 ?? imoavi_h.seek(1, os.SEEK_CUR) # 0x64 imoavi_h.seek(3, os.SEEK_CUR) # 0x00 ?? imoavi_h.seek(4, os.SEEK_CUR) # ?? imoavi_h.seek(1, os.SEEK_CUR) # Number of jpg files in section imoavi_h.seek(4, os.SEEK_CUR) # 0x00 imoavi_h.seek(1, os.SEEK_CUR) # 0x05 ??? imoavi_h.seek(2, os.SEEK_CUR) # 0x00 ?? imoavi_h.seek(4, os.SEEK_CUR) # 720 ?? imoavi_h.seek(4, os.SEEK_CUR) # Full size without header? to_next_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] # Bytes till next header imoavi_h.seek(16, os.SEEK_CUR) # 0x00 jpg_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] imoavi_h.seek(4, os.SEEK_CUR) # 0x00 file_num = 0 file_buffer.extend(imoavi_h.read(jpg_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + (str(file_num)).zfill(3) + '.jpg') create_file(outfile_name, file_buffer) while to_next_size != 0: file_buffer = bytearray(b'') to_next_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] if to_next_size == 24: # 0x1C header for index part file_buffer.extend(imoavi_h.read(to_next_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + '.index') create_file(outfile_name, file_buffer, 'ab') # concatenate with index file else: imoavi_h.seek(2, os.SEEK_CUR) # unknown imoavi_h.seek(2, os.SEEK_CUR) # Unknown, almost always FF FF or FF FE file_num = struct.unpack('B', imoavi_h.read(1))[0] # File number imoavi_h.seek(11, os.SEEK_CUR) # 0x00 jpg_size = struct.unpack('&lt;L', imoavi_h.read(4))[0] imoavi_h.seek(4, os.SEEK_CUR) # 0x00 file_buffer.extend(imoavi_h.read(jpg_size)) outfile_name = prepare_filename(imoavi_f, output_dir, '_' + (str(file_num)).zfill(3) + '.jpg') create_file(outfile_name, file_buffer)</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Después de desempaquetar, puede asegurarse de que la animación de la pantalla de bienvenida en el menú esté almacenada solo en el archivo 1_ タ イ ト ル 画面 ム ー ビ ー .b en el formato imoavi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/81/_r/lo81_rlqvf55nia7relrkbsckey.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eso es todo con los recursos del juego. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desafortunadamente, el proceso de traducción reveló varios matices más desagradables que no se pudieron superar. El juego, como ya escribí, no admite codificaciones Unicode. Por lo tanto, todo el texto traducido se muestra con el espacio entre letras incorrecto. Hubo algunos problemas más con el empaquetado de archivos y el inicio del juego sin cambiar la codificación del sistema a japonés. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En algún momento, nosotros (o mejor dicho, el responsable de la parte técnica de la traducción en nuestro equipo) pensamos: ¿tal vez no deberíamos quedarnos con el viejo motor, sino portar la novela al motor Renpy, al mismo tiempo obtener multiplataforma? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quizás teníamos prisa, pero en algún momento, fue una pena dejar lo que empezamos y no quedaba nada más que terminar la traducción.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué encontramos durante la portabilidad? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre esto en la segunda parte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enlaces: </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestros scripts de bitbucket </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acerca de la </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tabla de codificación Shift Jis del </font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">motor Qlie japonés </font></a></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lea más sobre el problema de la transcodificación de Shift Jis a la </font></font></a> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">utilidad exfp3_v3 asmodean </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">UTF-8</font></a></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es426431/">https://habr.com/ru/post/es426431/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es426421/index.html">EHCI humanamente en ruso</a></li>
<li><a href="../es426423/index.html">mmWave en teléfonos inteligentes: cómo Qualcomm hizo posible lo imposible</a></li>
<li><a href="../es426425/index.html">Toda la verdad sobre RTOS. Artículo # 14. Secciones de memoria: introducción y servicios básicos.</a></li>
<li><a href="../es426427/index.html">Cosas útiles para "cosas": una pequeña selección con precios bajos</a></li>
<li><a href="../es426429/index.html">Instalación de FreeSWITCH 1.8 en Debian 9 (Raspbian Stretch, la imagen básica del sistema MajorDoMo Smart Home en Rasbperri Pi)</a></li>
<li><a href="../es426433/index.html">Deliciosa SMM para el restaurante.</a></li>
<li><a href="../es426435/index.html">Los mejores especialistas son los que yo mismo preparé: un curso de prueba de juegos de los expertos de Mail.Ru Group</a></li>
<li><a href="../es426437/index.html">Cómo el reconocimiento facial te ayuda a encontrar teléfonos de prueba</a></li>
<li><a href="../es426439/index.html">Falsificación de gráficos, sustitución de cotizaciones y manipulación de precios: cómo descifrar aplicaciones para negociar en el intercambio</a></li>
<li><a href="../es426441/index.html">Mail.Ru Group 20 años: códigos y puntos de control tecnológicos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>