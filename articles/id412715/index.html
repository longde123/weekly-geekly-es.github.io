<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘Œ â¬†ï¸ ğŸ“ Belajar pemrograman Go multithreaded dengan gambar ğŸ™ŒğŸ» ğŸ‘¨ğŸ¾â€ğŸ’» ğŸ‘©â€ğŸ­</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kemungkinan besar, Anda telah mendengar tentang bahasa pemrograman Go, popularitasnya terus meningkat, yang cukup masuk akal. Bahasa ini sederhana, ce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Belajar pemrograman Go multithreaded dengan gambar</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412715/"><img src="https://habrastorage.org/webt/qk/hi/im/qkhiimd_phctfhx4kka_rhpkepq.png"><br>  Kemungkinan besar, Anda telah mendengar tentang bahasa pemrograman Go, popularitasnya terus meningkat, yang cukup masuk akal.  Bahasa ini sederhana, cepat dan bergantung pada komunitas yang hebat.  Salah satu aspek yang paling aneh dari bahasa ini adalah model pemrograman multi-threaded.  Primitif yang mendasarinya memungkinkan Anda membuat program multi-utas dengan mudah dan sederhana.  Artikel ini ditujukan bagi mereka yang ingin mempelajari primitif ini: goroutine dan saluran.  Dan, melalui ilustrasi, saya akan menunjukkan cara bekerja dengannya.  Saya harap ini akan menjadi bantuan yang baik untuk Anda dalam studi Anda selanjutnya. <br><a name="habracut"></a><br><h4>  Program tunggal dan multi-utas </h4><br>  Anda kemungkinan besar sudah menulis program single-threaded.  Biasanya terlihat seperti ini: ada satu set fungsi untuk melakukan berbagai tugas, masing-masing fungsi dipanggil hanya ketika yang sebelumnya menyiapkan data untuk itu.  Dengan demikian, program berjalan secara berurutan. <br><br>  Itu akan menjadi contoh pertama kami - program penambangan bijih.  Fungsi kami akan mencari, menambang, dan memproses bijih.  Bijih di tambang dalam contoh kami diwakili oleh daftar string, fungsinya mengambil parameter dan mengembalikan daftar string "diproses".  Untuk program single-threaded, aplikasi kami akan dirancang sebagai berikut: <br><br><img src="https://habrastorage.org/webt/c5/ua/ja/c5uajayyncivzzj9_orh-u_sw34.png"><br><br>  Dalam contoh ini, semua pekerjaan dilakukan oleh satu utas (Gary's gopher).  Tiga fungsi utama: pencarian, produksi, dan pemrosesan dilakukan berurutan satu demi satu. <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} foundOre := finder(theMine) minedOre := miner(foundOre) smelter(minedOre) }</code> </pre> <br>  Jika kami mencetak hasil dari masing-masing fungsi, kami mendapatkan yang berikut: <br><br><pre> <code class="hljs powershell">From Finder: [<span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span> <span class="hljs-type"><span class="hljs-type">ore</span></span>] From Miner: [<span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span> <span class="hljs-type"><span class="hljs-type">minedOre</span></span>] From Smelter: [<span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span> <span class="hljs-type"><span class="hljs-type">smeltedOre</span></span>]</code> </pre><br>  Desain dan implementasi yang sederhana merupakan nilai tambah dari pendekatan single-threaded.  Tetapi bagaimana jika Anda ingin menjalankan dan menjalankan fungsi secara independen satu sama lain?  Di sini pemrograman multithreaded membantu Anda. <br><br><img src="https://habrastorage.org/webt/om/x1/mq/omx1mqphfsqqs57lab9bngsnggi.png"><br>  Pendekatan penambangan bijih ini jauh lebih efisien.  Sekarang beberapa utas (pedagang eceran) bekerja secara independen, dan Gary hanya mengerjakan sebagian dari pekerjaan itu.  Satu gopher mencari bijih, yang lain menghasilkan, dan yang ketiga meleleh, dan semua ini berpotensi secara simultan.  Untuk menerapkan pendekatan ini, kita memerlukan dua hal dalam kode: untuk membuat prosesor-gopher secara independen satu sama lain dan untuk mentransfer bijih di antara mereka.  Go memiliki goroutine dan saluran untuk ini. <br><br><h4>  Gorutin </h4><br>  Goroutine dapat dianggap sebagai "thread ringan", untuk membuat goroutine Anda hanya perlu meletakkan kata kunci <b>go</b> sebelum kode panggilan fungsi.  Untuk mendemonstrasikan betapa sederhananya, mari kita membuat dua fungsi pencarian, panggil mereka dengan kata kunci <b>go</b> dan cetak pesan setiap kali mereka menemukan "ore" di tambang mereka. <br><img src="https://habrastorage.org/webt/jz/wx/nb/jzwxnbgxocr-a0rq7kmdoujt_gg.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder1(theMine) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> finder2(theMine) &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//       }</span></span></code> </pre><br>  Output dari program kami adalah sebagai berikut: <br><br><pre> <code class="hljs pgsql">Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore! Finder <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> ore!</code> </pre><br>  Seperti yang Anda lihat, tidak ada urutan di mana fungsi pertama kali "menemukan bijih";  fungsi pencarian bekerja secara simultan.  Jika Anda menjalankan contoh beberapa kali, urutannya akan berbeda.  Sekarang kita dapat menjalankan program multi-threaded (multi-sphere), dan ini adalah kemajuan yang serius.  Tetapi apa yang harus dilakukan ketika kita perlu membangun hubungan antara goroutine independen?  Waktunya akan tiba untuk keajaiban saluran. <br><br><h4>  Saluran </h4><br><img src="https://habrastorage.org/webt/pa/a-/5r/paa-5r_dtecx3fzem9r0dsv42jo.png"><br>  Saluran memungkinkan goroutine untuk bertukar data.  Ini adalah semacam pipa tempat goroutin dapat mengirim dan menerima informasi dari goroutin lain. <br><img src="https://habrastorage.org/webt/-d/vp/fz/-dvpfzbpaa65exwi7l4pgerte48.png"><br>  Membaca dan menulis ke saluran dilakukan menggunakan operator panah (&lt;-), yang menunjukkan arah pergerakan data. <br><img src="https://habrastorage.org/webt/wd/1j/qp/wd1jqp8ipkwvcdgc5xbuoyy6wey.png"><br><pre> <code class="go hljs">myFirstChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) myFirstChannel &lt;- <span class="hljs-string"><span class="hljs-string">"hello"</span></span> <span class="hljs-comment"><span class="hljs-comment">//    myVariable := &lt;- myFirstChannel //   </span></span></code> </pre><br>  Sekarang pencari bakat kami tidak perlu menumpuk bijih, ia dapat segera mentransfernya lebih lanjut menggunakan saluran. <br><img src="https://habrastorage.org/webt/60/yx/_j/60yx_jlczbwcy2tfmsqgvzwp4dg.png"><br>  Saya memperbarui contoh, sekarang kode pencari bijih dan penambang adalah fungsi anonim.  Jangan terlalu repot jika Anda belum pernah menjumpai mereka sebelumnya, perlu diingat bahwa masing-masing dari mereka dipanggil dengan kata kunci <b>go</b> , oleh karena itu, itu akan dieksekusi di goroutine sendiri.  Yang paling penting di sini adalah bahwa goroutine mengirimkan data di antara mereka sendiri menggunakan saluran <b>oreChan</b> .  Dan kita akan berurusan dengan fungsi anonim lebih dekat hingga akhir. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{â€œore1â€, â€œore2â€, â€œore3â€} oreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   go func(mine [5]string) { for _, item := range mine { oreChan &lt;- item // } }(theMine) //   go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChan // fmt.Println(â€œMiner: Received â€œ + foundOre + â€œ from finderâ€) } }() &lt;-time.After(time.Second * 5) //     }</span></span></code> </pre><br>  Kesimpulan di bawah ini dengan jelas menunjukkan bahwa Penambang kami menerima tiga kali dari saluran tersebut, satu porsi setiap kali. <br><br><pre> <code class="hljs cs">Miner: Received ore1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder Miner: Received ore3 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> finder</code> </pre><br>  Jadi, sekarang kita dapat mentransfer data antara goroutine yang berbeda (akan menghubungkan), tetapi sebelum kita mulai menulis program yang kompleks, mari kita lihat beberapa sifat penting dari saluran. <br><br><h4>  Kunci </h4><br>  Dalam beberapa situasi, ketika bekerja dengan saluran, goroutin dapat diblokir.  Ini diperlukan agar goroutine dapat bersinkronisasi satu sama lain sebelum mereka mulai atau terus bekerja. <br><br><h4>  Tulis Kunci </h4><br><img src="https://habrastorage.org/webt/ir/vv/zi/irvvziqxuk3opysywirescrn40e.png"><br><br>  Ketika goroutine (gopher) mengirim data ke saluran, itu diblokir sampai goroutine lain membaca data dari saluran. <br><br><h4>  Baca kunci </h4><br><img src="https://habrastorage.org/webt/eq/e5/k8/eqe5k854n39oia6xwaavj5xfk-q.png"><br><br>  Mirip dengan mengunci ketika menulis ke saluran, goroutin dapat dikunci saat membaca dari saluran sampai tidak ada yang tertulis di sana. <br>  Jika kunci, pada pandangan pertama, tampak rumit bagi Anda, Anda dapat membayangkannya sebagai "transfer uang" antara dua goroutine (penjual akan).  Ketika seorang gopher ingin mentransfer atau menerima uang, ia harus menunggu peserta kedua dalam transaksi. <br><br>  Setelah berurusan dengan kunci goroutine pada saluran, mari kita bahas dua jenis saluran yang berbeda: buffered dan unbuffered.  Memilih jenis ini atau itu, kami sangat menentukan perilaku program. <br><br><h4>  Saluran yang tidak dibangun </h4><br><img src="https://habrastorage.org/webt/hv/k0/ba/hvk0badnrvqhncjqf9uwyrlowq8.png"><br><br>  Dalam semua contoh sebelumnya, kami hanya menggunakan saluran tersebut.  Pada saluran tersebut, hanya satu bagian data yang dapat dikirimkan pada satu waktu (dengan pemblokiran, seperti dijelaskan di atas). <br><br><h4>  Saluran yang disangga </h4><br><img src="https://habrastorage.org/webt/zs/zg/b1/zszgb15grrrjjiyaqs6gwtfkkye.png"><br><br>  Streaming dalam suatu program tidak selalu dapat disinkronkan dengan sempurna.  Misalkan, dalam contoh kita, itu terjadi bahwa pengintai gopher menemukan tiga bagian bijih, dan seorang penambang gopher berhasil mengekstraksi hanya satu bagian dari cadangan yang ditemukan pada saat yang sama.  Di sini, agar pengintaian gopher tidak menghabiskan sebagian besar waktunya, menunggu penambang menyelesaikan pekerjaannya, kita akan menggunakan saluran buffered.  Mari kita mulai dengan membuat saluran dengan kapasitas 3. <br><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  Kami dapat mengirim beberapa bagian data ke saluran buffer, tanpa perlu membacanya dengan goroutine lain.  Ini adalah perbedaan utama dari saluran yang tidak disadap. <br><br><img src="https://habrastorage.org/webt/sh/ok/f2/shokf2oswaiw1yk6i-uwplypezi.png"><br><pre> <code class="go hljs">bufferedChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"first"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 1st"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"second"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 2nd"</span></span>) bufferedChan &lt;- <span class="hljs-string"><span class="hljs-string">"third"</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"Sent 3rd"</span></span>) }() &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { firstRead := &lt;- bufferedChan fmt.Println(<span class="hljs-string"><span class="hljs-string">"Receiving.."</span></span>) fmt.Println(firstRead) secondRead := &lt;- bufferedChan fmt.Println(secondRead) thirdRead := &lt;- bufferedChan fmt.Println(thirdRead) }()</code> </pre><br>  Urutan output dalam program tersebut adalah sebagai berikut: <br><br><pre> <code class="hljs dos">Sent <span class="hljs-number"><span class="hljs-number">1</span></span>st Sent <span class="hljs-number"><span class="hljs-number">2</span></span>nd Sent <span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-built_in"><span class="hljs-built_in">rd</span></span> Receiving.. first second third</code> </pre><br>  Untuk menghindari komplikasi yang tidak perlu, kami tidak akan menggunakan saluran buffered dalam program kami.  Tetapi penting untuk diingat bahwa jenis saluran ini juga tersedia untuk digunakan. <br>  Penting juga untuk dicatat bahwa saluran buffer tidak selalu menyelamatkan Anda dari pemblokiran.  Misalnya, jika pemandu gopher sepuluh kali lebih cepat dari penambang gopher, dan mereka terhubung melalui saluran buffered dengan kapasitas 2, maka pemandu gopher akan diblokir setiap kali dikirim, jika sudah ada dua bagian data dalam saluran. <br><br><h4>  Menyatukan semuanya </h4><br>  Jadi, dengan berbekal goroutine dan saluran, kita dapat menulis sebuah program menggunakan semua keunggulan pemrograman multithreaded di Go. <br><br><img src="https://habrastorage.org/webt/cq/xa/h7/cqxah7wnmg1wbcjqwhd13gyejaw.png"><br><pre> <code class="go hljs">theMine := [<span class="hljs-number"><span class="hljs-number">5</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{<span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>, <span class="hljs-string"><span class="hljs-string">"rock"</span></span>, <span class="hljs-string"><span class="hljs-string">"ore"</span></span>} oreChannel := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) minedOreChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  go func(mine [5]string) { for _, item := range mine { if item == "ore" { oreChannel &lt;- item //   oreChannel } } }(theMine) //  go func() { for i := 0; i &lt; 3; i++ { foundOre := &lt;-oreChannel //   oreChannel fmt.Println("From Finder: ", foundOre) minedOreChan &lt;- "minedOre" //   minedOreChan } }() //  go func() { for i := 0; i &lt; 3; i++ { minedOre := &lt;-minedOreChan //   minedOreChan fmt.Println("From Miner: ", minedOre) fmt.Println("From Smelter: Ore is smelted") } }() &lt;-time.After(time.Second * 5) //    </span></span></code> </pre><br>  Program semacam itu akan menampilkan yang berikut: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Finder: ore <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Miner: minedOre <span class="hljs-keyword"><span class="hljs-keyword">From</span></span> Smelter: Ore <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> smelted</code> </pre><br>  Dibandingkan dengan contoh pertama kami, ini merupakan peningkatan besar, sekarang semua fungsi dilakukan secara independen, masing-masing di goroutine sendiri.  Dan kami juga mendapatkan konveyor dari saluran, di mana bijih ditransfer segera setelah pemrosesan.  Untuk mempertahankan fokus pada pemahaman dasar tentang pengoperasian saluran dan goroutine, saya menghilangkan beberapa poin, yang dapat menyebabkan kesulitan dalam meluncurkan program.  Kesimpulannya, saya ingin memikirkan fitur-fitur bahasa ini, karena mereka membantu dalam bekerja dengan goroutine dan saluran. <br><br><h4>  Gorutin Anonim </h4><br><img src="https://habrastorage.org/webt/ko/t5/y6/kot5y6lv7cf-3h2zbyghvqwf1is.png"><br><br>  Sama seperti kita menjalankan fungsi reguler di goroutine, kita dapat mendeklarasikan fungsi anonim segera setelah kata kunci <b>go</b> dan memanggilnya menggunakan sintaks berikut: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   go func() { fmt.Println("I'm running in my own go routine") }()</span></span></code> </pre><br>  Jadi, jika kita perlu memanggil fungsi hanya di satu tempat, kita dapat menjalankannya di goroutine terpisah tanpa khawatir tentang deklarasi sebelumnya. <br><br><h4>  Fungsi utamanya adalah goroutine. </h4><br><img src="https://habrastorage.org/webt/c_/bo/y7/c_boy7hpqt3y3krcd1utthdjy3s.png"><br><br>  Ya, fungsi <b>utama</b> tidak bekerja di goroutine sendiri.  Dan, yang lebih penting, setelah selesai, semua goroutine lainnya juga berakhir.  Karena alasan inilah kami menempatkan penghitung waktu di akhir fungsi <b>utama</b> kami.  Panggilan ini menciptakan saluran dan mengirimkan data setelah 5 detik. <br><br><pre> <code class="go hljs">&lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre><br>  Ingat bahwa goroutine akan diblokir saat membaca dari saluran sampai ada sesuatu yang dikirim ke sana?  Inilah yang terjadi ketika kode yang ditentukan ditambahkan.  Goroutine utama akan diblokir, memberi goroutias lainnya 5 detik waktu untuk bekerja.  Metode ini bekerja dengan baik, tetapi biasanya pendekatan yang berbeda digunakan untuk memverifikasi bahwa semua goroutine telah menyelesaikan pekerjaan mereka.  Untuk mengirimkan sinyal tentang penyelesaian pekerjaan, saluran khusus dibuat, goroutine utama diblokir agar tidak dapat membacanya, dan segera setelah putrinya goroutine menyelesaikan pekerjaannya, ia menulis ke saluran ini;  Goroutine utama tidak dikunci dan program berakhir. <br><br><img src="https://habrastorage.org/webt/vi/4e/zv/vi4ezv-tyvzugvamrwi3z9xod8a.png"><br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { doneChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//  -  doneChan &lt;- â€œI'm all done!â€ }() &lt;-doneChan //        }</span></span></code> </pre><br><h4>  Baca dari pipa dalam lingkaran for-range </h4><br>  Dalam contoh kami, dalam fungsi goffer-getter, kami menggunakan loop <b>for</b> untuk memilih tiga elemen dari saluran.  Tapi apa yang harus dilakukan jika tidak diketahui sebelumnya berapa banyak data yang bisa di saluran?  Dalam kasus seperti itu, Anda bisa menggunakan saluran sebagai argumen untuk loop <b>for-range</b> , seperti halnya dengan koleksi.  Fungsi yang diperbarui mungkin terlihat seperti ini: <br><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//  go func() { for foundOre := range oreChan { fmt.Println(â€œMiner: Received â€œ + foundOre + â€œ from finderâ€) } }()</span></span></code> </pre><br>  Dengan demikian, penambang bijih akan membaca semua yang dikirim pramuka kepadanya, menggunakan saluran dalam siklus akan menjamin ini.  Harap perhatikan bahwa setelah semua data dari saluran diproses, siklus akan mengunci saat membaca;  untuk menghindari pemblokiran, Anda perlu menutup saluran dengan memanggil <b>tutup (saluran)</b> . <br><br><h4>  Pembacaan saluran non-blocking </h4><br>  Menggunakan konstruksi <b>case-pilih</b> , memblokir pembacaan dari pipa dapat dihindari.  Berikut ini adalah contoh penggunaan konstruksi ini: goroutine akan membaca data dari saluran, jika hanya ada di sana, jika tidak blok <b>default</b> dijalankan: <br><br><pre> <code class="go hljs">myChan := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ myChan &lt;- â€œMessage!â€ }() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(â€œNo Msgâ€) } &lt;-time.After(time.Second * <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> msg := &lt;- myChan: fmt.Println(msg) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(â€œNo Msgâ€) }</code> </pre><br>  Setelah diluncurkan, kode ini akan menampilkan yang berikut: <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-type"><span class="hljs-type">Msg</span></span> <span class="hljs-type"><span class="hljs-type">Message!</span></span></code> </pre><br><h4>  Rekaman saluran yang tidak menghalangi </h4><br>  Mengunci saat menulis ke saluran dapat dihindari dengan menggunakan konstruksi <b>case-pilih yang</b> sama.  Mari kita edit kecil ke contoh sebelumnya: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> myChan &lt;- â€œmessageâ€: fmt.Println(â€œsent the messageâ€) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(â€œno message sentâ€) }</code> </pre><br><h4>  Apa yang harus dipelajari lebih lanjut </h4><br><img src="https://habrastorage.org/webt/d6/69/yd/d669ydnx51qv_h0tf-p-lbo8xyu.png"><br><br>  Ada banyak artikel dan laporan yang meliput pekerjaan dengan saluran dan goroutine secara lebih rinci.  Dan sekarang, dengan kode Anda memiliki gagasan yang jelas tentang mengapa dan bagaimana alat ini digunakan, Anda bisa mendapatkan yang terbaik dari bahan-bahan berikut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Google I / O 2012 - Go Concurrency Patterns</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rob Pike - 'Concurrency Is Not Parallelism'</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GopherCon 2017: Edward Muller - Go Anti-Patterns</a> </li></ul><br><br>  Terima kasih telah meluangkan waktu untuk membaca.  Saya harap saya membantu Anda memahami saluran, goroutine, dan manfaat yang diberikan program multithreaded kepada Anda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412715/">https://habr.com/ru/post/id412715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412703/index.html">Pada konferensi dengan Veeam: ulasan tentang VeeamON 2018 dan undangan untuk Forum VeeamON di Moskow</a></li>
<li><a href="../id412705/index.html">Meretas sistem: bagaimana kami mengubah pemilihan dan adaptasi pengembang</a></li>
<li><a href="../id412709/index.html">Oh, Kode Saya: Pembelajaran Mesin dan Analisis di Teman Sekelas</a></li>
<li><a href="../id412711/index.html">Untuk memeriksa persamaan Einstein, Anda perlu menendang lubang hitam</a></li>
<li><a href="../id412713/index.html">Ikhtisar inovasi paling menarik dari pembaruan May Power BI</a></li>
<li><a href="../id412717/index.html">Halo alien; tolong jangan bunuh kami</a></li>
<li><a href="../id412719/index.html">MDG mengumumkan kompetisi sintesis wicara</a></li>
<li><a href="../id412721/index.html">Tiga harapan umat manusia untuk penemuan alien</a></li>
<li><a href="../id412723/index.html">Mencari warna miliar dolar baru</a></li>
<li><a href="../id412725/index.html">Cara membuat infrastruktur TI Anda membosankan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>