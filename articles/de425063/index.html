<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòì ü§ï ü§Ωüèø Migrieren eines Datenbankschemas ohne Ausfallzeit f√ºr postgresql am Beispiel von django üï¥üèΩ üôãüèº üßû</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Hallo Habr! 


 Ich m√∂chte die Erfahrung des Schreibens von Migrationen f√ºr Postgres und Django teilen. Hier geht es haupts√§chlich um P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Migrieren eines Datenbankschemas ohne Ausfallzeit f√ºr postgresql am Beispiel von django</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425063/"><h1 id="vvedenie">  Einf√ºhrung </h1><br><p>  Hallo Habr! </p><br><p>  Ich m√∂chte die Erfahrung des Schreibens von Migrationen f√ºr Postgres und Django teilen.  Hier geht es haupts√§chlich um Postgres. Django ist hier eine gute Erg√§nzung, da das Datenschema f√ºr Modell√§nderungen sofort automatisch migriert wird, dh eine ziemlich vollst√§ndige Liste der Arbeitsvorg√§nge zum √Ñndern des Schemas.  Django kann durch jedes bevorzugte Framework / jede bevorzugte Bibliothek ersetzt werden - die Ans√§tze werden h√∂chstwahrscheinlich √§hnlich sein. </p><br><p>  Ich werde nicht beschreiben, wie ich dazu gekommen bin, aber jetzt, wo ich die Dokumentation lese, komme ich auf die Idee, dass es notwendig war, dies fr√ºher mit gr√∂√üerer Sorgfalt und Aufmerksamkeit zu tun, daher empfehle ich es sehr. </p><br><p>  Bevor ich weiter gehe, m√∂chte ich die folgenden Annahmen treffen. </p><br><p>  Sie k√∂nnen die Logik der Arbeit mit der Datenbank der meisten Anwendungen in drei Teile unterteilen: </p><br><ol><li> Migrationen - √Ñndern des Datenbankschemas (Tabellen). Nehmen wir an, wir f√ºhren sie immer in einem Thread aus. </li><li>  Gesch√§ftslogik - direkte Arbeit mit Daten (in Benutzertabellen), arbeitet st√§ndig und wettbewerbsf√§hig mit denselben Daten. </li><li>  Datenmigrationen - √Ñndern Sie keine Datenschemata, sie funktionieren im Wesentlichen wie Gesch√§ftslogik. Wenn wir √ºber Gesch√§ftslogik sprechen, meinen wir standardm√§√üig auch Datenmigrationen. </li></ol><br><p>  Ausfallzeit ist ein Zustand, in dem ein Teil unserer Gesch√§ftslogik f√ºr eine f√ºr den Benutzer sp√ºrbare Zeit nicht verf√ºgbar ist / f√§llt / geladen wird. Nehmen wir an, dies sind einige Sekunden. </p><br><p>  Das Fehlen von Ausfallzeiten kann eine kritische Bedingung f√ºr ein Unternehmen sein, an die sich alle Anstrengungen halten m√ºssen. <a name="habracut"></a></p><br><h1 id="process-vykatki">  Rollout-Prozess </h1><br><p>  Die Hauptanforderungen beim Rollout: </p><br><ol><li>  Wir haben eine Arbeitsbasis. </li><li>  Wir haben mehrere Maschinen, auf denen sich die Gesch√§ftslogik dreht. </li><li>  Autos mit Gesch√§ftslogik sind hinter dem Balancer versteckt. </li><li>  Unsere Anwendung funktioniert gut vor, w√§hrend und nach der fortlaufenden Migration (der alte Code funktioniert korrekt mit dem alten und dem neuen Datenbankschema). </li><li>  Unsere Anwendung funktioniert gut vor, w√§hrend und nach der Aktualisierung des Codes auf den Autos (der alte und der neue Code funktionieren korrekt mit dem aktuellen Datenbankschema). </li></ol><br><p>  Wenn es eine gro√üe Anzahl von √Ñnderungen gibt und der Rollout diese Bedingungen nicht mehr erf√ºllt, wird er in die erforderliche Anzahl kleinerer Rollouts unterteilt, die diese Bedingungen erf√ºllen. Andernfalls treten Ausfallzeiten auf. </p><br><p>  Direkte Einf√ºhrung: </p><br><ol><li>  √ºberflutete die Migration; </li><li>  entfernte einen Computer vom Balancer, aktualisierte den Computer und startete neu, gab den Computer an den Balancer zur√ºck; </li><li>  wiederholte den vorherigen Schritt, um alle Autos zu aktualisieren. </li></ol><br><p>  Die umgekehrte Rollout-Reihenfolge ist f√ºr das L√∂schen von Tabellen und Spalten in einer Tabelle relevant, wenn wir automatisch Migrationen gem√§√ü dem ge√§nderten Schema erstellen und das Vorhandensein aller Migrationen zu CI √ºberpr√ºfen: </p><br><ol><li>  entfernte einen Computer vom Balancer, aktualisierte den Computer und startete neu, gab den Computer an den Balancer zur√ºck; </li><li>  wiederholte den vorherigen Schritt, um alle Autos zu aktualisieren; </li><li>  √ºberflutete die Migration. </li></ol><br><h1 id="teoriya">  Theorie </h1><br><p>  Postgres ist eine ausgezeichnete Datenbank. Wir k√∂nnen eine Anwendung schreiben, die dieselben Daten in Hunderten und Tausenden von Streams schreibt und liest, und mit hoher Wahrscheinlichkeit k√∂nnen wir sicher sein, dass unsere Daten g√ºltig bleiben und im Allgemeinen nicht vollst√§ndig ACID besch√§digt werden.  Postgres implementiert verschiedene Mechanismen, um dies zu erreichen. Einer davon ist das Blockieren. </p><br><p>  Postgres hat verschiedene Arten von Sperren. Weitere Details finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . Als Teil des Themas werde ich nur auf Sperren auf Tabellen- und Aufzeichnungsebene eingehen. </p><br><h2 id="blokirovki-na-urovne-tablicy">  Sperren auf Tabellenebene </h2><br><p>  Auf Tabellenebene verf√ºgt Postgres √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verschiedene Arten von Sperren</a> . Das Hauptmerkmal besteht darin, dass Konflikte auftreten, dh, zwei Vorg√§nge mit widerspr√ºchlichen Sperren k√∂nnen nicht gleichzeitig ausgef√ºhrt werden: </p><br><table><thead><tr><th></th><th><code>ACCESS SHARE</code> </th> <th> <code>ROW SHARE</code> </th> <th> <code>ROW EXCLUSIVE</code> </th> <th> <code>SHARE UPDATE EXCLUSIVE</code> </th> <th> <code>SHARE</code> </th> <th> <code>SHARE ROW EXCLUSIVE</code> </th> <th> <code>EXCLUSIVE</code> </th> <th> <code>ACCESS EXCLUSIVE</code> </th> </tr></thead><tbody><tr><td> <code>ACCESS SHARE</code> </td> <td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X. </td></tr><tr><td> <code>ROW SHARE</code> </td> <td></td><td></td><td></td><td></td><td></td><td></td><td>  X. </td><td>  X. </td></tr><tr><td> <code>ROW EXCLUSIVE</code> </td> <td></td><td></td><td></td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td></tr><tr><td> <code>SHARE UPDATE EXCLUSIVE</code> </td> <td></td><td></td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td></tr><tr><td> <code>SHARE</code> </td> <td></td><td></td><td>  X. </td><td>  X. </td><td></td><td>  X. </td><td>  X. </td><td>  X. </td></tr><tr><td> <code>SHARE ROW EXCLUSIVE</code> </td> <td></td><td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td></tr><tr><td> <code>EXCLUSIVE</code> </td> <td></td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td></tr><tr><td> <code>ACCESS EXCLUSIVE</code> </td> <td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td></tr></tbody></table><br><p>  Beispielsweise m√ºssen der <code>ALTER TABLE tablename ADD COLUMN newcolumn integer</code> und der <code>ALTER TABLE tablename ADD COLUMN newcolumn integer</code> <code>SELECT COUNT(*) FROM tablename</code> einzeln ausgef√ºhrt werden, da wir sonst nicht herausfinden k√∂nnen, welche Spalten an <code>COUNT(*)</code> . </p><br><p>  Bei Django-Migrationen (vollst√§ndige Liste unten) gibt es die folgenden Vorg√§nge und die entsprechenden Sperren: </p><br><table><thead><tr><th>  Blockieren </th><th>  Operationen </th></tr></thead><tbody><tr><td> <code>ACCESS EXCLUSIVE</code> </td> <td>  <code>CREATE SEQUENCE</code> , <code>DROP SEQUENCE</code> , <code>CREATE TABLE</code> , <code>DROP TABLE</code> , <code>ALTER TABLE</code> , <code>DROP INDEX</code> </td></tr><tr><td> <code>SHARE</code> </td> <td> <code>CREATE INDEX</code> </td> </tr><tr><td> <code>SHARE UPDATE EXCLUSIVE</code> </td> <td>  <code>CREATE INDEX CONCURRENTLY</code> , <code>DROP INDEX CONCURRENTLY</code> <code>CREATE INDEX CONCURRENTLY</code> , <code>DROP INDEX CONCURRENTLY</code> <code>ALTER TABLE VALIDATE CONSTRAINT</code> </td></tr></tbody></table><br><p>  Von den Kommentaren haben nicht alle <code>ALTER TABLE</code> <code>ACCESS EXCLUSIVE</code> Locking, auch Django-Migrationen haben nicht <code>CREATE INDEX CONCURRENTLY</code> und <code>ALTER TABLE VALIDATE CONSTRAINT</code> , aber sie werden etwas sp√§ter f√ºr eine sicherere Alternative zu Standardoperationen ben√∂tigt. </p><br><p>  Wenn Migrationen nacheinander in einem Thread ausgef√ºhrt werden, sieht alles gut aus, da die Migration nicht mit einer anderen Migration in Konflikt steht, unsere Gesch√§ftslogik jedoch nur w√§hrend der Migration und des Konflikts funktioniert. </p><br><table><thead><tr><th>  Blockieren </th><th>  Operationen </th><th>  Konflikte mit Sperren </th><th>  Konflikte mit Operationen </th></tr></thead><tbody><tr><td> <code>ACCESS SHARE</code> </td> <td> <code>SELECT</code> </td> <td> <code>ACCESS EXCLUSIVE</code> </td> <td>  <code>ALTER TABLE</code> , <code>DROP INDEX</code> </td></tr><tr><td> <code>ROW SHARE</code> </td> <td> <code>SELECT FOR UPDATE</code> </td> <td>  <code>ACCESS EXCLUSIVE</code> , <code>EXCLUSIVE</code> </td><td>  <code>ALTER TABLE</code> , <code>DROP INDEX</code> </td></tr><tr><td> <code>ROW EXCLUSIVE</code> </td> <td>  <code>INSERT</code> , <code>UPDATE</code> , <code>DELETE</code> </td><td>  <code>ACCESS EXCLUSIVE</code> , <code>EXCLUSIVE</code> , <code>SHARE ROW EXCLUSIVE</code> , <code>SHARE</code> </td><td>  <code>ALTER TABLE</code> , <code>DROP INDEX</code> , <code>CREATE INDEX</code> </td></tr></tbody></table><br><p>  Zwei Punkte k√∂nnen hier zusammengefasst werden: </p><br><ol><li>  Wenn es eine Alternative mit einfacherem Sperren gibt, k√∂nnen Sie sie als <code>CREATE INDEX</code> und <code>CREATE INDEX CONCURRENTLY</code> . </li><li>  Die meisten Migrationen zur √Ñnderung des Datenschemas stehen in Konflikt mit der Gesch√§ftslogik. Dar√ºber hinaus stehen sie im Widerspruch zu <code>ACCESS EXCLUSIVE</code> . Das hei√üt, wir k√∂nnen <code>SELECT</code> nicht einmal <code>SELECT</code> w√§hrend diese Sperre gedr√ºckt gehalten wird, und erwarten hier m√∂glicherweise eine Ausfallzeit, au√üer in dem Fall, dass dieser Vorgang nicht sofort funktioniert und unsere Ausfallzeit auftritt ein paar Sekunden. </li></ol><br><p>  Es muss eine Auswahl geben, oder wir vermeiden immer <code>ACCESS EXCLUSIVE</code> , <code>ACCESS EXCLUSIVE</code> wir erstellen neue Platten und kopieren die Daten dort - zuverl√§ssig, aber lange Zeit f√ºr eine gro√üe Datenmenge, oder wir machen <code>ACCESS EXCLUSIVE</code> so schnell wie m√∂glich und machen zus√§tzliche Warnungen vor Ausfallzeiten - es ist potenziell gef√§hrlich, aber schnell. </p><br><h2 id="blokirovki-na-urovne-zapisi">  Sperren aufzeichnen </h2><br><p>  Auf der Aufzeichnungsebene gibt es auch Sperren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.postgresql.org/docs/current/static/explicit-locking.html#LOCKING-ROWS</a> . Sie stehen ebenfalls in Konflikt, wirken sich jedoch nur auf unsere Gesch√§ftslogik aus: </p><br><table><thead><tr><th></th><th> <code>FOR KEY SHARE</code> </th> <th> <code>FOR SHARE</code> </th> <th> <code>FOR NO KEY UPDATE</code> </th> <th> <code>FOR UPDATE</code> </th> </tr></thead><tbody><tr><td> <code>FOR KEY SHARE</code> </td> <td></td><td></td><td></td><td>  X. </td></tr><tr><td> <code>FOR SHARE</code> </td> <td></td><td></td><td>  X. </td><td>  X. </td></tr><tr><td> <code>FOR NO KEY UPDATE</code> </td> <td></td><td>  X. </td><td>  X. </td><td>  X. </td></tr><tr><td> <code>FOR UPDATE</code> </td> <td>  X. </td><td>  X. </td><td>  X. </td><td>  X. </td></tr></tbody></table><br><p>  Dies ist der Hauptpunkt bei Datenmigrationen. Wenn wir also eine <code>UPDATE</code> -Datenmigration auf der gesamten Platte durchf√ºhren, wartet der Rest der Gesch√§ftslogik, die die Daten aktualisiert, auf die Freigabe der Sperre und √ºberschreitet m√∂glicherweise unseren Ausfallzeitschwellenwert. Daher ist es besser, Aktualisierungen in Teilen f√ºr Datenmigrationen durchzuf√ºhren.  Es ist auch erw√§hnenswert, dass bei Verwendung komplexerer SQL-Abfragen f√ºr Datenmigrationen die Aufteilung in Teile schneller funktionieren kann, da ein optimalerer Plan und optimale Indizes verwendet werden k√∂nnen. </p><br><h2 id="ocheryodnost-vypolneniya-operaciy">  Die Reihenfolge der Operationen </h2><br><p>  Ein weiteres wichtiges Wissen ist, wie Operationen ausgef√ºhrt werden, wann und wie sie Sperren aufheben und aufheben: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/889/8f9/adb/8898f9adbf4eab0350517d07177b7257.png" alt="Bild"></p><br><p>  Hier k√∂nnen Sie folgende Elemente hervorheben: </p><br><ol><li>  Ausf√ºhrungszeit des Vorgangs - f√ºr die Migration ist es die Zeit, in der die Sperre gehalten wird. Wenn die schwere Sperre l√§ngere Zeit gehalten wird, tritt eine Ausfallzeit auf. <code>ALTER TABLE ADD COLUMN SET DEFAULT</code> kann beispielsweise mit <code>CREATE INDEX</code> oder <code>ALTER TABLE ADD COLUMN SET DEFAULT</code> (in Postgres 11 ist dies besser). </li><li>  Die Wartezeit f√ºr widerspr√ºchliche Sperren - das hei√üt, die Migration wartet, bis alle widerspr√ºchlichen Anforderungen erf√ºllt sind. Zu diesem Zeitpunkt warten neue Anforderungen auf unsere Migration. Langsame Anforderungen k√∂nnen hier sehr gef√§hrlich sein, entweder einfach nicht optimal oder analytisch. Daher sollten w√§hrenddessen keine langsamen Anforderungen auftreten Migration. </li><li>  Die Anzahl der Anfragen pro Sekunde - Wenn viele Anfragen √ºber einen l√§ngeren Zeitraum bearbeitet werden, k√∂nnen freie Verbindungen schnell beendet werden und anstelle eines problematischen Ortes kann die gesamte Datenbank in Ausfallzeiten geraten (es gibt nur ein Verbindungslimit f√ºr den Superuser). Hier m√ºssen Sie langsame Anfragen vermeiden und die Anzahl der Anfragen reduzieren Starten Sie beispielsweise Migrationen w√§hrend der minimalen Auslastung und trennen Sie kritische Komponenten mit ihren eigenen Datenbanken in verschiedene Dienste. </li><li>  Es gibt viele Migrationsvorg√§nge in einer Transaktion. Je mehr Vorg√§nge in einer Transaktion ausgef√ºhrt werden, desto l√§nger wird die schwere Sperre gehalten. Daher ist es besser, schwere Operationen zu trennen, keine <code>ALTER TABLE VALIDATE CONSTRAINT</code> oder Datenmigrationen in einer Transaktion mit einer schweren Sperre. </li></ol><br><h2 id="taymauty">  Zeit√ºberschreitungen </h2><br><p>  <code>lock_timeout</code> verf√ºgt √ºber Einstellungen wie <code>lock_timeout</code> und <code>statement_timeout</code> , die den Beginn von Migrationen sowohl vor schlecht geschriebener Migration als auch vor schlechten Bedingungen sch√ºtzen k√∂nnen, unter denen eine Migration ausgel√∂st werden kann.  Sie k√∂nnen sowohl global als auch f√ºr die aktuelle Verbindung installiert werden. </p><br><p>  <code>SET lock_timeout TO '2s'</code> , vermeiden Sie Ausfallzeiten, wenn Sie vor der Migration auf langsame Anforderungen / Transaktionen warten: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-LOCK-TIMEOUT</a> . </p><br><p>  <code>SET statement_timeout TO '2s'</code> vermeidet Ausfallzeiten beim Starten einer starken Migration mit einer starken Sperre: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT</a> . </p><br><h2 id="dedloki">  Deadlocks </h2><br><p>  Bei Deadlocks bei Migrationen geht es nicht um Ausfallzeiten, aber es ist nicht angenehm, wenn die Migration geschrieben wird. In einer Testumgebung funktioniert es einwandfrei, aber beim Rolling auf dem Produkt werden Deadlocks abgefangen.  Die Hauptprobleme k√∂nnen eine gro√üe Anzahl von Vorg√§ngen in einer Transaktion und einem Fremdschl√ºssel sein, da in beiden Tabellen Sperren erstellt werden. Daher ist es besser, die Migrationsvorg√§nge zu trennen. Je atomarer, desto besser. </p><br><h2 id="hranenie-zapisey">  Datensatzspeicher </h2><br><p>  Postgres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">speichert Werte verschiedener Typen auf unterschiedliche Weise</a> : Wenn Typen auf unterschiedliche Weise gespeichert werden, erfordert die Konvertierung zwischen ihnen eine vollst√§ndige Neufassung aller Werte. Gl√ºcklicherweise werden einige Typen auf dieselbe Weise gespeichert und m√ºssen beim √Ñndern nicht neu geschrieben werden.  Beispielsweise werden Zeilen unabh√§ngig von ihrer Gr√∂√üe gleich gespeichert, und das Verringern / Erh√∂hen der Abmessung einer Zeile erfordert kein Umschreiben. Beim Verringern muss jedoch √ºberpr√ºft werden, ob alle Zeilen eine kleinere Gr√∂√üe nicht √ºberschreiten.  Andere Typen k√∂nnen ebenfalls auf √§hnliche Weise gespeichert werden und haben √§hnliche Eigenschaften. </p><br><h2 id="multiversion-concurrency-control-mvcc">  Multiversion Concurrency Control (MVCC) </h2><br><p>  Gem√§√ü der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> basiert die Postgres-Konsistenz auf Datenmultiversion, dh, jede Transaktion und Operation sieht ihre eigene Version der Daten.  Diese Funktion kommt mit dem Konkurrenzzugriff perfekt zurecht und bietet auch einen interessanten Effekt, wenn ein Schema wie das Hinzuf√ºgen und Entfernen von Spalten nur dann ge√§ndert wird, wenn keine zus√§tzlichen Operationen zum √Ñndern von Daten, Indizes oder Konstanten vorhanden sind. Danach werden die Einf√ºge- und Aktualisierungsoperationen auf niedriger Ebene neu erstellt Datens√§tze mit allen erforderlichen Werten. Durch L√∂schen wird der entsprechende Datensatz als gel√∂scht markiert.  VACUUM oder AUTO VACUUM ist f√ºr die Reinigung der verbleibenden R√ºckst√§nde verantwortlich. </p><br><h1 id="primer-django">  Django Beispiel </h1><br><p>  Wir haben jetzt eine Vorstellung davon, wovon Ausfallzeiten abh√§ngen k√∂nnen und wie sie vermieden werden k√∂nnen. Bevor Sie jedoch Wissen anwenden, k√∂nnen Sie sich ansehen, was Django sofort bietet ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/django/django/blob/2.1.2/django) /db/backends/base/schema.py</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/django/django/blob/2.1.2/django/db/backends/postgresql/schema.py</a> ): </p><br><table><thead><tr><th></th><th>  Betrieb </th></tr></thead><tbody><tr><td>  1 </td><td> <code>CREATE SEQUENCE</code> </td> </tr><tr><td>  2 </td><td> <code>DROP SEQUENCE</code> </td> </tr><tr><td>  3 </td><td> <code>CREATE TABLE</code> </td> </tr><tr><td>  4 </td><td> <code>DROP TABLE</code> </td> </tr><tr><td>  5 </td><td> <code>ALTER TABLE RENAME TO</code> </td> </tr><tr><td>  6 </td><td> <code>ALTER TABLE SET TABLESPACE</code> </td> </tr><tr><td>  7 </td><td> <code>ALTER TABLE ADD COLUMN [SET DEFAULT] [SET NOT NULL] [PRIMARY KEY] [UNIQUE]</code> </td> </tr><tr><td>  8 </td><td> <code>ALTER TABLE ALTER COLUMN [TYPE] [SET NOT NULL|DROP NOT NULL] [SET DEFAULT|DROP DEFAULT]</code> </td> </tr><tr><td>  9 </td><td> <code>ALTER TABLE DROP COLUMN</code> </td> </tr><tr><td>  10 </td><td> <code>ALTER TABLE RENAME COLUMN</code> </td> </tr><tr><td>  11 </td><td> <code>ALTER TABLE ADD CONSTRAINT CHECK</code> </td> </tr><tr><td>  12 </td><td> <code>ALTER TABLE DROP CONSTRAINT CHECK</code> </td> </tr><tr><td>  13 </td><td> <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> </td> </tr><tr><td>  14 </td><td> <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> </td> </tr><tr><td>  15 </td><td> <code>ALTER TABLE ADD CONSTRAINT PRIMARY KEY</code> </td> </tr><tr><td>  16 </td><td> <code>ALTER TABLE DROP CONSTRAINT PRIMARY KEY</code> </td> </tr><tr><td>  17 </td><td> <code>ALTER TABLE ADD CONSTRAINT UNIQUE</code> </td> </tr><tr><td>  18 </td><td> <code>ALTER TABLE DROP CONSTRAINT UNIQUE</code> </td> </tr><tr><td>  19 </td><td> <code>CREATE INDEX</code> </td> </tr><tr><td>  20 </td><td> <code>DROP INDEX</code> </td> </tr></tbody></table><br><p>  Django deckt meine Migrationsbed√ºrfnisse sehr gut ab. Jetzt k√∂nnen wir mit unserem Wissen sichere und gef√§hrliche Vorg√§nge f√ºr Migrationen ohne Ausfallzeiten besprechen. </p><br><p>  Wir werden sicherere Migrationen mit <code>SHARE UPDATE EXCLUSIVE</code> Locking oder <code>ACCESS EXCLUSIVE</code> , was sofort funktioniert. <br>  Wir werden gef√§hrliche Migrationen mit <code>SHARE</code> und <code>ACCESS EXCLUSIVE</code> Sperren aufrufen, die viel Zeit in <code>ACCESS EXCLUSIVE</code> nehmen. </p><br><p>  Ich werde im Voraus einen n√ºtzlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zur Dokumentation</a> mit gro√üartigen Beispielen hinterlassen. </p><br><h2 id="sozdanie-i-udalenie-tablicy">  Erstellen und l√∂schen Sie eine Tabelle </h2><br><p>  <code>CREATE SEQUENCE</code> , <code>DROP SEQUENCE</code> , <code>CREATE TABLE</code> , <code>DROP TABLE</code> k√∂nnen als sicher bezeichnet werden, da die Gesch√§ftslogik entweder nicht mehr mit der migrierten Tabelle funktioniert und das L√∂schen einer Tabelle mit FOREIGN KEY etwas sp√§ter erfolgt. </p><br><h2 id="tyazhelo-podderzhivaemye-operacii-na-rabochih-tablicah">  Stark unterst√ºtzte Arbeitsblattvorg√§nge </h2><br><p>  <code>ALTER TABLE RENAME TO</code> - Ich kann es nicht als sicher bezeichnen, da es schwierig ist, eine Logik zu schreiben, die mit einer solchen Tabelle vor und nach der Migration funktioniert. </p><br><p>  <code>ALTER TABLE SET TABLESPACE</code> - unsicher, da es die Platte physisch bewegt, und dies kann bei einem gro√üen Volumen lange dauern. </p><br><p>  Andererseits sind diese Vorg√§nge √§u√üerst selten. Alternativ k√∂nnen Sie die Erstellung einer neuen Tabelle und das Kopieren von Daten in diese anbieten. </p><br><h2 id="sozdanie-i-udalenie-kolonki">  Spalten erstellen und l√∂schen </h2><br><p>  <code>ALTER TABLE ADD COLUMN</code> , <code>ALTER TABLE DROP COLUMN</code> - kann als sicher bezeichnet werden (Erstellung ohne DEFAULT / NOT NULL / PRIMARY KEY / UNIQUE), da die Gesch√§ftslogik entweder nicht mit einer migrierten Spalte funktioniert, das Verhalten beim L√∂schen einer Spalte mit FOREIGN KEY, andere Konstanten und Indizes werden sp√§ter kommen. </p><br><p>  <code>ALTER TABLE ADD COLUMN SET DEFAULT</code> , <code>ALTER TABLE ADD COLUMN SET NOT NULL</code> , <code>ALTER TABLE ADD COLUMN PRIMARY KEY</code> nullbare Spalten und weitere √Ñnderungen. </p><br><p>  Es ist erw√§hnenswert, dass das schnellere <code>SET DEFAULT</code> in Postgres 11 als sicher angesehen werden kann, aber es wird in Django nicht sehr n√ºtzlich, da Django <code>SET DEFAULT</code> nur zum F√ºllen der Spalte verwendet und dann <code>DROP DEFAULT</code> und im Intervall zwischen Migration und Aktualisierung von Maschinen mit erstellt In der Gesch√§ftslogik k√∂nnen Datens√§tze erstellt werden, in denen keine Standardeinstellungen vorhanden sind, dh die Datenmigration. </p><br><h2 id="tyazhelo-podderzhivaemye-operacii-na-rabochey-tablice">  Stark unterst√ºtzte Vorg√§nge in einem Arbeitsblatt </h2><br><p>  <code>ALTER TABLE RENAME COLUMN</code> - Ich kann es auch nicht als sicher bezeichnen, da es schwierig ist, eine Logik zu schreiben, die mit einer solchen Spalte vor und nach der Migration funktioniert.  Vielmehr wird dieser Vorgang auch nicht h√§ufig sein, da alternativ vorgeschlagen werden kann, eine neue Spalte zu erstellen und Daten in diese zu kopieren. </p><br><h2 id="izmenenie-kolonki">  Spaltenwechsel </h2><br><p>  <code>ALTER TABLE ALTER COLUMN TYPE</code> - Der Vorgang kann sowohl gef√§hrlich als auch sicher sein.  Sicher, wenn postgres nur das Schema √§ndert und die Daten bereits im erforderlichen Format gespeichert sind und keine zus√§tzlichen Typpr√ºfungen erforderlich sind, zum Beispiel: </p><br><ul><li>  <code>varchar(LESS)</code> von <code>varchar(LESS)</code> zu <code>varchar(MORE)</code> ; </li><li>  <code>varchar(ANY)</code> von <code>varchar(ANY)</code> zu <code>text</code> ; </li><li>  <code>numeric(LESS, SAME)</code> von <code>numeric(LESS, SAME)</code> zu <code>numeric(MORE, SAME)</code> . </li></ul><br><p>  <code>ALTER TABLE ALTER COLUMN SET NOT NULL</code> ist gef√§hrlich, da es die darin enthaltenen Daten durchl√§uft und nach NULL <code>ALTER TABLE ALTER COLUMN SET NOT NULL</code> Gl√ºcklicherweise kann dieses Konstrukt durch ein anderes ersetzt werden. <code>CHECK IS NOT NULL</code> .  Es ist erw√§hnenswert, dass dieser Ersatz zu einem anderen Schema f√ºhrt, jedoch mit identischen Eigenschaften. </p><br><p>  <code>ALTER TABLE ALTER COLUMN DROP NOT NULL</code> , <code>ALTER TABLE ALTER COLUMN SET DEFAULT</code> , <code>ALTER TABLE ALTER COLUMN DROP DEFAULT</code> - sichere Operationen. </p><br><h2 id="sozdanie-i-udalenie-indeksov-i-konstreyntov">  Erstellen und L√∂schen von Indizes und Konstanten </h2><br><p>  <code>ALTER TABLE ADD CONSTRAINT CHECK</code> und <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> sind unsichere Vorg√§nge, k√∂nnen jedoch als <code>NOT VALID</code> und dann als <code>ALTER TABLE VALIDATE CONSTRAINT</code> . </p><br><p>  <code>ALTER TABLE ADD CONSTRAINT PRIMARY KEY</code> und <code>ALTER TABLE ADD CONSTRAINT UNIQUE</code> unsicher, da sie einen eindeutigen Index im Inneren erstellen. Sie k√∂nnen jedoch einen eindeutigen Index als <code>CONCURRENTLY</code> erstellen und dann die entsprechende Konstante mithilfe eines vorgefertigten Index √ºber <code>USING INDEX</code> . </p><br><p>  <code>CREATE INDEX</code> ist eine unsichere Operation, aber ein Index kann als <code>CONCURRENTLY</code> . </p><br><p>  <code>ALTER TABLE DROP CONSTRAINT CHECK</code> , <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> , <code>ALTER TABLE DROP CONSTRAINT PRIMARY KEY</code> , <code>ALTER TABLE DROP CONSTRAINT UNIQUE</code> , <code>DROP INDEX</code> - sichere Operationen. </p><br><p>  Es ist erw√§hnenswert, dass <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> und <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> zwei Tabellen gleichzeitig sperren. </p><br><h2 id="primenyaem-znaniya-v-django">  Wissen in Django anwenden </h2><br><p>  Django hat eine Operation in Migrationen, um SQL auszuf√ºhren: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.djangoproject.com/de/2.1/ref/migration-operations/#django.db.migrations.operations.RunSQL</a> .  √úber diese <code>state_operations</code> k√∂nnen Sie die erforderlichen <code>state_operations</code> und alternative Vorg√§nge f√ºr Migrationen anwenden, wobei Sie <code>state_operations</code> - die Migration, die wir ersetzen. </p><br><p>  Dies funktioniert gut f√ºr den Code, obwohl zus√§tzliches Schreiben erforderlich ist. Sie k√∂nnen die Dirty Work jedoch im DB-Backend belassen, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/tbicr/django-pg-zero-downtime-migrations/blob/master/django_zero_downtime_migrations_postgres_backend/schema .py</a> sammelt die beschriebenen Vorgehensweisen und ersetzt unsichere Vorg√§nge durch sichere Gegenst√ºcke. Dies funktioniert f√ºr Bibliotheken von Drittanbietern. </p><br><h1 id="naposledok">  Am Ende </h1><br><p>  Diese Praktiken erm√∂glichten es mir, ein identisches Schema, das von django erstellt wurde, sofort zu erhalten, mit Ausnahme des Ersetzens des Konstrukts <code>CHECK IS NOT NULL</code> anstelle von <code>NOT NULL</code> und einiger Konstruktnamen (z. B. f√ºr <code>ALTER TABLE ADD COLUMN UNIQUE</code> und eine Alternative).  Ein weiterer Kompromiss kann die mangelnde Transaktionsf√§higkeit f√ºr alternative Migrationsvorg√§nge sein, insbesondere wenn <code>CREATE INDEX CONCURRENTLY</code> und <code>ALTER TABLE VALIDATE CONSTRAINT</code> . </p><br><p>  Wenn Sie nicht √ºber postgres hinausgehen, gibt es viele M√∂glichkeiten, das Datenschema zu √§ndern, und sie k√∂nnen unter bestimmten Bedingungen in Kombination variiert werden: </p><br><ul><li>  mit jsonb als schamlose l√∂sung </li><li>  die M√∂glichkeit, Ausfallzeiten zu vermeiden </li><li>  Anforderung, Migrationen ohne Ausfallzeiten durchzuf√ºhren </li></ul><br><p>  Auf jeden Fall hoffe ich, dass sich das Material als n√ºtzlich erwiesen hat, um entweder die Betriebszeit zu erh√∂hen oder das Bewusstsein zu erweitern. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425063/">https://habr.com/ru/post/de425063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425053/index.html">SSR: wann, warum und wof√ºr. Am Beispiel von Vue</a></li>
<li><a href="../de425055/index.html">Oculus Quest</a></li>
<li><a href="../de425057/index.html">Vorzugsdarlehen f√ºr Bildung f√ºr alle GeekUniversity-Programme von GeekBrains und Alfa Bank</a></li>
<li><a href="../de425059/index.html">Hackathon Nr. 1 bei Tinkoff.ru</a></li>
<li><a href="../de425061/index.html">CodeRainbow: Interaktives Lernen und Dokumentieren von Code</a></li>
<li><a href="../de425069/index.html">Testen eines Pr√§sentators mit PromiseKit</a></li>
<li><a href="../de425071/index.html">Wie sch√ºtzt man sich vor Stapel√ºberlauf (bei Cortex M)?</a></li>
<li><a href="../de425073/index.html">Einfache Erstellung eines Git-Repositorys auf OneDrive</a></li>
<li><a href="../de425075/index.html">Bildverarbeitung: Installieren, Konfigurieren und Verwenden von Google Cloud Vision in PHP</a></li>
<li><a href="../de425077/index.html">Kotlin unter der Haube - siehe dekompilierten Bytecode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>