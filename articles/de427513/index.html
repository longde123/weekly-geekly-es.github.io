<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♐️ 🤠 🐯 So analysieren Sie den Thread-Dump 🖐🏾 🈯️ ⏳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt einige Themen zu den Interna der JVM im Java Developer- Kursprogramm. Wir verstehen die Arbeitsmechanismen von Sammlungen, Bytecode, Garbage C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So analysieren Sie den Thread-Dump</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/427513/">  <i>Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt</a> einige Themen zu den Interna der JVM im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Developer-</a> Kursprogramm.</i>  <i>Wir verstehen die Arbeitsmechanismen von Sammlungen, Bytecode, Garbage Collectors usw.</i>  <i>Heute widmen wir Ihnen die Übersetzung eines ziemlich interessanten Artikels über Thread Dump.</i>  <i>Was ist es, wie man es bekommt und wie man es benutzt.</i> <br><br>  Möchten Sie lernen, wie Sie den Thread-Dump analysieren?  Gehen Sie unter die Katze, um mehr darüber zu erfahren, wie Sie einen Thread-Dump in Java erhalten und was Sie später damit tun können. <br><a name="habracut"></a><br>  Die meisten modernen Java-Anwendungen sind Multithread-Anwendungen.  Multithreading kann die Funktionalität der Anwendung erheblich erweitern und gleichzeitig eine erhebliche Komplexität mit sich bringen. <br><br>  In einer Single-Threaded-Anwendung können alle Ressourcen (gemeinsam genutzter Speicher, Eingabe- / Ausgabeoperationen usw.) ohne Synchronisierung verwendet werden, da  Zu einem bestimmten Zeitpunkt verwendet nur ein Thread die Ressource. <br><br>  Bei Multithread-Anwendungen muss ein Kompromiss zwischen der Komplikation des Programms und einer möglichen Leistungssteigerung gefunden werden, wenn mehrere Threads alle verfügbaren (häufig mehr als einen) Core-Prozessor (CPU) verwenden können.  Wenn alles richtig gemacht wurde, können Sie mit Multithreading (formalisiert nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amdahls Gesetz</a> ) eine signifikante Steigerung der Anwendungsleistung erzielen.  Es muss jedoch beachtet werden, dass mehrere Streams gleichzeitig auf eine gemeinsam genutzte Ressource zugreifen können.  In den meisten Fällen kapseln Frameworks wie Spring die Arbeit mit Threads und verbergen viele technische Details vor Benutzern.  Bei der Verwendung moderner komplexer Frameworks kann jedoch etwas schief gehen, und wir als Benutzer werden auf schwer zu lösende Multithreading-Fehler stoßen. <br><br>  Glücklicherweise ist Java mit einem speziellen Mechanismus ausgestattet, mit dem Informationen über den aktuellen Status aller Threads zu einem bestimmten Zeitpunkt abgerufen werden können - es handelt sich um einen Thread-Dump (eine Art Snapshot).  In diesem Artikel erfahren Sie, wie Sie einen Thread-Dump für eine Anwendung mit realistischer Größe erstellen und diesen Dump analysieren. <br><br>  Es wird davon ausgegangen, dass der Leser über grundlegende Informationen zur Multithread-Programmierung verfügt und sich der Probleme der Thread-Synchronisation und der Verwendung gemeinsam genutzter Ressourcen bewusst ist.  Es wird jedoch nicht überflüssig sein, einige grundlegende Begriffe und Konzepte zu aktualisieren. <br><br><h4>  Grundlegende Terminologie </h4><br>  Auf den ersten Blick mögen Java-Thread-Dumps wie ein „chinesischer Buchstabe“ erscheinen. Die folgenden Konzepte sind der Schlüssel zum Verständnis.  Im Allgemeinen wiederholen wir die Grundbegriffe des Multithreading, mit denen wir Dumps analysieren. <br><br><ul><li> <strong>Thread</strong> oder Thread ist eine diskrete Multithreading-Einheit, die von der Java Virtual Machine (JVM) verwaltet wird.  JVM-Threads entsprechen Threads im Betriebssystem (OS) - native Threads, die den Codeausführungsmechanismus implementieren. <br><br>  Jeder Thread hat eine eindeutige Kennung und einen eindeutigen Namen.  Streams können "Dämonen" und "keine Dämonen" sein. <br><br>  Das Programm wird beendet, wenn alle Nicht-Daemon-Threads beendet werden oder die Methode <i>Runtime.exit aufgerufen wird</i> .  Arbeitende "Dämonen" haben keinen Einfluss auf den Abschluss des Programms.  Das heißt,  Die JVM wartet darauf, dass alle „Nicht-Dämonen“ finalisiert und heruntergefahren werden. Sie achten nicht auf „Nicht-Dämonen“. <br><br>  Weitere Informationen finden Sie in der Dokumentation zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thread-Klasse</a> . <br>  Ein Stream kann sich in einem der folgenden Zustände befinden: <br><br><ul><li>  <strong>Lebendiger Thread</strong> oder "live" - ​​ein Thread, der etwas Arbeit leistet (normaler Zustand). </li><li>  <strong>Blockierter Thread</strong> oder "blockiert" - Ein Thread, der versucht hat, in den synchronisierten Abschnitt einzutreten (synchronisiert), aber ein anderer Thread hat es bereits geschafft, zuerst in diesen Block einzutreten, und alle folgenden Threads, die versuchen, in denselben Block einzutreten, werden blockiert. </li><li>  <strong>Wartender Thread</strong> oder "Warten" - ein Thread, der die <i>Wartemethode</i> aufgerufen hat (möglicherweise mit einer Zeitüberschreitung) und jetzt darauf wartet, dass eine andere Methode <i>notify</i> oder <i>nonifyAll</i> für dasselbe Objekt ausführt. <br><br>  Bitte beachten Sie, dass der Thread nicht als "wartend" betrachtet wird, wenn er "Warten mit einer Zeitüberschreitung" aufgerufen hat und diese Zeitüberschreitung abgelaufen ist. </li><li>  <strong>Sleeping Thread</strong> oder "Sleeping" - ein Thread, der derzeit nicht ausgeführt wird, weil  führte die Thread.sleep-Methode durch (Angabe der Dauer des "Schlafes"). </li></ul></li><li>  <strong>Monitor</strong> ist ein Mechanismus, der von der JVM verwendet wird, um Multithread-Zugriff auf ein einzelnes Objekt bereitzustellen.  Der Mechanismus wird mit dem speziellen <i>synchronisierten Schlüsselwort</i> gestartet. <br><br>  Jedes Objekt in Java hat einen Monitor, mit dem der Thread synchronisiert werden kann, d.h.  Setzen Sie eine Sperre, die garantiert, dass kein anderer Thread Zugriff auf dieses Objekt erhält, bis die Sperre aufgehoben wird, d. h.  Thread - Der Eigentümer der Sperre verlässt den <i>synchronisierten</i> Block nicht. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Informationen finden</a> Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt Synchronisierung (17.1) der Java Langauge Specification (JLS)</a> . <br></li><li>  <strong>Deadlock</strong> ist eine Situation, in der ein Thread, z. B. A, eine Ressource blockiert. Er benötigt eine andere Ressource, die von einem anderen Thread blockiert wird, z. B. B. Stream B gibt diese Ressource nicht frei, weil  Um einen bestimmten Vorgang abzuschließen, benötigt er eine Ressource, die von Thread A blockiert wird. Es stellt sich heraus, dass Thread A darauf wartet, dass die Ressource von Thread B entsperrt wird, der darauf wartet, dass eine andere Ressource von Thread A entsperrt wird. Daher warten die Threads aufeinander.  Infolgedessen hängt das gesamte Programm und wartet darauf, dass die Threads irgendwie entsperrt werden und weiterarbeiten.  In einem Deadlock können sich viele Threads befinden.  Dieses Problem ist als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Problem der Speisephilosophen" bekannt.</a> <br><br><img src="https://habrastorage.org/webt/8t/ll/jb/8tlljb_n-e80_dk_0uayobgil_s.png"><br></li><li>  <strong>Livelock</strong> ist eine Situation, in der Thread A Thread B zwingt, eine Aktion auszuführen, was wiederum dazu führt, dass Thread A die anfängliche Aktion ausführt, was wiederum die Aktion von Thread B bewirkt. Eine zyklische Abhängigkeit wird erhalten.  Dies kann man sich als einen Hund vorstellen, der seinem Schwanz nachläuft.  Ähnlich wie bei <i>Deadlock macht</i> das Programm in einer Livelock-Situation keine Fortschritte, d. H.  führt keine nützliche Aktion aus, in dieser Situation werden die Threads jedoch nicht blockiert. <br></li></ul><br>  Die vorgestellte Terminologie ist nicht erschöpfend für die Beschreibung der Welt des Multithreading, aber dies reicht aus, um mit der Analyse von Thread-Dumps zu beginnen. <br><br>  Weitere Informationen finden Sie in folgenden Quellen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt 17 der JLS-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java-Parallelität in der Praxis</a> <br><br>  Mit diesen einfachen Konzepten zum Ablauf in Java können wir eine Testanwendung erstellen.  Für diese Anwendung kompilieren wir den Thread-Dump.  Wir werden den resultierenden Speicherauszug analysieren und nützliche Informationen über die aktuellen Anwendungsabläufe extrahieren. <br><br><h4>  Beispielprogramm erstellen </h4><br>  Vor dem Erstellen eines Thread-Dumps müssen wir eine Java-Anwendung entwickeln.  Das traditionelle "Hallo Welt!"  Für unseren Zweck zu einfach, und ein mittelgroßer Speicherauszug der Anwendung ist möglicherweise zu kompliziert, um dies zu demonstrieren.  Basierend darauf werden wir eine ziemlich einfache Anwendung erstellen, in der zwei Threads erstellt werden.  Und die Fäden geraten ins Stocken: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceB, resourceA)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Dieses Programm erstellt zwei Ressourcen: resourceA und resourceB und startet zwei Threads: threadLockingResourceAFirst und threadLockingResourceBFirst, die sich gegenseitig die Ressourcen blockieren. <br><br>  Die Ursache für einen Deadlock ist eine "Kreuz" -Blockierung von Ressourcen durch Threads. <br><br>  Der Grund für das Auftreten eines Deadlocks ist ein Versuch, Ressourcen "gegenseitig" zu beschlagnahmen, d.h.  threadLockingResourceAFirst-Thread erfasst resourceA-Ressource, threadLockingResourceBFirst-Thread erfasst resourceB-Ressource.  Danach versucht threadLockingResourceAFirst, ohne seine Ressource freizugeben, resourceB zu greifen, und threadLockingResourceBFirst, ohne seine Ressource freizugeben, versucht, resourceA zu greifen.  Infolgedessen werden Threads blockiert.  Eine Verzögerung von 1s wurde hinzugefügt, um die Blockierung zu gewährleisten.  Threads warten auf die Freigabe der erforderlichen Ressourcen, dies wird jedoch niemals passieren. <br><br>  Die Ausgabe des Programms sieht folgendermaßen aus (die Zahlen nach java.lang.Object @ sind bei jedem Start unterschiedlich): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Thread-0</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">locked</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">resource</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Object</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">149bc794</span></span> Thread-<span class="hljs-number"><span class="hljs-number">1</span></span>: locked resource -&gt; java.lang.Object@<span class="hljs-number"><span class="hljs-number">17</span></span>c10009</code> </pre> <br>  Nach der Ausgabe dieser Nachrichten sieht das Programm so aus, als würde es ausgeführt (der Prozess, der dieses Programm ausführt, ist nicht abgeschlossen), während das Programm keine Arbeit ausführt.  So sieht Deadlock in der Praxis aus.  Um das Problem zu lösen, müssen wir manuell einen Profildump erstellen und den Status der Threads analysieren. <br><br><h4>  Thread Dump Generation </h4><br>  In der Praxis kann ein Java-Programm beim Erstellen eines Thread-Dumps abstürzen.  In einigen Fällen (z. B. bei Deadlocks) wird das Programm jedoch nicht beendet und der Thread-Dump wird nicht erstellt, sondern hängt nur.  Um einen Speicherauszug solcher blockierter Programme zu erstellen, müssen Sie zunächst die Kennung des Programmprozesses herausfinden, d. H.  Prozess-ID (PID).  Dazu können Sie das Dienstprogramm JVM Process Status (JPS) verwenden, das ab Version 7 Teil des Java Development Kit (JDK) ist.  Um die Prozess-PID unseres blockierten Programms zu ermitteln, führen wir einfach jps im Terminal (Windows oder Linux) aus: <br><br><pre> <code class="hljs ruby">$ jps <span class="hljs-number"><span class="hljs-number">11568</span></span> DeadlockProgram <span class="hljs-number"><span class="hljs-number">15584</span></span> Jps <span class="hljs-number"><span class="hljs-number">15636</span></span></code> </pre> <br>  Die erste Spalte ist die Kennung der lokalen virtuellen Maschine (lokale VM-ID, d. H. Lvmid) für den ausgeführten Java-Prozess.  Im Kontext der lokalen JVM verweist lvmid auf die PID des Java-Prozesses. <br><br>  Es ist zu beachten, dass dieser Wert wahrscheinlich vom obigen Wert abweicht.  Die zweite Spalte ist der Name der Anwendung, der auf den Namen der Hauptklasse, der JAR-Datei oder gleich "Unbekannt" verweisen kann.  Es hängt alles davon ab, wie die Anwendung gestartet wurde. <br><br>  In unserem Fall ist der Anwendungsname DeadlockProgram der Name der Hauptklassen, die beim Start des Programms gestartet wurden.  Im obigen Beispiel PID des Programms 11568 reichen diese Informationen aus, um einen Thread-Dump zu generieren.  Um den <strong>Speicherauszug</strong> zu generieren, verwenden wir das Dienstprogramm <strong>jstack</strong> , das Teil des JDK ist, ab Version 7. Um den <strong>Speicherauszug abzurufen</strong> , übergeben wir <strong>die</strong> PID unseres Programms an <strong>jstack</strong> und geben das Flag -l an (Erstellen einer langen Liste).  Die Ausgabe des Dienstprogramms wird in eine Textdatei umgeleitet, d. H.  thread_dump.txt: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">jstack</span></span> -l <span class="hljs-number"><span class="hljs-number">11568</span></span> &gt; thread_dump.txt</code> </pre> <br>  Die resultierende Datei thread_dump.txt enthält den Thread-Dump unseres blockierten Programms und wichtige Informationen zur Diagnose der Ursachen für Deadlocks. <br><br>  Wenn das JDK bis Version 7 verwendet wird, können Sie zum Generieren eines Speicherauszugs das Linux-Dienstprogramm verwenden - <strong>kill</strong> mit dem Flag -3.  Wenn Sie kill -3 aufrufen, sendet das Programm ein SIGQUIT-Signal. <br><br>  In unserem Fall sieht der Anruf folgendermaßen aus: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">kill</span></span> <span class="hljs-number"><span class="hljs-number">-3</span></span> <span class="hljs-number"><span class="hljs-number">11568</span></span></code> </pre> <br><h4>  Einfache Thread-Dump-Analyse </h4><br>  Wenn Sie die Datei thread_dump.txt öffnen, sehen Sie ungefähr Folgendes: <br><br><pre> 2018-06-19 16:44:44
 Vollständiger Thread-Dump Java HotSpot (TM) 64-Bit-Server-VM (10.0.1 + 10 gemischter Modus):
 Threads Klasse SMR Info:
 _java_thread_list = 0x00000250e5488a00, Länge = 13, Elemente = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }}
 "Reference Handler" # 2 Daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 wartet auf Bedingung [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     at java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     unter java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     unter java.lang.ref.Reference.access $ 000 (java.base@10.0.1/Reference.java: 44)
     at java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Finalizer" # 3 Daemon prio = 8 os_prio = 1 tid = 0x00000250e4982800 nid = 0x2a54 in Object.wait () [0x000000b82aaff000]
    java.lang.Thread.State: WAITING (auf dem Objektmonitor)
     at java.lang.Object.wait (java.base@10.0.1/Native Method)
     - Warten auf &lt;0x0000000089509410&gt; (eine java.lang.ref.ReferenceQueue $ Lock)
     unter java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - Warten auf erneutes Sperren in wait () &lt;0x0000000089509410&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     unter java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 172)
     at java.lang.ref.Finalizer $ FinalizerThread.run (java.base@10.0.1/Finalizer.java: 216)
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Signal Dispatcher" # 4 Daemon prio = 9 os_prio = 2 tid = 0x00000250e52f2800 nid = 0x2184 runnable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Listener anhängen" # 5 Daemon prio = 5 os_prio = 2 tid = 0x00000250e4992800 nid = 0x1624 wartet auf Bedingung [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "C2 CompilerThread0" # 6 Daemon prio = 9 os_prio = 2 tid = 0x00000250e4995800 nid = 0x4198 wartet auf Bedingung [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Keine Kompilierungsaufgabe
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "C2 CompilerThread1" # 7 Daemon prio = 9 os_prio = 2 tid = 0x00000250e49a5800 nid = 0x3b98 wartet auf Bedingung [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Keine Kompilierungsaufgabe
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "C1 CompilerThread2" # 8 Daemon prio = 9 os_prio = 2 tid = 0x00000250e49ae800 nid = 0x1a84 wartet auf Bedingung [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Keine Kompilierungsaufgabe
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Sweeper-Thread" # 9 Daemon prio = 9 os_prio = 2 tid = 0x00000250e5324000 nid = 0x5f0 ausführbar [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Service Thread" # 10 Daemon prio = 9 os_prio = 0 tid = 0x00000250e54cd800 nid = 0x169c ausführbar [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Common-Cleaner" # 11 Daemon prio = 8 os_prio = 1 tid = 0x00000250e54cf000 nid = 0x1610 in Object.wait () [0x000000b82b2fe000]
    java.lang.Thread.State: TIMED_WAITING (auf dem Objektmonitor)
     at java.lang.Object.wait (java.base@10.0.1/Native Method)
     - Warten auf &lt;0x000000008943e600&gt; (eine java.lang.ref.ReferenceQueue $ Lock)
     unter java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - Warten auf erneutes Sperren in wait () &lt;0x000000008943e600&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     unter jdk.internal.ref.CleanerImpl.run (java.base@10.0.1/CleanerImpl.java: 148)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
     unter jdk.internal.misc.InnocuousThread.run (java.base@10.0.1/InnocuousThread.java: 134)
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec wartet auf Monitoreintrag [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (auf dem Objektmonitor)
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Thread-1" # 13 prio = 5 os_prio = 0 tid = 0x00000250e54d2000 nid = 0x415c wartet auf Monitoreintrag [0x000000b82b5ff000]
    java.lang.Thread.State: BLOCKED (auf dem Objektmonitor)
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "DestroyJavaVM" # 14 prio = 5 os_prio = 0 tid = 0x00000250e54d0800 nid = 0x2b8c wartet auf Bedingung [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 ausführbar  
 "GC Thread # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c ausführbar  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 ausführbar  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 ausführbar  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 ausführbar  
 "G1 Hauptmarker" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 ausführbar  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 ausführbar  
 "G1 Refine # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c ausführbar  
 "G1 Refine # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 ausführbar  
 "G1 Refine # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 ausführbar  
 "G1 Refine # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 ausführbar  
 "G1 Young RemSet Sampling" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 runnable  
 "VM Periodic Task Thread" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 wartet auf Bedingung  
 Globale JNI-Referenzen: 2
 Es wurde ein Deadlock auf Java-Ebene gefunden:
 ===============================
 "Thread-0":
   Warten auf Sperren des Monitors 0x00000250e4982480 (Objekt 0x00000000894465b0, ein java.lang.Object),
   welches von "Thread-1" gehalten wird
 "Thread-1":
   Warten auf Sperren des Monitors 0x00000250e4982380 (Objekt 0x00000000894465a0, ein java.lang.Object),
   welches von "Thread-0" gehalten wird
 Java-Stack-Informationen für die oben aufgeführten Threads:
 ================================================== =
 "Thread-0":
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Thread-1":
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 1 Deadlock gefunden.
</pre><br><h3>  Einführende Informationen </h3><br>  Obwohl diese Datei auf den ersten Blick zu kompliziert und verwirrend erscheint, ist es in Wirklichkeit recht einfach, wenn Sie sie Schritt für Schritt in Teile zerlegen. <br><br>  Die erste Zeile gibt den Zeitpunkt an, zu dem der Speicherauszug erstellt wurde, die zweite - Diagnoseinformationen über die JVM, auf der der Speicherauszug empfangen wurde: <br><br><pre> <code class="hljs css">2018<span class="hljs-selector-tag"><span class="hljs-selector-tag">-06-19</span></span> 16<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Full</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dump</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Java</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">HotSpot</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TM</span></span>) 64<span class="hljs-selector-tag"><span class="hljs-selector-tag">-Bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Server</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VM</span></span> (10<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span>+10 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mixed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mode</span></span>):</code> </pre> <br>  In diesem Abschnitt gibt es keine Flussinformationen.  Hier wird der allgemeine Kontext des Systems festgelegt, in dem der Speicherauszug gesammelt wurde. <br><br><h4>  Allgemeine Flussinformationen </h4><br>  Der folgende Abschnitt enthält Informationen zu den Threads, die zum Zeitpunkt der Speicherauszugserfassung im System ausgeführt wurden: <br><br><pre> Threads Klasse SMR Info:
 _java_thread_list = 0x00000250e5488a00, Länge = 13, Elemente = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }}
</pre><br>  Der folgende Abschnitt listet auf: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMR-Informationen (Safe Memory Reclamation)</a> <br><br>  Es enthält Informationen zu Threads außerhalb der JVM, d. H.  Dies sind keine Threads für virtuelle Maschinen oder Garbage Collection-Threads.  Wenn Sie sich die Adressen dieser Threads ansehen, werden Sie feststellen, dass sie dem Wert von <i>tid entsprechen</i> - der "natürlichen, eisernen" (nativen) Adresse im Betriebssystem und nicht der Thread-ID. <br><br>  Ellipsen werden verwendet, um redundante Informationen auszublenden: <br><br><pre> "Referenzhandler" # 2 ... tid = 0x00000250e4979000 ...
 "Finalizer" # 3 ... tid = 0x00000250e4982800 ...
 "Signal Dispatcher" # 4 ... tid = 0x00000250e52f2800 ...
 "Listener anhängen" # 5 ... tid = 0x00000250e4992800 ...
 "C2 CompilerThread0" # 6 ... tid = 0x00000250e4995800 ...
 "C2 CompilerThread1" # 7 ... tid = 0x00000250e49a5800 ...
 "C1 CompilerThread2" # 8 ... tid = 0x00000250e49ae800 ...
 "Kehrfaden" # 9 ... tid = 0x00000250e5324000 ...
 "Service Thread" # 10 ... tid = 0x00000250e54cd800 ...
 "Common-Cleaner" # 11 ... tid = 0x00000250e54cf000 ...
 "Thread-0" # 12 ... tid = 0x00000250e54d1800 ...
 "Thread-1" # 13 ... tid = 0x00000250e54d2000 ...
 "DestroyJavaVM" # 14 ... tid = 0x00000250e54d0800 ...
</pre><br><h3>  Streams </h3><br>  Direkt nach dem SMR-Block befindet sich eine Liste von Threads.  Der erste Thread auf unserer Liste ist der Referenzhandler: <br><br><pre> "Reference Handler" # 2 Daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 wartet auf Bedingung [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     at java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     unter java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     unter java.lang.ref.Reference.access $ 000 (java.base@10.0.1/Reference.java: 44)
     at java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Gesperrte besitzbare Synchronisierer:
     - Keine
</pre><br><h4>  Kurze Beschreibung des Streams </h4><br>  Die erste Zeile für jeden Thread enthält eine allgemeine Beschreibung.  Die Beschreibung enthält folgende Elemente: <br><table><tbody><tr><th width="70">  Abschnitt </th><th width="100">  Beispiel </th><th>  Beschreibung </th></tr><tr><td>  Name </td><td>  "Referenzhandler" </td><td>  Vom Menschen lesbarer Streamname.  Der Name kann durch Aufrufen der <i>setName-</i> Methode des <i>Thread-</i> Objekts angegeben werden.  Und rufen Sie <i>getName an</i> </td></tr><tr><td>  ID </td><td>  # 2 </td><td>  Eine eindeutige ID, die jedem Objekt der <i>Thread-</i> Klasse zugewiesen wird.  ID wird für Threads im System generiert.  Der Anfangswert ist 1. Jedem neu erstellten Thread wird eine eigene ID zugewiesen, die zuvor um 1 erhöht wurde. Diese schreibgeschützte Thread-Eigenschaft kann mit der Funktion <i>getId eines</i> Objekts der <i>Thread-</i> Klasse abgerufen werden. </td></tr><tr><td>  Daemon-Status </td><td>  Daemon </td><td>  Die Flagge ist ein Zeichen dafür, dass der Thread ein Dämon ist.  Wenn es sich um einen Dämon handelt, wird die Flagge gesetzt.  Beispielsweise ist Thread <i>-0</i> kein Daemon. </td></tr><tr><td>  Priorität </td><td>  Prio = 10 </td><td>  Die numerische Priorität des Java-Streams.  Beachten Sie, dass diese Priorität nicht unbedingt der Priorität des zugeordneten Threads im Betriebssystem entspricht.  Um die Priorität festzulegen, können Sie <br>  Verwenden Sie die <i>setPriority-</i> Methode <i>eines</i> Objekts der Klasse <i>Thread</i> und, um <i>abzurufen</i> <br>  <i>getPriority-</i> Methode. </td></tr><tr><td>  OS-Thread-Priorität </td><td>  os_prio = 2 </td><td>  Prioritäts-Thread im Betriebssystem.  Diese Priorität kann von der dem verknüpften Java-Thread zugewiesenen Priorität abweichen. </td></tr><tr><td>  Adresse </td><td>  tid = 0x00000250e4979000 </td><td>  Die Adresse des Java-Streams.  Diese Adresse ist ein Zeiger auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">native JNI-</a> Objekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">(Java Native Interface)</a> der <i>Thread-</i> Klasse (ein C ++ - <i>Thread-</i> Objekt, das über JNI mit dem Java-Thread verbunden ist).  Dieser Wert wird erhalten, indem ein Zeiger darauf geworfen wird <br>  (das C ++ - Objekt, das diesem Java-Thread zugeordnet ist) in Ganzzahl.  Siehe <br>  <a href="">Zeile 879 in hotspot / share / runtime / thread.cpp</a> : <br><pre> st-&gt; print ("tid =" INTPTR_FORMAT "", p2i (this));
</pre><br>  Obwohl der Schlüssel für dieses Objekt ( <i>tid</i> ) wie eine Stream-ID aussehen kann, <br>  Tatsächlich ist dies die Adresse des mit dem <i>JNI C ++ - Thread</i> verbundenen Objekts, und dies ist nicht der Wert, der <br>  <i>Gibt</i> die <i>getId-</i> Methode des Java- <i>Threads zurück</i> . </td></tr><tr><td>  OS-Thread-ID </td><td>  nid = 0x3c28 </td><td>  Die eindeutige Kennung des Betriebssystem-Threads, an den der Java-Thread gebunden ist. <br>  Dieser Wert wird mit folgendem Code ausgegeben: <br>  <a href="">Zeile 42 in hotspot / share / runtime / osThread.cpp</a> : <br><pre> st-&gt; print ("nid = 0x% x", thread_id ());
</pre><br></td></tr><tr><td>  Status </td><td>  Warten unter der Bedingung </td><td>  Vom Menschen lesbarer Status des aktuellen Threads. <br>  In dieser Zeile werden zusätzliche Informationen zum einfachen Status des Streams angezeigt (siehe unten) <br>  wird verwendet, um zu verstehen, was der Thread tun würde (d. h. ob der Thread versucht hat, eine Sperre zu erhalten <br>  oder darauf warten, dass die Entsperrbedingung erfüllt ist). </td></tr><tr><td>  Letzter bekannter Java-Stapelzeiger </td><td>  [0x000000b82a9ff000] </td><td>  Der letzte bekannte Stapelzeiger (SP), der diesem Stream zugeordnet ist. <br>  Dieser Wert wird mit nativem C ++ - Code erhalten, der mit Java-Code unter Verwendung von JNI gemischt wird.  Der Wert wird von der Funktion <i>last_Java_sp () zurückgegeben</i> . <br>  <a href="">Zeile 2886 in hotspot / share / runtime / thread.cpp</a> : <br><pre>   st-&gt; print_cr ("[" INTPTR_FORMAT "]", 
     (intptr_t) last_Java_sp () &amp; ~ right_n_bits (12));
</pre><br>  Für einfache Thread-Dumps sind diese Informationen fast unbrauchbar.  In komplexen Fällen kann SP jedoch <br>  verwendet werden, um Schlösser zu verfolgen. </td></tr></tbody></table><br><h4>  Stream-Status </h4><br>  Die zweite Zeile ist der aktuelle Status des Streams.  Mögliche Stream-Zustände sind in Aufzählung aufgeführt: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Thread.State</a> : <br><br>  NEU <br>  RUNNABLE <br>  BLOCKIERT <br>  WARTEN <br>  TIMED_WAITING <br>  BEENDET <br><br>  Weitere Informationen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Dokumentation</a> . <br><br><h4>  Thread-Stack-Trace </h4><br>  Der nächste Abschnitt enthält die Stapelverfolgung des Streams zum Zeitpunkt des Dumps.  Diese Stapelverfolgung ist einer Stapelverfolgung sehr ähnlich, die von einer nicht erfassten Ausnahme ausgelöst wird.  Und es enthält die Namen von Klassen und Zeichenfolgen, die zum Zeitpunkt der Erstellung des Dumps ausgeführt wurden.  Im Fall des Reference Handler-Streams sehen wir nichts Interessantes. <br><br>  Die Thread-02-Thread-Ablaufverfolgung unterscheidet sich jedoch von der Standard-Ablaufverfolgung: <br><br><pre> "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec wartet auf Monitoreintrag [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (auf dem Objektmonitor)
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Gesperrte besitzbare Synchronisierer:
     - Keine
</pre><br>  In der Ablaufverfolgung sehen wir, dass Informationen zur Sperre hinzugefügt wurden.  Dieser Thread erwartet eine Sperre für das Objekt mit der Adresse 0x00000000894465b0 (Objekttyp java.lang.Object).  Darüber hinaus enthält der Thread selbst die Sperre mit der Adresse 0x00000000894465a0 (auch ein java.lang.Object).  Diese Informationen werden uns später für die Diagnose eines Deadlocks nützlich sein. <br><br><h4>  Erfasste Synchronisationsprimitive (Ownable Synchronizer) </h4><br>  Der letzte Abschnitt listet die vom Stream erfassten Synchronisationsprimitive auf.  Dies sind Objekte, mit denen Threads synchronisiert werden können, z. B. Sperren. <br><br>  Gemäß der offiziellen Java-Dokumentation ist <strong>Ownable Synchronizer</strong> der Nachkomme von <i>AbstractOwnableSynchronizer</i> (oder seiner Unterklasse), der ausschließlich vom Stream zu Synchronisationszwecken erfasst werden kann. <br><br>  <i>ReentrantLock</i> und <i>Schreibsperre</i> , jedoch nicht die <i>Lesesperre</i> der <i>ReentrantReadWriteLock-</i> Klasse, sind zwei gute Beispiele für solche "besitzbaren Synchronisierer", die von der Plattform angeboten werden. <br><br>  Weitere Informationen zu diesem Thema finden Sie hier <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Post</a> . <br><br><h4>  JVM-Threads </h4><br>  Der nächste Abschnitt des Speicherauszugs enthält Informationen zu technischen JVM-Threads, die nicht Teil der Anwendung sind und Betriebssystem-Threads zugeordnet sind.  Weil  Diese Streams funktionieren außerhalb der Anwendung. Sie haben keine Stream-IDs.  Am häufigsten sind dies Garbage Collector-Threads und andere technische JVM-Threads: <br><br><pre> "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 ausführbar  
 "GC Thread # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c ausführbar  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 ausführbar  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 ausführbar  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 ausführbar  
 "G1 Hauptmarker" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 ausführbar  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 ausführbar  
 "G1 Refine # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c ausführbar  
 "G1 Refine # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 ausführbar  
 "G1 Refine # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 ausführbar  
 "G1 Refine # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 ausführbar  
 "G1 Young RemSet Sampling" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 runnable  
 "VM Periodic Task Thread" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 wartet auf Bedingung
</pre><br><h4>  JNI Global Links </h4><br>  Dieser Abschnitt gibt die Anzahl der globalen Referenzen an, die von der JVM über die JNI verwendet werden.  Diese Links werden vom Garbage Collector nicht bereitgestellt und können unter bestimmten Umständen einen Speicherverlust verursachen. <br><br><pre> Globale JNI-Referenzen: 2
</pre><br>  In den meisten einfachen Fällen werden diese Informationen nicht verwendet.  Die Bedeutung globaler Referenzen muss jedoch verstanden werden.  Weitere Informationen finden Sie in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Beitrag</a> . <br><br><h4>  Deadlocked Threads </h4><br>  Der letzte Abschnitt enthält Informationen zu gefundenen Deadlocks. <br>  Wenn diese nicht gefunden werden, ist der Abschnitt leer.  Weil  Wir haben speziell eine Anwendung mit Schlössern entwickelt, in unserem Fall ist dieser Abschnitt.  Während des Dumpings wurde eine Sperre festgestellt, die folgende Meldung enthält: <br><br><pre> Es wurde ein Deadlock auf Java-Ebene gefunden:
 ===============================
 "Thread-0":
   Warten auf Sperren des Monitors 0x00000250e4982480 (Objekt 0x00000000894465b0, ein java.lang.Object),
   welches von "Thread-1" gehalten wird
 "Thread-1":
   Warten auf Sperren des Monitors 0x00000250e4982380 (Objekt 0x00000000894465a0, ein java.lang.Object),
   welches von "Thread-0" gehalten wird
 Java-Stack-Informationen für die oben aufgeführten Threads:
 ================================================== =
 "Thread-0":
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Thread-1":
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 1 Deadlock gefunden.
</pre><br>  Der erste Unterabschnitt beschreibt das Deadlock-Szenario: <br><br>  Thread-0 erwartet, dass der Monitor erfasst werden kann (dies ist ein Zugriff auf den <i>synchronisierten</i> Block <i>(secondResource)</i> in unserer Anwendung). Gleichzeitig hält dieser Thread einen Monitor, der versucht, den Thread-1 zu erfassen (dies <i>greift</i> auf dasselbe Codefragment zu: <i>synchronized (secondResource) )</i> in unserer Bewerbung). <br><br>  Dieses kreisförmige Schloss wird auch als <strong>Deadlock bezeichnet</strong> .  Im Bild unten <br>  Diese Situation wird in grafischer Form dargestellt: <br><br><img src="https://habrastorage.org/webt/11/yd/kr/11ydkrm0xkbw8aqxb8t71kypskg.png"><br><br>  Im zweiten Unterabschnitt wird die Stapelverfolgung für beide blockierten Threads angegeben. <br><br>  Mit dieser Stapelverfolgung können wir den Betrieb jedes Threads verfolgen, bis eine Sperre auftritt. <br>  In unserem Fall, wenn wir uns die Zeile ansehen: <br><br>  <i>Bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34) sehen</i> wir den Problemteil des Codes: <br><br><pre> printLockedResource (secondResource);
</pre><br>  Diese Zeile ist die erste Zeile des synchronisierten Blocks, die den Grund für die Sperre darstellt, und gibt an, dass die Synchronisierung auf der zweiten Ressource der Grund für die gegenseitige Sperre ist.  Um Abhilfe zu schaffen, müssen wir sicherstellen, dass beide Threads dieselbe Synchronisationsreihenfolge für die Ressourcen resourceA und resourceB haben.  Wenn wir dies tun, kommen wir zu der folgenden Anwendung: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Diese Anwendung wird ohne Verriegelung beendet, und als Ergebnis erhalten wir die folgende Ausgabe (beachten Sie, dass sich die Adressen der Object-Klasse geändert haben): <br><br><pre> Thread-0: gesperrte Ressource -&gt; java.lang.Object@1ad895d1
 Thread-0: gesperrte Ressource -&gt; java.lang.Object@6e41d7dd
 Thread-1: gesperrte Ressource -&gt; java.lang.Object@1ad895d1
 Thread-1: gesperrte Ressource -&gt; java.lang.Object@6e41d7dd
</pre><br>  ,   ,   thread dump,           .        (     deadlock-).      ,   . <br><br><h3>    Thread Dump- </h3><br>         . <br><br>   JVM       .         (     ,   ). <br><br>         . <br><br>       - — Thread Dump Analyzers (TDAs).    Java thread dump-     - ,     .  ,           . ,        . <br><br>        TDA: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">fastThread</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Spotify TDA</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">IBM Thread and Monitor Dump Analyze for Java</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">irockel TDA</a> </li></ul><br>        .               . <br><br><h4>  Fazit </h4><br> Thread dump- —      Java-,       .     ,           . <br><br>        deadlock,    .         .     ,           — . <br><br>   ,   Java-     thread dump-.     ,             . <br><br> , thread dump —   « »   ,        ,      Java-. <br><br> <i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Java</a>     .       ,        deadlock- .</i> <br><br> <i>      ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427513/">https://habr.com/ru/post/de427513/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427499/index.html">Worüber schreiben sie im technischen Support des Video-Streamers?</a></li>
<li><a href="../de427501/index.html">Seymour Papert: Harter Spaß</a></li>
<li><a href="../de427505/index.html">Vermutung des Geistes</a></li>
<li><a href="../de427507/index.html">Seymour Papert: Die köstliche Entdeckung von "Nichts"</a></li>
<li><a href="../de427509/index.html">Webserver: Southbridge Erfahrung und Praxis</a></li>
<li><a href="../de427517/index.html">Übersicht der interessantesten Joker 2018-Berichte: Version von EastBanc Technologies</a></li>
<li><a href="../de427519/index.html">@Kubernetes Meetup bei Mail.Ru Group: 29. Oktober und immer</a></li>
<li><a href="../de427521/index.html">Durchbruchspreis 2019. Die Gewinner des Milner, Brin und Zuckerberg Science Award werden bekannt gegeben.</a></li>
<li><a href="../de427523/index.html">Absicherungserfolg</a></li>
<li><a href="../de427525/index.html">Intel Core 9th Gen in Zahlen und Benchmarks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>