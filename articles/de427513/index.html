<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôêÔ∏è ü§† üêØ So analysieren Sie den Thread-Dump üñêüèæ üàØÔ∏è ‚è≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt einige Themen zu den Interna der JVM im Java Developer- Kursprogramm. Wir verstehen die Arbeitsmechanismen von Sammlungen, Bytecode, Garbage C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So analysieren Sie den Thread-Dump</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/427513/">  <i>Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gibt</a> einige Themen zu den Interna der JVM im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java Developer-</a> Kursprogramm.</i>  <i>Wir verstehen die Arbeitsmechanismen von Sammlungen, Bytecode, Garbage Collectors usw.</i>  <i>Heute widmen wir Ihnen die √úbersetzung eines ziemlich interessanten Artikels √ºber Thread Dump.</i>  <i>Was ist es, wie man es bekommt und wie man es benutzt.</i> <br><br>  M√∂chten Sie lernen, wie Sie den Thread-Dump analysieren?  Gehen Sie unter die Katze, um mehr dar√ºber zu erfahren, wie Sie einen Thread-Dump in Java erhalten und was Sie sp√§ter damit tun k√∂nnen. <br><a name="habracut"></a><br>  Die meisten modernen Java-Anwendungen sind Multithread-Anwendungen.  Multithreading kann die Funktionalit√§t der Anwendung erheblich erweitern und gleichzeitig eine erhebliche Komplexit√§t mit sich bringen. <br><br>  In einer Single-Threaded-Anwendung k√∂nnen alle Ressourcen (gemeinsam genutzter Speicher, Eingabe- / Ausgabeoperationen usw.) ohne Synchronisierung verwendet werden, da  Zu einem bestimmten Zeitpunkt verwendet nur ein Thread die Ressource. <br><br>  Bei Multithread-Anwendungen muss ein Kompromiss zwischen der Komplikation des Programms und einer m√∂glichen Leistungssteigerung gefunden werden, wenn mehrere Threads alle verf√ºgbaren (h√§ufig mehr als einen) Core-Prozessor (CPU) verwenden k√∂nnen.  Wenn alles richtig gemacht wurde, k√∂nnen Sie mit Multithreading (formalisiert nach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amdahls Gesetz</a> ) eine signifikante Steigerung der Anwendungsleistung erzielen.  Es muss jedoch beachtet werden, dass mehrere Streams gleichzeitig auf eine gemeinsam genutzte Ressource zugreifen k√∂nnen.  In den meisten F√§llen kapseln Frameworks wie Spring die Arbeit mit Threads und verbergen viele technische Details vor Benutzern.  Bei der Verwendung moderner komplexer Frameworks kann jedoch etwas schief gehen, und wir als Benutzer werden auf schwer zu l√∂sende Multithreading-Fehler sto√üen. <br><br>  Gl√ºcklicherweise ist Java mit einem speziellen Mechanismus ausgestattet, mit dem Informationen √ºber den aktuellen Status aller Threads zu einem bestimmten Zeitpunkt abgerufen werden k√∂nnen - es handelt sich um einen Thread-Dump (eine Art Snapshot).  In diesem Artikel erfahren Sie, wie Sie einen Thread-Dump f√ºr eine Anwendung mit realistischer Gr√∂√üe erstellen und diesen Dump analysieren. <br><br>  Es wird davon ausgegangen, dass der Leser √ºber grundlegende Informationen zur Multithread-Programmierung verf√ºgt und sich der Probleme der Thread-Synchronisation und der Verwendung gemeinsam genutzter Ressourcen bewusst ist.  Es wird jedoch nicht √ºberfl√ºssig sein, einige grundlegende Begriffe und Konzepte zu aktualisieren. <br><br><h4>  Grundlegende Terminologie </h4><br>  Auf den ersten Blick m√∂gen Java-Thread-Dumps wie ein ‚Äûchinesischer Buchstabe‚Äú erscheinen. Die folgenden Konzepte sind der Schl√ºssel zum Verst√§ndnis.  Im Allgemeinen wiederholen wir die Grundbegriffe des Multithreading, mit denen wir Dumps analysieren. <br><br><ul><li> <strong>Thread</strong> oder Thread ist eine diskrete Multithreading-Einheit, die von der Java Virtual Machine (JVM) verwaltet wird.  JVM-Threads entsprechen Threads im Betriebssystem (OS) - native Threads, die den Codeausf√ºhrungsmechanismus implementieren. <br><br>  Jeder Thread hat eine eindeutige Kennung und einen eindeutigen Namen.  Streams k√∂nnen "D√§monen" und "keine D√§monen" sein. <br><br>  Das Programm wird beendet, wenn alle Nicht-Daemon-Threads beendet werden oder die Methode <i>Runtime.exit aufgerufen wird</i> .  Arbeitende "D√§monen" haben keinen Einfluss auf den Abschluss des Programms.  Das hei√üt,  Die JVM wartet darauf, dass alle ‚ÄûNicht-D√§monen‚Äú finalisiert und heruntergefahren werden. Sie achten nicht auf ‚ÄûNicht-D√§monen‚Äú. <br><br>  Weitere Informationen finden Sie in der Dokumentation zur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Thread-Klasse</a> . <br>  Ein Stream kann sich in einem der folgenden Zust√§nde befinden: <br><br><ul><li>  <strong>Lebendiger Thread</strong> oder "live" - ‚Äã‚Äãein Thread, der etwas Arbeit leistet (normaler Zustand). </li><li>  <strong>Blockierter Thread</strong> oder "blockiert" - Ein Thread, der versucht hat, in den synchronisierten Abschnitt einzutreten (synchronisiert), aber ein anderer Thread hat es bereits geschafft, zuerst in diesen Block einzutreten, und alle folgenden Threads, die versuchen, in denselben Block einzutreten, werden blockiert. </li><li>  <strong>Wartender Thread</strong> oder "Warten" - ein Thread, der die <i>Wartemethode</i> aufgerufen hat (m√∂glicherweise mit einer Zeit√ºberschreitung) und jetzt darauf wartet, dass eine andere Methode <i>notify</i> oder <i>nonifyAll</i> f√ºr dasselbe Objekt ausf√ºhrt. <br><br>  Bitte beachten Sie, dass der Thread nicht als "wartend" betrachtet wird, wenn er "Warten mit einer Zeit√ºberschreitung" aufgerufen hat und diese Zeit√ºberschreitung abgelaufen ist. </li><li>  <strong>Sleeping Thread</strong> oder "Sleeping" - ein Thread, der derzeit nicht ausgef√ºhrt wird, weil  f√ºhrte die Thread.sleep-Methode durch (Angabe der Dauer des "Schlafes"). </li></ul></li><li>  <strong>Monitor</strong> ist ein Mechanismus, der von der JVM verwendet wird, um Multithread-Zugriff auf ein einzelnes Objekt bereitzustellen.  Der Mechanismus wird mit dem speziellen <i>synchronisierten Schl√ºsselwort</i> gestartet. <br><br>  Jedes Objekt in Java hat einen Monitor, mit dem der Thread synchronisiert werden kann, d.h.  Setzen Sie eine Sperre, die garantiert, dass kein anderer Thread Zugriff auf dieses Objekt erh√§lt, bis die Sperre aufgehoben wird, d. h.  Thread - Der Eigent√ºmer der Sperre verl√§sst den <i>synchronisierten</i> Block nicht. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Informationen finden</a> Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt Synchronisierung (17.1) der Java Langauge Specification (JLS)</a> . <br></li><li>  <strong>Deadlock</strong> ist eine Situation, in der ein Thread, z. B. A, eine Ressource blockiert. Er ben√∂tigt eine andere Ressource, die von einem anderen Thread blockiert wird, z. B. B. Stream B gibt diese Ressource nicht frei, weil  Um einen bestimmten Vorgang abzuschlie√üen, ben√∂tigt er eine Ressource, die von Thread A blockiert wird. Es stellt sich heraus, dass Thread A darauf wartet, dass die Ressource von Thread B entsperrt wird, der darauf wartet, dass eine andere Ressource von Thread A entsperrt wird. Daher warten die Threads aufeinander.  Infolgedessen h√§ngt das gesamte Programm und wartet darauf, dass die Threads irgendwie entsperrt werden und weiterarbeiten.  In einem Deadlock k√∂nnen sich viele Threads befinden.  Dieses Problem ist als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Problem der Speisephilosophen" bekannt.</a> <br><br><img src="https://habrastorage.org/webt/8t/ll/jb/8tlljb_n-e80_dk_0uayobgil_s.png"><br></li><li>  <strong>Livelock</strong> ist eine Situation, in der Thread A Thread B zwingt, eine Aktion auszuf√ºhren, was wiederum dazu f√ºhrt, dass Thread A die anf√§ngliche Aktion ausf√ºhrt, was wiederum die Aktion von Thread B bewirkt. Eine zyklische Abh√§ngigkeit wird erhalten.  Dies kann man sich als einen Hund vorstellen, der seinem Schwanz nachl√§uft.  √Ñhnlich wie bei <i>Deadlock macht</i> das Programm in einer Livelock-Situation keine Fortschritte, d. H.  f√ºhrt keine n√ºtzliche Aktion aus, in dieser Situation werden die Threads jedoch nicht blockiert. <br></li></ul><br>  Die vorgestellte Terminologie ist nicht ersch√∂pfend f√ºr die Beschreibung der Welt des Multithreading, aber dies reicht aus, um mit der Analyse von Thread-Dumps zu beginnen. <br><br>  Weitere Informationen finden Sie in folgenden Quellen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Abschnitt 17 der JLS-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java-Parallelit√§t in der Praxis</a> <br><br>  Mit diesen einfachen Konzepten zum Ablauf in Java k√∂nnen wir eine Testanwendung erstellen.  F√ºr diese Anwendung kompilieren wir den Thread-Dump.  Wir werden den resultierenden Speicherauszug analysieren und n√ºtzliche Informationen √ºber die aktuellen Anwendungsabl√§ufe extrahieren. <br><br><h4>  Beispielprogramm erstellen </h4><br>  Vor dem Erstellen eines Thread-Dumps m√ºssen wir eine Java-Anwendung entwickeln.  Das traditionelle "Hallo Welt!"  F√ºr unseren Zweck zu einfach, und ein mittelgro√üer Speicherauszug der Anwendung ist m√∂glicherweise zu kompliziert, um dies zu demonstrieren.  Basierend darauf werden wir eine ziemlich einfache Anwendung erstellen, in der zwei Threads erstellt werden.  Und die F√§den geraten ins Stocken: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceB, resourceA)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Dieses Programm erstellt zwei Ressourcen: resourceA und resourceB und startet zwei Threads: threadLockingResourceAFirst und threadLockingResourceBFirst, die sich gegenseitig die Ressourcen blockieren. <br><br>  Die Ursache f√ºr einen Deadlock ist eine "Kreuz" -Blockierung von Ressourcen durch Threads. <br><br>  Der Grund f√ºr das Auftreten eines Deadlocks ist ein Versuch, Ressourcen "gegenseitig" zu beschlagnahmen, d.h.  threadLockingResourceAFirst-Thread erfasst resourceA-Ressource, threadLockingResourceBFirst-Thread erfasst resourceB-Ressource.  Danach versucht threadLockingResourceAFirst, ohne seine Ressource freizugeben, resourceB zu greifen, und threadLockingResourceBFirst, ohne seine Ressource freizugeben, versucht, resourceA zu greifen.  Infolgedessen werden Threads blockiert.  Eine Verz√∂gerung von 1s wurde hinzugef√ºgt, um die Blockierung zu gew√§hrleisten.  Threads warten auf die Freigabe der erforderlichen Ressourcen, dies wird jedoch niemals passieren. <br><br>  Die Ausgabe des Programms sieht folgenderma√üen aus (die Zahlen nach java.lang.Object @ sind bei jedem Start unterschiedlich): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Thread-0</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">locked</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">resource</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Object</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">149bc794</span></span> Thread-<span class="hljs-number"><span class="hljs-number">1</span></span>: locked resource -&gt; java.lang.Object@<span class="hljs-number"><span class="hljs-number">17</span></span>c10009</code> </pre> <br>  Nach der Ausgabe dieser Nachrichten sieht das Programm so aus, als w√ºrde es ausgef√ºhrt (der Prozess, der dieses Programm ausf√ºhrt, ist nicht abgeschlossen), w√§hrend das Programm keine Arbeit ausf√ºhrt.  So sieht Deadlock in der Praxis aus.  Um das Problem zu l√∂sen, m√ºssen wir manuell einen Profildump erstellen und den Status der Threads analysieren. <br><br><h4>  Thread Dump Generation </h4><br>  In der Praxis kann ein Java-Programm beim Erstellen eines Thread-Dumps abst√ºrzen.  In einigen F√§llen (z. B. bei Deadlocks) wird das Programm jedoch nicht beendet und der Thread-Dump wird nicht erstellt, sondern h√§ngt nur.  Um einen Speicherauszug solcher blockierter Programme zu erstellen, m√ºssen Sie zun√§chst die Kennung des Programmprozesses herausfinden, d. H.  Prozess-ID (PID).  Dazu k√∂nnen Sie das Dienstprogramm JVM Process Status (JPS) verwenden, das ab Version 7 Teil des Java Development Kit (JDK) ist.  Um die Prozess-PID unseres blockierten Programms zu ermitteln, f√ºhren wir einfach jps im Terminal (Windows oder Linux) aus: <br><br><pre> <code class="hljs ruby">$ jps <span class="hljs-number"><span class="hljs-number">11568</span></span> DeadlockProgram <span class="hljs-number"><span class="hljs-number">15584</span></span> Jps <span class="hljs-number"><span class="hljs-number">15636</span></span></code> </pre> <br>  Die erste Spalte ist die Kennung der lokalen virtuellen Maschine (lokale VM-ID, d. H. Lvmid) f√ºr den ausgef√ºhrten Java-Prozess.  Im Kontext der lokalen JVM verweist lvmid auf die PID des Java-Prozesses. <br><br>  Es ist zu beachten, dass dieser Wert wahrscheinlich vom obigen Wert abweicht.  Die zweite Spalte ist der Name der Anwendung, der auf den Namen der Hauptklasse, der JAR-Datei oder gleich "Unbekannt" verweisen kann.  Es h√§ngt alles davon ab, wie die Anwendung gestartet wurde. <br><br>  In unserem Fall ist der Anwendungsname DeadlockProgram der Name der Hauptklassen, die beim Start des Programms gestartet wurden.  Im obigen Beispiel PID des Programms 11568 reichen diese Informationen aus, um einen Thread-Dump zu generieren.  Um den <strong>Speicherauszug</strong> zu generieren, verwenden wir das Dienstprogramm <strong>jstack</strong> , das Teil des JDK ist, ab Version 7. Um den <strong>Speicherauszug abzurufen</strong> , √ºbergeben wir <strong>die</strong> PID unseres Programms an <strong>jstack</strong> und geben das Flag -l an (Erstellen einer langen Liste).  Die Ausgabe des Dienstprogramms wird in eine Textdatei umgeleitet, d. H.  thread_dump.txt: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">jstack</span></span> -l <span class="hljs-number"><span class="hljs-number">11568</span></span> &gt; thread_dump.txt</code> </pre> <br>  Die resultierende Datei thread_dump.txt enth√§lt den Thread-Dump unseres blockierten Programms und wichtige Informationen zur Diagnose der Ursachen f√ºr Deadlocks. <br><br>  Wenn das JDK bis Version 7 verwendet wird, k√∂nnen Sie zum Generieren eines Speicherauszugs das Linux-Dienstprogramm verwenden - <strong>kill</strong> mit dem Flag -3.  Wenn Sie kill -3 aufrufen, sendet das Programm ein SIGQUIT-Signal. <br><br>  In unserem Fall sieht der Anruf folgenderma√üen aus: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">kill</span></span> <span class="hljs-number"><span class="hljs-number">-3</span></span> <span class="hljs-number"><span class="hljs-number">11568</span></span></code> </pre> <br><h4>  Einfache Thread-Dump-Analyse </h4><br>  Wenn Sie die Datei thread_dump.txt √∂ffnen, sehen Sie ungef√§hr Folgendes: <br><br><pre> 2018-06-19 16:44:44
 Vollst√§ndiger Thread-Dump Java HotSpot (TM) 64-Bit-Server-VM (10.0.1 + 10 gemischter Modus):
 Threads Klasse SMR Info:
 _java_thread_list = 0x00000250e5488a00, L√§nge = 13, Elemente = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }}
 "Reference Handler" # 2 Daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 wartet auf Bedingung [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     at java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     unter java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     unter java.lang.ref.Reference.access $ 000 (java.base@10.0.1/Reference.java: 44)
     at java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Finalizer" # 3 Daemon prio = 8 os_prio = 1 tid = 0x00000250e4982800 nid = 0x2a54 in Object.wait () [0x000000b82aaff000]
    java.lang.Thread.State: WAITING (auf dem Objektmonitor)
     at java.lang.Object.wait (java.base@10.0.1/Native Method)
     - Warten auf &lt;0x0000000089509410&gt; (eine java.lang.ref.ReferenceQueue $ Lock)
     unter java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - Warten auf erneutes Sperren in wait () &lt;0x0000000089509410&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     unter java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 172)
     at java.lang.ref.Finalizer $ FinalizerThread.run (java.base@10.0.1/Finalizer.java: 216)
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Signal Dispatcher" # 4 Daemon prio = 9 os_prio = 2 tid = 0x00000250e52f2800 nid = 0x2184 runnable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Listener anh√§ngen" # 5 Daemon prio = 5 os_prio = 2 tid = 0x00000250e4992800 nid = 0x1624 wartet auf Bedingung [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "C2 CompilerThread0" # 6 Daemon prio = 9 os_prio = 2 tid = 0x00000250e4995800 nid = 0x4198 wartet auf Bedingung [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Keine Kompilierungsaufgabe
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "C2 CompilerThread1" # 7 Daemon prio = 9 os_prio = 2 tid = 0x00000250e49a5800 nid = 0x3b98 wartet auf Bedingung [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Keine Kompilierungsaufgabe
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "C1 CompilerThread2" # 8 Daemon prio = 9 os_prio = 2 tid = 0x00000250e49ae800 nid = 0x1a84 wartet auf Bedingung [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Keine Kompilierungsaufgabe
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Sweeper-Thread" # 9 Daemon prio = 9 os_prio = 2 tid = 0x00000250e5324000 nid = 0x5f0 ausf√ºhrbar [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Service Thread" # 10 Daemon prio = 9 os_prio = 0 tid = 0x00000250e54cd800 nid = 0x169c ausf√ºhrbar [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Common-Cleaner" # 11 Daemon prio = 8 os_prio = 1 tid = 0x00000250e54cf000 nid = 0x1610 in Object.wait () [0x000000b82b2fe000]
    java.lang.Thread.State: TIMED_WAITING (auf dem Objektmonitor)
     at java.lang.Object.wait (java.base@10.0.1/Native Method)
     - Warten auf &lt;0x000000008943e600&gt; (eine java.lang.ref.ReferenceQueue $ Lock)
     unter java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - Warten auf erneutes Sperren in wait () &lt;0x000000008943e600&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     unter jdk.internal.ref.CleanerImpl.run (java.base@10.0.1/CleanerImpl.java: 148)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
     unter jdk.internal.misc.InnocuousThread.run (java.base@10.0.1/InnocuousThread.java: 134)
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec wartet auf Monitoreintrag [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (auf dem Objektmonitor)
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "Thread-1" # 13 prio = 5 os_prio = 0 tid = 0x00000250e54d2000 nid = 0x415c wartet auf Monitoreintrag [0x000000b82b5ff000]
    java.lang.Thread.State: BLOCKED (auf dem Objektmonitor)
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "DestroyJavaVM" # 14 prio = 5 os_prio = 0 tid = 0x00000250e54d0800 nid = 0x2b8c wartet auf Bedingung [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Gesperrte besitzbare Synchronisierer:
     - Keine
 "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 ausf√ºhrbar  
 "GC Thread # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c ausf√ºhrbar  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 ausf√ºhrbar  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 ausf√ºhrbar  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 ausf√ºhrbar  
 "G1 Hauptmarker" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 ausf√ºhrbar  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 ausf√ºhrbar  
 "G1 Refine # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c ausf√ºhrbar  
 "G1 Refine # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 ausf√ºhrbar  
 "G1 Refine # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 ausf√ºhrbar  
 "G1 Refine # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 ausf√ºhrbar  
 "G1 Young RemSet Sampling" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 runnable  
 "VM Periodic Task Thread" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 wartet auf Bedingung  
 Globale JNI-Referenzen: 2
 Es wurde ein Deadlock auf Java-Ebene gefunden:
 ===============================
 "Thread-0":
   Warten auf Sperren des Monitors 0x00000250e4982480 (Objekt 0x00000000894465b0, ein java.lang.Object),
   welches von "Thread-1" gehalten wird
 "Thread-1":
   Warten auf Sperren des Monitors 0x00000250e4982380 (Objekt 0x00000000894465a0, ein java.lang.Object),
   welches von "Thread-0" gehalten wird
 Java-Stack-Informationen f√ºr die oben aufgef√ºhrten Threads:
 ================================================== =
 "Thread-0":
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Thread-1":
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 1 Deadlock gefunden.
</pre><br><h3>  Einf√ºhrende Informationen </h3><br>  Obwohl diese Datei auf den ersten Blick zu kompliziert und verwirrend erscheint, ist es in Wirklichkeit recht einfach, wenn Sie sie Schritt f√ºr Schritt in Teile zerlegen. <br><br>  Die erste Zeile gibt den Zeitpunkt an, zu dem der Speicherauszug erstellt wurde, die zweite - Diagnoseinformationen √ºber die JVM, auf der der Speicherauszug empfangen wurde: <br><br><pre> <code class="hljs css">2018<span class="hljs-selector-tag"><span class="hljs-selector-tag">-06-19</span></span> 16<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Full</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dump</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Java</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">HotSpot</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TM</span></span>) 64<span class="hljs-selector-tag"><span class="hljs-selector-tag">-Bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Server</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VM</span></span> (10<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span>+10 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mixed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mode</span></span>):</code> </pre> <br>  In diesem Abschnitt gibt es keine Flussinformationen.  Hier wird der allgemeine Kontext des Systems festgelegt, in dem der Speicherauszug gesammelt wurde. <br><br><h4>  Allgemeine Flussinformationen </h4><br>  Der folgende Abschnitt enth√§lt Informationen zu den Threads, die zum Zeitpunkt der Speicherauszugserfassung im System ausgef√ºhrt wurden: <br><br><pre> Threads Klasse SMR Info:
 _java_thread_list = 0x00000250e5488a00, L√§nge = 13, Elemente = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }}
</pre><br>  Der folgende Abschnitt listet auf: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SMR-Informationen (Safe Memory Reclamation)</a> <br><br>  Es enth√§lt Informationen zu Threads au√üerhalb der JVM, d. H.  Dies sind keine Threads f√ºr virtuelle Maschinen oder Garbage Collection-Threads.  Wenn Sie sich die Adressen dieser Threads ansehen, werden Sie feststellen, dass sie dem Wert von <i>tid entsprechen</i> - der "nat√ºrlichen, eisernen" (nativen) Adresse im Betriebssystem und nicht der Thread-ID. <br><br>  Ellipsen werden verwendet, um redundante Informationen auszublenden: <br><br><pre> "Referenzhandler" # 2 ... tid = 0x00000250e4979000 ...
 "Finalizer" # 3 ... tid = 0x00000250e4982800 ...
 "Signal Dispatcher" # 4 ... tid = 0x00000250e52f2800 ...
 "Listener anh√§ngen" # 5 ... tid = 0x00000250e4992800 ...
 "C2 CompilerThread0" # 6 ... tid = 0x00000250e4995800 ...
 "C2 CompilerThread1" # 7 ... tid = 0x00000250e49a5800 ...
 "C1 CompilerThread2" # 8 ... tid = 0x00000250e49ae800 ...
 "Kehrfaden" # 9 ... tid = 0x00000250e5324000 ...
 "Service Thread" # 10 ... tid = 0x00000250e54cd800 ...
 "Common-Cleaner" # 11 ... tid = 0x00000250e54cf000 ...
 "Thread-0" # 12 ... tid = 0x00000250e54d1800 ...
 "Thread-1" # 13 ... tid = 0x00000250e54d2000 ...
 "DestroyJavaVM" # 14 ... tid = 0x00000250e54d0800 ...
</pre><br><h3>  Streams </h3><br>  Direkt nach dem SMR-Block befindet sich eine Liste von Threads.  Der erste Thread auf unserer Liste ist der Referenzhandler: <br><br><pre> "Reference Handler" # 2 Daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 wartet auf Bedingung [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     at java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     unter java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     unter java.lang.ref.Reference.access $ 000 (java.base@10.0.1/Reference.java: 44)
     at java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Gesperrte besitzbare Synchronisierer:
     - Keine
</pre><br><h4>  Kurze Beschreibung des Streams </h4><br>  Die erste Zeile f√ºr jeden Thread enth√§lt eine allgemeine Beschreibung.  Die Beschreibung enth√§lt folgende Elemente: <br><table><tbody><tr><th width="70">  Abschnitt </th><th width="100">  Beispiel </th><th>  Beschreibung </th></tr><tr><td>  Name </td><td>  "Referenzhandler" </td><td>  Vom Menschen lesbarer Streamname.  Der Name kann durch Aufrufen der <i>setName-</i> Methode des <i>Thread-</i> Objekts angegeben werden.  Und rufen Sie <i>getName an</i> </td></tr><tr><td>  ID </td><td>  # 2 </td><td>  Eine eindeutige ID, die jedem Objekt der <i>Thread-</i> Klasse zugewiesen wird.  ID wird f√ºr Threads im System generiert.  Der Anfangswert ist 1. Jedem neu erstellten Thread wird eine eigene ID zugewiesen, die zuvor um 1 erh√∂ht wurde. Diese schreibgesch√ºtzte Thread-Eigenschaft kann mit der Funktion <i>getId eines</i> Objekts der <i>Thread-</i> Klasse abgerufen werden. </td></tr><tr><td>  Daemon-Status </td><td>  Daemon </td><td>  Die Flagge ist ein Zeichen daf√ºr, dass der Thread ein D√§mon ist.  Wenn es sich um einen D√§mon handelt, wird die Flagge gesetzt.  Beispielsweise ist Thread <i>-0</i> kein Daemon. </td></tr><tr><td>  Priorit√§t </td><td>  Prio = 10 </td><td>  Die numerische Priorit√§t des Java-Streams.  Beachten Sie, dass diese Priorit√§t nicht unbedingt der Priorit√§t des zugeordneten Threads im Betriebssystem entspricht.  Um die Priorit√§t festzulegen, k√∂nnen Sie <br>  Verwenden Sie die <i>setPriority-</i> Methode <i>eines</i> Objekts der Klasse <i>Thread</i> und, um <i>abzurufen</i> <br>  <i>getPriority-</i> Methode. </td></tr><tr><td>  OS-Thread-Priorit√§t </td><td>  os_prio = 2 </td><td>  Priorit√§ts-Thread im Betriebssystem.  Diese Priorit√§t kann von der dem verkn√ºpften Java-Thread zugewiesenen Priorit√§t abweichen. </td></tr><tr><td>  Adresse </td><td>  tid = 0x00000250e4979000 </td><td>  Die Adresse des Java-Streams.  Diese Adresse ist ein Zeiger auf das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">native JNI-</a> Objekt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">(Java Native Interface)</a> der <i>Thread-</i> Klasse (ein C ++ - <i>Thread-</i> Objekt, das √ºber JNI mit dem Java-Thread verbunden ist).  Dieser Wert wird erhalten, indem ein Zeiger darauf geworfen wird <br>  (das C ++ - Objekt, das diesem Java-Thread zugeordnet ist) in Ganzzahl.  Siehe <br>  <a href="">Zeile 879 in hotspot / share / runtime / thread.cpp</a> : <br><pre> st-&gt; print ("tid =" INTPTR_FORMAT "", p2i (this));
</pre><br>  Obwohl der Schl√ºssel f√ºr dieses Objekt ( <i>tid</i> ) wie eine Stream-ID aussehen kann, <br>  Tats√§chlich ist dies die Adresse des mit dem <i>JNI C ++ - Thread</i> verbundenen Objekts, und dies ist nicht der Wert, der <br>  <i>Gibt</i> die <i>getId-</i> Methode des Java- <i>Threads zur√ºck</i> . </td></tr><tr><td>  OS-Thread-ID </td><td>  nid = 0x3c28 </td><td>  Die eindeutige Kennung des Betriebssystem-Threads, an den der Java-Thread gebunden ist. <br>  Dieser Wert wird mit folgendem Code ausgegeben: <br>  <a href="">Zeile 42 in hotspot / share / runtime / osThread.cpp</a> : <br><pre> st-&gt; print ("nid = 0x% x", thread_id ());
</pre><br></td></tr><tr><td>  Status </td><td>  Warten unter der Bedingung </td><td>  Vom Menschen lesbarer Status des aktuellen Threads. <br>  In dieser Zeile werden zus√§tzliche Informationen zum einfachen Status des Streams angezeigt (siehe unten) <br>  wird verwendet, um zu verstehen, was der Thread tun w√ºrde (d. h. ob der Thread versucht hat, eine Sperre zu erhalten <br>  oder darauf warten, dass die Entsperrbedingung erf√ºllt ist). </td></tr><tr><td>  Letzter bekannter Java-Stapelzeiger </td><td>  [0x000000b82a9ff000] </td><td>  Der letzte bekannte Stapelzeiger (SP), der diesem Stream zugeordnet ist. <br>  Dieser Wert wird mit nativem C ++ - Code erhalten, der mit Java-Code unter Verwendung von JNI gemischt wird.  Der Wert wird von der Funktion <i>last_Java_sp () zur√ºckgegeben</i> . <br>  <a href="">Zeile 2886 in hotspot / share / runtime / thread.cpp</a> : <br><pre>   st-&gt; print_cr ("[" INTPTR_FORMAT "]", 
     (intptr_t) last_Java_sp () &amp; ~ right_n_bits (12));
</pre><br>  F√ºr einfache Thread-Dumps sind diese Informationen fast unbrauchbar.  In komplexen F√§llen kann SP jedoch <br>  verwendet werden, um Schl√∂sser zu verfolgen. </td></tr></tbody></table><br><h4>  Stream-Status </h4><br>  Die zweite Zeile ist der aktuelle Status des Streams.  M√∂gliche Stream-Zust√§nde sind in Aufz√§hlung aufgef√ºhrt: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Thread.State</a> : <br><br>  NEU <br>  RUNNABLE <br>  BLOCKIERT <br>  WARTEN <br>  TIMED_WAITING <br>  BEENDET <br><br>  Weitere Informationen finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Dokumentation</a> . <br><br><h4>  Thread-Stack-Trace </h4><br>  Der n√§chste Abschnitt enth√§lt die Stapelverfolgung des Streams zum Zeitpunkt des Dumps.  Diese Stapelverfolgung ist einer Stapelverfolgung sehr √§hnlich, die von einer nicht erfassten Ausnahme ausgel√∂st wird.  Und es enth√§lt die Namen von Klassen und Zeichenfolgen, die zum Zeitpunkt der Erstellung des Dumps ausgef√ºhrt wurden.  Im Fall des Reference Handler-Streams sehen wir nichts Interessantes. <br><br>  Die Thread-02-Thread-Ablaufverfolgung unterscheidet sich jedoch von der Standard-Ablaufverfolgung: <br><br><pre> "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec wartet auf Monitoreintrag [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (auf dem Objektmonitor)
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Gesperrte besitzbare Synchronisierer:
     - Keine
</pre><br>  In der Ablaufverfolgung sehen wir, dass Informationen zur Sperre hinzugef√ºgt wurden.  Dieser Thread erwartet eine Sperre f√ºr das Objekt mit der Adresse 0x00000000894465b0 (Objekttyp java.lang.Object).  Dar√ºber hinaus enth√§lt der Thread selbst die Sperre mit der Adresse 0x00000000894465a0 (auch ein java.lang.Object).  Diese Informationen werden uns sp√§ter f√ºr die Diagnose eines Deadlocks n√ºtzlich sein. <br><br><h4>  Erfasste Synchronisationsprimitive (Ownable Synchronizer) </h4><br>  Der letzte Abschnitt listet die vom Stream erfassten Synchronisationsprimitive auf.  Dies sind Objekte, mit denen Threads synchronisiert werden k√∂nnen, z. B. Sperren. <br><br>  Gem√§√ü der offiziellen Java-Dokumentation ist <strong>Ownable Synchronizer</strong> der Nachkomme von <i>AbstractOwnableSynchronizer</i> (oder seiner Unterklasse), der ausschlie√ülich vom Stream zu Synchronisationszwecken erfasst werden kann. <br><br>  <i>ReentrantLock</i> und <i>Schreibsperre</i> , jedoch nicht die <i>Lesesperre</i> der <i>ReentrantReadWriteLock-</i> Klasse, sind zwei gute Beispiele f√ºr solche "besitzbaren Synchronisierer", die von der Plattform angeboten werden. <br><br>  Weitere Informationen zu diesem Thema finden Sie hier <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Post</a> . <br><br><h4>  JVM-Threads </h4><br>  Der n√§chste Abschnitt des Speicherauszugs enth√§lt Informationen zu technischen JVM-Threads, die nicht Teil der Anwendung sind und Betriebssystem-Threads zugeordnet sind.  Weil  Diese Streams funktionieren au√üerhalb der Anwendung. Sie haben keine Stream-IDs.  Am h√§ufigsten sind dies Garbage Collector-Threads und andere technische JVM-Threads: <br><br><pre> "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 ausf√ºhrbar  
 "GC Thread # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c ausf√ºhrbar  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 ausf√ºhrbar  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 ausf√ºhrbar  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 ausf√ºhrbar  
 "G1 Hauptmarker" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 ausf√ºhrbar  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 ausf√ºhrbar  
 "G1 Refine # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c ausf√ºhrbar  
 "G1 Refine # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 ausf√ºhrbar  
 "G1 Refine # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 ausf√ºhrbar  
 "G1 Refine # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 ausf√ºhrbar  
 "G1 Young RemSet Sampling" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 runnable  
 "VM Periodic Task Thread" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 wartet auf Bedingung
</pre><br><h4>  JNI Global Links </h4><br>  Dieser Abschnitt gibt die Anzahl der globalen Referenzen an, die von der JVM √ºber die JNI verwendet werden.  Diese Links werden vom Garbage Collector nicht bereitgestellt und k√∂nnen unter bestimmten Umst√§nden einen Speicherverlust verursachen. <br><br><pre> Globale JNI-Referenzen: 2
</pre><br>  In den meisten einfachen F√§llen werden diese Informationen nicht verwendet.  Die Bedeutung globaler Referenzen muss jedoch verstanden werden.  Weitere Informationen finden Sie in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Beitrag</a> . <br><br><h4>  Deadlocked Threads </h4><br>  Der letzte Abschnitt enth√§lt Informationen zu gefundenen Deadlocks. <br>  Wenn diese nicht gefunden werden, ist der Abschnitt leer.  Weil  Wir haben speziell eine Anwendung mit Schl√∂ssern entwickelt, in unserem Fall ist dieser Abschnitt.  W√§hrend des Dumpings wurde eine Sperre festgestellt, die folgende Meldung enth√§lt: <br><br><pre> Es wurde ein Deadlock auf Java-Ebene gefunden:
 ===============================
 "Thread-0":
   Warten auf Sperren des Monitors 0x00000250e4982480 (Objekt 0x00000000894465b0, ein java.lang.Object),
   welches von "Thread-1" gehalten wird
 "Thread-1":
   Warten auf Sperren des Monitors 0x00000250e4982380 (Objekt 0x00000000894465a0, ein java.lang.Object),
   welches von "Thread-0" gehalten wird
 Java-Stack-Informationen f√ºr die oben aufgef√ºhrten Threads:
 ================================================== =
 "Thread-0":
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Thread-1":
     bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - Warten auf das Sperren von &lt;0x00000000894465a0&gt; (ein java.lang.Object)
     - gesperrt &lt;0x00000000894465b0&gt; (ein java.lang.Object)
     unter java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 1 Deadlock gefunden.
</pre><br>  Der erste Unterabschnitt beschreibt das Deadlock-Szenario: <br><br>  Thread-0 erwartet, dass der Monitor erfasst werden kann (dies ist ein Zugriff auf den <i>synchronisierten</i> Block <i>(secondResource)</i> in unserer Anwendung). Gleichzeitig h√§lt dieser Thread einen Monitor, der versucht, den Thread-1 zu erfassen (dies <i>greift</i> auf dasselbe Codefragment zu: <i>synchronized (secondResource) )</i> in unserer Bewerbung). <br><br>  Dieses kreisf√∂rmige Schloss wird auch als <strong>Deadlock bezeichnet</strong> .  Im Bild unten <br>  Diese Situation wird in grafischer Form dargestellt: <br><br><img src="https://habrastorage.org/webt/11/yd/kr/11ydkrm0xkbw8aqxb8t71kypskg.png"><br><br>  Im zweiten Unterabschnitt wird die Stapelverfolgung f√ºr beide blockierten Threads angegeben. <br><br>  Mit dieser Stapelverfolgung k√∂nnen wir den Betrieb jedes Threads verfolgen, bis eine Sperre auftritt. <br>  In unserem Fall, wenn wir uns die Zeile ansehen: <br><br>  <i>Bei DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34) sehen</i> wir den Problemteil des Codes: <br><br><pre> printLockedResource (secondResource);
</pre><br>  Diese Zeile ist die erste Zeile des synchronisierten Blocks, die den Grund f√ºr die Sperre darstellt, und gibt an, dass die Synchronisierung auf der zweiten Ressource der Grund f√ºr die gegenseitige Sperre ist.  Um Abhilfe zu schaffen, m√ºssen wir sicherstellen, dass beide Threads dieselbe Synchronisationsreihenfolge f√ºr die Ressourcen resourceA und resourceB haben.  Wenn wir dies tun, kommen wir zu der folgenden Anwendung: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  Diese Anwendung wird ohne Verriegelung beendet, und als Ergebnis erhalten wir die folgende Ausgabe (beachten Sie, dass sich die Adressen der Object-Klasse ge√§ndert haben): <br><br><pre> Thread-0: gesperrte Ressource -&gt; java.lang.Object@1ad895d1
 Thread-0: gesperrte Ressource -&gt; java.lang.Object@6e41d7dd
 Thread-1: gesperrte Ressource -&gt; java.lang.Object@1ad895d1
 Thread-1: gesperrte Ressource -&gt; java.lang.Object@6e41d7dd
</pre><br>  ,   ,   thread dump,           .        (     deadlock-).      ,   . <br><br><h3>    Thread Dump- </h3><br>         . <br><br>   JVM       .         (     ,   ). <br><br>         . <br><br>       - ‚Äî Thread Dump Analyzers (TDAs).    Java thread dump-     - ,     .  ,           . ,        . <br><br>        TDA: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">fastThread</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Spotify TDA</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">IBM Thread and Monitor Dump Analyze for Java</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">irockel TDA</a> </li></ul><br>        .               . <br><br><h4>  Fazit </h4><br> Thread dump- ‚Äî      Java-,       .     ,           . <br><br>        deadlock,    .         .     ,           ‚Äî . <br><br>   ,   Java-     thread dump-.     ,             . <br><br> , thread dump ‚Äî   ¬´ ¬ª   ,        ,      Java-. <br><br> <i>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Java</a>     .       ,        deadlock- .</i> <br><br> <i>      ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427513/">https://habr.com/ru/post/de427513/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427499/index.html">Wor√ºber schreiben sie im technischen Support des Video-Streamers?</a></li>
<li><a href="../de427501/index.html">Seymour Papert: Harter Spa√ü</a></li>
<li><a href="../de427505/index.html">Vermutung des Geistes</a></li>
<li><a href="../de427507/index.html">Seymour Papert: Die k√∂stliche Entdeckung von "Nichts"</a></li>
<li><a href="../de427509/index.html">Webserver: Southbridge Erfahrung und Praxis</a></li>
<li><a href="../de427517/index.html">√úbersicht der interessantesten Joker 2018-Berichte: Version von EastBanc Technologies</a></li>
<li><a href="../de427519/index.html">@Kubernetes Meetup bei Mail.Ru Group: 29. Oktober und immer</a></li>
<li><a href="../de427521/index.html">Durchbruchspreis 2019. Die Gewinner des Milner, Brin und Zuckerberg Science Award werden bekannt gegeben.</a></li>
<li><a href="../de427523/index.html">Absicherungserfolg</a></li>
<li><a href="../de427525/index.html">Intel Core 9th Gen in Zahlen und Benchmarks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>