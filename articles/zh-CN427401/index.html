<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙🏽 📼 🤟🏼 溶解着色器和世界探索 🚣🏾 🤒 🥝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="第1部分：溶出度着色器 
 溶解着色器返回漂亮的效果，而且易于创建和理解； 今天，我们将在Unity Shader Graph中进行制作 ，并在HLSL上进行编写。 

 这是我们将创建的示例： 



 如何运作 
 要创建溶解着色器，我们将必须使用“ Shader Graph”着色器中的Alph...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>溶解着色器和世界探索</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427401/"><h1> 第1部分：溶出度着色器 </h1><br>  <strong>溶解着色器</strong>返回漂亮的效果，而且易于创建和理解； 今天，我们将在<strong>Unity Shader Graph中进行制作</strong> ，并在<strong>HLSL上进行</strong>编写。 <br><br> 这是我们将创建的示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce4/46c/b99/ce446cb9949fdee3ed4b29d121aa1c89.gif"></div><br><br><h1> 如何运作 </h1><br> 要创建<strong>溶解</strong>着色器，我们将必须使用“ Shader Graph”着色器中的<strong>AlphaClipThreshold</strong>值，或使用称为<strong>clip</strong>的HLSL函数。 <br><br> 本质上，我们告诉着色器<strong>不要</strong>基于传递的<strong>纹理</strong>和<strong>值</strong> <strong>来渲染像素</strong> 。 我们需要了解以下内容： <strong>白色部分溶解得更快</strong> 。 <br><a name="habracut"></a><br> 我们将使用以下纹理： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cc/f52/1cd/1ccf521cdd1ba16cdaa45b33ae50fec4.png"></div><br> 您可以创建自己的-直线，三角形，但是任何东西！ 请记住， <strong>白色部分溶解得更快</strong> 。 <br><br> 我使用“云”滤镜在Photoshop中创建了此纹理。 <br><br> 即使您只对Shader Graph感兴趣，而对HLSL也不了解，我仍然建议您阅读本部分，因为这对于了解Unity Shader Graph如何在内部工作非常有用。 <br><br><hr><br><h1>  ls </h1><br> 在HLSL中，我们使用<strong>clip（x）</strong>函数。  <strong>clip（x）</strong>函数丢弃所有值小于<strong>零的</strong>像素。 因此，如果我们调用<strong>clip（-1）</strong> ，我们将确保着色器永远不会渲染此像素。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Microsoft Docs中</a>了解有关<strong>剪辑的</strong>更多信息。 <br><br><h4> 属性 </h4><br> 着色器需要两个属性， <strong>Dissolve Texture</strong>和<strong>Amount</strong> （将指示整个执行过程）。 与其他属性和变量一样，您可以随意调用它们。 <br><br><pre><code class="hljs powershell">Properties { //Your other properties //[<span class="hljs-type"><span class="hljs-type">...</span></span>] //Dissolve shader properties _DissolveTexture(<span class="hljs-string"><span class="hljs-string">"Dissolve Texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _Amount(<span class="hljs-string"><span class="hljs-string">"Amount"</span></span>, Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br> 确保在CGPROGRAM SubShader之后添加以下内容（换句话说，声明变量）： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sampler2D</span></span> _DissolveTexture; <span class="hljs-attribute"><span class="hljs-attribute">half</span></span> _Amount;</code> </pre> <br> 另外，不要忘记。 它们的名称必须与“属性”部分中的名称匹配。 <br><br><h4> 功能介绍 </h4><br> 我们通过采样<strong>溶解</strong>的<strong>纹理</strong>并获取<strong>红色</strong>的<strong>值来</strong>开始“ <strong>表面”</strong>或“ <strong>片段”</strong>功能。  PS我们的纹理以<strong>灰度</strong>存储，即<strong>R</strong> ， <strong>G</strong>和<strong>B</strong>的值相等，您可以<strong>选择任意一个</strong> 。 例如， <strong>白色</strong>为<strong>（1,1,1）</strong> ， <strong>黑色</strong>为<strong>（0,0,0）</strong> 。 <br><br> 在我的示例中，我使用了表面着色器： <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> surf (Input IN, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { half dissolve_value = tex2D(_DissolveTexture, IN.uv_MainTex).r; <span class="hljs-comment"><span class="hljs-comment">//Get how much we have to dissolve based on our dissolve texture clip(dissolve_value - _Amount); //Dissolve! //Your shader body, you can set the Albedo etc. //[...] }</span></span></code> </pre> <br>  <strong>就是这样！</strong> 我们可以将此过程应用于任何现有的着色器，并将其转变为<strong>溶解着色器</strong> ！ <br><br> 这是Unity引擎的标准Surface Shader，已变成<strong>双面</strong> <strong>溶解着色器：</strong> <br><br><pre> <code class="hljs pgsql">Shader "Custom/DissolveSurface" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> //Dissolve properties _DissolveTexture("Dissolve Texutre", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Amount("Amount", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> Cull <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> //Fast way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> turn your material <span class="hljs-type"><span class="hljs-type">double</span></span>-sided CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; //Dissolve properties sampler2D _DissolveTexture; half _Amount; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { //Dissolve <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> half dissolve_value = tex2D(_DissolveTexture, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex).r; clip(dissolve_value - _Amount); //Basic shader <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><hr><br><h1> 着色器图 </h1><br> 如果需要使用Unity <strong>Shader Graph</strong>创建此效果，则必须使用<strong>AlphaClipThreshold</strong>值（其工作原理与HLSL中的<strong>clip（x）</strong>不同）。 在此示例中，我创建了一个PBR着色器。 <br><br>  <strong>AlphaClipThreshold</strong>函数指示着色器丢弃其值小于其<strong>Alpha</strong>值的所有像素。 例如，如果值为<strong>0.3f</strong> ，而我们的alpha值为<strong>0.2f</strong> ，则着色器<strong>将不会渲染</strong>此像素。 可以在<strong>Unity文档中</strong>找到<strong>AlphaClipThreshold</strong>函数： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PBR主节点</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">未点亮的主节点</a> 。 <br><br> 这是我们完成的着色器： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/368/ede/1b9368ede92dad1544f3ca702a2924ad.png"></div><br> 我们对<strong>溶解纹理进行</strong>采样并获得<strong>红色</strong>的<strong>值</strong> ，然后将其添加到<strong>Amount</strong>值（这是我添加以指示整个执行过程的属性，该值1表示完全溶解）并将其连接到<strong>AlphaClipThreshold</strong> 。  <strong>做完了！</strong> <br><br> 如果要将其应用于任何现有的着色器，则只需<strong>将</strong> <strong>节点连接</strong> <strong>复制</strong>到<strong>AlphaClipThreshold</strong> （不要错过必要的属性！）。 您也可以使其<strong>双边，</strong>并获得更漂亮的效果！ <br><br><hr><br><h1> 轮廓溶解着色器 </h1><br> 如果您尝试为其添加<strong>轮廓</strong> ？ 开始吧！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c59/0db/e64/c590dbe64e954bdc6c7ce1154726e80b.gif"></div><br> 我们无法处理已经溶解的像素，因为放下像素后<em>它们会永远消失</em> 。 相反，我们可以使用“几乎已分解”的值！ <br><br> 在<strong>HLSL中，</strong>这非常简单，只需在计算<strong>剪辑</strong>后添加几行代码即可： <br><br><pre> <code class="hljs powershell">void surf (Input <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, inout SurfaceOutputStandard o) { //[<span class="hljs-type"><span class="hljs-type">...</span></span>] //After our clip calculations <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dissolve_value - _Amount &lt; .<span class="hljs-number"><span class="hljs-number">05</span></span>f) //outline width = .<span class="hljs-number"><span class="hljs-number">05</span></span>f o.Emission = fixed3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); //emits white color //Your shader body, you can set the Albedo etc. //[<span class="hljs-type"><span class="hljs-type">...</span></span>] }</code> </pre> <br>  <strong>做完了！</strong> <br><br> 使用<strong>Shader Graph时，</strong>逻辑略有不同。 这是完成的着色器： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e26/288/1ef/e262881ef6ad042856b345ba2d9f2765.png"></div><br><hr><br> 我们可以使用简单的<strong>溶解着色器</strong>创建非常<strong>酷的效果</strong> ； 您可以尝试<strong>不同的纹理</strong>和<strong>值</strong> ，以及其他一些东西！ <br><br><h1> 第2部分：世界探索着色器 </h1><br>  <strong>世界探索</strong>着色器（或“ <strong>世界溶出度着色器</strong> ，或<strong>全局溶出度</strong> ”）使我们能够根据对象到位置的距离相等地隐藏场景中的所有对象；现在，我们将在<strong>Unity Shader Graph中</strong>创建这样的着色<strong>器</strong>并将其写入<strong>HLSL</strong> 。 <br><br> 这是我们将创建的示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/228/7bb/169/2287bb1692d36eae92224f36359648a3.gif"></div><br><hr><br><h2> 距离作为参数 </h2><br> 假设如果场景中<strong>的物体</strong> <strong>离播放器太远，</strong>我们需要将其<strong>溶解</strong> 。 我们已经宣布了<strong>_Amount</strong>参数，该参数控制对象的消失/消失，因此我们需要用对象与播放器之间的距离替换它。 <br><br> 为此，我们需要选择<strong>Player</strong>和<strong>Object</strong>的位置。 <br><br><h3> 球员位置 </h3><br>  <strong>Unity Shader Graph</strong>和<strong>HLSL</strong> <strong>的过程</strong>都相似：我们需要在代码中转移玩家的位置。 <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Updates the _PlayerPos variable in all the shaders //Be aware that the parameter name has to match the one in your shaders or it wont' work Shader.SetGlobalVector("_PlayerPos", transform.position); //"transform" is the transform of the Player }</span></span></code> </pre> <br><hr><br><h2> 着色器图 </h2><br><h4> 物体的位置和距离 </h4><br> 使用明暗器图，我们可以使用位置和距离节点。 <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Position节点的文档</a> 。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">距离节点的文档</a> 。 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b1/cdb/078/7b1cdb078a844a10451317e40a14df7c.png"></div><br>  PS若要使该系统与Sprite Renderers一起使用，您需要添加_MainTex属性，对其进行采样并将其连接到反照率。 您可以阅读我以前的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sprites漫反射着色器</a>教程（使用着色器图）。 <br><br><hr><br><h2>  HLSL（表面） </h2><br><h4> 对象位置 </h4><br> 在HLSL中，我们可以将<strong>worldPos</strong>变量添加到<strong>Input</strong>结构中以获取对象顶点的位置。 <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float3 worldPos; <span class="hljs-comment"><span class="hljs-comment">//add this and Unity will set it automatically };</span></span></code> </pre> <br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Unity文档页面上，</a>您可以找到允许添加到Input结构中的其他内置参数。 <br><br><h4> 应用距离 </h4><br> 我们需要使用物体与玩家之间的距离作为溶解量。 为此，您可以使用内置的<strong>距离</strong>功能（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Microsoft文档</a> ）。 <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> surf (Input IN, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { half dissolve_value = tex2D(_DissolveTexture, IN.uv_MainTex).x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = distance(_PlayerPos, IN.worldPos); clip(dissolve_value - dist/ <span class="hljs-number"><span class="hljs-number">6</span></span>f); <span class="hljs-comment"><span class="hljs-comment">//"6" is the maximum distance where your object will start showing //Set albedo, alpha, smoothness etc[...] }</span></span></code> </pre> <br><h3> 结果（3D） </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/868/f5c/2e8/868f5c2e803708138c71f84c95e3390c.gif"></div><br><h3> 结果（2D） </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/380/e2b/289380e2ba53cbe569621821affc7009.gif"></div><br> 如您所见，对象“局部溶解”，我们没有得到均质效果，因为我们从使用每个对象的UV采样的纹理中获得“溶解值”。  （在2D中，这不太明显）。 <br><br><hr><br><h3>  HLSL上的3D LocalUV Dissolve Shader </h3><br><pre> <code class="hljs pgsql">Shader "Custom/GlobalDissolveSurface" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> _DissolveTexture("Dissolve texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Radius("Distance", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">1</span></span> //distance <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> reveal the objects } SubShader{ Tags { "RenderType" = "Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> Cull <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> //material <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> two sided CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; sampler2D _DissolveTexture; //texture <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the dissolve <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; float3 worldPos; //Built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> world position }; half _Glossiness; half _Metallic; fixed4 _Color; float3 _PlayerPos; //"Global Shader Variable", contains the Player Position <span class="hljs-type"><span class="hljs-type">float</span></span> _Radius; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { half dissolve_value = tex2D(_DissolveTexture, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex).x; <span class="hljs-type"><span class="hljs-type">float</span></span> dist = distance(_PlayerPos, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos); clip(dissolve_value - dist/ _Radius); fixed4 c = tex2D (_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><h3>  Sprites漫反射-HLSL上的LocalUV Dissolve Shader </h3><br><pre> <code class="hljs pgsql">Shader "Custom/GlobalDissolveSprites" { Properties { [PerRendererData] _MainTex("Sprite Texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Color("Tint", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [MaterialToggle] PixelSnap("Pixel snap", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> [HideInInspector] _RendererColor("RendererColor", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [HideInInspector] _Flip("Flip", Vector) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) [PerRendererData] _AlphaTex("External Alpha", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} [PerRendererData] _EnableExternalAlpha("Enable External Alpha", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> _DissolveTexture("Dissolve texture", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Radius("Distance", <span class="hljs-type"><span class="hljs-type">Float</span></span>) = <span class="hljs-number"><span class="hljs-number">1</span></span> //distance <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> reveal the objects } SubShader { Tags { "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" "PreviewType" = "Plane" "CanUseSpriteAtlas" = "True" } Cull <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Lighting <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> ZWrite <span class="hljs-keyword"><span class="hljs-keyword">Off</span></span> Blend One OneMinusSrcAlpha CGPROGRAM #pragma surface surf Lambert vertex:vert nofog nolightmap nodynlightmap keepalpha noinstancing #pragma multi_compile _ PIXELSNAP_ON #pragma multi_compile _ ETC1_EXTERNAL_ALPHA #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> "UnitySprites.cginc" struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; fixed4 color; float3 worldPos; //Built-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> world position }; sampler2D _DissolveTexture; //texture <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> we <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the dissolve <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> float3 _PlayerPos; //"Global Shader Variable", contains the Player Position <span class="hljs-type"><span class="hljs-type">float</span></span> _Radius; <span class="hljs-type"><span class="hljs-type">void</span></span> vert(<span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> appdata_full v, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> o) { v.vertex = UnityFlipSprite(v.vertex, _Flip); #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(PIXELSNAP_ON) v.vertex = UnityPixelSnap(v.vertex); #endif UNITY_INITIALIZE_OUTPUT(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span>, o); o.color = v.color * _Color * _RendererColor; } <span class="hljs-type"><span class="hljs-type">void</span></span> surf(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutput o) { half dissolve_value = tex2D(_DissolveTexture, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex).x; <span class="hljs-type"><span class="hljs-type">float</span></span> dist = distance(_PlayerPos, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos); clip(dissolve_value - dist / _Radius); fixed4 c = SampleSpriteTexture(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Albedo = c.rgb * ca; o.Alpha = ca; } ENDCG } Fallback "Transparent/VertexLit" }</code> </pre> <br>  PS为了创建最后一个着色器，我复制了标准的Unity Sprites-Diffuse着色器，并添加了本文此部分前面所述的“溶解”部分。 所有标准着色器都可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 <br><br><hr><br><h2> 使效果均匀 </h2><br> 为了使效果均匀，我们可以使用全局坐标（在世界上的位置）作为溶解纹理的UV坐标。 在溶出度纹理参数中设置<strong>Wrap = Repeat</strong>也是很重要的，这样我们就可以在不注意到纹理的情况下重复纹理（确保纹理是无缝的并且可以重复！ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7db/b9f/e0e/7dbb9fe0e582bf7a63b2dccfb43a9b9b.png"></div><br><h4>  HLSL（表面） </h4><br><pre> <code class="hljs delphi">half dissolve_value = tex2D(_DissolveTexture, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos / <span class="hljs-number"><span class="hljs-number">4</span></span>).x; <span class="hljs-comment"><span class="hljs-comment">//I modified the worldPos to reduce the texture size</span></span></code> </pre> <br><h4> 着色器图 </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/787/167/9c6/7871679c66cab1c842fe02c5ce523884.png"></div><br><h3> 结果（2D） </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/428/b34/425/428b344254f3e80ef68b63ba8754dfa2.gif"></div><br> 结果就是：我们可以注意到，整个世界的溶解质地现在是一致的。 <br><br> 该着色器已经<strong>非常适合2D游戏</strong> ，但对于<strong>3D对象</strong>则需要<strong>改进</strong> 。 <br><br><h3>  3D对象的问题 </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/231/1f4/09b/2311f409be1ca990c276895eb8e49695.png"></div><br> 如您所见，着色器不适用于“非垂直”面，并极大地扭曲了纹理。 这就是为什么  UV坐标需要值float2，如果我们通过worldPos，则它仅接收X和Y。 <br><br> 如果通过应用计算以在所有面上显示纹理来消除此问题，则会遇到一个新问题：变暗时，对象将彼此相交，并且将不会保持均匀。 <br><br> 对于初学者而言，解决方案将很难理解：必须消除纹理，在世界上产生三维噪声，并从中获得“溶出值”。 在这篇文章中，我不会解释3D噪声的产生，但是您可以找到一堆可以使用的功能！ <br><br> 这是一个噪声着色器示例： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/keijiro/NoiseShader</a> 。 您还可以在以下位置了解如何产生噪音： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//thebookofshaders.com/11/</a>和此处： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> ： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//catlikecoding.com/unity/tutorials/noise/</a> <br><br> 我将以这种方式设置表面功能（假设您已经编写了噪波部分）： <br><br><pre> <code class="hljs powershell">void surf (Input <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, inout SurfaceOutputStandard o) { float dist = distance(_PlayerPos, IN.worldPos); //<span class="hljs-string"><span class="hljs-string">"abs"</span></span> because you have to make sure that the noise is between the range [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] //you can remove <span class="hljs-string"><span class="hljs-string">"abs"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> your noise <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">between</span></span></span><span class="hljs-function"> [</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">0</span></span></span><span class="hljs-function">,</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">1</span></span></span><span class="hljs-function">] //</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">also</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replace</span></span></span><span class="hljs-function"> "</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NOISE_FUNCTION_HERE</span></span></span><span class="hljs-function">" </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">with</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">your</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">3D</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">. </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">half</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dissolve_value</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">abs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NOISE_FUNCTION_HERE(IN.worldPos)</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dist &gt; _Radius)</span></span></span></span> { float clip_value = dissolve_value - ((dist - _Radius) / _Radius); clip(clip_value); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clip_value &lt; <span class="hljs-number"><span class="hljs-number">0.05</span></span>f) o.Emission = float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); } fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br>  HLSL的简要提醒：在使用/调用函数之前，必须先编写/声明函数。 <br><br>  PS如果要使用Unity Shader Graph创建着色器，则需要使用“自定义节点”（并通过在其中写入HLSL代码来产生噪声）。 我将在以后的教程中讨论自定义节点。 <br><br><h3> 结果（3D） </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce6/a89/ad3/ce6a89ad324ff4a03d4bfabf1a694024.gif"></div><br><hr><br><h2> 添加轮廓 </h2><br> 要添加轮廓，您需要从教程的上一部分开始重复该过程。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/228/7bb/169/2287bb1692d36eae92224f36359648a3.gif"></div><br><hr><br><h2> 反作用 </h2><br> 如果我们想扭转这种影响？  （如果玩家在附近，则物体应消失） <br><br> 对于我们来说，更改一行就足够了： <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> dist = _Radius - distance(_PlayerPos, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos);</code> </pre> <br>  （相同的过程适用于Shader Graph）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/579/86c/1f9/57986c1f96a56f1ec478b64c89be3eba.gif"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN427401/">https://habr.com/ru/post/zh-CN427401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN427391/index.html">面向青少年的提示：建立良好的生活习惯</a></li>
<li><a href="../zh-CN427393/index.html">企业无线安全分析</a></li>
<li><a href="../zh-CN427395/index.html">“让我们解释一下：还是数学家程序员为什么要这么做。” 关于如何不错过数学讲座的书</a></li>
<li><a href="../zh-CN427397/index.html">开发用于训练神经网络的声学数据集</a></li>
<li><a href="../zh-CN427399/index.html">在基于GraphQL构建API时使用数据</a></li>
<li><a href="../zh-CN427403/index.html">ReportingObserver API：以新的角度看待网页代码</a></li>
<li><a href="../zh-CN427405/index.html">ES2018-最终承诺方法</a></li>
<li><a href="../zh-CN427407/index.html">误差最小化的元集群，以及为什么我认为大脑以这种方式工作</a></li>
<li><a href="../zh-CN427409/index.html">该书“辉煌的敏捷。 使用敏捷，Scrum和看板的灵活项目管理»</a></li>
<li><a href="../zh-CN427413/index.html">争夺资源，第4部分：太好了</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>