<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛹🏼 🤸🏾 🏄 MVCC in PostgreSQL-1. Isolierung 💇🏽 👩🏽‍🎨 👩🏼‍🤝‍👩🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Mit diesem Artikel beginne ich eine Reihe von Reihen (oder eine Reihe von Mengen? - Mit einem Wort, die Idee ist grandios) über die intern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC in PostgreSQL-1. Isolierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/467437/">  Hallo Habr!  Mit diesem Artikel beginne ich eine Reihe von Reihen (oder eine Reihe von Mengen? - Mit einem Wort, die Idee ist grandios) über die interne Struktur von PostgreSQL. <br><br>  Das Material basiert auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schulungen</a> (auf Russisch) zur Verwaltung, die Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Pluzanov</a> und ich erstellen.  Nicht jeder sieht sich gerne Videos an (das tue ich definitiv nicht), und das Lesen von Folien ist selbst mit Kommentaren überhaupt nicht gut. <br><br><blockquote>  Leider ist der einzige Kurs, der derzeit auf Englisch verfügbar ist, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweitägige Einführung in PostgreSQL 11</a> . <br></blockquote><br>  Natürlich stimmen die Artikel nicht genau mit dem Inhalt der Kurse überein.  Ich werde nur darüber sprechen, wie alles organisiert ist, wobei die Verwaltung selbst weggelassen wird, aber ich werde versuchen, dies detaillierter und gründlicher zu tun.  Und ich glaube, dass dieses Wissen für einen Anwendungsentwickler genauso nützlich ist wie für einen Administrator. <br><br>  Ich werde mich an diejenigen wenden, die bereits Erfahrung mit PostgreSQL haben und zumindest allgemein verstehen, was was ist.  Der Text wird für Anfänger zu schwierig sein.  Zum Beispiel werde ich kein Wort darüber sagen, wie man PostgreSQL installiert und psql ausführt. <br><br>  Das fragliche Zeug variiert nicht viel von Version zu Version, aber ich werde das aktuelle 11. Vanille-PostgreSQL verwenden. <br><br>  Die erste Serie befasst sich mit Problemen im Zusammenhang mit Isolation und Multiversion-Parallelität. Der Plan der Serie lautet wie folgt: <br><br><ol><li>  Isolation im Sinne von Standard und PostgreSQL (dieser Artikel). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabeln, Dateien, Seiten</a> - was auf physischer Ebene passiert. </li><li>  Zeilenversionen, virtuelle Transaktionen und Subtransaktionen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenschnappschüsse</a> und die Sichtbarkeit von Zeilenversionen;  der Ereignishorizont. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In-Page-Vakuum und HOT-Updates</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Normales Vakuum</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autovakuum</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umgehung und Einfrieren der Transaktions-ID</a> . </li></ol><br>  Auf geht's! <br><br><blockquote>  Und bevor wir anfangen, möchte ich Elena Indrupskaya für die Übersetzung der Artikel ins Englische danken. <br></blockquote><br><a name="habracut"></a><br><h1>  Was ist Isolation und warum ist sie wichtig? </h1><br>  Wahrscheinlich ist sich zumindest jeder der Existenz von Transaktionen bewusst, ist auf die Abkürzung ACID gestoßen und hat von Isolationsstufen gehört.  Wir sind jedoch immer noch der Meinung, dass dies die Theorie betrifft, was in der Praxis nicht notwendig ist.  Daher werde ich einige Zeit damit verbringen, zu erklären, warum dies wirklich wichtig ist. <br><br>  Es ist unwahrscheinlich, dass Sie zufrieden sind, wenn eine Anwendung falsche Daten aus der Datenbank erhält oder wenn die Anwendung falsche Daten in die Datenbank schreibt. <br><br>  Aber was sind "richtige" Daten?  Es ist bekannt, dass <em>Integritätsbeschränkungen</em> wie NOT NULL oder UNIQUE auf Datenbankebene erstellt werden können.  Wenn die Daten immer Integritätsbeschränkungen erfüllen (und dies ist so, da das DBMS dies garantiert), sind sie ganzheitlich. <br><br>  Sind <em>richtig</em> und <em>ganzheitlich</em> die gleichen Dinge?  Nicht genau.  Auf Datenbankebene können nicht alle Einschränkungen angegeben werden.  Einige der Einschränkungen sind beispielsweise zu kompliziert und decken mehrere Tabellen gleichzeitig ab.  Und selbst wenn eine Einschränkung im Allgemeinen in der Datenbank hätte definiert werden können, aber aus irgendeinem Grund nicht, bedeutet dies nicht, dass die Einschränkung verletzt werden kann. <br><br>  <em>Korrektheit</em> ist also stärker als <em>Integrität</em> , aber wir wissen nicht genau, was dies bedeutet.  Wir müssen nur zugeben, dass der „Goldstandard“ der Korrektheit eine Anwendung ist, die, wie wir gerne glauben würden, <em>richtig</em> geschrieben ist und niemals falsch läuft.  In jedem Fall, wenn eine Anwendung nicht die Integrität, sondern die Richtigkeit verletzt, weiß das DBMS nichts davon und fängt die Anwendung nicht auf frischer Tat ab. <br><br>  Weiterhin werden wir den Begriff <em>Konsistenz verwenden</em> , um die Korrektheit zu bezeichnen. <br><br>  Nehmen wir jedoch an, dass eine Anwendung nur korrekte Folgen von Operatoren ausführt.  Welche Rolle spielt DBMS, wenn die Anwendung korrekt ist? <br><br>  Erstens stellt sich heraus, dass eine korrekte Folge von Operatoren die Datenkonsistenz vorübergehend beeinträchtigen kann, und seltsamerweise ist dies normal.  Ein abgedroschenes, aber klares Beispiel ist die Überweisung von Geldern von einem Konto auf ein anderes.  Die Konsistenzregel mag folgendermaßen klingen: <em>Eine Überweisung ändert niemals den Gesamtbetrag auf den Konten</em> (diese Regel ist in SQL als Integritätsbedingung nur schwer anzugeben, daher existiert sie auf Anwendungsebene und ist für das DBMS unsichtbar).  Eine Überweisung besteht aus zwei Vorgängen: Der erste reduziert das Guthaben auf einem Konto und der zweite erhöht das Guthaben auf dem anderen.  Die erste Operation unterbricht die Datenkonsistenz, während die zweite die Datenkonsistenz wiederherstellt. <br><br><blockquote>  Eine gute Übung besteht darin, die obige Regel auf der Ebene der Integritätsbeschränkungen zu implementieren. <br></blockquote><br>  Was ist, wenn die erste Operation ausgeführt wird und die zweite nicht?  In der Tat, ohne viel Aufhebens: Während der zweiten Operation kann es zu einem Stromausfall, einem Serverabsturz und einer Division durch Null kommen - was auch immer.  Es ist klar, dass die Konsistenz gebrochen wird, und dies kann nicht zugelassen werden.  Im Allgemeinen ist es möglich, solche Probleme auf Anwendungsebene zu lösen, jedoch auf Kosten enormer Anstrengungen.  Zum Glück ist dies jedoch nicht erforderlich: Dies erfolgt durch das DBMS.  Dazu muss das DBMS jedoch wissen, dass die beiden Operationen ein unteilbares Ganzes sind.  Das heißt, <em>eine Transaktion</em> . <br><br>  Es stellt sich als interessant heraus: Da das DBMS weiß, dass Vorgänge eine Transaktion bilden, trägt es zur Aufrechterhaltung der Konsistenz bei, indem sichergestellt wird, dass die Transaktionen atomar sind, und dies ohne Kenntnis spezifischer Konsistenzregeln. <br><br>  Aber es gibt noch einen zweiten, subtileren Punkt.  Sobald mehrere gleichzeitige Transaktionen im System angezeigt werden, die separat absolut korrekt sind, funktionieren sie möglicherweise nicht richtig zusammen.  Dies liegt daran, dass die Reihenfolge der Vorgänge verwechselt ist: Sie können nicht davon ausgehen, dass alle Vorgänge einer Transaktion zuerst und dann alle Vorgänge der anderen Transaktion ausgeführt werden. <br><br>  Ein Hinweis zur Gleichzeitigkeit.  In der Tat können Transaktionen gleichzeitig auf einem System mit einem Mehrkernprozessor, einem Festplattenarray usw. ausgeführt werden.  Die gleiche Überlegung gilt jedoch für einen Server, der Befehle nacheinander in einem Time-Sharing-Modus ausführt: Während bestimmter Taktzyklen wird eine Transaktion ausgeführt und während der nächsten bestimmten Zyklen die andere.  Manchmal wird der Begriff <em>gleichzeitige</em> Ausführung für eine Verallgemeinerung verwendet. <br><br>  Situationen, in denen korrekte Transaktionen falsch zusammenarbeiten, werden als <em>Anomalien</em> der gleichzeitigen Ausführung bezeichnet. <br><br>  Ein einfaches Beispiel: Wenn eine Anwendung korrekte Daten aus der Datenbank abrufen möchte, darf sie zumindest keine Änderungen anderer nicht festgeschriebener Transaktionen sehen.  Andernfalls können Sie nicht nur inkonsistente Daten abrufen, sondern auch etwas sehen, das noch nie in der Datenbank vorhanden war (wenn die Transaktion abgebrochen wird).  Diese Anomalie wird als <em>Dirty Read bezeichnet</em> . <br><br>  Es gibt andere, komplexere Anomalien, auf die wir später noch eingehen werden. <br><br>  Es ist sicherlich unmöglich, eine gleichzeitige Ausführung zu vermeiden. Ansonsten, von welcher Art von Leistung können wir sprechen?  Sie können aber auch nicht mit falschen Daten arbeiten. <br><br>  Und wieder kommt das DBMS zur Rettung.  Sie können Transaktionen <em>wie</em> nacheinander ausführen, <em>als ob sie</em> nacheinander ausgeführt würden.  Mit anderen Worten - <em>voneinander isoliert</em> .  In der Realität kann das DBMS Operationen durcheinander bringen, aber sicherstellen, dass das Ergebnis einer gleichzeitigen Ausführung mit dem Ergebnis einiger möglicher sequentieller Ausführungen übereinstimmt.  Und das beseitigt mögliche Anomalien. <br><br>  Also kamen wir zu der Definition: <br><br><blockquote>  Eine Transaktion ist eine Reihe von Operationen, die von einer Anwendung ausgeführt werden, die eine Datenbank von einem korrekten Zustand in einen anderen korrekten Zustand überträgt (Konsistenz), vorausgesetzt, die Transaktion ist abgeschlossen (Atomizität) und ohne Störung durch andere Transaktionen (Isolation). <br></blockquote><br>  Diese Definition vereint die ersten drei Buchstaben des Akronyms ACID.  Sie sind so eng miteinander verbunden, dass es keinen Sinn macht, einen ohne den anderen zu betrachten.  Tatsächlich ist es auch schwierig, den Buchstaben D (Haltbarkeit) abzunehmen.  Wenn ein System abstürzt, werden immer noch Änderungen an nicht festgeschriebenen Transaktionen vorgenommen, mit denen Sie etwas tun müssen, um die Datenkonsistenz wiederherzustellen. <br><br>  Alles wäre in Ordnung gewesen, aber die Implementierung einer vollständigen Isolierung ist eine technisch schwierige Aufgabe, die eine Reduzierung des Systemdurchsatzes zur Folge hat.  Daher wird in der Praxis sehr oft (nicht immer, aber fast immer) die geschwächte Isolation verwendet, wodurch einige, aber nicht alle Anomalien verhindert werden.  Dies bedeutet, dass ein Teil der Arbeit zur Sicherstellung der Datenkorrektheit auf die Anwendung fällt.  Aus diesem Grund ist es sehr wichtig zu verstehen, welche Isolationsstufe im System verwendet wird, welche Garantien es gibt und was nicht und wie man unter solchen Bedingungen korrekten Code schreibt. <br><br><h1>  Isolationsstufen und Anomalien im SQL-Standard </h1><br>  Der SQL-Standard hat lange Zeit vier Isolationsstufen beschrieben.  Diese Ebenen werden definiert, indem Anomalien aufgelistet werden, die zulässig oder nicht zulässig sind, wenn Transaktionen gleichzeitig auf dieser Ebene ausgeführt werden.  Um über diese Ebenen zu sprechen, ist es daher notwendig, die Anomalien kennenzulernen. <br><br>  Ich betone, dass es sich in diesem Teil um den Standard handelt, dh um eine Theorie, auf der die Praxis maßgeblich basiert, von der sie aber gleichzeitig erheblich abweicht.  Daher sind alle Beispiele hier spekulativ.  Sie werden die gleichen Operationen auf Kundenkonten anwenden: Dies ist ziemlich demonstrativ, hat jedoch zugegebenermaßen nichts mit der Organisation der Bankoperationen in der Realität zu tun. <br><br><h2>  Verlustaktualisierung </h2><br>  Beginnen wir mit dem <em>verlorenen Update</em> .  Diese Anomalie tritt auf, wenn zwei Transaktionen dieselbe Zeile der Tabelle lesen, dann eine Transaktion diese Zeile aktualisiert und die zweite Transaktion dieselbe Zeile ebenfalls aktualisiert, ohne die durch die erste Transaktion vorgenommenen Änderungen zu berücksichtigen. <br><br>  Beispielsweise erhöhen zwei Transaktionen den Betrag auf demselben Konto um 100 ₽ (₽ ist das Währungszeichen für den russischen Rubel).  Die erste Transaktion liest den aktuellen Wert (~ 1000) und die zweite Transaktion liest den gleichen Wert.  Die erste Transaktion erhöht den Betrag (dies ergibt 001100) und schreibt diesen Wert.  Die zweite Transaktion verhält sich genauso: Sie erhält den gleichen Wert von 001100 und schreibt diesen Wert.  Infolgedessen verlor der Kunde 100.. <br><br>  Der Standard erlaubt keine verlorenen Updates auf irgendeiner Isolationsstufe. <br><br><h2>  Dirty Read und Read Uncommitted </h2><br>  Eine <em>schmutzige Lektüre</em> ist das, was wir bereits kennengelernt haben.  Diese Anomalie tritt auf, wenn eine Transaktion Änderungen liest, die noch nicht von einer anderen Transaktion festgeschrieben wurden. <br><br>  Beispielsweise überträgt die erste Transaktion das gesamte Geld vom Konto des Kunden auf ein anderes Konto, schreibt die Änderung jedoch nicht fest.  Eine andere Transaktion liest den Kontostand, um ₽0 zu erhalten, und weigert sich, dem Kunden Bargeld abzuheben, obwohl die erste Transaktion ihre Änderungen abbricht und zurücksetzt, sodass der Wert 0 nie in der Datenbank vorhanden war. <br><br>  Der Standard erlaubt Dirty Reads auf der Ebene Read Uncommitted. <br><br><h2>  Nicht wiederholbares Lesen und Lesen festgeschrieben </h2><br>  Eine <em>nicht wiederholbare</em> Leseanomalie tritt auf, wenn eine Transaktion dieselbe Zeile zweimal liest und zwischen den Lesevorgängen die zweite Transaktion diese Zeile ändert (oder löscht) und die Änderungen festschreibt.  Dann erhält die erste Transaktion unterschiedliche Ergebnisse. <br><br>  Lassen Sie beispielsweise eine Konsistenzregel <em>negative Beträge auf Kundenkonten verbieten</em> .  Die erste Transaktion wird den Betrag auf dem Konto um 100 ₽ reduzieren.  Es prüft den aktuellen Wert, erhält 1000 und entscheidet, dass die Abnahme möglich ist.  Gleichzeitig reduziert die zweite Transaktion den Betrag auf dem Konto auf Null und schreibt die Änderungen fest.  Wenn die erste Transaktion nun den Betrag erneut prüft, erhält sie ₽0 (aber sie hat bereits beschlossen, den Wert zu reduzieren, und das Konto schreibt rote Zahlen). <br><br>  Der Standard erlaubt nicht wiederholbare Lesevorgänge auf den Ebenen Read Uncommitted und Read Committed.  Read Committed erlaubt jedoch keine Dirty Reads. <br><br><h2>  Phantom Read und Repeatable Read </h2><br>  Ein <em>Phantom-</em> Lesevorgang tritt auf, wenn eine Transaktion einen Satz von Zeilen mit derselben Bedingung zweimal liest und zwischen den Lesevorgängen die zweite Transaktion Zeilen hinzufügt, die diese Bedingung erfüllen (und die Änderungen festschreibt).  Dann erhält die erste Transaktion einen anderen Satz von Zeilen. <br><br>  Lassen Sie beispielsweise eine Konsistenzregel <em>verhindern, dass ein Kunde mehr als 3 Konten hat</em> .  Die erste Transaktion eröffnet ein neues Konto, überprüft die aktuelle Anzahl der Konten (z. B. 2) und entscheidet, dass eine Eröffnung möglich ist.  Gleichzeitig eröffnet die zweite Transaktion ein neues Konto für den Kunden und schreibt die Änderungen fest.  Wenn die erste Transaktion die Nummer erneut überprüft, erhält sie 3 (es wird jedoch bereits ein anderes Konto eröffnet, und der Kunde scheint 4 davon zu haben). <br><br>  Der Standard erlaubt Phantom-Lesevorgänge auf den Ebenen Read Uncommitted, Read Committed und Repeatable Read.  Nicht wiederholbares Lesen ist jedoch auf der Ebene Wiederholbares Lesen nicht zulässig. <br><br><h2>  Das Fehlen von Anomalien und serialisierbar </h2><br>  Der Standard definiert eine weitere Ebene - Serializable -, die keine Anomalien zulässt.  Dies ist nicht dasselbe, um verlorene Updates und schmutzige, nicht wiederholbare oder Phantom-Lesevorgänge zu verbieten. <br><br>  Die Sache ist, dass es viel mehr bekannte Anomalien gibt als im Standard aufgeführt und auch eine unbekannte Anzahl von noch unbekannten. <br><br>  Die serialisierbare Ebene muss <em>absolut alle</em> Anomalien verhindern.  Dies bedeutet, dass ein Anwendungsentwickler auf dieser Ebene nicht über die gleichzeitige Ausführung nachdenken muss.  Wenn Transaktionen eine korrekte Reihenfolge von Operatoren ausführen, die separat arbeiten, sind die Daten auch dann konsistent, wenn diese Transaktionen gleichzeitig ausgeführt werden. <br><br><h2>  Übersichtstabelle </h2><br>  Jetzt können wir eine bekannte Tabelle bereitstellen.  Hier wird jedoch der Klarheit halber die letzte Spalte hinzugefügt, die im Standard fehlt. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Verlorene Änderungen </th><th>  Schmutzige Lektüre </th><th>  Nicht wiederholbares Lesen </th><th>  Phantom gelesen </th><th>  Andere Anomalien </th></tr><tr><th>  Lesen Sie Uncommitted </th><th>  - - </th><th>  Ja </th><th>  Ja </th><th>  Ja </th><th>  Ja </th></tr><tr><th>  Lesen Sie verpflichtet </th><th>  - - </th><th>  - - </th><th>  Ja </th><th>  Ja </th><th>  Ja </th></tr><tr><th>  Wiederholbares Lesen </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  Ja </th><th>  Ja </th></tr><tr><th>  Serialisierbar </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th></tr></tbody></table></div><br><h2>  Warum genau diese Anomalien? </h2><br>  Warum listet der Standard nur einige der vielen möglichen Anomalien auf und warum sind sie genau diese? <br><br>  Niemand scheint es sicher zu wissen.  Aber hier ist die Praxis offensichtlich der Theorie voraus, so dass es möglich ist, dass zu dieser Zeit (nach dem SQL: 92-Standard) nicht nur an andere Anomalien gedacht wurde. <br><br>  Außerdem wurde angenommen, dass die Isolation auf Schlössern aufgebaut sein muss.  Die Idee hinter dem weit verbreiteten <em>Two-Phase Locking-Protokoll</em> (2PL) ist, dass eine Transaktion während der Ausführung die Zeilen sperrt, mit denen sie arbeitet, und die Sperren nach Abschluss aufhebt.  Je mehr Sperren eine Transaktion erwirbt, desto besser ist sie von anderen Transaktionen isoliert.  Die Leistung des Systems leidet jedoch auch stärker, da Transaktionen nicht zusammenarbeiten, sondern für dieselben Zeilen in die Warteschlange gestellt werden. <br><br>  Meiner Meinung nach ist es nur die Anzahl der erforderlichen Sperren, die den Unterschied zwischen den Isolationsstufen des Standards erklärt. <br><br>  Wenn eine Transaktion die zu ändernden Zeilen vom Aktualisieren, aber nicht vom Lesen sperrt, erhalten wir die Stufe "Nicht festgeschrieben lesen": Verlorene Änderungen sind nicht zulässig, aber nicht festgeschriebene Daten können gelesen werden. <br><br>  Wenn eine Transaktion die zu ändernden Zeilen sowohl beim Lesen als auch beim Aktualisieren sperrt, erhalten wir die Stufe "Festgeschrieben": Sie können keine nicht festgeschriebenen Daten lesen, aber Sie können einen anderen Wert (nicht wiederholbares Lesen) erhalten, wenn Sie erneut auf die Zeile zugreifen. <br><br>  Wenn eine Transaktion die zu lesenden und zu ändernden Zeilen sowie das Lesen und Aktualisieren sperrt, erhalten wir die Stufe Wiederholbares Lesen: Beim erneuten Lesen der Zeile wird derselbe Wert zurückgegeben. <br><br>  Bei Serializable gibt es jedoch ein Problem: Sie können eine noch nicht vorhandene Zeile nicht sperren.  Daher ist ein Phantom-Lesevorgang weiterhin möglich: Eine andere Transaktion kann eine Zeile hinzufügen (aber nicht löschen), die die Bedingungen einer zuvor ausgeführten Abfrage erfüllt, und diese Zeile wird in die Neuauswahl einbezogen. <br><br>  Um die Ebene Serializable zu implementieren, reichen normale Sperren daher nicht aus. Sie müssen eher Bedingungen (Prädikate) als Zeilen sperren.  Daher wurden solche Sperren als <em>Prädikat bezeichnet</em> .  Sie wurden 1976 vorgeschlagen, aber ihre praktische Anwendbarkeit wird durch relativ einfache Bedingungen eingeschränkt, für die klar ist, wie zwei verschiedene Prädikate verbunden werden sollen.  Soweit ich weiß, wurden solche Sperren bisher in keinem System implementiert. <br><br><h1>  Isolationsstufen in PostgreSQL </h1><br>  Im Laufe der Zeit wurden sperrbasierte Protokolle des Transaktionsmanagements durch das Snapshot Isolation Protocol (SI) ersetzt.  Die Idee ist, dass jede Transaktion zu einem bestimmten Zeitpunkt mit einem konsistenten Snapshot der Daten arbeitet und nur die Änderungen in den Snapshot übernommen werden, die vor ihrer Erstellung festgeschrieben wurden. <br><br>  Diese Isolierung verhindert automatisch fehlerhafte Lesevorgänge.  Formal können Sie in PostgreSQL die Stufe Read Uncommitted angeben, diese funktioniert jedoch genauso wie Read Committed.  Daher werden wir weiter überhaupt nicht über die Stufe "Uncommitted lesen" sprechen. <br><br>  PostgreSQL implementiert eine <em>Multiversionsvariante</em> dieses Protokolls.  Die Idee der Multiversion-Parallelität besteht darin, dass mehrere Versionen derselben Zeile in einem DBMS nebeneinander existieren können.  Auf diese Weise können Sie mit vorhandenen Versionen einen Snapshot der Daten erstellen und ein Minimum an Sperren verwenden.  Tatsächlich werden nur nachfolgende Änderungen an derselben Zeile gesperrt.  Alle anderen Vorgänge werden gleichzeitig ausgeführt: Schreibtransaktionen sperren niemals schreibgeschützte Transaktionen, und schreibgeschützte Transaktionen sperren niemals etwas. <br><br>  Durch die Verwendung von Datenschnappschüssen ist die Isolation in PostgreSQL strenger als vom Standard gefordert: Die Stufe Wiederholbares Lesen erlaubt nicht nur nicht wiederholbare Lesevorgänge, sondern auch Phantomlesevorgänge (obwohl sie keine vollständige Isolation bietet).  Und das ohne Effizienzverlust. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Verlorene Änderungen </th><th>  Schmutzige Lektüre </th><th>  Nicht wiederholbares Lesen </th><th>  Phantom gelesen </th><th>  Andere Anomalien </th></tr><tr><th>  Lesen Sie Uncommitted </th><th>  - - </th><th>  - - </th><th>  Ja </th><th>  Ja </th><th>  Ja </th></tr><tr><th>  Lesen Sie verpflichtet </th><th>  - - </th><th>  - - </th><th>  Ja </th><th>  Ja </th><th>  Ja </th></tr><tr><th>  Wiederholbares Lesen </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  Ja </th></tr><tr><th>  Serialisierbar </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th></tr></tbody></table></div><br>  In den nächsten Artikeln werden wir darüber sprechen, wie Multiversion-Parallelität „unter der Haube“ implementiert wird, und jetzt werden wir jede der drei Ebenen mit dem Auge eines Benutzers im Detail betrachten (wie Sie wissen, verbirgt sich das Interessanteste hinter „anderen Anomalien“ ”).  Dazu erstellen wir eine Kontenliste.  Alice und Bob haben jeweils 1000 Euro, aber Bob hat zwei eröffnete Konten: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Lesen Sie verpflichtet </h2><br><h3>  Das Fehlen von Dirty Read </h3><br>  Es ist einfach sicherzustellen, dass schmutzige Daten nicht gelesen werden können.  Wir starten die Transaktion.  Standardmäßig wird die Isolationsstufe Read Committed verwendet: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  Genauer gesagt wird die Standardstufe durch den Parameter festgelegt, der bei Bedarf geändert werden kann: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Bei einer offenen Transaktion ziehen wir also Geld vom Konto ab, übernehmen jedoch keine Änderungen.  Die Transaktion sieht ihre eigenen Änderungen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  In der zweiten Sitzung starten wir eine weitere Transaktion mit derselben Read Committed-Ebene.  Zur Unterscheidung zwischen den Transaktionen werden Befehle der zweiten Transaktion eingerückt und mit einem Balken markiert. <br><br>  Um die obigen Befehle zu wiederholen (was nützlich ist), müssen Sie zwei Terminals öffnen und jeweils psql ausführen.  Im ersten Terminal können Sie die Befehle einer Transaktion eingeben und im zweiten die Befehle der anderen. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Wie erwartet werden bei der anderen Transaktion keine nicht festgeschriebenen Änderungen angezeigt, da Dirty Reads nicht zulässig sind. <br><br><h3>  Nicht wiederholbares Lesen </h3><br>  Lassen Sie nun die erste Transaktion die Änderungen festschreiben und die zweite dieselbe Abfrage erneut ausführen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Die Abfrage erhält bereits neue Daten - und dies ist die <em>nicht wiederholbare</em> Leseanomalie, die auf der Ebene Read Committed zulässig ist. <br><br>  <em>Praktische Schlussfolgerung</em> : In einer Transaktion können Sie keine Entscheidungen treffen, die auf Daten basieren, die von einem vorherigen Operator gelesen wurden, da sich die Dinge zwischen der Ausführung der Operatoren ändern können.  Hier ist ein Beispiel, dessen Variationen im Anwendungscode so häufig auftreten, dass es als klassisches Antimuster betrachtet wird: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  Während der Zeit zwischen Überprüfung und Aktualisierung können andere Transaktionen den Status des Kontos auf irgendeine Weise ändern, sodass eine solche „Überprüfung“ vor nichts schützt.  Es ist zweckmäßig, sich vorzustellen, dass zwischen den Betreibern einer Transaktion alle anderen Betreiber anderer Transaktionen beispielsweise wie folgt „keilen“ können: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Wenn durch die Neuanordnung der Operatoren alles verdorben werden kann, ist der Code falsch geschrieben.  Und täuschen Sie sich nicht, dass ein solcher Zufall nicht passieren wird - das wird es mit Sicherheit. <br><br>  Aber wie schreibt man Code richtig?  Die Optionen sind in der Regel wie folgt: <br><br><ul><li>  Code nicht schreiben. <br>  Das ist kein Scherz.  In diesem Fall wird das Überprüfen beispielsweise leicht zu einer Integritätsbeschränkung: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  Jetzt sind keine Überprüfungen erforderlich: Führen Sie einfach den Vorgang aus und behandeln Sie gegebenenfalls die Ausnahme, die auftritt, wenn eine Integritätsverletzung versucht wird. <br></li><li>  So verwenden Sie eine einzelne SQL-Anweisung <br>  Konsistenzprobleme treten auf, da im Zeitintervall zwischen Operatoren eine andere Transaktion abgeschlossen werden kann, wodurch die sichtbaren Daten geändert werden.  Und wenn es einen Operator gibt, gibt es keine Zeitintervalle. <br>  PostgreSQL verfügt über genügend Techniken, um komplexe Probleme mit einer SQL-Anweisung zu lösen.  Beachten Sie die allgemeinen Tabellenausdrücke (CTE), in denen Sie unter anderem die Anweisungen INSERT / UPDATE / DELETE sowie die Anweisung INSERT ON CONFLICT verwenden können, die die Logik von „insert, aber wenn die Zeile bereits vorhanden ist, implementiert. update ”in einer Anweisung. <br></li><li>  Benutzerdefinierte Schlösser. <br>  Der letzte Ausweg besteht darin, manuell eine exklusive Sperre für alle erforderlichen Zeilen (SELECT FOR UPDATE) oder sogar für die gesamte Tabelle (LOCK TABLE) festzulegen.  Dies funktioniert immer, macht jedoch die Vorteile der Multiversions-Parallelität zunichte: Einige Vorgänge werden nacheinander anstelle der gleichzeitigen Ausführung ausgeführt. <br></li></ul><br><h3>  Inkonsistentes Lesen </h3><br>  Bevor Sie zur nächsten Stufe der Isolation übergehen, müssen Sie zugeben, dass dies nicht alles so einfach ist, wie es sich anhört.  Die Implementierung von PostgreSQL ist so, dass andere, weniger bekannte Anomalien berücksichtigt werden, die nicht durch den Standard geregelt werden. <br><br>  Nehmen wir an, dass die erste Transaktion den Geldtransfer von einem Bob-Konto auf das andere gestartet hat: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Gleichzeitig zählt eine andere Transaktion den Kontostand von Bob und die Berechnung wird in einer Schleife über alle Konten von Bob durchgeführt.  Tatsächlich beginnt die Transaktion mit dem ersten Konto (und sieht offensichtlich den vorherigen Status): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  Zu diesem Zeitpunkt wird die erste Transaktion erfolgreich abgeschlossen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Und der andere liest den Status des zweiten Kontos (und sieht bereits den neuen Wert): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Daher erhielt die zweite Transaktion insgesamt 1100 GBP, dh falsche Daten.  Und dies ist eine <em>inkonsistente</em> Leseanomalie. <br><br>  Wie vermeide ich eine solche Anomalie, während ich auf der Stufe "Read Committed" bleibe?  Verwenden Sie natürlich einen Operator.  Zum Beispiel: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  Bis hierher habe ich behauptet, dass sich die Sichtbarkeit von Daten nur zwischen Operatoren ändern kann, aber ist das so offensichtlich?  Und wenn die Abfrage lange dauert, kann sie einen Teil der Daten in einem Zustand und einen Teil in einem anderen sehen? <br><br>  Lassen Sie uns überprüfen.  Eine bequeme Möglichkeit, dies zu tun, besteht darin, eine erzwungene Verzögerung in den Operator einzufügen, indem die Funktion pg_sleep aufgerufen wird.  Sein Parameter gibt die Verzögerungszeit in Sekunden an. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Während dieser Operator ausgeführt wird, überweisen wir das Geld in einer anderen Transaktion zurück: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Das Ergebnis zeigt, dass der Bediener die Daten in dem Zustand sieht, den sie zum Zeitpunkt des Starts der Ausführung des Bedieners hatten.  Dies ist zweifellos richtig. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Aber so einfach ist es auch hier nicht.  Mit PostgreSQL können Sie Funktionen definieren, und Funktionen haben das Konzept einer <em>Volatilitätskategorie</em> .  Wenn eine VOLATILE-Funktion in einer Abfrage aufgerufen wird und eine andere Abfrage in dieser Funktion ausgeführt wird, werden in der Abfrage innerhalb der Funktion Daten angezeigt, die nicht mit den Daten in der Hauptabfrage übereinstimmen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  In diesem Fall erhalten wir falsche Daten - 100 gehen verloren: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Ich betone, dass dieser Effekt nur auf der Isolationsstufe Read Committed und nur mit den VOLATILE-Funktionen möglich ist.  Das Problem ist, dass standardmäßig genau diese Isolationsstufe und diese Volatilitätskategorie verwendet werden.  Fallen Sie nicht in die Falle! <br><br><h3>  Inkonsistentes Lesen im Austausch für verlorene Änderungen </h3><br>  Wir können während eines Updates auch einen inkonsistenten Lesevorgang innerhalb eines einzelnen Operators erhalten, wenn auch auf etwas unerwartete Weise. <br><br>  Mal sehen, was passiert, wenn zwei Transaktionen versuchen, dieselbe Zeile zu ändern.  Jetzt hat Bob 1000 Euro auf zwei Konten: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Wir starten eine Transaktion, die Bobs Guthaben reduziert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Gleichzeitig fallen bei einer anderen Transaktion Zinsen auf alle Kundenkonten mit einem Gesamtguthaben von mindestens 1.000 GBP an: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  Die Ausführung des UPDATE-Operators besteht aus zwei Teilen.  Zunächst wird tatsächlich SELECT ausgeführt, wodurch die zu aktualisierenden Zeilen ausgewählt werden, die die entsprechende Bedingung erfüllen.  Da die Änderung in der ersten Transaktion nicht festgeschrieben wird, kann die zweite Transaktion sie nicht sehen, und die Änderung wirkt sich nicht auf die Auswahl der Zeilen für die Zinsabgrenzung aus.  Nun, dann erfüllen Bobs Konten die Bedingung und sobald das Update ausgeführt wird, sollte sich sein Kontostand um ₽10 erhöhen. <br><br>  In der zweiten Phase der Ausführung werden die ausgewählten Zeilen einzeln aktualisiert.  Hier wird die zweite Transaktion zum "Hängen" gezwungen, da die Zeile mit id = 3 bereits von der ersten Transaktion gesperrt ist. <br><br>  In der Zwischenzeit werden bei der ersten Transaktion die Änderungen festgeschrieben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Was wird das Ergebnis sein? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  Einerseits sollte der UPDATE-Befehl die Änderungen der zweiten Transaktion nicht sehen.  Andererseits sollte es die in der zweiten Transaktion festgeschriebenen Änderungen nicht verlieren. <br><br>  Sobald die Sperre aufgehoben ist, liest UPDATE die Zeile, die aktualisiert werden soll, erneut (jedoch nur diese).  Infolgedessen sammelte Bob 9., Basierend auf dem Betrag von 900..  Aber wenn Bob 900 Euro gehabt hätte, wären seine Konten überhaupt nicht in der Auswahl gewesen. <br><br>  Die Transaktion erhält also falsche Daten: Einige der Zeilen sind zu einem bestimmten Zeitpunkt sichtbar, andere zu einem anderen.  Anstelle eines verlorenen Updates erhalten wir erneut die Anomalie des <em>inkonsistenten Lesens</em> . <br><br><blockquote>  Aufmerksame Leser bemerken, dass Sie mit Hilfe der Anwendung ein verlorenes Update erhalten können, selbst auf der Ebene von Read Committed.  Zum Beispiel: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Die Datenbank ist nicht schuld: Sie erhält zwei SQL-Anweisungen und weiß nichts darüber, dass der Wert von x + 100 in irgendeiner Weise mit dem Kontobetrag zusammenhängt.  Vermeiden Sie es, Code auf diese Weise zu schreiben. <br></blockquote><br><h2>  Wiederholbares Lesen </h2><br><h3>  Das Fehlen von nicht wiederholbaren und Phantom-Lesevorgängen </h3><br>  Der Name der Isolationsstufe setzt voraus, dass das Lesen wiederholbar ist.  Lassen Sie es uns überprüfen und gleichzeitig sicherstellen, dass keine Phantom-Lesevorgänge vorhanden sind.  Zu diesem Zweck setzen wir in der ersten Transaktion die Konten von Bob auf den vorherigen Status zurück und erstellen ein neues Konto für Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  In der zweiten Sitzung starten wir die Transaktion mit der Ebene Wiederholbares Lesen, indem wir sie im Befehl BEGIN angeben (die Ebene der ersten Transaktion ist unwesentlich). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  Jetzt schreibt die erste Transaktion die Änderungen fest und die zweite führt dieselbe Abfrage erneut aus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Die zweite Transaktion sieht immer noch genau die gleichen Daten wie zu Beginn: Es sind keine Änderungen an vorhandenen oder neuen Zeilen sichtbar. <br><br>  Auf dieser Ebene können Sie vermeiden, sich über Dinge Gedanken zu machen, die sich zwischen zwei Operatoren ändern können. <br><br><h3>  Serialisierungsfehler im Austausch für verlorene Änderungen </h3><br>  Wir haben bereits erwähnt, dass beim Aktualisieren derselben Zeile auf Read-Committed-Ebene durch zwei Transaktionen eine Anomalie des inkonsistenten Lesens auftreten kann.  Dies liegt daran, dass die wartende Transaktion die gesperrte Zeile erneut liest und sie daher nicht zum gleichen Zeitpunkt wie die anderen Zeilen sieht. <br><br>  Auf der Ebene "Wiederholbares Lesen" ist diese Anomalie nicht zulässig. In diesem Fall kann jedoch nichts unternommen werden. Die Transaktion wird daher mit einem Serialisierungsfehler beendet.  Überprüfen wir dies, indem wir dasselbe Szenario mit Zinsabgrenzung wiederholen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>;&lt;span/&gt; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span>&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>&lt;span/&gt; | );&lt;span/&gt;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Die Daten blieben konsistent: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  Der gleiche Fehler tritt bei jeder anderen Wettbewerbsänderung einer Zeile auf, selbst wenn die Spalten unseres Anliegens nicht tatsächlich geändert wurden. <br><br>  <em>Praktische Schlussfolgerung</em> : Wenn Ihre Anwendung die Isolationsstufe Wiederholbares Lesen für Schreibtransaktionen verwendet, muss sie bereit sein, Transaktionen zu wiederholen, die mit einem Serialisierungsfehler beendet wurden.  Bei schreibgeschützten Transaktionen ist dieses Ergebnis nicht möglich. <br><br><h3>  Inkonsistentes Schreiben </h3><br>  In PostgreSQL werden auf der Isolationsstufe "Wiederholbares Lesen" alle im Standard beschriebenen Anomalien verhindert.  Aber nicht alle Anomalien im Allgemeinen.  Es stellt sich heraus, dass <em>genau zwei</em> Anomalien noch möglich sind.  (Dies gilt nicht nur für PostgreSQL, sondern auch für andere Implementierungen von Snapshot Isolation.) <br><br>  Die erste dieser Anomalien ist ein <em>inkonsistentes Schreiben</em> . <br><br>  Es gilt die folgende Konsistenzregel: <em>Negative Beträge auf Kundenkonten sind zulässig, wenn der Gesamtbetrag auf allen Konten dieses Kunden nicht negativ bleibt</em> . <br><br>  Die erste Transaktion erhält den Betrag auf Bobs Konten: :900. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  Die zweite Transaktion erhält den gleichen Betrag. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  Die erste Transaktion geht zu Recht davon aus, dass der Betrag eines der Konten um 600 GBP reduziert werden kann. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Und die zweite Transaktion kommt zu dem gleichen Ergebnis.  Aber es reduziert ein anderes Konto: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Wir haben es geschafft, Bobs Saldo in die roten Zahlen zu bringen, obwohl jede Transaktion alleine korrekt funktioniert. <br><br><h3>  Schreibgeschützte Transaktionsanomalie </h3><br>  Dies ist die zweite und letzte der Anomalien, die auf der Ebene des wiederholbaren Lesens möglich sind.  Um dies zu demonstrieren, benötigen Sie drei Transaktionen, von denen zwei die Daten ändern und die dritte sie nur liest. <br><br>  Aber lassen Sie uns zuerst den Status von Bobs Konten wiederherstellen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  Bei der ersten Transaktion fallen Zinsen auf den auf allen Bob-Konten verfügbaren Betrag an.  Die Zinsen werden einem seiner Konten gutgeschrieben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Dann zieht eine andere Transaktion Geld von einem anderen Bob-Konto ab und schreibt seine Änderungen fest: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Wenn die erste Transaktion zu diesem Zeitpunkt festgeschrieben wird, tritt keine Anomalie auf: Wir können davon ausgehen, dass die erste Transaktion zuerst und dann die zweite ausgeführt wurde (aber nicht umgekehrt, da bei der ersten Transaktion zuvor der Status des Kontos mit der ID = 3 angezeigt wurde Konto wurde durch die zweite Transaktion geändert). <br><br>  Stellen Sie sich jedoch vor, dass zu diesem Zeitpunkt die dritte (schreibgeschützte) Transaktion beginnt, die den Status eines Kontos liest, das von den ersten beiden Transaktionen nicht betroffen ist: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  Und erst danach ist die erste Transaktion abgeschlossen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Welchen Status sollte die dritte Transaktion jetzt sehen? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Nach dem Start konnte die dritte Transaktion die Änderungen der zweiten Transaktion (die bereits festgeschrieben wurde) sehen, jedoch nicht der ersten Transaktion (die noch nicht festgeschrieben worden war).  Andererseits haben wir oben bereits festgestellt, dass die zweite Transaktion nach der ersten als gestartet betrachtet werden sollte.  Welchen Status die dritte Transaktion sieht, ist inkonsistent - dies ist nur die Anomalie einer schreibgeschützten Transaktion.  Auf der Ebene Wiederholbares Lesen ist jedoch Folgendes zulässig: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  Serialisierbar </h2><br>  Die Stufe Serializable verhindert alle möglichen Anomalien.  Tatsächlich basiert Serializable auf der Snapshot-Isolation.  Die Anomalien, die beim wiederholbaren Lesen nicht auftreten (z. B. ein fehlerhafter, nicht wiederholbarer oder Phantom-Lesevorgang), treten auch auf der Ebene der Serialisierbarkeit nicht auf.  Und die auftretenden Anomalien (ein inkonsistentes Schreiben und eine schreibgeschützte Transaktionsanomalie) werden erkannt und die Transaktion wird abgebrochen - ein bekannter Serialisierungsfehler tritt auf: Der <em>Zugriff konnte nicht serialisiert werden</em> . <br><br><h3>  Inkonsistentes Schreiben </h3><br>  Um dies zu veranschaulichen, wiederholen wir das Szenario mit einer inkonsistenten Schreibanomalie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  Genau wie auf der Ebene "Wiederholbares Lesen" muss eine Anwendung, die die Isolationsstufe "Serialisierbar" verwendet, Transaktionen wiederholen, die mit einem Serialisierungsfehler beendet wurden, wie die Fehlermeldung uns auffordert. <br><br>  Die Programmierung wird einfacher, aber der Preis dafür ist die erzwungene Beendigung eines Teils der Transaktionen und die Notwendigkeit, diese zu wiederholen.  Die Frage ist natürlich, wie groß dieser Anteil ist.  Wenn nur die Transaktionen beendet worden wären, die sich nicht mit anderen Transaktionen überschneiden, wäre es schön gewesen.  Eine solche Implementierung wäre jedoch zwangsläufig ressourcenintensiv und ineffizient, da Sie die Vorgänge in jeder Zeile verfolgen müssten. <br><br>  Tatsächlich ist die Implementierung von PostgreSQL so, dass sie falsche Negative zulässt: Einige absolut normale Transaktionen, die nur "unglücklich" sind, werden ebenfalls abgebrochen.  Wie wir später sehen werden, hängt dies von vielen Faktoren ab, wie der Verfügbarkeit geeigneter Indizes oder der verfügbaren RAM-Größe.  Darüber hinaus gibt es einige andere (ziemlich schwerwiegende) Implementierungsbeschränkungen, z. B. funktionieren Abfragen auf der Ebene der Serialisierbarkeit nicht für Replikate und sie verwenden keine parallelen Ausführungspläne.  Obwohl die Arbeiten zur Verbesserung der Implementierung fortgesetzt werden, machen die bestehenden Einschränkungen diese Isolationsstufe weniger attraktiv. <br><blockquote>  Parallele Pläne werden bereits in PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigt</a> .  Abfragen zu Replikaten können in PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem weiteren Patch</a> ) ausgeführt werden. <br></blockquote><br><h3>  Schreibgeschützte Transaktionsanomalie </h3><br>  Damit eine schreibgeschützte Transaktion nicht zu einer Anomalie führt und nicht darunter leidet, bietet PostgreSQL eine interessante Technik: Eine solche Transaktion kann gesperrt werden, bis ihre Ausführung sicher ist.  Dies ist der einzige Fall, in dem ein SELECT-Operator durch Zeilenaktualisierungen gesperrt werden kann.  So sieht das aus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Die dritte Transaktion wird ausdrücklich als READ ONLY und DEFERRABLE deklariert: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Beim Versuch, die Abfrage auszuführen, wird die Transaktion gesperrt, da dies sonst zu einer Anomalie führen würde. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Und erst nachdem die erste Transaktion festgeschrieben wurde, setzt die dritte die Ausführung fort: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Ein weiterer wichtiger Hinweis: Wenn die serialisierbare Isolation verwendet wird, müssen alle Transaktionen in der Anwendung diese Ebene verwenden.  Sie können Read-Committed- (oder Repeatable Read-) Transaktionen nicht mit Serializable mischen.  Das heißt, Sie <em>können</em> mischen, aber dann verhält sich Serializable wie "Repeatable Read" ohne Warnungen.  Wir werden später diskutieren, warum dies passiert, wenn wir über die Implementierung sprechen. <br><br>  Wenn Sie sich also für die Verwendung von Serializble entscheiden, ist es am besten, die Standardstufe global festzulegen (obwohl dies Sie natürlich nicht daran hindert, explizit eine falsche Stufe anzugeben): <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote>  Eine genauere Darstellung der Probleme im Zusammenhang mit Transaktionen, Konsistenz und Anomalien finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlesungskurs</a> von Boris Novikov „Grundlagen der Datenbanktechnologien“ (nur in Russion verfügbar). <br></blockquote><br><h1>  Welche Isolationsstufe soll verwendet werden? </h1><br>  Die Read Committed-Isolationsstufe wird in PostgreSQL standardmäßig verwendet, und es ist wahrscheinlich, dass diese Stufe in der überwiegenden Mehrheit der Anwendungen verwendet wird.  Diese Standardeinstellung ist praktisch, da auf dieser Ebene ein Transaktionsabbruch nur im Fehlerfall möglich ist, jedoch nicht, um Inkonsistenzen zu vermeiden.  Mit anderen Worten, ein Serialisierungsfehler kann nicht auftreten. <br><br>  Die andere Seite der Medaille ist eine große Anzahl möglicher Anomalien, die oben ausführlich diskutiert wurden.  Der Softwareentwickler muss sie immer im Auge behalten und Code schreiben, damit sie nicht angezeigt werden.  Wenn Sie die erforderlichen Aktionen nicht in einer einzelnen SQL-Anweisung codieren können, müssen Sie auf explizite Sperren zurückgreifen.  Am problematischsten ist, dass es schwierig ist, Code auf Fehler zu testen, die mit dem Abrufen inkonsistenter Daten verbunden sind. Die Fehler selbst können auf unvorhersehbare und nicht reproduzierbare Weise auftreten und sind daher schwer zu beheben. <br><br>  Die Isolationsstufe "Wiederholbares Lesen" beseitigt einige der Inkonsistenzprobleme, aber leider nicht alle.  Daher müssen Sie sich nicht nur an die verbleibenden Anomalien erinnern, sondern auch die Anwendung so ändern, dass Serialisierungsfehler korrekt behandelt werden.  Es ist sicherlich unpraktisch.  Bei schreibgeschützten Transaktionen ergänzt diese Ebene jedoch perfekt Read Committed und ist beispielsweise sehr praktisch, um Berichte zu erstellen, die mehrere SQL-Abfragen verwenden. <br><br>  Schließlich können Sie sich auf der Ebene Serializable keine Gedanken über Inkonsistenzen machen, was die Codierung erheblich erleichtert.  Das einzige, was von der Anwendung benötigt wird, ist die Möglichkeit, jede Transaktion zu wiederholen, wenn ein Serialisierungsfehler auftritt.  Der Anteil abgebrochener Transaktionen, der zusätzliche Overhead und die Unfähigkeit, Abfragen zu parallelisieren, können den Systemdurchsatz jedoch erheblich reduzieren.  Beachten Sie außerdem, dass die serialisierbare Ebene nicht auf Replikate anwendbar ist und nicht mit anderen Isolationsstufen gemischt werden kann. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467437/">https://habr.com/ru/post/de467437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467423/index.html">Xamarin.Forms - bequeme Verwendung von Symbolschriftarten in der Anwendung</a></li>
<li><a href="../de467425/index.html">STEM Intensive Learning Approach</a></li>
<li><a href="../de467427/index.html">BudgetTracker - ein weiteres Open-Source-Tool für die persönliche Finanzbuchhaltung</a></li>
<li><a href="../de467429/index.html">Habrastatistik: Erkundung der am meisten und am wenigsten besuchten Abschnitte der Website</a></li>
<li><a href="../de467435/index.html">Wir senden Berichte von Veeam Agent Linux per Post oder per Telegramm</a></li>
<li><a href="../de467439/index.html">Warum ist Vinyl zurückgekommen und wie hängen Streaming-Dienste damit zusammen?</a></li>
<li><a href="../de467443/index.html">Multimedia Center "Kodi" und Yocto Project</a></li>
<li><a href="../de467445/index.html">Schwer fassbare Liste der installierten Windows-Updates</a></li>
<li><a href="../de467449/index.html">Erkennung von Schwachstellen und Bewertung der Resistenz gegen Hackerangriffe von Smartcards und Kryptoprozessoren mit integriertem Schutz</a></li>
<li><a href="../de467453/index.html">Lösung des Problems der Nummer 42 mit einem planetaren Supercomputer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>