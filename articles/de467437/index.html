<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õπüèº ü§∏üèæ üèÑ MVCC in PostgreSQL-1. Isolierung üíáüèΩ üë©üèΩ‚Äçüé® üë©üèº‚Äçü§ù‚Äçüë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Mit diesem Artikel beginne ich eine Reihe von Reihen (oder eine Reihe von Mengen? - Mit einem Wort, die Idee ist grandios) √ºber die intern...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC in PostgreSQL-1. Isolierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/467437/">  Hallo Habr!  Mit diesem Artikel beginne ich eine Reihe von Reihen (oder eine Reihe von Mengen? - Mit einem Wort, die Idee ist grandios) √ºber die interne Struktur von PostgreSQL. <br><br>  Das Material basiert auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schulungen</a> (auf Russisch) zur Verwaltung, die Pavel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Pluzanov</a> und ich erstellen.  Nicht jeder sieht sich gerne Videos an (das tue ich definitiv nicht), und das Lesen von Folien ist selbst mit Kommentaren √ºberhaupt nicht gut. <br><br><blockquote>  Leider ist der einzige Kurs, der derzeit auf Englisch verf√ºgbar ist, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweit√§gige Einf√ºhrung in PostgreSQL 11</a> . <br></blockquote><br>  Nat√ºrlich stimmen die Artikel nicht genau mit dem Inhalt der Kurse √ºberein.  Ich werde nur dar√ºber sprechen, wie alles organisiert ist, wobei die Verwaltung selbst weggelassen wird, aber ich werde versuchen, dies detaillierter und gr√ºndlicher zu tun.  Und ich glaube, dass dieses Wissen f√ºr einen Anwendungsentwickler genauso n√ºtzlich ist wie f√ºr einen Administrator. <br><br>  Ich werde mich an diejenigen wenden, die bereits Erfahrung mit PostgreSQL haben und zumindest allgemein verstehen, was was ist.  Der Text wird f√ºr Anf√§nger zu schwierig sein.  Zum Beispiel werde ich kein Wort dar√ºber sagen, wie man PostgreSQL installiert und psql ausf√ºhrt. <br><br>  Das fragliche Zeug variiert nicht viel von Version zu Version, aber ich werde das aktuelle 11. Vanille-PostgreSQL verwenden. <br><br>  Die erste Serie befasst sich mit Problemen im Zusammenhang mit Isolation und Multiversion-Parallelit√§t. Der Plan der Serie lautet wie folgt: <br><br><ol><li>  Isolation im Sinne von Standard und PostgreSQL (dieser Artikel). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gabeln, Dateien, Seiten</a> - was auf physischer Ebene passiert. </li><li>  Zeilenversionen, virtuelle Transaktionen und Subtransaktionen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenschnappsch√ºsse</a> und die Sichtbarkeit von Zeilenversionen;  der Ereignishorizont. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">In-Page-Vakuum und HOT-Updates</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Normales Vakuum</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autovakuum</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umgehung und Einfrieren der Transaktions-ID</a> . </li></ol><br>  Auf geht's! <br><br><blockquote>  Und bevor wir anfangen, m√∂chte ich Elena Indrupskaya f√ºr die √úbersetzung der Artikel ins Englische danken. <br></blockquote><br><a name="habracut"></a><br><h1>  Was ist Isolation und warum ist sie wichtig? </h1><br>  Wahrscheinlich ist sich zumindest jeder der Existenz von Transaktionen bewusst, ist auf die Abk√ºrzung ACID gesto√üen und hat von Isolationsstufen geh√∂rt.  Wir sind jedoch immer noch der Meinung, dass dies die Theorie betrifft, was in der Praxis nicht notwendig ist.  Daher werde ich einige Zeit damit verbringen, zu erkl√§ren, warum dies wirklich wichtig ist. <br><br>  Es ist unwahrscheinlich, dass Sie zufrieden sind, wenn eine Anwendung falsche Daten aus der Datenbank erh√§lt oder wenn die Anwendung falsche Daten in die Datenbank schreibt. <br><br>  Aber was sind "richtige" Daten?  Es ist bekannt, dass <em>Integrit√§tsbeschr√§nkungen</em> wie NOT NULL oder UNIQUE auf Datenbankebene erstellt werden k√∂nnen.  Wenn die Daten immer Integrit√§tsbeschr√§nkungen erf√ºllen (und dies ist so, da das DBMS dies garantiert), sind sie ganzheitlich. <br><br>  Sind <em>richtig</em> und <em>ganzheitlich</em> die gleichen Dinge?  Nicht genau.  Auf Datenbankebene k√∂nnen nicht alle Einschr√§nkungen angegeben werden.  Einige der Einschr√§nkungen sind beispielsweise zu kompliziert und decken mehrere Tabellen gleichzeitig ab.  Und selbst wenn eine Einschr√§nkung im Allgemeinen in der Datenbank h√§tte definiert werden k√∂nnen, aber aus irgendeinem Grund nicht, bedeutet dies nicht, dass die Einschr√§nkung verletzt werden kann. <br><br>  <em>Korrektheit</em> ist also st√§rker als <em>Integrit√§t</em> , aber wir wissen nicht genau, was dies bedeutet.  Wir m√ºssen nur zugeben, dass der ‚ÄûGoldstandard‚Äú der Korrektheit eine Anwendung ist, die, wie wir gerne glauben w√ºrden, <em>richtig</em> geschrieben ist und niemals falsch l√§uft.  In jedem Fall, wenn eine Anwendung nicht die Integrit√§t, sondern die Richtigkeit verletzt, wei√ü das DBMS nichts davon und f√§ngt die Anwendung nicht auf frischer Tat ab. <br><br>  Weiterhin werden wir den Begriff <em>Konsistenz verwenden</em> , um die Korrektheit zu bezeichnen. <br><br>  Nehmen wir jedoch an, dass eine Anwendung nur korrekte Folgen von Operatoren ausf√ºhrt.  Welche Rolle spielt DBMS, wenn die Anwendung korrekt ist? <br><br>  Erstens stellt sich heraus, dass eine korrekte Folge von Operatoren die Datenkonsistenz vor√ºbergehend beeintr√§chtigen kann, und seltsamerweise ist dies normal.  Ein abgedroschenes, aber klares Beispiel ist die √úberweisung von Geldern von einem Konto auf ein anderes.  Die Konsistenzregel mag folgenderma√üen klingen: <em>Eine √úberweisung √§ndert niemals den Gesamtbetrag auf den Konten</em> (diese Regel ist in SQL als Integrit√§tsbedingung nur schwer anzugeben, daher existiert sie auf Anwendungsebene und ist f√ºr das DBMS unsichtbar).  Eine √úberweisung besteht aus zwei Vorg√§ngen: Der erste reduziert das Guthaben auf einem Konto und der zweite erh√∂ht das Guthaben auf dem anderen.  Die erste Operation unterbricht die Datenkonsistenz, w√§hrend die zweite die Datenkonsistenz wiederherstellt. <br><br><blockquote>  Eine gute √úbung besteht darin, die obige Regel auf der Ebene der Integrit√§tsbeschr√§nkungen zu implementieren. <br></blockquote><br>  Was ist, wenn die erste Operation ausgef√ºhrt wird und die zweite nicht?  In der Tat, ohne viel Aufhebens: W√§hrend der zweiten Operation kann es zu einem Stromausfall, einem Serverabsturz und einer Division durch Null kommen - was auch immer.  Es ist klar, dass die Konsistenz gebrochen wird, und dies kann nicht zugelassen werden.  Im Allgemeinen ist es m√∂glich, solche Probleme auf Anwendungsebene zu l√∂sen, jedoch auf Kosten enormer Anstrengungen.  Zum Gl√ºck ist dies jedoch nicht erforderlich: Dies erfolgt durch das DBMS.  Dazu muss das DBMS jedoch wissen, dass die beiden Operationen ein unteilbares Ganzes sind.  Das hei√üt, <em>eine Transaktion</em> . <br><br>  Es stellt sich als interessant heraus: Da das DBMS wei√ü, dass Vorg√§nge eine Transaktion bilden, tr√§gt es zur Aufrechterhaltung der Konsistenz bei, indem sichergestellt wird, dass die Transaktionen atomar sind, und dies ohne Kenntnis spezifischer Konsistenzregeln. <br><br>  Aber es gibt noch einen zweiten, subtileren Punkt.  Sobald mehrere gleichzeitige Transaktionen im System angezeigt werden, die separat absolut korrekt sind, funktionieren sie m√∂glicherweise nicht richtig zusammen.  Dies liegt daran, dass die Reihenfolge der Vorg√§nge verwechselt ist: Sie k√∂nnen nicht davon ausgehen, dass alle Vorg√§nge einer Transaktion zuerst und dann alle Vorg√§nge der anderen Transaktion ausgef√ºhrt werden. <br><br>  Ein Hinweis zur Gleichzeitigkeit.  In der Tat k√∂nnen Transaktionen gleichzeitig auf einem System mit einem Mehrkernprozessor, einem Festplattenarray usw. ausgef√ºhrt werden.  Die gleiche √úberlegung gilt jedoch f√ºr einen Server, der Befehle nacheinander in einem Time-Sharing-Modus ausf√ºhrt: W√§hrend bestimmter Taktzyklen wird eine Transaktion ausgef√ºhrt und w√§hrend der n√§chsten bestimmten Zyklen die andere.  Manchmal wird der Begriff <em>gleichzeitige</em> Ausf√ºhrung f√ºr eine Verallgemeinerung verwendet. <br><br>  Situationen, in denen korrekte Transaktionen falsch zusammenarbeiten, werden als <em>Anomalien</em> der gleichzeitigen Ausf√ºhrung bezeichnet. <br><br>  Ein einfaches Beispiel: Wenn eine Anwendung korrekte Daten aus der Datenbank abrufen m√∂chte, darf sie zumindest keine √Ñnderungen anderer nicht festgeschriebener Transaktionen sehen.  Andernfalls k√∂nnen Sie nicht nur inkonsistente Daten abrufen, sondern auch etwas sehen, das noch nie in der Datenbank vorhanden war (wenn die Transaktion abgebrochen wird).  Diese Anomalie wird als <em>Dirty Read bezeichnet</em> . <br><br>  Es gibt andere, komplexere Anomalien, auf die wir sp√§ter noch eingehen werden. <br><br>  Es ist sicherlich unm√∂glich, eine gleichzeitige Ausf√ºhrung zu vermeiden. Ansonsten, von welcher Art von Leistung k√∂nnen wir sprechen?  Sie k√∂nnen aber auch nicht mit falschen Daten arbeiten. <br><br>  Und wieder kommt das DBMS zur Rettung.  Sie k√∂nnen Transaktionen <em>wie</em> nacheinander ausf√ºhren, <em>als ob sie</em> nacheinander ausgef√ºhrt w√ºrden.  Mit anderen Worten - <em>voneinander isoliert</em> .  In der Realit√§t kann das DBMS Operationen durcheinander bringen, aber sicherstellen, dass das Ergebnis einer gleichzeitigen Ausf√ºhrung mit dem Ergebnis einiger m√∂glicher sequentieller Ausf√ºhrungen √ºbereinstimmt.  Und das beseitigt m√∂gliche Anomalien. <br><br>  Also kamen wir zu der Definition: <br><br><blockquote>  Eine Transaktion ist eine Reihe von Operationen, die von einer Anwendung ausgef√ºhrt werden, die eine Datenbank von einem korrekten Zustand in einen anderen korrekten Zustand √ºbertr√§gt (Konsistenz), vorausgesetzt, die Transaktion ist abgeschlossen (Atomizit√§t) und ohne St√∂rung durch andere Transaktionen (Isolation). <br></blockquote><br>  Diese Definition vereint die ersten drei Buchstaben des Akronyms ACID.  Sie sind so eng miteinander verbunden, dass es keinen Sinn macht, einen ohne den anderen zu betrachten.  Tats√§chlich ist es auch schwierig, den Buchstaben D (Haltbarkeit) abzunehmen.  Wenn ein System abst√ºrzt, werden immer noch √Ñnderungen an nicht festgeschriebenen Transaktionen vorgenommen, mit denen Sie etwas tun m√ºssen, um die Datenkonsistenz wiederherzustellen. <br><br>  Alles w√§re in Ordnung gewesen, aber die Implementierung einer vollst√§ndigen Isolierung ist eine technisch schwierige Aufgabe, die eine Reduzierung des Systemdurchsatzes zur Folge hat.  Daher wird in der Praxis sehr oft (nicht immer, aber fast immer) die geschw√§chte Isolation verwendet, wodurch einige, aber nicht alle Anomalien verhindert werden.  Dies bedeutet, dass ein Teil der Arbeit zur Sicherstellung der Datenkorrektheit auf die Anwendung f√§llt.  Aus diesem Grund ist es sehr wichtig zu verstehen, welche Isolationsstufe im System verwendet wird, welche Garantien es gibt und was nicht und wie man unter solchen Bedingungen korrekten Code schreibt. <br><br><h1>  Isolationsstufen und Anomalien im SQL-Standard </h1><br>  Der SQL-Standard hat lange Zeit vier Isolationsstufen beschrieben.  Diese Ebenen werden definiert, indem Anomalien aufgelistet werden, die zul√§ssig oder nicht zul√§ssig sind, wenn Transaktionen gleichzeitig auf dieser Ebene ausgef√ºhrt werden.  Um √ºber diese Ebenen zu sprechen, ist es daher notwendig, die Anomalien kennenzulernen. <br><br>  Ich betone, dass es sich in diesem Teil um den Standard handelt, dh um eine Theorie, auf der die Praxis ma√ügeblich basiert, von der sie aber gleichzeitig erheblich abweicht.  Daher sind alle Beispiele hier spekulativ.  Sie werden die gleichen Operationen auf Kundenkonten anwenden: Dies ist ziemlich demonstrativ, hat jedoch zugegebenerma√üen nichts mit der Organisation der Bankoperationen in der Realit√§t zu tun. <br><br><h2>  Verlustaktualisierung </h2><br>  Beginnen wir mit dem <em>verlorenen Update</em> .  Diese Anomalie tritt auf, wenn zwei Transaktionen dieselbe Zeile der Tabelle lesen, dann eine Transaktion diese Zeile aktualisiert und die zweite Transaktion dieselbe Zeile ebenfalls aktualisiert, ohne die durch die erste Transaktion vorgenommenen √Ñnderungen zu ber√ºcksichtigen. <br><br>  Beispielsweise erh√∂hen zwei Transaktionen den Betrag auf demselben Konto um 100 ‚ÇΩ (‚ÇΩ ist das W√§hrungszeichen f√ºr den russischen Rubel).  Die erste Transaktion liest den aktuellen Wert (~ 1000) und die zweite Transaktion liest den gleichen Wert.  Die erste Transaktion erh√∂ht den Betrag (dies ergibt 001100) und schreibt diesen Wert.  Die zweite Transaktion verh√§lt sich genauso: Sie erh√§lt den gleichen Wert von 001100 und schreibt diesen Wert.  Infolgedessen verlor der Kunde 100.. <br><br>  Der Standard erlaubt keine verlorenen Updates auf irgendeiner Isolationsstufe. <br><br><h2>  Dirty Read und Read Uncommitted </h2><br>  Eine <em>schmutzige Lekt√ºre</em> ist das, was wir bereits kennengelernt haben.  Diese Anomalie tritt auf, wenn eine Transaktion √Ñnderungen liest, die noch nicht von einer anderen Transaktion festgeschrieben wurden. <br><br>  Beispielsweise √ºbertr√§gt die erste Transaktion das gesamte Geld vom Konto des Kunden auf ein anderes Konto, schreibt die √Ñnderung jedoch nicht fest.  Eine andere Transaktion liest den Kontostand, um ‚ÇΩ0 zu erhalten, und weigert sich, dem Kunden Bargeld abzuheben, obwohl die erste Transaktion ihre √Ñnderungen abbricht und zur√ºcksetzt, sodass der Wert 0 nie in der Datenbank vorhanden war. <br><br>  Der Standard erlaubt Dirty Reads auf der Ebene Read Uncommitted. <br><br><h2>  Nicht wiederholbares Lesen und Lesen festgeschrieben </h2><br>  Eine <em>nicht wiederholbare</em> Leseanomalie tritt auf, wenn eine Transaktion dieselbe Zeile zweimal liest und zwischen den Lesevorg√§ngen die zweite Transaktion diese Zeile √§ndert (oder l√∂scht) und die √Ñnderungen festschreibt.  Dann erh√§lt die erste Transaktion unterschiedliche Ergebnisse. <br><br>  Lassen Sie beispielsweise eine Konsistenzregel <em>negative Betr√§ge auf Kundenkonten verbieten</em> .  Die erste Transaktion wird den Betrag auf dem Konto um 100 ‚ÇΩ reduzieren.  Es pr√ºft den aktuellen Wert, erh√§lt 1000 und entscheidet, dass die Abnahme m√∂glich ist.  Gleichzeitig reduziert die zweite Transaktion den Betrag auf dem Konto auf Null und schreibt die √Ñnderungen fest.  Wenn die erste Transaktion nun den Betrag erneut pr√ºft, erh√§lt sie ‚ÇΩ0 (aber sie hat bereits beschlossen, den Wert zu reduzieren, und das Konto schreibt rote Zahlen). <br><br>  Der Standard erlaubt nicht wiederholbare Lesevorg√§nge auf den Ebenen Read Uncommitted und Read Committed.  Read Committed erlaubt jedoch keine Dirty Reads. <br><br><h2>  Phantom Read und Repeatable Read </h2><br>  Ein <em>Phantom-</em> Lesevorgang tritt auf, wenn eine Transaktion einen Satz von Zeilen mit derselben Bedingung zweimal liest und zwischen den Lesevorg√§ngen die zweite Transaktion Zeilen hinzuf√ºgt, die diese Bedingung erf√ºllen (und die √Ñnderungen festschreibt).  Dann erh√§lt die erste Transaktion einen anderen Satz von Zeilen. <br><br>  Lassen Sie beispielsweise eine Konsistenzregel <em>verhindern, dass ein Kunde mehr als 3 Konten hat</em> .  Die erste Transaktion er√∂ffnet ein neues Konto, √ºberpr√ºft die aktuelle Anzahl der Konten (z. B. 2) und entscheidet, dass eine Er√∂ffnung m√∂glich ist.  Gleichzeitig er√∂ffnet die zweite Transaktion ein neues Konto f√ºr den Kunden und schreibt die √Ñnderungen fest.  Wenn die erste Transaktion die Nummer erneut √ºberpr√ºft, erh√§lt sie 3 (es wird jedoch bereits ein anderes Konto er√∂ffnet, und der Kunde scheint 4 davon zu haben). <br><br>  Der Standard erlaubt Phantom-Lesevorg√§nge auf den Ebenen Read Uncommitted, Read Committed und Repeatable Read.  Nicht wiederholbares Lesen ist jedoch auf der Ebene Wiederholbares Lesen nicht zul√§ssig. <br><br><h2>  Das Fehlen von Anomalien und serialisierbar </h2><br>  Der Standard definiert eine weitere Ebene - Serializable -, die keine Anomalien zul√§sst.  Dies ist nicht dasselbe, um verlorene Updates und schmutzige, nicht wiederholbare oder Phantom-Lesevorg√§nge zu verbieten. <br><br>  Die Sache ist, dass es viel mehr bekannte Anomalien gibt als im Standard aufgef√ºhrt und auch eine unbekannte Anzahl von noch unbekannten. <br><br>  Die serialisierbare Ebene muss <em>absolut alle</em> Anomalien verhindern.  Dies bedeutet, dass ein Anwendungsentwickler auf dieser Ebene nicht √ºber die gleichzeitige Ausf√ºhrung nachdenken muss.  Wenn Transaktionen eine korrekte Reihenfolge von Operatoren ausf√ºhren, die separat arbeiten, sind die Daten auch dann konsistent, wenn diese Transaktionen gleichzeitig ausgef√ºhrt werden. <br><br><h2>  √úbersichtstabelle </h2><br>  Jetzt k√∂nnen wir eine bekannte Tabelle bereitstellen.  Hier wird jedoch der Klarheit halber die letzte Spalte hinzugef√ºgt, die im Standard fehlt. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Verlorene √Ñnderungen </th><th>  Schmutzige Lekt√ºre </th><th>  Nicht wiederholbares Lesen </th><th>  Phantom gelesen </th><th>  Andere Anomalien </th></tr><tr><th>  Lesen Sie Uncommitted </th><th>  - - </th><th>  Ja </th><th>  Ja </th><th>  Ja </th><th>  Ja </th></tr><tr><th>  Lesen Sie verpflichtet </th><th>  - - </th><th>  - - </th><th>  Ja </th><th>  Ja </th><th>  Ja </th></tr><tr><th>  Wiederholbares Lesen </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  Ja </th><th>  Ja </th></tr><tr><th>  Serialisierbar </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th></tr></tbody></table></div><br><h2>  Warum genau diese Anomalien? </h2><br>  Warum listet der Standard nur einige der vielen m√∂glichen Anomalien auf und warum sind sie genau diese? <br><br>  Niemand scheint es sicher zu wissen.  Aber hier ist die Praxis offensichtlich der Theorie voraus, so dass es m√∂glich ist, dass zu dieser Zeit (nach dem SQL: 92-Standard) nicht nur an andere Anomalien gedacht wurde. <br><br>  Au√üerdem wurde angenommen, dass die Isolation auf Schl√∂ssern aufgebaut sein muss.  Die Idee hinter dem weit verbreiteten <em>Two-Phase Locking-Protokoll</em> (2PL) ist, dass eine Transaktion w√§hrend der Ausf√ºhrung die Zeilen sperrt, mit denen sie arbeitet, und die Sperren nach Abschluss aufhebt.  Je mehr Sperren eine Transaktion erwirbt, desto besser ist sie von anderen Transaktionen isoliert.  Die Leistung des Systems leidet jedoch auch st√§rker, da Transaktionen nicht zusammenarbeiten, sondern f√ºr dieselben Zeilen in die Warteschlange gestellt werden. <br><br>  Meiner Meinung nach ist es nur die Anzahl der erforderlichen Sperren, die den Unterschied zwischen den Isolationsstufen des Standards erkl√§rt. <br><br>  Wenn eine Transaktion die zu √§ndernden Zeilen vom Aktualisieren, aber nicht vom Lesen sperrt, erhalten wir die Stufe "Nicht festgeschrieben lesen": Verlorene √Ñnderungen sind nicht zul√§ssig, aber nicht festgeschriebene Daten k√∂nnen gelesen werden. <br><br>  Wenn eine Transaktion die zu √§ndernden Zeilen sowohl beim Lesen als auch beim Aktualisieren sperrt, erhalten wir die Stufe "Festgeschrieben": Sie k√∂nnen keine nicht festgeschriebenen Daten lesen, aber Sie k√∂nnen einen anderen Wert (nicht wiederholbares Lesen) erhalten, wenn Sie erneut auf die Zeile zugreifen. <br><br>  Wenn eine Transaktion die zu lesenden und zu √§ndernden Zeilen sowie das Lesen und Aktualisieren sperrt, erhalten wir die Stufe Wiederholbares Lesen: Beim erneuten Lesen der Zeile wird derselbe Wert zur√ºckgegeben. <br><br>  Bei Serializable gibt es jedoch ein Problem: Sie k√∂nnen eine noch nicht vorhandene Zeile nicht sperren.  Daher ist ein Phantom-Lesevorgang weiterhin m√∂glich: Eine andere Transaktion kann eine Zeile hinzuf√ºgen (aber nicht l√∂schen), die die Bedingungen einer zuvor ausgef√ºhrten Abfrage erf√ºllt, und diese Zeile wird in die Neuauswahl einbezogen. <br><br>  Um die Ebene Serializable zu implementieren, reichen normale Sperren daher nicht aus. Sie m√ºssen eher Bedingungen (Pr√§dikate) als Zeilen sperren.  Daher wurden solche Sperren als <em>Pr√§dikat bezeichnet</em> .  Sie wurden 1976 vorgeschlagen, aber ihre praktische Anwendbarkeit wird durch relativ einfache Bedingungen eingeschr√§nkt, f√ºr die klar ist, wie zwei verschiedene Pr√§dikate verbunden werden sollen.  Soweit ich wei√ü, wurden solche Sperren bisher in keinem System implementiert. <br><br><h1>  Isolationsstufen in PostgreSQL </h1><br>  Im Laufe der Zeit wurden sperrbasierte Protokolle des Transaktionsmanagements durch das Snapshot Isolation Protocol (SI) ersetzt.  Die Idee ist, dass jede Transaktion zu einem bestimmten Zeitpunkt mit einem konsistenten Snapshot der Daten arbeitet und nur die √Ñnderungen in den Snapshot √ºbernommen werden, die vor ihrer Erstellung festgeschrieben wurden. <br><br>  Diese Isolierung verhindert automatisch fehlerhafte Lesevorg√§nge.  Formal k√∂nnen Sie in PostgreSQL die Stufe Read Uncommitted angeben, diese funktioniert jedoch genauso wie Read Committed.  Daher werden wir weiter √ºberhaupt nicht √ºber die Stufe "Uncommitted lesen" sprechen. <br><br>  PostgreSQL implementiert eine <em>Multiversionsvariante</em> dieses Protokolls.  Die Idee der Multiversion-Parallelit√§t besteht darin, dass mehrere Versionen derselben Zeile in einem DBMS nebeneinander existieren k√∂nnen.  Auf diese Weise k√∂nnen Sie mit vorhandenen Versionen einen Snapshot der Daten erstellen und ein Minimum an Sperren verwenden.  Tats√§chlich werden nur nachfolgende √Ñnderungen an derselben Zeile gesperrt.  Alle anderen Vorg√§nge werden gleichzeitig ausgef√ºhrt: Schreibtransaktionen sperren niemals schreibgesch√ºtzte Transaktionen, und schreibgesch√ºtzte Transaktionen sperren niemals etwas. <br><br>  Durch die Verwendung von Datenschnappsch√ºssen ist die Isolation in PostgreSQL strenger als vom Standard gefordert: Die Stufe Wiederholbares Lesen erlaubt nicht nur nicht wiederholbare Lesevorg√§nge, sondern auch Phantomlesevorg√§nge (obwohl sie keine vollst√§ndige Isolation bietet).  Und das ohne Effizienzverlust. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Verlorene √Ñnderungen </th><th>  Schmutzige Lekt√ºre </th><th>  Nicht wiederholbares Lesen </th><th>  Phantom gelesen </th><th>  Andere Anomalien </th></tr><tr><th>  Lesen Sie Uncommitted </th><th>  - - </th><th>  - - </th><th>  Ja </th><th>  Ja </th><th>  Ja </th></tr><tr><th>  Lesen Sie verpflichtet </th><th>  - - </th><th>  - - </th><th>  Ja </th><th>  Ja </th><th>  Ja </th></tr><tr><th>  Wiederholbares Lesen </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  Ja </th></tr><tr><th>  Serialisierbar </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th><th>  - - </th></tr></tbody></table></div><br>  In den n√§chsten Artikeln werden wir dar√ºber sprechen, wie Multiversion-Parallelit√§t ‚Äûunter der Haube‚Äú implementiert wird, und jetzt werden wir jede der drei Ebenen mit dem Auge eines Benutzers im Detail betrachten (wie Sie wissen, verbirgt sich das Interessanteste hinter ‚Äûanderen Anomalien‚Äú ‚Äù).  Dazu erstellen wir eine Kontenliste.  Alice und Bob haben jeweils 1000 Euro, aber Bob hat zwei er√∂ffnete Konten: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( id <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, number <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span>, client <span class="hljs-type"><span class="hljs-type">text</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'1001'</span></span>, <span class="hljs-string"><span class="hljs-string">'alice'</span></span>, <span class="hljs-number"><span class="hljs-number">1000.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2001'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2002'</span></span>, <span class="hljs-string"><span class="hljs-string">'bob'</span></span>, <span class="hljs-number"><span class="hljs-number">900.00</span></span>);</code> </pre> <br><h2>  Lesen Sie verpflichtet </h2><br><h3>  Das Fehlen von Dirty Read </h3><br>  Es ist einfach sicherzustellen, dass schmutzige Daten nicht gelesen werden k√∂nnen.  Wir starten die Transaktion.  Standardm√§√üig wird die Isolationsstufe Read Committed verwendet: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> transaction_isolation ----------------------- read committed (1 row)</code> </pre><br>  Genauer gesagt wird die Standardstufe durch den Parameter festgelegt, der bei Bedarf ge√§ndert werden kann: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SHOW</span></span> default_transaction_isolation;</code> </pre><pre> <code class="plaintext hljs"> default_transaction_isolation ------------------------------- read committed (1 row)</code> </pre><br>  Bei einer offenen Transaktion ziehen wir also Geld vom Konto ab, √ºbernehmen jedoch keine √Ñnderungen.  Die Transaktion sieht ihre eigenen √Ñnderungen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 1 | 1001 | alice | 800.00 (1 row)</code> </pre><br>  In der zweiten Sitzung starten wir eine weitere Transaktion mit derselben Read Committed-Ebene.  Zur Unterscheidung zwischen den Transaktionen werden Befehle der zweiten Transaktion einger√ºckt und mit einem Balken markiert. <br><br>  Um die obigen Befehle zu wiederholen (was n√ºtzlich ist), m√ºssen Sie zwei Terminals √∂ffnen und jeweils psql ausf√ºhren.  Im ersten Terminal k√∂nnen Sie die Befehle einer Transaktion eingeben und im zweiten die Befehle der anderen. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+--------- | 1 | 1001 | alice | 1000.00 | (1 row)</code> </pre><br>  Wie erwartet werden bei der anderen Transaktion keine nicht festgeschriebenen √Ñnderungen angezeigt, da Dirty Reads nicht zul√§ssig sind. <br><br><h3>  Nicht wiederholbares Lesen </h3><br>  Lassen Sie nun die erste Transaktion die √Ñnderungen festschreiben und die zweite dieselbe Abfrage erneut ausf√ºhren. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'alice'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Die Abfrage erh√§lt bereits neue Daten - und dies ist die <em>nicht wiederholbare</em> Leseanomalie, die auf der Ebene Read Committed zul√§ssig ist. <br><br>  <em>Praktische Schlussfolgerung</em> : In einer Transaktion k√∂nnen Sie keine Entscheidungen treffen, die auf Daten basieren, die von einem vorherigen Operator gelesen wurden, da sich die Dinge zwischen der Ausf√ºhrung der Operatoren √§ndern k√∂nnen.  Hier ist ein Beispiel, dessen Variationen im Anwendungscode so h√§ufig auftreten, dass es als klassisches Antimuster betrachtet wird: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span>;</code> </pre><br>  W√§hrend der Zeit zwischen √úberpr√ºfung und Aktualisierung k√∂nnen andere Transaktionen den Status des Kontos auf irgendeine Weise √§ndern, sodass eine solche ‚Äû√úberpr√ºfung‚Äú vor nichts sch√ºtzt.  Es ist zweckm√§√üig, sich vorzustellen, dass zwischen den Betreibern einer Transaktion alle anderen Betreiber anderer Transaktionen beispielsweise wie folgt ‚Äûkeilen‚Äú k√∂nnen: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-comment"><span class="hljs-comment">----- | UPDATE accounts SET amount = amount - 200 WHERE id = 1; | COMMIT; ----- UPDATE accounts SET amount = amount - 1000 WHERE id = 1; END IF;</span></span></code> </pre><br>  Wenn durch die Neuanordnung der Operatoren alles verdorben werden kann, ist der Code falsch geschrieben.  Und t√§uschen Sie sich nicht, dass ein solcher Zufall nicht passieren wird - das wird es mit Sicherheit. <br><br>  Aber wie schreibt man Code richtig?  Die Optionen sind in der Regel wie folgt: <br><br><ul><li>  Code nicht schreiben. <br>  Das ist kein Scherz.  In diesem Fall wird das √úberpr√ºfen beispielsweise leicht zu einer Integrit√§tsbeschr√§nkung: <br> <code>ALTER TABLE accounts ADD CHECK amount &gt;= 0;</code> <br>  Jetzt sind keine √úberpr√ºfungen erforderlich: F√ºhren Sie einfach den Vorgang aus und behandeln Sie gegebenenfalls die Ausnahme, die auftritt, wenn eine Integrit√§tsverletzung versucht wird. <br></li><li>  So verwenden Sie eine einzelne SQL-Anweisung <br>  Konsistenzprobleme treten auf, da im Zeitintervall zwischen Operatoren eine andere Transaktion abgeschlossen werden kann, wodurch die sichtbaren Daten ge√§ndert werden.  Und wenn es einen Operator gibt, gibt es keine Zeitintervalle. <br>  PostgreSQL verf√ºgt √ºber gen√ºgend Techniken, um komplexe Probleme mit einer SQL-Anweisung zu l√∂sen.  Beachten Sie die allgemeinen Tabellenausdr√ºcke (CTE), in denen Sie unter anderem die Anweisungen INSERT / UPDATE / DELETE sowie die Anweisung INSERT ON CONFLICT verwenden k√∂nnen, die die Logik von ‚Äûinsert, aber wenn die Zeile bereits vorhanden ist, implementiert. update ‚Äùin einer Anweisung. <br></li><li>  Benutzerdefinierte Schl√∂sser. <br>  Der letzte Ausweg besteht darin, manuell eine exklusive Sperre f√ºr alle erforderlichen Zeilen (SELECT FOR UPDATE) oder sogar f√ºr die gesamte Tabelle (LOCK TABLE) festzulegen.  Dies funktioniert immer, macht jedoch die Vorteile der Multiversions-Parallelit√§t zunichte: Einige Vorg√§nge werden nacheinander anstelle der gleichzeitigen Ausf√ºhrung ausgef√ºhrt. <br></li></ul><br><h3>  Inkonsistentes Lesen </h3><br>  Bevor Sie zur n√§chsten Stufe der Isolation √ºbergehen, m√ºssen Sie zugeben, dass dies nicht alles so einfach ist, wie es sich anh√∂rt.  Die Implementierung von PostgreSQL ist so, dass andere, weniger bekannte Anomalien ber√ºcksichtigt werden, die nicht durch den Standard geregelt werden. <br><br>  Nehmen wir an, dass die erste Transaktion den Geldtransfer von einem Bob-Konto auf das andere gestartet hat: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Gleichzeitig z√§hlt eine andere Transaktion den Kontostand von Bob und die Berechnung wird in einer Schleife √ºber alle Konten von Bob durchgef√ºhrt.  Tats√§chlich beginnt die Transaktion mit dem ersten Konto (und sieht offensichtlich den vorherigen Status): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | -------- | 100.00 | (1 row)</code> </pre><br>  Zu diesem Zeitpunkt wird die erste Transaktion erfolgreich abgeschlossen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Und der andere liest den Status des zweiten Kontos (und sieht bereits den neuen Wert): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="plaintext hljs">| amount | --------- | 1000.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Daher erhielt die zweite Transaktion insgesamt 1100 GBP, dh falsche Daten.  Und dies ist eine <em>inkonsistente</em> Leseanomalie. <br><br>  Wie vermeide ich eine solche Anomalie, w√§hrend ich auf der Stufe "Read Committed" bleibe?  Verwenden Sie nat√ºrlich einen Operator.  Zum Beispiel: <br><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><br>  Bis hierher habe ich behauptet, dass sich die Sichtbarkeit von Daten nur zwischen Operatoren √§ndern kann, aber ist das so offensichtlich?  Und wenn die Abfrage lange dauert, kann sie einen Teil der Daten in einem Zustand und einen Teil in einem anderen sehen? <br><br>  Lassen Sie uns √ºberpr√ºfen.  Eine bequeme M√∂glichkeit, dies zu tun, besteht darin, eine erzwungene Verz√∂gerung in den Operator einzuf√ºgen, indem die Funktion pg_sleep aufgerufen wird.  Sein Parameter gibt die Verz√∂gerungszeit in Sekunden an. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount, pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  W√§hrend dieser Operator ausgef√ºhrt wird, √ºberweisen wir das Geld in einer anderen Transaktion zur√ºck: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Das Ergebnis zeigt, dass der Bediener die Daten in dem Zustand sieht, den sie zum Zeitpunkt des Starts der Ausf√ºhrung des Bedieners hatten.  Dies ist zweifellos richtig. <br><br><pre> <code class="plaintext hljs"> amount | pg_sleep ---------+---------- 0.00 | 1000.00 | (2 rows)</code> </pre><br>  Aber so einfach ist es auch hier nicht.  Mit PostgreSQL k√∂nnen Sie Funktionen definieren, und Funktionen haben das Konzept einer <em>Volatilit√§tskategorie</em> .  Wenn eine VOLATILE-Funktion in einer Abfrage aufgerufen wird und eine andere Abfrage in dieser Funktion ausgef√ºhrt wird, werden in der Abfrage innerhalb der Funktion Daten angezeigt, die nicht mit den Daten in der Hauptabfrage √ºbereinstimmen. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_amount(id <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">numeric</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> amount </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> accounts a </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHERE</span></span></span><span class="pgsql"> a.id = get_amount.id; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">VOLATILE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sql</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> get_amount(id), pg_sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  In diesem Fall erhalten wir falsche Daten - 100 gehen verloren: <br><br><pre> <code class="plaintext hljs"> get_amount | pg_sleep ------------+---------- 100.00 | 800.00 | (2 rows)</code> </pre><br>  Ich betone, dass dieser Effekt nur auf der Isolationsstufe Read Committed und nur mit den VOLATILE-Funktionen m√∂glich ist.  Das Problem ist, dass standardm√§√üig genau diese Isolationsstufe und diese Volatilit√§tskategorie verwendet werden.  Fallen Sie nicht in die Falle! <br><br><h3>  Inkonsistentes Lesen im Austausch f√ºr verlorene √Ñnderungen </h3><br>  Wir k√∂nnen w√§hrend eines Updates auch einen inkonsistenten Lesevorgang innerhalb eines einzelnen Operators erhalten, wenn auch auf etwas unerwartete Weise. <br><br>  Mal sehen, was passiert, wenn zwei Transaktionen versuchen, dieselbe Zeile zu √§ndern.  Jetzt hat Bob 1000 Euro auf zwei Konten: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><br>  Wir starten eine Transaktion, die Bobs Guthaben reduziert: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  Gleichzeitig fallen bei einer anderen Transaktion Zinsen auf alle Kundenkonten mit einem Gesamtguthaben von mindestens 1.000 GBP an: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> ( | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span> | );</code> </pre><br>  Die Ausf√ºhrung des UPDATE-Operators besteht aus zwei Teilen.  Zun√§chst wird tats√§chlich SELECT ausgef√ºhrt, wodurch die zu aktualisierenden Zeilen ausgew√§hlt werden, die die entsprechende Bedingung erf√ºllen.  Da die √Ñnderung in der ersten Transaktion nicht festgeschrieben wird, kann die zweite Transaktion sie nicht sehen, und die √Ñnderung wirkt sich nicht auf die Auswahl der Zeilen f√ºr die Zinsabgrenzung aus.  Nun, dann erf√ºllen Bobs Konten die Bedingung und sobald das Update ausgef√ºhrt wird, sollte sich sein Kontostand um ‚ÇΩ10 erh√∂hen. <br><br>  In der zweiten Phase der Ausf√ºhrung werden die ausgew√§hlten Zeilen einzeln aktualisiert.  Hier wird die zweite Transaktion zum "H√§ngen" gezwungen, da die Zeile mit id = 3 bereits von der ersten Transaktion gesperrt ist. <br><br>  In der Zwischenzeit werden bei der ersten Transaktion die √Ñnderungen festgeschrieben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Was wird das Ergebnis sein? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+---------- 2 | 2001 | bob | 202.0000 3 | 2002 | bob | 707.0000 (2 rows)</code> </pre><br>  Einerseits sollte der UPDATE-Befehl die √Ñnderungen der zweiten Transaktion nicht sehen.  Andererseits sollte es die in der zweiten Transaktion festgeschriebenen √Ñnderungen nicht verlieren. <br><br>  Sobald die Sperre aufgehoben ist, liest UPDATE die Zeile, die aktualisiert werden soll, erneut (jedoch nur diese).  Infolgedessen sammelte Bob 9., Basierend auf dem Betrag von 900..  Aber wenn Bob 900 Euro gehabt h√§tte, w√§ren seine Konten √ºberhaupt nicht in der Auswahl gewesen. <br><br>  Die Transaktion erh√§lt also falsche Daten: Einige der Zeilen sind zu einem bestimmten Zeitpunkt sichtbar, andere zu einem anderen.  Anstelle eines verlorenen Updates erhalten wir erneut die Anomalie des <em>inkonsistenten Lesens</em> . <br><br><blockquote>  Aufmerksame Leser bemerken, dass Sie mit Hilfe der Anwendung ein verlorenes Update erhalten k√∂nnen, selbst auf der Ebene von Read Committed.  Zum Beispiel: <br><br><pre> <code class="pgsql hljs"> x := (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = x + <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Die Datenbank ist nicht schuld: Sie erh√§lt zwei SQL-Anweisungen und wei√ü nichts dar√ºber, dass der Wert von x + 100 in irgendeiner Weise mit dem Kontobetrag zusammenh√§ngt.  Vermeiden Sie es, Code auf diese Weise zu schreiben. <br></blockquote><br><h2>  Wiederholbares Lesen </h2><br><h3>  Das Fehlen von nicht wiederholbaren und Phantom-Lesevorg√§ngen </h3><br>  Der Name der Isolationsstufe setzt voraus, dass das Lesen wiederholbar ist.  Lassen Sie es uns √ºberpr√ºfen und gleichzeitig sicherstellen, dass keine Phantom-Lesevorg√§nge vorhanden sind.  Zu diesem Zweck setzen wir in der ersten Transaktion die Konten von Bob auf den vorherigen Status zur√ºck und erstellen ein neues Konto f√ºr Charlie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">200.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">800.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'3001'</span></span>, <span class="hljs-string"><span class="hljs-string">'charlie'</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+---------+-------- 1 | 1001 | alice | 800.00 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 4 | 3001 | charlie | 100.00 (4 rows)</code> </pre><br>  In der zweiten Sitzung starten wir die Transaktion mit der Ebene Wiederholbares Lesen, indem wir sie im Befehl BEGIN angeben (die Ebene der ersten Transaktion ist unwesentlich). <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><br>  Jetzt schreibt die erste Transaktion die √Ñnderungen fest und die zweite f√ºhrt dieselbe Abfrage erneut aus. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 1 | 1001 | alice | 800.00 | 2 | 2001 | bob | 202.0000 | 3 | 2002 | bob | 707.0000 | (3 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Die zweite Transaktion sieht immer noch genau die gleichen Daten wie zu Beginn: Es sind keine √Ñnderungen an vorhandenen oder neuen Zeilen sichtbar. <br><br>  Auf dieser Ebene k√∂nnen Sie vermeiden, sich √ºber Dinge Gedanken zu machen, die sich zwischen zwei Operatoren √§ndern k√∂nnen. <br><br><h3>  Serialisierungsfehler im Austausch f√ºr verlorene √Ñnderungen </h3><br>  Wir haben bereits erw√§hnt, dass beim Aktualisieren derselben Zeile auf Read-Committed-Ebene durch zwei Transaktionen eine Anomalie des inkonsistenten Lesens auftreten kann.  Dies liegt daran, dass die wartende Transaktion die gesperrte Zeile erneut liest und sie daher nicht zum gleichen Zeitpunkt wie die anderen Zeilen sieht. <br><br>  Auf der Ebene "Wiederholbares Lesen" ist diese Anomalie nicht zul√§ssig. In diesem Fall kann jedoch nichts unternommen werden. Die Transaktion wird daher mit einem Serialisierungsfehler beendet.  √úberpr√ºfen wir dies, indem wir dasselbe Szenario mit Zinsabgrenzung wiederholen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 800.00 (2 rows)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>;&lt;span/&gt; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount * <span class="hljs-number"><span class="hljs-number">1.01</span></span>&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> client&lt;span/&gt; | <span class="hljs-keyword"><span class="hljs-keyword">HAVING</span></span> sum(amount) &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>&lt;span/&gt; | );&lt;span/&gt;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| ERROR: could not serialize access due to concurrent update</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Die Daten blieben konsistent: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 200.00 3 | 2002 | bob | 700.00 (2 rows)</code> </pre><br>  Der gleiche Fehler tritt bei jeder anderen Wettbewerbs√§nderung einer Zeile auf, selbst wenn die Spalten unseres Anliegens nicht tats√§chlich ge√§ndert wurden. <br><br>  <em>Praktische Schlussfolgerung</em> : Wenn Ihre Anwendung die Isolationsstufe Wiederholbares Lesen f√ºr Schreibtransaktionen verwendet, muss sie bereit sein, Transaktionen zu wiederholen, die mit einem Serialisierungsfehler beendet wurden.  Bei schreibgesch√ºtzten Transaktionen ist dieses Ergebnis nicht m√∂glich. <br><br><h3>  Inkonsistentes Schreiben </h3><br>  In PostgreSQL werden auf der Isolationsstufe "Wiederholbares Lesen" alle im Standard beschriebenen Anomalien verhindert.  Aber nicht alle Anomalien im Allgemeinen.  Es stellt sich heraus, dass <em>genau zwei</em> Anomalien noch m√∂glich sind.  (Dies gilt nicht nur f√ºr PostgreSQL, sondern auch f√ºr andere Implementierungen von Snapshot Isolation.) <br><br>  Die erste dieser Anomalien ist ein <em>inkonsistentes Schreiben</em> . <br><br>  Es gilt die folgende Konsistenzregel: <em>Negative Betr√§ge auf Kundenkonten sind zul√§ssig, wenn der Gesamtbetrag auf allen Konten dieses Kunden nicht negativ bleibt</em> . <br><br>  Die erste Transaktion erh√§lt den Betrag auf Bobs Konten: :900. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum -------- 900.00 (1 row)</code> </pre><br>  Die zweite Transaktion erh√§lt den gleichen Betrag. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | -------- | 900.00 | (1 row)</code> </pre><br>  Die erste Transaktion geht zu Recht davon aus, dass der Betrag eines der Konten um 600 GBP reduziert werden kann. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Und die zweite Transaktion kommt zu dem gleichen Ergebnis.  Aber es reduziert ein anderes Konto: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+--------- 2 | 2001 | bob | -400.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br>  Wir haben es geschafft, Bobs Saldo in die roten Zahlen zu bringen, obwohl jede Transaktion alleine korrekt funktioniert. <br><br><h3>  Schreibgesch√ºtzte Transaktionsanomalie </h3><br>  Dies ist die zweite und letzte der Anomalien, die auf der Ebene des wiederholbaren Lesens m√∂glich sind.  Um dies zu demonstrieren, ben√∂tigen Sie drei Transaktionen, von denen zwei die Daten √§ndern und die dritte sie nur liest. <br><br>  Aber lassen Sie uns zuerst den Status von Bobs Konten wiederherstellen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 3 | 2002 | bob | 100.00 2 | 2001 | bob | 900.00 (2 rows)</code> </pre><br>  Bei der ersten Transaktion fallen Zinsen auf den auf allen Bob-Konten verf√ºgbaren Betrag an.  Die Zinsen werden einem seiner Konten gutgeschrieben: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br>  Dann zieht eine andere Transaktion Geld von einem anderen Bob-Konto ab und schreibt seine √Ñnderungen fest: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Wenn die erste Transaktion zu diesem Zeitpunkt festgeschrieben wird, tritt keine Anomalie auf: Wir k√∂nnen davon ausgehen, dass die erste Transaktion zuerst und dann die zweite ausgef√ºhrt wurde (aber nicht umgekehrt, da bei der ersten Transaktion zuvor der Status des Kontos mit der ID = 3 angezeigt wurde Konto wurde durch die zweite Transaktion ge√§ndert). <br><br>  Stellen Sie sich jedoch vor, dass zu diesem Zeitpunkt die dritte (schreibgesch√ºtzte) Transaktion beginnt, die den Status eines Kontos liest, das von den ersten beiden Transaktionen nicht betroffen ist: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPEATABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><br>  Und erst danach ist die erste Transaktion abgeschlossen: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Welchen Status sollte die dritte Transaktion jetzt sehen? <br><br><pre> <code class="pgsql hljs">| <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><br>  Nach dem Start konnte die dritte Transaktion die √Ñnderungen der zweiten Transaktion (die bereits festgeschrieben wurde) sehen, jedoch nicht der ersten Transaktion (die noch nicht festgeschrieben worden war).  Andererseits haben wir oben bereits festgestellt, dass die zweite Transaktion nach der ersten als gestartet betrachtet werden sollte.  Welchen Status die dritte Transaktion sieht, ist inkonsistent - dies ist nur die Anomalie einer schreibgesch√ºtzten Transaktion.  Auf der Ebene Wiederholbares Lesen ist jedoch Folgendes zul√§ssig: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 2 | 2001 | bob | 900.00 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h2>  Serialisierbar </h2><br>  Die Stufe Serializable verhindert alle m√∂glichen Anomalien.  Tats√§chlich basiert Serializable auf der Snapshot-Isolation.  Die Anomalien, die beim wiederholbaren Lesen nicht auftreten (z. B. ein fehlerhafter, nicht wiederholbarer oder Phantom-Lesevorgang), treten auch auf der Ebene der Serialisierbarkeit nicht auf.  Und die auftretenden Anomalien (ein inkonsistentes Schreiben und eine schreibgesch√ºtzte Transaktionsanomalie) werden erkannt und die Transaktion wird abgebrochen - ein bekannter Serialisierungsfehler tritt auf: Der <em>Zugriff konnte nicht serialisiert werden</em> . <br><br><h3>  Inkonsistentes Schreiben </h3><br>  Um dies zu veranschaulichen, wiederholen wir das Szenario mit einer inkonsistenten Schreibanomalie: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> sum ---------- 910.0000 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sum(amount) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| sum | ---------- | 910.0000 | (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">600.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ERROR: could not serialize access due to read/write dependencies among transactions DETAIL: Reason code: Canceled on identification as a pivot, during commit attempt. HINT: The transaction might succeed if retried.</code> </pre><br>  Genau wie auf der Ebene "Wiederholbares Lesen" muss eine Anwendung, die die Isolationsstufe "Serialisierbar" verwendet, Transaktionen wiederholen, die mit einem Serialisierungsfehler beendet wurden, wie die Fehlermeldung uns auffordert. <br><br>  Die Programmierung wird einfacher, aber der Preis daf√ºr ist die erzwungene Beendigung eines Teils der Transaktionen und die Notwendigkeit, diese zu wiederholen.  Die Frage ist nat√ºrlich, wie gro√ü dieser Anteil ist.  Wenn nur die Transaktionen beendet worden w√§ren, die sich nicht mit anderen Transaktionen √ºberschneiden, w√§re es sch√∂n gewesen.  Eine solche Implementierung w√§re jedoch zwangsl√§ufig ressourcenintensiv und ineffizient, da Sie die Vorg√§nge in jeder Zeile verfolgen m√ºssten. <br><br>  Tats√§chlich ist die Implementierung von PostgreSQL so, dass sie falsche Negative zul√§sst: Einige absolut normale Transaktionen, die nur "ungl√ºcklich" sind, werden ebenfalls abgebrochen.  Wie wir sp√§ter sehen werden, h√§ngt dies von vielen Faktoren ab, wie der Verf√ºgbarkeit geeigneter Indizes oder der verf√ºgbaren RAM-Gr√∂√üe.  Dar√ºber hinaus gibt es einige andere (ziemlich schwerwiegende) Implementierungsbeschr√§nkungen, z. B. funktionieren Abfragen auf der Ebene der Serialisierbarkeit nicht f√ºr Replikate und sie verwenden keine parallelen Ausf√ºhrungspl√§ne.  Obwohl die Arbeiten zur Verbesserung der Implementierung fortgesetzt werden, machen die bestehenden Einschr√§nkungen diese Isolationsstufe weniger attraktiv. <br><blockquote>  Parallele Pl√§ne werden bereits in PostgreSQL 12 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Patch</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigt</a> .  Abfragen zu Replikaten k√∂nnen in PostgreSQL 13 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem weiteren Patch</a> ) ausgef√ºhrt werden. <br></blockquote><br><h3>  Schreibgesch√ºtzte Transaktionsanomalie </h3><br>  Damit eine schreibgesch√ºtzte Transaktion nicht zu einer Anomalie f√ºhrt und nicht darunter leidet, bietet PostgreSQL eine interessante Technik: Eine solche Transaktion kann gesperrt werden, bis ihre Ausf√ºhrung sicher ist.  Dies ist der einzige Fall, in dem ein SELECT-Operator durch Zeilenaktualisierungen gesperrt werden kann.  So sieht das aus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">900.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">2</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">3</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> id;</code> </pre><pre> <code class="plaintext hljs"> id | number | client | amount ----+--------+--------+-------- 2 | 2001 | bob | 900.00 3 | 2002 | bob | 100.00 (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 1 =&gt; UPDATE accounts SET amount = amount + ( SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01 WHERE id = 2;</span></span></code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 2 | =&gt; UPDATE accounts SET amount = amount - 100.00 WHERE id = 3; | =&gt; COMMIT;</span></span></code> </pre><br>  Die dritte Transaktion wird ausdr√ºcklich als READ ONLY und DEFERRABLE deklariert: <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ISOLATION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEVEL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SERIALIZABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">READ</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFERRABLE</span></span>; <span class="hljs-comment"><span class="hljs-comment">-- 3 | =&gt; SELECT * FROM accounts WHERE client = 'alice';</span></span></code> </pre><br>  Beim Versuch, die Abfrage auszuf√ºhren, wird die Transaktion gesperrt, da dies sonst zu einer Anomalie f√ºhren w√ºrde. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Und erst nachdem die erste Transaktion festgeschrieben wurde, setzt die dritte die Ausf√ºhrung fort: <br><br><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+-------- | 1 | 1001 | alice | 800.00 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> client = <span class="hljs-string"><span class="hljs-string">'bob'</span></span>;</code> </pre><pre> <code class="plaintext hljs">| id | number | client | amount | ----+--------+--------+---------- | 2 | 2001 | bob | 910.0000 | 3 | 2002 | bob | 0.00 | (2 rows)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Ein weiterer wichtiger Hinweis: Wenn die serialisierbare Isolation verwendet wird, m√ºssen alle Transaktionen in der Anwendung diese Ebene verwenden.  Sie k√∂nnen Read-Committed- (oder Repeatable Read-) Transaktionen nicht mit Serializable mischen.  Das hei√üt, Sie <em>k√∂nnen</em> mischen, aber dann verh√§lt sich Serializable wie "Repeatable Read" ohne Warnungen.  Wir werden sp√§ter diskutieren, warum dies passiert, wenn wir √ºber die Implementierung sprechen. <br><br>  Wenn Sie sich also f√ºr die Verwendung von Serializble entscheiden, ist es am besten, die Standardstufe global festzulegen (obwohl dies Sie nat√ºrlich nicht daran hindert, explizit eine falsche Stufe anzugeben): <br><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SYSTEM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> default_transaction_isolation = <span class="hljs-string"><span class="hljs-string">'serializable'</span></span>;</code> </pre><br><blockquote>  Eine genauere Darstellung der Probleme im Zusammenhang mit Transaktionen, Konsistenz und Anomalien finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Buch-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlesungskurs</a> von Boris Novikov ‚ÄûGrundlagen der Datenbanktechnologien‚Äú (nur in Russion verf√ºgbar). <br></blockquote><br><h1>  Welche Isolationsstufe soll verwendet werden? </h1><br>  Die Read Committed-Isolationsstufe wird in PostgreSQL standardm√§√üig verwendet, und es ist wahrscheinlich, dass diese Stufe in der √ºberwiegenden Mehrheit der Anwendungen verwendet wird.  Diese Standardeinstellung ist praktisch, da auf dieser Ebene ein Transaktionsabbruch nur im Fehlerfall m√∂glich ist, jedoch nicht, um Inkonsistenzen zu vermeiden.  Mit anderen Worten, ein Serialisierungsfehler kann nicht auftreten. <br><br>  Die andere Seite der Medaille ist eine gro√üe Anzahl m√∂glicher Anomalien, die oben ausf√ºhrlich diskutiert wurden.  Der Softwareentwickler muss sie immer im Auge behalten und Code schreiben, damit sie nicht angezeigt werden.  Wenn Sie die erforderlichen Aktionen nicht in einer einzelnen SQL-Anweisung codieren k√∂nnen, m√ºssen Sie auf explizite Sperren zur√ºckgreifen.  Am problematischsten ist, dass es schwierig ist, Code auf Fehler zu testen, die mit dem Abrufen inkonsistenter Daten verbunden sind. Die Fehler selbst k√∂nnen auf unvorhersehbare und nicht reproduzierbare Weise auftreten und sind daher schwer zu beheben. <br><br>  Die Isolationsstufe "Wiederholbares Lesen" beseitigt einige der Inkonsistenzprobleme, aber leider nicht alle.  Daher m√ºssen Sie sich nicht nur an die verbleibenden Anomalien erinnern, sondern auch die Anwendung so √§ndern, dass Serialisierungsfehler korrekt behandelt werden.  Es ist sicherlich unpraktisch.  Bei schreibgesch√ºtzten Transaktionen erg√§nzt diese Ebene jedoch perfekt Read Committed und ist beispielsweise sehr praktisch, um Berichte zu erstellen, die mehrere SQL-Abfragen verwenden. <br><br>  Schlie√ülich k√∂nnen Sie sich auf der Ebene Serializable keine Gedanken √ºber Inkonsistenzen machen, was die Codierung erheblich erleichtert.  Das einzige, was von der Anwendung ben√∂tigt wird, ist die M√∂glichkeit, jede Transaktion zu wiederholen, wenn ein Serialisierungsfehler auftritt.  Der Anteil abgebrochener Transaktionen, der zus√§tzliche Overhead und die Unf√§higkeit, Abfragen zu parallelisieren, k√∂nnen den Systemdurchsatz jedoch erheblich reduzieren.  Beachten Sie au√üerdem, dass die serialisierbare Ebene nicht auf Replikate anwendbar ist und nicht mit anderen Isolationsstufen gemischt werden kann. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467437/">https://habr.com/ru/post/de467437/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467423/index.html">Xamarin.Forms - bequeme Verwendung von Symbolschriftarten in der Anwendung</a></li>
<li><a href="../de467425/index.html">STEM Intensive Learning Approach</a></li>
<li><a href="../de467427/index.html">BudgetTracker - ein weiteres Open-Source-Tool f√ºr die pers√∂nliche Finanzbuchhaltung</a></li>
<li><a href="../de467429/index.html">Habrastatistik: Erkundung der am meisten und am wenigsten besuchten Abschnitte der Website</a></li>
<li><a href="../de467435/index.html">Wir senden Berichte von Veeam Agent Linux per Post oder per Telegramm</a></li>
<li><a href="../de467439/index.html">Warum ist Vinyl zur√ºckgekommen und wie h√§ngen Streaming-Dienste damit zusammen?</a></li>
<li><a href="../de467443/index.html">Multimedia Center "Kodi" und Yocto Project</a></li>
<li><a href="../de467445/index.html">Schwer fassbare Liste der installierten Windows-Updates</a></li>
<li><a href="../de467449/index.html">Erkennung von Schwachstellen und Bewertung der Resistenz gegen Hackerangriffe von Smartcards und Kryptoprozessoren mit integriertem Schutz</a></li>
<li><a href="../de467453/index.html">L√∂sung des Problems der Nummer 42 mit einem planetaren Supercomputer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>