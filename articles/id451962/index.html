<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍💼 🛍️ 👏 Bangun alat dalam proyek pembelajaran mesin, gambaran umum 🎳 🤞🏻 🔅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya bertanya-tanya tentang pembelajaran mesin / struktur proyek sains data / alur kerja dan membaca pendapat yang berbeda tentang subjek tersebut. Da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bangun alat dalam proyek pembelajaran mesin, gambaran umum</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451962/"> Saya bertanya-tanya tentang pembelajaran mesin / struktur proyek sains data / alur kerja dan membaca pendapat yang berbeda tentang subjek tersebut.  Dan ketika orang mulai berbicara tentang alur kerja mereka ingin alur kerja mereka dapat direproduksi.  Ada banyak posting di luar sana yang menyarankan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">make</a> agar alur kerja dapat direproduksi.  Meskipun <code>make</code> sangat stabil dan banyak digunakan, saya pribadi suka solusi lintas platform.  Lagi pula, ini tahun 2019, bukan tahun 1977. Orang dapat berargumen bahwa membuat itu sendiri adalah cross-platform, tetapi pada kenyataannya Anda akan mengalami kesulitan dan akan menghabiskan waktu untuk memperbaiki alat Anda daripada melakukan pekerjaan yang sebenarnya.  Jadi saya memutuskan untuk melihat-lihat dan memeriksa alat apa yang tersedia.  Ya, saya memutuskan untuk meluangkan waktu pada alat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aff/fbf/656/afffbf6566a6e67ea6427d28d76d7eea.png" alt="gambar"></div><br>  Posting ini lebih merupakan undangan untuk dialog daripada tutorial.  Mungkin solusi Anda sempurna.  Jika ya maka akan menarik untuk mendengarnya. <br><br>  Dalam posting ini saya akan menggunakan proyek Python kecil dan akan melakukan tugas otomasi yang sama dengan sistem yang berbeda: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CMake</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pybuilder</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pynt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paver</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lakukan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Luigi</a> </li></ul><br>  Akan ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tabel perbandingan</a> di akhir posting. <br><a name="habracut"></a><br>  Sebagian besar alat saya akan melihat dikenal sebagai <em>membangun perangkat lunak otomatisasi</em> atau <em>membangun sistem</em> .  Ada banyak sekali dari mereka dalam semua rasa, ukuran dan kompleksitas yang berbeda.  Idenya sama: pengembang menetapkan aturan untuk menghasilkan beberapa hasil dengan cara yang otomatis dan konsisten.  Misalnya, hasil mungkin berupa gambar dengan grafik.  Untuk membuat gambar ini, seseorang harus mengunduh data, membersihkan data, dan melakukan beberapa manipulasi data (contoh klasik, sungguh).  Anda dapat mulai dengan beberapa skrip shell yang akan melakukan pekerjaan.  Setelah Anda kembali ke proyek setahun kemudian, akan sulit untuk mengingat semua langkah dan urutan yang harus Anda ambil untuk membuat gambar itu.  Solusi yang jelas adalah mendokumentasikan semua langkah.  Kabar baik!  Membangun sistem memungkinkan Anda mendokumentasikan langkah-langkah dalam bentuk program komputer.  Beberapa sistem build seperti skrip shell Anda, tetapi dengan lonceng dan peluit tambahan. <br><br>  Landasan posting ini adalah serangkaian posting oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mateusz Bednarski</a> tentang alur kerja otomatis untuk proyek pembelajaran mesin.  Mateusz menjelaskan pandangannya dan menyediakan resep untuk menggunakan <code>make</code> .  Saya mendorong Anda untuk pergi dan memeriksa posnya terlebih dahulu.  Saya kebanyakan akan menggunakan kodenya, tetapi dengan sistem build yang berbeda. <br><br>  Jika Anda ingin tahu lebih banyak tentang <code>make</code> , berikut ini adalah referensi untuk beberapa posting.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Brooke Kennedy</a> memberikan ikhtisar tingkat tinggi dalam 5 Langkah Mudah untuk Membuat Proyek Ilmu Data Anda Dapat Diproduksi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Zachary Jones</a> memberikan rincian lebih lanjut tentang sintaks dan kapabilitas bersama dengan tautan ke pos lain.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">David Stevens</a> menulis posting yang sangat hype tentang mengapa Anda benar-benar harus mulai menggunakan <code>make</code> segera.  Dia memberikan contoh yang bagus membandingkan <i>cara lama</i> dan <i>cara baru</i> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Samuel Lampa</a> , di sisi lain, menulis tentang mengapa menggunakan <code>make</code> adalah ide yang buruk. <br><br>  Pilihan sistem bangun saya tidak komprehensif atau tidak bias.  Jika Anda ingin membuat daftar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> mungkin merupakan titik awal yang baik.  Seperti yang dinyatakan di atas, saya akan membahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CMake</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PyBuilder</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pynt</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paver</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">doit</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Luigi</a> .  Sebagian besar alat dalam daftar ini berbasis python dan masuk akal karena proyek ini menggunakan Python.  Posting ini tidak akan membahas cara menginstal alat.  Saya berasumsi bahwa Anda cukup mahir dalam Python. <br><br>  Saya sebagian besar tertarik untuk menguji fungsi ini: <br><br><ol><li>  Menentukan beberapa target dengan dependensi.  Saya ingin melihat bagaimana melakukannya dan betapa mudahnya. </li><li>  Memeriksa apakah build tambahan mungkin dilakukan.  Ini berarti sistem build tidak akan membangun kembali apa yang belum diubah sejak dijalankan terakhir, yaitu Anda tidak perlu mengunduh ulang data mentah Anda.  Hal lain yang saya akan cari adalah membangun bertahap ketika ketergantungan berubah.  Bayangkan kita memiliki grafik dependensi <code>A -&gt; B -&gt; C</code>  Apakah target <code>C</code> akan dibangun kembali jika <code>B</code> berubah?  Jika a? </li><li>  Memeriksa apakah pembangunan kembali akan dipicu jika kode sumber diubah, mis. Kita mengubah parameter grafik yang dihasilkan, lain kali kita membangun gambar harus dibangun kembali. </li><li>  Memeriksa cara-cara membersihkan artefak build, yaitu menghapus file yang telah dibuat selama build dan memutar kembali ke kode sumber bersih. </li></ol><br>  Saya tidak akan menggunakan semua target pembangunan dari pos Mateusz, hanya tiga di antaranya untuk menggambarkan prinsip-prinsip tersebut. <br><br>  Semua kode tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . <br><br><h2><a name="CMake"></a>  CMake </h2><br>  CMake adalah generator skrip build, yang menghasilkan file input untuk berbagai sistem build.  Dan namanya adalah singkatan dari cross-platform make.  CMake adalah alat rekayasa perangkat lunak.  Perhatian utama adalah tentang membangun executable dan perpustakaan.  Jadi CMake tahu bagaimana membangun <i>target</i> dari kode sumber dalam bahasa yang didukung.  CMake dieksekusi dalam dua langkah: konfigurasi dan generasi.  Selama konfigurasi dimungkinkan untuk mengkonfigurasi bangunan masa depan sesuai dengan satu kebutuhan.  Misalnya, variabel yang disediakan pengguna diberikan selama langkah ini.  Pembuatan file biasanya mudah dan menghasilkan file yang dapat digunakan untuk membangun sistem.  Dengan CMake, Anda masih bisa menggunakan <code>make</code> , tetapi alih-alih menulis makefile secara langsung, Anda menulis file CMake, yang akan menghasilkan makefile untuk Anda. <br><br>  Konsep penting lainnya adalah bahwa CMake mendorong <i>pembangunan di luar sumber</i> .  Pembuatan di luar sumber menjauhkan kode sumber dari artefak apa pun yang dihasilkannya.  Ini masuk akal bagi executable di mana basis kode sumber tunggal dapat dikompilasi di bawah arsitektur CPU yang berbeda dan sistem operasi.  Namun, pendekatan ini dapat bertentangan dengan cara kerja banyak ilmuwan data.  Menurut saya komunitas sains data cenderung memiliki data, kode, dan hasil yang tinggi. <br><br>  Mari kita lihat apa yang kita butuhkan untuk mencapai tujuan kita dengan CMake.  Ada dua kemungkinan untuk mendefinisikan hal-hal khusus di CMake: target kustom dan perintah kustom.  Sayangnya kita perlu menggunakan keduanya, yang menghasilkan lebih banyak pengetikan dibandingkan dengan vanila makefile.  Target khusus dianggap selalu ketinggalan zaman, yaitu jika ada target untuk mengunduh data mentah, CMake akan selalu mengunduh ulang.  Kombinasi perintah khusus dengan target kustom memungkinkan untuk menjaga target tetap terbaru. <br><br>  Untuk proyek kami, kami akan membuat file bernama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CMakeLists.txt</a> dan meletakkannya di root proyek.  Mari kita periksa isinya: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">cmake_minimum_required</span></span>(VERSION <span class="hljs-number"><span class="hljs-number">3.14</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> FATAL_ERROR) <span class="hljs-keyword"><span class="hljs-keyword">project</span></span>(Cmake_in_ml VERSION <span class="hljs-number"><span class="hljs-number">0.1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> LANGUAGES NONE)</code> </pre><br>  Bagian ini mendasar.  Baris kedua mendefinisikan nama proyek Anda, versi, dan menentukan bahwa kami tidak akan menggunakan dukungan bahasa bawaan apa pun (karena kami akan memanggil skrip Python). <br><br>  Target pertama kami akan mengunduh dataset IRIS: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(IRIS_URL <span class="hljs-string"><span class="hljs-string">"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"</span></span> CACHE <span class="hljs-keyword"><span class="hljs-keyword">STRING</span></span> <span class="hljs-string"><span class="hljs-string">"URL to the IRIS data"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_DIR <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/raw) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(IRIS_FILE <span class="hljs-variable"><span class="hljs-variable">${IRIS_DIR}</span></span>/iris.csv) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Downloading IRIS."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/download.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_URL}</span></span> <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> <span class="hljs-variable"><span class="hljs-variable">${CMAKE_COMMAND}</span></span> -E echo <span class="hljs-string"><span class="hljs-string">"Done. Checkout ${IRIS_FILE}."</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(rawdata ALL DEPENDS <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span>)</code> </pre><br>  Baris pertama mendefinisikan parameter <code>IRIS_URL</code> , yang diekspos kepada pengguna selama langkah konfigurasi.  Jika Anda menggunakan CMake GUI, Anda dapat mengatur variabel ini melalui GUI: <br><br><img src="https://habrastorage.org/webt/oo/za/pj/oozapjujvjg_q86ndg6r7c5u36a.png"><br><br>  Selanjutnya, kami mendefinisikan variabel dengan lokasi unduhan dataset IRIS.  Kemudian kami menambahkan perintah khusus, yang akan menghasilkan <code>IRIS_FILE</code> sebagai outputnya.  Pada akhirnya, kami menetapkan <code>rawdata</code> target kustom yang bergantung pada <code>IRIS_FILE</code> berarti bahwa untuk membangun <code>rawdata</code> <code>IRIS_FILE</code> harus dibangun.  Opsi <code>ALL</code> dari target kustom mengatakan bahwa <code>rawdata</code> akan menjadi salah satu target default untuk dibangun.  Perhatikan bahwa saya menggunakan <code>CMAKE_CURRENT_SOURCE_DIR</code> untuk menjaga data yang diunduh di folder sumber dan tidak di folder build.  Ini hanya untuk membuatnya sama dengan Mateusz. <br><br>  Baiklah, mari kita lihat bagaimana kita bisa menggunakannya.  Saat ini saya menjalankannya di WIndows dengan kompiler MinGW yang diinstal.  Anda mungkin perlu menyesuaikan pengaturan generator untuk kebutuhan Anda (jalankan <code>cmake --help</code> untuk melihat daftar generator yang tersedia).  Jalankan terminal dan buka folder induk dari kode sumber, lalu: <br><br><pre> <code class="bash hljs">mkdir overcome-the-chaos-build <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> overcome-the-chaos-build cmake -G <span class="hljs-string"><span class="hljs-string">"MinGW Makefiles"</span></span> ../overcome-the-chaos</code> </pre><br><div class="spoiler">  <b class="spoiler_title">hasil</b> <div class="spoiler_text">  - Konfigurasi selesai <br>  - Menghasilkan selesai <br>  - File Build telah ditulis ke: C: / home / workspace / mengatasi-kekacauan-build <br></div></div><br>  Dengan CMake modern kita dapat membangun proyek langsung dari CMake.  Perintah ini akan memanggil <code>build all</code> command: <br><br><pre> <code class="bash hljs">cmake --build .</code> </pre><br><div class="spoiler">  <b class="spoiler_title">hasil</b> <div class="spoiler_text">  Memindai dependensi rawdata target <br>  [100%] Membangun rawdata target <br></div></div><br>  Kami juga dapat melihat daftar target yang tersedia: <br><br><pre> <code class="bash hljs">cmake --build . --target <span class="hljs-built_in"><span class="hljs-built_in">help</span></span></code> </pre><br>  Dan kita dapat menghapus file yang diunduh dengan: <br><br><pre> <code class="bash hljs">cmake --build . --target clean</code> </pre><br>  Lihat bahwa kita tidak perlu membuat target bersih secara manual. <br><br>  Sekarang mari kita pindah ke target berikutnya - data IRIS yang telah diproses.  Mateusz membuat dua file dari satu fungsi: <code>processed.pickle</code> dan <code>processed.xlsx</code> .  Anda dapat melihat bagaimana ia pergi dengan membersihkan file Excel ini dengan menggunakan <code>rm</code> dengan wildcard.  Saya pikir ini bukan pendekatan yang sangat baik.  Di CMake, kami memiliki dua opsi tentang cara menghadapinya.  Opsi pertama adalah menggunakan properti direktori <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ADDITIONAL_MAKE_CLEAN_FILES</a> .  Kode tersebut akan: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(PROCESSED_FILE <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/data/processed/processed.pickle) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Additional files to clean set_property(DIRECTORY PROPERTY ADDITIONAL_MAKE_CLEAN_FILES ${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx )</span></span></code> </pre><br>  Opsi kedua adalah menentukan daftar file sebagai output perintah khusus: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">LIST</span></span>(APPEND PROCESSED_FILE <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.pickle"</span></span> <span class="hljs-string"><span class="hljs-string">"${CMAKE_CURRENT_SOURCE_DIR}/data/processed/processed.xlsx"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/data/preprocess.py <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> data/processed/processed.pickle --excel data/processed/processed.xlsx WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS rawdata <span class="hljs-variable"><span class="hljs-variable">${IRIS_FILE}</span></span> src/data/preprocess.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(preprocess DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span>)</code> </pre><br>  Lihat bahwa dalam kasus ini saya membuat daftar, tetapi tidak menggunakannya di dalam perintah kustom.  Saya tidak tahu cara untuk referensi argumen keluaran perintah kustom di dalamnya. <br><br>  Hal lain yang menarik untuk diperhatikan adalah penggunaan <code>depends</code> dalam perintah khusus ini.  Kami menetapkan ketergantungan tidak hanya dari target kustom, tetapi juga output dan skrip python.  Jika kami tidak menambahkan ketergantungan pada <code>IRIS_FILE</code> , memodifikasi <code>iris.csv</code> secara manual tidak akan menghasilkan pembangunan kembali target <code>preprocess</code> .  Yah, Anda tidak boleh memodifikasi file di direktori build Anda secara manual di tempat pertama.  Hanya memberi tahu Anda.  Lebih detail di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos Sam Thursfield</a> .  Ketergantungan pada skrip python diperlukan untuk membangun kembali target jika skrip python berubah. <br><br>  Dan akhirnya target ketiga: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(EXPLORATORY_IMG <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span>/reports/figures/exploratory.png) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_COMMAND</span></span>(OUTPUT <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMAND</span></span> python src/visualization/exploratory.py <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span> WORKING_DIRECTORY <span class="hljs-variable"><span class="hljs-variable">${CMAKE_CURRENT_SOURCE_DIR}</span></span> DEPENDS <span class="hljs-variable"><span class="hljs-variable">${PROCESSED_FILE}</span></span> src/visualization/exploratory.py ) <span class="hljs-keyword"><span class="hljs-keyword">ADD_CUSTOM_TARGET</span></span>(exploratory DEPENDS <span class="hljs-variable"><span class="hljs-variable">${EXPLORATORY_IMG}</span></span>)</code> </pre><br>  Target ini pada dasarnya sama dengan yang kedua. <br><br>  Untuk menyelesaikan.  CMake terlihat berantakan dan lebih sulit daripada Make.  Memang, banyak orang mengkritik CMake karena sintaksisnya.  Dalam pengalaman saya, pemahaman akan datang dan benar-benar mungkin untuk memahami bahkan file CMake yang sangat rumit. <br><br>  Anda masih akan melakukan banyak pengeleman karena Anda harus melewati variabel yang benar.  Saya tidak melihat cara mudah merujuk keluaran dari satu perintah kustom di perintah lain.  Sepertinya itu mungkin dilakukan melalui target kustom. <br><br><h2><a name="PyBuilder"></a>  Pybuilder </h2><br>  Bagian PyBuilder sangat pendek.  Saya menggunakan Python 3.7 dalam proyek saya dan PyBuilder versi saat ini 0.11.17 tidak mendukungnya.  Solusi yang diusulkan adalah menggunakan versi pengembangan.  Namun versi itu terbatas pada pip v9.  Pip adalah v19.3 pada saat penulisan.  Nyebelin.  Setelah mengotak-atiknya sedikit, itu tidak berhasil sama sekali bagi saya.  Evaluasi PyBuilder adalah yang berumur pendek. <br><br><h2><a name="pynt"></a>  pynt </h2><br>  Pynt adalah berbasis python, yang berarti kita dapat menggunakan fungsi python secara langsung.  Tidak perlu membungkusnya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klik</a> dan untuk menyediakan antarmuka baris perintah.  Namun, pynt juga mampu menjalankan perintah shell.  Saya akan menggunakan fungsi python. <br><br>  Perintah build diberikan dalam file <code>build.py</code> .  Target / tugas dibuat dengan dekorator fungsi.  Ketergantungan tugas diberikan melalui dekorator yang sama. <br><br>  Karena saya ingin menggunakan fungsi python, saya perlu mengimpornya dalam skrip build.  Pynt tidak menyertakan direktori saat ini sebagai skrip python, jadi menulis sesuatu seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  tidak akan bekerja  Yang harus kita lakukan: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys sys.path.append(os.path.join(os.path.dirname(__file__), <span class="hljs-string"><span class="hljs-string">'.'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> src.data.download <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pydownload_file</code> </pre><br>  File <code>build.py</code> awal saya seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python import os import sys sys.path.append(os.path.join(os.path.dirname(__file__), '.')) from pynt import task from path import Path import glob from src.data.download import pydownload_file from src.data.preprocess import pypreprocess iris_file = 'data/raw/iris.csv' processed_file = 'data/processed/processed.pickle' @task() def rawdata(): '''Download IRIS dataset''' pydownload_file('https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data', iris_file) @task() def clean(): '''Clean all build artifacts''' patterns = ['data/raw/*.csv', 'data/processed/*.pickle', 'data/processed/*.xlsx', 'reports/figures/*.png'] for pat in patterns: for fl in glob.glob(pat): Path(fl).remove() @task(rawdata) def preprocess(): '''Preprocess IRIS dataset''' pypreprocess(iris_file, processed_file, 'data/processed/processed.xlsx')</span></span></code> </pre><br>  Dan target <code>preprocess</code> tidak berhasil.  Itu terus-menerus mengeluh tentang argumen input fungsi <code>pypreprocess</code> .  Sepertinya Pynt tidak menangani argumen fungsi opsional dengan sangat baik.  Saya harus menghapus argumen untuk membuat file excel.  Ingatlah ini jika proyek Anda memiliki fungsi dengan argumen opsional. <br><br>  Kami dapat menjalankan pynt dari folder proyek dan mendaftar semua target yang tersedia: <br><br><pre> <code class="bash hljs">pynt -l</code> </pre><br><div class="spoiler">  <b class="spoiler_title">hasil</b> <div class="spoiler_text"><pre> <code class="bash hljs">Tasks <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> build file build.py: clean Clean all build artifacts exploratory Make an image with pairwise distribution preprocess Preprocess IRIS dataset rawdata Download IRIS dataset Powered by pynt 0.8.2 - A Lightweight Python Build Tool.</code> </pre><br></div></div><br>  Mari kita membuat distribusi berpasangan: <br><br><pre> <code class="bash hljs">pynt exploratory</code> </pre><br><div class="spoiler">  <b class="spoiler_title">hasil</b> <div class="spoiler_text"><pre> <code class="bash hljs">[ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] Downloading from https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data to data/raw/iris.csv [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"rawdata"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] Preprocessing data [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"preprocess"</span></span> ] [ build.py - Starting task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ] Plotting pairwise distribution... [ build.py - Completed task <span class="hljs-string"><span class="hljs-string">"exploratory"</span></span> ]</code> </pre><br></div></div><br>  Jika sekarang kita menjalankan perintah yang sama lagi (mis. <code>pynt exploratory</code> ) akan ada pembangunan kembali secara penuh.  Pynt tidak melacak bahwa tidak ada yang berubah. <br><br><h2><a name="Paver"></a>  Paver </h2><br>  Paver terlihat hampir persis seperti Pynt.  Ini sedikit berbeda dengan cara seseorang mendefinisikan ketergantungan antara target (penghias lainnya <code>@needs</code> ).  Paver membuat pembangunan kembali penuh setiap kali dan tidak bermain dengan baik dengan fungsi yang memiliki argumen opsional.  Instruksi pembuatan dapat ditemukan di file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pavement.py</a> . <br><br><h2><a name="doit"></a>  lakukan </h2><br>  Doit sepertinya merupakan upaya untuk membuat alat otomasi yang benar-benar dibangun dengan python.  Itu dapat mengeksekusi kode python dan perintah shell.  Terlihat cukup menjanjikan.  Apa yang tampaknya terlewatkan (dalam konteks tujuan khusus kami) adalah kemampuan untuk menangani ketergantungan antar target.  Katakanlah kita ingin membuat pipa kecil di mana output dari target A digunakan sebagai input dari target B. Dan katakanlah kita menggunakan file sebagai output, jadi target A membuat file bernama <code>outA</code> . <br><br><img src="https://habrastorage.org/webt/xh/te/ol/xhteolpanywbjxanltb8uxdsoly.png"><br><br>  Untuk membuat pipeline seperti itu, kita perlu menentukan file <code>outA</code> dua kali dalam target A (sebagai hasil dari target, tetapi juga mengembalikan namanya sebagai bagian dari eksekusi target).  Maka kita perlu menentukannya sebagai input untuk target B. Jadi ada 3 tempat secara total di mana kita perlu memberikan informasi tentang file <code>outA</code> .  Dan bahkan setelah kita melakukannya, modifikasi file <code>outA</code> tidak akan mengarah ke pembangunan kembali otomatis target B. Ini berarti bahwa jika kita meminta doit untuk membangun target B, doit hanya akan memeriksa apakah target B up-to-date tanpa memeriksa apa pun dari dependensi.  Untuk mengatasinya, kita perlu menentukan <code>outA</code> 4 kali - juga sebagai ketergantungan file target B. Saya melihat ini sebagai kekurangan.  Baik Make dan CMake mampu menangani situasi seperti itu dengan benar. <br><br>  Ketergantungan dalam doit berbasis file dan dinyatakan sebagai string.  Ini berarti dependensi <code>./myfile.txt</code> dan <code>myfile.txt</code> dipandang berbeda.  Seperti yang saya tulis di atas, saya menemukan cara menyampaikan informasi dari target ke target (ketika menggunakan target python) agak aneh.  Target memiliki daftar artefak yang akan diproduksi, tetapi target lain tidak dapat menggunakannya.  Sebaliknya fungsi python, yang merupakan target, harus mengembalikan kamus, yang dapat diakses di target lain.  Mari kita lihat pada contoh: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">task_preprocess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Preprocess IRIS dataset"""</span></span> pickle_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.pickle'</span></span> excel_file = <span class="hljs-string"><span class="hljs-string">'data/processed/processed.xlsx'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-string"><span class="hljs-string">'file_dep'</span></span>: [<span class="hljs-string"><span class="hljs-string">'src/data/preprocess.py'</span></span>], <span class="hljs-string"><span class="hljs-string">'targets'</span></span>: [pickle_file, excel_file], <span class="hljs-string"><span class="hljs-string">'actions'</span></span>: [doit_pypreprocess], <span class="hljs-string"><span class="hljs-string">'getargs'</span></span>: {<span class="hljs-string"><span class="hljs-string">'input_file'</span></span>: (<span class="hljs-string"><span class="hljs-string">'rawdata'</span></span>, <span class="hljs-string"><span class="hljs-string">'filename'</span></span>)}, <span class="hljs-string"><span class="hljs-string">'clean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, }</code> </pre><br>  Di sini <code>preprocess</code> target tergantung pada data <code>rawdata</code> .  Ketergantungan diberikan melalui properti <code>getargs</code> .  Dikatakan bahwa argumen <code>input_file</code> dari fungsi <code>doit_pypreprocess</code> adalah <code>filename</code> keluaran dari <code>rawdata</code> target.  Lihat contoh lengkap di file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dodo.py.</a> <br><br>  Mungkin ada baiknya membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kisah sukses</a> menggunakan doit.  Ini pasti memiliki fitur-fitur bagus seperti kemampuan untuk memberikan pemeriksaan target kustom terbaru. <br><br><h2><a name="Luigi"></a>  Luigi </h2><br>  Luigi tetap terpisah dari alat-alat lain karena merupakan sistem untuk membangun jaringan pipa yang kompleks.  Itu muncul di radar saya setelah seorang rekan mengatakan kepada saya bahwa ia mencoba Make, tidak pernah dapat menggunakannya di Windows / Linux dan pindah ke Luigi. <br><br>  Luigi bertujuan untuk sistem yang siap produksi.  Itu datang dengan server, yang dapat digunakan untuk memvisualisasikan tugas Anda atau untuk mendapatkan riwayat pelaksanaan tugas.  Server disebut <em>pusat schedler</em> .  Penjadwal lokal tersedia untuk tujuan debugging. <br><br>  Luigi juga berbeda dari sistem lain dengan cara bagaimana tugas dibuat.  Lugi tidak bertindak pada beberapa file yang telah ditentukan (seperti <code>dodo.py</code> , <code>pavement.py</code> atau makefile).  Sebaliknya, kita harus melewati nama modul python.  Jadi, jika kita mencoba menggunakannya dengan cara yang mirip dengan alat lain (menempatkan file dengan tugas di root proyek), itu tidak akan berfungsi.  Kita harus menginstal proyek kita atau memodifikasi variabel lingkungan <code>PYTHONPATH</code> dengan menambahkan path ke proyek. <br><br>  Apa yang hebat tentang luigi adalah cara menentukan ketergantungan antar tugas.  Setiap tugas adalah kelas.  <code>output</code> metode memberi tahu Luigi di mana hasil tugas akan berakhir.  Hasil dapat berupa elemen tunggal atau daftar.  Metode <code>requires</code> menentukan dependensi tugas (tugas lain; walaupun dimungkinkan untuk membuat dependensi dari dirinya sendiri).  Dan itu saja.  Apa pun yang ditentukan sebagai <code>output</code> dalam tugas A akan diteruskan sebagai input ke tugas B jika tugas B bergantung pada tugas A. <br><img src="https://habrastorage.org/getpro/habr/post_images/ba2/95c/bb9/ba295cbb9b744767e709aa7b3a0e358f.png"><br><br>  Luigi tidak peduli dengan modifikasi file.  Itu peduli tentang keberadaan file.  Jadi tidak mungkin untuk memicu pembangunan kembali ketika kode sumber berubah.  Luigi tidak memiliki fungsionalitas <i>bersih</i> bawaan. <br><br>  Tugas Luigi untuk proyek ini tersedia dalam file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">luigitasks.py</a> .  Saya menjalankannya dari terminal: <br><br><pre> <code class="plaintext hljs">luigi --local-scheduler --module luigitasks Exploratory</code> </pre><br><h2><a name="Comparison"></a>  Perbandingan </h2><br>  Tabel di bawah ini merangkum bagaimana sistem yang berbeda bekerja sehubungan dengan tujuan spesifik kami. <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Tetapkan target dengan ketergantungan </th><th>  Membangun bertahap </th><th>  Build tambahan jika kode sumber diubah </th><th>  Kemampuan untuk mencari tahu artefak mana yang harus dihapus selama perintah <code>clean</code> </th></tr><tr><td>  <strong>CMake</strong> </td><td>  iya </td><td>  iya </td><td>  iya </td><td>  iya </td></tr><tr><td>  <strong>Pynt</strong> </td><td>  iya </td><td>  tidak </td><td>  tidak </td><td>  tidak </td></tr><tr><td>  <strong>Paver</strong> </td><td>  iya </td><td>  tidak </td><td>  tidak </td><td>  tidak </td></tr><tr><td>  <strong>lakukan</strong> </td><td>  Agaknya ya </td><td>  iya </td><td>  iya </td><td>  iya </td></tr><tr><td>  <strong>Luigi</strong> </td><td>  iya </td><td>  tidak </td><td>  tidak </td><td>  tidak </td></tr></tbody></table></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451962/">https://habr.com/ru/post/id451962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451950/index.html">Pembangkit listrik virtual. Apakah mungkin untuk mengelola sumber energi "hijau"?</a></li>
<li><a href="../id451954/index.html">Lebih Banyak Telegram Rahasia</a></li>
<li><a href="../id451956/index.html">Menggunakan AppDynamics dengan Red Hat OpenShift v3</a></li>
<li><a href="../id451958/index.html">Kami menonton torrent di TV pintar tanpa SMS dan registrasi</a></li>
<li><a href="../id451960/index.html">90 Kerentanan Eksekusi Kode Jarak Jauh di Pembaruan Mei, Selasa</a></li>
<li><a href="../id451966/index.html">Perangkat I / O modern lebih cepat daripada prosesor. Tinjauan Artikel</a></li>
<li><a href="../id451968/index.html">3D Academy Terbaik - pelatihan teknologi aditif di perusahaan Rusia terkemuka</a></li>
<li><a href="../id451970/index.html">Thrangrycat: kerentanan kritis dalam firmware perangkat Cisco memungkinkan peretas untuk menginstal backdoors pada mereka</a></li>
<li><a href="../id451972/index.html">QuadCast - Kedengarannya Nyata</a></li>
<li><a href="../id451974/index.html">Sejarah AMD: 50 Tahun Perkembangan Pesat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>