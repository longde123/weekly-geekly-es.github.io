<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚔 🤹🏿 🏂🏻 Scier les données confortablement 🧑🏼 🛥️ 👨🏼‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour. 

 Dans la pratique, vous rencontrez souvent des tâches qui sont loin d'être des algorithmes ML complexes, mais en même temps non moins impor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Scier les données confortablement</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438556/"><img src="https://habrastorage.org/webt/im/nm/mx/imnmmxqmywsjq2wirence45dz4g.jpeg" alt="image"><br><br>  Bonjour. <br><br>  Dans la pratique, vous rencontrez souvent des tâches qui sont loin d'être des algorithmes ML complexes, mais en même temps non moins importantes et urgentes pour l'entreprise. <br>  Parlons de l'un d'eux. <br><br>  La tâche se résume à distribuer (sciage, rasplitovat - le jargon de l'entreprise est inépuisable) les données d'une table cible avec des agrégats (valeurs agrégées) sur une table de granularité plus détaillée. <br><br>  Par exemple, le service commercial doit décomposer le plan annuel convenu au niveau de la marque - en détail pour les produits, pour que les spécialistes du marketing décomposent le budget marketing annuel par pays, le service de planification et économique pour décomposer les dépenses commerciales générales par centres de responsabilité financière, etc.  etc. <br><br>  Si vous sentez que des tâches comme celle-ci se profilent déjà devant vous à l'horizon ou traitent déjà ceux qui ont souffert de telles tâches, alors je demande un chat. <br><a name="habracut"></a><br>  Prenons un exemple réel: <br><br>  Ils abaissent le plan de vente comme une tâche comme dans l'image ci-dessous (j'ai intentionnellement simplifié l'exemple, en réalité - une bannière Excel de 100-200 Mo). <br><br>  Explication de la rubrique: <br><br><ul><li>  pos_terr-territoire (région) du débouché </li><li>  pos_fo - le district fédéral du point de vente (par exemple, le district fédéral central et le district fédéral central) </li><li>  product_brend - marque de produit </li><li>  product_class - classe de produit </li><li>  plan.sales est un plan de vente pour tout. </li></ul><br><img src="https://habrastorage.org/webt/wc/2t/n5/wc2tn5wplux5kjawucs4gpl5ey8.png" alt="image"><br><br>  Et ils demandent, par exemple, de casser leur méga-table (dans le cadre de l'exemple de nos enfants, c'est bien sûr plus modeste) - au canal de vente.  A la question - selon quelle logique se décomposer, j'obtiens la réponse: «mais prenez les statistiques des ventes réelles pour le 4ème trimestre de telle ou telle année, obtenez les parts réelles des canaux en% pour chaque ligne du plan et décomposez ces parties de la ligne du plan». <br>  En fait, c'est la réponse la plus fréquente dans de telles tâches ... <br><br>  Jusqu'à présent, tout semble assez simple. <br><br>  Je comprends ce fait (voir l'image ci-dessous): <br><br><ul><li>  pos_channell - canal de vente (attribut cible pour le plan) </li><li>  fact.sales - ventes réelles de quelque chose. </li></ul><br><img src="https://habrastorage.org/webt/8t/uo/pn/8tuopnzhdexvdz9cq2c6sqftgxc.png" alt="image"><br><br>  Sur la base de l'approche obtenue du "sciage" sur l'exemple de la première ligne du plan, nous le décomposerons sur la base du fait quelque chose comme ceci: <br><br><img src="https://habrastorage.org/webt/b9/ib/q0/b9ibq06zbezjvfhsf5gxkeoba4s.png" alt="image"><br><br>  Cependant, si nous comparons le fait avec le plan pour la plaque entière afin de comprendre si toutes les lignes du plan peuvent être correctement «coupées» en parts, nous obtenons l'image suivante: (vert - tous les attributs de la ligne du plan coïncident avec le fait, les cellules jaunes ne correspondent pas). <br><br><img src="https://habrastorage.org/webt/tp/vm/ta/tpvmtayhezx1cou7359wqzmds3c.png" alt="image"><br><br><ul><li>  Dans la 1ère ligne du plan, tous les champs se trouvent complètement dans le fait. </li><li>  Dans la 2ème ligne du plan, le territoire correspondant n'a pas été trouvé dans le fait </li><li>  La 3ème ligne du plan ne suffit pas dans le fait de la marque </li><li>  La 4ème ligne du plan ne suffit pas dans le fait du territoire et du district fédéral </li><li>  La 5ème ligne du plan manque en fait de marque et de classe. </li></ul><br>  Comme l'a dit Panikovsky: "J'ai vu la Shura, vu - ils sont en or ..." <br><br><img src="https://habrastorage.org/webt/m3/v0/ig/m3v0ig5ao9agopnt9-7tthegaiu.jpeg" alt="image"><br><br>  Je vais chez le client professionnel et clarifie sur l'exemple de la 2ème ligne, quel type d'approche voit-il pour de telles situations? <br><br>  J'obtiens la réponse: «pour les cas où il n'est pas possible de calculer la part des canaux pour la marque n ° 2 dans la région de Smolensk (en tenant compte du fait que nous avons la région de Smolensk dans le district fédéral central-district fédéral central) - alors rompez cette ligne en fonction de la structure des canaux dans l'ensemble du district fédéral central!» <br><br>  Autrement dit, pour {Smolensk region + brand_2}, nous agrégons le fait au niveau du district fédéral central et divisons la région de Smolensk quelque chose comme ceci: <br><br><img src="https://habrastorage.org/webt/2t/pf/i1/2tpfi18n14-qytt76pydyjjwnfs.png" alt="image"><br><br>  En remontant et en digérant ce que j'ai entendu, j'essaie de généraliser à une heuristique plus universelle: <br>  S'il n'y a pas de données au niveau de détail actuel de la table de faits, puis avant de calculer les parts pour le champ cible (canal de vente), nous agrégons la table de faits jusqu'à l'attribut de hiérarchie ci-dessus. <br><br>  Autrement dit, si ce n'est pour le territoire, nous agrégons le fait à un niveau de hiérarchie plus élevé - parts pour le même district fédéral central que dans le plan.  Si ce n'est pas pour la marque, alors dans la hiérarchie ci-dessus, il y a une classe de produits - en conséquence, nous recomptons les actions pour la même classe et ainsi de suite. <br><br>  C'est-à-dire  on combine le plan et le fait sur les champs de couplage dont on considère les parts dans le fait et à chaque itération selon le plan non distribué restant, on réduit successivement la composition des champs de couplage. <br><br>  Un certain modèle de distribution de données se profile déjà ici: <br><br><ol><li>  Nous distribuons en fait le plan basé sur la coïncidence complète des champs correspondants </li><li>  Nous obtenons un plan cassé (nous l'accumulons dans le résultat intermédiaire) et un plan ininterrompu (toutes les lignes ne correspondent pas) </li><li>  Nous prenons un plan ininterrompu et le divisons en fait à un niveau de hiérarchie supérieur (c'est-à-dire que nous abandonnons un certain champ de couplage de ces 2 tables et agrégons le fait sans ce champ pour calculer les parts) </li><li>  Nous obtenons un plan cassé (nous l'ajoutons au résultat intermédiaire) et un plan ininterrompu (toutes les lignes ne correspondent pas) </li><li>  Et nous répétons les mêmes étapes jusqu'à ce qu'il n'y ait pas de plan «non résolu». </li></ol><br>  En général, personne ne nous oblige à supprimer systématiquement les champs d'attelage uniquement dans la hiérarchie.  Par exemple, nous avons déjà supprimé la marque et le territoire des champs d'attelage et distribué le plan restant par: product_class (hiérarchie au-dessus de la marque) + Fed.krug (hiérarchie au-dessus du territoire).  Et encore obtenu un certain solde non alloué du plan. <br><br>  En outre, nous pouvons supprimer des champs de couplage soit la classe de produits, soit le district fédéral, comme  ils ne sont plus intégrés dans la hiérarchie de l'autre. <br><br>  Étant donné qu'il y a des dizaines et des rangées de champs dans de telles tables - jusqu'à un million faisant de telles manipulations avec vos mains - la tâche n'est pas la plus agréable. <br><br>  Et étant donné que des tâches de ce genre me viennent régulièrement à la fin de chaque année (approuver les budgets de l'année suivante au conseil d'administration), vous avez dû traduire ce processus en une sorte de modèle universel flexible. <br><br>  Et comme la plupart du temps, je travaille avec des données via R - l'implémentation est donc la même. <br><br>  Tout d'abord, nous devons écrire une fonction magique universelle qui prendra une table de base (basetab) avec des données pour une ventilation (dans notre exemple, un plan) et une table de calcul des parts (sharetab) sur la base desquelles nous "verrons" les données (dans notre exemple, fait).  Mais la fonction doit également comprendre ce qui doit être fait avec ces objets, donc la fonction acceptera également le vecteur des noms des champs de couplage (merge.vrs) - c'est-à-dire  ces champs qui sont nommés de manière identique dans les deux tables et nous permettront de connecter une table avec les autres champs où elle fonctionne (c'est-à-dire la jointure droite).  En outre, la fonction doit comprendre quelle colonne de la table de base doit être prise dans la distribution (basetab.value) et en fonction du champ pour compter les partages (sharetab.value).  Eh bien, et le plus important - ce qu'il faut prendre pour le champ résultant (sharetab.targetvars), dans notre cas, nous voulons détailler le plan via le canal de vente. <br><br>  Par ailleurs, cette variable sharetab.targetvars n'est pas aléatoire au pluriel - il peut ne pas s'agir d'un champ mais d'un vecteur de noms de champ, dans les cas où vous devez ajouter non pas un champ à la table de base de la table de partage mais plusieurs à la fois (par exemple, en fonction du fait, vous ne pouvez pas diviser le plan uniquement par le canal de vente mais aussi par le nom des produits inclus dans la marque). <br><br>  Oui, et encore une condition :) ma fonction doit être aussi localiste et lisible que possible, sans bâtiment à plusieurs étages sur 2 écrans (je n'aime vraiment pas les grandes fonctions). <br><br>  Dans la dernière condition, le package dplyr populaire s'intègre aussi confortablement que possible et compte tenu du fait que ses opérateurs de pipeline doivent comprendre les noms textuels des champs qui ont été abaissés dans la fonction, il ne peut pas se passer de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">évaluation Standart</a> . <br><br>  Voici ce bébé (sans compter les commentaires internes): <br><br><pre><code class="plaintext hljs">fn_distr &lt;- function(sharetab, sharetab.value, sharetab.targetvars, basetab, basetab.value, merge.vrs,level.txt=NA) { # sharetab - =   # sharetab.value -            - # sharetab.targetvars -      -          # basetab - =      # basetab.value -         # merge.vrs -    2-  # level.txt -    .       (     merge.vrs) require(dplyr) sharetab.value &lt;- as.name(sharetab.value) basetab.value &lt;- as.name(basetab.value) if(is.na(level.txt )){level.txt &lt;- paste0(merge.vrs,collapse = ",")} result &lt;- sharetab %&gt;% group_by(.dots = c(merge.vrs, sharetab.targetvars)) %&gt;% summarise(sharetab.sum = sum(!!sharetab.value)) %&gt;% ungroup %&gt;% group_by(.dots = merge.vrs) %&gt;% mutate(sharetab.share = sharetab.sum / sum(sharetab.sum)) %&gt;% ungroup %&gt;% right_join(y = basetab, by = merge.vrs) %&gt;% mutate(distributed.result = !!basetab.value * sharetab.share, level = level.txt) %&gt;% select(-sharetab.sum,-sharetab.share) return(result) }</code> </pre> <br>  En sortie, la fonction doit renvoyer data.frame de l'union de deux tables avec les lignes du plan + fait où il était possible de diviser le plan sur la version actuelle des champs de couplage, et avec les lignes d'origine du plan (et le fait vide) dans les lignes où le plan n'a pas pu être divisé dans l'itération en cours. <br><br>  Autrement dit, le résultat renvoyé par la fonction après la première itération (briser la première ligne du plan pour la région de Yaroslavl) ressemblera à ceci: <br><br><img src="https://habrastorage.org/webt/zr/jy/nz/zrjynzehck-sb3mv1bysenaixde.png" alt="image"><br><br>  De plus, ce résultat peut être pris par un résultat distribué non vide dans le résultat cumulatif et par un résultat distribué (NA) vide - envoyé à l'itération typique suivante, mais ventilé par part à un niveau hiérarchique supérieur. <br><br>  Tout le charme et toute la commodité est que le travail est effectué dans le même type de blocs et une fonction universelle, tout ce qui est nécessaire à chaque étape (itération) est de corriger le vecteur merge.vrs et d'observer comment la magie fait tout ce travail fastidieux pour vous: <br><br><img src="https://habrastorage.org/webt/rb/7x/hb/rb7xhby_9ztkha0hwfjfysslxaq.jpeg" alt="image"><br><br>  Oui, j'ai presque oublié une petite nuance: si quelque chose se passe mal et à la fin, nous obtenons un plan cassé qui au total ne sera pas égal au plan avant la panne, il sera difficile de suivre à quelle itération tout s'est mal passé. <br><br>  Par conséquent, nous fournissons à chaque itération une somme de contrôle: <br><br><pre> <code class="plaintext hljs">(_)-(___ )-(___.)=0</code> </pre> <br>  Essayons maintenant d'exécuter notre exemple dans le modèle de distribution et de voir ce que nous obtenons à la sortie. <br><br>  Tout d'abord, récupérez les données source: <br><br><pre> <code class="plaintext hljs">library(dplyr) plan &lt;- data_frame(pos_terr = c(" ", " ", " ", " ", " "), pos_fo = c("", "", "", "", ""), product_brend = c("brend_1", "brend_2", "brend_3", "brend_4", "brend_5"), product_class = c("class_1", "class_1", "class_2", "class_2", "class_3"), plan.sales = c(100, 200, 300, 400, 500)) fact &lt;- data_frame(pos_terr = c(" ", " ", " ", " ", " "," ", " ", " ", " ", " "), pos_fo = c("", "","","", "", "", "", "", "", ""), product_brend = c("brend_1", "brend_1", "brend_2", "brend_2","brend_2", "brend_4", "brend_4", "brend_1", "brend_2", "brend_4"), product_class = c("class_1", "class_1", "class_1","class_1","class_1", "class_2", "class_2", "class_1", "class_1", "class_2"), pos_channell = c("", "", "","", "", "", "", "", "", ""), fact.sales = c(16.38, 11.64, 30.73,60, 20, 6.40, 26.49, 46.63, 65.96, 98.81)) &lt;/soure&gt;      (   )     . &lt;source&gt; plan.remain &lt;- plan result.total &lt;- data_frame()</code> </pre><br>  <b>1. Nous distribuons par Terr, FD (district fédéral), marque, classe</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_terr","pos_fo","product_brend", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) #     -      plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) #            =    cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre> <br><img src="https://habrastorage.org/webt/84/zv/zq/84zvzqtilnk4mbdvkntjpf43lls.png" alt="image"><br><br>  <b>2. Nous distribuons par pho, marque, classe (c'est-à-dire que nous abandonnons le territoire en fait)</b> <br><br>  La seule différence avec le premier bloc est qu'ils ont légèrement raccourci merge.fields en supprimant pos_terr dedans <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_fo","product_brend", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  <b>3. Distribuer par pho, classe</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c("pos_fo", "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  <b>4. Distribuer par classe</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c( "product_class") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre> <br><img src="https://habrastorage.org/webt/fe/-q/nd/fe-qnd2szmr7giomwxnliujddha.png" alt="image"><br><br>  <b>5. Distribuer par FD</b> <br><br><pre> <code class="plaintext hljs">merge.fields &lt;- c( "pos_fo") result.current &lt;- fn_distr(sharetab = fact,sharetab.value = "fact.sales",sharetab.targetvars = "pos_channell", basetab = plan.remain,basetab.value = "plan.sales",merge.vrs = merge.fields) result.total &lt;- result.current %&gt;% filter(!is.na(distributed.result)) %&gt;% select(-plan.sales) %&gt;% bind_rows(result.total) plan.remain &lt;- result.current %&gt;% filter(is.na(distributed.result)) %&gt;% select(colnames(plan)) cat(" :",sum(plan.remain$plan.sales)+sum(result.total$distributed.result)-sum(plan$plan.sales),"\n", " :",nrow(plan.remain)," ")</code> </pre><br>  Comme vous pouvez le voir, il n'y a plus de plan «non scié» et l'arithmétique du plan distribué est égale à celle d'origine. <br><br><img src="https://habrastorage.org/webt/bb/cz/-e/bbcz-enxlpsnwnji6atftwle1tg.png" alt="image"><br><br>  Et voici le résultat avec les canaux de vente (dans la colonne de droite, la fonction affiche les champs pour lesquels le couplage / agrégation était destiné, afin que nous puissions plus tard comprendre d'où venait cette distribution): <br><br><img src="https://habrastorage.org/webt/l_/3t/fg/l_3tfgj9v2hvsflh_q18o8l2cbo.png" alt="image"><br><br>  C'est tout.  L'article n'était pas très petit, mais il y a plus de texte explicatif que le code lui-même. <br><br>  J'espère que cette approche flexible me fera gagner du temps et des nerfs non seulement :-) <br><br>  Merci de votre attention. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr438556/">https://habr.com/ru/post/fr438556/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr438544/index.html">Nous regardons des films à la maison: 10 documents sur la construction d'un home cinéma et le choix de l'équipement</a></li>
<li><a href="../fr438546/index.html">Analyse des approches de liaison de modules dans Node.js</a></li>
<li><a href="../fr438548/index.html">Lombok, sources.jar et débogage pratique</a></li>
<li><a href="../fr438550/index.html">Un autre manifeste</a></li>
<li><a href="../fr438554/index.html">Gestion de l'état et des événements entre les composants de GameObject</a></li>
<li><a href="../fr438560/index.html">Écrire XGBoost à partir de zéro - partie 1: arbres de décision</a></li>
<li><a href="../fr438562/index.html">Écrire XGBoost à partir de zéro - partie 2: renforcement du gradient</a></li>
<li><a href="../fr438566/index.html">Boîtier pour microprocesseur Apple Strange A12X</a></li>
<li><a href="../fr438568/index.html">À propos des ordinateurs quantiques: comment différents pays développent cette technologie</a></li>
<li><a href="../fr438570/index.html">Concours du Nouvel An du CS Center 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>