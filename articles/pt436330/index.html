<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÜüèº ü•ú üë©‚Äçüë©‚Äçüëß‚Äçüë¶ Criando um jogo para o Game Boy üë®‚Äçüë¶‚Äçüë¶ üëºüèº ü§Ø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algumas semanas atr√°s, eu decidi trabalhar em um jogo para o Game Boy, cuja cria√ß√£o me deu um grande prazer. Seu nome de trabalho √© Aqua and Ashes. O ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando um jogo para o Game Boy</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436330/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/913/597/052/91359705210df58524bc0e6c9e9955a8.png" alt="imagem"></div><br>  Algumas semanas atr√°s, eu decidi trabalhar em um jogo para o Game Boy, cuja cria√ß√£o me deu um grande prazer.  Seu nome de trabalho √© Aqua and Ashes.  O jogo tem c√≥digo aberto e √© postado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> . <br><br><h2>  Como essa ideia me veio √† mente </h2><br>  Recentemente, consegui um emprego de est√°gio criando um back-end em PHP e Python para o site da minha universidade.  Este √© um trabalho bom e interessante, pelo qual sou muito grato.  Mas ... ao mesmo tempo, todo esse c√≥digo de desenvolvimento da Web de alto n√≠vel me infectou com um desejo insaci√°vel.  E era o desejo de um trabalho de baixo n√≠vel com bits. <br><br>  Eu recebia um resumo semanal do itch.io sobre compotas de jogos, no qual o lan√ßamento do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mini Jam 4 era</a> anunciado.  Foi um engarrafamento de 48 horas (bem, na verdade, um pouco maior), no qual a limita√ß√£o era criar gr√°ficos no estilo de Game Boy.  Minha primeira rea√ß√£o l√≥gica foi criar um jogo homebrew para Game Boy.  O tema da gel√©ia era "esta√ß√µes" e "chama". <br><br>  Depois de pensar um pouco sobre o enredo e a mec√¢nica que podem ser implementados em 48 horas e que se encaixam nas limita√ß√µes do t√≥pico, <s>criei</s> um <s>clone de uma</s> nova interpreta√ß√£o do n√≠vel do jogo SNES de 1993 Tiny Toon Adventures: Buster Busts Loose !, em que o jogador no papel de Baster joga futebol americano . <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XmyJZkJ-zeA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Eu sempre gostei de como os criadores deste n√≠vel adotaram um esporte incrivelmente complexo, se livraram de todos os truques, posi√ß√µes e elementos estrat√©gicos, resultando em um jogo extremamente interessante e f√°cil.  Obviamente, uma vis√£o t√£o simplificada do futebol americano n√£o substituir√° Madden, assim como o NBA Jam (uma id√©ia semelhante: apenas 4 jogadores em um campo muito menor com uma jogabilidade mais direta do que em um jogo normal) n√£o substituir√° a s√©rie 2K.  Mas essa id√©ia tem um certo charme, e os n√∫meros de vendas da NBA Jam confirmam isso. <br><br>  Como tudo isso se relaciona com a minha ideia?  Decidi pegar esse n√≠vel de futebol e refaz√™-lo para que ele permane√ßa semelhante ao original e, ao mesmo tempo, atual.  Primeiro, reduzi o jogo para apenas quatro jogadores - um defensor e um atacante.  Isso foi feito principalmente devido √†s limita√ß√µes do hardware, mas, ao mesmo tempo, permitir√° que eu experimente um pouco mais com uma IA mais inteligente, n√£o se limitando ao princ√≠pio de "correr para a esquerda e √†s vezes pular" de jogar no SNES. <br><br>  Por uma quest√£o de conformidade com o t√≥pico, substituirei os port√µes por colunas em chamas, ou por fogueiras, ou algo assim (ainda n√£o decidi) e a bola de futebol por tochas e baldes de √°gua.  O vencedor ser√° o time que controla as duas fogueiras, e em torno deste conceito simples voc√™ pode facilmente criar uma trama.  As esta√ß√µes tamb√©m s√£o levadas em considera√ß√£o: decidi que as esta√ß√µes mudariam a cada turno, para que a equipe de bombeiros obtenha vantagem no ver√£o e a equipe de bombeiros no inverno.  Essa vantagem parece obst√°culos no campo que interferem apenas na equipe advers√°ria. <br><br>  Obviamente, ao criar duas equipes, eram necess√°rios dois animais que amam e n√£o gostam de fogo.  No come√ßo, pensei em formigas de fogo e algum tipo de inseto aqu√°tico, louva-a-deus e coisas do g√™nero, mas, tendo estudado a quest√£o, n√£o encontrei nenhum inseto ativo no inverno, ent√£o substitu√≠-os por raposas polares e lagartixas.  Raposas polares gostam de neve, lagartixas gostam de se deitar ao sol, ent√£o tudo parece l√≥gico.  No final, √© apenas um jogo para o Game Boy. <br><br>  Al√©m disso, caso isso ainda n√£o esteja claro, no final do congestionamento, o jogo n√£o estava quase completo.  Enfim, foi divertido de qualquer maneira. <br><br><h2>  Treinamento de Game Boy </h2><br>  Primeiro voc√™ precisa determinar os requisitos.  Decidi escrever para o DMG (nome interno do modelo Game Boy, abrevia√ß√£o de Dot Matrix Game).  Principalmente para atender aos requisitos de um congestionamento de jogo, mas tamb√©m porque eu realmente queria.  Pessoalmente, nunca tive jogos para DMG (embora existam v√°rios jogos para Game Boy Color), mas acho que a est√©tica de 2 bits √© uma limita√ß√£o muito agrad√°vel e interessante para experimentos.  Talvez eu adicione cores adicionais para SGB e CGB, mas at√© agora n√£o pensei nisso. <br><br>  Tamb√©m decidi usar um cartucho com 32K ROM + sem RAM, para o caso de querer criar uma c√≥pia f√≠sica do jogo.  CatSkull, que publicou v√°rios jogos de Game Boy, como Sheep it Up !, tem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cartuchos de flash de 32 kilobytes muito baratos √† venda,</a> perfeitos para mim.  Essa √© outra limita√ß√£o adicional, mas n√£o acho que em um futuro pr√≥ximo eu possa superar o volume de 32K com um jogo t√£o simples.  O mais dif√≠cil ser√° com os gr√°ficos e, se tudo estiver completamente ruim, tentarei compact√°-lo. <br><br>  Quanto ao trabalho de Game Boy, tudo √© bastante complicado.  No entanto, para ser sincero, de todos os retro-consoles com os quais tive que trabalhar, o Game Boy foi o mais agrad√°vel.  Comecei com um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">excelente tutorial</a> (pelo menos pela primeira vez, porque nunca foi conclu√≠do) pelo autor do AssemblyDigest.  Eu sabia que √© melhor escrever em ASM, por mais doloroso que seja, √†s vezes, porque o hardware n√£o √© projetado para C e eu n√£o tinha certeza de que a linguagem legal que o Wiz mencionada no tutorial seria adequada a longo prazo.  Al√©m disso, fa√ßo isso principalmente porque <em>posso</em> trabalhar com o ASM. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Verifique o commit 8c0a4ea</a> <br><br>  A primeira coisa a fazer foi iniciar o Game Boy.  Se o logotipo da Nintendo n√£o for encontrado com uma compensa√ß√£o de <code>$104</code> e o restante do cabe√ßalho n√£o estiver configurado corretamente, o equipamento Game Boy assumir√° que o cartucho foi inserido incorretamente e se recusar√° a carregar.  Resolver esse problema √© muito simples, porque muitos tutoriais j√° foram escritos sobre isso.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui est√° como eu resolvi o problema do cabe√ßalho.</a>  N√£o h√° nada digno de aten√ß√£o especial. <br><br>  Ser√° mais dif√≠cil executar a√ß√µes significativas ap√≥s o carregamento.  √â muito simples fazer com que o sistema entre em um ciclo ocupado infinito, no qual executa uma linha de c√≥digo repetidamente.  A execu√ß√£o do c√≥digo come√ßa com o r√≥tulo <code>main</code> (onde o salto para o endere√ßo <code>$100</code> indica), ent√£o voc√™ precisa inserir um c√≥digo simples l√°.  Por exemplo: <br><br><pre> <code class="hljs pgsql">main: .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: halt jr .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span></code> </pre> <br>  e n√£o faz absolutamente nada al√©m de aguardar o in√≠cio da interrup√ß√£o, ap√≥s o que retorna ao r√≥tulo <code>.loop</code> .  (A seguir, omitirei a descri√ß√£o detalhada do ASM. Se voc√™ ficar confuso, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">verifique a documenta√ß√£o do assembler que eu uso</a> .) Voc√™ pode estar curioso por que simplesmente n√£o volto ao r√≥tulo <code>main</code> .  Isso √© porque eu quero que tudo antes do r√≥tulo <code>.loop</code> seja a inicializa√ß√£o do programa e tudo depois que ele acontece em todos os quadros.  Portanto, n√£o preciso ignorar o ciclo de carregamento de dados do cartucho e limpar a mem√≥ria em cada quadro. <br><br>  Vamos dar mais um passo.  O pacote do assembler RGBDS que eu uso cont√©m um conversor de imagens.  Como, nesta fase, ainda n√£o tenho recursos para o jogo, decidi usar o bot√£o monocrom√°tico da minha p√°gina Sobre como um bitmap de teste.  Usando o RGBGFX, converti-o para o formato Game Boy e usei o comando .incbin assembler para inseri-lo ap√≥s a fun√ß√£o <code>main</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26e/1d4/8b2/26e1d48b29e761edb6df6c6a3a3d035b.png" alt="imagem"></div><br>  Para exibi-lo na tela, preciso do seguinte: <br><br><ol><li>  LCD desligado </li><li>  Definir paleta </li><li>  Definir posi√ß√£o de rolagem </li><li>  Limpar mem√≥ria de v√≠deo (VRAM) </li><li>  Carregar gr√°ficos de bloco na VRAM </li><li>  Fa√ßa o download do mapa de fundo da telha VRAM </li><li>  Ligue o LCD novamente </li></ol><br><h3>  LCD desligado </h3><br>  Para iniciantes, esse se torna o obst√°culo mais s√©rio.  No primeiro Game Boy, √© imposs√≠vel simplesmente gravar dados na VRAM a qualquer momento.  √â necess√°rio aguardar o momento em que o sistema n√£o desenha nada.  Imitando o brilho do f√≥sforo em televis√µes CRT antigas, o intervalo entre cada quadro quando o VRAM √© aberto √© chamado Vertical-Blank, ou VBlank (no CRT, √© um impulso para extinguir o feixe do cinesc√≥pio durante uma varredura reversa).  (Tamb√©m h√° HBlank entre cada linha da tela, mas √© muito curto.) No entanto, podemos solucionar esse problema desligando a tela LCD, ou seja, podemos gravar em VRAM, independentemente de onde a faixa de f√≥sforo da tela CRT esteja localizada. <br><br>  Se voc√™ est√° confuso, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta revis√£o deve explicar muito para voc√™</a> .  Nele, a quest√£o √© considerada do ponto de vista do SNES; portanto, n√£o esque√ßa que n√£o h√° feixe de el√©trons e os n√∫meros s√£o diferentes, mas em todo o resto √© bastante aplic√°vel.  Essencialmente, precisamos definir a bandeira do FBlank. <br><br>  No entanto, o truque do Game Boy √© que voc√™ s√≥ pode desligar o LCD durante o VBlank.  Ou seja, temos que esperar pelo VBlank.  Para fazer isso, use interrup√ß√µes.  Interrup√ß√µes s√£o sinais de que o Game Boy envia hardware para a CPU.  Se o manipulador de interrup√ß√µes estiver definido, o processador interromper√° o trabalho e chamar√° o manipulador.  O Game Boy suporta cinco interrup√ß√µes e uma delas inicia quando o VBlank √© iniciado. <br><br>  As interrup√ß√µes podem ser tratadas de duas maneiras diferentes.  A primeira e mais comum √© a tarefa de <em>um manipulador de interrup√ß√µes</em> que funciona como expliquei acima.  No entanto, podemos ativar uma interrup√ß√£o espec√≠fica e desativar todos os manipuladores, definindo o sinalizador de habilita√ß√£o para essa interrup√ß√£o e usando o c√≥digo <code>di</code> opera√ß√£o.  Geralmente n√£o faz nada, mas tem o efeito colateral de sair do c√≥digo de opera√ß√£o HALT, que interrompe a CPU antes que ocorra uma interrup√ß√£o.  (Isso tamb√©m acontece quando os manipuladores s√£o ativados, o que nos permite sair do ciclo HALT em <code>main</code> .) Caso voc√™ esteja interessado, tamb√©m criaremos um manipulador VBlank ao longo do tempo, mas muito disso depender√° de certos valores em determinados endere√ßos.  Como nada foi definido na RAM at√© agora, uma tentativa de chamar o manipulador do VBlank pode levar a uma falha no sistema. <br><br>  Para definir os valores, precisamos enviar comandos para os registros de hardware do Game Boy.  Existem endere√ßos de mem√≥ria especiais diretamente relacionados a v√°rias partes do equipamento, no nosso caso, a CPU, que permite alterar a maneira como ele funciona.  Estamos particularmente interessados ‚Äã‚Äãnos endere√ßos <code>$FFFF</code> (campo de bit de ativa√ß√£o de interrup√ß√£o), <code>$FF0F</code> (campo de bit de <code>$FF0F</code> ativado mas n√£o <code>$FF0F</code> ) e <code>$FF40</code> (controle de LCD).  Uma lista desses registros pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nas p√°ginas</a> associadas √† se√ß√£o "Documenta√ß√£o" da lista Awesome Game Boy Development. <br><br>  Para desligar o LCD, ligamos apenas a interrup√ß√£o do VBlank, atribuindo <code>$FFFF</code> valor <code>$01</code> , execute HALT at√© que a condi√ß√£o <code>$FF0F == $01</code> satisfeita e, em seguida, atribua o bit 7 do endere√ßo <code>$FF40</code> a 0. <br><br><h3>  Definindo a paleta e a posi√ß√£o de rolagem </h3><br>  Isso √© f√°cil de fazer.  Agora que o LCD est√° desligado, n√£o precisamos nos preocupar com o VBlank.  Para definir a posi√ß√£o de rolagem, basta definir os registros X e Y como 0. Com a paleta, tudo √© um pouco mais complicado.  No Game Boy, voc√™ pode atribuir tons do primeiro ao quarto gr√°fico de qualquer um dos quatro tons de cinza (ou verde do p√¢ntano, se desejar), o que √© √∫til para fazer transi√ß√µes e coisas do g√™nero.  <code>%11100100</code> um gradiente simples como uma paleta, definida como uma lista de bits <code>%11100100</code> . <br><br><h3>  Limpando VRAM e carregando gr√°ficos de bloco </h3><br>  Quando lan√ßados, todos os dados gr√°ficos e o mapa de fundo consistem apenas em um logotipo da Nintendo rolante, que √© exibido quando o sistema √© inicializado.  Se eu ativar sprites (eles est√£o desativados por padr√£o), eles ser√£o espalhados pelo lixo na tela.  Voc√™ precisa limpar a mem√≥ria de v√≠deo para come√ßar do zero. <br><br>  Para fazer isso, preciso de uma fun√ß√£o como <code>memset</code> de C. (Tamb√©m preciso de um <code>memcpy</code> anal√≥gico para copiar os dados gr√°ficos.) A fun√ß√£o <code>memset</code> define o fragmento especificado de mem√≥ria para um determinado byte.  Ser√° f√°cil implementar isso sozinho, mas o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tutorial</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AssemblyDigest</a> j√° possui essas fun√ß√µes, ent√£o eu as uso. <br><br>  Nesse ponto, eu posso limpar o VRAM com o <code>memset</code> escrevendo <code>$00</code> (embora o primeiro commit tenha usado o valor <code>$FF</code> , o que tamb√©m era adequado) e depois carregar os gr√°ficos do bloco no VRAM usando o <code>memcpy</code> .  Mais especificamente, eu preciso copi√°-lo para o endere√ßo <code>$9000</code> , porque esses s√£o blocos usados ‚Äã‚Äãapenas para gr√°ficos de plano de fundo.  (Os endere√ßos <code>$8000-$87FF</code> s√£o usados ‚Äã‚Äãapenas para blocos de sprite e os endere√ßos <code>$8800-$8FFF</code> s√£o comuns para ambos os tipos.) <br><br><h3>  Configura√ß√£o de mapa de lado a lado </h3><br>  O Game Boy tem uma camada de fundo, dividida em blocos de 8x8.  A camada de segundo plano em si ocupa cerca de 32x32 blocos, ou seja, possui um tamanho total de 256x256.  (Para compara√ß√£o: a tela do console tem uma resolu√ß√£o de 160x144.) Eu precisava indicar manualmente os blocos que comp√µem minha imagem linha por linha.  Felizmente, todos os blocos foram organizados em ordem, ent√£o eu apenas tive que preencher cada linha com valores de <code>N*11</code> a <code>N*11 + 10</code> , onde <code>N</code> √© o n√∫mero da linha e os 22 elementos restantes preenchendo <code>$FF</code> . <br><br><h3>  Ligar o LCD </h3><br>  Aqui n√£o precisamos esperar pelo VBlank, porque a tela ainda n√£o ser√° ligada at√© o VBlank, ent√£o acabei de escrever no registro de controle do LCD novamente.  Tamb√©m inclu√≠ camadas de plano de fundo e sprite e tamb√©m indiquei os endere√ßos corretos do mapa e dos gr√°ficos do bloco.  Depois disso, obtive os seguintes resultados.  Tamb√©m liguei os manipuladores de interrup√ß√£o novamente usando o <code>ei</code> opcode. <br><br>  Nesse ponto, para torn√°-lo ainda mais interessante, escrevi um manipulador de interrup√ß√µes muito simples para o VBlank.  Adicionando o c√≥digo de opera√ß√£o de transi√ß√£o a <code>$40</code> , eu posso fazer com que o manipulador funcione de qualquer maneira.  Nesse caso, escrevi uma fun√ß√£o simples que rola a tela para cima e para baixo. <br><br>  Aqui est√£o os resultados finais.  [Al√©m disso: acabei de perceber que o GIF n√£o est√° em loop corretamente, ele deve transferir constantemente a imagem.] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd0/c84/9db/fd0c849dbe3bc68910d186b1ef014c66.gif"></div><br>  At√© agora, nada de surpreendente, mas ainda √© legal que, teoricamente, eu possa pegar meu antigo Game Boy Color e ver como meu pr√≥prio c√≥digo √© executado nele. <br><br><h2>  Divers√£o com folhas quadriculadas </h2><br>  Para desenhar algo na tela, naturalmente preciso de algum tipo de sprite.  Tendo estudado o PPU (Picture Processing Unit) do console Game Boy, decidi me concentrar nos sprites 8x8 ou 8x16.  Provavelmente, precisarei da √∫ltima op√ß√£o, mas apenas para sentir o tamanho, rapidamente rabisquei em um papel quadriculado uma captura de tela do jogo em uma escala de 1: 8. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/b5b/ece/887b5becec39b13f2fd167e9436c63e5.jpg"></div><br>  Eu queria deixar a parte superior da tela sob o HUD.  Pareceu-me que pareceria mais natural do que a partir de baixo, porque quando estiver pronto, se os personagens precisarem bloquear temporariamente o HUD, como em Super Mario Bros, eles poder√£o faz√™-lo.  Este jogo n√£o ter√° nenhuma plataforma complexa e, de fato, o design de n√≠veis tamb√©m, ent√£o n√£o preciso mostrar uma vis√£o muito geral do campo.  A posi√ß√£o dos personagens na tela e, possivelmente, os obst√°culos que aparecem de tempos em tempos ser√£o suficientes.  Portanto, eu posso pagar sprites muito grandes. <br><br>  Portanto, se um quadrado tiver um bloco de 8x8, um sprite <em>n√£o</em> ser√° suficiente, independentemente do tamanho que eu escolher.  Isso √© especialmente verdade, j√° que quase n√£o haver√° movimento vertical no jogo, com exce√ß√£o dos saltos.  Ent√£o eu decidi criar sprites a partir de quatro sprites 8x16.  A exce√ß√£o foi a cauda da raposa, que ocupa dois sprites de 8x16.  Ap√≥s c√°lculos simples, ficou claro que duas raposas e duas lagartixas ocupar√£o 20 dos 40 sprites, ou seja, ser√° poss√≠vel adicionar muito mais sprites.  (Sprites 8x8 esgotariam rapidamente o meu limite, o que eu n√£o quero fazer nos est√°gios iniciais de desenvolvimento.) <br><br>  Por enquanto, eu s√≥ preciso desenhar sprites.  Abaixo est√£o esbo√ßos aproximados em papel quadriculado.  Eu tenho um sprite de espera, um sprite de "pensamento" para escolher entre passar ou correr, como em um jogo SNES ... e √© isso.  Eu tamb√©m planejava fazer sprites de personagens em execu√ß√£o, pulando e personagens que os oponentes pegam.  Mas, para come√ßar, desenhei apenas sprites de espera e pensamento, para n√£o complicar.  Eu ainda n√£o fiz o resto, preciso fazer isso. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/623/20c/124/62320c12434cacf0c0ca06a2aad33fae.jpg"></div><br>  Sim, eu sei, n√£o desenho muito bem.  A perspectiva √© uma coisa complicada.  (Sim, e esta face da raposa polar √© terr√≠vel.) Mas combina comigo perfeitamente.  O design de personagens n√£o possui nenhum recurso especial, mas √© adequado para o game jam.  √â claro que usei lagartixas e raposas polares como refer√™ncia.  Isso √© impercept√≠vel? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fe/b2e/936/1feb2e936415aeceaf8cd35596d7e55d.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/215/cc8/568/215cc856884bb518df111799d6e10a87.jpg"></div><br>  Voc√™ n√£o pode dizer.  (Para constar: depois de ver essas fotos novamente, percebi que h√° uma enorme diferen√ßa entre lagartixas e lagartos. N√£o sei o que fazer com isso, exceto para me considerar est√∫pido ...) Acho que voc√™ pode imaginar que a fonte de inspira√ß√£o para Blaze the Cat da s√©rie de jogos Sonic serviu como cabe√ßa da raposa. <br><br>  Inicialmente, eu queria que os zagueiros e atacantes de cada equipe fossem de sexos diferentes e fosse mais f√°cil distinguir entre eles.  (Eu tamb√©m deixaria os jogadores escolherem o g√™nero de seu personagem.) No entanto, isso exigiria muito mais desenho.  Ent√£o decidi por lagartixas e raposas. <br><br>  E, finalmente, desenhei uma tela inicial porque havia um lugar para ela em um peda√ßo de papel quadriculado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c67/5ac/30a/c675ac30af04025014da7eee842d285d.jpg"></div><br>  Sim, poses de a√ß√£o ainda est√£o longe do ideal.  A raposa polar deve ficar mais chateada e correr, e a lagartixa deve parecer amea√ßadora.  Defender Fox em segundo plano - uma refer√™ncia divertida √† arte na caixa Doom. <br><br><h2>  Digitaliza√ß√£o de sprites </h2><br>  Ent√£o comecei a transformar desenhos em papel em sprites.  Para isso, usei o programa GraphicsGale, recentemente liberado.  (Eu sei que voc√™ pode usar asesprite, mas eu prefiro GraphicsGale.) O trabalho em sprites acabou sendo muito mais complicado do que eu esperava.  Cada um desses quadrados dos sprites mostrados acima ocupa at√© 4 pixels em uma grade 2x2.  E esses quadrados geralmente tinham MUITO mais detalhes do que 4 pixels.  Portanto, eu tive que me livrar de muitos detalhes dos esbo√ßos.  √Äs vezes at√© era dif√≠cil aderir a uma forma simples, porque era necess√°rio deixar um local aceit√°vel para os olhos ou nariz.  Mas parece-me que tudo parece bom, mesmo que o sprite tenha se tornado completamente diferente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/789/d16/39f789d16e3c10c85fa4f0613a0cf571.png"></div><br>  Os olhos da raposa perderam a forma amendoada e se transformaram em uma linha de dois pixels de altura.  Os olhos da lagartixa mantiveram sua redondeza.  A cabe√ßa da lagartixa teve que ser aumentada, livrando-se dos ombros largos, e todas as curvas que a raposa podia ter foram significativamente suavizadas.  Mas, honestamente, todas essas mudan√ßas f√°ceis n√£o s√£o t√£o ruins.  √Äs vezes, mal conseguia escolher qual das varia√ß√µes √© melhor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/32f/d71/a5232fd71193a02dfaebdc2c043edbe5.png"></div><br>  GraphicsGale tamb√©m possui fun√ß√µes convenientes para camadas e anima√ß√µes.  Isso significa que eu posso animar a cauda da raposa separadamente do corpo dela.  Isso ajuda muito a economizar espa√ßo precioso no VRAM, porque n√£o preciso duplicar a cauda em todos os quadros.  Al√©m disso, isso significava que voc√™ poderia abanar o rabo com uma velocidade vari√°vel, diminuindo a velocidade quando o personagem estava em p√© e acelerando enquanto corria.  No entanto, isso torna a programa√ß√£o um pouco mais complicada.  Mas ainda assim eu assumirei esta tarefa.  Eu decidi por 4 quadros de anima√ß√£o, porque isso √© suficiente. <br><br>  Voc√™ pode notar que a raposa polar usa os tr√™s tons mais claros de cinza, enquanto a lagartixa usa os tr√™s tons mais escuros de cinza.  No GameBoy, isso √© aceit√°vel, porque, embora possa haver apenas tr√™s cores em um sprite, o console permite especificar duas paletas.  Fiz isso para que a paleta 0 seja usada para raposas e a paleta 1 para lagartixas. Esse conjunto de paletas dispon√≠veis acabou, mas acho que n√£o precisarei de outras. <br><br>  Eu tamb√©m precisava cuidar do fundo.  N√£o me incomodei com os esbo√ßos dele, porque planejei que fosse uma cor s√≥lida ou um simples padr√£o geom√©trico.  Ainda n√£o digitalizei o protetor de tela, porque n√£o tinha tempo suficiente. <br><br><h2>  Carregando sprites no jogo </h2><br>  Verifique com a confirma√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">be99d97</a> . <br><br>  Depois que cada quadro individual dos gr√°ficos dos personagens foi salvo, foi poss√≠vel come√ßar a convert√™-los para o formato GameBoy.  Descobriu-se que no RGBDS existe um utilit√°rio muito conveniente para isso chamado RGBGFX.  Ele pode ser chamado com o comando <code>rgbgfx -h -o output.bin input.png</code> e criar√° um conjunto de blocos compat√≠veis com o GameBoy.  (A op√ß√£o -h especifica um modo de bloco compat√≠vel com 8x16, para que a convers√£o seja realizada de cima para baixo e n√£o da esquerda para a direita.) No entanto, ele n√£o fornece liga√ß√µes e n√£o pode rastrear blocos duplicados quando cada quadro √© uma imagem separada.  Mas deixaremos esse problema para mais tarde. <br><br>  Ap√≥s gerar os arquivos .bin de sa√≠da, basta adicion√°-los no assembler usando o <code>incbin "output.bin"</code> .  Para manter tudo junto, criei um arquivo comum ‚Äúgfxinclude.z80‚Äù, que cont√©m todos os gr√°ficos a serem adicionados. <br><br>  No entanto, era muito chato regenerar manualmente os gr√°ficos sempre que algo mudava.  Ent√£o editei o arquivo build.bat, adicionando a linha <code>for %%f in (gfx/*.png) do rgbds\rgbgfx -h -o gfx/bin/%%f.bin gfx/%%f</code> , que converte cada arquivo. png na pasta gfx / para o arquivo bin e salva-o em gfx / bin.  Isso simplificou muito minha vida. <br><br>  Para criar gr√°ficos de fundo, usei uma maneira <em>muito</em> mais pregui√ßosa.  O RGBASM possui uma diretiva <code>dw `</code> .  √â seguido por uma linha de 8 valores de 0 a 4 igual a uma linha de dados de pixel.  Como os sprites de fundo eram muito simples, tornou-se mais f√°cil copiar e colar um padr√£o geom√©trico simples para criar um padr√£o s√≥lido, listrado ou quadriculado.  Aqui, por exemplo, se parece com um terreno. <br><br><pre> <code class="hljs powershell">bg_dirt: dw `00110011 dw `00000000 dw `01100110 dw `00000000 dw `11001100 dw `00000000 dw `10011001 dw `00000000</code> </pre> <br>  Ele cria uma s√©rie de listras deslocadas com a ilus√£o de perspectiva.  Essa √© uma abordagem simples, mas inteligente.  Com a grama era um pouco mais complicado.  Inicialmente, era um grupo de linhas horizontais com 2 pixels de altura, mas adicionei manualmente alguns pixels que adicionam um pouco de ru√≠do que faz a grama parecer melhor: <br><br><pre> <code class="hljs powershell">bg_grass: dw `12121112 dw `12121212 dw `22112211 dw `11121212 dw `22112211 dw `21212121 dw `12121212 dw `12211222</code> </pre> <br><h2>  Renderiza√ß√£o gr√°fica </h2><br>  No GameBoy, os sprites s√£o armazenados em uma √°rea chamada OAM, ou Object Attribute Memory.  Ele cont√©m apenas atributos (dire√ß√£o, paleta e prioridade), al√©m do n√∫mero do bloco.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foi o suficiente para eu preencher essa √°rea de mem√≥ria para exibir sprites na tela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embora haja pequenos recursos. Primeiro, voc√™ precisa carregar os gr√°ficos da ROM na VRAM. O GameBoy pode renderizar apenas blocos armazenados em uma √°rea especial da mem√≥ria chamada VRAM. Felizmente, para copiar da ROM para o VRAM, basta execut√°-lo </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no est√°gio de inicializa√ß√£o do programa. Aconteceu que, com apenas 6 sprites de caracteres e 4 pe√ßas de cauda, ‚Äã‚Äãeu j√° ocupei um quarto da √°rea de VRAM alocada para sprites. (VRAM geralmente √© dividido em √°reas de segundo plano e sprites, e 128 bytes s√£o comuns a eles.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al√©m disso, o acesso ao OAM s√≥ √© poss√≠vel durante o VBlank. Comecei dizendo que o VBlank estava aguardando c√°lculos de sprite, mas tive problemas porque os c√°lculos de sprite duravam todo o tempo alocado pelo VBlank e era imposs√≠vel finaliz√°-los. A solu√ß√£o aqui √© gravar em uma </font><font style="vertical-align: inherit;">√°rea de mem√≥ria </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separada</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fora do VBlank e simplesmente copi√°-los para o OAM durante o VBlank. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como se viu, o GameBoy possui um procedimento especial de c√≥pia de hardware, um tipo de DMA (acesso direto √† mem√≥ria, acesso direto √† mem√≥ria) que faz exatamente isso. Escrevendo para um registro espec√≠fico e indo para o ciclo ocupado no HiRAM (porque a ROM n√£o est√° dispon√≠vel durante o DMA), voc√™ pode copiar dados da RAM para o OAM muito mais rapidamente do que usar a fun√ß√£o</font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se estiver interessado, detalhes interessantes podem ser encontrados </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesse est√°gio, eu s√≥ conseguia criar um procedimento que determina o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ser√° gravado no DMA. </font><font style="vertical-align: inherit;">Para fazer isso, eu precisava armazenar o estado dos objetos em outro lugar. </font><font style="vertical-align: inherit;">No m√≠nimo, era necess√°rio o seguinte:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tipo (lagartixa, raposa polar ou item de transporte de uma das equipes) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dire√ß√£o </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posi√ß√£o X </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posi√ß√£o Y </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quadro de anima√ß√£o </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Temporizador de anima√ß√£o </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na primeira decis√£o muito desajeitada, verifiquei o tipo do objeto e, dependendo dele, mudei para um procedimento que desenha spriticamente esse tipo de objeto. O procedimento raposa polar, por exemplo, assumiu uma posi√ß√£o em X, dependendo da dire√ß√£o, somada ou subtra√≠da 16, adicionado dois sprites de cauda e depois movido para cima e para baixo no sprite principal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui est√° uma captura de tela de como o sprite ficou em VRAM ao renderizar na tela. A parte esquerda √© composta por sprites individuais, n√∫meros hexadecimais pr√≥ximos a eles, de cima para baixo - posi√ß√£o vertical e horizontal, sinalizadores de blocos e atributos. √Ä direita, voc√™ pode ver como tudo parecia depois da montagem.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/e7d/240/8e9e7d2401e1a07d0c77e2f0c6c99e3d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com a anima√ß√£o da cauda, ‚Äã‚Äãfoi um pouco mais complicado. Na primeira solu√ß√£o, simplesmente incrementei o timer de anima√ß√£o em cada quadro e realizei um incremento l√≥gico </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um valor </font></font><code>%11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para obter o n√∫mero do quadro. Em seguida, voc√™ pode simplesmente adicionar 4 * o n√∫mero do quadro (cada quadro de anima√ß√£o consiste em 4 blocos) ao primeiro bloco final no VRAM para obter 4 quadros diferentes armazenados no VRAM. Funcionou (especialmente aquele com a busca do ladrilho da cauda), mas o rabo balan√ßou </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incrivelmente</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> r√°pido, e eu precisava encontrar uma maneira de desaceler√°-lo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na segunda solu√ß√£o melhor, realizei um incremento do </font><font style="vertical-align: inherit;">cron√¥metro </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">global</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em cada quadro </font><font style="vertical-align: inherit;">e quando o valor da opera√ß√£o </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e o grau de dois escolhidos por mim foi 0, o incremento do cron√¥metro do objeto foi realizado. Assim, cada objeto individual pode contar seu cron√¥metro de anima√ß√£o a qualquer velocidade necess√°ria. Isso funcionou perfeitamente e me permitiu diminuir a cauda para um n√≠vel razo√°vel.</font></font><br><br><h2>  Dificuldades </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas se tudo fosse t√£o simples. N√£o esque√ßa que eu gerenciei tudo isso no c√≥digo, usando meu pr√≥prio subprocedimento para cada objeto e, se voc√™ precisar continuar, precisar√° fazer isso em todos os quadros. Eu tive que especificar como proceder para o pr√≥ximo sprite, bem como em qual bloco ele consiste, manipulando manualmente os registros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Era um sistema completamente inst√°vel. Para desenhar um quadro, era necess√°rio manipular um n√∫mero suficientemente grande de registros e tempo de CPU. Era quase imposs√≠vel adicionar suporte a outras pessoas e, mesmo que eu conseguisse, o suporte ao sistema seria muito doloroso. </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acredite, foi um verdadeiro caos.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu precisava de um sistema no qual o c√≥digo para renderizar sprites fosse generalizado e direto, para que n√£o fosse um entrela√ßamento de condi√ß√µes, manipula√ß√£o de registradores e operadores matem√°ticos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como eu consertei isso? </font><font style="vertical-align: inherit;">Vou falar sobre isso na pr√≥xima parte do artigo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47d/f64/3a2/47df643a2bd620cf8899b3601162748b.gif" alt="imagem"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436330/">https://habr.com/ru/post/pt436330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436320/index.html">Muitas propriedades ou objeto de propriedade: crit√©rios de sele√ß√£o</a></li>
<li><a href="../pt436322/index.html">@Pythonetc dezembro de 2018</a></li>
<li><a href="../pt436324/index.html">Dicas e truques do meu canal Telegram @pythonetc, dezembro de 2018</a></li>
<li><a href="../pt436326/index.html">Re-descentraliza√ß√£o da web. Para sempre desta vez</a></li>
<li><a href="../pt436328/index.html">PVS-Studio 7.00</a></li>
<li><a href="../pt436332/index.html">PVS-Studio 7.00</a></li>
<li><a href="../pt436334/index.html">Aprendendo conceitos atrav√©s da intera√ß√£o sens√≥rio-motora</a></li>
<li><a href="../pt436338/index.html">Como funciona o aeroporto de Vnukovo</a></li>
<li><a href="../pt436340/index.html">N√≠vel de log separado para cada solicita√ß√£o</a></li>
<li><a href="../pt436342/index.html">Uma introdu√ß√£o √† otimiza√ß√£o robusta [... e uma pequena lista de compras que eu esqueci ...]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>