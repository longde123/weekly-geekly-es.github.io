<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏾 🚩 💬 代码质量 🧝 😷 ⚫️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="代码质量是编程所固有的主题。 ISO 9000用于评估和控制企业管理的质量，产品使用GOST和相同的ISO，但是没有用于质量评估的GOST代码。 对于代码质量也没有确切的定义和标准。 



 每个开发人员都根据经验以自己的方式理解质量。 傻瓜和领导的观点是不同的，这导致了分歧。 每个项目的团队都以...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>代码质量</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/433326/"> 代码质量是编程所固有的主题。  ISO 9000用于评估和控制企业管理的质量，产品使用GOST和相同的ISO，但是没有用于质量评估的GOST代码。 对于代码质量也没有确切的定义和标准。 <br><br><img src="https://habrastorage.org/webt/g7/lf/vf/g7lfvflqvaed3arisqbaikdvrhi.jpeg"><br><br> 每个开发人员都根据经验以自己的方式理解质量。 傻瓜和领导的观点是不同的，这导致了分歧。 每个项目的团队都以自己的方式评估代码。 团队正在更新，开发人员正在离开，团队领导者正在改变-质量的定义正在改变。 来自Tinkoff.ru的<strong>Ivan Botanov</strong> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">StressoID</a> ），Frontend-developer，Angular的在线讲师，会议和会议的发言人，YouTube的讲师以及公司的团队教练有时会尝试帮助解决此问题。 <br><br> 在解读Ivan关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Frontend Conf</a>的报告时<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，我们</a>将讨论可读性，命名，声明性，代码风格，并间接涉及傻瓜和领导者的关系：错误，耙子和“燃烧”幼仔。 <br><br>  <em>免责声明：请</em>做好心理准备，文本<em>中将会有很多错误的代码</em> ，这些<em>代码来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“特殊”站点</a> 。</em> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dpkKf-Nkwcw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2> 一点历史 <br></h2><br> 我们都以不同的方式写作。 当您更改工作地点，项目或团队时，您可能已经注意到了这一点-不寻常的事情立即显而易见。 这件事在我身上也发生过很多次，这就是为什么这份报告诞生的原因。 我专注于新手开发人员，但是本文对那些已经写而不是编写或自定义开发流程的人来说将是有用的。 我们要谈论什么： <br><br><ul><li> 关于不可读代码的问题。 </li><li> 让我们讨论命名。 </li><li> 让我们看看声明式和命令式之间的区别是什么，以及有哪些问题。 </li><li> 关于代码模块化和类型化。 </li><li> 关于代码样式和技术债务，关于提交和git flow。 </li><li> 关于您可以使用的工具，并修复产品中的错误。 </li></ul><br> 在开始之前，我会问一个问题： <strong>“为了使项目停止开发，总线必须起飞多少个程序员？”</strong>  。 正确答案：大家。 <br><br><h2> 什么是公交车系数？ <br></h2><br> 有条件地，Petya或Vasya在一个团队中工作，他们了解该项目的一切：他们去找他，问这个和那个，它在这里如何工作，以及它在那里如何工作。 每个人都依赖Petya，该项目的公交车号是1。 数字越小，开发该项目就越困难，因为每个人都会分散Petya的注意力，而且他很酷，必须执行任务，而不回答问题。 <br><br> 您会说<em>成为Pete有多酷！</em>  <em>每个人都爱他，欣赏他，需要他。</em> <br><br> 事实并非如此。 通常，Petya是团队负责人，他还必须处理其他任务：讨论项目的开发，构建体系结构，管理团队，但不要去沙丘并解释为什么将其写在这里，否则就不要写。 <br><br> 如果代码干净而且不错，那么阅读它会很好，而且琼斯语中的问题也更少了。  <strong>干净的代码可以提高项目的可行性，并降低准入门槛</strong> 。 当新人出现在团队中时，他们会问的问题会更少。 在这样的项目中，由于入门门槛低， <strong>因此更容易吸引开发人员</strong> 。 <br><br><blockquote> 质量代码提高了公交车数量。 <br></blockquote><br><h2> 易读性 <br></h2><br> 缩进，弯曲的命名和强大的嵌套会影响可读性-许多项目都因此而受苦。 除了缩进之外，多行三元运算符，缺少单一的Code样式，开发方法的组合以及对变量的明确定义也降低了可读性。 所有这些都是导致代码可读性差的最常见原因。 <br><br> 对于我自己，我已经确定了术语<strong>线性代码</strong> -这是可以像书一样阅读的代码。 <br><br><blockquote> 从左到右，从上到下读取线性代码，而不必返回到先前编写的代码。 <br></blockquote><br> 此类代码的示例： <br><br><pre><code class="javascript hljs">list.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element1</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element1.parent_id == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { output.push(element1); list.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element2</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element2.parent_id == element1.id) { output.push(element2); list.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element3</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element3.parent_id == element2.id) { output.push(element3); list.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element4</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element4.parent_id == element3.id) { output.push(element4); } }) } }) } }) } })</code> </pre> <br> 这段代码是线性的，但是还有另一个问题-它是大量嵌套的。 因此，我们还必须监视嵌套。 <br><br>  <strong>非线性</strong>代码示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!brk &amp;&amp; html.childNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>].value &amp;&amp; html.childNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>].max) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(clear) html.childNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>].value = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(html.childNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>].value &lt;= html.childNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>].max) { ++ html.childNodes[<span class="hljs-number"><span class="hljs-number">0</span></span>].value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(brk) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(id = <span class="hljs-number"><span class="hljs-number">1</span></span>; id &lt; html.childNodes.length; ++ id) findActive(html.childNodes[id], <span class="hljs-literal"><span class="hljs-literal">true</span></span>); html.parentNode.className = <span class="hljs-string"><span class="hljs-string">""</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { html.parentNode.className = <span class="hljs-string"><span class="hljs-string">"Ready"</span></span>; html.className = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html; } }</code> </pre><br> 如果我们丢弃所有多余的东西并找出破坏线性的东西，那么我们将看到类似以下内容： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br> 如果还有其他地方，首先您必须查看一个地方写的内容，然后再看另一个地方。 如果它是一个很大的嵌套或很大的嵌套，则注意力分散了，并且代码很难阅读。 <br><br><h3> 如何减少嵌套并实现线性代码？ <br></h3><br>  <strong>结合条件</strong> 。 这是我们可以做的最简单的事情-如果可以合并条件并稍微减少嵌套，则可以嵌套。 <br><br> 那是： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUser()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAdmin()) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'admin'</span></span>); } }</code> </pre><br> 它变成了： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isUser() &amp;&amp; isAdmin()) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'admin'</span></span>); }</code> </pre><br> 应用<strong>早期返回模式</strong> 。 它使您可以完全摆脱其他问题。 我可以用早期返回的if-else替换该方法或一段代码，然后执行一个代码块或另一个代码块。 这非常方便-您不必滚动并返回到代码的某些部分。 <br><br> 那是： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAdmin()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> admin; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user; }</code> </pre><br> 它变成了： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAdmin()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> admin; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user;</code> </pre><br><br>  <strong>应用承诺链</strong> 。 这是典型的量角器代码。 不久之前，我写了E2E测试，这样的代码伤了我的眼睛： <br><br><pre> <code class="javascript hljs">ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q01_D'</span></span>)).click().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q02_C'</span></span>)).click().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q03_D'</span></span>)).click().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); }); }); })</code> </pre><br> 使用promise链，代码将变为： <br><br><pre> <code class="javascript hljs">ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q01_D'</span></span>)).click() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q02_C'</span></span>)).click(); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q03_D'</span></span>)).click(); }) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>); });</code> </pre><br><br> 如果我们使用箭头函数的知识，则可以执行以下操作： <br><br><pre> <code class="javascript hljs">ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q01_D'</span></span>)).click() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q02_C'</span></span>)).click()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ptor.findElement(protractor.By.id(<span class="hljs-string"><span class="hljs-string">'q03_D'</span></span>)).click()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'done'</span></span>));</code> </pre><br> 它可读，声明，精美-一切都清晰可见。 <br><br>  <strong>高阶可观察。</strong> 由于我是有角度的并且使用RxJS，因此我面临着意大利面条代码强烈嵌套的问题-嵌套的<strong>Observable</strong> （即嵌套订阅）。 有一个流，在流内部您需要获取值，然后与另一个流相关。 一些这样写： <br><br><pre> <code class="javascript hljs">Observable.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> { item += <span class="hljs-number"><span class="hljs-number">2</span></span>; Observable.of(item) .subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function"> =&gt;</span></span> { element += <span class="hljs-number"><span class="hljs-number">1</span></span>; }) })</code> </pre><br> 这确实会影响成人项目。 您可以这样做： <br><br><pre> <code class="javascript hljs">Observable.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) .mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable.of(item + <span class="hljs-number"><span class="hljs-number">2</span></span>)) .mergeMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function"> =&gt;</span></span> Observable.of(element + <span class="hljs-number"><span class="hljs-number">1</span></span>)) .subscribe()</code> </pre><br> 利用RxJS API的知识，由于可以<strong>观察</strong>到<strong>更高的顺序</strong> ，因此我们不再使用强嵌套，而是使用了<strong>声明式</strong> 。 这件事，将内部流的价值抛向外部，就全部了。 但是它干净，线性，美观且没有花钱。 <br><br><h3> 嵌套三元运算符 <br></h3><br> 我认为，代码中最糟糕的是<strong>嵌套的三元运算符</strong> 。 用块条件语句重写它们，尽量不要使用它们。 我们根本不会谈论隐式条件-这是一个失败。 <br><br> 嵌套三元运算符和隐式条件的示例： <br><br><pre> <code class="javascript hljs">arr.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? arr[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-number"><span class="hljs-number">1</span></span> ? arr[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span> : arr[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'empty arr'</span></span>); !a &amp;&amp; b &amp;&amp; func()</code> </pre><br> 我在5分钟内编写了这个简单的三元组。 它具有数组的长度和一些操作，但是很难读取，因为某个地方有一个问题，其他地方-一切都不清楚。 可以使用多行嵌套三元运算符来重写此代码： <br><br><pre> <code class="javascript hljs">arr.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? arr[<span class="hljs-number"><span class="hljs-number">1</span></span>] === <span class="hljs-number"><span class="hljs-number">1</span></span> ? arr[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">2</span></span> : arr[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'empty arr'</span></span>);</code> </pre><br> 您会说： <br><br>  - <em>好吧！</em> <br>  - <em>看到了吗？</em> <br>  - <em>可见！</em> <br><br> 您对此说什么： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> query <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span> ? (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ fn.each(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id.match(query)) { seatSet.push(id, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seatSet; })() : (query.length == <span class="hljs-number"><span class="hljs-number">1</span></span> ? (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">character</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//user searches just for a particual character fn.each(function () { if (this.char() == character) { seatSet.push(this.settings.id, this); } }); return seatSet; })(query) : (function () { //user runs a more sophisticated query, so let's see if there's a dot return query.indexOf('.') &gt; -1 ? (function () { //there's a dot which separates character and the status var parts = query.split('.'); fn.each(function (seatId) { if (this.char() == parts[0] &amp;&amp; this.status() == parts[1]) { seatSet.push(this.settings.id, this); } }); return seatSet; })() : (function () { fn.each(function () { if (this.status() == query) { seatSet.push(this.settings.id, this); } }); return seatSet; })(); })() );</span></span></code> </pre><br> 有人撰写并支持了这个ternarnik。 通过访问这段代码，将很难弄清楚问号在哪里开始和在哪里结束。 如果您使用三元，请不要互相投资-这很不好。 <br><br><h2> 命名 <br></h2><br> 另一个错误的代码： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0x30119c = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0x3af68e = { <span class="hljs-string"><span class="hljs-string">'data'</span></span>: { <span class="hljs-string"><span class="hljs-string">'key'</span></span>: <span class="hljs-string"><span class="hljs-string">'cookie'</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>: <span class="hljs-string"><span class="hljs-string">'timeout'</span></span> }, <span class="hljs-string"><span class="hljs-string">'setCookie'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_0x3543f3, _0x13e5c1, _0x586dac, _0x1c9d63</span></span></span><span class="hljs-function">) </span></span>{ _0x1c9d63 = _0x1c9d63 || {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0x47b83f = _0x13e5c1 + <span class="hljs-string"><span class="hljs-string">'='</span></span> + _0x586dac; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0xae3be = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0xae3be = <span class="hljs-number"><span class="hljs-number">0x0</span></span>, _0x5d2845 = _0x3543f3[<span class="hljs-string"><span class="hljs-string">'length'</span></span>]; _0xae3be &lt; _0x5d2845; _0xae3be++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0x440369 = _0x3543f3[_0xae3be]; _0x47b83f += <span class="hljs-string"><span class="hljs-string">';\x20'</span></span> + _0x440369; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _0x411875 = _0x3543f3[_0x440369]; _0x3543f3[<span class="hljs-string"><span class="hljs-string">'push'</span></span>](_0x411875); _0x5d2845 = _0x3543f3[<span class="hljs-string"><span class="hljs-string">'length'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_0x411875 !== !![]) { _0x47b83f += <span class="hljs-string"><span class="hljs-string">'='</span></span> + _0x411875; } } _0x1c9d63[<span class="hljs-string"><span class="hljs-string">'cookie'</span></span>] = _0x47b83f; } };</code> </pre><br><br> 我们可以说这段代码是<strong>模糊的</strong> ，但即使如此：我们看到有一个易于理解的功能，一个清晰的“数据”，setCookie做一些事情，然后它只是一揽子，没有什么清楚的- <strong>串联在一起的</strong>东西，在某个地方。 一切都非常糟糕。 <br><br><h3> 命名时需要考虑的事项 <br></h3><br> 使用<strong>CamelCase表示法</strong> ： <code>camelCaseNotation</code> 。  <strong>没有音译，所有方法的名称都只有英文</strong> ： <code>ssylka, vikup, tovar, yslyga</code>或<code>checkTovaraNaNalichieTseni</code>失败。 顺便说一下，后者是我刚开始编程时写的。 <br><br>  <strong>没有item，data，el，html，arr</strong> ，尤其是在遍历数组时。 例如，对于一系列产品或报价，请选择友好名称： <code>product, offer, etc</code> 产品和产品之间的差异不是很大，但是可读性更高。 即使您具有单行功能加上一些东西，一个商业友好的名称也会提高可读性。 <br><br>  <code>private_property</code> <strong>表示私有财产</strong> ： <code>private_property</code> 。 我添加此规则是因为我已经第二年编写TypeScript了，但是JS中没有访问修饰符，并且在命名约定中我们同意下划线为其他开发人员定义私有属性。 <br><br>  <strong>大写字母</strong> <code>const BLOCK_WIDTH = 300;</code> ： <code>const BLOCK_WIDTH = 300;</code>  ，以及<strong>大写形式的类名：</strong> <code>class SomeClass</code> 。 我用TypeScript编写，在那里一切都清晰可见，在<strong>ES6中</strong>一切都清晰可见，但是也有一些旧项目，其中所有带有<code>new</code>运算符的函数类都以大写形式编写。 <br><br>  <strong>没有一个字母变量</strong> ： <code>u = user</code> 。 这是对<strong>i</strong>的引用-不。 写清楚，即从功能上讲。 无需制作Check方法，该方法可以检查某些内容，但尚不清楚。 写下方法的<code>addProductToCard(); sendFeedback()</code> <strong>名称</strong> ： <code>addProductToCard(); sendFeedback()</code>  <code>addProductToCard(); sendFeedback()</code> 。 <br><br><h2> 必要性 <br></h2><br> 一个小题外话。 命令性与编程同时出现。 那时，他们用汇编语言进行编码，并命令式地编写：详细描述了每个命令，每个步骤，并为该值分配了一个存储单元。 我们生活在2019年，因此不再写JS。 <br><br><img src="https://habrastorage.org/webt/zl/ra/s4/zlras4uvhmk2psu5vnew5pgxqya.jpeg"><br><br> 这是简单的命令式代码，具有for循环，变量。 目前尚不清楚为什么在这里添加它们。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> someItem = conferences[i]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prefixString = <span class="hljs-string"><span class="hljs-string">'Hello '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (someItem === <span class="hljs-string"><span class="hljs-string">'Frontend Conf'</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(prefixString + someItem); } }</code> </pre><br> 强制性代码问题<strong>：</strong>很多变量，这些变量的很多维护构造以及很多注释，因为需要以某种方式描述这些变量-您无法创建变量而忘记它。 所有这些都会影响代码的可读性。 <br><br><h2> 声明性 <br></h2><br> 声明式样式已替换。 我们使用JavaScript编写并且可以使用。 声明式样式如下所示： <br><br><pre> <code class="javascript hljs">conferences .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">someItem</span></span></span><span class="hljs-function"> =&gt;</span></span> someItem === <span class="hljs-string"><span class="hljs-string">'Frontend Conf'</span></span>) .forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">someItem</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello'</span></span> + someItem));</code> </pre><br> 这与命令中的命令相同，但更加简单和易于理解。 <br><br><h3> 声明性代码的好处 <br></h3><br> 这样的代码更易于阅读，维护和测试，复杂的代码构造可以隐藏在方法和抽象的后面。 您可以通过煎鸡蛋的示例来了解命令式和声明式之间的区别。 要以命令式的方式煎炸鸡蛋，我们将一个煎锅放在火上，倒入油，然后将鸡蛋打碎，倒出。 我们以声明式的方式说：“煎蛋”，该过程将隐藏在抽象的后面。 我们要煎炒鸡蛋，而不是想知道它是如何工作的。 <br><br> 当不是非常有经验的开发人员来自他们研究Pascal的大学时，问题就开始了，并且这样写： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> prefix = <span class="hljs-string"><span class="hljs-string">'Hello '</span></span>; conferences .forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">someItem</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (someItem === <span class="hljs-string"><span class="hljs-string">'Frontend Conf'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = prefix + someItem; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) } });</code> </pre><br><br> 这是声明式和命令式样式的<strong>组合</strong> 。 没有可读性，没有完整的命令性，有些变量以及<code>if</code> 。  <code>if</code>有人添加，则是因为他根本不了解过滤器。 如果您是潜在客户并且看到这样的代码，请上前<s>用棍子</s>戳一下链接<s>，</s>然后将代码带到声明性代码中。 <br><br><h3> 创建变量 <br></h3><br> 不要为了变量而创建变量-这是一个坏主意。 当我从开发人员那里找出为什么要这样做时，我听到： <br><br>  -好吧，它增加了可读性！ <br><br> 什么增加了这里的可读性<code>const username = user.name</code> ？ 如果要创建变量，请给名称赋予含义。 例如，我们有一个正则表达式： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> somePattern = <span class="hljs-regexp"><span class="hljs-regexp">/[0-9]+/</span></span>; str.split(somePattern); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> someResult = a + b - c;</code> </pre><br> 在这里，我将创建一个变量，这样一个人就不会浪费时间在诉讼程序上，而是要阅读该常规文件以检查电话，然后走得更远。 如果您有数学运算，也要写一个变量，因为可以肯定的是，数学运算有一个业务实体，例如某个业务界标，可以计算篮子或打折。 在这种情况下，您可以创建一个变量。 <br><br><blockquote> 创建变量来创建变量是不值得的。 </blockquote><br><h3> 重新定义变量 <br></h3><br> 假设我们创建了一个<code>element</code>变量，但其名称尚不清楚。 我们写了一个DOM <code>element</code> ，出于某种原因在数组中写了它的覆盖，然后离开了： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'someId'</span></span>); arr.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... //      // ... element = document.getElementById('someItem') if (typeof item === 'string') { let element = document.getElementById('some' + item); element.appendChild(); } });</span></span></code> </pre><br> 一切都好，消失了，被遗忘了。 在我们团队工作的Petya之后，加入了<code>if</code>块。 怎么了 再次重新定义变量，然后离开。 而且范围已经不同。 当下一个开发人员尝试理解此代码时，尤其是如果方法很大时，它将等待<code>someId</code>或<code>someItem</code> ，而根本没有。 在这里，您可能会浪费大量时间来查找问题所在。 我们将编写一个<code>debugger</code> ，放一个<code>brake point</code> ，看看那里有什么-通常，不要那样写。 <br><br><h3> 分成方法 <br></h3><br> 我们简要地考虑了方法划分，并顺利地进行了抽象。 <br><br> 方法应该具有<strong>原子功能</strong> ： <strong>一种方法一行动</strong> 。 如果您有单行动作，则不要混用，只是因为方法太小。 该方法不应<strong>超过10行。</strong> 该声明激起了一个高潮，现在也“射击”，因此写信给我或在评论中，我将解释为什么我编写此规则。 <br><br><h3> 代码模块化 <br></h3><br> 模块化通过拆分成多个抽象<strong>来</strong> <strong>提高代码的可读性</strong> ， <strong>有助于“隐藏”难以阅读的代码，</strong> <strong>易于测试，</strong>并且易于<strong>修复错误</strong> 。 我将更详细地解释。 <br><br><h3> 隐藏在抽象背后 <br></h3><br> 例如，有一些代码创建一个按钮，为它分配一个ID，一个类并单击它-一切都很简单。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'button'</span></span>); element.id = <span class="hljs-string"><span class="hljs-string">'id_button'</span></span>; element.classList = <span class="hljs-string"><span class="hljs-string">'red'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(element); element.click();</code> </pre><br> 您可以在按钮代码中添加一个函数，包装它，并在创建按钮时使用<code>createButton</code>函数： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span>.button = createButton(<span class="hljs-string"><span class="hljs-string">'id_button'</span></span>); button.click(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">') { element = document.createElement('</span></span></span></span><span class="hljs-function"><span class="hljs-params">button</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'); element.id = id; element.classList = '</span></span></span></span><span class="hljs-function"><span class="hljs-params">red</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'; document.body.appendChild(element); return element; }</span></span></span></span></span></span></code> </pre><br> 通过“交谈”名称，可以清楚地知道函数的作用以及传递的ID。 如果我们想创建一个按钮而不了解它的创建方式和原因，则可以使用此函数编写代码。 <br><br><pre> <code class="javascript hljs">button.component.js <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> button = createButton(<span class="hljs-string"><span class="hljs-string">'id_button'</span></span>); button.click();</code> </pre><br> 接下来，我们编写<strong>helper</strong> ，稍后其他开发人员将使用它。 如果他们想了解炒鸡蛋的油炸方式或想改变食谱-添加或除去盐，它们将流连忘返。 <br><br><pre> <code class="javascript hljs">button.helpers.js <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createButton</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> button = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'button'</span></span>); button.id = id; button.classList = <span class="hljs-string"><span class="hljs-string">'red'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> button; }</code> </pre><br><h3> 打字 <br></h3><br> 我不会谈论打字很长时间了-有很多报告。 我喜欢用TypeScript编写，但是仍然有流程和其他工具。 如果您没有在项目中键入内容，那么是时候实施它了。 这有助于调试许多错误。 <br><br><h3> 代码气味 <br></h3><br> 代码的气味与我的主题非常相关，因为编写质量低下的代码会产生这种气味。 看看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Alexei Okhrimenko的精彩报告</a> ，他详细<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">谈到</a>了这个话题。 <br><br><h2> 代码风格 <br></h2><br> 这是开发人员遵循的一组团队，项目或公司的规则。 好的<strong>代码样式</strong>包含好的和坏的代码示例。 可以在任何方便的工具和地方编写它。 我们有这个Wiki，对于一家小型公司而言，Word中的文件就足够了。 您还可以采用现成的代码样式，该样式已被其他公司使用： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JQuery</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Google</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Airbnb-</a>最受欢迎的代码样式。 <br><br> 如果使用特定的技术或框架，它们通常也具有自己的代码样式，这值得一看。 例如，在Angular中，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Angular样式指南</a>或Airbnb的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React / JSX样式指南</a> 。 <br><br> 这是我们代码风格的一个例子。 <br><br><img src="https://habrastorage.org/webt/3q/2v/h0/3q2vh0awwujjwunmpkg3e7iqtfe.png"><br><br> 这是用于创建变量的部分，并描述了如何不执行以及如何执行。 <br><br><h2> 技术债务 <br></h2><br> 这是对我们曾经割过的地方的一种报偿。 当我们没有时间完成一项任务并写一个提醒以后再返回时，通常会产生技术债务。 在与业务功能无关的情况下，例如，这是更新框架。 <br><br><blockquote> 技术债务催生了拐杖和低质量的代码。 <br></blockquote><br> 由于技术欠债，我编写了错误的代码和拐杖。 下一位开发人员将一目了然，看到门框并添加另一个拐杖：“如果仍然有支持，那就没错。” 科技债务催生拐杖，质量下降，再次催生拐杖，它们使科技债务增加的更多。 <br><br> 有一种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“破窗”</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">理论</a> 。 如果破碎的窗户出现在建筑物中并且未更改，则过一会儿将出现第二个破碎的窗户，第三个是涂鸦。 人们看到没有人跟随建筑物，因此不应对破窗进行惩罚。 代码也是如此。 在旧项目中，代码经常被拐杖包围，因为有条件的Petit和Vasya看到拐杖并思考：“没关系，我将成为第一个。” 因此，在普通公司中，技术债务有足够的时间-他们可以通过配额或技术冲刺来解决问题。 如果您是领导者，或者以某种方式影响冲刺的过程以及要执行的任务列表，请注意技术债务-这很重要。 <br><br><h2> 资料库 <br></h2><br> 让我们讨论提交消息。 该图显示了我在不同项目中看到的真实消息的示例。 您认为其中哪几个能提供参考？ <br><br><img src="https://habrastorage.org/webt/q8/72/mj/q872mjvfvpr0ykuknmkekksni6m.png"><br><br><div class="spoiler">  <b class="spoiler_title">正确答案</b> <div class="spoiler_text"> 信息性消息呈块状显示，但“添加了功能”，“修复了错误”-没有提供信息。 <br></div></div><br><h3> 提交讯息 <br></h3><br> 我用<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebStorm</a></strong>编写并喜欢它。 在其中，您可以配置任务编号的突出显示，单击“任务跟踪器”时的过渡很酷。 如果某人不使用WebStorm，那么该是时候了，因为与他一起，可以获得高质量的提交消息。 什么是质量提交消息？ 这是一个提交，其中<strong>包含任务编号</strong>和简短但简洁<strong>的更改本质说明</strong> <strong>：</strong> “制作了一个新模块”，“添加了一个按钮”，“添加了用于创建组件的功能”，而不是一个不露面的“添加的功能”。 查看提交时，将很清楚在何处添加了组件以及在何处修复了错误。 即使在提交消息中，也必须指出<strong>更改</strong>的<strong>类型</strong> <strong>：</strong>功能，错误修正，以便清楚地知道更改发生的位置。 <br><br><h3>  Gitflow <br></h3><br> 我将简要介绍Gitflow。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文森特德森文章翻译的</a>详细说明。  Gitflow是最流行和非常成功的存储库管理模型之一，它具有<strong>主要分支</strong> -开发，主，预生产，生产和<strong>临时分支</strong> ：功能，错误，发行版。 当我们开始任务时，我们将特征分支从开发分支中转移出来。 在功能分支上通过代码审查后，我们将其重新投入开发。 最后，我们收集来自development的发行版和master发行版。 <br><br><img src="https://habrastorage.org/webt/e4/kk/3g/e4kk3g7gg9-wfqfl38ecmdfstvg.png"><br><br><h3> 工具 <br></h3><br> 首先是<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Commitizen</a></strong> 。 这是我不久前了解的软件实用程序-我看上去，感觉到，喜欢它。 它允许您标准化消息提交，具有一个不错的控制台界面，您可以在其中选择功能。 如果您本着“更正功能”或“修复错误”的精神进行工作，那么现在是时候向大家展示Commitizen，以便他们至少可以从头开始使用它，然后您可以从头开始编写它。 <br><br>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Linters</a></strong>是每个项目中的必备工具。  linter中有许多现成的配置，但是您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编写自己的规则</a> 。 如果您有自己的规则，则短绒棉绒应该将这些规则放短-您将需要为您的代码样式编写规则。 <br> 关于linter的有用链接： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/dustinspecker/awesome-eslint</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">eslint.org</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/reid/node-jslint</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">palantir.github.io/tslint/</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> </li></ul><br> 一个单独的段落分配了<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sonarJS</a> 。</strong> 这是一个允许您将代码验证集成到CI中的工具。 例如，我们发出请求，然后sonarJS编写请求以询问关于我们学校的请求，无论是否感到沮丧。 这很酷-我喜欢它。 即使有条件的Vasya认为没有人会注意到他的伪善-他也会注意到sonarJS。 <br><br> 该工具可以轻松集成到Jenkins中。 我们的家伙内置速度足够快。 它很可能集成到其他系统中，但我们尚未尝试过。  SonarJS仍在检查代码中的代码味道。 老实说，我不知道普通棉短绒是否会这样做。 <br><br>  <strong>格式化程序或</strong>样式<strong>师</strong>是根据配置（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Prettier）</a>格式化代码的工具。 您可以将其配置为<strong>pre-push hook</strong> ，并在存储库中获得统一的代码样式。 我们团队的Petya可以放置500个空间，或者根本不写分号-储存库中的所有内容都会干净整洁。 <br><br><blockquote> 格式化程序使您可以将代码保持单一样式。 <br></blockquote><br> 我想讲一个发生在我们身上的故事。 我们在编写了很多任务的项目中实现了Prettier，因此决定不通过它来运行整个项目，而只运行具有功能的代码段。 在我们看来，逐渐地，我们会出来并且不会破坏提交的历史：在注释中，我们将看到谁最后统治。 那是一个错误的决定。 当我们完成任务和请求请求并更改了几行后，Prettier格式化了整个文件，而当我们观看请求请求时，只有两行！ 这花费了大量的代码审查时间。 因此， <strong>如果要实施Prettier，请运行整个项目</strong> 。 <br><br> 还有另一个工具-运行时<strong>错误跟踪</strong> 。 ,     ,    .  -       —    . Error tracking     DOM-,  ,        .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sentry</a> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TrackJS</a>   ,    . <br><br>      Sentry,  . 怎么了   ,   Sentry.   . <br><br><img src="https://habrastorage.org/webt/zi/wx/ua/ziwxuafsfcoonphdjgxesammrxu.jpeg"><br>   . <br><br><img src="https://habrastorage.org/webt/hh/7q/cc/hh7qccwp1liaxrjlvblcyktusry.jpeg"><br>     , ,    : «,    iOS,  ,     ,   Android  — ,    iOS». <br><br>  Sentry  <strong>StackTrace</strong> —   ,  . <br><br><img src="https://habrastorage.org/webt/qy/um/vc/qyumvcgz6gerwfs9u0bwrnaudeu.jpeg"><br>    Sentry.      ,    —  :   .     ,  ,   : «   ,     ?».  —  .       ,    .   ,      —  «»       . <br><br><h2> - <br></h2><br> -   ,    . <br><br><ul><li>       . </li><li>    —  . </li><li>     . </li><li>   .   ,     frontend-developer  Tinkoff.ru. </li><li>   Code style,    .   —  . </li><li>    —   .   ,   ,     . </li><li>  Git Flow —   ,   .         —  . </li><li>   — , .     ,     . </li></ul><br>       <strong> </strong> .   « » ,          —      ,      .      .       ,   ,      ,   .   ,    ,    . <br><br>    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Twitter</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Facebook</a> . <br><br><blockquote>   —     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Frontend Conf</a> . ?   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Frontend Conf ++</a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  </a> :  , ,       . <br><br>        —    FrontendConf ++.      — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> ,       . ,    27  </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433326/">https://habr.com/ru/post/zh-CN433326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433316/index.html">设计摘要：入职，反馈，搜索想法和决策</a></li>
<li><a href="../zh-CN433318/index.html">垃圾收集（）</a></li>
<li><a href="../zh-CN433320/index.html">网格布局是现代布局的基础</a></li>
<li><a href="../zh-CN433322/index.html">JSON API-我们根据规范进行工作</a></li>
<li><a href="../zh-CN433324/index.html">使用Webpack收集梦想</a></li>
<li><a href="../zh-CN433328/index.html">最好输掉一天</a></li>
<li><a href="../zh-CN433330/index.html">使用SAT解算器解决日语填字游戏</a></li>
<li><a href="../zh-CN433332/index.html">Azure Functions中的Python支持</a></li>
<li><a href="../zh-CN433334/index.html">WPF的XAML行为现已开放源代码</a></li>
<li><a href="../zh-CN433336/index.html">巴比伦图书馆的实施</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>